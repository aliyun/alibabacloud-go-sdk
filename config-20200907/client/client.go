// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type ResourceDirectoryFolderNode struct {
	AccountId      *string                        `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	Children       []*ResourceDirectoryFolderNode `json:"Children,omitempty" xml:"Children,omitempty" type:"Repeated"`
	DisplayName    *string                        `json:"DisplayName,omitempty" xml:"DisplayName,omitempty"`
	FolderId       *string                        `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	FolderName     *string                        `json:"FolderName,omitempty" xml:"FolderName,omitempty"`
	ParentFolderId *string                        `json:"ParentFolderId,omitempty" xml:"ParentFolderId,omitempty"`
}

func (s ResourceDirectoryFolderNode) String() string {
	return tea.Prettify(s)
}

func (s ResourceDirectoryFolderNode) GoString() string {
	return s.String()
}

func (s *ResourceDirectoryFolderNode) SetAccountId(v string) *ResourceDirectoryFolderNode {
	s.AccountId = &v
	return s
}

func (s *ResourceDirectoryFolderNode) SetChildren(v []*ResourceDirectoryFolderNode) *ResourceDirectoryFolderNode {
	s.Children = v
	return s
}

func (s *ResourceDirectoryFolderNode) SetDisplayName(v string) *ResourceDirectoryFolderNode {
	s.DisplayName = &v
	return s
}

func (s *ResourceDirectoryFolderNode) SetFolderId(v string) *ResourceDirectoryFolderNode {
	s.FolderId = &v
	return s
}

func (s *ResourceDirectoryFolderNode) SetFolderName(v string) *ResourceDirectoryFolderNode {
	s.FolderName = &v
	return s
}

func (s *ResourceDirectoryFolderNode) SetParentFolderId(v string) *ResourceDirectoryFolderNode {
	s.ParentFolderId = &v
	return s
}

type ActiveAggregateConfigRulesRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The rule ID. Separate multiple rule IDs with commas (,).
	//
	// For more information about how to obtain the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s ActiveAggregateConfigRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ActiveAggregateConfigRulesRequest) GoString() string {
	return s.String()
}

func (s *ActiveAggregateConfigRulesRequest) SetAggregatorId(v string) *ActiveAggregateConfigRulesRequest {
	s.AggregatorId = &v
	return s
}

func (s *ActiveAggregateConfigRulesRequest) SetConfigRuleIds(v string) *ActiveAggregateConfigRulesRequest {
	s.ConfigRuleIds = &v
	return s
}

type ActiveAggregateConfigRulesResponseBody struct {
	// The returned result.
	OperateRuleResult *ActiveAggregateConfigRulesResponseBodyOperateRuleResult `json:"OperateRuleResult,omitempty" xml:"OperateRuleResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ActiveAggregateConfigRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ActiveAggregateConfigRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ActiveAggregateConfigRulesResponseBody) SetOperateRuleResult(v *ActiveAggregateConfigRulesResponseBodyOperateRuleResult) *ActiveAggregateConfigRulesResponseBody {
	s.OperateRuleResult = v
	return s
}

func (s *ActiveAggregateConfigRulesResponseBody) SetRequestId(v string) *ActiveAggregateConfigRulesResponseBody {
	s.RequestId = &v
	return s
}

type ActiveAggregateConfigRulesResponseBodyOperateRuleResult struct {
	// The returned result.
	OperateRuleItemList []*ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList `json:"OperateRuleItemList,omitempty" xml:"OperateRuleItemList,omitempty" type:"Repeated"`
}

func (s ActiveAggregateConfigRulesResponseBodyOperateRuleResult) String() string {
	return tea.Prettify(s)
}

func (s ActiveAggregateConfigRulesResponseBodyOperateRuleResult) GoString() string {
	return s.String()
}

func (s *ActiveAggregateConfigRulesResponseBodyOperateRuleResult) SetOperateRuleItemList(v []*ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) *ActiveAggregateConfigRulesResponseBodyOperateRuleResult {
	s.OperateRuleItemList = v
	return s
}

type ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList struct {
	// The rule ID.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The error code returned.
	//
	// *   If the rule is enabled, no error code is returned.
	// *   If the rule fails to be enabled, an error code is returned. For more information about error codes, see [Error codes](https://error-center.alibabacloud.com/status/product/Config).
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) String() string {
	return tea.Prettify(s)
}

func (s ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) GoString() string {
	return s.String()
}

func (s *ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetConfigRuleId(v string) *ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.ConfigRuleId = &v
	return s
}

func (s *ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetErrorCode(v string) *ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.ErrorCode = &v
	return s
}

func (s *ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetSuccess(v bool) *ActiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.Success = &v
	return s
}

type ActiveAggregateConfigRulesResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ActiveAggregateConfigRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ActiveAggregateConfigRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ActiveAggregateConfigRulesResponse) GoString() string {
	return s.String()
}

func (s *ActiveAggregateConfigRulesResponse) SetHeaders(v map[string]*string) *ActiveAggregateConfigRulesResponse {
	s.Headers = v
	return s
}

func (s *ActiveAggregateConfigRulesResponse) SetStatusCode(v int32) *ActiveAggregateConfigRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ActiveAggregateConfigRulesResponse) SetBody(v *ActiveAggregateConfigRulesResponseBody) *ActiveAggregateConfigRulesResponse {
	s.Body = v
	return s
}

type ActiveConfigRulesRequest struct {
	// The rule IDs. Separate multiple rule IDs with commas (,). You can specify a maximum of 20 rule IDs at a time.
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s ActiveConfigRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ActiveConfigRulesRequest) GoString() string {
	return s.String()
}

func (s *ActiveConfigRulesRequest) SetConfigRuleIds(v string) *ActiveConfigRulesRequest {
	s.ConfigRuleIds = &v
	return s
}

type ActiveConfigRulesResponseBody struct {
	// The result information about the operation.
	OperateRuleResult *ActiveConfigRulesResponseBodyOperateRuleResult `json:"OperateRuleResult,omitempty" xml:"OperateRuleResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ActiveConfigRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ActiveConfigRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ActiveConfigRulesResponseBody) SetOperateRuleResult(v *ActiveConfigRulesResponseBodyOperateRuleResult) *ActiveConfigRulesResponseBody {
	s.OperateRuleResult = v
	return s
}

func (s *ActiveConfigRulesResponseBody) SetRequestId(v string) *ActiveConfigRulesResponseBody {
	s.RequestId = &v
	return s
}

type ActiveConfigRulesResponseBodyOperateRuleResult struct {
	// The result information about the operation.
	OperateRuleItemList []*ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList `json:"OperateRuleItemList,omitempty" xml:"OperateRuleItemList,omitempty" type:"Repeated"`
}

func (s ActiveConfigRulesResponseBodyOperateRuleResult) String() string {
	return tea.Prettify(s)
}

func (s ActiveConfigRulesResponseBodyOperateRuleResult) GoString() string {
	return s.String()
}

func (s *ActiveConfigRulesResponseBodyOperateRuleResult) SetOperateRuleItemList(v []*ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) *ActiveConfigRulesResponseBodyOperateRuleResult {
	s.OperateRuleItemList = v
	return s
}

type ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList struct {
	// The rule ID.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The error code returned if the request failed.
	//
	// *   If the rule is enabled, no error code is returned.
	// *   If the rule fails to be enabled, an error code is returned. For more information about error codes, see [Error codes](https://next.api.aliyun.com/document/Config/2020-09-07/errorCode).
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the rule is enabled. Valid values:
	//
	// *   true
	// *   false
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) String() string {
	return tea.Prettify(s)
}

func (s ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) GoString() string {
	return s.String()
}

func (s *ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetConfigRuleId(v string) *ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.ConfigRuleId = &v
	return s
}

func (s *ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetErrorCode(v string) *ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.ErrorCode = &v
	return s
}

func (s *ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetSuccess(v bool) *ActiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.Success = &v
	return s
}

type ActiveConfigRulesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ActiveConfigRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ActiveConfigRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ActiveConfigRulesResponse) GoString() string {
	return s.String()
}

func (s *ActiveConfigRulesResponse) SetHeaders(v map[string]*string) *ActiveConfigRulesResponse {
	s.Headers = v
	return s
}

func (s *ActiveConfigRulesResponse) SetStatusCode(v int32) *ActiveConfigRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ActiveConfigRulesResponse) SetBody(v *ActiveConfigRulesResponseBody) *ActiveConfigRulesResponse {
	s.Body = v
	return s
}

type AttachAggregateConfigRuleToCompliancePackRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the compliance package to which you want to add the rule.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListAggregateCompliancePacks](~~262059~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The ID of the rule to be added to the compliance package. Separate multiple rule IDs with commas (,).
	//
	// For more information about how to obtain the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s AttachAggregateConfigRuleToCompliancePackRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachAggregateConfigRuleToCompliancePackRequest) GoString() string {
	return s.String()
}

func (s *AttachAggregateConfigRuleToCompliancePackRequest) SetAggregatorId(v string) *AttachAggregateConfigRuleToCompliancePackRequest {
	s.AggregatorId = &v
	return s
}

func (s *AttachAggregateConfigRuleToCompliancePackRequest) SetCompliancePackId(v string) *AttachAggregateConfigRuleToCompliancePackRequest {
	s.CompliancePackId = &v
	return s
}

func (s *AttachAggregateConfigRuleToCompliancePackRequest) SetConfigRuleIds(v string) *AttachAggregateConfigRuleToCompliancePackRequest {
	s.ConfigRuleIds = &v
	return s
}

type AttachAggregateConfigRuleToCompliancePackResponseBody struct {
	// The results of the operations to add one or more rules.
	OperateRuleResult *AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult `json:"OperateRuleResult,omitempty" xml:"OperateRuleResult,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachAggregateConfigRuleToCompliancePackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachAggregateConfigRuleToCompliancePackResponseBody) GoString() string {
	return s.String()
}

func (s *AttachAggregateConfigRuleToCompliancePackResponseBody) SetOperateRuleResult(v *AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult) *AttachAggregateConfigRuleToCompliancePackResponseBody {
	s.OperateRuleResult = v
	return s
}

func (s *AttachAggregateConfigRuleToCompliancePackResponseBody) SetRequestId(v string) *AttachAggregateConfigRuleToCompliancePackResponseBody {
	s.RequestId = &v
	return s
}

type AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult struct {
	// The result of the operation to add the rule.
	OperateRuleItemList []*AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList `json:"OperateRuleItemList,omitempty" xml:"OperateRuleItemList,omitempty" type:"Repeated"`
}

func (s AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult) String() string {
	return tea.Prettify(s)
}

func (s AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult) GoString() string {
	return s.String()
}

func (s *AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult) SetOperateRuleItemList(v []*AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) *AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult {
	s.OperateRuleItemList = v
	return s
}

type AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList struct {
	// The ID of the rule that is added to the compliance package.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The error code.
	//
	// *   This parameter is empty if the rule is added to the compliance package.
	//
	// <!---->
	//
	// *   An error code is returned if the rule fails to be added to the compliance package. For more information about error codes, visit the [API Error Center](https://error-center.alibabacloud.com/status/product/Config).
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the operation is successful. Valid values:
	//
	// *   true: The operation is successful.
	// *   false: The operation fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) String() string {
	return tea.Prettify(s)
}

func (s AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) GoString() string {
	return s.String()
}

func (s *AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) SetConfigRuleId(v string) *AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList {
	s.ConfigRuleId = &v
	return s
}

func (s *AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) SetErrorCode(v string) *AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList {
	s.ErrorCode = &v
	return s
}

func (s *AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) SetSuccess(v bool) *AttachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList {
	s.Success = &v
	return s
}

type AttachAggregateConfigRuleToCompliancePackResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachAggregateConfigRuleToCompliancePackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachAggregateConfigRuleToCompliancePackResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachAggregateConfigRuleToCompliancePackResponse) GoString() string {
	return s.String()
}

func (s *AttachAggregateConfigRuleToCompliancePackResponse) SetHeaders(v map[string]*string) *AttachAggregateConfigRuleToCompliancePackResponse {
	s.Headers = v
	return s
}

func (s *AttachAggregateConfigRuleToCompliancePackResponse) SetStatusCode(v int32) *AttachAggregateConfigRuleToCompliancePackResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachAggregateConfigRuleToCompliancePackResponse) SetBody(v *AttachAggregateConfigRuleToCompliancePackResponseBody) *AttachAggregateConfigRuleToCompliancePackResponse {
	s.Body = v
	return s
}

type AttachConfigRuleToCompliancePackRequest struct {
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListCompliancePacks](~~263332~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The rule ID. Separate multiple rule IDs with commas (,).
	//
	// For more information about how to obtain the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s AttachConfigRuleToCompliancePackRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachConfigRuleToCompliancePackRequest) GoString() string {
	return s.String()
}

func (s *AttachConfigRuleToCompliancePackRequest) SetCompliancePackId(v string) *AttachConfigRuleToCompliancePackRequest {
	s.CompliancePackId = &v
	return s
}

func (s *AttachConfigRuleToCompliancePackRequest) SetConfigRuleIds(v string) *AttachConfigRuleToCompliancePackRequest {
	s.ConfigRuleIds = &v
	return s
}

type AttachConfigRuleToCompliancePackResponseBody struct {
	// The results of the operations to add one or more rules.
	OperateRuleResult *AttachConfigRuleToCompliancePackResponseBodyOperateRuleResult `json:"OperateRuleResult,omitempty" xml:"OperateRuleResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachConfigRuleToCompliancePackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachConfigRuleToCompliancePackResponseBody) GoString() string {
	return s.String()
}

func (s *AttachConfigRuleToCompliancePackResponseBody) SetOperateRuleResult(v *AttachConfigRuleToCompliancePackResponseBodyOperateRuleResult) *AttachConfigRuleToCompliancePackResponseBody {
	s.OperateRuleResult = v
	return s
}

func (s *AttachConfigRuleToCompliancePackResponseBody) SetRequestId(v string) *AttachConfigRuleToCompliancePackResponseBody {
	s.RequestId = &v
	return s
}

type AttachConfigRuleToCompliancePackResponseBodyOperateRuleResult struct {
	// The result of the operation to add the rule.
	OperateRuleItemList []*AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList `json:"OperateRuleItemList,omitempty" xml:"OperateRuleItemList,omitempty" type:"Repeated"`
}

func (s AttachConfigRuleToCompliancePackResponseBodyOperateRuleResult) String() string {
	return tea.Prettify(s)
}

func (s AttachConfigRuleToCompliancePackResponseBodyOperateRuleResult) GoString() string {
	return s.String()
}

func (s *AttachConfigRuleToCompliancePackResponseBodyOperateRuleResult) SetOperateRuleItemList(v []*AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) *AttachConfigRuleToCompliancePackResponseBodyOperateRuleResult {
	s.OperateRuleItemList = v
	return s
}

type AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList struct {
	// The rule ID.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The error code returned.
	//
	// *   This parameter is empty if the rule is added to the compliance package.
	// *   An error code is returned if the rule fails to be added to the compliance package. For more information about error codes, see [Error codes](https://error-center.alibabacloud.com/status/product/Config).
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) String() string {
	return tea.Prettify(s)
}

func (s AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) GoString() string {
	return s.String()
}

func (s *AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) SetConfigRuleId(v string) *AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList {
	s.ConfigRuleId = &v
	return s
}

func (s *AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) SetErrorCode(v string) *AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList {
	s.ErrorCode = &v
	return s
}

func (s *AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) SetSuccess(v bool) *AttachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList {
	s.Success = &v
	return s
}

type AttachConfigRuleToCompliancePackResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachConfigRuleToCompliancePackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachConfigRuleToCompliancePackResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachConfigRuleToCompliancePackResponse) GoString() string {
	return s.String()
}

func (s *AttachConfigRuleToCompliancePackResponse) SetHeaders(v map[string]*string) *AttachConfigRuleToCompliancePackResponse {
	s.Headers = v
	return s
}

func (s *AttachConfigRuleToCompliancePackResponse) SetStatusCode(v int32) *AttachConfigRuleToCompliancePackResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachConfigRuleToCompliancePackResponse) SetBody(v *AttachConfigRuleToCompliancePackResponseBody) *AttachConfigRuleToCompliancePackResponse {
	s.Body = v
	return s
}

type CopyCompliancePacksRequest struct {
	// The IDs of the destination account groups into which the compliance packages are replicated. Separate multiple account group IDs with commas (,).
	//
	// > If this parameter is left empty, the compliance packages are replicated to the current account group.
	DesAggregatorIds *string `json:"DesAggregatorIds,omitempty" xml:"DesAggregatorIds,omitempty"`
	// The ID of the account group to which the compliance packages belong.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	SrcAggregatorId *string `json:"SrcAggregatorId,omitempty" xml:"SrcAggregatorId,omitempty"`
	// The IDs of the compliance packages. Separate multiple compliance package IDs with commas (,).
	//
	// For more information about how to obtain the ID of a compliance package, see [ListCompliancePacks](~~263332~~).
	SrcCompliancePackIds *string `json:"SrcCompliancePackIds,omitempty" xml:"SrcCompliancePackIds,omitempty"`
}

func (s CopyCompliancePacksRequest) String() string {
	return tea.Prettify(s)
}

func (s CopyCompliancePacksRequest) GoString() string {
	return s.String()
}

func (s *CopyCompliancePacksRequest) SetDesAggregatorIds(v string) *CopyCompliancePacksRequest {
	s.DesAggregatorIds = &v
	return s
}

func (s *CopyCompliancePacksRequest) SetSrcAggregatorId(v string) *CopyCompliancePacksRequest {
	s.SrcAggregatorId = &v
	return s
}

func (s *CopyCompliancePacksRequest) SetSrcCompliancePackIds(v string) *CopyCompliancePacksRequest {
	s.SrcCompliancePackIds = &v
	return s
}

type CopyCompliancePacksResponseBody struct {
	// Indicates whether the compliance packages are replicated. Valid values:
	//
	// *   true
	// *   false
	CopyRulesResult *bool `json:"CopyRulesResult,omitempty" xml:"CopyRulesResult,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CopyCompliancePacksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CopyCompliancePacksResponseBody) GoString() string {
	return s.String()
}

func (s *CopyCompliancePacksResponseBody) SetCopyRulesResult(v bool) *CopyCompliancePacksResponseBody {
	s.CopyRulesResult = &v
	return s
}

func (s *CopyCompliancePacksResponseBody) SetRequestId(v string) *CopyCompliancePacksResponseBody {
	s.RequestId = &v
	return s
}

type CopyCompliancePacksResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CopyCompliancePacksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CopyCompliancePacksResponse) String() string {
	return tea.Prettify(s)
}

func (s CopyCompliancePacksResponse) GoString() string {
	return s.String()
}

func (s *CopyCompliancePacksResponse) SetHeaders(v map[string]*string) *CopyCompliancePacksResponse {
	s.Headers = v
	return s
}

func (s *CopyCompliancePacksResponse) SetStatusCode(v int32) *CopyCompliancePacksResponse {
	s.StatusCode = &v
	return s
}

func (s *CopyCompliancePacksResponse) SetBody(v *CopyCompliancePacksResponseBody) *CopyCompliancePacksResponse {
	s.Body = v
	return s
}

type CopyConfigRulesRequest struct {
	// The IDs of the destination account groups into which the rules are replicated. Separate multiple account group IDs with commas (,).
	//
	// > If you leave this parameter empty, the compliance packages are replicated into the same account group.
	DesAggregatorIds *string `json:"DesAggregatorIds,omitempty" xml:"DesAggregatorIds,omitempty"`
	// The ID of the account group to which the rules belong.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	SrcAggregatorId *string `json:"SrcAggregatorId,omitempty" xml:"SrcAggregatorId,omitempty"`
	// The rule IDs. Separate multiple rule IDs with commas (,).
	SrcConfigRuleIds *string `json:"SrcConfigRuleIds,omitempty" xml:"SrcConfigRuleIds,omitempty"`
}

func (s CopyConfigRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s CopyConfigRulesRequest) GoString() string {
	return s.String()
}

func (s *CopyConfigRulesRequest) SetDesAggregatorIds(v string) *CopyConfigRulesRequest {
	s.DesAggregatorIds = &v
	return s
}

func (s *CopyConfigRulesRequest) SetSrcAggregatorId(v string) *CopyConfigRulesRequest {
	s.SrcAggregatorId = &v
	return s
}

func (s *CopyConfigRulesRequest) SetSrcConfigRuleIds(v string) *CopyConfigRulesRequest {
	s.SrcConfigRuleIds = &v
	return s
}

type CopyConfigRulesResponseBody struct {
	// Indicates whether the rules are replicated. Valid values:
	//
	// *   true
	// *   false
	CopyRulesResult *bool `json:"CopyRulesResult,omitempty" xml:"CopyRulesResult,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CopyConfigRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CopyConfigRulesResponseBody) GoString() string {
	return s.String()
}

func (s *CopyConfigRulesResponseBody) SetCopyRulesResult(v bool) *CopyConfigRulesResponseBody {
	s.CopyRulesResult = &v
	return s
}

func (s *CopyConfigRulesResponseBody) SetRequestId(v string) *CopyConfigRulesResponseBody {
	s.RequestId = &v
	return s
}

type CopyConfigRulesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CopyConfigRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CopyConfigRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s CopyConfigRulesResponse) GoString() string {
	return s.String()
}

func (s *CopyConfigRulesResponse) SetHeaders(v map[string]*string) *CopyConfigRulesResponse {
	s.Headers = v
	return s
}

func (s *CopyConfigRulesResponse) SetStatusCode(v int32) *CopyConfigRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *CopyConfigRulesResponse) SetBody(v *CopyConfigRulesResponseBody) *CopyConfigRulesResponse {
	s.Body = v
	return s
}

type CreateAdvancedSearchFileRequest struct {
	Sql *string `json:"Sql,omitempty" xml:"Sql,omitempty"`
}

func (s CreateAdvancedSearchFileRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAdvancedSearchFileRequest) GoString() string {
	return s.String()
}

func (s *CreateAdvancedSearchFileRequest) SetSql(v string) *CreateAdvancedSearchFileRequest {
	s.Sql = &v
	return s
}

type CreateAdvancedSearchFileResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAdvancedSearchFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAdvancedSearchFileResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAdvancedSearchFileResponseBody) SetRequestId(v string) *CreateAdvancedSearchFileResponseBody {
	s.RequestId = &v
	return s
}

type CreateAdvancedSearchFileResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAdvancedSearchFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAdvancedSearchFileResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAdvancedSearchFileResponse) GoString() string {
	return s.String()
}

func (s *CreateAdvancedSearchFileResponse) SetHeaders(v map[string]*string) *CreateAdvancedSearchFileResponse {
	s.Headers = v
	return s
}

func (s *CreateAdvancedSearchFileResponse) SetStatusCode(v int32) *CreateAdvancedSearchFileResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAdvancedSearchFileResponse) SetBody(v *CreateAdvancedSearchFileResponseBody) *CreateAdvancedSearchFileResponse {
	s.Body = v
	return s
}

type CreateAggregateAdvancedSearchFileRequest struct {
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	Sql          *string `json:"Sql,omitempty" xml:"Sql,omitempty"`
}

func (s CreateAggregateAdvancedSearchFileRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateAdvancedSearchFileRequest) GoString() string {
	return s.String()
}

func (s *CreateAggregateAdvancedSearchFileRequest) SetAggregatorId(v string) *CreateAggregateAdvancedSearchFileRequest {
	s.AggregatorId = &v
	return s
}

func (s *CreateAggregateAdvancedSearchFileRequest) SetSql(v string) *CreateAggregateAdvancedSearchFileRequest {
	s.Sql = &v
	return s
}

type CreateAggregateAdvancedSearchFileResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAggregateAdvancedSearchFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateAdvancedSearchFileResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAggregateAdvancedSearchFileResponseBody) SetRequestId(v string) *CreateAggregateAdvancedSearchFileResponseBody {
	s.RequestId = &v
	return s
}

type CreateAggregateAdvancedSearchFileResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAggregateAdvancedSearchFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAggregateAdvancedSearchFileResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateAdvancedSearchFileResponse) GoString() string {
	return s.String()
}

func (s *CreateAggregateAdvancedSearchFileResponse) SetHeaders(v map[string]*string) *CreateAggregateAdvancedSearchFileResponse {
	s.Headers = v
	return s
}

func (s *CreateAggregateAdvancedSearchFileResponse) SetStatusCode(v int32) *CreateAggregateAdvancedSearchFileResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAggregateAdvancedSearchFileResponse) SetBody(v *CreateAggregateAdvancedSearchFileResponseBody) *CreateAggregateAdvancedSearchFileResponse {
	s.Body = v
	return s
}

type CreateAggregateCompliancePackRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The client token that you want to use to ensure the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.``
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The name of the compliance package.
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
	// The ID of the compliance package template.
	//
	// For more information about how to obtain the ID of a compliance package template, see [ListCompliancePackTemplates](~~261176~~).
	CompliancePackTemplateId *string `json:"CompliancePackTemplateId,omitempty" xml:"CompliancePackTemplateId,omitempty"`
	// The rules in the compliance package.
	ConfigRules []*CreateAggregateCompliancePackRequestConfigRules `json:"ConfigRules,omitempty" xml:"ConfigRules,omitempty" type:"Repeated"`
	// Specifies whether to enable the rule together with the compliance package. Valid values:
	//
	// *   true: The system enables the rule together with the compliance package.
	// *   false: The system does not enable the rule together with the compliance package.
	DefaultEnable *bool `json:"DefaultEnable,omitempty" xml:"DefaultEnable,omitempty"`
	// The description of the compliance package.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the resource that you do not want to evaluate by using the compliance package. Separate multiple resource IDs with commas (,).
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The ID of the region whose resources you want to evaluate by using the compliance package. Separate multiple region IDs with commas (,).
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group whose resources you want to evaluate by using the compliance package. Separate multiple resource group IDs with commas (,).
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The risk level of the resources that are not compliant with the rules in the compliance package. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The tag key of the resource that you want to evaluate by using the compliance package.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value of the resource that you want to evaluate by using the compliance package.
	//
	// >  You must configure the TagValueScope parameter together with the TagKeyScope parameter.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s CreateAggregateCompliancePackRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateCompliancePackRequest) GoString() string {
	return s.String()
}

func (s *CreateAggregateCompliancePackRequest) SetAggregatorId(v string) *CreateAggregateCompliancePackRequest {
	s.AggregatorId = &v
	return s
}

func (s *CreateAggregateCompliancePackRequest) SetClientToken(v string) *CreateAggregateCompliancePackRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateAggregateCompliancePackRequest) SetCompliancePackName(v string) *CreateAggregateCompliancePackRequest {
	s.CompliancePackName = &v
	return s
}

func (s *CreateAggregateCompliancePackRequest) SetCompliancePackTemplateId(v string) *CreateAggregateCompliancePackRequest {
	s.CompliancePackTemplateId = &v
	return s
}

func (s *CreateAggregateCompliancePackRequest) SetConfigRules(v []*CreateAggregateCompliancePackRequestConfigRules) *CreateAggregateCompliancePackRequest {
	s.ConfigRules = v
	return s
}

func (s *CreateAggregateCompliancePackRequest) SetDefaultEnable(v bool) *CreateAggregateCompliancePackRequest {
	s.DefaultEnable = &v
	return s
}

func (s *CreateAggregateCompliancePackRequest) SetDescription(v string) *CreateAggregateCompliancePackRequest {
	s.Description = &v
	return s
}

func (s *CreateAggregateCompliancePackRequest) SetExcludeResourceIdsScope(v string) *CreateAggregateCompliancePackRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *CreateAggregateCompliancePackRequest) SetRegionIdsScope(v string) *CreateAggregateCompliancePackRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *CreateAggregateCompliancePackRequest) SetResourceGroupIdsScope(v string) *CreateAggregateCompliancePackRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *CreateAggregateCompliancePackRequest) SetRiskLevel(v int32) *CreateAggregateCompliancePackRequest {
	s.RiskLevel = &v
	return s
}

func (s *CreateAggregateCompliancePackRequest) SetTagKeyScope(v string) *CreateAggregateCompliancePackRequest {
	s.TagKeyScope = &v
	return s
}

func (s *CreateAggregateCompliancePackRequest) SetTagValueScope(v string) *CreateAggregateCompliancePackRequest {
	s.TagValueScope = &v
	return s
}

type CreateAggregateCompliancePackRequestConfigRules struct {
	// The ID of the rule. If you configure this parameter, Cloud Config adds the rule of the specified ID to the compliance package.
	//
	// You only need to configure the `ManagedRuleIdentifier` or `ConfigRuleId` parameter. If you configure both parameters, the value of the `ConfigRuleId` parameter takes precedence. For more information about how to obtain the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The details of the input parameter of the rule.
	ConfigRuleParameters []*CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters `json:"ConfigRuleParameters,omitempty" xml:"ConfigRuleParameters,omitempty" type:"Repeated"`
	// The description of the rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the managed rule. Cloud Config automatically create a managed rule of the specified ID and adds the rule to the compliance package.
	//
	// You only need to configure the `ManagedRuleIdentifier` or `ConfigRuleId` parameter. If you configure both parameters, the value of the `ConfigRuleId` parameter take precedence. For more information about how to obtain the identifier of a managed rule, see [ListCompliancePackTemplates](~~261176~~).
	ManagedRuleIdentifier *string `json:"ManagedRuleIdentifier,omitempty" xml:"ManagedRuleIdentifier,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s CreateAggregateCompliancePackRequestConfigRules) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateCompliancePackRequestConfigRules) GoString() string {
	return s.String()
}

func (s *CreateAggregateCompliancePackRequestConfigRules) SetConfigRuleId(v string) *CreateAggregateCompliancePackRequestConfigRules {
	s.ConfigRuleId = &v
	return s
}

func (s *CreateAggregateCompliancePackRequestConfigRules) SetConfigRuleName(v string) *CreateAggregateCompliancePackRequestConfigRules {
	s.ConfigRuleName = &v
	return s
}

func (s *CreateAggregateCompliancePackRequestConfigRules) SetConfigRuleParameters(v []*CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters) *CreateAggregateCompliancePackRequestConfigRules {
	s.ConfigRuleParameters = v
	return s
}

func (s *CreateAggregateCompliancePackRequestConfigRules) SetDescription(v string) *CreateAggregateCompliancePackRequestConfigRules {
	s.Description = &v
	return s
}

func (s *CreateAggregateCompliancePackRequestConfigRules) SetManagedRuleIdentifier(v string) *CreateAggregateCompliancePackRequestConfigRules {
	s.ManagedRuleIdentifier = &v
	return s
}

func (s *CreateAggregateCompliancePackRequestConfigRules) SetRiskLevel(v int32) *CreateAggregateCompliancePackRequestConfigRules {
	s.RiskLevel = &v
	return s
}

type CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters struct {
	// The name of the input parameter.
	//
	// You must configure the `ParameterName` and `ParameterValue` parameters or neither of them. If the managed rule has an input parameter but no default value exists, you must configure this parameter. For more information about how to obtain the name of an input parameter for a managed rule, see [ListCompliancePackTemplates](~~261176~~).
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The value of the input parameter.
	//
	// You must configure the `ParameterName` and `ParameterValue` parameters or neither of them. If the managed rule has an input parameter but no default value exists, you must configure this parameter. For more information about how to obtain the value of an input parameter for a managed rule, see [ListCompliancePackTemplates](~~261176~~).
	ParameterValue *string `json:"ParameterValue,omitempty" xml:"ParameterValue,omitempty"`
}

func (s CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters) GoString() string {
	return s.String()
}

func (s *CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters) SetParameterName(v string) *CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters {
	s.ParameterName = &v
	return s
}

func (s *CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters) SetParameterValue(v string) *CreateAggregateCompliancePackRequestConfigRulesConfigRuleParameters {
	s.ParameterValue = &v
	return s
}

type CreateAggregateCompliancePackShrinkRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The client token that you want to use to ensure the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.``
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The name of the compliance package.
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
	// The ID of the compliance package template.
	//
	// For more information about how to obtain the ID of a compliance package template, see [ListCompliancePackTemplates](~~261176~~).
	CompliancePackTemplateId *string `json:"CompliancePackTemplateId,omitempty" xml:"CompliancePackTemplateId,omitempty"`
	// The rules in the compliance package.
	ConfigRulesShrink *string `json:"ConfigRules,omitempty" xml:"ConfigRules,omitempty"`
	// Specifies whether to enable the rule together with the compliance package. Valid values:
	//
	// *   true: The system enables the rule together with the compliance package.
	// *   false: The system does not enable the rule together with the compliance package.
	DefaultEnable *bool `json:"DefaultEnable,omitempty" xml:"DefaultEnable,omitempty"`
	// The description of the compliance package.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the resource that you do not want to evaluate by using the compliance package. Separate multiple resource IDs with commas (,).
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The ID of the region whose resources you want to evaluate by using the compliance package. Separate multiple region IDs with commas (,).
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group whose resources you want to evaluate by using the compliance package. Separate multiple resource group IDs with commas (,).
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The risk level of the resources that are not compliant with the rules in the compliance package. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The tag key of the resource that you want to evaluate by using the compliance package.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value of the resource that you want to evaluate by using the compliance package.
	//
	// >  You must configure the TagValueScope parameter together with the TagKeyScope parameter.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s CreateAggregateCompliancePackShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateCompliancePackShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateAggregateCompliancePackShrinkRequest) SetAggregatorId(v string) *CreateAggregateCompliancePackShrinkRequest {
	s.AggregatorId = &v
	return s
}

func (s *CreateAggregateCompliancePackShrinkRequest) SetClientToken(v string) *CreateAggregateCompliancePackShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateAggregateCompliancePackShrinkRequest) SetCompliancePackName(v string) *CreateAggregateCompliancePackShrinkRequest {
	s.CompliancePackName = &v
	return s
}

func (s *CreateAggregateCompliancePackShrinkRequest) SetCompliancePackTemplateId(v string) *CreateAggregateCompliancePackShrinkRequest {
	s.CompliancePackTemplateId = &v
	return s
}

func (s *CreateAggregateCompliancePackShrinkRequest) SetConfigRulesShrink(v string) *CreateAggregateCompliancePackShrinkRequest {
	s.ConfigRulesShrink = &v
	return s
}

func (s *CreateAggregateCompliancePackShrinkRequest) SetDefaultEnable(v bool) *CreateAggregateCompliancePackShrinkRequest {
	s.DefaultEnable = &v
	return s
}

func (s *CreateAggregateCompliancePackShrinkRequest) SetDescription(v string) *CreateAggregateCompliancePackShrinkRequest {
	s.Description = &v
	return s
}

func (s *CreateAggregateCompliancePackShrinkRequest) SetExcludeResourceIdsScope(v string) *CreateAggregateCompliancePackShrinkRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *CreateAggregateCompliancePackShrinkRequest) SetRegionIdsScope(v string) *CreateAggregateCompliancePackShrinkRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *CreateAggregateCompliancePackShrinkRequest) SetResourceGroupIdsScope(v string) *CreateAggregateCompliancePackShrinkRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *CreateAggregateCompliancePackShrinkRequest) SetRiskLevel(v int32) *CreateAggregateCompliancePackShrinkRequest {
	s.RiskLevel = &v
	return s
}

func (s *CreateAggregateCompliancePackShrinkRequest) SetTagKeyScope(v string) *CreateAggregateCompliancePackShrinkRequest {
	s.TagKeyScope = &v
	return s
}

func (s *CreateAggregateCompliancePackShrinkRequest) SetTagValueScope(v string) *CreateAggregateCompliancePackShrinkRequest {
	s.TagValueScope = &v
	return s
}

type CreateAggregateCompliancePackResponseBody struct {
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAggregateCompliancePackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateCompliancePackResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAggregateCompliancePackResponseBody) SetCompliancePackId(v string) *CreateAggregateCompliancePackResponseBody {
	s.CompliancePackId = &v
	return s
}

func (s *CreateAggregateCompliancePackResponseBody) SetRequestId(v string) *CreateAggregateCompliancePackResponseBody {
	s.RequestId = &v
	return s
}

type CreateAggregateCompliancePackResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAggregateCompliancePackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAggregateCompliancePackResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateCompliancePackResponse) GoString() string {
	return s.String()
}

func (s *CreateAggregateCompliancePackResponse) SetHeaders(v map[string]*string) *CreateAggregateCompliancePackResponse {
	s.Headers = v
	return s
}

func (s *CreateAggregateCompliancePackResponse) SetStatusCode(v int32) *CreateAggregateCompliancePackResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAggregateCompliancePackResponse) SetBody(v *CreateAggregateCompliancePackResponseBody) *CreateAggregateCompliancePackResponse {
	s.Body = v
	return s
}

type CreateAggregateConfigDeliveryChannelRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The `token` can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [Ensure idempotence](~~25693~~)
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to deliver resource change logs. If you set this parameter to true, Cloud Config delivers resource change logs to OSS, Log Service, or MNS when the configurations of the resources change. Valid values:
	//
	// *   true: Cloud Config delivers resource change logs.
	// *   false: Cloud Config does not deliver resource change logs. This is the default value.
	//
	// > This parameter is available for delivery channels of the OSS, SLS, and MNS types.
	ConfigurationItemChangeNotification *bool `json:"ConfigurationItemChangeNotification,omitempty" xml:"ConfigurationItemChangeNotification,omitempty"`
	// Specifies whether to deliver scheduled resource snapshots. Cloud Config delivers scheduled resource snapshots to OSS, MNS, or Log Service at `04:00Z` and `16:00Z` every day. The time is displayed in UTC. Valid values:
	//
	// *   true: Cloud Config delivers scheduled resource snapshots.
	// *   false: Cloud Config does not deliver scheduled resource snapshots. This is the default value.
	ConfigurationSnapshot *bool `json:"ConfigurationSnapshot,omitempty" xml:"ConfigurationSnapshot,omitempty"`
	// The rule that you want to attach to the delivery channel. This parameter is available when you deliver data of all types to MNS or deliver snapshots to Log Service.
	//
	// *   If you set the DeliveryChannelType parameter to MNS, take note of the following settings of the lowest risk level and the resource types of the events to which you want to subscribe:
	//
	//     *   The lowest risk level of the events to which you want to subscribe is in the following format: `{"filterType":"RuleRiskLevel","value":"1","multiple":false}`.
	//
	//         The `value` field indicates the risk level of the events to which you want to subscribe. Valid values: 1, 2, and 3. The value 1 indicates the high risk level, the value 2 indicates the medium risk level, and the value 3 indicates the low risk level.
	//
	//     *   The setting of the resource types of the events to which you want to subscribe is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//         The `values` field indicates the resource types of the events to which you want to subscribe. The value of the field is a JSON array. Example:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	//
	// *   If you set the DeliveryChannelType parameter to SLS, the setting of the resource types of the snapshots to which you want to deliver is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//     The `values` field specifies the resource types of the snapshots to which you want to deliver. The value of the field is a JSON array. Example:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	DeliveryChannelCondition *string `json:"DeliveryChannelCondition,omitempty" xml:"DeliveryChannelCondition,omitempty"`
	// The name of the delivery channel.
	//
	// > If you do not configure this parameter, this parameter is left empty.
	DeliveryChannelName *string `json:"DeliveryChannelName,omitempty" xml:"DeliveryChannelName,omitempty"`
	// The ARN of the delivery destination. Valid values:
	//
	// *   `acs:oss:{RegionId}:{accountId}:{bucketName}` if your delivery destination is an OSS bucket. Example: `acs:oss:cn-shanghai:100931896542****:new-bucket`.
	// *   `acs:mns:{RegionId}:{accountId}:/topics/{topicName}` if your delivery destination is an MNS topic. Example: `acs:mns:cn-shanghai:100931896542****:/topics/topic1`.
	// *   `acs:log:{RegionId}:{accountId}:project/{projectName}/logstore/{logstoreName}` if your delivery destination is a Log Service Logstore. Example: `acs:log:cn-shanghai:100931896542****:project/project1/logstore/logstore1`.
	DeliveryChannelTargetArn *string `json:"DeliveryChannelTargetArn,omitempty" xml:"DeliveryChannelTargetArn,omitempty"`
	// The type of the delivery channel. Valid values:
	//
	// *   OSS: Object Storage Service (OSS)
	// *   MNS: Message Service (MNS)
	// *   SLS: Log Service
	DeliveryChannelType *string `json:"DeliveryChannelType,omitempty" xml:"DeliveryChannelType,omitempty"`
	// The time when you want Cloud Config to deliver scheduled resource snapshots every day.
	//
	// Format: `HH:mmZ`. This time is displayed in UTC.
	//
	// > When you enable the scheduled resource delivery feature, you can configure this parameter to specify a custom delivery time. If you do not configure this parameter, Cloud Config automatically delivers scheduled resource snapshots at `04:00Z` and `16:00Z` every day.
	DeliverySnapshotTime *string `json:"DeliverySnapshotTime,omitempty" xml:"DeliverySnapshotTime,omitempty"`
	// The description of the delivery channel.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to deliver resource non-compliance events. If you set this parameter to true, Cloud Config delivers resource non-compliance events to Log Service or MNS when resources are considered non-compliant. Valid values:
	//
	// *   true: Cloud Config delivers resource non-compliance events.
	// *   false: Cloud Config does not deliver resource non-compliance events. This is the default value.
	//
	// > This parameter is available only for delivery channels of the SLS or MNS type.
	NonCompliantNotification *bool `json:"NonCompliantNotification,omitempty" xml:"NonCompliantNotification,omitempty"`
	// The ARN of the OSS bucket to which you want to transfer the delivery data when the size of the data exceeds the specified upper limit of the delivery channel. Format: `acs:oss:{RegionId}:{accountId}:{bucketName}`.
	//
	// If you do not configure this parameter, Cloud Config delivers only summary data.
	//
	// > This parameter is available only for delivery channels of the SLS or MNS type. The upper limit on the storage size of delivery channels of the SLS type is 1 MB, and the maximum storage size of delivery channels of the MNS type is 64 KB.
	OversizedDataOSSTargetArn *string `json:"OversizedDataOSSTargetArn,omitempty" xml:"OversizedDataOSSTargetArn,omitempty"`
}

func (s CreateAggregateConfigDeliveryChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateConfigDeliveryChannelRequest) GoString() string {
	return s.String()
}

func (s *CreateAggregateConfigDeliveryChannelRequest) SetAggregatorId(v string) *CreateAggregateConfigDeliveryChannelRequest {
	s.AggregatorId = &v
	return s
}

func (s *CreateAggregateConfigDeliveryChannelRequest) SetClientToken(v string) *CreateAggregateConfigDeliveryChannelRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateAggregateConfigDeliveryChannelRequest) SetConfigurationItemChangeNotification(v bool) *CreateAggregateConfigDeliveryChannelRequest {
	s.ConfigurationItemChangeNotification = &v
	return s
}

func (s *CreateAggregateConfigDeliveryChannelRequest) SetConfigurationSnapshot(v bool) *CreateAggregateConfigDeliveryChannelRequest {
	s.ConfigurationSnapshot = &v
	return s
}

func (s *CreateAggregateConfigDeliveryChannelRequest) SetDeliveryChannelCondition(v string) *CreateAggregateConfigDeliveryChannelRequest {
	s.DeliveryChannelCondition = &v
	return s
}

func (s *CreateAggregateConfigDeliveryChannelRequest) SetDeliveryChannelName(v string) *CreateAggregateConfigDeliveryChannelRequest {
	s.DeliveryChannelName = &v
	return s
}

func (s *CreateAggregateConfigDeliveryChannelRequest) SetDeliveryChannelTargetArn(v string) *CreateAggregateConfigDeliveryChannelRequest {
	s.DeliveryChannelTargetArn = &v
	return s
}

func (s *CreateAggregateConfigDeliveryChannelRequest) SetDeliveryChannelType(v string) *CreateAggregateConfigDeliveryChannelRequest {
	s.DeliveryChannelType = &v
	return s
}

func (s *CreateAggregateConfigDeliveryChannelRequest) SetDeliverySnapshotTime(v string) *CreateAggregateConfigDeliveryChannelRequest {
	s.DeliverySnapshotTime = &v
	return s
}

func (s *CreateAggregateConfigDeliveryChannelRequest) SetDescription(v string) *CreateAggregateConfigDeliveryChannelRequest {
	s.Description = &v
	return s
}

func (s *CreateAggregateConfigDeliveryChannelRequest) SetNonCompliantNotification(v bool) *CreateAggregateConfigDeliveryChannelRequest {
	s.NonCompliantNotification = &v
	return s
}

func (s *CreateAggregateConfigDeliveryChannelRequest) SetOversizedDataOSSTargetArn(v string) *CreateAggregateConfigDeliveryChannelRequest {
	s.OversizedDataOSSTargetArn = &v
	return s
}

type CreateAggregateConfigDeliveryChannelResponseBody struct {
	// The ID of the delivery channel.
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAggregateConfigDeliveryChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateConfigDeliveryChannelResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAggregateConfigDeliveryChannelResponseBody) SetDeliveryChannelId(v string) *CreateAggregateConfigDeliveryChannelResponseBody {
	s.DeliveryChannelId = &v
	return s
}

func (s *CreateAggregateConfigDeliveryChannelResponseBody) SetRequestId(v string) *CreateAggregateConfigDeliveryChannelResponseBody {
	s.RequestId = &v
	return s
}

type CreateAggregateConfigDeliveryChannelResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAggregateConfigDeliveryChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAggregateConfigDeliveryChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateConfigDeliveryChannelResponse) GoString() string {
	return s.String()
}

func (s *CreateAggregateConfigDeliveryChannelResponse) SetHeaders(v map[string]*string) *CreateAggregateConfigDeliveryChannelResponse {
	s.Headers = v
	return s
}

func (s *CreateAggregateConfigDeliveryChannelResponse) SetStatusCode(v int32) *CreateAggregateConfigDeliveryChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAggregateConfigDeliveryChannelResponse) SetBody(v *CreateAggregateConfigDeliveryChannelResponseBody) *CreateAggregateConfigDeliveryChannelResponse {
	s.Body = v
	return s
}

type CreateAggregateConfigRuleRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The `token` can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The rule name.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The rule is triggered by configuration changes.
	// *   ScheduledNotification: The rule is periodically triggered.
	ConfigRuleTriggerTypes *string `json:"ConfigRuleTriggerTypes,omitempty" xml:"ConfigRuleTriggerTypes,omitempty"`
	// The description of the rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the member account to which the rule does not apply, which means that the resources within the member account are not evaluated based on the rule. Separate multiple member account IDs with commas (,).
	//
	// > This parameter applies only to a managed rule.
	ExcludeAccountIdsScope *string `json:"ExcludeAccountIdsScope,omitempty" xml:"ExcludeAccountIdsScope,omitempty"`
	// The ID of the resource directory to which the rule does not apply, which means that the resources within member accounts in the resource directory are not evaluated based on the rule. Separate multiple resource directory IDs with commas (,).
	//
	// >
	//
	// *   This parameter applies only to a rule of a global account group.
	//
	// *   This parameter applies only to a managed rule.
	ExcludeFolderIdsScope *string `json:"ExcludeFolderIdsScope,omitempty" xml:"ExcludeFolderIdsScope,omitempty"`
	// The ID of the resource to be excluded from the compliance evaluations performed by the rule. Separate multiple resource IDs with commas (,).
	//
	// > This parameter applies only to a managed rule.
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The ID of the resource directory to which the rule applies, which means that the resources within member accounts in the resource directory are evaluated based on the rule.
	//
	// >
	//
	// *   This parameter applies only to a rule of a global account group.
	//
	// *   This parameter applies only to a managed rule.
	FolderIdsScope *string `json:"FolderIdsScope,omitempty" xml:"FolderIdsScope,omitempty"`
	// The input parameter of the rule.
	InputParameters map[string]interface{} `json:"InputParameters,omitempty" xml:"InputParameters,omitempty"`
	// The interval at which the rule is triggered. Valid values:
	//
	// *   One_Hour: 1 hour.
	// *   Three_Hours: 3 hours.
	// *   Six_Hours: 6 hours.
	// *   Twelve_Hours: 12 hours.
	// *   TwentyFour_Hours (default): 24 hours.
	//
	// > This parameter is required if the `ConfigRuleTriggerTypes` parameter is set to `ScheduledNotification`.
	MaximumExecutionFrequency *string `json:"MaximumExecutionFrequency,omitempty" xml:"MaximumExecutionFrequency,omitempty"`
	// The ID of the region to which the rule applies. Separate multiple region IDs with commas (,).
	//
	// > This parameter applies only to a managed rule.
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group to which the rule applies. Separate multiple resource group IDs with commas (,).
	//
	// > This parameter applies only to a managed rule.
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The type of the resource evaluated by the rule. Separate multiple resource types with commas (,).
	ResourceTypesScope []*string `json:"ResourceTypesScope,omitempty" xml:"ResourceTypesScope,omitempty" type:"Repeated"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The identifier of the rule.
	//
	// *   If you set the SourceOwner parameter to ALIYUN, set this parameter to the name of the managed rule.
	// *   If you set the SourceOwner parameter to CUSTOM_FC, set this parameter to the Alibaba Cloud Resource Name (ARN) of the relevant function in Function Compute.
	//
	// For more information about how to query the name of a managed rule, see [Managed rules](~~127404~~).
	SourceIdentifier *string `json:"SourceIdentifier,omitempty" xml:"SourceIdentifier,omitempty"`
	// The type of the rule. Valid values:
	//
	// *   ALIYUN: a managed rule.
	// *   CUSTOM_FC: a custom rule.
	SourceOwner *string `json:"SourceOwner,omitempty" xml:"SourceOwner,omitempty"`
	// The logical relationship among the tag keys if you specify multiple tag keys for the `TagKeyScope` parameter. For example, if you set the `TagKeyScope` parameter to `ECS,OSS` and the TagKeyLogicScope parameter to `AND`, the rule applies to resources with both the `ECS` and `OSS` tag keys. Valid values:
	//
	// *   AND
	// *   OR
	TagKeyLogicScope *string `json:"TagKeyLogicScope,omitempty" xml:"TagKeyLogicScope,omitempty"`
	// The tag key used to filter resources. The rule applies only to the resources with the specified tag key. Separate multiple parameter values with commas (,).
	//
	// > This parameter applies only to a managed rule. You must configure the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value used to filter resources. The rule applies only to the resources with the specified tag value.
	//
	// > This parameter applies only to a managed rule. You must configure the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s CreateAggregateConfigRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateConfigRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateAggregateConfigRuleRequest) SetAggregatorId(v string) *CreateAggregateConfigRuleRequest {
	s.AggregatorId = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetClientToken(v string) *CreateAggregateConfigRuleRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetConfigRuleName(v string) *CreateAggregateConfigRuleRequest {
	s.ConfigRuleName = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetConfigRuleTriggerTypes(v string) *CreateAggregateConfigRuleRequest {
	s.ConfigRuleTriggerTypes = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetDescription(v string) *CreateAggregateConfigRuleRequest {
	s.Description = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetExcludeAccountIdsScope(v string) *CreateAggregateConfigRuleRequest {
	s.ExcludeAccountIdsScope = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetExcludeFolderIdsScope(v string) *CreateAggregateConfigRuleRequest {
	s.ExcludeFolderIdsScope = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetExcludeResourceIdsScope(v string) *CreateAggregateConfigRuleRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetFolderIdsScope(v string) *CreateAggregateConfigRuleRequest {
	s.FolderIdsScope = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetInputParameters(v map[string]interface{}) *CreateAggregateConfigRuleRequest {
	s.InputParameters = v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetMaximumExecutionFrequency(v string) *CreateAggregateConfigRuleRequest {
	s.MaximumExecutionFrequency = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetRegionIdsScope(v string) *CreateAggregateConfigRuleRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetResourceGroupIdsScope(v string) *CreateAggregateConfigRuleRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetResourceTypesScope(v []*string) *CreateAggregateConfigRuleRequest {
	s.ResourceTypesScope = v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetRiskLevel(v int32) *CreateAggregateConfigRuleRequest {
	s.RiskLevel = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetSourceIdentifier(v string) *CreateAggregateConfigRuleRequest {
	s.SourceIdentifier = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetSourceOwner(v string) *CreateAggregateConfigRuleRequest {
	s.SourceOwner = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetTagKeyLogicScope(v string) *CreateAggregateConfigRuleRequest {
	s.TagKeyLogicScope = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetTagKeyScope(v string) *CreateAggregateConfigRuleRequest {
	s.TagKeyScope = &v
	return s
}

func (s *CreateAggregateConfigRuleRequest) SetTagValueScope(v string) *CreateAggregateConfigRuleRequest {
	s.TagValueScope = &v
	return s
}

type CreateAggregateConfigRuleShrinkRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The `token` can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The rule name.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The rule is triggered by configuration changes.
	// *   ScheduledNotification: The rule is periodically triggered.
	ConfigRuleTriggerTypes *string `json:"ConfigRuleTriggerTypes,omitempty" xml:"ConfigRuleTriggerTypes,omitempty"`
	// The description of the rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the member account to which the rule does not apply, which means that the resources within the member account are not evaluated based on the rule. Separate multiple member account IDs with commas (,).
	//
	// > This parameter applies only to a managed rule.
	ExcludeAccountIdsScope *string `json:"ExcludeAccountIdsScope,omitempty" xml:"ExcludeAccountIdsScope,omitempty"`
	// The ID of the resource directory to which the rule does not apply, which means that the resources within member accounts in the resource directory are not evaluated based on the rule. Separate multiple resource directory IDs with commas (,).
	//
	// >
	//
	// *   This parameter applies only to a rule of a global account group.
	//
	// *   This parameter applies only to a managed rule.
	ExcludeFolderIdsScope *string `json:"ExcludeFolderIdsScope,omitempty" xml:"ExcludeFolderIdsScope,omitempty"`
	// The ID of the resource to be excluded from the compliance evaluations performed by the rule. Separate multiple resource IDs with commas (,).
	//
	// > This parameter applies only to a managed rule.
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The ID of the resource directory to which the rule applies, which means that the resources within member accounts in the resource directory are evaluated based on the rule.
	//
	// >
	//
	// *   This parameter applies only to a rule of a global account group.
	//
	// *   This parameter applies only to a managed rule.
	FolderIdsScope *string `json:"FolderIdsScope,omitempty" xml:"FolderIdsScope,omitempty"`
	// The input parameter of the rule.
	InputParametersShrink *string `json:"InputParameters,omitempty" xml:"InputParameters,omitempty"`
	// The interval at which the rule is triggered. Valid values:
	//
	// *   One_Hour: 1 hour.
	// *   Three_Hours: 3 hours.
	// *   Six_Hours: 6 hours.
	// *   Twelve_Hours: 12 hours.
	// *   TwentyFour_Hours (default): 24 hours.
	//
	// > This parameter is required if the `ConfigRuleTriggerTypes` parameter is set to `ScheduledNotification`.
	MaximumExecutionFrequency *string `json:"MaximumExecutionFrequency,omitempty" xml:"MaximumExecutionFrequency,omitempty"`
	// The ID of the region to which the rule applies. Separate multiple region IDs with commas (,).
	//
	// > This parameter applies only to a managed rule.
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group to which the rule applies. Separate multiple resource group IDs with commas (,).
	//
	// > This parameter applies only to a managed rule.
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The type of the resource evaluated by the rule. Separate multiple resource types with commas (,).
	ResourceTypesScopeShrink *string `json:"ResourceTypesScope,omitempty" xml:"ResourceTypesScope,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The identifier of the rule.
	//
	// *   If you set the SourceOwner parameter to ALIYUN, set this parameter to the name of the managed rule.
	// *   If you set the SourceOwner parameter to CUSTOM_FC, set this parameter to the Alibaba Cloud Resource Name (ARN) of the relevant function in Function Compute.
	//
	// For more information about how to query the name of a managed rule, see [Managed rules](~~127404~~).
	SourceIdentifier *string `json:"SourceIdentifier,omitempty" xml:"SourceIdentifier,omitempty"`
	// The type of the rule. Valid values:
	//
	// *   ALIYUN: a managed rule.
	// *   CUSTOM_FC: a custom rule.
	SourceOwner *string `json:"SourceOwner,omitempty" xml:"SourceOwner,omitempty"`
	// The logical relationship among the tag keys if you specify multiple tag keys for the `TagKeyScope` parameter. For example, if you set the `TagKeyScope` parameter to `ECS,OSS` and the TagKeyLogicScope parameter to `AND`, the rule applies to resources with both the `ECS` and `OSS` tag keys. Valid values:
	//
	// *   AND
	// *   OR
	TagKeyLogicScope *string `json:"TagKeyLogicScope,omitempty" xml:"TagKeyLogicScope,omitempty"`
	// The tag key used to filter resources. The rule applies only to the resources with the specified tag key. Separate multiple parameter values with commas (,).
	//
	// > This parameter applies only to a managed rule. You must configure the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value used to filter resources. The rule applies only to the resources with the specified tag value.
	//
	// > This parameter applies only to a managed rule. You must configure the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s CreateAggregateConfigRuleShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateConfigRuleShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetAggregatorId(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.AggregatorId = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetClientToken(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetConfigRuleName(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.ConfigRuleName = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetConfigRuleTriggerTypes(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.ConfigRuleTriggerTypes = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetDescription(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.Description = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetExcludeAccountIdsScope(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.ExcludeAccountIdsScope = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetExcludeFolderIdsScope(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.ExcludeFolderIdsScope = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetExcludeResourceIdsScope(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetFolderIdsScope(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.FolderIdsScope = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetInputParametersShrink(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.InputParametersShrink = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetMaximumExecutionFrequency(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.MaximumExecutionFrequency = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetRegionIdsScope(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetResourceGroupIdsScope(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetResourceTypesScopeShrink(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.ResourceTypesScopeShrink = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetRiskLevel(v int32) *CreateAggregateConfigRuleShrinkRequest {
	s.RiskLevel = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetSourceIdentifier(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.SourceIdentifier = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetSourceOwner(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.SourceOwner = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetTagKeyLogicScope(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.TagKeyLogicScope = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetTagKeyScope(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.TagKeyScope = &v
	return s
}

func (s *CreateAggregateConfigRuleShrinkRequest) SetTagValueScope(v string) *CreateAggregateConfigRuleShrinkRequest {
	s.TagValueScope = &v
	return s
}

type CreateAggregateConfigRuleResponseBody struct {
	// The rule ID.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAggregateConfigRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateConfigRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAggregateConfigRuleResponseBody) SetConfigRuleId(v string) *CreateAggregateConfigRuleResponseBody {
	s.ConfigRuleId = &v
	return s
}

func (s *CreateAggregateConfigRuleResponseBody) SetRequestId(v string) *CreateAggregateConfigRuleResponseBody {
	s.RequestId = &v
	return s
}

type CreateAggregateConfigRuleResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAggregateConfigRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAggregateConfigRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateConfigRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateAggregateConfigRuleResponse) SetHeaders(v map[string]*string) *CreateAggregateConfigRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateAggregateConfigRuleResponse) SetStatusCode(v int32) *CreateAggregateConfigRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAggregateConfigRuleResponse) SetBody(v *CreateAggregateConfigRuleResponseBody) *CreateAggregateConfigRuleResponse {
	s.Body = v
	return s
}

type CreateAggregateRemediationRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The `token` can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The rule ID.
	//
	// For more information about how to obtain the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The execution mode of the remediation template. Valid values:
	//
	// *   NON_EXECUTION: The remediation template is not executed.
	// *   AUTO_EXECUTION: The remediation template is automatically executed.
	// *   MANUAL_EXECUTION: The remediation template is manually executed.
	// *   NOT_CONFIG: The execution mode is not specified.
	InvokeType *string `json:"InvokeType,omitempty" xml:"InvokeType,omitempty"`
	// The configuration of the remediation template.
	//
	// For more information about how to obtain the configuration of the remediation template, see [ListRemediationTemplates](~~416781~~). You can view the `TemplateDefinition` response parameter to obtain the configuration of the remediation template.
	Params *string `json:"Params,omitempty" xml:"Params,omitempty"`
	// The ID of the remediation template.
	//
	// *   If you set the `RemediationType` parameter to `OOS`, set this parameter to the identifier of the relevant official remediation template, such as `ACS-OSS-PutBucketAcl`. For more information about how to obtain the remediation template identifier, see [ListRemediationTemplates](~~416781~~).
	// *   If you set the `RemediationType` parameter to `FC`, set this parameter to the Alibaba Cloud Resource Name (ARN) of the relevant Function Compute resource, such as `acs:fc:cn-hangzhou:100931896542****:services/ConfigService.LATEST/functions/test-php`.
	RemediationTemplateId *string `json:"RemediationTemplateId,omitempty" xml:"RemediationTemplateId,omitempty"`
	// The type of the remediation template. Valid values:
	//
	// *   OOS: stands for Operation Orchestration Service and indicates official remediation.
	// *   FC: stands for Function Compute and indicates custom remediation.
	RemediationType *string `json:"RemediationType,omitempty" xml:"RemediationType,omitempty"`
	// The source of remediation template. Valid values:
	//
	// *   ALIYUN (default): official template.
	// *   CUSTOM: custom template.
	// *   NONE: none.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s CreateAggregateRemediationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateRemediationRequest) GoString() string {
	return s.String()
}

func (s *CreateAggregateRemediationRequest) SetAggregatorId(v string) *CreateAggregateRemediationRequest {
	s.AggregatorId = &v
	return s
}

func (s *CreateAggregateRemediationRequest) SetClientToken(v string) *CreateAggregateRemediationRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateAggregateRemediationRequest) SetConfigRuleId(v string) *CreateAggregateRemediationRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *CreateAggregateRemediationRequest) SetInvokeType(v string) *CreateAggregateRemediationRequest {
	s.InvokeType = &v
	return s
}

func (s *CreateAggregateRemediationRequest) SetParams(v string) *CreateAggregateRemediationRequest {
	s.Params = &v
	return s
}

func (s *CreateAggregateRemediationRequest) SetRemediationTemplateId(v string) *CreateAggregateRemediationRequest {
	s.RemediationTemplateId = &v
	return s
}

func (s *CreateAggregateRemediationRequest) SetRemediationType(v string) *CreateAggregateRemediationRequest {
	s.RemediationType = &v
	return s
}

func (s *CreateAggregateRemediationRequest) SetSourceType(v string) *CreateAggregateRemediationRequest {
	s.SourceType = &v
	return s
}

type CreateAggregateRemediationResponseBody struct {
	// The ID of the remediation template.
	RemediationId *string `json:"RemediationId,omitempty" xml:"RemediationId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAggregateRemediationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateRemediationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAggregateRemediationResponseBody) SetRemediationId(v string) *CreateAggregateRemediationResponseBody {
	s.RemediationId = &v
	return s
}

func (s *CreateAggregateRemediationResponseBody) SetRequestId(v string) *CreateAggregateRemediationResponseBody {
	s.RequestId = &v
	return s
}

type CreateAggregateRemediationResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAggregateRemediationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAggregateRemediationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregateRemediationResponse) GoString() string {
	return s.String()
}

func (s *CreateAggregateRemediationResponse) SetHeaders(v map[string]*string) *CreateAggregateRemediationResponse {
	s.Headers = v
	return s
}

func (s *CreateAggregateRemediationResponse) SetStatusCode(v int32) *CreateAggregateRemediationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAggregateRemediationResponse) SetBody(v *CreateAggregateRemediationResponseBody) *CreateAggregateRemediationResponse {
	s.Body = v
	return s
}

type CreateAggregatorRequest struct {
	// The type of the member account. Valid value: ResourceDirectory.
	AggregatorAccounts []*CreateAggregatorRequestAggregatorAccounts `json:"AggregatorAccounts,omitempty" xml:"AggregatorAccounts,omitempty" type:"Repeated"`
	// The name of the account group.
	AggregatorName *string `json:"AggregatorName,omitempty" xml:"AggregatorName,omitempty"`
	// The type of the account group. Valid values:
	//
	// *   RD: global account group
	// *   CUSTOM (default): custom account group
	AggregatorType *string `json:"AggregatorType,omitempty" xml:"AggregatorType,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The `token` can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the account group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
}

func (s CreateAggregatorRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregatorRequest) GoString() string {
	return s.String()
}

func (s *CreateAggregatorRequest) SetAggregatorAccounts(v []*CreateAggregatorRequestAggregatorAccounts) *CreateAggregatorRequest {
	s.AggregatorAccounts = v
	return s
}

func (s *CreateAggregatorRequest) SetAggregatorName(v string) *CreateAggregatorRequest {
	s.AggregatorName = &v
	return s
}

func (s *CreateAggregatorRequest) SetAggregatorType(v string) *CreateAggregatorRequest {
	s.AggregatorType = &v
	return s
}

func (s *CreateAggregatorRequest) SetClientToken(v string) *CreateAggregatorRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateAggregatorRequest) SetDescription(v string) *CreateAggregatorRequest {
	s.Description = &v
	return s
}

type CreateAggregatorRequestAggregatorAccounts struct {
	// The Alibaba Cloud account ID of the member. For more information about how to obtain the ID of a member account, see [ListAccounts](~~160016~~).
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The name of the member account. For more information about how to obtain the name of a member account, see [ListAccounts](~~160016~~).
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The type of the member account. The value is fixed to ResourceDirectory.
	AccountType *string `json:"AccountType,omitempty" xml:"AccountType,omitempty"`
}

func (s CreateAggregatorRequestAggregatorAccounts) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregatorRequestAggregatorAccounts) GoString() string {
	return s.String()
}

func (s *CreateAggregatorRequestAggregatorAccounts) SetAccountId(v int64) *CreateAggregatorRequestAggregatorAccounts {
	s.AccountId = &v
	return s
}

func (s *CreateAggregatorRequestAggregatorAccounts) SetAccountName(v string) *CreateAggregatorRequestAggregatorAccounts {
	s.AccountName = &v
	return s
}

func (s *CreateAggregatorRequestAggregatorAccounts) SetAccountType(v string) *CreateAggregatorRequestAggregatorAccounts {
	s.AccountType = &v
	return s
}

type CreateAggregatorShrinkRequest struct {
	// The type of the member account. Valid value: ResourceDirectory.
	AggregatorAccountsShrink *string `json:"AggregatorAccounts,omitempty" xml:"AggregatorAccounts,omitempty"`
	// The name of the account group.
	AggregatorName *string `json:"AggregatorName,omitempty" xml:"AggregatorName,omitempty"`
	// The type of the account group. Valid values:
	//
	// *   RD: global account group
	// *   CUSTOM (default): custom account group
	AggregatorType *string `json:"AggregatorType,omitempty" xml:"AggregatorType,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The `token` can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the account group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
}

func (s CreateAggregatorShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregatorShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateAggregatorShrinkRequest) SetAggregatorAccountsShrink(v string) *CreateAggregatorShrinkRequest {
	s.AggregatorAccountsShrink = &v
	return s
}

func (s *CreateAggregatorShrinkRequest) SetAggregatorName(v string) *CreateAggregatorShrinkRequest {
	s.AggregatorName = &v
	return s
}

func (s *CreateAggregatorShrinkRequest) SetAggregatorType(v string) *CreateAggregatorShrinkRequest {
	s.AggregatorType = &v
	return s
}

func (s *CreateAggregatorShrinkRequest) SetClientToken(v string) *CreateAggregatorShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateAggregatorShrinkRequest) SetDescription(v string) *CreateAggregatorShrinkRequest {
	s.Description = &v
	return s
}

type CreateAggregatorResponseBody struct {
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateAggregatorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregatorResponseBody) GoString() string {
	return s.String()
}

func (s *CreateAggregatorResponseBody) SetAggregatorId(v string) *CreateAggregatorResponseBody {
	s.AggregatorId = &v
	return s
}

func (s *CreateAggregatorResponseBody) SetRequestId(v string) *CreateAggregatorResponseBody {
	s.RequestId = &v
	return s
}

type CreateAggregatorResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateAggregatorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateAggregatorResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateAggregatorResponse) GoString() string {
	return s.String()
}

func (s *CreateAggregatorResponse) SetHeaders(v map[string]*string) *CreateAggregatorResponse {
	s.Headers = v
	return s
}

func (s *CreateAggregatorResponse) SetStatusCode(v int32) *CreateAggregatorResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateAggregatorResponse) SetBody(v *CreateAggregatorResponseBody) *CreateAggregatorResponse {
	s.Body = v
	return s
}

type CreateCompliancePackRequest struct {
	// The client token that you want to use to ensure the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.``
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The name of the compliance package.
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
	// The ID of the compliance package template.
	//
	// For more information about how to obtain the ID of a compliance package template, see [ListCompliancePackTemplates](~~261176~~).
	CompliancePackTemplateId *string `json:"CompliancePackTemplateId,omitempty" xml:"CompliancePackTemplateId,omitempty"`
	// The rules in the compliance package.
	ConfigRules []*CreateCompliancePackRequestConfigRules `json:"ConfigRules,omitempty" xml:"ConfigRules,omitempty" type:"Repeated"`
	// Specifies whether to enable the rule together with the compliance package. Valid values:
	//
	// *   true: The system enables the rule together with the compliance package.
	// *   false: The system does not enable the rule together with the compliance package.
	DefaultEnable *bool `json:"DefaultEnable,omitempty" xml:"DefaultEnable,omitempty"`
	// The description of the compliance package.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the resource that you do not want to evaluate by using the compliance package. Separate multiple resource IDs with commas (,).
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The ID of the region whose resources you want to evaluate by using the compliance package. Separate multiple region IDs with commas (,).
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group whose resources you want to evaluate by using the compliance package. Separate multiple resource group IDs with commas (,).
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The risk level of the resources that are not compliant with the rules in the compliance package. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The tag key of the resource that you want to evaluate by using the compliance package.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value of the resource that you want to evaluate by using the compliance package.
	//
	// >  You must configure the TagValueScope parameter together with the TagKeyScope parameter.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s CreateCompliancePackRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCompliancePackRequest) GoString() string {
	return s.String()
}

func (s *CreateCompliancePackRequest) SetClientToken(v string) *CreateCompliancePackRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateCompliancePackRequest) SetCompliancePackName(v string) *CreateCompliancePackRequest {
	s.CompliancePackName = &v
	return s
}

func (s *CreateCompliancePackRequest) SetCompliancePackTemplateId(v string) *CreateCompliancePackRequest {
	s.CompliancePackTemplateId = &v
	return s
}

func (s *CreateCompliancePackRequest) SetConfigRules(v []*CreateCompliancePackRequestConfigRules) *CreateCompliancePackRequest {
	s.ConfigRules = v
	return s
}

func (s *CreateCompliancePackRequest) SetDefaultEnable(v bool) *CreateCompliancePackRequest {
	s.DefaultEnable = &v
	return s
}

func (s *CreateCompliancePackRequest) SetDescription(v string) *CreateCompliancePackRequest {
	s.Description = &v
	return s
}

func (s *CreateCompliancePackRequest) SetExcludeResourceIdsScope(v string) *CreateCompliancePackRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *CreateCompliancePackRequest) SetRegionIdsScope(v string) *CreateCompliancePackRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *CreateCompliancePackRequest) SetResourceGroupIdsScope(v string) *CreateCompliancePackRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *CreateCompliancePackRequest) SetRiskLevel(v int32) *CreateCompliancePackRequest {
	s.RiskLevel = &v
	return s
}

func (s *CreateCompliancePackRequest) SetTagKeyScope(v string) *CreateCompliancePackRequest {
	s.TagKeyScope = &v
	return s
}

func (s *CreateCompliancePackRequest) SetTagValueScope(v string) *CreateCompliancePackRequest {
	s.TagValueScope = &v
	return s
}

type CreateCompliancePackRequestConfigRules struct {
	// The ID of the rule. If you configure this parameter, Cloud Config adds the rule of the specified ID to the compliance package.
	//
	// You only need to configure the `ManagedRuleIdentifier` or `ConfigRuleId` parameter. If you configure both parameters, the value of the `ConfigRuleId` parameter takes precedence. For more information about how to obtain the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The details of the input parameters of the rule.
	ConfigRuleParameters []*CreateCompliancePackRequestConfigRulesConfigRuleParameters `json:"ConfigRuleParameters,omitempty" xml:"ConfigRuleParameters,omitempty" type:"Repeated"`
	// The description of the rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the managed rule. Cloud Config automatically creates a managed rule based on the specified ID and adds the rule to the compliance package.
	//
	// You only need to configure the `ManagedRuleIdentifier` or `ConfigRuleId` parameter. If you configure both parameters, the value of the `ConfigRuleId` parameter take precedence. For more information about how to obtain the identifier of a managed rule, see [ListCompliancePackTemplates](~~261176~~).
	ManagedRuleIdentifier *string `json:"ManagedRuleIdentifier,omitempty" xml:"ManagedRuleIdentifier,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s CreateCompliancePackRequestConfigRules) String() string {
	return tea.Prettify(s)
}

func (s CreateCompliancePackRequestConfigRules) GoString() string {
	return s.String()
}

func (s *CreateCompliancePackRequestConfigRules) SetConfigRuleId(v string) *CreateCompliancePackRequestConfigRules {
	s.ConfigRuleId = &v
	return s
}

func (s *CreateCompliancePackRequestConfigRules) SetConfigRuleName(v string) *CreateCompliancePackRequestConfigRules {
	s.ConfigRuleName = &v
	return s
}

func (s *CreateCompliancePackRequestConfigRules) SetConfigRuleParameters(v []*CreateCompliancePackRequestConfigRulesConfigRuleParameters) *CreateCompliancePackRequestConfigRules {
	s.ConfigRuleParameters = v
	return s
}

func (s *CreateCompliancePackRequestConfigRules) SetDescription(v string) *CreateCompliancePackRequestConfigRules {
	s.Description = &v
	return s
}

func (s *CreateCompliancePackRequestConfigRules) SetManagedRuleIdentifier(v string) *CreateCompliancePackRequestConfigRules {
	s.ManagedRuleIdentifier = &v
	return s
}

func (s *CreateCompliancePackRequestConfigRules) SetRiskLevel(v int32) *CreateCompliancePackRequestConfigRules {
	s.RiskLevel = &v
	return s
}

type CreateCompliancePackRequestConfigRulesConfigRuleParameters struct {
	// The name of the input parameter.
	//
	// You must configure the `ParameterName` and `ParameterValue` parameters or neither of them. If the managed rule has an input parameter but no default value exists, you must configure this parameter. For more information about how to obtain the name of an input parameter for a managed rule, see [ListCompliancePackTemplates](~~261176~~).
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The value of the input parameter.
	//
	// You must configure the `ParameterName` and `ParameterValue` parameters or neither of them. If the managed rule has an input parameter but no default value exists you must configure this parameter. For more information about how to obtain the expected value of an input parameter for a managed rule, see [ListCompliancePackTemplates](~~261176~~).
	ParameterValue *string `json:"ParameterValue,omitempty" xml:"ParameterValue,omitempty"`
}

func (s CreateCompliancePackRequestConfigRulesConfigRuleParameters) String() string {
	return tea.Prettify(s)
}

func (s CreateCompliancePackRequestConfigRulesConfigRuleParameters) GoString() string {
	return s.String()
}

func (s *CreateCompliancePackRequestConfigRulesConfigRuleParameters) SetParameterName(v string) *CreateCompliancePackRequestConfigRulesConfigRuleParameters {
	s.ParameterName = &v
	return s
}

func (s *CreateCompliancePackRequestConfigRulesConfigRuleParameters) SetParameterValue(v string) *CreateCompliancePackRequestConfigRulesConfigRuleParameters {
	s.ParameterValue = &v
	return s
}

type CreateCompliancePackShrinkRequest struct {
	// The client token that you want to use to ensure the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.``
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The name of the compliance package.
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
	// The ID of the compliance package template.
	//
	// For more information about how to obtain the ID of a compliance package template, see [ListCompliancePackTemplates](~~261176~~).
	CompliancePackTemplateId *string `json:"CompliancePackTemplateId,omitempty" xml:"CompliancePackTemplateId,omitempty"`
	// The rules in the compliance package.
	ConfigRulesShrink *string `json:"ConfigRules,omitempty" xml:"ConfigRules,omitempty"`
	// Specifies whether to enable the rule together with the compliance package. Valid values:
	//
	// *   true: The system enables the rule together with the compliance package.
	// *   false: The system does not enable the rule together with the compliance package.
	DefaultEnable *bool `json:"DefaultEnable,omitempty" xml:"DefaultEnable,omitempty"`
	// The description of the compliance package.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the resource that you do not want to evaluate by using the compliance package. Separate multiple resource IDs with commas (,).
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The ID of the region whose resources you want to evaluate by using the compliance package. Separate multiple region IDs with commas (,).
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group whose resources you want to evaluate by using the compliance package. Separate multiple resource group IDs with commas (,).
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The risk level of the resources that are not compliant with the rules in the compliance package. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The tag key of the resource that you want to evaluate by using the compliance package.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value of the resource that you want to evaluate by using the compliance package.
	//
	// >  You must configure the TagValueScope parameter together with the TagKeyScope parameter.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s CreateCompliancePackShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCompliancePackShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateCompliancePackShrinkRequest) SetClientToken(v string) *CreateCompliancePackShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateCompliancePackShrinkRequest) SetCompliancePackName(v string) *CreateCompliancePackShrinkRequest {
	s.CompliancePackName = &v
	return s
}

func (s *CreateCompliancePackShrinkRequest) SetCompliancePackTemplateId(v string) *CreateCompliancePackShrinkRequest {
	s.CompliancePackTemplateId = &v
	return s
}

func (s *CreateCompliancePackShrinkRequest) SetConfigRulesShrink(v string) *CreateCompliancePackShrinkRequest {
	s.ConfigRulesShrink = &v
	return s
}

func (s *CreateCompliancePackShrinkRequest) SetDefaultEnable(v bool) *CreateCompliancePackShrinkRequest {
	s.DefaultEnable = &v
	return s
}

func (s *CreateCompliancePackShrinkRequest) SetDescription(v string) *CreateCompliancePackShrinkRequest {
	s.Description = &v
	return s
}

func (s *CreateCompliancePackShrinkRequest) SetExcludeResourceIdsScope(v string) *CreateCompliancePackShrinkRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *CreateCompliancePackShrinkRequest) SetRegionIdsScope(v string) *CreateCompliancePackShrinkRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *CreateCompliancePackShrinkRequest) SetResourceGroupIdsScope(v string) *CreateCompliancePackShrinkRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *CreateCompliancePackShrinkRequest) SetRiskLevel(v int32) *CreateCompliancePackShrinkRequest {
	s.RiskLevel = &v
	return s
}

func (s *CreateCompliancePackShrinkRequest) SetTagKeyScope(v string) *CreateCompliancePackShrinkRequest {
	s.TagKeyScope = &v
	return s
}

func (s *CreateCompliancePackShrinkRequest) SetTagValueScope(v string) *CreateCompliancePackShrinkRequest {
	s.TagValueScope = &v
	return s
}

type CreateCompliancePackResponseBody struct {
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCompliancePackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCompliancePackResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCompliancePackResponseBody) SetCompliancePackId(v string) *CreateCompliancePackResponseBody {
	s.CompliancePackId = &v
	return s
}

func (s *CreateCompliancePackResponseBody) SetRequestId(v string) *CreateCompliancePackResponseBody {
	s.RequestId = &v
	return s
}

type CreateCompliancePackResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCompliancePackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCompliancePackResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCompliancePackResponse) GoString() string {
	return s.String()
}

func (s *CreateCompliancePackResponse) SetHeaders(v map[string]*string) *CreateCompliancePackResponse {
	s.Headers = v
	return s
}

func (s *CreateCompliancePackResponse) SetStatusCode(v int32) *CreateCompliancePackResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCompliancePackResponse) SetBody(v *CreateCompliancePackResponseBody) *CreateCompliancePackResponse {
	s.Body = v
	return s
}

type CreateConfigDeliveryChannelRequest struct {
	// The client token that is used to ensure the idempotency of the request. You can use the client to generate the token, but you must ensure that the token is unique among different requests.
	//
	// The `token` can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to deliver resource change logs. If you set this parameter to true, Cloud Config delivers resource change logs to OSS, Log Service, or MNS when the configurations of the resources change. Valid values:
	//
	// *   true: Cloud Config delivers resource change logs.
	// *   false (default): Cloud Config does not deliver resource change logs.
	//
	// > This parameter is available for delivery channels of the OSS, SLS, and MNS types.
	ConfigurationItemChangeNotification *bool `json:"ConfigurationItemChangeNotification,omitempty" xml:"ConfigurationItemChangeNotification,omitempty"`
	// Specifies whether to deliver scheduled resource snapshots. Cloud Config delivers scheduled resource snapshots at `04:00Z` and `16:00Z` to OSS, MNS, or Log Service every day. The time is displayed in UTC. Valid values:
	//
	// *   true: Cloud Config delivers scheduled resource snapshots.
	// *   false (default): Cloud Config does not deliver scheduled resource snapshots.
	ConfigurationSnapshot *bool `json:"ConfigurationSnapshot,omitempty" xml:"ConfigurationSnapshot,omitempty"`
	// The rule that you want to attach to the delivery channel. This parameter is available when you deliver data of all types to MNS or deliver snapshots to Log Service.
	//
	// *   If the value of the DeliveryChannelType parameter is MNS, take note of the following settings of the lowest risk level and resource types of the events to which you subscribed:
	//
	//     *   The setting of the lowest risk level for the events to which you want to subscribe is in the following format: `{"filterType":"RuleRiskLevel","value":"1","multiple":false}`.
	//
	//         The `value` field indicates the lowest risk level of the events to which you want to subscribe. Valid values: 1, 2, and 3. The value 1 indicates the high risk level, the value 2 indicates the medium risk level, and the value 3 indicates the low risk level.
	//
	//     *   The setting of the resource types of the events to which you want to subscribe is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//         The `values` field indicates the resource types of the events to which you want to subscribe. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	//
	// *   If you set the DeliveryChannelType parameter to SLS, the setting of the resource types of the snapshots to which you want to deliver is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//     The `values` field specifies the resource types of the snapshots to which you want to deliver. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	DeliveryChannelCondition *string `json:"DeliveryChannelCondition,omitempty" xml:"DeliveryChannelCondition,omitempty"`
	// The name of the delivery channel.
	//
	// > If you do not configure this parameter, this parameter is left empty.
	DeliveryChannelName *string `json:"DeliveryChannelName,omitempty" xml:"DeliveryChannelName,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the delivery destination. Valid values:
	//
	// *   `acs:oss:{RegionId}:{accountId}:{bucketName}` if your delivery destination is an OSS bucket. Example: `acs:oss:cn-shanghai:100931896542****:new-bucket`.
	// *   `acs:mns:{RegionId}:{accountId}:/topics/{topicName}` if your delivery destination is an MNS topic. Example: `acs:mns:cn-shanghai:100931896542****:/topics/topic1`.
	// *   `acs:log:{RegionId}:{accountId}:project/{projectName}/logstore/{logstoreName}` if your delivery destination is a Log Service Logstore. Example: `acs:log:cn-shanghai:100931896542****:project/project1/logstore/logstore1`.
	DeliveryChannelTargetArn *string `json:"DeliveryChannelTargetArn,omitempty" xml:"DeliveryChannelTargetArn,omitempty"`
	// The type of the delivery channel. Valid values:
	//
	// *   OSS: Object Storage Service (OSS)
	// *   MNS: Message Service (MNS)
	// *   SLS: Log Service
	DeliveryChannelType *string `json:"DeliveryChannelType,omitempty" xml:"DeliveryChannelType,omitempty"`
	// The time when you want Cloud Config to deliver scheduled resource snapshots every day.
	//
	// Format: `HH:mmZ`. This time is displayed in UTC.
	//
	// > When you enable the scheduled resource delivery feature, you can configure this parameter to specify a custom delivery time. If you do not configure this parameter, Cloud Config automatically delivers scheduled resource snapshots at `04:00Z` and `16:00Z` every day.
	DeliverySnapshotTime *string `json:"DeliverySnapshotTime,omitempty" xml:"DeliverySnapshotTime,omitempty"`
	// The description of the delivery channel.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to deliver resource non-compliance events. If you set this parameter to true, Cloud Config delivers resource non-compliance events to Log Service or MNS when resources are considered non-compliant. Valid values:
	//
	// *   true: Cloud Config delivers resource non-compliance events.
	// *   false (default): Cloud Config does not deliver resource non-compliance events.
	//
	// > This parameter is available only for delivery channels of the SLS or MNS type.
	NonCompliantNotification *bool `json:"NonCompliantNotification,omitempty" xml:"NonCompliantNotification,omitempty"`
	// The ARN of the OSS bucket to which you want to transfer the delivery data when the size of the data exceeds the specified upper limit of the delivery channel. Format: `acs:oss:{RegionId}:{accountId}:{bucketName}`.
	//
	// If you do not configure this parameter, Cloud Config delivers only summary data.
	//
	// > This parameter is available only for delivery channels of the SLS or MNS type. The maximum storage size of delivery channels of the SLS type is 1 MB, and the maximum storage size of delivery channels of the MNS type is 64 KB.
	OversizedDataOSSTargetArn *string `json:"OversizedDataOSSTargetArn,omitempty" xml:"OversizedDataOSSTargetArn,omitempty"`
}

func (s CreateConfigDeliveryChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateConfigDeliveryChannelRequest) GoString() string {
	return s.String()
}

func (s *CreateConfigDeliveryChannelRequest) SetClientToken(v string) *CreateConfigDeliveryChannelRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateConfigDeliveryChannelRequest) SetConfigurationItemChangeNotification(v bool) *CreateConfigDeliveryChannelRequest {
	s.ConfigurationItemChangeNotification = &v
	return s
}

func (s *CreateConfigDeliveryChannelRequest) SetConfigurationSnapshot(v bool) *CreateConfigDeliveryChannelRequest {
	s.ConfigurationSnapshot = &v
	return s
}

func (s *CreateConfigDeliveryChannelRequest) SetDeliveryChannelCondition(v string) *CreateConfigDeliveryChannelRequest {
	s.DeliveryChannelCondition = &v
	return s
}

func (s *CreateConfigDeliveryChannelRequest) SetDeliveryChannelName(v string) *CreateConfigDeliveryChannelRequest {
	s.DeliveryChannelName = &v
	return s
}

func (s *CreateConfigDeliveryChannelRequest) SetDeliveryChannelTargetArn(v string) *CreateConfigDeliveryChannelRequest {
	s.DeliveryChannelTargetArn = &v
	return s
}

func (s *CreateConfigDeliveryChannelRequest) SetDeliveryChannelType(v string) *CreateConfigDeliveryChannelRequest {
	s.DeliveryChannelType = &v
	return s
}

func (s *CreateConfigDeliveryChannelRequest) SetDeliverySnapshotTime(v string) *CreateConfigDeliveryChannelRequest {
	s.DeliverySnapshotTime = &v
	return s
}

func (s *CreateConfigDeliveryChannelRequest) SetDescription(v string) *CreateConfigDeliveryChannelRequest {
	s.Description = &v
	return s
}

func (s *CreateConfigDeliveryChannelRequest) SetNonCompliantNotification(v bool) *CreateConfigDeliveryChannelRequest {
	s.NonCompliantNotification = &v
	return s
}

func (s *CreateConfigDeliveryChannelRequest) SetOversizedDataOSSTargetArn(v string) *CreateConfigDeliveryChannelRequest {
	s.OversizedDataOSSTargetArn = &v
	return s
}

type CreateConfigDeliveryChannelResponseBody struct {
	// The ID of the delivery channel.
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateConfigDeliveryChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateConfigDeliveryChannelResponseBody) GoString() string {
	return s.String()
}

func (s *CreateConfigDeliveryChannelResponseBody) SetDeliveryChannelId(v string) *CreateConfigDeliveryChannelResponseBody {
	s.DeliveryChannelId = &v
	return s
}

func (s *CreateConfigDeliveryChannelResponseBody) SetRequestId(v string) *CreateConfigDeliveryChannelResponseBody {
	s.RequestId = &v
	return s
}

type CreateConfigDeliveryChannelResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateConfigDeliveryChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateConfigDeliveryChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateConfigDeliveryChannelResponse) GoString() string {
	return s.String()
}

func (s *CreateConfigDeliveryChannelResponse) SetHeaders(v map[string]*string) *CreateConfigDeliveryChannelResponse {
	s.Headers = v
	return s
}

func (s *CreateConfigDeliveryChannelResponse) SetStatusCode(v int32) *CreateConfigDeliveryChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateConfigDeliveryChannelResponse) SetBody(v *CreateConfigDeliveryChannelResponseBody) *CreateConfigDeliveryChannelResponse {
	s.Body = v
	return s
}

type CreateConfigRuleRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must ensure that the token is unique among different requests. The `token` can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The rule name.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The rule is triggered by configuration changes.
	// *   ScheduledNotification: The rule is periodically triggered.
	//
	// > Separate two trigger mechanisms with commas (,).
	ConfigRuleTriggerTypes *string `json:"ConfigRuleTriggerTypes,omitempty" xml:"ConfigRuleTriggerTypes,omitempty"`
	// The rule description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the resource excluded from the compliance evaluations performed based on the rule. Separate multiple resource IDs with commas (,).
	//
	// > This parameter applies only to a managed rule.
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The input parameters of the rule.
	InputParameters map[string]interface{} `json:"InputParameters,omitempty" xml:"InputParameters,omitempty"`
	// The interval at which the rule is triggered. Valid values:
	//
	// *   One_Hour: 1 hour.
	// *   Three_Hours: 3 hours.
	// *   Six_Hours: 6 hours.
	// *   Twelve_Hours: 12 hours.
	// *   TwentyFour_Hours (default): 24 hours.
	//
	// > This parameter is required if the ConfigRuleTriggerTypes parameter is set to ScheduledNotification.
	MaximumExecutionFrequency *string `json:"MaximumExecutionFrequency,omitempty" xml:"MaximumExecutionFrequency,omitempty"`
	// The ID of the region to which the rule applies. Separate multiple region IDs with commas (,).
	//
	// > This parameter applies only to a managed rule.
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group to which the rule applies. Separate multiple resource group IDs with commas (,).
	//
	// > This parameter applies only to a managed rule.
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The type of the resource evaluated by the rule. Separate multiple resource types with commas (,).
	ResourceTypesScope []*string `json:"ResourceTypesScope,omitempty" xml:"ResourceTypesScope,omitempty" type:"Repeated"`
	// The risk level of the resources that do not comply with the rule. Valid values:
	//
	// *   1: high
	// *   2: medium
	// *   3: low
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The identifier of the rule.
	//
	// *   If you set the SourceOwner parameter to ALIYUN, set this parameter to the name of the managed rule.
	// *   If you set the SourceOwner parameter to CUSTOM_FC, set this parameter to the Alibaba Cloud Resource Name (ARN) of the relevant function in Function Compute.
	//
	// For more information about how to query the name of a managed rule, see [Managed rules](~~127404~~).
	SourceIdentifier *string `json:"SourceIdentifier,omitempty" xml:"SourceIdentifier,omitempty"`
	// The type of the rule. Valid values:
	//
	// *   ALIYUN: managed rule
	// *   CUSTOM_FC: a custom rule
	SourceOwner *string `json:"SourceOwner,omitempty" xml:"SourceOwner,omitempty"`
	// The logical relationship among the tag keys if you specify multiple tag keys by using the `TagKeyScope` parameter. For example, if you set the `TagKeyScope` parameter to `ECS,OSS` and set the TagKeyLogicScope parameter to `AND`, the rule applies to resources with both the `ECS` and `OSS` tag keys. Valid values:
	//
	// *   AND
	// *   OR
	TagKeyLogicScope *string `json:"TagKeyLogicScope,omitempty" xml:"TagKeyLogicScope,omitempty"`
	// The tag value used to filter resources. The rule applies only to the resources that use the specified tag value.
	//
	// > This parameter applies only to a managed rule. You must configure the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value used to filter resources. The rule applies only to the resources that use the specified tag value.
	//
	// > This parameter applies only to a managed rule. You must configure the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s CreateConfigRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateConfigRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateConfigRuleRequest) SetClientToken(v string) *CreateConfigRuleRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateConfigRuleRequest) SetConfigRuleName(v string) *CreateConfigRuleRequest {
	s.ConfigRuleName = &v
	return s
}

func (s *CreateConfigRuleRequest) SetConfigRuleTriggerTypes(v string) *CreateConfigRuleRequest {
	s.ConfigRuleTriggerTypes = &v
	return s
}

func (s *CreateConfigRuleRequest) SetDescription(v string) *CreateConfigRuleRequest {
	s.Description = &v
	return s
}

func (s *CreateConfigRuleRequest) SetExcludeResourceIdsScope(v string) *CreateConfigRuleRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *CreateConfigRuleRequest) SetInputParameters(v map[string]interface{}) *CreateConfigRuleRequest {
	s.InputParameters = v
	return s
}

func (s *CreateConfigRuleRequest) SetMaximumExecutionFrequency(v string) *CreateConfigRuleRequest {
	s.MaximumExecutionFrequency = &v
	return s
}

func (s *CreateConfigRuleRequest) SetRegionIdsScope(v string) *CreateConfigRuleRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *CreateConfigRuleRequest) SetResourceGroupIdsScope(v string) *CreateConfigRuleRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *CreateConfigRuleRequest) SetResourceTypesScope(v []*string) *CreateConfigRuleRequest {
	s.ResourceTypesScope = v
	return s
}

func (s *CreateConfigRuleRequest) SetRiskLevel(v int32) *CreateConfigRuleRequest {
	s.RiskLevel = &v
	return s
}

func (s *CreateConfigRuleRequest) SetSourceIdentifier(v string) *CreateConfigRuleRequest {
	s.SourceIdentifier = &v
	return s
}

func (s *CreateConfigRuleRequest) SetSourceOwner(v string) *CreateConfigRuleRequest {
	s.SourceOwner = &v
	return s
}

func (s *CreateConfigRuleRequest) SetTagKeyLogicScope(v string) *CreateConfigRuleRequest {
	s.TagKeyLogicScope = &v
	return s
}

func (s *CreateConfigRuleRequest) SetTagKeyScope(v string) *CreateConfigRuleRequest {
	s.TagKeyScope = &v
	return s
}

func (s *CreateConfigRuleRequest) SetTagValueScope(v string) *CreateConfigRuleRequest {
	s.TagValueScope = &v
	return s
}

type CreateConfigRuleShrinkRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must ensure that the token is unique among different requests. The `token` can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The rule name.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The rule is triggered by configuration changes.
	// *   ScheduledNotification: The rule is periodically triggered.
	//
	// > Separate two trigger mechanisms with commas (,).
	ConfigRuleTriggerTypes *string `json:"ConfigRuleTriggerTypes,omitempty" xml:"ConfigRuleTriggerTypes,omitempty"`
	// The rule description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the resource excluded from the compliance evaluations performed based on the rule. Separate multiple resource IDs with commas (,).
	//
	// > This parameter applies only to a managed rule.
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The input parameters of the rule.
	InputParametersShrink *string `json:"InputParameters,omitempty" xml:"InputParameters,omitempty"`
	// The interval at which the rule is triggered. Valid values:
	//
	// *   One_Hour: 1 hour.
	// *   Three_Hours: 3 hours.
	// *   Six_Hours: 6 hours.
	// *   Twelve_Hours: 12 hours.
	// *   TwentyFour_Hours (default): 24 hours.
	//
	// > This parameter is required if the ConfigRuleTriggerTypes parameter is set to ScheduledNotification.
	MaximumExecutionFrequency *string `json:"MaximumExecutionFrequency,omitempty" xml:"MaximumExecutionFrequency,omitempty"`
	// The ID of the region to which the rule applies. Separate multiple region IDs with commas (,).
	//
	// > This parameter applies only to a managed rule.
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group to which the rule applies. Separate multiple resource group IDs with commas (,).
	//
	// > This parameter applies only to a managed rule.
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The type of the resource evaluated by the rule. Separate multiple resource types with commas (,).
	ResourceTypesScopeShrink *string `json:"ResourceTypesScope,omitempty" xml:"ResourceTypesScope,omitempty"`
	// The risk level of the resources that do not comply with the rule. Valid values:
	//
	// *   1: high
	// *   2: medium
	// *   3: low
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The identifier of the rule.
	//
	// *   If you set the SourceOwner parameter to ALIYUN, set this parameter to the name of the managed rule.
	// *   If you set the SourceOwner parameter to CUSTOM_FC, set this parameter to the Alibaba Cloud Resource Name (ARN) of the relevant function in Function Compute.
	//
	// For more information about how to query the name of a managed rule, see [Managed rules](~~127404~~).
	SourceIdentifier *string `json:"SourceIdentifier,omitempty" xml:"SourceIdentifier,omitempty"`
	// The type of the rule. Valid values:
	//
	// *   ALIYUN: managed rule
	// *   CUSTOM_FC: a custom rule
	SourceOwner *string `json:"SourceOwner,omitempty" xml:"SourceOwner,omitempty"`
	// The logical relationship among the tag keys if you specify multiple tag keys by using the `TagKeyScope` parameter. For example, if you set the `TagKeyScope` parameter to `ECS,OSS` and set the TagKeyLogicScope parameter to `AND`, the rule applies to resources with both the `ECS` and `OSS` tag keys. Valid values:
	//
	// *   AND
	// *   OR
	TagKeyLogicScope *string `json:"TagKeyLogicScope,omitempty" xml:"TagKeyLogicScope,omitempty"`
	// The tag value used to filter resources. The rule applies only to the resources that use the specified tag value.
	//
	// > This parameter applies only to a managed rule. You must configure the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value used to filter resources. The rule applies only to the resources that use the specified tag value.
	//
	// > This parameter applies only to a managed rule. You must configure the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s CreateConfigRuleShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateConfigRuleShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateConfigRuleShrinkRequest) SetClientToken(v string) *CreateConfigRuleShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateConfigRuleShrinkRequest) SetConfigRuleName(v string) *CreateConfigRuleShrinkRequest {
	s.ConfigRuleName = &v
	return s
}

func (s *CreateConfigRuleShrinkRequest) SetConfigRuleTriggerTypes(v string) *CreateConfigRuleShrinkRequest {
	s.ConfigRuleTriggerTypes = &v
	return s
}

func (s *CreateConfigRuleShrinkRequest) SetDescription(v string) *CreateConfigRuleShrinkRequest {
	s.Description = &v
	return s
}

func (s *CreateConfigRuleShrinkRequest) SetExcludeResourceIdsScope(v string) *CreateConfigRuleShrinkRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *CreateConfigRuleShrinkRequest) SetInputParametersShrink(v string) *CreateConfigRuleShrinkRequest {
	s.InputParametersShrink = &v
	return s
}

func (s *CreateConfigRuleShrinkRequest) SetMaximumExecutionFrequency(v string) *CreateConfigRuleShrinkRequest {
	s.MaximumExecutionFrequency = &v
	return s
}

func (s *CreateConfigRuleShrinkRequest) SetRegionIdsScope(v string) *CreateConfigRuleShrinkRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *CreateConfigRuleShrinkRequest) SetResourceGroupIdsScope(v string) *CreateConfigRuleShrinkRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *CreateConfigRuleShrinkRequest) SetResourceTypesScopeShrink(v string) *CreateConfigRuleShrinkRequest {
	s.ResourceTypesScopeShrink = &v
	return s
}

func (s *CreateConfigRuleShrinkRequest) SetRiskLevel(v int32) *CreateConfigRuleShrinkRequest {
	s.RiskLevel = &v
	return s
}

func (s *CreateConfigRuleShrinkRequest) SetSourceIdentifier(v string) *CreateConfigRuleShrinkRequest {
	s.SourceIdentifier = &v
	return s
}

func (s *CreateConfigRuleShrinkRequest) SetSourceOwner(v string) *CreateConfigRuleShrinkRequest {
	s.SourceOwner = &v
	return s
}

func (s *CreateConfigRuleShrinkRequest) SetTagKeyLogicScope(v string) *CreateConfigRuleShrinkRequest {
	s.TagKeyLogicScope = &v
	return s
}

func (s *CreateConfigRuleShrinkRequest) SetTagKeyScope(v string) *CreateConfigRuleShrinkRequest {
	s.TagKeyScope = &v
	return s
}

func (s *CreateConfigRuleShrinkRequest) SetTagValueScope(v string) *CreateConfigRuleShrinkRequest {
	s.TagValueScope = &v
	return s
}

type CreateConfigRuleResponseBody struct {
	// The rule ID.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateConfigRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateConfigRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateConfigRuleResponseBody) SetConfigRuleId(v string) *CreateConfigRuleResponseBody {
	s.ConfigRuleId = &v
	return s
}

func (s *CreateConfigRuleResponseBody) SetRequestId(v string) *CreateConfigRuleResponseBody {
	s.RequestId = &v
	return s
}

type CreateConfigRuleResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateConfigRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateConfigRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateConfigRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateConfigRuleResponse) SetHeaders(v map[string]*string) *CreateConfigRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateConfigRuleResponse) SetStatusCode(v int32) *CreateConfigRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateConfigRuleResponse) SetBody(v *CreateConfigRuleResponseBody) *CreateConfigRuleResponse {
	s.Body = v
	return s
}

type CreateDeliveryChannelRequest struct {
	// The client token that is used to ensure the idempotency of the request. You can use the client to generate the token, but you must ensure that the token is unique among different requests.
	//
	// The `token` can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to deliver resource change logs to the specified destination. If you set this parameter to true, Cloud Config delivers resource change logs to OSS, Log Service, or MNS when the configurations of the resources change. Valid values:
	//
	// *   true
	// *   false (default)
	//
	// > This parameter is available for delivery channels of the OSS, SLS, and MNS types.
	ConfigurationItemChangeNotification *bool `json:"ConfigurationItemChangeNotification,omitempty" xml:"ConfigurationItemChangeNotification,omitempty"`
	// Specifies whether to deliver scheduled resource snapshots to the OSS bucket. If the value of this parameter is true, the scheduled resource snapshots are delivered to the specified OSS bucket at 00:00:00 and 12:00:00 on a daily basis. Valid values:
	//
	// *   true
	// *   false (default)
	//
	// > This parameter is applicable only to delivery channels of the OSS type.
	ConfigurationSnapshot *bool `json:"ConfigurationSnapshot,omitempty" xml:"ConfigurationSnapshot,omitempty"`
	// The ARN of the role that you want to assign to the delivery channel. Specify the ARN in the following format: `acs:ram::{accountId}:role/aliyunserviceroleforconfig`.
	DeliveryChannelAssumeRoleArn *string `json:"DeliveryChannelAssumeRoleArn,omitempty" xml:"DeliveryChannelAssumeRoleArn,omitempty"`
	// The rule that you want to attach to the delivery channel. This parameter is available only for delivery channels of the MNS type.
	//
	// This parameter specifies the lowest risk level and the resource types for the events to which you want to subscribe.
	//
	// *   The setting of the lowest risk level for the events to which you want to subscribe is in the following format: `{"filterType":"RuleRiskLevel","value":"1","multiple":false}`.
	//
	//     The `value` field indicates the lowest risk level of the events to which you want to subscribe. Valid values: 1, 2, and 3. The value 1 indicates the high risk level, the value 2 indicates the medium risk level, and the value 3 indicates the low risk level.
	//
	// *   The setting of the resource types of the events to which you want to subscribe is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//     The `values` field indicates the resource types of the events to which you want to subscribe. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	DeliveryChannelCondition *string `json:"DeliveryChannelCondition,omitempty" xml:"DeliveryChannelCondition,omitempty"`
	// The name of the delivery channel.
	//
	// > If you do not configure this parameter, this parameter is left empty.
	DeliveryChannelName *string `json:"DeliveryChannelName,omitempty" xml:"DeliveryChannelName,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the delivery destination. Valid values:
	//
	// *   `acs:oss:{RegionId}:{accountId}:{bucketName}` if your delivery destination is an OSS bucket. Example: `acs:oss:cn-shanghai:100931896542****:new-bucket`.
	// *   `acs:mns:{RegionId}:{accountId}:/topics/{topicName}` if your delivery destination is an MNS topic. Example: `acs:mns:cn-shanghai:100931896542****:/topics/topic1`.
	// *   `acs:log:{RegionId}:{accountId}:project/{projectName}/logstore/{logstoreName}` if your delivery destination is a Log Service Logstore. Example: `acs:log:cn-shanghai:100931896542****:project/project1/logstore/logstore1`.
	DeliveryChannelTargetArn *string `json:"DeliveryChannelTargetArn,omitempty" xml:"DeliveryChannelTargetArn,omitempty"`
	// The type of the delivery channel. Valid values:
	//
	// *   OSS: Object Storage Service (OSS)
	// *   MNS: Message Service (MNS)
	// *   SLS: Log Service
	DeliveryChannelType *string `json:"DeliveryChannelType,omitempty" xml:"DeliveryChannelType,omitempty"`
	// The description of the delivery channel.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to deliver resource non-compliance events. If you set this parameter to true, Cloud Config delivers resource non-compliance events to Log Service or MNS when resources are considered non-compliant. Valid values:
	//
	// *   true
	// *   false (default)
	//
	// > This parameter is available only for delivery channels of the SLS or MNS type.
	NonCompliantNotification *bool `json:"NonCompliantNotification,omitempty" xml:"NonCompliantNotification,omitempty"`
	// The ARN of the OSS bucket to which you want to transfer the delivery data when the size of the data exceeds the specified upper limit of the delivery channel. Format: `acs:oss:{RegionId}:{accountId}:{bucketName}`.
	//
	// If you do not configure this parameter, Cloud Config delivers only summary data.
	//
	// > This parameter is available only for delivery channels of the SLS or MNS type. The maximum storage size of delivery channels of the SLS type is 1 MB, and the maximum storage size of delivery channels of the MNS type is 64 KB.
	OversizedDataOSSTargetArn *string `json:"OversizedDataOSSTargetArn,omitempty" xml:"OversizedDataOSSTargetArn,omitempty"`
}

func (s CreateDeliveryChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDeliveryChannelRequest) GoString() string {
	return s.String()
}

func (s *CreateDeliveryChannelRequest) SetClientToken(v string) *CreateDeliveryChannelRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDeliveryChannelRequest) SetConfigurationItemChangeNotification(v bool) *CreateDeliveryChannelRequest {
	s.ConfigurationItemChangeNotification = &v
	return s
}

func (s *CreateDeliveryChannelRequest) SetConfigurationSnapshot(v bool) *CreateDeliveryChannelRequest {
	s.ConfigurationSnapshot = &v
	return s
}

func (s *CreateDeliveryChannelRequest) SetDeliveryChannelAssumeRoleArn(v string) *CreateDeliveryChannelRequest {
	s.DeliveryChannelAssumeRoleArn = &v
	return s
}

func (s *CreateDeliveryChannelRequest) SetDeliveryChannelCondition(v string) *CreateDeliveryChannelRequest {
	s.DeliveryChannelCondition = &v
	return s
}

func (s *CreateDeliveryChannelRequest) SetDeliveryChannelName(v string) *CreateDeliveryChannelRequest {
	s.DeliveryChannelName = &v
	return s
}

func (s *CreateDeliveryChannelRequest) SetDeliveryChannelTargetArn(v string) *CreateDeliveryChannelRequest {
	s.DeliveryChannelTargetArn = &v
	return s
}

func (s *CreateDeliveryChannelRequest) SetDeliveryChannelType(v string) *CreateDeliveryChannelRequest {
	s.DeliveryChannelType = &v
	return s
}

func (s *CreateDeliveryChannelRequest) SetDescription(v string) *CreateDeliveryChannelRequest {
	s.Description = &v
	return s
}

func (s *CreateDeliveryChannelRequest) SetNonCompliantNotification(v bool) *CreateDeliveryChannelRequest {
	s.NonCompliantNotification = &v
	return s
}

func (s *CreateDeliveryChannelRequest) SetOversizedDataOSSTargetArn(v string) *CreateDeliveryChannelRequest {
	s.OversizedDataOSSTargetArn = &v
	return s
}

type CreateDeliveryChannelResponseBody struct {
	// The ID of the delivery channel.
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDeliveryChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDeliveryChannelResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDeliveryChannelResponseBody) SetDeliveryChannelId(v string) *CreateDeliveryChannelResponseBody {
	s.DeliveryChannelId = &v
	return s
}

func (s *CreateDeliveryChannelResponseBody) SetRequestId(v string) *CreateDeliveryChannelResponseBody {
	s.RequestId = &v
	return s
}

type CreateDeliveryChannelResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDeliveryChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDeliveryChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDeliveryChannelResponse) GoString() string {
	return s.String()
}

func (s *CreateDeliveryChannelResponse) SetHeaders(v map[string]*string) *CreateDeliveryChannelResponse {
	s.Headers = v
	return s
}

func (s *CreateDeliveryChannelResponse) SetStatusCode(v int32) *CreateDeliveryChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDeliveryChannelResponse) SetBody(v *CreateDeliveryChannelResponseBody) *CreateDeliveryChannelResponse {
	s.Body = v
	return s
}

type CreateRemediationRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The `token` can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The rule ID.
	//
	// For more information about how to obtain the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The execution mode of the remediation template. Valid values:
	//
	// *   NON_EXECUTION: The remediation template is not executed.
	// *   AUTO_EXECUTION: The remediation template is automatically executed.
	// *   MANUAL_EXECUTION: The remediation template is manually executed.
	// *   NOT_CONFIG: The execution mode is not specified.
	InvokeType *string `json:"InvokeType,omitempty" xml:"InvokeType,omitempty"`
	// The configuration of the remediation template.
	//
	// For more information about how to obtain the remediation template configuration, see the `TemplateDefinition` response parameter provided in [ListRemediationTemplates](~~416781~~).
	Params *string `json:"Params,omitempty" xml:"Params,omitempty"`
	// The ID of the remediation template.
	//
	// *   If you set the `RemediationType` parameter to `OOS`, set this parameter to the identifier of the relevant official remediation template, such as `ACS-OSS-PutBucketAcl`. For more information about how to obtain the remediation template identifier, see [ListRemediationTemplates](~~416781~~).
	// *   If you set the `RemediationType` parameter to `FC`, set this parameter to the Alibaba Cloud Resource Name (ARN) of the relevant Function Compute resource, such as `acs:fc:cn-hangzhou:100931896542****:services/ConfigService.LATEST/functions/test-php`.
	RemediationTemplateId *string `json:"RemediationTemplateId,omitempty" xml:"RemediationTemplateId,omitempty"`
	// The type of the remediation template. Valid values:
	//
	// *   OOS: Operation Orchestration Service (official remediation)
	// *   FC: Function Compute (custom remediation)
	RemediationType *string `json:"RemediationType,omitempty" xml:"RemediationType,omitempty"`
	// The source of remediation. Valid values:
	//
	// *   ALIYUN (default): official template.
	// *   CUSTOM: custom template.
	// *   NONE: none.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s CreateRemediationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateRemediationRequest) GoString() string {
	return s.String()
}

func (s *CreateRemediationRequest) SetClientToken(v string) *CreateRemediationRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateRemediationRequest) SetConfigRuleId(v string) *CreateRemediationRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *CreateRemediationRequest) SetInvokeType(v string) *CreateRemediationRequest {
	s.InvokeType = &v
	return s
}

func (s *CreateRemediationRequest) SetParams(v string) *CreateRemediationRequest {
	s.Params = &v
	return s
}

func (s *CreateRemediationRequest) SetRemediationTemplateId(v string) *CreateRemediationRequest {
	s.RemediationTemplateId = &v
	return s
}

func (s *CreateRemediationRequest) SetRemediationType(v string) *CreateRemediationRequest {
	s.RemediationType = &v
	return s
}

func (s *CreateRemediationRequest) SetSourceType(v string) *CreateRemediationRequest {
	s.SourceType = &v
	return s
}

type CreateRemediationResponseBody struct {
	// The ID of the remediation template.
	RemediationId *string `json:"RemediationId,omitempty" xml:"RemediationId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateRemediationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateRemediationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateRemediationResponseBody) SetRemediationId(v string) *CreateRemediationResponseBody {
	s.RemediationId = &v
	return s
}

func (s *CreateRemediationResponseBody) SetRequestId(v string) *CreateRemediationResponseBody {
	s.RequestId = &v
	return s
}

type CreateRemediationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateRemediationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateRemediationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateRemediationResponse) GoString() string {
	return s.String()
}

func (s *CreateRemediationResponse) SetHeaders(v map[string]*string) *CreateRemediationResponse {
	s.Headers = v
	return s
}

func (s *CreateRemediationResponse) SetStatusCode(v int32) *CreateRemediationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateRemediationResponse) SetBody(v *CreateRemediationResponseBody) *CreateRemediationResponse {
	s.Body = v
	return s
}

type DeactiveAggregateConfigRulesRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The rule ID. Separate multiple rule IDs with commas (,).
	//
	// For more information about how to obtain the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s DeactiveAggregateConfigRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeactiveAggregateConfigRulesRequest) GoString() string {
	return s.String()
}

func (s *DeactiveAggregateConfigRulesRequest) SetAggregatorId(v string) *DeactiveAggregateConfigRulesRequest {
	s.AggregatorId = &v
	return s
}

func (s *DeactiveAggregateConfigRulesRequest) SetConfigRuleIds(v string) *DeactiveAggregateConfigRulesRequest {
	s.ConfigRuleIds = &v
	return s
}

type DeactiveAggregateConfigRulesResponseBody struct {
	// The returned result.
	OperateRuleResult *DeactiveAggregateConfigRulesResponseBodyOperateRuleResult `json:"OperateRuleResult,omitempty" xml:"OperateRuleResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeactiveAggregateConfigRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeactiveAggregateConfigRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DeactiveAggregateConfigRulesResponseBody) SetOperateRuleResult(v *DeactiveAggregateConfigRulesResponseBodyOperateRuleResult) *DeactiveAggregateConfigRulesResponseBody {
	s.OperateRuleResult = v
	return s
}

func (s *DeactiveAggregateConfigRulesResponseBody) SetRequestId(v string) *DeactiveAggregateConfigRulesResponseBody {
	s.RequestId = &v
	return s
}

type DeactiveAggregateConfigRulesResponseBodyOperateRuleResult struct {
	// The returned result.
	OperateRuleItemList []*DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList `json:"OperateRuleItemList,omitempty" xml:"OperateRuleItemList,omitempty" type:"Repeated"`
}

func (s DeactiveAggregateConfigRulesResponseBodyOperateRuleResult) String() string {
	return tea.Prettify(s)
}

func (s DeactiveAggregateConfigRulesResponseBodyOperateRuleResult) GoString() string {
	return s.String()
}

func (s *DeactiveAggregateConfigRulesResponseBodyOperateRuleResult) SetOperateRuleItemList(v []*DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) *DeactiveAggregateConfigRulesResponseBodyOperateRuleResult {
	s.OperateRuleItemList = v
	return s
}

type DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList struct {
	// The rule ID.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The error code returned.
	//
	// *   If the rule is disabled, no error code is returned.
	// *   If the rule fails to be disabled, an error code is returned. For more information about error codes, see [Error codes](https://error-center.alibabacloud.com/status/product/Config).
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) String() string {
	return tea.Prettify(s)
}

func (s DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) GoString() string {
	return s.String()
}

func (s *DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetConfigRuleId(v string) *DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.ConfigRuleId = &v
	return s
}

func (s *DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetErrorCode(v string) *DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.ErrorCode = &v
	return s
}

func (s *DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetSuccess(v bool) *DeactiveAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.Success = &v
	return s
}

type DeactiveAggregateConfigRulesResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeactiveAggregateConfigRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeactiveAggregateConfigRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeactiveAggregateConfigRulesResponse) GoString() string {
	return s.String()
}

func (s *DeactiveAggregateConfigRulesResponse) SetHeaders(v map[string]*string) *DeactiveAggregateConfigRulesResponse {
	s.Headers = v
	return s
}

func (s *DeactiveAggregateConfigRulesResponse) SetStatusCode(v int32) *DeactiveAggregateConfigRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeactiveAggregateConfigRulesResponse) SetBody(v *DeactiveAggregateConfigRulesResponseBody) *DeactiveAggregateConfigRulesResponse {
	s.Body = v
	return s
}

type DeactiveConfigRulesRequest struct {
	// The ID of the rule. Separate multiple rule IDs with commas (,).
	//
	// For more information about how to obtain the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s DeactiveConfigRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeactiveConfigRulesRequest) GoString() string {
	return s.String()
}

func (s *DeactiveConfigRulesRequest) SetConfigRuleIds(v string) *DeactiveConfigRulesRequest {
	s.ConfigRuleIds = &v
	return s
}

type DeactiveConfigRulesResponseBody struct {
	// The results of the operations to disable the specified rules.
	OperateRuleResult *DeactiveConfigRulesResponseBodyOperateRuleResult `json:"OperateRuleResult,omitempty" xml:"OperateRuleResult,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeactiveConfigRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeactiveConfigRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DeactiveConfigRulesResponseBody) SetOperateRuleResult(v *DeactiveConfigRulesResponseBodyOperateRuleResult) *DeactiveConfigRulesResponseBody {
	s.OperateRuleResult = v
	return s
}

func (s *DeactiveConfigRulesResponseBody) SetRequestId(v string) *DeactiveConfigRulesResponseBody {
	s.RequestId = &v
	return s
}

type DeactiveConfigRulesResponseBodyOperateRuleResult struct {
	// The result of the operation to disable the rule.
	OperateRuleItemList []*DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList `json:"OperateRuleItemList,omitempty" xml:"OperateRuleItemList,omitempty" type:"Repeated"`
}

func (s DeactiveConfigRulesResponseBodyOperateRuleResult) String() string {
	return tea.Prettify(s)
}

func (s DeactiveConfigRulesResponseBodyOperateRuleResult) GoString() string {
	return s.String()
}

func (s *DeactiveConfigRulesResponseBodyOperateRuleResult) SetOperateRuleItemList(v []*DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) *DeactiveConfigRulesResponseBodyOperateRuleResult {
	s.OperateRuleItemList = v
	return s
}

type DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList struct {
	// The ID of the rule.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The error code.
	//
	// *   If the rule is disabled, no error code is returned.
	//
	// <!---->
	//
	// *   If the rule fails to be disabled, an error code is returned. For more information about error codes, visit the [API Error Center](https://error-center.alibabacloud.com/status/product/Config).
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the operation is successful. Valid values:
	//
	// *   true: The operation is successful.
	// *   false: The operation fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) String() string {
	return tea.Prettify(s)
}

func (s DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) GoString() string {
	return s.String()
}

func (s *DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetConfigRuleId(v string) *DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.ConfigRuleId = &v
	return s
}

func (s *DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetErrorCode(v string) *DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.ErrorCode = &v
	return s
}

func (s *DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetSuccess(v bool) *DeactiveConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.Success = &v
	return s
}

type DeactiveConfigRulesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeactiveConfigRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeactiveConfigRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeactiveConfigRulesResponse) GoString() string {
	return s.String()
}

func (s *DeactiveConfigRulesResponse) SetHeaders(v map[string]*string) *DeactiveConfigRulesResponse {
	s.Headers = v
	return s
}

func (s *DeactiveConfigRulesResponse) SetStatusCode(v int32) *DeactiveConfigRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeactiveConfigRulesResponse) SetBody(v *DeactiveConfigRulesResponseBody) *DeactiveConfigRulesResponse {
	s.Body = v
	return s
}

type DeleteAggregateCompliancePacksRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The `token` can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the compliance package. Separate multiple compliance package IDs with commas (,).
	//
	// For more information about how to obtain the ID of a compliance package, see [ListAggregateCompliancePacks](~~262059~~).
	CompliancePackIds *string `json:"CompliancePackIds,omitempty" xml:"CompliancePackIds,omitempty"`
	// Specifies whether to delete the rules in the compliance package. Valid values:
	//
	// *   true: The rules are deleted.
	// *   false (default): The rules are not deleted.
	DeleteRule *bool `json:"DeleteRule,omitempty" xml:"DeleteRule,omitempty"`
}

func (s DeleteAggregateCompliancePacksRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateCompliancePacksRequest) GoString() string {
	return s.String()
}

func (s *DeleteAggregateCompliancePacksRequest) SetAggregatorId(v string) *DeleteAggregateCompliancePacksRequest {
	s.AggregatorId = &v
	return s
}

func (s *DeleteAggregateCompliancePacksRequest) SetClientToken(v string) *DeleteAggregateCompliancePacksRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteAggregateCompliancePacksRequest) SetCompliancePackIds(v string) *DeleteAggregateCompliancePacksRequest {
	s.CompliancePackIds = &v
	return s
}

func (s *DeleteAggregateCompliancePacksRequest) SetDeleteRule(v bool) *DeleteAggregateCompliancePacksRequest {
	s.DeleteRule = &v
	return s
}

type DeleteAggregateCompliancePacksResponseBody struct {
	// The results of the delete operations.
	OperateCompliancePacksResult *DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResult `json:"OperateCompliancePacksResult,omitempty" xml:"OperateCompliancePacksResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAggregateCompliancePacksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateCompliancePacksResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAggregateCompliancePacksResponseBody) SetOperateCompliancePacksResult(v *DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResult) *DeleteAggregateCompliancePacksResponseBody {
	s.OperateCompliancePacksResult = v
	return s
}

func (s *DeleteAggregateCompliancePacksResponseBody) SetRequestId(v string) *DeleteAggregateCompliancePacksResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResult struct {
	// An array that contains the deleted compliance packages.
	OperateCompliancePacks []*DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks `json:"OperateCompliancePacks,omitempty" xml:"OperateCompliancePacks,omitempty" type:"Repeated"`
}

func (s DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResult) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResult) GoString() string {
	return s.String()
}

func (s *DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResult) SetOperateCompliancePacks(v []*DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks) *DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResult {
	s.OperateCompliancePacks = v
	return s
}

type DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks struct {
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The error code returned.
	//
	// *   If the compliance package is deleted, no error code is returned.
	// *   If the compliance package fails to be deleted, an error code is returned. For more information about error codes, see [Error codes](https://error-center.alibabacloud.com/status/product/Config).
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks) GoString() string {
	return s.String()
}

func (s *DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks) SetCompliancePackId(v string) *DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks {
	s.CompliancePackId = &v
	return s
}

func (s *DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks) SetErrorCode(v string) *DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks {
	s.ErrorCode = &v
	return s
}

func (s *DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks) SetSuccess(v bool) *DeleteAggregateCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks {
	s.Success = &v
	return s
}

type DeleteAggregateCompliancePacksResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAggregateCompliancePacksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAggregateCompliancePacksResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateCompliancePacksResponse) GoString() string {
	return s.String()
}

func (s *DeleteAggregateCompliancePacksResponse) SetHeaders(v map[string]*string) *DeleteAggregateCompliancePacksResponse {
	s.Headers = v
	return s
}

func (s *DeleteAggregateCompliancePacksResponse) SetStatusCode(v int32) *DeleteAggregateCompliancePacksResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAggregateCompliancePacksResponse) SetBody(v *DeleteAggregateCompliancePacksResponseBody) *DeleteAggregateCompliancePacksResponse {
	s.Body = v
	return s
}

type DeleteAggregateConfigDeliveryChannelRequest struct {
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the delivery channel.
	//
	// For more information about how to obtain the ID of a delivery channel, see [ListAggregateConfigDeliveryChannels](~~429842~~).
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
}

func (s DeleteAggregateConfigDeliveryChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateConfigDeliveryChannelRequest) GoString() string {
	return s.String()
}

func (s *DeleteAggregateConfigDeliveryChannelRequest) SetAggregatorId(v string) *DeleteAggregateConfigDeliveryChannelRequest {
	s.AggregatorId = &v
	return s
}

func (s *DeleteAggregateConfigDeliveryChannelRequest) SetDeliveryChannelId(v string) *DeleteAggregateConfigDeliveryChannelRequest {
	s.DeliveryChannelId = &v
	return s
}

type DeleteAggregateConfigDeliveryChannelResponseBody struct {
	// The ID of the delivery channel.
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAggregateConfigDeliveryChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateConfigDeliveryChannelResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAggregateConfigDeliveryChannelResponseBody) SetDeliveryChannelId(v string) *DeleteAggregateConfigDeliveryChannelResponseBody {
	s.DeliveryChannelId = &v
	return s
}

func (s *DeleteAggregateConfigDeliveryChannelResponseBody) SetRequestId(v string) *DeleteAggregateConfigDeliveryChannelResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAggregateConfigDeliveryChannelResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAggregateConfigDeliveryChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAggregateConfigDeliveryChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateConfigDeliveryChannelResponse) GoString() string {
	return s.String()
}

func (s *DeleteAggregateConfigDeliveryChannelResponse) SetHeaders(v map[string]*string) *DeleteAggregateConfigDeliveryChannelResponse {
	s.Headers = v
	return s
}

func (s *DeleteAggregateConfigDeliveryChannelResponse) SetStatusCode(v int32) *DeleteAggregateConfigDeliveryChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAggregateConfigDeliveryChannelResponse) SetBody(v *DeleteAggregateConfigDeliveryChannelResponseBody) *DeleteAggregateConfigDeliveryChannelResponse {
	s.Body = v
	return s
}

type DeleteAggregateConfigRulesRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The rule ID. Separate multiple rule IDs with commas (,).
	//
	// For more information about how to obtain the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s DeleteAggregateConfigRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateConfigRulesRequest) GoString() string {
	return s.String()
}

func (s *DeleteAggregateConfigRulesRequest) SetAggregatorId(v string) *DeleteAggregateConfigRulesRequest {
	s.AggregatorId = &v
	return s
}

func (s *DeleteAggregateConfigRulesRequest) SetConfigRuleIds(v string) *DeleteAggregateConfigRulesRequest {
	s.ConfigRuleIds = &v
	return s
}

type DeleteAggregateConfigRulesResponseBody struct {
	// The results of the delete operations.
	OperateRuleResult *DeleteAggregateConfigRulesResponseBodyOperateRuleResult `json:"OperateRuleResult,omitempty" xml:"OperateRuleResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAggregateConfigRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateConfigRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAggregateConfigRulesResponseBody) SetOperateRuleResult(v *DeleteAggregateConfigRulesResponseBodyOperateRuleResult) *DeleteAggregateConfigRulesResponseBody {
	s.OperateRuleResult = v
	return s
}

func (s *DeleteAggregateConfigRulesResponseBody) SetRequestId(v string) *DeleteAggregateConfigRulesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAggregateConfigRulesResponseBodyOperateRuleResult struct {
	// The details of the result.
	OperateRuleItemList []*DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList `json:"OperateRuleItemList,omitempty" xml:"OperateRuleItemList,omitempty" type:"Repeated"`
}

func (s DeleteAggregateConfigRulesResponseBodyOperateRuleResult) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateConfigRulesResponseBodyOperateRuleResult) GoString() string {
	return s.String()
}

func (s *DeleteAggregateConfigRulesResponseBodyOperateRuleResult) SetOperateRuleItemList(v []*DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) *DeleteAggregateConfigRulesResponseBodyOperateRuleResult {
	s.OperateRuleItemList = v
	return s
}

type DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList struct {
	// The rule ID.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The error code returned.
	//
	// *   If the rule is deleted, no error code is returned.
	// *   If the rule fails to be deleted, an error code is returned. For more information about error codes, see [Error codes](https://error-center.alibabacloud.com/status/product/Config).
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) GoString() string {
	return s.String()
}

func (s *DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetConfigRuleId(v string) *DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.ConfigRuleId = &v
	return s
}

func (s *DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetErrorCode(v string) *DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.ErrorCode = &v
	return s
}

func (s *DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetSuccess(v bool) *DeleteAggregateConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.Success = &v
	return s
}

type DeleteAggregateConfigRulesResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAggregateConfigRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAggregateConfigRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateConfigRulesResponse) GoString() string {
	return s.String()
}

func (s *DeleteAggregateConfigRulesResponse) SetHeaders(v map[string]*string) *DeleteAggregateConfigRulesResponse {
	s.Headers = v
	return s
}

func (s *DeleteAggregateConfigRulesResponse) SetStatusCode(v int32) *DeleteAggregateConfigRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAggregateConfigRulesResponse) SetBody(v *DeleteAggregateConfigRulesResponseBody) *DeleteAggregateConfigRulesResponse {
	s.Body = v
	return s
}

type DeleteAggregateRemediationsRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the remediation template. Separate multiple remediation template IDs with commas (,).
	//
	// For more information about how to obtain the ID of a remediation template, see [ListAggregateRemediations](~~270036~~).
	RemediationIds *string `json:"RemediationIds,omitempty" xml:"RemediationIds,omitempty"`
}

func (s DeleteAggregateRemediationsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateRemediationsRequest) GoString() string {
	return s.String()
}

func (s *DeleteAggregateRemediationsRequest) SetAggregatorId(v string) *DeleteAggregateRemediationsRequest {
	s.AggregatorId = &v
	return s
}

func (s *DeleteAggregateRemediationsRequest) SetRemediationIds(v string) *DeleteAggregateRemediationsRequest {
	s.RemediationIds = &v
	return s
}

type DeleteAggregateRemediationsResponseBody struct {
	// The results of the delete operation.
	RemediationDeleteResults []*DeleteAggregateRemediationsResponseBodyRemediationDeleteResults `json:"RemediationDeleteResults,omitempty" xml:"RemediationDeleteResults,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAggregateRemediationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateRemediationsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAggregateRemediationsResponseBody) SetRemediationDeleteResults(v []*DeleteAggregateRemediationsResponseBodyRemediationDeleteResults) *DeleteAggregateRemediationsResponseBody {
	s.RemediationDeleteResults = v
	return s
}

func (s *DeleteAggregateRemediationsResponseBody) SetRequestId(v string) *DeleteAggregateRemediationsResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAggregateRemediationsResponseBodyRemediationDeleteResults struct {
	// The error code returned.
	//
	// *   If the remediation template is deleted, no error code is returned.
	// *   If the remediation template fails to be deleted, an error code is returned. For more information about error codes, see [Error codes](https://error-center.alibabacloud.com/status/product/Config).
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the remediation template.
	RemediationId *string `json:"RemediationId,omitempty" xml:"RemediationId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteAggregateRemediationsResponseBodyRemediationDeleteResults) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateRemediationsResponseBodyRemediationDeleteResults) GoString() string {
	return s.String()
}

func (s *DeleteAggregateRemediationsResponseBodyRemediationDeleteResults) SetErrorMessage(v string) *DeleteAggregateRemediationsResponseBodyRemediationDeleteResults {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteAggregateRemediationsResponseBodyRemediationDeleteResults) SetRemediationId(v string) *DeleteAggregateRemediationsResponseBodyRemediationDeleteResults {
	s.RemediationId = &v
	return s
}

func (s *DeleteAggregateRemediationsResponseBodyRemediationDeleteResults) SetSuccess(v bool) *DeleteAggregateRemediationsResponseBodyRemediationDeleteResults {
	s.Success = &v
	return s
}

type DeleteAggregateRemediationsResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAggregateRemediationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAggregateRemediationsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregateRemediationsResponse) GoString() string {
	return s.String()
}

func (s *DeleteAggregateRemediationsResponse) SetHeaders(v map[string]*string) *DeleteAggregateRemediationsResponse {
	s.Headers = v
	return s
}

func (s *DeleteAggregateRemediationsResponse) SetStatusCode(v int32) *DeleteAggregateRemediationsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAggregateRemediationsResponse) SetBody(v *DeleteAggregateRemediationsResponseBody) *DeleteAggregateRemediationsResponse {
	s.Body = v
	return s
}

type DeleteAggregatorsRequest struct {
	// The ID of the account group. Separate multiple IDs with commas (,).
	AggregatorIds *string `json:"AggregatorIds,omitempty" xml:"AggregatorIds,omitempty"`
	// The client token that you want to use to ensure the idempotency of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
}

func (s DeleteAggregatorsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregatorsRequest) GoString() string {
	return s.String()
}

func (s *DeleteAggregatorsRequest) SetAggregatorIds(v string) *DeleteAggregatorsRequest {
	s.AggregatorIds = &v
	return s
}

func (s *DeleteAggregatorsRequest) SetClientToken(v string) *DeleteAggregatorsRequest {
	s.ClientToken = &v
	return s
}

type DeleteAggregatorsResponseBody struct {
	// The returned result.
	OperateAggregatorsResult *DeleteAggregatorsResponseBodyOperateAggregatorsResult `json:"OperateAggregatorsResult,omitempty" xml:"OperateAggregatorsResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteAggregatorsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregatorsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteAggregatorsResponseBody) SetOperateAggregatorsResult(v *DeleteAggregatorsResponseBodyOperateAggregatorsResult) *DeleteAggregatorsResponseBody {
	s.OperateAggregatorsResult = v
	return s
}

func (s *DeleteAggregatorsResponseBody) SetRequestId(v string) *DeleteAggregatorsResponseBody {
	s.RequestId = &v
	return s
}

type DeleteAggregatorsResponseBodyOperateAggregatorsResult struct {
	// The details of the account group.
	OperateAggregators []*DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators `json:"OperateAggregators,omitempty" xml:"OperateAggregators,omitempty" type:"Repeated"`
}

func (s DeleteAggregatorsResponseBodyOperateAggregatorsResult) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregatorsResponseBodyOperateAggregatorsResult) GoString() string {
	return s.String()
}

func (s *DeleteAggregatorsResponseBodyOperateAggregatorsResult) SetOperateAggregators(v []*DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators) *DeleteAggregatorsResponseBodyOperateAggregatorsResult {
	s.OperateAggregators = v
	return s
}

type DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators struct {
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The error code returned.
	//
	// > No error code is returned for the account group if the account group is deleted.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators) GoString() string {
	return s.String()
}

func (s *DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators) SetAggregatorId(v string) *DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators {
	s.AggregatorId = &v
	return s
}

func (s *DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators) SetErrorCode(v string) *DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators {
	s.ErrorCode = &v
	return s
}

func (s *DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators) SetSuccess(v bool) *DeleteAggregatorsResponseBodyOperateAggregatorsResultOperateAggregators {
	s.Success = &v
	return s
}

type DeleteAggregatorsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteAggregatorsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteAggregatorsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteAggregatorsResponse) GoString() string {
	return s.String()
}

func (s *DeleteAggregatorsResponse) SetHeaders(v map[string]*string) *DeleteAggregatorsResponse {
	s.Headers = v
	return s
}

func (s *DeleteAggregatorsResponse) SetStatusCode(v int32) *DeleteAggregatorsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteAggregatorsResponse) SetBody(v *DeleteAggregatorsResponseBody) *DeleteAggregatorsResponse {
	s.Body = v
	return s
}

type DeleteCompliancePacksRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The `token` can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the compliance package. Separate multiple compliance package IDs with commas (,).
	//
	// For more information about how to obtain the ID of a compliance package, see [ListCompliancePacks](~~263332~~).
	CompliancePackIds *string `json:"CompliancePackIds,omitempty" xml:"CompliancePackIds,omitempty"`
	// Specifies whether to delete the rules in the compliance package. Valid values:
	//
	// *   true: The rules are deleted.
	// *   false (default): The rules are not deleted.
	DeleteRule *bool `json:"DeleteRule,omitempty" xml:"DeleteRule,omitempty"`
}

func (s DeleteCompliancePacksRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCompliancePacksRequest) GoString() string {
	return s.String()
}

func (s *DeleteCompliancePacksRequest) SetClientToken(v string) *DeleteCompliancePacksRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteCompliancePacksRequest) SetCompliancePackIds(v string) *DeleteCompliancePacksRequest {
	s.CompliancePackIds = &v
	return s
}

func (s *DeleteCompliancePacksRequest) SetDeleteRule(v bool) *DeleteCompliancePacksRequest {
	s.DeleteRule = &v
	return s
}

type DeleteCompliancePacksResponseBody struct {
	// The returned result.
	OperateCompliancePacksResult *DeleteCompliancePacksResponseBodyOperateCompliancePacksResult `json:"OperateCompliancePacksResult,omitempty" xml:"OperateCompliancePacksResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCompliancePacksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCompliancePacksResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCompliancePacksResponseBody) SetOperateCompliancePacksResult(v *DeleteCompliancePacksResponseBodyOperateCompliancePacksResult) *DeleteCompliancePacksResponseBody {
	s.OperateCompliancePacksResult = v
	return s
}

func (s *DeleteCompliancePacksResponseBody) SetRequestId(v string) *DeleteCompliancePacksResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCompliancePacksResponseBodyOperateCompliancePacksResult struct {
	// An array that contains compliance packages that are deleted.
	OperateCompliancePacks []*DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks `json:"OperateCompliancePacks,omitempty" xml:"OperateCompliancePacks,omitempty" type:"Repeated"`
}

func (s DeleteCompliancePacksResponseBodyOperateCompliancePacksResult) String() string {
	return tea.Prettify(s)
}

func (s DeleteCompliancePacksResponseBodyOperateCompliancePacksResult) GoString() string {
	return s.String()
}

func (s *DeleteCompliancePacksResponseBodyOperateCompliancePacksResult) SetOperateCompliancePacks(v []*DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks) *DeleteCompliancePacksResponseBodyOperateCompliancePacksResult {
	s.OperateCompliancePacks = v
	return s
}

type DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks struct {
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The error code returned.
	//
	// *   If the compliance package is deleted, no error code is returned.
	// *   If the compliance package fails to be deleted, an error code is returned. For more information about error codes, see [Error codes](https://error-center.alibabacloud.com/status/product/Config).
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks) String() string {
	return tea.Prettify(s)
}

func (s DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks) GoString() string {
	return s.String()
}

func (s *DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks) SetCompliancePackId(v string) *DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks {
	s.CompliancePackId = &v
	return s
}

func (s *DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks) SetErrorCode(v string) *DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks {
	s.ErrorCode = &v
	return s
}

func (s *DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks) SetSuccess(v bool) *DeleteCompliancePacksResponseBodyOperateCompliancePacksResultOperateCompliancePacks {
	s.Success = &v
	return s
}

type DeleteCompliancePacksResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCompliancePacksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCompliancePacksResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCompliancePacksResponse) GoString() string {
	return s.String()
}

func (s *DeleteCompliancePacksResponse) SetHeaders(v map[string]*string) *DeleteCompliancePacksResponse {
	s.Headers = v
	return s
}

func (s *DeleteCompliancePacksResponse) SetStatusCode(v int32) *DeleteCompliancePacksResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCompliancePacksResponse) SetBody(v *DeleteCompliancePacksResponseBody) *DeleteCompliancePacksResponse {
	s.Body = v
	return s
}

type DeleteConfigDeliveryChannelRequest struct {
	// The ID of the delivery channel.
	//
	// For more information about how to obtain the ID of a delivery channel, see [DescribeDeliveryChannels](~~429841~~).
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
}

func (s DeleteConfigDeliveryChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteConfigDeliveryChannelRequest) GoString() string {
	return s.String()
}

func (s *DeleteConfigDeliveryChannelRequest) SetDeliveryChannelId(v string) *DeleteConfigDeliveryChannelRequest {
	s.DeliveryChannelId = &v
	return s
}

type DeleteConfigDeliveryChannelResponseBody struct {
	// The ID of the delivery channel.
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteConfigDeliveryChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteConfigDeliveryChannelResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteConfigDeliveryChannelResponseBody) SetDeliveryChannelId(v string) *DeleteConfigDeliveryChannelResponseBody {
	s.DeliveryChannelId = &v
	return s
}

func (s *DeleteConfigDeliveryChannelResponseBody) SetRequestId(v string) *DeleteConfigDeliveryChannelResponseBody {
	s.RequestId = &v
	return s
}

type DeleteConfigDeliveryChannelResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteConfigDeliveryChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteConfigDeliveryChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteConfigDeliveryChannelResponse) GoString() string {
	return s.String()
}

func (s *DeleteConfigDeliveryChannelResponse) SetHeaders(v map[string]*string) *DeleteConfigDeliveryChannelResponse {
	s.Headers = v
	return s
}

func (s *DeleteConfigDeliveryChannelResponse) SetStatusCode(v int32) *DeleteConfigDeliveryChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteConfigDeliveryChannelResponse) SetBody(v *DeleteConfigDeliveryChannelResponseBody) *DeleteConfigDeliveryChannelResponse {
	s.Body = v
	return s
}

type DeleteConfigRulesRequest struct {
	// The rule IDs. Separate multiple rule IDs with commas (,).
	//
	// For more information about how to obtain the ID of a rule, see ListConfigRules.
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s DeleteConfigRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteConfigRulesRequest) GoString() string {
	return s.String()
}

func (s *DeleteConfigRulesRequest) SetConfigRuleIds(v string) *DeleteConfigRulesRequest {
	s.ConfigRuleIds = &v
	return s
}

type DeleteConfigRulesResponseBody struct {
	// The results of the delete operations.
	OperateRuleResult *DeleteConfigRulesResponseBodyOperateRuleResult `json:"OperateRuleResult,omitempty" xml:"OperateRuleResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteConfigRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteConfigRulesResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteConfigRulesResponseBody) SetOperateRuleResult(v *DeleteConfigRulesResponseBodyOperateRuleResult) *DeleteConfigRulesResponseBody {
	s.OperateRuleResult = v
	return s
}

func (s *DeleteConfigRulesResponseBody) SetRequestId(v string) *DeleteConfigRulesResponseBody {
	s.RequestId = &v
	return s
}

type DeleteConfigRulesResponseBodyOperateRuleResult struct {
	// The result of the delete operation.
	OperateRuleItemList []*DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList `json:"OperateRuleItemList,omitempty" xml:"OperateRuleItemList,omitempty" type:"Repeated"`
}

func (s DeleteConfigRulesResponseBodyOperateRuleResult) String() string {
	return tea.Prettify(s)
}

func (s DeleteConfigRulesResponseBodyOperateRuleResult) GoString() string {
	return s.String()
}

func (s *DeleteConfigRulesResponseBodyOperateRuleResult) SetOperateRuleItemList(v []*DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) *DeleteConfigRulesResponseBodyOperateRuleResult {
	s.OperateRuleItemList = v
	return s
}

type DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList struct {
	// The rule ID.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The error code returned if the request failed.
	//
	// *   If the rule is deleted, no error code is returned.
	// *   If the rule fails to be deleted, an error code is returned. For more information about error codes, see [Error codes](https://api.aliyun.com/document/Config/2020-09-07/errorCode).
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true
	// *   false
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) String() string {
	return tea.Prettify(s)
}

func (s DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) GoString() string {
	return s.String()
}

func (s *DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetConfigRuleId(v string) *DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.ConfigRuleId = &v
	return s
}

func (s *DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetErrorCode(v string) *DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.ErrorCode = &v
	return s
}

func (s *DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList) SetSuccess(v bool) *DeleteConfigRulesResponseBodyOperateRuleResultOperateRuleItemList {
	s.Success = &v
	return s
}

type DeleteConfigRulesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteConfigRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteConfigRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteConfigRulesResponse) GoString() string {
	return s.String()
}

func (s *DeleteConfigRulesResponse) SetHeaders(v map[string]*string) *DeleteConfigRulesResponse {
	s.Headers = v
	return s
}

func (s *DeleteConfigRulesResponse) SetStatusCode(v int32) *DeleteConfigRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteConfigRulesResponse) SetBody(v *DeleteConfigRulesResponseBody) *DeleteConfigRulesResponse {
	s.Body = v
	return s
}

type DeleteRemediationsRequest struct {
	// The ID of the remediation template. Separate multiple remediation template IDs with commas (,).
	//
	// For more information about how to obtain the ID of a remediation template, see [ListRemediations](~~270772~~).
	RemediationIds *string `json:"RemediationIds,omitempty" xml:"RemediationIds,omitempty"`
}

func (s DeleteRemediationsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRemediationsRequest) GoString() string {
	return s.String()
}

func (s *DeleteRemediationsRequest) SetRemediationIds(v string) *DeleteRemediationsRequest {
	s.RemediationIds = &v
	return s
}

type DeleteRemediationsResponseBody struct {
	// The returned result.
	RemediationDeleteResults []*DeleteRemediationsResponseBodyRemediationDeleteResults `json:"RemediationDeleteResults,omitempty" xml:"RemediationDeleteResults,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteRemediationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRemediationsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRemediationsResponseBody) SetRemediationDeleteResults(v []*DeleteRemediationsResponseBodyRemediationDeleteResults) *DeleteRemediationsResponseBody {
	s.RemediationDeleteResults = v
	return s
}

func (s *DeleteRemediationsResponseBody) SetRequestId(v string) *DeleteRemediationsResponseBody {
	s.RequestId = &v
	return s
}

type DeleteRemediationsResponseBodyRemediationDeleteResults struct {
	// The error code returned.
	//
	// *   If the remediation template is deleted, no error code is returned.
	// *   If the remediation template fails to be deleted, an error code is returned. For more information about error codes, see [Error codes](https://error-center.alibabacloud.com/status/product/Config).
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the remediation template.
	RemediationId *string `json:"RemediationId,omitempty" xml:"RemediationId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteRemediationsResponseBodyRemediationDeleteResults) String() string {
	return tea.Prettify(s)
}

func (s DeleteRemediationsResponseBodyRemediationDeleteResults) GoString() string {
	return s.String()
}

func (s *DeleteRemediationsResponseBodyRemediationDeleteResults) SetErrorMessage(v string) *DeleteRemediationsResponseBodyRemediationDeleteResults {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteRemediationsResponseBodyRemediationDeleteResults) SetRemediationId(v string) *DeleteRemediationsResponseBodyRemediationDeleteResults {
	s.RemediationId = &v
	return s
}

func (s *DeleteRemediationsResponseBodyRemediationDeleteResults) SetSuccess(v bool) *DeleteRemediationsResponseBodyRemediationDeleteResults {
	s.Success = &v
	return s
}

type DeleteRemediationsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteRemediationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteRemediationsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRemediationsResponse) GoString() string {
	return s.String()
}

func (s *DeleteRemediationsResponse) SetHeaders(v map[string]*string) *DeleteRemediationsResponse {
	s.Headers = v
	return s
}

func (s *DeleteRemediationsResponse) SetStatusCode(v int32) *DeleteRemediationsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRemediationsResponse) SetBody(v *DeleteRemediationsResponseBody) *DeleteRemediationsResponse {
	s.Body = v
	return s
}

type DescribeRemediationRequest struct {
	ConfigRuleId  *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	RemediationId *string `json:"RemediationId,omitempty" xml:"RemediationId,omitempty"`
}

func (s DescribeRemediationRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRemediationRequest) GoString() string {
	return s.String()
}

func (s *DescribeRemediationRequest) SetConfigRuleId(v string) *DescribeRemediationRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *DescribeRemediationRequest) SetRemediationId(v string) *DescribeRemediationRequest {
	s.RemediationId = &v
	return s
}

type DescribeRemediationResponseBody struct {
	Remediation *DescribeRemediationResponseBodyRemediation `json:"Remediation,omitempty" xml:"Remediation,omitempty" type:"Struct"`
	RequestId   *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeRemediationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRemediationResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRemediationResponseBody) SetRemediation(v *DescribeRemediationResponseBodyRemediation) *DescribeRemediationResponseBody {
	s.Remediation = v
	return s
}

func (s *DescribeRemediationResponseBody) SetRequestId(v string) *DescribeRemediationResponseBody {
	s.RequestId = &v
	return s
}

type DescribeRemediationResponseBodyRemediation struct {
	AccountId                    *int64  `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	ConfigRuleId                 *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	InvokeType                   *string `json:"InvokeType,omitempty" xml:"InvokeType,omitempty"`
	LastSuccessfulInvocationId   *string `json:"LastSuccessfulInvocationId,omitempty" xml:"LastSuccessfulInvocationId,omitempty"`
	LastSuccessfulInvocationTime *int64  `json:"LastSuccessfulInvocationTime,omitempty" xml:"LastSuccessfulInvocationTime,omitempty"`
	LastSuccessfulInvocationType *string `json:"LastSuccessfulInvocationType,omitempty" xml:"LastSuccessfulInvocationType,omitempty"`
	RemediationId                *string `json:"RemediationId,omitempty" xml:"RemediationId,omitempty"`
	RemediationOriginParams      *string `json:"RemediationOriginParams,omitempty" xml:"RemediationOriginParams,omitempty"`
	RemediationSourceType        *string `json:"RemediationSourceType,omitempty" xml:"RemediationSourceType,omitempty"`
	RemediationTemplateId        *string `json:"RemediationTemplateId,omitempty" xml:"RemediationTemplateId,omitempty"`
	RemediationType              *string `json:"RemediationType,omitempty" xml:"RemediationType,omitempty"`
}

func (s DescribeRemediationResponseBodyRemediation) String() string {
	return tea.Prettify(s)
}

func (s DescribeRemediationResponseBodyRemediation) GoString() string {
	return s.String()
}

func (s *DescribeRemediationResponseBodyRemediation) SetAccountId(v int64) *DescribeRemediationResponseBodyRemediation {
	s.AccountId = &v
	return s
}

func (s *DescribeRemediationResponseBodyRemediation) SetConfigRuleId(v string) *DescribeRemediationResponseBodyRemediation {
	s.ConfigRuleId = &v
	return s
}

func (s *DescribeRemediationResponseBodyRemediation) SetInvokeType(v string) *DescribeRemediationResponseBodyRemediation {
	s.InvokeType = &v
	return s
}

func (s *DescribeRemediationResponseBodyRemediation) SetLastSuccessfulInvocationId(v string) *DescribeRemediationResponseBodyRemediation {
	s.LastSuccessfulInvocationId = &v
	return s
}

func (s *DescribeRemediationResponseBodyRemediation) SetLastSuccessfulInvocationTime(v int64) *DescribeRemediationResponseBodyRemediation {
	s.LastSuccessfulInvocationTime = &v
	return s
}

func (s *DescribeRemediationResponseBodyRemediation) SetLastSuccessfulInvocationType(v string) *DescribeRemediationResponseBodyRemediation {
	s.LastSuccessfulInvocationType = &v
	return s
}

func (s *DescribeRemediationResponseBodyRemediation) SetRemediationId(v string) *DescribeRemediationResponseBodyRemediation {
	s.RemediationId = &v
	return s
}

func (s *DescribeRemediationResponseBodyRemediation) SetRemediationOriginParams(v string) *DescribeRemediationResponseBodyRemediation {
	s.RemediationOriginParams = &v
	return s
}

func (s *DescribeRemediationResponseBodyRemediation) SetRemediationSourceType(v string) *DescribeRemediationResponseBodyRemediation {
	s.RemediationSourceType = &v
	return s
}

func (s *DescribeRemediationResponseBodyRemediation) SetRemediationTemplateId(v string) *DescribeRemediationResponseBodyRemediation {
	s.RemediationTemplateId = &v
	return s
}

func (s *DescribeRemediationResponseBodyRemediation) SetRemediationType(v string) *DescribeRemediationResponseBodyRemediation {
	s.RemediationType = &v
	return s
}

type DescribeRemediationResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRemediationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRemediationResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRemediationResponse) GoString() string {
	return s.String()
}

func (s *DescribeRemediationResponse) SetHeaders(v map[string]*string) *DescribeRemediationResponse {
	s.Headers = v
	return s
}

func (s *DescribeRemediationResponse) SetStatusCode(v int32) *DescribeRemediationResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRemediationResponse) SetBody(v *DescribeRemediationResponseBody) *DescribeRemediationResponse {
	s.Body = v
	return s
}

type DetachAggregateConfigRuleToCompliancePackRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the compliance package from which you want to remove the rule.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListAggregateCompliancePacks](~~262059~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The ID of the rule to be removed from the compliance package. Separate multiple rule IDs with commas (,).
	//
	// For more information about how to obtain the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s DetachAggregateConfigRuleToCompliancePackRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachAggregateConfigRuleToCompliancePackRequest) GoString() string {
	return s.String()
}

func (s *DetachAggregateConfigRuleToCompliancePackRequest) SetAggregatorId(v string) *DetachAggregateConfigRuleToCompliancePackRequest {
	s.AggregatorId = &v
	return s
}

func (s *DetachAggregateConfigRuleToCompliancePackRequest) SetCompliancePackId(v string) *DetachAggregateConfigRuleToCompliancePackRequest {
	s.CompliancePackId = &v
	return s
}

func (s *DetachAggregateConfigRuleToCompliancePackRequest) SetConfigRuleIds(v string) *DetachAggregateConfigRuleToCompliancePackRequest {
	s.ConfigRuleIds = &v
	return s
}

type DetachAggregateConfigRuleToCompliancePackResponseBody struct {
	// The results of the operations to remove one or more rules.
	OperateRuleResult *DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult `json:"OperateRuleResult,omitempty" xml:"OperateRuleResult,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachAggregateConfigRuleToCompliancePackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachAggregateConfigRuleToCompliancePackResponseBody) GoString() string {
	return s.String()
}

func (s *DetachAggregateConfigRuleToCompliancePackResponseBody) SetOperateRuleResult(v *DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult) *DetachAggregateConfigRuleToCompliancePackResponseBody {
	s.OperateRuleResult = v
	return s
}

func (s *DetachAggregateConfigRuleToCompliancePackResponseBody) SetRequestId(v string) *DetachAggregateConfigRuleToCompliancePackResponseBody {
	s.RequestId = &v
	return s
}

type DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult struct {
	// The result of the operation to remove the rule.
	OperateRuleItemList []*DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList `json:"OperateRuleItemList,omitempty" xml:"OperateRuleItemList,omitempty" type:"Repeated"`
}

func (s DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult) String() string {
	return tea.Prettify(s)
}

func (s DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult) GoString() string {
	return s.String()
}

func (s *DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult) SetOperateRuleItemList(v []*DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) *DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResult {
	s.OperateRuleItemList = v
	return s
}

type DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList struct {
	// The ID of the rule that is removed from the compliance package.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The error code.
	//
	// *   This parameter is empty if the rule is removed from the compliance package.
	//
	// <!---->
	//
	// *   An error code is returned if the rule fails to be removed from the compliance package. For more information about error codes, visit the [API Error Center](https://error-center.alibabacloud.com/status/product/Config).
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the operation is successful. Valid values:
	//
	// *   true: The operation is successful.
	// *   false: The operation fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) String() string {
	return tea.Prettify(s)
}

func (s DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) GoString() string {
	return s.String()
}

func (s *DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) SetConfigRuleId(v string) *DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList {
	s.ConfigRuleId = &v
	return s
}

func (s *DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) SetErrorCode(v string) *DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList {
	s.ErrorCode = &v
	return s
}

func (s *DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) SetSuccess(v bool) *DetachAggregateConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList {
	s.Success = &v
	return s
}

type DetachAggregateConfigRuleToCompliancePackResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachAggregateConfigRuleToCompliancePackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachAggregateConfigRuleToCompliancePackResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachAggregateConfigRuleToCompliancePackResponse) GoString() string {
	return s.String()
}

func (s *DetachAggregateConfigRuleToCompliancePackResponse) SetHeaders(v map[string]*string) *DetachAggregateConfigRuleToCompliancePackResponse {
	s.Headers = v
	return s
}

func (s *DetachAggregateConfigRuleToCompliancePackResponse) SetStatusCode(v int32) *DetachAggregateConfigRuleToCompliancePackResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachAggregateConfigRuleToCompliancePackResponse) SetBody(v *DetachAggregateConfigRuleToCompliancePackResponseBody) *DetachAggregateConfigRuleToCompliancePackResponse {
	s.Body = v
	return s
}

type DetachConfigRuleToCompliancePackRequest struct {
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListCompliancePacks](~~263332~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The rule ID. Separate multiple rule IDs with commas (,).
	//
	// For more information about how to obtain the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s DetachConfigRuleToCompliancePackRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachConfigRuleToCompliancePackRequest) GoString() string {
	return s.String()
}

func (s *DetachConfigRuleToCompliancePackRequest) SetCompliancePackId(v string) *DetachConfigRuleToCompliancePackRequest {
	s.CompliancePackId = &v
	return s
}

func (s *DetachConfigRuleToCompliancePackRequest) SetConfigRuleIds(v string) *DetachConfigRuleToCompliancePackRequest {
	s.ConfigRuleIds = &v
	return s
}

type DetachConfigRuleToCompliancePackResponseBody struct {
	// The results of the operations to remove one or more rules.
	OperateRuleResult *DetachConfigRuleToCompliancePackResponseBodyOperateRuleResult `json:"OperateRuleResult,omitempty" xml:"OperateRuleResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachConfigRuleToCompliancePackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachConfigRuleToCompliancePackResponseBody) GoString() string {
	return s.String()
}

func (s *DetachConfigRuleToCompliancePackResponseBody) SetOperateRuleResult(v *DetachConfigRuleToCompliancePackResponseBodyOperateRuleResult) *DetachConfigRuleToCompliancePackResponseBody {
	s.OperateRuleResult = v
	return s
}

func (s *DetachConfigRuleToCompliancePackResponseBody) SetRequestId(v string) *DetachConfigRuleToCompliancePackResponseBody {
	s.RequestId = &v
	return s
}

type DetachConfigRuleToCompliancePackResponseBodyOperateRuleResult struct {
	// The result of the operation to remove the rule.
	OperateRuleItemList []*DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList `json:"OperateRuleItemList,omitempty" xml:"OperateRuleItemList,omitempty" type:"Repeated"`
}

func (s DetachConfigRuleToCompliancePackResponseBodyOperateRuleResult) String() string {
	return tea.Prettify(s)
}

func (s DetachConfigRuleToCompliancePackResponseBodyOperateRuleResult) GoString() string {
	return s.String()
}

func (s *DetachConfigRuleToCompliancePackResponseBodyOperateRuleResult) SetOperateRuleItemList(v []*DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) *DetachConfigRuleToCompliancePackResponseBodyOperateRuleResult {
	s.OperateRuleItemList = v
	return s
}

type DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList struct {
	// The rule ID.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The error code returned.
	//
	// *   This parameter is empty if the rule is removed from the compliance package.
	// *   An error code is returned if the rule fails to be removed from the compliance package. For more information about error codes, see [Error codes](https://error-center.alibabacloud.com/status/product/Config).
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) String() string {
	return tea.Prettify(s)
}

func (s DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) GoString() string {
	return s.String()
}

func (s *DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) SetConfigRuleId(v string) *DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList {
	s.ConfigRuleId = &v
	return s
}

func (s *DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) SetErrorCode(v string) *DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList {
	s.ErrorCode = &v
	return s
}

func (s *DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList) SetSuccess(v bool) *DetachConfigRuleToCompliancePackResponseBodyOperateRuleResultOperateRuleItemList {
	s.Success = &v
	return s
}

type DetachConfigRuleToCompliancePackResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachConfigRuleToCompliancePackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachConfigRuleToCompliancePackResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachConfigRuleToCompliancePackResponse) GoString() string {
	return s.String()
}

func (s *DetachConfigRuleToCompliancePackResponse) SetHeaders(v map[string]*string) *DetachConfigRuleToCompliancePackResponse {
	s.Headers = v
	return s
}

func (s *DetachConfigRuleToCompliancePackResponse) SetStatusCode(v int32) *DetachConfigRuleToCompliancePackResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachConfigRuleToCompliancePackResponse) SetBody(v *DetachConfigRuleToCompliancePackResponseBody) *DetachConfigRuleToCompliancePackResponse {
	s.Body = v
	return s
}

type EvaluatePreConfigRulesRequest struct {
	// Specifies whether to enable the managed rule. Valid values:
	//
	// *   true: enables the managed rule.
	// *   false: does not enable the managed rule. This is the default value.
	//
	// >  After you create an evaluation rule, a managed rule that has the same settings as the evaluation rule is created. After you create a resource, the managed rule can be used to continuously check the compliance of the resource.
	EnableManagedRules *bool `json:"EnableManagedRules,omitempty" xml:"EnableManagedRules,omitempty"`
	// The resources that you want to evaluate.
	ResourceEvaluateItems []*EvaluatePreConfigRulesRequestResourceEvaluateItems `json:"ResourceEvaluateItems,omitempty" xml:"ResourceEvaluateItems,omitempty" type:"Repeated"`
}

func (s EvaluatePreConfigRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s EvaluatePreConfigRulesRequest) GoString() string {
	return s.String()
}

func (s *EvaluatePreConfigRulesRequest) SetEnableManagedRules(v bool) *EvaluatePreConfigRulesRequest {
	s.EnableManagedRules = &v
	return s
}

func (s *EvaluatePreConfigRulesRequest) SetResourceEvaluateItems(v []*EvaluatePreConfigRulesRequestResourceEvaluateItems) *EvaluatePreConfigRulesRequest {
	s.ResourceEvaluateItems = v
	return s
}

type EvaluatePreConfigRulesRequestResourceEvaluateItems struct {
	// The logical ID of the resource.
	ResourceLogicalId *string `json:"ResourceLogicalId,omitempty" xml:"ResourceLogicalId,omitempty"`
	// The properties of the resource.
	ResourceProperties *string `json:"ResourceProperties,omitempty" xml:"ResourceProperties,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The evaluation rules.
	Rules []*EvaluatePreConfigRulesRequestResourceEvaluateItemsRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Repeated"`
}

func (s EvaluatePreConfigRulesRequestResourceEvaluateItems) String() string {
	return tea.Prettify(s)
}

func (s EvaluatePreConfigRulesRequestResourceEvaluateItems) GoString() string {
	return s.String()
}

func (s *EvaluatePreConfigRulesRequestResourceEvaluateItems) SetResourceLogicalId(v string) *EvaluatePreConfigRulesRequestResourceEvaluateItems {
	s.ResourceLogicalId = &v
	return s
}

func (s *EvaluatePreConfigRulesRequestResourceEvaluateItems) SetResourceProperties(v string) *EvaluatePreConfigRulesRequestResourceEvaluateItems {
	s.ResourceProperties = &v
	return s
}

func (s *EvaluatePreConfigRulesRequestResourceEvaluateItems) SetResourceType(v string) *EvaluatePreConfigRulesRequestResourceEvaluateItems {
	s.ResourceType = &v
	return s
}

func (s *EvaluatePreConfigRulesRequestResourceEvaluateItems) SetRules(v []*EvaluatePreConfigRulesRequestResourceEvaluateItemsRules) *EvaluatePreConfigRulesRequestResourceEvaluateItems {
	s.Rules = v
	return s
}

type EvaluatePreConfigRulesRequestResourceEvaluateItemsRules struct {
	// The identifier of the evaluation rule.
	//
	// For more information about how to obtain the identifier of an evaluation rule, see [ListManagedRules](~~467810~~).
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The input parameters of the evaluation rule.
	InputParameters *string `json:"InputParameters,omitempty" xml:"InputParameters,omitempty"`
}

func (s EvaluatePreConfigRulesRequestResourceEvaluateItemsRules) String() string {
	return tea.Prettify(s)
}

func (s EvaluatePreConfigRulesRequestResourceEvaluateItemsRules) GoString() string {
	return s.String()
}

func (s *EvaluatePreConfigRulesRequestResourceEvaluateItemsRules) SetIdentifier(v string) *EvaluatePreConfigRulesRequestResourceEvaluateItemsRules {
	s.Identifier = &v
	return s
}

func (s *EvaluatePreConfigRulesRequestResourceEvaluateItemsRules) SetInputParameters(v string) *EvaluatePreConfigRulesRequestResourceEvaluateItemsRules {
	s.InputParameters = &v
	return s
}

type EvaluatePreConfigRulesShrinkRequest struct {
	// Specifies whether to enable the managed rule. Valid values:
	//
	// *   true: enables the managed rule.
	// *   false: does not enable the managed rule. This is the default value.
	//
	// >  After you create an evaluation rule, a managed rule that has the same settings as the evaluation rule is created. After you create a resource, the managed rule can be used to continuously check the compliance of the resource.
	EnableManagedRules *bool `json:"EnableManagedRules,omitempty" xml:"EnableManagedRules,omitempty"`
	// The resources that you want to evaluate.
	ResourceEvaluateItemsShrink *string `json:"ResourceEvaluateItems,omitempty" xml:"ResourceEvaluateItems,omitempty"`
}

func (s EvaluatePreConfigRulesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s EvaluatePreConfigRulesShrinkRequest) GoString() string {
	return s.String()
}

func (s *EvaluatePreConfigRulesShrinkRequest) SetEnableManagedRules(v bool) *EvaluatePreConfigRulesShrinkRequest {
	s.EnableManagedRules = &v
	return s
}

func (s *EvaluatePreConfigRulesShrinkRequest) SetResourceEvaluateItemsShrink(v string) *EvaluatePreConfigRulesShrinkRequest {
	s.ResourceEvaluateItemsShrink = &v
	return s
}

type EvaluatePreConfigRulesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the compliance evaluation result.
	ResourceEvaluations []*EvaluatePreConfigRulesResponseBodyResourceEvaluations `json:"ResourceEvaluations,omitempty" xml:"ResourceEvaluations,omitempty" type:"Repeated"`
}

func (s EvaluatePreConfigRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EvaluatePreConfigRulesResponseBody) GoString() string {
	return s.String()
}

func (s *EvaluatePreConfigRulesResponseBody) SetRequestId(v string) *EvaluatePreConfigRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *EvaluatePreConfigRulesResponseBody) SetResourceEvaluations(v []*EvaluatePreConfigRulesResponseBodyResourceEvaluations) *EvaluatePreConfigRulesResponseBody {
	s.ResourceEvaluations = v
	return s
}

type EvaluatePreConfigRulesResponseBodyResourceEvaluations struct {
	// The logical ID of the resource.
	//
	// >  If the ResourceLogicalId request parameter is left empty, the value of the ResourceLogicalId response parameter is generated based on the value of the `ResourceProperties` parameter.
	ResourceLogicalId *string `json:"ResourceLogicalId,omitempty" xml:"ResourceLogicalId,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The evaluation rules.
	Rules []*EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Repeated"`
}

func (s EvaluatePreConfigRulesResponseBodyResourceEvaluations) String() string {
	return tea.Prettify(s)
}

func (s EvaluatePreConfigRulesResponseBodyResourceEvaluations) GoString() string {
	return s.String()
}

func (s *EvaluatePreConfigRulesResponseBodyResourceEvaluations) SetResourceLogicalId(v string) *EvaluatePreConfigRulesResponseBodyResourceEvaluations {
	s.ResourceLogicalId = &v
	return s
}

func (s *EvaluatePreConfigRulesResponseBodyResourceEvaluations) SetResourceType(v string) *EvaluatePreConfigRulesResponseBodyResourceEvaluations {
	s.ResourceType = &v
	return s
}

func (s *EvaluatePreConfigRulesResponseBodyResourceEvaluations) SetRules(v []*EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules) *EvaluatePreConfigRulesResponseBodyResourceEvaluations {
	s.Rules = v
	return s
}

type EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules struct {
	// The reason why the resource was evaluated as incompliant.
	Annotation *string `json:"Annotation,omitempty" xml:"Annotation,omitempty"`
	// The compliance type of the resource that was evaluated by using the evaluation rule. Valid values:
	//
	// *   COMPLIANT: The resource was evaluated as compliant.
	// *   NON_COMPLIANT: The resource was evaluated as incompliant.
	// *   NOT_APPLICABLE: The evaluation rule does not apply to the resource.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The URL of the topic that describes how the managed rule remediates the incompliant configurations.
	HelpUrl *string `json:"HelpUrl,omitempty" xml:"HelpUrl,omitempty"`
	// The identifier of the evaluation rule.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
}

func (s EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules) String() string {
	return tea.Prettify(s)
}

func (s EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules) GoString() string {
	return s.String()
}

func (s *EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules) SetAnnotation(v string) *EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules {
	s.Annotation = &v
	return s
}

func (s *EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules) SetComplianceType(v string) *EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules {
	s.ComplianceType = &v
	return s
}

func (s *EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules) SetHelpUrl(v string) *EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules {
	s.HelpUrl = &v
	return s
}

func (s *EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules) SetIdentifier(v string) *EvaluatePreConfigRulesResponseBodyResourceEvaluationsRules {
	s.Identifier = &v
	return s
}

type EvaluatePreConfigRulesResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EvaluatePreConfigRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EvaluatePreConfigRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s EvaluatePreConfigRulesResponse) GoString() string {
	return s.String()
}

func (s *EvaluatePreConfigRulesResponse) SetHeaders(v map[string]*string) *EvaluatePreConfigRulesResponse {
	s.Headers = v
	return s
}

func (s *EvaluatePreConfigRulesResponse) SetStatusCode(v int32) *EvaluatePreConfigRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *EvaluatePreConfigRulesResponse) SetBody(v *EvaluatePreConfigRulesResponseBody) *EvaluatePreConfigRulesResponse {
	s.Body = v
	return s
}

type GenerateAggregateCompliancePackReportRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The `token` can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListAggregateCompliancePacks](~~262059~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
}

func (s GenerateAggregateCompliancePackReportRequest) String() string {
	return tea.Prettify(s)
}

func (s GenerateAggregateCompliancePackReportRequest) GoString() string {
	return s.String()
}

func (s *GenerateAggregateCompliancePackReportRequest) SetAggregatorId(v string) *GenerateAggregateCompliancePackReportRequest {
	s.AggregatorId = &v
	return s
}

func (s *GenerateAggregateCompliancePackReportRequest) SetClientToken(v string) *GenerateAggregateCompliancePackReportRequest {
	s.ClientToken = &v
	return s
}

func (s *GenerateAggregateCompliancePackReportRequest) SetCompliancePackId(v string) *GenerateAggregateCompliancePackReportRequest {
	s.CompliancePackId = &v
	return s
}

type GenerateAggregateCompliancePackReportResponseBody struct {
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GenerateAggregateCompliancePackReportResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GenerateAggregateCompliancePackReportResponseBody) GoString() string {
	return s.String()
}

func (s *GenerateAggregateCompliancePackReportResponseBody) SetCompliancePackId(v string) *GenerateAggregateCompliancePackReportResponseBody {
	s.CompliancePackId = &v
	return s
}

func (s *GenerateAggregateCompliancePackReportResponseBody) SetRequestId(v string) *GenerateAggregateCompliancePackReportResponseBody {
	s.RequestId = &v
	return s
}

type GenerateAggregateCompliancePackReportResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GenerateAggregateCompliancePackReportResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GenerateAggregateCompliancePackReportResponse) String() string {
	return tea.Prettify(s)
}

func (s GenerateAggregateCompliancePackReportResponse) GoString() string {
	return s.String()
}

func (s *GenerateAggregateCompliancePackReportResponse) SetHeaders(v map[string]*string) *GenerateAggregateCompliancePackReportResponse {
	s.Headers = v
	return s
}

func (s *GenerateAggregateCompliancePackReportResponse) SetStatusCode(v int32) *GenerateAggregateCompliancePackReportResponse {
	s.StatusCode = &v
	return s
}

func (s *GenerateAggregateCompliancePackReportResponse) SetBody(v *GenerateAggregateCompliancePackReportResponseBody) *GenerateAggregateCompliancePackReportResponse {
	s.Body = v
	return s
}

type GenerateAggregateConfigRulesReportRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The `token` can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The rule ID. Separate multiple rule IDs with commas (,).
	//
	// For more information about how to obtain the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s GenerateAggregateConfigRulesReportRequest) String() string {
	return tea.Prettify(s)
}

func (s GenerateAggregateConfigRulesReportRequest) GoString() string {
	return s.String()
}

func (s *GenerateAggregateConfigRulesReportRequest) SetAggregatorId(v string) *GenerateAggregateConfigRulesReportRequest {
	s.AggregatorId = &v
	return s
}

func (s *GenerateAggregateConfigRulesReportRequest) SetClientToken(v string) *GenerateAggregateConfigRulesReportRequest {
	s.ClientToken = &v
	return s
}

func (s *GenerateAggregateConfigRulesReportRequest) SetConfigRuleIds(v string) *GenerateAggregateConfigRulesReportRequest {
	s.ConfigRuleIds = &v
	return s
}

type GenerateAggregateConfigRulesReportResponseBody struct {
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the compliance evaluation report.
	ReportId *string `json:"ReportId,omitempty" xml:"ReportId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GenerateAggregateConfigRulesReportResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GenerateAggregateConfigRulesReportResponseBody) GoString() string {
	return s.String()
}

func (s *GenerateAggregateConfigRulesReportResponseBody) SetAggregatorId(v string) *GenerateAggregateConfigRulesReportResponseBody {
	s.AggregatorId = &v
	return s
}

func (s *GenerateAggregateConfigRulesReportResponseBody) SetReportId(v string) *GenerateAggregateConfigRulesReportResponseBody {
	s.ReportId = &v
	return s
}

func (s *GenerateAggregateConfigRulesReportResponseBody) SetRequestId(v string) *GenerateAggregateConfigRulesReportResponseBody {
	s.RequestId = &v
	return s
}

type GenerateAggregateConfigRulesReportResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GenerateAggregateConfigRulesReportResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GenerateAggregateConfigRulesReportResponse) String() string {
	return tea.Prettify(s)
}

func (s GenerateAggregateConfigRulesReportResponse) GoString() string {
	return s.String()
}

func (s *GenerateAggregateConfigRulesReportResponse) SetHeaders(v map[string]*string) *GenerateAggregateConfigRulesReportResponse {
	s.Headers = v
	return s
}

func (s *GenerateAggregateConfigRulesReportResponse) SetStatusCode(v int32) *GenerateAggregateConfigRulesReportResponse {
	s.StatusCode = &v
	return s
}

func (s *GenerateAggregateConfigRulesReportResponse) SetBody(v *GenerateAggregateConfigRulesReportResponseBody) *GenerateAggregateConfigRulesReportResponse {
	s.Body = v
	return s
}

type GenerateAggregateResourceInventoryRequest struct {
	AccountIds    *string `json:"AccountIds,omitempty" xml:"AccountIds,omitempty"`
	AggregatorId  *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	Regions       *string `json:"Regions,omitempty" xml:"Regions,omitempty"`
	ResourceTypes *string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty"`
}

func (s GenerateAggregateResourceInventoryRequest) String() string {
	return tea.Prettify(s)
}

func (s GenerateAggregateResourceInventoryRequest) GoString() string {
	return s.String()
}

func (s *GenerateAggregateResourceInventoryRequest) SetAccountIds(v string) *GenerateAggregateResourceInventoryRequest {
	s.AccountIds = &v
	return s
}

func (s *GenerateAggregateResourceInventoryRequest) SetAggregatorId(v string) *GenerateAggregateResourceInventoryRequest {
	s.AggregatorId = &v
	return s
}

func (s *GenerateAggregateResourceInventoryRequest) SetRegions(v string) *GenerateAggregateResourceInventoryRequest {
	s.Regions = &v
	return s
}

func (s *GenerateAggregateResourceInventoryRequest) SetResourceTypes(v string) *GenerateAggregateResourceInventoryRequest {
	s.ResourceTypes = &v
	return s
}

type GenerateAggregateResourceInventoryResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GenerateAggregateResourceInventoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GenerateAggregateResourceInventoryResponseBody) GoString() string {
	return s.String()
}

func (s *GenerateAggregateResourceInventoryResponseBody) SetRequestId(v string) *GenerateAggregateResourceInventoryResponseBody {
	s.RequestId = &v
	return s
}

type GenerateAggregateResourceInventoryResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GenerateAggregateResourceInventoryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GenerateAggregateResourceInventoryResponse) String() string {
	return tea.Prettify(s)
}

func (s GenerateAggregateResourceInventoryResponse) GoString() string {
	return s.String()
}

func (s *GenerateAggregateResourceInventoryResponse) SetHeaders(v map[string]*string) *GenerateAggregateResourceInventoryResponse {
	s.Headers = v
	return s
}

func (s *GenerateAggregateResourceInventoryResponse) SetStatusCode(v int32) *GenerateAggregateResourceInventoryResponse {
	s.StatusCode = &v
	return s
}

func (s *GenerateAggregateResourceInventoryResponse) SetBody(v *GenerateAggregateResourceInventoryResponseBody) *GenerateAggregateResourceInventoryResponse {
	s.Body = v
	return s
}

type GenerateCompliancePackReportRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The `token` can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListCompliancePacks](~~263332~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
}

func (s GenerateCompliancePackReportRequest) String() string {
	return tea.Prettify(s)
}

func (s GenerateCompliancePackReportRequest) GoString() string {
	return s.String()
}

func (s *GenerateCompliancePackReportRequest) SetClientToken(v string) *GenerateCompliancePackReportRequest {
	s.ClientToken = &v
	return s
}

func (s *GenerateCompliancePackReportRequest) SetCompliancePackId(v string) *GenerateCompliancePackReportRequest {
	s.CompliancePackId = &v
	return s
}

type GenerateCompliancePackReportResponseBody struct {
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GenerateCompliancePackReportResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GenerateCompliancePackReportResponseBody) GoString() string {
	return s.String()
}

func (s *GenerateCompliancePackReportResponseBody) SetCompliancePackId(v string) *GenerateCompliancePackReportResponseBody {
	s.CompliancePackId = &v
	return s
}

func (s *GenerateCompliancePackReportResponseBody) SetRequestId(v string) *GenerateCompliancePackReportResponseBody {
	s.RequestId = &v
	return s
}

type GenerateCompliancePackReportResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GenerateCompliancePackReportResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GenerateCompliancePackReportResponse) String() string {
	return tea.Prettify(s)
}

func (s GenerateCompliancePackReportResponse) GoString() string {
	return s.String()
}

func (s *GenerateCompliancePackReportResponse) SetHeaders(v map[string]*string) *GenerateCompliancePackReportResponse {
	s.Headers = v
	return s
}

func (s *GenerateCompliancePackReportResponse) SetStatusCode(v int32) *GenerateCompliancePackReportResponse {
	s.StatusCode = &v
	return s
}

func (s *GenerateCompliancePackReportResponse) SetBody(v *GenerateCompliancePackReportResponseBody) *GenerateCompliancePackReportResponse {
	s.Body = v
	return s
}

type GenerateConfigRulesReportRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the rule. Separate multiple rule IDs with commas (,).
	//
	// For more information about how to query the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s GenerateConfigRulesReportRequest) String() string {
	return tea.Prettify(s)
}

func (s GenerateConfigRulesReportRequest) GoString() string {
	return s.String()
}

func (s *GenerateConfigRulesReportRequest) SetClientToken(v string) *GenerateConfigRulesReportRequest {
	s.ClientToken = &v
	return s
}

func (s *GenerateConfigRulesReportRequest) SetConfigRuleIds(v string) *GenerateConfigRulesReportRequest {
	s.ConfigRuleIds = &v
	return s
}

type GenerateConfigRulesReportResponseBody struct {
	// The ID of the compliance evaluation report.
	ReportId *string `json:"ReportId,omitempty" xml:"ReportId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GenerateConfigRulesReportResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GenerateConfigRulesReportResponseBody) GoString() string {
	return s.String()
}

func (s *GenerateConfigRulesReportResponseBody) SetReportId(v string) *GenerateConfigRulesReportResponseBody {
	s.ReportId = &v
	return s
}

func (s *GenerateConfigRulesReportResponseBody) SetRequestId(v string) *GenerateConfigRulesReportResponseBody {
	s.RequestId = &v
	return s
}

type GenerateConfigRulesReportResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GenerateConfigRulesReportResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GenerateConfigRulesReportResponse) String() string {
	return tea.Prettify(s)
}

func (s GenerateConfigRulesReportResponse) GoString() string {
	return s.String()
}

func (s *GenerateConfigRulesReportResponse) SetHeaders(v map[string]*string) *GenerateConfigRulesReportResponse {
	s.Headers = v
	return s
}

func (s *GenerateConfigRulesReportResponse) SetStatusCode(v int32) *GenerateConfigRulesReportResponse {
	s.StatusCode = &v
	return s
}

func (s *GenerateConfigRulesReportResponse) SetBody(v *GenerateConfigRulesReportResponseBody) *GenerateConfigRulesReportResponse {
	s.Body = v
	return s
}

type GenerateResourceInventoryRequest struct {
	Regions       *string `json:"Regions,omitempty" xml:"Regions,omitempty"`
	ResourceTypes *string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty"`
}

func (s GenerateResourceInventoryRequest) String() string {
	return tea.Prettify(s)
}

func (s GenerateResourceInventoryRequest) GoString() string {
	return s.String()
}

func (s *GenerateResourceInventoryRequest) SetRegions(v string) *GenerateResourceInventoryRequest {
	s.Regions = &v
	return s
}

func (s *GenerateResourceInventoryRequest) SetResourceTypes(v string) *GenerateResourceInventoryRequest {
	s.ResourceTypes = &v
	return s
}

type GenerateResourceInventoryResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GenerateResourceInventoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GenerateResourceInventoryResponseBody) GoString() string {
	return s.String()
}

func (s *GenerateResourceInventoryResponseBody) SetRequestId(v string) *GenerateResourceInventoryResponseBody {
	s.RequestId = &v
	return s
}

type GenerateResourceInventoryResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GenerateResourceInventoryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GenerateResourceInventoryResponse) String() string {
	return tea.Prettify(s)
}

func (s GenerateResourceInventoryResponse) GoString() string {
	return s.String()
}

func (s *GenerateResourceInventoryResponse) SetHeaders(v map[string]*string) *GenerateResourceInventoryResponse {
	s.Headers = v
	return s
}

func (s *GenerateResourceInventoryResponse) SetStatusCode(v int32) *GenerateResourceInventoryResponse {
	s.StatusCode = &v
	return s
}

func (s *GenerateResourceInventoryResponse) SetBody(v *GenerateResourceInventoryResponseBody) *GenerateResourceInventoryResponse {
	s.Body = v
	return s
}

type GetAdvancedSearchFileResponseBody struct {
	RequestId      *string                                          `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ResourceSearch *GetAdvancedSearchFileResponseBodyResourceSearch `json:"ResourceSearch,omitempty" xml:"ResourceSearch,omitempty" type:"Struct"`
}

func (s GetAdvancedSearchFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAdvancedSearchFileResponseBody) GoString() string {
	return s.String()
}

func (s *GetAdvancedSearchFileResponseBody) SetRequestId(v string) *GetAdvancedSearchFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAdvancedSearchFileResponseBody) SetResourceSearch(v *GetAdvancedSearchFileResponseBodyResourceSearch) *GetAdvancedSearchFileResponseBody {
	s.ResourceSearch = v
	return s
}

type GetAdvancedSearchFileResponseBodyResourceSearch struct {
	DownloadUrl                   *string `json:"DownloadUrl,omitempty" xml:"DownloadUrl,omitempty"`
	ResourceInventoryGenerateTime *int64  `json:"ResourceInventoryGenerateTime,omitempty" xml:"ResourceInventoryGenerateTime,omitempty"`
	Status                        *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetAdvancedSearchFileResponseBodyResourceSearch) String() string {
	return tea.Prettify(s)
}

func (s GetAdvancedSearchFileResponseBodyResourceSearch) GoString() string {
	return s.String()
}

func (s *GetAdvancedSearchFileResponseBodyResourceSearch) SetDownloadUrl(v string) *GetAdvancedSearchFileResponseBodyResourceSearch {
	s.DownloadUrl = &v
	return s
}

func (s *GetAdvancedSearchFileResponseBodyResourceSearch) SetResourceInventoryGenerateTime(v int64) *GetAdvancedSearchFileResponseBodyResourceSearch {
	s.ResourceInventoryGenerateTime = &v
	return s
}

func (s *GetAdvancedSearchFileResponseBodyResourceSearch) SetStatus(v string) *GetAdvancedSearchFileResponseBodyResourceSearch {
	s.Status = &v
	return s
}

type GetAdvancedSearchFileResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAdvancedSearchFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAdvancedSearchFileResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAdvancedSearchFileResponse) GoString() string {
	return s.String()
}

func (s *GetAdvancedSearchFileResponse) SetHeaders(v map[string]*string) *GetAdvancedSearchFileResponse {
	s.Headers = v
	return s
}

func (s *GetAdvancedSearchFileResponse) SetStatusCode(v int32) *GetAdvancedSearchFileResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAdvancedSearchFileResponse) SetBody(v *GetAdvancedSearchFileResponseBody) *GetAdvancedSearchFileResponse {
	s.Body = v
	return s
}

type GetAggregateAccountComplianceByPackRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListAggregateCompliancePacks](~~262059~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
}

func (s GetAggregateAccountComplianceByPackRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateAccountComplianceByPackRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateAccountComplianceByPackRequest) SetAggregatorId(v string) *GetAggregateAccountComplianceByPackRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateAccountComplianceByPackRequest) SetCompliancePackId(v string) *GetAggregateAccountComplianceByPackRequest {
	s.CompliancePackId = &v
	return s
}

type GetAggregateAccountComplianceByPackResponseBody struct {
	// The compliance evaluation results of member accounts for which the compliance package takes effect in an account group.
	AccountComplianceResult *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult `json:"AccountComplianceResult,omitempty" xml:"AccountComplianceResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregateAccountComplianceByPackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateAccountComplianceByPackResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateAccountComplianceByPackResponseBody) SetAccountComplianceResult(v *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult) *GetAggregateAccountComplianceByPackResponseBody {
	s.AccountComplianceResult = v
	return s
}

func (s *GetAggregateAccountComplianceByPackResponseBody) SetRequestId(v string) *GetAggregateAccountComplianceByPackResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult struct {
	// The compliance evaluation result of member accounts.
	AccountCompliances []*GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances `json:"AccountCompliances,omitempty" xml:"AccountCompliances,omitempty" type:"Repeated"`
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The number of non-compliant member accounts.
	NonCompliantCount *int32 `json:"NonCompliantCount,omitempty" xml:"NonCompliantCount,omitempty"`
	// The total number of member accounts.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult) GoString() string {
	return s.String()
}

func (s *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult) SetAccountCompliances(v []*GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances) *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult {
	s.AccountCompliances = v
	return s
}

func (s *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult) SetCompliancePackId(v string) *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult {
	s.CompliancePackId = &v
	return s
}

func (s *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult) SetNonCompliantCount(v int32) *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult {
	s.NonCompliantCount = &v
	return s
}

func (s *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult) SetTotalCount(v int32) *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResult {
	s.TotalCount = &v
	return s
}

type GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances struct {
	// The ID of the member account in the account group.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The name of the member account in the account group.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The compliance evaluation result. Valid values:
	//
	// *   COMPLIANT: The resource was evaluated as compliant.
	// *   NON_COMPLIANT: The resource was evaluated as incompliant.
	// *   NOT_APPLICABLE: The rule did not apply to your resource.
	// *   INSUFFICIENT_DATA: No resource data was available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
}

func (s GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances) GoString() string {
	return s.String()
}

func (s *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances) SetAccountId(v int64) *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances {
	s.AccountId = &v
	return s
}

func (s *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances) SetAccountName(v string) *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances {
	s.AccountName = &v
	return s
}

func (s *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances) SetComplianceType(v string) *GetAggregateAccountComplianceByPackResponseBodyAccountComplianceResultAccountCompliances {
	s.ComplianceType = &v
	return s
}

type GetAggregateAccountComplianceByPackResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateAccountComplianceByPackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateAccountComplianceByPackResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateAccountComplianceByPackResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateAccountComplianceByPackResponse) SetHeaders(v map[string]*string) *GetAggregateAccountComplianceByPackResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateAccountComplianceByPackResponse) SetStatusCode(v int32) *GetAggregateAccountComplianceByPackResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateAccountComplianceByPackResponse) SetBody(v *GetAggregateAccountComplianceByPackResponseBody) *GetAggregateAccountComplianceByPackResponse {
	s.Body = v
	return s
}

type GetAggregateAdvancedSearchFileRequest struct {
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
}

func (s GetAggregateAdvancedSearchFileRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateAdvancedSearchFileRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateAdvancedSearchFileRequest) SetAggregatorId(v string) *GetAggregateAdvancedSearchFileRequest {
	s.AggregatorId = &v
	return s
}

type GetAggregateAdvancedSearchFileResponseBody struct {
	RequestId      *string                                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ResourceSearch *GetAggregateAdvancedSearchFileResponseBodyResourceSearch `json:"ResourceSearch,omitempty" xml:"ResourceSearch,omitempty" type:"Struct"`
}

func (s GetAggregateAdvancedSearchFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateAdvancedSearchFileResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateAdvancedSearchFileResponseBody) SetRequestId(v string) *GetAggregateAdvancedSearchFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAggregateAdvancedSearchFileResponseBody) SetResourceSearch(v *GetAggregateAdvancedSearchFileResponseBodyResourceSearch) *GetAggregateAdvancedSearchFileResponseBody {
	s.ResourceSearch = v
	return s
}

type GetAggregateAdvancedSearchFileResponseBodyResourceSearch struct {
	DownloadUrl                   *string `json:"DownloadUrl,omitempty" xml:"DownloadUrl,omitempty"`
	ResourceInventoryGenerateTime *int64  `json:"ResourceInventoryGenerateTime,omitempty" xml:"ResourceInventoryGenerateTime,omitempty"`
	Status                        *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetAggregateAdvancedSearchFileResponseBodyResourceSearch) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateAdvancedSearchFileResponseBodyResourceSearch) GoString() string {
	return s.String()
}

func (s *GetAggregateAdvancedSearchFileResponseBodyResourceSearch) SetDownloadUrl(v string) *GetAggregateAdvancedSearchFileResponseBodyResourceSearch {
	s.DownloadUrl = &v
	return s
}

func (s *GetAggregateAdvancedSearchFileResponseBodyResourceSearch) SetResourceInventoryGenerateTime(v int64) *GetAggregateAdvancedSearchFileResponseBodyResourceSearch {
	s.ResourceInventoryGenerateTime = &v
	return s
}

func (s *GetAggregateAdvancedSearchFileResponseBodyResourceSearch) SetStatus(v string) *GetAggregateAdvancedSearchFileResponseBodyResourceSearch {
	s.Status = &v
	return s
}

type GetAggregateAdvancedSearchFileResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateAdvancedSearchFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateAdvancedSearchFileResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateAdvancedSearchFileResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateAdvancedSearchFileResponse) SetHeaders(v map[string]*string) *GetAggregateAdvancedSearchFileResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateAdvancedSearchFileResponse) SetStatusCode(v int32) *GetAggregateAdvancedSearchFileResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateAdvancedSearchFileResponse) SetBody(v *GetAggregateAdvancedSearchFileResponseBody) *GetAggregateAdvancedSearchFileResponse {
	s.Body = v
	return s
}

type GetAggregateCompliancePackRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListAggregateCompliancePacks](~~262059~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
}

func (s GetAggregateCompliancePackRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateCompliancePackRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateCompliancePackRequest) SetAggregatorId(v string) *GetAggregateCompliancePackRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateCompliancePackRequest) SetCompliancePackId(v string) *GetAggregateCompliancePackRequest {
	s.CompliancePackId = &v
	return s
}

type GetAggregateCompliancePackResponseBody struct {
	// The details of the compliance package.
	CompliancePack *GetAggregateCompliancePackResponseBodyCompliancePack `json:"CompliancePack,omitempty" xml:"CompliancePack,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregateCompliancePackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateCompliancePackResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateCompliancePackResponseBody) SetCompliancePack(v *GetAggregateCompliancePackResponseBodyCompliancePack) *GetAggregateCompliancePackResponseBody {
	s.CompliancePack = v
	return s
}

func (s *GetAggregateCompliancePackResponseBody) SetRequestId(v string) *GetAggregateCompliancePackResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregateCompliancePackResponseBodyCompliancePack struct {
	// The ID of the management account to which the compliance package belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The name of the compliance package.
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
	// The ID of the compliance package template.
	CompliancePackTemplateId *string `json:"CompliancePackTemplateId,omitempty" xml:"CompliancePackTemplateId,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high
	// *   2: medium
	// *   3: low
	ConfigRules []*GetAggregateCompliancePackResponseBodyCompliancePackConfigRules `json:"ConfigRules,omitempty" xml:"ConfigRules,omitempty" type:"Repeated"`
	// The timestamp when the compliance package was created. Unit: milliseconds.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The description of the compliance package.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The risk level of the resources that are not compliant with the rules in the compliance package. Valid values:
	//
	// *   1: high
	// *   2: medium
	// *   3: low
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The evaluation scope of the compliance package.
	Scope *GetAggregateCompliancePackResponseBodyCompliancePackScope `json:"Scope,omitempty" xml:"Scope,omitempty" type:"Struct"`
	// The status of the compliance package. Valid values:
	//
	// *   ACTIVE: The compliance package was normal.
	// *   CREATING: The compliance package was being created.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetAggregateCompliancePackResponseBodyCompliancePack) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateCompliancePackResponseBodyCompliancePack) GoString() string {
	return s.String()
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePack) SetAccountId(v int64) *GetAggregateCompliancePackResponseBodyCompliancePack {
	s.AccountId = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePack) SetAggregatorId(v string) *GetAggregateCompliancePackResponseBodyCompliancePack {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePack) SetCompliancePackId(v string) *GetAggregateCompliancePackResponseBodyCompliancePack {
	s.CompliancePackId = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePack) SetCompliancePackName(v string) *GetAggregateCompliancePackResponseBodyCompliancePack {
	s.CompliancePackName = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePack) SetCompliancePackTemplateId(v string) *GetAggregateCompliancePackResponseBodyCompliancePack {
	s.CompliancePackTemplateId = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePack) SetConfigRules(v []*GetAggregateCompliancePackResponseBodyCompliancePackConfigRules) *GetAggregateCompliancePackResponseBodyCompliancePack {
	s.ConfigRules = v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePack) SetCreateTimestamp(v int64) *GetAggregateCompliancePackResponseBodyCompliancePack {
	s.CreateTimestamp = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePack) SetDescription(v string) *GetAggregateCompliancePackResponseBodyCompliancePack {
	s.Description = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePack) SetRiskLevel(v int32) *GetAggregateCompliancePackResponseBodyCompliancePack {
	s.RiskLevel = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePack) SetScope(v *GetAggregateCompliancePackResponseBodyCompliancePackScope) *GetAggregateCompliancePackResponseBodyCompliancePack {
	s.Scope = v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePack) SetStatus(v string) *GetAggregateCompliancePackResponseBodyCompliancePack {
	s.Status = &v
	return s
}

type GetAggregateCompliancePackResponseBodyCompliancePackConfigRules struct {
	// The ID of the rule.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The input parameters of the rule.
	ConfigRuleParameters []*GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters `json:"ConfigRuleParameters,omitempty" xml:"ConfigRuleParameters,omitempty" type:"Repeated"`
	// The description of the rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the managed rule.
	ManagedRuleIdentifier *string `json:"ManagedRuleIdentifier,omitempty" xml:"ManagedRuleIdentifier,omitempty"`
	ResourceTypesScope    *string `json:"ResourceTypesScope,omitempty" xml:"ResourceTypesScope,omitempty"`
	// The risk level of the resources that were not compliant with the rule. Valid values:
	//
	// *   1: high
	// *   2: medium
	// *   3: low
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s GetAggregateCompliancePackResponseBodyCompliancePackConfigRules) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateCompliancePackResponseBodyCompliancePackConfigRules) GoString() string {
	return s.String()
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePackConfigRules) SetConfigRuleId(v string) *GetAggregateCompliancePackResponseBodyCompliancePackConfigRules {
	s.ConfigRuleId = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePackConfigRules) SetConfigRuleName(v string) *GetAggregateCompliancePackResponseBodyCompliancePackConfigRules {
	s.ConfigRuleName = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePackConfigRules) SetConfigRuleParameters(v []*GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters) *GetAggregateCompliancePackResponseBodyCompliancePackConfigRules {
	s.ConfigRuleParameters = v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePackConfigRules) SetDescription(v string) *GetAggregateCompliancePackResponseBodyCompliancePackConfigRules {
	s.Description = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePackConfigRules) SetManagedRuleIdentifier(v string) *GetAggregateCompliancePackResponseBodyCompliancePackConfigRules {
	s.ManagedRuleIdentifier = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePackConfigRules) SetResourceTypesScope(v string) *GetAggregateCompliancePackResponseBodyCompliancePackConfigRules {
	s.ResourceTypesScope = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePackConfigRules) SetRiskLevel(v int32) *GetAggregateCompliancePackResponseBodyCompliancePackConfigRules {
	s.RiskLevel = &v
	return s
}

type GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters struct {
	// The name of the input parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The value of the input parameter.
	ParameterValue *string `json:"ParameterValue,omitempty" xml:"ParameterValue,omitempty"`
	// Indicates whether the input parameter was required. Valid values:
	//
	// *   true: required
	// *   false: optional
	Required *bool `json:"Required,omitempty" xml:"Required,omitempty"`
}

func (s GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters) GoString() string {
	return s.String()
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters) SetParameterName(v string) *GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters {
	s.ParameterName = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters) SetParameterValue(v string) *GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters {
	s.ParameterValue = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters) SetRequired(v bool) *GetAggregateCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters {
	s.Required = &v
	return s
}

type GetAggregateCompliancePackResponseBodyCompliancePackScope struct {
	// The ID of the resource that is not evaluated by using the compliance package.
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The ID of the region whose resources were evaluated by using the compliance package.
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group whose resources are evaluated by using the compliance package.
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The tag key of the resource that is evaluated by using the compliance package.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value of the resource that is evaluated by using the compliance package.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s GetAggregateCompliancePackResponseBodyCompliancePackScope) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateCompliancePackResponseBodyCompliancePackScope) GoString() string {
	return s.String()
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePackScope) SetExcludeResourceIdsScope(v string) *GetAggregateCompliancePackResponseBodyCompliancePackScope {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePackScope) SetRegionIdsScope(v string) *GetAggregateCompliancePackResponseBodyCompliancePackScope {
	s.RegionIdsScope = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePackScope) SetResourceGroupIdsScope(v string) *GetAggregateCompliancePackResponseBodyCompliancePackScope {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePackScope) SetTagKeyScope(v string) *GetAggregateCompliancePackResponseBodyCompliancePackScope {
	s.TagKeyScope = &v
	return s
}

func (s *GetAggregateCompliancePackResponseBodyCompliancePackScope) SetTagValueScope(v string) *GetAggregateCompliancePackResponseBodyCompliancePackScope {
	s.TagValueScope = &v
	return s
}

type GetAggregateCompliancePackResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateCompliancePackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateCompliancePackResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateCompliancePackResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateCompliancePackResponse) SetHeaders(v map[string]*string) *GetAggregateCompliancePackResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateCompliancePackResponse) SetStatusCode(v int32) *GetAggregateCompliancePackResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateCompliancePackResponse) SetBody(v *GetAggregateCompliancePackResponseBody) *GetAggregateCompliancePackResponse {
	s.Body = v
	return s
}

type GetAggregateCompliancePackReportRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListAggregateCompliancePacks](~~262059~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
}

func (s GetAggregateCompliancePackReportRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateCompliancePackReportRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateCompliancePackReportRequest) SetAggregatorId(v string) *GetAggregateCompliancePackReportRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateCompliancePackReportRequest) SetCompliancePackId(v string) *GetAggregateCompliancePackReportRequest {
	s.CompliancePackId = &v
	return s
}

type GetAggregateCompliancePackReportResponseBody struct {
	// The compliance evaluation report that is generated based on a compliance package.
	CompliancePackReport *GetAggregateCompliancePackReportResponseBodyCompliancePackReport `json:"CompliancePackReport,omitempty" xml:"CompliancePackReport,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregateCompliancePackReportResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateCompliancePackReportResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateCompliancePackReportResponseBody) SetCompliancePackReport(v *GetAggregateCompliancePackReportResponseBodyCompliancePackReport) *GetAggregateCompliancePackReportResponseBody {
	s.CompliancePackReport = v
	return s
}

func (s *GetAggregateCompliancePackReportResponseBody) SetRequestId(v string) *GetAggregateCompliancePackReportResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregateCompliancePackReportResponseBodyCompliancePackReport struct {
	// The ID of the management account to which the compliance package belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The timestamp when the compliance evaluation report was generated. Unit: milliseconds.
	ReportCreateTimestamp *int64 `json:"ReportCreateTimestamp,omitempty" xml:"ReportCreateTimestamp,omitempty"`
	// The status of the compliance evaluation report. Valid values:
	//
	// *   NONE: The compliance evaluation report is not generated.
	// *   CREATING: The compliance evaluation report is being generated.
	// *   COMPLETE: The compliance evaluation report is generated.
	ReportStatus *string `json:"ReportStatus,omitempty" xml:"ReportStatus,omitempty"`
	// The URL that is used to download the compliance evaluation report.
	ReportUrl *string `json:"ReportUrl,omitempty" xml:"ReportUrl,omitempty"`
}

func (s GetAggregateCompliancePackReportResponseBodyCompliancePackReport) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateCompliancePackReportResponseBodyCompliancePackReport) GoString() string {
	return s.String()
}

func (s *GetAggregateCompliancePackReportResponseBodyCompliancePackReport) SetAccountId(v int64) *GetAggregateCompliancePackReportResponseBodyCompliancePackReport {
	s.AccountId = &v
	return s
}

func (s *GetAggregateCompliancePackReportResponseBodyCompliancePackReport) SetCompliancePackId(v string) *GetAggregateCompliancePackReportResponseBodyCompliancePackReport {
	s.CompliancePackId = &v
	return s
}

func (s *GetAggregateCompliancePackReportResponseBodyCompliancePackReport) SetReportCreateTimestamp(v int64) *GetAggregateCompliancePackReportResponseBodyCompliancePackReport {
	s.ReportCreateTimestamp = &v
	return s
}

func (s *GetAggregateCompliancePackReportResponseBodyCompliancePackReport) SetReportStatus(v string) *GetAggregateCompliancePackReportResponseBodyCompliancePackReport {
	s.ReportStatus = &v
	return s
}

func (s *GetAggregateCompliancePackReportResponseBodyCompliancePackReport) SetReportUrl(v string) *GetAggregateCompliancePackReportResponseBodyCompliancePackReport {
	s.ReportUrl = &v
	return s
}

type GetAggregateCompliancePackReportResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateCompliancePackReportResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateCompliancePackReportResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateCompliancePackReportResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateCompliancePackReportResponse) SetHeaders(v map[string]*string) *GetAggregateCompliancePackReportResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateCompliancePackReportResponse) SetStatusCode(v int32) *GetAggregateCompliancePackReportResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateCompliancePackReportResponse) SetBody(v *GetAggregateCompliancePackReportResponseBody) *GetAggregateCompliancePackReportResponse {
	s.Body = v
	return s
}

type GetAggregateComplianceSummaryRequest struct {
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
}

func (s GetAggregateComplianceSummaryRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateComplianceSummaryRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateComplianceSummaryRequest) SetAggregatorId(v string) *GetAggregateComplianceSummaryRequest {
	s.AggregatorId = &v
	return s
}

type GetAggregateComplianceSummaryResponseBody struct {
	ComplianceSummary *GetAggregateComplianceSummaryResponseBodyComplianceSummary `json:"ComplianceSummary,omitempty" xml:"ComplianceSummary,omitempty" type:"Struct"`
	RequestId         *string                                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregateComplianceSummaryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateComplianceSummaryResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateComplianceSummaryResponseBody) SetComplianceSummary(v *GetAggregateComplianceSummaryResponseBodyComplianceSummary) *GetAggregateComplianceSummaryResponseBody {
	s.ComplianceSummary = v
	return s
}

func (s *GetAggregateComplianceSummaryResponseBody) SetRequestId(v string) *GetAggregateComplianceSummaryResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregateComplianceSummaryResponseBodyComplianceSummary struct {
	ComplianceSummaryByConfigRule *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule `json:"ComplianceSummaryByConfigRule,omitempty" xml:"ComplianceSummaryByConfigRule,omitempty" type:"Struct"`
	ComplianceSummaryByResource   *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource   `json:"ComplianceSummaryByResource,omitempty" xml:"ComplianceSummaryByResource,omitempty" type:"Struct"`
}

func (s GetAggregateComplianceSummaryResponseBodyComplianceSummary) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateComplianceSummaryResponseBodyComplianceSummary) GoString() string {
	return s.String()
}

func (s *GetAggregateComplianceSummaryResponseBodyComplianceSummary) SetComplianceSummaryByConfigRule(v *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule) *GetAggregateComplianceSummaryResponseBodyComplianceSummary {
	s.ComplianceSummaryByConfigRule = v
	return s
}

func (s *GetAggregateComplianceSummaryResponseBodyComplianceSummary) SetComplianceSummaryByResource(v *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource) *GetAggregateComplianceSummaryResponseBodyComplianceSummary {
	s.ComplianceSummaryByResource = v
	return s
}

type GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule struct {
	ComplianceSummaryTimestamp *int64 `json:"ComplianceSummaryTimestamp,omitempty" xml:"ComplianceSummaryTimestamp,omitempty"`
	CompliantCount             *int32 `json:"CompliantCount,omitempty" xml:"CompliantCount,omitempty"`
	NonCompliantCount          *int32 `json:"NonCompliantCount,omitempty" xml:"NonCompliantCount,omitempty"`
	TotalCount                 *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule) GoString() string {
	return s.String()
}

func (s *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule) SetComplianceSummaryTimestamp(v int64) *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule {
	s.ComplianceSummaryTimestamp = &v
	return s
}

func (s *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule) SetCompliantCount(v int32) *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule {
	s.CompliantCount = &v
	return s
}

func (s *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule) SetNonCompliantCount(v int32) *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule {
	s.NonCompliantCount = &v
	return s
}

func (s *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule) SetTotalCount(v int64) *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule {
	s.TotalCount = &v
	return s
}

type GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource struct {
	ComplianceSummaryTimestamp *int64 `json:"ComplianceSummaryTimestamp,omitempty" xml:"ComplianceSummaryTimestamp,omitempty"`
	CompliantCount             *int32 `json:"CompliantCount,omitempty" xml:"CompliantCount,omitempty"`
	NonCompliantCount          *int32 `json:"NonCompliantCount,omitempty" xml:"NonCompliantCount,omitempty"`
	TotalCount                 *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource) GoString() string {
	return s.String()
}

func (s *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource) SetComplianceSummaryTimestamp(v int64) *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource {
	s.ComplianceSummaryTimestamp = &v
	return s
}

func (s *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource) SetCompliantCount(v int32) *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource {
	s.CompliantCount = &v
	return s
}

func (s *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource) SetNonCompliantCount(v int32) *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource {
	s.NonCompliantCount = &v
	return s
}

func (s *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource) SetTotalCount(v int64) *GetAggregateComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource {
	s.TotalCount = &v
	return s
}

type GetAggregateComplianceSummaryResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateComplianceSummaryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateComplianceSummaryResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateComplianceSummaryResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateComplianceSummaryResponse) SetHeaders(v map[string]*string) *GetAggregateComplianceSummaryResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateComplianceSummaryResponse) SetStatusCode(v int32) *GetAggregateComplianceSummaryResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateComplianceSummaryResponse) SetBody(v *GetAggregateComplianceSummaryResponseBody) *GetAggregateComplianceSummaryResponse {
	s.Body = v
	return s
}

type GetAggregateConfigDeliveryChannelRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the delivery channel.
	//
	// For more information about how to obtain the ID of a delivery channel, see [ListAggregateConfigDeliveryChannels](~~429842~~).
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
}

func (s GetAggregateConfigDeliveryChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigDeliveryChannelRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigDeliveryChannelRequest) SetAggregatorId(v string) *GetAggregateConfigDeliveryChannelRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelRequest) SetDeliveryChannelId(v string) *GetAggregateConfigDeliveryChannelRequest {
	s.DeliveryChannelId = &v
	return s
}

type GetAggregateConfigDeliveryChannelResponseBody struct {
	// The information about a delivery channel.
	DeliveryChannel *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel `json:"DeliveryChannel,omitempty" xml:"DeliveryChannel,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregateConfigDeliveryChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigDeliveryChannelResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigDeliveryChannelResponseBody) SetDeliveryChannel(v *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) *GetAggregateConfigDeliveryChannelResponseBody {
	s.DeliveryChannel = v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponseBody) SetRequestId(v string) *GetAggregateConfigDeliveryChannelResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel struct {
	// The ID of the member in the account group.
	AccountId *string `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// Indicates whether the specified destination receives resource change logs. If the value of this parameter is true, Cloud Config delivers the resource change logs to OSS, Log Service, or MNS when the configurations of the resources change. Valid values:
	//
	// *   true: The specified destination receives resource change logs.
	// *   false: The specified destination does not receive resource change logs.
	ConfigurationItemChangeNotification *bool `json:"ConfigurationItemChangeNotification,omitempty" xml:"ConfigurationItemChangeNotification,omitempty"`
	// Indicates whether the specified destination receives scheduled resource snapshots. Cloud Config delivers scheduled resource snapshots at `04:00Z` and `16:00Z` to OSS, MNS, or Log Service every day. The time is displayed in UTC. Valid values:
	//
	// *   true: The specified destination receives scheduled resource snapshots.
	// *   false: The specified destination does not receive scheduled resource snapshots.
	ConfigurationSnapshot *bool `json:"ConfigurationSnapshot,omitempty" xml:"ConfigurationSnapshot,omitempty"`
	// The ARN of the role that is assigned to the delivery channel.
	DeliveryChannelAssumeRoleArn *string `json:"DeliveryChannelAssumeRoleArn,omitempty" xml:"DeliveryChannelAssumeRoleArn,omitempty"`
	// The rule that is attached to the delivery channel. This parameter is available when you deliver data of all types to MNS or deliver snapshots to Log Service.
	//
	// *   If the value of the DeliveryChannelType parameter is MNS, take note of the following settings of the lowest risk level and resource types of the events to which you subscribed:
	//
	//     *   The lowest risk level of the events to which you want to subscribe is in the following format: `{"filterType":"RuleRiskLevel","value":"1","multiple":false}`.
	//
	//         The `value` field indicates the risk level of the events to which you want to subscribe. Valid values: 1, 2, and 3. The value 1 indicates the high risk level, the value 2 indicates the medium risk level, and the value 3 indicates the low risk level.
	//
	//     *   The setting of the resource types of the events to which you want to subscribe is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//         The `values` field indicates the resource types of the events to which you want to subscribe. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	//
	// *   If you set the DeliveryChannelType parameter to SLS, the setting of the resource types of the snapshots to which you want to deliver is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//     The `values` field specifies the resource types of the snapshots to which you want to deliver. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	DeliveryChannelCondition *string `json:"DeliveryChannelCondition,omitempty" xml:"DeliveryChannelCondition,omitempty"`
	// The ID of the delivery channel.
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
	// The name of the delivery channel.
	DeliveryChannelName *string `json:"DeliveryChannelName,omitempty" xml:"DeliveryChannelName,omitempty"`
	// The ARN of the delivery destination.
	//
	// *   If the value of the DeliveryChannelType parameter is OSS, the value of this parameter is the ARN of the destination OSS bucket.
	// *   If the value of the DeliveryChannelType parameter is MNS, the value of this parameter is the ARN of the destination MNS topic.
	// *   If the value of the DeliveryChannelType parameter is SLS, the value of this parameter is the ARN of the destination Log Service Logstore.
	DeliveryChannelTargetArn *string `json:"DeliveryChannelTargetArn,omitempty" xml:"DeliveryChannelTargetArn,omitempty"`
	// The type of the delivery channel. Valid values:
	//
	// *   OSS: Object Storage Service (OSS)
	// *   MNS: Message Service (MNS)
	// *   SLS: Log Service
	DeliveryChannelType *string `json:"DeliveryChannelType,omitempty" xml:"DeliveryChannelType,omitempty"`
	// The time when Cloud Config delivers scheduled resources snapshots every day.
	//
	// Format: `HH:mmZ`. This time is displayed in UTC.
	DeliverySnapshotTime *string `json:"DeliverySnapshotTime,omitempty" xml:"DeliverySnapshotTime,omitempty"`
	// The description of the delivery channel.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the specified destination receives resource non-compliance events. If the value of this parameter is true, Cloud Config delivers resource non-compliance events to Log Service or MNS when resources are evaluated as non-compliant. Valid values:
	//
	// *   true: The specified destination receives resource non-compliance events.
	// *   false: The specified destination does not receive resource non-compliance events.
	NonCompliantNotification *bool `json:"NonCompliantNotification,omitempty" xml:"NonCompliantNotification,omitempty"`
	// The ARN of the OSS bucket to which the delivered data is transferred when the size of the data exceeds the specified upper limit of the delivery channel.
	OversizedDataOSSTargetArn *string `json:"OversizedDataOSSTargetArn,omitempty" xml:"OversizedDataOSSTargetArn,omitempty"`
	// The status of the delivery channel. Valid values:
	//
	// *   0: The delivery channel is disabled.
	// *   1: The delivery channel is enabled.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) SetAccountId(v string) *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.AccountId = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) SetAggregatorId(v string) *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) SetConfigurationItemChangeNotification(v bool) *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.ConfigurationItemChangeNotification = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) SetConfigurationSnapshot(v bool) *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.ConfigurationSnapshot = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) SetDeliveryChannelAssumeRoleArn(v string) *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.DeliveryChannelAssumeRoleArn = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) SetDeliveryChannelCondition(v string) *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.DeliveryChannelCondition = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) SetDeliveryChannelId(v string) *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.DeliveryChannelId = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) SetDeliveryChannelName(v string) *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.DeliveryChannelName = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) SetDeliveryChannelTargetArn(v string) *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.DeliveryChannelTargetArn = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) SetDeliveryChannelType(v string) *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.DeliveryChannelType = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) SetDeliverySnapshotTime(v string) *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.DeliverySnapshotTime = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) SetDescription(v string) *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.Description = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) SetNonCompliantNotification(v bool) *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.NonCompliantNotification = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) SetOversizedDataOSSTargetArn(v string) *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.OversizedDataOSSTargetArn = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel) SetStatus(v int32) *GetAggregateConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.Status = &v
	return s
}

type GetAggregateConfigDeliveryChannelResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateConfigDeliveryChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateConfigDeliveryChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigDeliveryChannelResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigDeliveryChannelResponse) SetHeaders(v map[string]*string) *GetAggregateConfigDeliveryChannelResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponse) SetStatusCode(v int32) *GetAggregateConfigDeliveryChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateConfigDeliveryChannelResponse) SetBody(v *GetAggregateConfigDeliveryChannelResponseBody) *GetAggregateConfigDeliveryChannelResponse {
	s.Body = v
	return s
}

type GetAggregateConfigRuleRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the rule.
	//
	// You can call the [ListAggregateConfigRules](~~264148~~) operation to obtain the rule ID.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
}

func (s GetAggregateConfigRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleRequest) SetAggregatorId(v string) *GetAggregateConfigRuleRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateConfigRuleRequest) SetConfigRuleId(v string) *GetAggregateConfigRuleRequest {
	s.ConfigRuleId = &v
	return s
}

type GetAggregateConfigRuleResponseBody struct {
	// The details of the rule.
	ConfigRule *GetAggregateConfigRuleResponseBodyConfigRule `json:"ConfigRule,omitempty" xml:"ConfigRule,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregateConfigRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleResponseBody) SetConfigRule(v *GetAggregateConfigRuleResponseBodyConfigRule) *GetAggregateConfigRuleResponseBody {
	s.ConfigRule = v
	return s
}

func (s *GetAggregateConfigRuleResponseBody) SetRequestId(v string) *GetAggregateConfigRuleResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregateConfigRuleResponseBodyConfigRule struct {
	// The ID of the Alibaba Cloud account to which the rule belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The details of compliance evaluation results.
	Compliance *GetAggregateConfigRuleResponseBodyConfigRuleCompliance `json:"Compliance,omitempty" xml:"Compliance,omitempty" type:"Struct"`
	// The ARN of the managed rule.
	ConfigRuleArn *string `json:"ConfigRuleArn,omitempty" xml:"ConfigRuleArn,omitempty"`
	// The information about compliance evaluations performed by the rule.
	ConfigRuleEvaluationStatus *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus `json:"ConfigRuleEvaluationStatus,omitempty" xml:"ConfigRuleEvaluationStatus,omitempty" type:"Struct"`
	// The ID of the rule.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the monitoring rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The status of the rule. Valid values:
	//
	// *   ACTIVE: The rule is being used to monitor resource configurations.
	// *   DELETING: The rule is being deleted.
	// *   EVALUATING: The rule is triggered and is being used to monitor resource configurations.
	// *   INACTIVE: The rule is disabled and is no longer used to monitor resource configurations.
	ConfigRuleState *string `json:"ConfigRuleState,omitempty" xml:"ConfigRuleState,omitempty"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The managed rule is triggered by configuration changes.
	// *   ScheduledNotification: The managed rule is periodically triggered.
	ConfigRuleTriggerTypes *string `json:"ConfigRuleTriggerTypes,omitempty" xml:"ConfigRuleTriggerTypes,omitempty"`
	// The information about the creation of the rule.
	CreateBy *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy `json:"CreateBy,omitempty" xml:"CreateBy,omitempty" type:"Struct"`
	// The timestamp when the rule was created. Unit: milliseconds.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The description of the managed rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the member account to which the rule does not apply, which means that the resources within the member account are not evaluated based on the rule.
	//
	// >  This parameter applies only to a managed rule.
	ExcludeAccountIdsScope *string `json:"ExcludeAccountIdsScope,omitempty" xml:"ExcludeAccountIdsScope,omitempty"`
	// The ID of the resource directory to which the rule does not apply, which means that the resources within member accounts in the resource directory are not evaluated based on the rule.
	//
	// >
	// *   This parameter applies only to a rule of a global account group.
	// *   This parameter applies only to a managed rule.
	ExcludeFolderIdsScope *string `json:"ExcludeFolderIdsScope,omitempty" xml:"ExcludeFolderIdsScope,omitempty"`
	// The ID of the resource excluded from the compliance evaluations performed by the rule.
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The ID of the resource directory to which the rule applies, which means that the resources within member accounts in the resource directory are evaluated based on the rule.
	//
	// >
	// *   This parameter applies only to rules of a global account group.
	// *   This parameter applies only to managed rules.
	FolderIdsScope *string `json:"FolderIdsScope,omitempty" xml:"FolderIdsScope,omitempty"`
	// The input parameters of the rule.
	InputParameters map[string]interface{} `json:"InputParameters,omitempty" xml:"InputParameters,omitempty"`
	// The details of the managed rule.
	ManagedRule *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule `json:"ManagedRule,omitempty" xml:"ManagedRule,omitempty" type:"Struct"`
	// The intervals at which the managed rule is triggered. Valid values:
	//
	// *   One_Hour: 1 hour.
	// *   Three_Hours: 3 hours.
	// *   Six_Hours: 6 hours.
	// *   Twelve_Hours: 12 hours
	// *   TwentyFour_Hours: 24 hours
	MaximumExecutionFrequency *string `json:"MaximumExecutionFrequency,omitempty" xml:"MaximumExecutionFrequency,omitempty"`
	// The timestamp when the rule was last updated. Unit: milliseconds.
	ModifiedTimestamp *int64 `json:"ModifiedTimestamp,omitempty" xml:"ModifiedTimestamp,omitempty"`
	// The ID of the region to which the rule applies.
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group to which the rule applies.
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The type of the resource evaluated by the rule.
	ResourceTypesScope *string `json:"ResourceTypesScope,omitempty" xml:"ResourceTypesScope,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The information about how the rule was created.
	Source *GetAggregateConfigRuleResponseBodyConfigRuleSource `json:"Source,omitempty" xml:"Source,omitempty" type:"Struct"`
	// The logical relationship among the tag keys if you specify multiple tag keys by using the `TagKeyScope` parameter. For example, if the `TagKeyScope` parameter is set to `ECS,OSS` and the TagKeyLogicScope parameter is set to `AND`, the rule applies to resources with both the `ECS` and `OSS` tag keys. Valid values:
	//
	// *   AND: the logical relationship of AND
	// *   OR: the logical relationship of OR
	TagKeyLogicScope *string `json:"TagKeyLogicScope,omitempty" xml:"TagKeyLogicScope,omitempty"`
	// The tag key used to filter resources. The rule applies only to the resources with the specified tag key.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value used to filter resources. The rule applies only to the resources with the specified tag value.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s GetAggregateConfigRuleResponseBodyConfigRule) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleResponseBodyConfigRule) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetAccountId(v int64) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.AccountId = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetCompliance(v *GetAggregateConfigRuleResponseBodyConfigRuleCompliance) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.Compliance = v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetConfigRuleArn(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.ConfigRuleArn = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetConfigRuleEvaluationStatus(v *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.ConfigRuleEvaluationStatus = v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetConfigRuleId(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.ConfigRuleId = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetConfigRuleName(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.ConfigRuleName = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetConfigRuleState(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.ConfigRuleState = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetConfigRuleTriggerTypes(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.ConfigRuleTriggerTypes = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetCreateBy(v *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.CreateBy = v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetCreateTimestamp(v int64) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.CreateTimestamp = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetDescription(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.Description = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetExcludeAccountIdsScope(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.ExcludeAccountIdsScope = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetExcludeFolderIdsScope(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.ExcludeFolderIdsScope = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetExcludeResourceIdsScope(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetFolderIdsScope(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.FolderIdsScope = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetInputParameters(v map[string]interface{}) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.InputParameters = v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetManagedRule(v *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.ManagedRule = v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetMaximumExecutionFrequency(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.MaximumExecutionFrequency = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetModifiedTimestamp(v int64) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.ModifiedTimestamp = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetRegionIdsScope(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.RegionIdsScope = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetResourceGroupIdsScope(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetResourceTypesScope(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.ResourceTypesScope = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetRiskLevel(v int32) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.RiskLevel = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetSource(v *GetAggregateConfigRuleResponseBodyConfigRuleSource) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.Source = v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetTagKeyLogicScope(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.TagKeyLogicScope = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetTagKeyScope(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.TagKeyScope = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRule) SetTagValueScope(v string) *GetAggregateConfigRuleResponseBodyConfigRule {
	s.TagValueScope = &v
	return s
}

type GetAggregateConfigRuleResponseBodyConfigRuleCompliance struct {
	// The statistics on the compliance evaluation results by compliance type. Valid values:
	//
	// *   COMPLIANT: The resources are evaluated as compliant.
	// *   NON_COMPLIANT: The resources are evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to your resources.
	// *   INSUFFICIENT_DATA: No resource data is available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The number of evaluated resources.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s GetAggregateConfigRuleResponseBodyConfigRuleCompliance) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleResponseBodyConfigRuleCompliance) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleCompliance) SetComplianceType(v string) *GetAggregateConfigRuleResponseBodyConfigRuleCompliance {
	s.ComplianceType = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleCompliance) SetCount(v int32) *GetAggregateConfigRuleResponseBodyConfigRuleCompliance {
	s.Count = &v
	return s
}

type GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus struct {
	// The timestamp when the rule was first triggered.
	FirstActivatedTimestamp *int64 `json:"FirstActivatedTimestamp,omitempty" xml:"FirstActivatedTimestamp,omitempty"`
	// Indicates whether resources were evaluated based on the rule. Valid values:
	//
	// *   true: Resources were evaluated based on the rule.
	// *   false: Resources were not evaluated based on the rule.
	FirstEvaluationStarted *bool `json:"FirstEvaluationStarted,omitempty" xml:"FirstEvaluationStarted,omitempty"`
	// The error code returned for the last failed compliance evaluation.
	LastErrorCode *string `json:"LastErrorCode,omitempty" xml:"LastErrorCode,omitempty"`
	// The error message returned for the last failed compliance evaluation.
	LastErrorMessage *string `json:"LastErrorMessage,omitempty" xml:"LastErrorMessage,omitempty"`
	// The timestamp when the last failed compliance evaluation of the rule ended. Unit: milliseconds.
	LastFailedEvaluationTimestamp *int64 `json:"LastFailedEvaluationTimestamp,omitempty" xml:"LastFailedEvaluationTimestamp,omitempty"`
	// The timestamp when the last failed compliance evaluation of the rule started. Unit: milliseconds.
	LastFailedInvocationTimestamp *int64 `json:"LastFailedInvocationTimestamp,omitempty" xml:"LastFailedInvocationTimestamp,omitempty"`
	// The timestamp when the last successful compliance evaluation of the rule ended. Unit: milliseconds.
	LastSuccessfulEvaluationTimestamp *int64 `json:"LastSuccessfulEvaluationTimestamp,omitempty" xml:"LastSuccessfulEvaluationTimestamp,omitempty"`
	// The timestamp when the last successful compliance evaluation of the rule started. Unit: milliseconds.
	LastSuccessfulInvocationTimestamp *int64 `json:"LastSuccessfulInvocationTimestamp,omitempty" xml:"LastSuccessfulInvocationTimestamp,omitempty"`
}

func (s GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetFirstActivatedTimestamp(v int64) *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.FirstActivatedTimestamp = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetFirstEvaluationStarted(v bool) *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.FirstEvaluationStarted = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetLastErrorCode(v string) *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.LastErrorCode = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetLastErrorMessage(v string) *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.LastErrorMessage = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetLastFailedEvaluationTimestamp(v int64) *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.LastFailedEvaluationTimestamp = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetLastFailedInvocationTimestamp(v int64) *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.LastFailedInvocationTimestamp = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetLastSuccessfulEvaluationTimestamp(v int64) *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.LastSuccessfulEvaluationTimestamp = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetLastSuccessfulInvocationTimestamp(v int64) *GetAggregateConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.LastSuccessfulInvocationTimestamp = &v
	return s
}

type GetAggregateConfigRuleResponseBodyConfigRuleCreateBy struct {
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The name of the account group.
	AggregatorName *string `json:"AggregatorName,omitempty" xml:"AggregatorName,omitempty"`
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The name of the compliance package.
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
	// The ID of the account that was used to create the rule.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The name of the account that was used to create the rule.
	CreatorName *string `json:"CreatorName,omitempty" xml:"CreatorName,omitempty"`
	// The type of the entity to which the rule belongs. The value is fixed to `AGGREGATOR`, which indicates an account group.
	CreatorType *string `json:"CreatorType,omitempty" xml:"CreatorType,omitempty"`
}

func (s GetAggregateConfigRuleResponseBodyConfigRuleCreateBy) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleResponseBodyConfigRuleCreateBy) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy) SetAggregatorId(v string) *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy) SetAggregatorName(v string) *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy {
	s.AggregatorName = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy) SetCompliancePackId(v string) *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy {
	s.CompliancePackId = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy) SetCompliancePackName(v string) *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy {
	s.CompliancePackName = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy) SetCreatorId(v string) *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy {
	s.CreatorId = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy) SetCreatorName(v string) *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy {
	s.CreatorName = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy) SetCreatorType(v string) *GetAggregateConfigRuleResponseBodyConfigRuleCreateBy {
	s.CreatorType = &v
	return s
}

type GetAggregateConfigRuleResponseBodyConfigRuleManagedRule struct {
	// The required input parameters of the managed rule.
	CompulsoryInputParameterDetails map[string]interface{} `json:"CompulsoryInputParameterDetails,omitempty" xml:"CompulsoryInputParameterDetails,omitempty"`
	// The description of the managed rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The identifier of the managed rule.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The tags of the managed rule.
	Labels []*string `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	// The name of the managed rule.
	ManagedRuleName *string `json:"ManagedRuleName,omitempty" xml:"ManagedRuleName,omitempty"`
	// The optional input parameters of the managed rule.
	OptionalInputParameterDetails map[string]interface{} `json:"OptionalInputParameterDetails,omitempty" xml:"OptionalInputParameterDetails,omitempty"`
	// The details of the source of the managed rule.
	SourceDetails []*GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails `json:"SourceDetails,omitempty" xml:"SourceDetails,omitempty" type:"Repeated"`
}

func (s GetAggregateConfigRuleResponseBodyConfigRuleManagedRule) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleResponseBodyConfigRuleManagedRule) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule) SetCompulsoryInputParameterDetails(v map[string]interface{}) *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule {
	s.CompulsoryInputParameterDetails = v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule) SetDescription(v string) *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule {
	s.Description = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule) SetIdentifier(v string) *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule {
	s.Identifier = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule) SetLabels(v []*string) *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule {
	s.Labels = v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule) SetManagedRuleName(v string) *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule {
	s.ManagedRuleName = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule) SetOptionalInputParameterDetails(v map[string]interface{}) *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule {
	s.OptionalInputParameterDetails = v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule) SetSourceDetails(v []*GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails) *GetAggregateConfigRuleResponseBodyConfigRuleManagedRule {
	s.SourceDetails = v
	return s
}

type GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails struct {
	// The event source of the managed rule.
	//
	// >  Only events related to Cloud Config are supported. The value is fixed to aliyun.config.
	EventSource *string `json:"EventSource,omitempty" xml:"EventSource,omitempty"`
	// The intervals at which the managed rule is triggered. Valid values:
	//
	// *   One_Hour: 1 hour.
	// *   Three_Hours: 3 hours.
	// *   Six_Hours: 6 hours.
	// *   Twelve_Hours: 12 hours
	// *   TwentyFour_Hours: 24 hours
	MaximumExecutionFrequency *string `json:"MaximumExecutionFrequency,omitempty" xml:"MaximumExecutionFrequency,omitempty"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The managed rule is triggered by configuration changes.
	// *   ScheduledNotification: The managed rule is periodically triggered.
	MessageType *string `json:"MessageType,omitempty" xml:"MessageType,omitempty"`
}

func (s GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails) SetEventSource(v string) *GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails {
	s.EventSource = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails) SetMaximumExecutionFrequency(v string) *GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails {
	s.MaximumExecutionFrequency = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails) SetMessageType(v string) *GetAggregateConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails {
	s.MessageType = &v
	return s
}

type GetAggregateConfigRuleResponseBodyConfigRuleSource struct {
	// The identifier of the rule.
	//
	// *   If the rule was created based on a managed rule, the value of this parameter is the name of the managed rule.
	// *   If the rule is a custom rule, the value of this parameter is the Alibaba Cloud Resource Name (ARN) of the relevant function in Function Compute.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The way in which the rule was created. Valid values:
	//
	// *   CUSTOM_FC: The rule is a custom rule.
	// *   ALIYUN: The rule was created based on a managed rule of Alibaba Cloud.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The details of the source of the rule.
	SourceDetails []*GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails `json:"SourceDetails,omitempty" xml:"SourceDetails,omitempty" type:"Repeated"`
}

func (s GetAggregateConfigRuleResponseBodyConfigRuleSource) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleResponseBodyConfigRuleSource) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleSource) SetIdentifier(v string) *GetAggregateConfigRuleResponseBodyConfigRuleSource {
	s.Identifier = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleSource) SetOwner(v string) *GetAggregateConfigRuleResponseBodyConfigRuleSource {
	s.Owner = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleSource) SetSourceDetails(v []*GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails) *GetAggregateConfigRuleResponseBodyConfigRuleSource {
	s.SourceDetails = v
	return s
}

type GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails struct {
	// The event source of the managed rule.
	//
	// >  Only events related to Cloud Config are supported. The value is fixed to aliyun.config.
	EventSource *string `json:"EventSource,omitempty" xml:"EventSource,omitempty"`
	// The intervals at which the managed rule is triggered. Valid values:
	//
	// *   One_Hour: 1 hour.
	// *   Three_Hours: 3 hours.
	// *   Six_Hours: 6 hours.
	// *   Twelve_Hours: 12 hours
	// *   TwentyFour_Hours: 24 hours
	MaximumExecutionFrequency *string `json:"MaximumExecutionFrequency,omitempty" xml:"MaximumExecutionFrequency,omitempty"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The managed rule is triggered by configuration changes.
	// *   ScheduledNotification: The managed rule is periodically triggered.
	MessageType *string `json:"MessageType,omitempty" xml:"MessageType,omitempty"`
}

func (s GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails) SetEventSource(v string) *GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails {
	s.EventSource = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails) SetMaximumExecutionFrequency(v string) *GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails {
	s.MaximumExecutionFrequency = &v
	return s
}

func (s *GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails) SetMessageType(v string) *GetAggregateConfigRuleResponseBodyConfigRuleSourceSourceDetails {
	s.MessageType = &v
	return s
}

type GetAggregateConfigRuleResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateConfigRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateConfigRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleResponse) SetHeaders(v map[string]*string) *GetAggregateConfigRuleResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateConfigRuleResponse) SetStatusCode(v int32) *GetAggregateConfigRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateConfigRuleResponse) SetBody(v *GetAggregateConfigRuleResponseBody) *GetAggregateConfigRuleResponse {
	s.Body = v
	return s
}

type GetAggregateConfigRuleComplianceByPackRequest struct {
	// The ID of the account group.
	//
	// For information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the compliance package.
	//
	// For information about how to obtain the ID of a compliance package, see [ListAggregateCompliancePacks](~~262059~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
}

func (s GetAggregateConfigRuleComplianceByPackRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleComplianceByPackRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleComplianceByPackRequest) SetAggregatorId(v string) *GetAggregateConfigRuleComplianceByPackRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateConfigRuleComplianceByPackRequest) SetCompliancePackId(v string) *GetAggregateConfigRuleComplianceByPackRequest {
	s.CompliancePackId = &v
	return s
}

type GetAggregateConfigRuleComplianceByPackResponseBody struct {
	// The compliance evaluation results that are returned by rules in the compliance package.
	ConfigRuleComplianceResult *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult `json:"ConfigRuleComplianceResult,omitempty" xml:"ConfigRuleComplianceResult,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregateConfigRuleComplianceByPackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleComplianceByPackResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleComplianceByPackResponseBody) SetConfigRuleComplianceResult(v *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult) *GetAggregateConfigRuleComplianceByPackResponseBody {
	s.ConfigRuleComplianceResult = v
	return s
}

func (s *GetAggregateConfigRuleComplianceByPackResponseBody) SetRequestId(v string) *GetAggregateConfigRuleComplianceByPackResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult struct {
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The information about rules in the compliance package.
	ConfigRuleCompliances []*GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances `json:"ConfigRuleCompliances,omitempty" xml:"ConfigRuleCompliances,omitempty" type:"Repeated"`
	// The number of rules against which specific resources are evaluated as non-compliant.
	NonCompliantCount *int32 `json:"NonCompliantCount,omitempty" xml:"NonCompliantCount,omitempty"`
	// The total number of rules in the compliance package.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult) SetCompliancePackId(v string) *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult {
	s.CompliancePackId = &v
	return s
}

func (s *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult) SetConfigRuleCompliances(v []*GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances) *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult {
	s.ConfigRuleCompliances = v
	return s
}

func (s *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult) SetNonCompliantCount(v int32) *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult {
	s.NonCompliantCount = &v
	return s
}

func (s *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult) SetTotalCount(v int32) *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult {
	s.TotalCount = &v
	return s
}

type GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances struct {
	// The compliance evaluation result returned by the rule. Valid values:
	//
	// *   COMPLIANT: The relevant resources are evaluated as compliant.
	// *   NON_COMPLIANT: The relevant resources are evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to your resources.
	// *   INSUFFICIENT_DATA: No resource data is available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The ID of the rule.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
}

func (s GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances) SetComplianceType(v string) *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances {
	s.ComplianceType = &v
	return s
}

func (s *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances) SetConfigRuleId(v string) *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances {
	s.ConfigRuleId = &v
	return s
}

func (s *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances) SetConfigRuleName(v string) *GetAggregateConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances {
	s.ConfigRuleName = &v
	return s
}

type GetAggregateConfigRuleComplianceByPackResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateConfigRuleComplianceByPackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateConfigRuleComplianceByPackResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleComplianceByPackResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleComplianceByPackResponse) SetHeaders(v map[string]*string) *GetAggregateConfigRuleComplianceByPackResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateConfigRuleComplianceByPackResponse) SetStatusCode(v int32) *GetAggregateConfigRuleComplianceByPackResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateConfigRuleComplianceByPackResponse) SetBody(v *GetAggregateConfigRuleComplianceByPackResponseBody) *GetAggregateConfigRuleComplianceByPackResponse {
	s.Body = v
	return s
}

type GetAggregateConfigRuleSummaryByRiskLevelRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
}

func (s GetAggregateConfigRuleSummaryByRiskLevelRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleSummaryByRiskLevelRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleSummaryByRiskLevelRequest) SetAggregatorId(v string) *GetAggregateConfigRuleSummaryByRiskLevelRequest {
	s.AggregatorId = &v
	return s
}

type GetAggregateConfigRuleSummaryByRiskLevelResponseBody struct {
	// The summary of compliance evaluation results by rule risk level.
	ConfigRuleSummaries []*GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries `json:"ConfigRuleSummaries,omitempty" xml:"ConfigRuleSummaries,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregateConfigRuleSummaryByRiskLevelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleSummaryByRiskLevelResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleSummaryByRiskLevelResponseBody) SetConfigRuleSummaries(v []*GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries) *GetAggregateConfigRuleSummaryByRiskLevelResponseBody {
	s.ConfigRuleSummaries = v
	return s
}

func (s *GetAggregateConfigRuleSummaryByRiskLevelResponseBody) SetRequestId(v string) *GetAggregateConfigRuleSummaryByRiskLevelResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries struct {
	// The number of rules against which specific resources are evaluated as compliant.
	CompliantCount *int32 `json:"CompliantCount,omitempty" xml:"CompliantCount,omitempty"`
	// The number of rules against which specific resources are evaluated as non-compliant.
	NonCompliantCount *int32 `json:"NonCompliantCount,omitempty" xml:"NonCompliantCount,omitempty"`
	// The risk level of the resources that do not comply with the rule. Valid values:
	//
	// *   1: high
	// *   2: medium
	// *   3: low
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries) SetCompliantCount(v int32) *GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries {
	s.CompliantCount = &v
	return s
}

func (s *GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries) SetNonCompliantCount(v int32) *GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries {
	s.NonCompliantCount = &v
	return s
}

func (s *GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries) SetRiskLevel(v int32) *GetAggregateConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries {
	s.RiskLevel = &v
	return s
}

type GetAggregateConfigRuleSummaryByRiskLevelResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateConfigRuleSummaryByRiskLevelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateConfigRuleSummaryByRiskLevelResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRuleSummaryByRiskLevelResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRuleSummaryByRiskLevelResponse) SetHeaders(v map[string]*string) *GetAggregateConfigRuleSummaryByRiskLevelResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateConfigRuleSummaryByRiskLevelResponse) SetStatusCode(v int32) *GetAggregateConfigRuleSummaryByRiskLevelResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateConfigRuleSummaryByRiskLevelResponse) SetBody(v *GetAggregateConfigRuleSummaryByRiskLevelResponseBody) *GetAggregateConfigRuleSummaryByRiskLevelResponse {
	s.Body = v
	return s
}

type GetAggregateConfigRulesReportRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the compliance evaluation report.
	ReportId *string `json:"ReportId,omitempty" xml:"ReportId,omitempty"`
}

func (s GetAggregateConfigRulesReportRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRulesReportRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRulesReportRequest) SetAggregatorId(v string) *GetAggregateConfigRulesReportRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateConfigRulesReportRequest) SetReportId(v string) *GetAggregateConfigRulesReportRequest {
	s.ReportId = &v
	return s
}

type GetAggregateConfigRulesReportResponseBody struct {
	// The information about the compliance evaluation report.
	ConfigRulesReport *GetAggregateConfigRulesReportResponseBodyConfigRulesReport `json:"ConfigRulesReport,omitempty" xml:"ConfigRulesReport,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregateConfigRulesReportResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRulesReportResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRulesReportResponseBody) SetConfigRulesReport(v *GetAggregateConfigRulesReportResponseBodyConfigRulesReport) *GetAggregateConfigRulesReportResponseBody {
	s.ConfigRulesReport = v
	return s
}

func (s *GetAggregateConfigRulesReportResponseBody) SetRequestId(v string) *GetAggregateConfigRulesReportResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregateConfigRulesReportResponseBodyConfigRulesReport struct {
	// The ID of the management account to which the rules belong.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The timestamp when the compliance evaluation report was generated. Unit: milliseconds.
	ReportCreateTimestamp *int64 `json:"ReportCreateTimestamp,omitempty" xml:"ReportCreateTimestamp,omitempty"`
	// The ID of the compliance evaluation report.
	ReportId *string `json:"ReportId,omitempty" xml:"ReportId,omitempty"`
	// The status of the compliance evaluation report. Valid values:
	//
	// *   NONE: The compliance evaluation report was not generated.
	// *   CREATING: The compliance evaluation report was being generated.
	// *   COMPLETE: The compliance evaluation report was generated.
	ReportStatus *string `json:"ReportStatus,omitempty" xml:"ReportStatus,omitempty"`
	// The URL that is used to download the compliance evaluation report.
	ReportUrl *string `json:"ReportUrl,omitempty" xml:"ReportUrl,omitempty"`
}

func (s GetAggregateConfigRulesReportResponseBodyConfigRulesReport) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRulesReportResponseBodyConfigRulesReport) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRulesReportResponseBodyConfigRulesReport) SetAccountId(v int64) *GetAggregateConfigRulesReportResponseBodyConfigRulesReport {
	s.AccountId = &v
	return s
}

func (s *GetAggregateConfigRulesReportResponseBodyConfigRulesReport) SetAggregatorId(v string) *GetAggregateConfigRulesReportResponseBodyConfigRulesReport {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateConfigRulesReportResponseBodyConfigRulesReport) SetReportCreateTimestamp(v int64) *GetAggregateConfigRulesReportResponseBodyConfigRulesReport {
	s.ReportCreateTimestamp = &v
	return s
}

func (s *GetAggregateConfigRulesReportResponseBodyConfigRulesReport) SetReportId(v string) *GetAggregateConfigRulesReportResponseBodyConfigRulesReport {
	s.ReportId = &v
	return s
}

func (s *GetAggregateConfigRulesReportResponseBodyConfigRulesReport) SetReportStatus(v string) *GetAggregateConfigRulesReportResponseBodyConfigRulesReport {
	s.ReportStatus = &v
	return s
}

func (s *GetAggregateConfigRulesReportResponseBodyConfigRulesReport) SetReportUrl(v string) *GetAggregateConfigRulesReportResponseBodyConfigRulesReport {
	s.ReportUrl = &v
	return s
}

type GetAggregateConfigRulesReportResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateConfigRulesReportResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateConfigRulesReportResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateConfigRulesReportResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateConfigRulesReportResponse) SetHeaders(v map[string]*string) *GetAggregateConfigRulesReportResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateConfigRulesReportResponse) SetStatusCode(v int32) *GetAggregateConfigRulesReportResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateConfigRulesReportResponse) SetBody(v *GetAggregateConfigRulesReportResponseBody) *GetAggregateConfigRulesReportResponse {
	s.Body = v
	return s
}

type GetAggregateDiscoveredResourceRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the region in which the resource resides.
	//
	// For more information about how to query the ID of a region in which the resource resides, see [ListAggregateDiscoveredResources](~~411691~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// 账号组内待查询资源所属的阿里云账号ID。
	// > 参数ResourceAccountId和ResourceOwnerId必须设置其中一个，推荐使用本参数。
	ResourceAccountId *int64 `json:"ResourceAccountId,omitempty" xml:"ResourceAccountId,omitempty"`
	// The resource ID.
	//
	// For more information about how to query the ID of a resource, see [ListAggregateDiscoveredResources](~~411691~~).
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// Deprecated
	ResourceOwnerId *int64 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource.
	//
	// For more information about how to obtain the type of a resource, see [ListAggregateDiscoveredResources](~~411691~~).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s GetAggregateDiscoveredResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateDiscoveredResourceRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateDiscoveredResourceRequest) SetAggregatorId(v string) *GetAggregateDiscoveredResourceRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateDiscoveredResourceRequest) SetRegion(v string) *GetAggregateDiscoveredResourceRequest {
	s.Region = &v
	return s
}

func (s *GetAggregateDiscoveredResourceRequest) SetResourceAccountId(v int64) *GetAggregateDiscoveredResourceRequest {
	s.ResourceAccountId = &v
	return s
}

func (s *GetAggregateDiscoveredResourceRequest) SetResourceId(v string) *GetAggregateDiscoveredResourceRequest {
	s.ResourceId = &v
	return s
}

func (s *GetAggregateDiscoveredResourceRequest) SetResourceOwnerId(v int64) *GetAggregateDiscoveredResourceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *GetAggregateDiscoveredResourceRequest) SetResourceType(v string) *GetAggregateDiscoveredResourceRequest {
	s.ResourceType = &v
	return s
}

type GetAggregateDiscoveredResourceResponseBody struct {
	// The information about the resource.
	DiscoveredResourceDetail *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail `json:"DiscoveredResourceDetail,omitempty" xml:"DiscoveredResourceDetail,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregateDiscoveredResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateDiscoveredResourceResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateDiscoveredResourceResponseBody) SetDiscoveredResourceDetail(v *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail) *GetAggregateDiscoveredResourceResponseBody {
	s.DiscoveredResourceDetail = v
	return s
}

func (s *GetAggregateDiscoveredResourceResponseBody) SetRequestId(v string) *GetAggregateDiscoveredResourceResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail struct {
	// The ID of the Alibaba Cloud account to which the resource belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the zone where the resource resides.
	AvailabilityZone *string `json:"AvailabilityZone,omitempty" xml:"AvailabilityZone,omitempty"`
	// The configuration of the resource.
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The timestamp when the resource was created.
	ResourceCreationTime *int64 `json:"ResourceCreationTime,omitempty" xml:"ResourceCreationTime,omitempty"`
	// Indicates whether the resource was deleted. Valid values:
	//
	// *   1: The resource was not deleted.
	// *   0: The resource was deleted.
	ResourceDeleted *int32 `json:"ResourceDeleted,omitempty" xml:"ResourceDeleted,omitempty"`
	// The resource ID.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The name of the resource.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The status of the resource. The value of this parameter varies based on the resource type and may be empty. Examples:
	//
	// *   If the value of the ResourceType parameter is ACS::ECS::Instance, the resource is an Elastic Compute Service (ECS) instance that is in a specific state. In this case, the valid values of this parameter are Running and Stopped.
	// *   If the value of the ResourceType parameter is ACS::OSS::Bucket, the resource is an Object Storage Service (OSS) bucket that is not in a specific state. In this case, this parameter is empty.
	ResourceStatus *string `json:"ResourceStatus,omitempty" xml:"ResourceStatus,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags of the resource.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail) GoString() string {
	return s.String()
}

func (s *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetAccountId(v int64) *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.AccountId = &v
	return s
}

func (s *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetAvailabilityZone(v string) *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.AvailabilityZone = &v
	return s
}

func (s *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetConfiguration(v string) *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.Configuration = &v
	return s
}

func (s *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetRegion(v string) *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.Region = &v
	return s
}

func (s *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetResourceCreationTime(v int64) *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.ResourceCreationTime = &v
	return s
}

func (s *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetResourceDeleted(v int32) *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.ResourceDeleted = &v
	return s
}

func (s *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetResourceId(v string) *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.ResourceId = &v
	return s
}

func (s *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetResourceName(v string) *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.ResourceName = &v
	return s
}

func (s *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetResourceStatus(v string) *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.ResourceStatus = &v
	return s
}

func (s *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetResourceType(v string) *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.ResourceType = &v
	return s
}

func (s *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetTags(v string) *GetAggregateDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.Tags = &v
	return s
}

type GetAggregateDiscoveredResourceResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateDiscoveredResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateDiscoveredResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateDiscoveredResourceResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateDiscoveredResourceResponse) SetHeaders(v map[string]*string) *GetAggregateDiscoveredResourceResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateDiscoveredResourceResponse) SetStatusCode(v int32) *GetAggregateDiscoveredResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateDiscoveredResourceResponse) SetBody(v *GetAggregateDiscoveredResourceResponseBody) *GetAggregateDiscoveredResourceResponse {
	s.Body = v
	return s
}

type GetAggregateResourceComplianceByConfigRuleRequest struct {
	// The ID of the account group.
	//
	// For more information about how to query the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The compliance evaluation result of the resources. Valid values:
	//
	// *   COMPLIANT: The resources are evaluated as compliant.
	// *   NON_COMPLIANT: The resources are evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to your resources.
	// *   INSUFFICIENT_DATA: No resource data is available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The ID of the rule.
	//
	// For more information about how to query the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleId      *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	ResourceAccountId *int64  `json:"ResourceAccountId,omitempty" xml:"ResourceAccountId,omitempty"`
	// Deprecated
	ResourceOwnerId *int64 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetAggregateResourceComplianceByConfigRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceByConfigRuleRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceByConfigRuleRequest) SetAggregatorId(v string) *GetAggregateResourceComplianceByConfigRuleRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateResourceComplianceByConfigRuleRequest) SetComplianceType(v string) *GetAggregateResourceComplianceByConfigRuleRequest {
	s.ComplianceType = &v
	return s
}

func (s *GetAggregateResourceComplianceByConfigRuleRequest) SetConfigRuleId(v string) *GetAggregateResourceComplianceByConfigRuleRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *GetAggregateResourceComplianceByConfigRuleRequest) SetResourceAccountId(v int64) *GetAggregateResourceComplianceByConfigRuleRequest {
	s.ResourceAccountId = &v
	return s
}

func (s *GetAggregateResourceComplianceByConfigRuleRequest) SetResourceOwnerId(v int64) *GetAggregateResourceComplianceByConfigRuleRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetAggregateResourceComplianceByConfigRuleResponseBody struct {
	// The return result of the request.
	ComplianceResult *GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult `json:"ComplianceResult,omitempty" xml:"ComplianceResult,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregateResourceComplianceByConfigRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceByConfigRuleResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceByConfigRuleResponseBody) SetComplianceResult(v *GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult) *GetAggregateResourceComplianceByConfigRuleResponseBody {
	s.ComplianceResult = v
	return s
}

func (s *GetAggregateResourceComplianceByConfigRuleResponseBody) SetRequestId(v string) *GetAggregateResourceComplianceByConfigRuleResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult struct {
	// The compliance evaluation results returned.
	Compliances []*GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances `json:"Compliances,omitempty" xml:"Compliances,omitempty" type:"Repeated"`
	// The total number of evaluated resources.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult) SetCompliances(v []*GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances) *GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult {
	s.Compliances = v
	return s
}

func (s *GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult) SetTotalCount(v int64) *GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResult {
	s.TotalCount = &v
	return s
}

type GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances struct {
	// The compliance evaluation result of the resources. Valid values:
	//
	// *   COMPLIANT: The resources are evaluated as compliant.
	// *   NON_COMPLIANT: The resources are evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to your resources.
	// *   INSUFFICIENT_DATA: No resource data is available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The number of resources that have the compliance evaluation result. For example, if the value of the `ComplianceType` parameter is `COMPLIANT`, this parameter value indicates the number of compliant resources.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances) SetComplianceType(v string) *GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances {
	s.ComplianceType = &v
	return s
}

func (s *GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances) SetCount(v int32) *GetAggregateResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances {
	s.Count = &v
	return s
}

type GetAggregateResourceComplianceByConfigRuleResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateResourceComplianceByConfigRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateResourceComplianceByConfigRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceByConfigRuleResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceByConfigRuleResponse) SetHeaders(v map[string]*string) *GetAggregateResourceComplianceByConfigRuleResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateResourceComplianceByConfigRuleResponse) SetStatusCode(v int32) *GetAggregateResourceComplianceByConfigRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateResourceComplianceByConfigRuleResponse) SetBody(v *GetAggregateResourceComplianceByConfigRuleResponseBody) *GetAggregateResourceComplianceByConfigRuleResponse {
	s.Body = v
	return s
}

type GetAggregateResourceComplianceByPackRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListAggregateCompliancePacks](~~262059~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
}

func (s GetAggregateResourceComplianceByPackRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceByPackRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceByPackRequest) SetAggregatorId(v string) *GetAggregateResourceComplianceByPackRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateResourceComplianceByPackRequest) SetCompliancePackId(v string) *GetAggregateResourceComplianceByPackRequest {
	s.CompliancePackId = &v
	return s
}

type GetAggregateResourceComplianceByPackResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The compliance evaluation results returned.
	ResourceComplianceResult *GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult `json:"ResourceComplianceResult,omitempty" xml:"ResourceComplianceResult,omitempty" type:"Struct"`
}

func (s GetAggregateResourceComplianceByPackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceByPackResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceByPackResponseBody) SetRequestId(v string) *GetAggregateResourceComplianceByPackResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAggregateResourceComplianceByPackResponseBody) SetResourceComplianceResult(v *GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult) *GetAggregateResourceComplianceByPackResponseBody {
	s.ResourceComplianceResult = v
	return s
}

type GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult struct {
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The number of non-compliant resources.
	NonCompliantCount *int32 `json:"NonCompliantCount,omitempty" xml:"NonCompliantCount,omitempty"`
	// The total number of resources.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult) SetCompliancePackId(v string) *GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult {
	s.CompliancePackId = &v
	return s
}

func (s *GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult) SetNonCompliantCount(v int32) *GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult {
	s.NonCompliantCount = &v
	return s
}

func (s *GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult) SetTotalCount(v int32) *GetAggregateResourceComplianceByPackResponseBodyResourceComplianceResult {
	s.TotalCount = &v
	return s
}

type GetAggregateResourceComplianceByPackResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateResourceComplianceByPackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateResourceComplianceByPackResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceByPackResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceByPackResponse) SetHeaders(v map[string]*string) *GetAggregateResourceComplianceByPackResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateResourceComplianceByPackResponse) SetStatusCode(v int32) *GetAggregateResourceComplianceByPackResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateResourceComplianceByPackResponse) SetBody(v *GetAggregateResourceComplianceByPackResponseBody) *GetAggregateResourceComplianceByPackResponse {
	s.Body = v
	return s
}

type GetAggregateResourceComplianceGroupByRegionRequest struct {
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The rule IDs. Separate multiple rule IDs with commas (,).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s GetAggregateResourceComplianceGroupByRegionRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceGroupByRegionRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceGroupByRegionRequest) SetAggregatorId(v string) *GetAggregateResourceComplianceGroupByRegionRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateResourceComplianceGroupByRegionRequest) SetConfigRuleIds(v string) *GetAggregateResourceComplianceGroupByRegionRequest {
	s.ConfigRuleIds = &v
	return s
}

type GetAggregateResourceComplianceGroupByRegionResponseBody struct {
	// The queried evaluation results.
	ComplianceResult *GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResult `json:"ComplianceResult,omitempty" xml:"ComplianceResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregateResourceComplianceGroupByRegionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceGroupByRegionResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceGroupByRegionResponseBody) SetComplianceResult(v *GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResult) *GetAggregateResourceComplianceGroupByRegionResponseBody {
	s.ComplianceResult = v
	return s
}

func (s *GetAggregateResourceComplianceGroupByRegionResponseBody) SetRequestId(v string) *GetAggregateResourceComplianceGroupByRegionResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResult struct {
	// The evaluation results grouped by region.
	ComplianceResultList []*GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList `json:"ComplianceResultList,omitempty" xml:"ComplianceResultList,omitempty" type:"Repeated"`
}

func (s GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResult) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResult) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResult) SetComplianceResultList(v []*GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList) *GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResult {
	s.ComplianceResultList = v
	return s
}

type GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList struct {
	// The queried evaluation results.
	Compliances []*GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances `json:"Compliances,omitempty" xml:"Compliances,omitempty" type:"Repeated"`
	// The region ID of the evaluated resource.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList) SetCompliances(v []*GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances) *GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList {
	s.Compliances = v
	return s
}

func (s *GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList) SetRegionId(v string) *GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList {
	s.RegionId = &v
	return s
}

type GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances struct {
	// The evaluation result. Valid values:
	//
	// *   COMPLIANT: The resource is evaluated as compliant.
	// *   NON_COMPLIANT: The resource is evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to the resource.
	// *   INSUFFICIENT_DATA: No data is available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The total number of evaluation results.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances) SetComplianceType(v string) *GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances {
	s.ComplianceType = &v
	return s
}

func (s *GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances) SetCount(v int64) *GetAggregateResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances {
	s.Count = &v
	return s
}

type GetAggregateResourceComplianceGroupByRegionResponse struct {
	Headers    map[string]*string                                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateResourceComplianceGroupByRegionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateResourceComplianceGroupByRegionResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceGroupByRegionResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceGroupByRegionResponse) SetHeaders(v map[string]*string) *GetAggregateResourceComplianceGroupByRegionResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateResourceComplianceGroupByRegionResponse) SetStatusCode(v int32) *GetAggregateResourceComplianceGroupByRegionResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateResourceComplianceGroupByRegionResponse) SetBody(v *GetAggregateResourceComplianceGroupByRegionResponseBody) *GetAggregateResourceComplianceGroupByRegionResponse {
	s.Body = v
	return s
}

type GetAggregateResourceComplianceGroupByResourceTypeRequest struct {
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the rule. Separate multiple rule IDs with commas (,).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s GetAggregateResourceComplianceGroupByResourceTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceGroupByResourceTypeRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceGroupByResourceTypeRequest) SetAggregatorId(v string) *GetAggregateResourceComplianceGroupByResourceTypeRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateResourceComplianceGroupByResourceTypeRequest) SetConfigRuleIds(v string) *GetAggregateResourceComplianceGroupByResourceTypeRequest {
	s.ConfigRuleIds = &v
	return s
}

type GetAggregateResourceComplianceGroupByResourceTypeResponseBody struct {
	// The queried evaluation results.
	ComplianceResult *GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResult `json:"ComplianceResult,omitempty" xml:"ComplianceResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregateResourceComplianceGroupByResourceTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceGroupByResourceTypeResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceGroupByResourceTypeResponseBody) SetComplianceResult(v *GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResult) *GetAggregateResourceComplianceGroupByResourceTypeResponseBody {
	s.ComplianceResult = v
	return s
}

func (s *GetAggregateResourceComplianceGroupByResourceTypeResponseBody) SetRequestId(v string) *GetAggregateResourceComplianceGroupByResourceTypeResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResult struct {
	// The evaluation results grouped by resource type.
	ComplianceResultList []*GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList `json:"ComplianceResultList,omitempty" xml:"ComplianceResultList,omitempty" type:"Repeated"`
}

func (s GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResult) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResult) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResult) SetComplianceResultList(v []*GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList) *GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResult {
	s.ComplianceResultList = v
	return s
}

type GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList struct {
	// The queried evaluation results.
	Compliances []*GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances `json:"Compliances,omitempty" xml:"Compliances,omitempty" type:"Repeated"`
	// The type of the evaluated resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList) SetCompliances(v []*GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances) *GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList {
	s.Compliances = v
	return s
}

func (s *GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList) SetResourceType(v string) *GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList {
	s.ResourceType = &v
	return s
}

type GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances struct {
	// The evaluation result. Valid values:
	//
	// *   COMPLIANT: The resource is evaluated as compliant.
	// *   NON_COMPLIANT: The resource is evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to the resource.
	// *   INSUFFICIENT_DATA: No data is available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The number of statistical results.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances) SetComplianceType(v string) *GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances {
	s.ComplianceType = &v
	return s
}

func (s *GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances) SetCount(v int64) *GetAggregateResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances {
	s.Count = &v
	return s
}

type GetAggregateResourceComplianceGroupByResourceTypeResponse struct {
	Headers    map[string]*string                                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateResourceComplianceGroupByResourceTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateResourceComplianceGroupByResourceTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceGroupByResourceTypeResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceGroupByResourceTypeResponse) SetHeaders(v map[string]*string) *GetAggregateResourceComplianceGroupByResourceTypeResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateResourceComplianceGroupByResourceTypeResponse) SetStatusCode(v int32) *GetAggregateResourceComplianceGroupByResourceTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateResourceComplianceGroupByResourceTypeResponse) SetBody(v *GetAggregateResourceComplianceGroupByResourceTypeResponseBody) *GetAggregateResourceComplianceGroupByResourceTypeResponse {
	s.Body = v
	return s
}

type GetAggregateResourceComplianceTimelineRequest struct {
	// The ID of the account group.
	//
	// For information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The end of the time range to query. The default value indicates the time when the GetAggregateResourceConfigurationTimeline operation is called. Unit: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The maximum number of entries returned for a single request. Valid values: 1 to 100.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The `token` that is used to initiate the next request if the response of the current request is truncated. You can use the token to initiate another request and obtain the remaining records.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region where the resource resides.
	//
	// For more information about how to obtain the ID of a region, see [ListAggregateDiscoveredResources](~~265983~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The ID of the Alibaba Cloud account to which the resources in the account group belong.
	//
	// > You can use either the ResourceAccountId or ResourceOwnerId parameter. We recommend that you use the ResourceAccountId parameter.
	ResourceAccountId *int64 `json:"ResourceAccountId,omitempty" xml:"ResourceAccountId,omitempty"`
	// The resource ID.
	//
	// For more information about how to query the ID of a resource, see [ListAggregateDiscoveredResources](~~265983~~).
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// Deprecated
	ResourceOwnerId *int64 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The resource type.
	//
	// For more information about how to obtain the type of a resource, see [ListAggregateDiscoveredResources](~~265983~~).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The beginning of the time range to query. By default, Cloud Config retrieves the configuration changes in the last 30 days for the specified resource. Unit: milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s GetAggregateResourceComplianceTimelineRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceTimelineRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceTimelineRequest) SetAggregatorId(v string) *GetAggregateResourceComplianceTimelineRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineRequest) SetEndTime(v int64) *GetAggregateResourceComplianceTimelineRequest {
	s.EndTime = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineRequest) SetMaxResults(v int32) *GetAggregateResourceComplianceTimelineRequest {
	s.MaxResults = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineRequest) SetNextToken(v string) *GetAggregateResourceComplianceTimelineRequest {
	s.NextToken = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineRequest) SetRegion(v string) *GetAggregateResourceComplianceTimelineRequest {
	s.Region = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineRequest) SetResourceAccountId(v int64) *GetAggregateResourceComplianceTimelineRequest {
	s.ResourceAccountId = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineRequest) SetResourceId(v string) *GetAggregateResourceComplianceTimelineRequest {
	s.ResourceId = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineRequest) SetResourceOwnerId(v int64) *GetAggregateResourceComplianceTimelineRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineRequest) SetResourceType(v string) *GetAggregateResourceComplianceTimelineRequest {
	s.ResourceType = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineRequest) SetStartTime(v int64) *GetAggregateResourceComplianceTimelineRequest {
	s.StartTime = &v
	return s
}

type GetAggregateResourceComplianceTimelineResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the compliance timeline.
	ResourceComplianceTimeline *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline `json:"ResourceComplianceTimeline,omitempty" xml:"ResourceComplianceTimeline,omitempty" type:"Struct"`
}

func (s GetAggregateResourceComplianceTimelineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceTimelineResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceTimelineResponseBody) SetRequestId(v string) *GetAggregateResourceComplianceTimelineResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponseBody) SetResourceComplianceTimeline(v *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline) *GetAggregateResourceComplianceTimelineResponseBody {
	s.ResourceComplianceTimeline = v
	return s
}

type GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline struct {
	// The status of the resource. The parameter value varies based on the resource type and may be left empty. Examples:
	//
	// *   If the value of the ResourceType parameter is ACS::ECS::Instance, the resource is an Elastic Compute Service (ECS) instance that has a specific state. In this case, the valid values of this parameter are Running and Stopped.
	// *   If the value of the ResourceType parameter is ACS::OSS::Bucket, the resource is an Object Storage Service (OSS) bucket that is not in a specific state. In this case, this parameter is empty.
	ComplianceList []*GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList `json:"ComplianceList,omitempty" xml:"ComplianceList,omitempty" type:"Repeated"`
	// The maximum number of entries returned for a single request.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// A pagination token. It can be used in the next request to retrieve a new page of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline) SetComplianceList(v []*GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline {
	s.ComplianceList = v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline) SetMaxResults(v int32) *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline {
	s.MaxResults = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline) SetNextToken(v string) *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimeline {
	s.NextToken = &v
	return s
}

type GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList struct {
	// The ID of the Alibaba Cloud account to which the resource belongs.
	AccountId *string `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the zone in which the resource resides.
	AvailabilityZone *string `json:"AvailabilityZone,omitempty" xml:"AvailabilityZone,omitempty"`
	// The timestamp when the compliance evaluation was recorded. Unit: milliseconds.
	CaptureTime *int64 `json:"CaptureTime,omitempty" xml:"CaptureTime,omitempty"`
	// The information about the rules that evaluated the resource and the compliance evaluation result.
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
	// The details of the resource change that triggered the compliance evaluation.
	ConfigurationDiff *string `json:"ConfigurationDiff,omitempty" xml:"ConfigurationDiff,omitempty"`
	// The ID of the region in which the resource resides.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The timestamp when the resource was created. Unit: milliseconds.
	ResourceCreateTime *int64 `json:"ResourceCreateTime,omitempty" xml:"ResourceCreateTime,omitempty"`
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The name of the resource.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The status of the resource. The parameter value varies based on the resource type and may be left empty. Examples:
	//
	// *   If the ResourceType parameter is set to ACS::ECS::Instance, the resource is an Elastic Compute Service (ECS) instance that has a specific state. In this case, the valid values of this parameter are Running and Stopped.
	// *   If the ResourceType parameter is set to ACS::OSS::Bucket, the resource is an OSS bucket that does not have a specific state. In this case, this parameter is left empty.
	ResourceStatus *string `json:"ResourceStatus,omitempty" xml:"ResourceStatus,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags of the resource.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetAccountId(v string) *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.AccountId = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetAvailabilityZone(v string) *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.AvailabilityZone = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetCaptureTime(v int64) *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.CaptureTime = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetConfiguration(v string) *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.Configuration = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetConfigurationDiff(v string) *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.ConfigurationDiff = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetRegion(v string) *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.Region = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetResourceCreateTime(v int64) *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.ResourceCreateTime = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetResourceId(v string) *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.ResourceId = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetResourceName(v string) *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.ResourceName = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetResourceStatus(v string) *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.ResourceStatus = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetResourceType(v string) *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.ResourceType = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetTags(v string) *GetAggregateResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.Tags = &v
	return s
}

type GetAggregateResourceComplianceTimelineResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateResourceComplianceTimelineResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateResourceComplianceTimelineResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceComplianceTimelineResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceComplianceTimelineResponse) SetHeaders(v map[string]*string) *GetAggregateResourceComplianceTimelineResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponse) SetStatusCode(v int32) *GetAggregateResourceComplianceTimelineResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateResourceComplianceTimelineResponse) SetBody(v *GetAggregateResourceComplianceTimelineResponseBody) *GetAggregateResourceComplianceTimelineResponse {
	s.Body = v
	return s
}

type GetAggregateResourceConfigurationTimelineRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The end of the time range to query. The default value indicates the time when the GetAggregateResourceConfigurationTimeline operation is called. Unit: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The maximum number of entries to return for a single request. Valid values: 1 to 100.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The `token` that is used to initiate the next request if the response of the current request is truncated. You can use the token to initiate another request and obtain the remaining records.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region in which the resource resides.
	//
	// For more information about how to obtain the ID of a region, see [ListAggregateDiscoveredResources](~~265983~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The ID of the Alibaba Cloud account to which the resource in the account group belongs.
	//
	// > You can use either the ResourceAccountId or ResourceOwnerId parameter. We recommend that you use the ResourceAccountId parameter.
	ResourceAccountId *int64 `json:"ResourceAccountId,omitempty" xml:"ResourceAccountId,omitempty"`
	// The resource ID.
	//
	// For more information about how to query the ID of a resource, see [ListAggregateDiscoveredResources](~~265983~~).
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// Deprecated
	ResourceOwnerId *int64 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource.
	//
	// For more information about how to obtain the type of a resource, see [ListAggregateDiscoveredResources](~~265983~~).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The beginning of the time range to query. By default, Cloud Config retrieves the configuration changes in the last 30 days for the specified resource. Unit: milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s GetAggregateResourceConfigurationTimelineRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceConfigurationTimelineRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceConfigurationTimelineRequest) SetAggregatorId(v string) *GetAggregateResourceConfigurationTimelineRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineRequest) SetEndTime(v int64) *GetAggregateResourceConfigurationTimelineRequest {
	s.EndTime = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineRequest) SetMaxResults(v int32) *GetAggregateResourceConfigurationTimelineRequest {
	s.MaxResults = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineRequest) SetNextToken(v string) *GetAggregateResourceConfigurationTimelineRequest {
	s.NextToken = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineRequest) SetRegion(v string) *GetAggregateResourceConfigurationTimelineRequest {
	s.Region = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineRequest) SetResourceAccountId(v int64) *GetAggregateResourceConfigurationTimelineRequest {
	s.ResourceAccountId = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineRequest) SetResourceId(v string) *GetAggregateResourceConfigurationTimelineRequest {
	s.ResourceId = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineRequest) SetResourceOwnerId(v int64) *GetAggregateResourceConfigurationTimelineRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineRequest) SetResourceType(v string) *GetAggregateResourceConfigurationTimelineRequest {
	s.ResourceType = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineRequest) SetStartTime(v int64) *GetAggregateResourceConfigurationTimelineRequest {
	s.StartTime = &v
	return s
}

type GetAggregateResourceConfigurationTimelineResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The configuration timeline of the resource.
	ResourceConfigurationTimeline *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline `json:"ResourceConfigurationTimeline,omitempty" xml:"ResourceConfigurationTimeline,omitempty" type:"Struct"`
}

func (s GetAggregateResourceConfigurationTimelineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceConfigurationTimelineResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceConfigurationTimelineResponseBody) SetRequestId(v string) *GetAggregateResourceConfigurationTimelineResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineResponseBody) SetResourceConfigurationTimeline(v *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline) *GetAggregateResourceConfigurationTimelineResponseBody {
	s.ResourceConfigurationTimeline = v
	return s
}

type GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline struct {
	// The resource name.
	ConfigurationList []*GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList `json:"ConfigurationList,omitempty" xml:"ConfigurationList,omitempty" type:"Repeated"`
	// The maximum number of entries returned for a single request.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used to initiate the next request.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline) SetConfigurationList(v []*GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline {
	s.ConfigurationList = v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline) SetMaxResults(v int32) *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline {
	s.MaxResults = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline) SetNextToken(v string) *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline {
	s.NextToken = &v
	return s
}

type GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList struct {
	// The ID of the Alibaba Cloud account to which the resource belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the zone in which the resource resides.
	AvailabilityZone *string `json:"AvailabilityZone,omitempty" xml:"AvailabilityZone,omitempty"`
	// The timestamp when the resource change snapshot was recorded. Unit: milliseconds.
	CaptureTime *string `json:"CaptureTime,omitempty" xml:"CaptureTime,omitempty"`
	// The details of the resource change that triggered the compliance evaluation.
	ConfigurationDiff *string `json:"ConfigurationDiff,omitempty" xml:"ConfigurationDiff,omitempty"`
	// The ID of the region in which the resource resides.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The timestamp when the resource was created. Unit: milliseconds.
	ResourceCreateTime *string `json:"ResourceCreateTime,omitempty" xml:"ResourceCreateTime,omitempty"`
	// The type of the resource change event involved. Valid values:
	//
	// *   DISCOVERED: A resource is created.
	// *   DISCOVERED_REVISED: A resource is created by periodic remediation tasks.
	// *   MODIFY: A resource is modified.
	// *   MODIFY_REVISED: A resource is modified by periodic remediation tasks.
	// *   REMOVE: A resource is deleted.
	//
	// >
	// *   To ensure the integrity of resources, periodic remediation tasks are run to check data and generate events that indicate the creation of new resources. Such events are infrequent.
	// *   The time when a resource change event is generated by a periodic remediation task is considered as the detection time of Cloud Config. The detection time is later than the time when the resource is modified.
	ResourceEventType *string `json:"ResourceEventType,omitempty" xml:"ResourceEventType,omitempty"`
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The name of the resource.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags of the resource.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetAccountId(v int64) *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.AccountId = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetAvailabilityZone(v string) *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.AvailabilityZone = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetCaptureTime(v string) *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.CaptureTime = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetConfigurationDiff(v string) *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.ConfigurationDiff = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetRegion(v string) *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.Region = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetResourceCreateTime(v string) *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.ResourceCreateTime = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetResourceEventType(v string) *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.ResourceEventType = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetResourceId(v string) *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.ResourceId = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetResourceName(v string) *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.ResourceName = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetResourceType(v string) *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.ResourceType = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetTags(v string) *GetAggregateResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.Tags = &v
	return s
}

type GetAggregateResourceConfigurationTimelineResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateResourceConfigurationTimelineResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateResourceConfigurationTimelineResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceConfigurationTimelineResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceConfigurationTimelineResponse) SetHeaders(v map[string]*string) *GetAggregateResourceConfigurationTimelineResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineResponse) SetStatusCode(v int32) *GetAggregateResourceConfigurationTimelineResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateResourceConfigurationTimelineResponse) SetBody(v *GetAggregateResourceConfigurationTimelineResponseBody) *GetAggregateResourceConfigurationTimelineResponse {
	s.Body = v
	return s
}

type GetAggregateResourceCountsGroupByRegionRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the folder in the resource directory. For more information about how to obtain the ID of a folder, see [View the basic information of a folder](~~111223~~).
	FolderId *string `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The ID of the Alibaba Cloud account to which the resources in the account group belong.
	//
	// > You can use either the ResourceAccountId or ResourceOwnerId parameter. We recommend that you use the ResourceAccountId parameter.
	ResourceAccountId *int64 `json:"ResourceAccountId,omitempty" xml:"ResourceAccountId,omitempty"`
	// Deprecated
	ResourceOwnerId *int64 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The resource type.
	//
	// For more information about how to obtain the type of a resource, see [ListAggregateDiscoveredResources](~~265983~~).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s GetAggregateResourceCountsGroupByRegionRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceCountsGroupByRegionRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceCountsGroupByRegionRequest) SetAggregatorId(v string) *GetAggregateResourceCountsGroupByRegionRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateResourceCountsGroupByRegionRequest) SetFolderId(v string) *GetAggregateResourceCountsGroupByRegionRequest {
	s.FolderId = &v
	return s
}

func (s *GetAggregateResourceCountsGroupByRegionRequest) SetResourceAccountId(v int64) *GetAggregateResourceCountsGroupByRegionRequest {
	s.ResourceAccountId = &v
	return s
}

func (s *GetAggregateResourceCountsGroupByRegionRequest) SetResourceOwnerId(v int64) *GetAggregateResourceCountsGroupByRegionRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *GetAggregateResourceCountsGroupByRegionRequest) SetResourceType(v string) *GetAggregateResourceCountsGroupByRegionRequest {
	s.ResourceType = &v
	return s
}

type GetAggregateResourceCountsGroupByRegionResponseBody struct {
	// The ID of the region by which statistics are collected.
	DiscoveredResourceCountsSummary []*GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary `json:"DiscoveredResourceCountsSummary,omitempty" xml:"DiscoveredResourceCountsSummary,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregateResourceCountsGroupByRegionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceCountsGroupByRegionResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceCountsGroupByRegionResponseBody) SetDiscoveredResourceCountsSummary(v []*GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary) *GetAggregateResourceCountsGroupByRegionResponseBody {
	s.DiscoveredResourceCountsSummary = v
	return s
}

func (s *GetAggregateResourceCountsGroupByRegionResponseBody) SetRequestId(v string) *GetAggregateResourceCountsGroupByRegionResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary struct {
	// The dimension by which statistics are collected.
	//
	// >  In most cases, the `Region` parameter is returned instead of the GroupName parameter.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the region by which statistics are collected.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The total number of resources in the region.
	ResourceCount *int64 `json:"ResourceCount,omitempty" xml:"ResourceCount,omitempty"`
}

func (s GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary) SetGroupName(v string) *GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary {
	s.GroupName = &v
	return s
}

func (s *GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary) SetRegion(v string) *GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary {
	s.Region = &v
	return s
}

func (s *GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary) SetResourceCount(v int64) *GetAggregateResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary {
	s.ResourceCount = &v
	return s
}

type GetAggregateResourceCountsGroupByRegionResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateResourceCountsGroupByRegionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateResourceCountsGroupByRegionResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceCountsGroupByRegionResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceCountsGroupByRegionResponse) SetHeaders(v map[string]*string) *GetAggregateResourceCountsGroupByRegionResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateResourceCountsGroupByRegionResponse) SetStatusCode(v int32) *GetAggregateResourceCountsGroupByRegionResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateResourceCountsGroupByRegionResponse) SetBody(v *GetAggregateResourceCountsGroupByRegionResponseBody) *GetAggregateResourceCountsGroupByRegionResponse {
	s.Body = v
	return s
}

type GetAggregateResourceCountsGroupByResourceTypeRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the folder in the resource directory.
	//
	// For more information about how to obtain the ID of a folder, see [View the basic information of a folder](~~111223~~).
	FolderId *string `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The ID of the Alibaba Cloud account to which the resources in the account group belong.
	//
	// > You can specify either the ResourceAccountId or ResourceOwnerId parameter. We recommend that you specify the ResourceAccountId parameter.
	ResourceAccountId *int64 `json:"ResourceAccountId,omitempty" xml:"ResourceAccountId,omitempty"`
	// Deprecated
	ResourceOwnerId *int64 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GetAggregateResourceCountsGroupByResourceTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceCountsGroupByResourceTypeRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceCountsGroupByResourceTypeRequest) SetAggregatorId(v string) *GetAggregateResourceCountsGroupByResourceTypeRequest {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregateResourceCountsGroupByResourceTypeRequest) SetFolderId(v string) *GetAggregateResourceCountsGroupByResourceTypeRequest {
	s.FolderId = &v
	return s
}

func (s *GetAggregateResourceCountsGroupByResourceTypeRequest) SetRegion(v string) *GetAggregateResourceCountsGroupByResourceTypeRequest {
	s.Region = &v
	return s
}

func (s *GetAggregateResourceCountsGroupByResourceTypeRequest) SetResourceAccountId(v int64) *GetAggregateResourceCountsGroupByResourceTypeRequest {
	s.ResourceAccountId = &v
	return s
}

func (s *GetAggregateResourceCountsGroupByResourceTypeRequest) SetResourceOwnerId(v int64) *GetAggregateResourceCountsGroupByResourceTypeRequest {
	s.ResourceOwnerId = &v
	return s
}

type GetAggregateResourceCountsGroupByResourceTypeResponseBody struct {
	// The resource type by which the statistics are collected.
	DiscoveredResourceCountsSummary []*GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary `json:"DiscoveredResourceCountsSummary,omitempty" xml:"DiscoveredResourceCountsSummary,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregateResourceCountsGroupByResourceTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceCountsGroupByResourceTypeResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceCountsGroupByResourceTypeResponseBody) SetDiscoveredResourceCountsSummary(v []*GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary) *GetAggregateResourceCountsGroupByResourceTypeResponseBody {
	s.DiscoveredResourceCountsSummary = v
	return s
}

func (s *GetAggregateResourceCountsGroupByResourceTypeResponseBody) SetRequestId(v string) *GetAggregateResourceCountsGroupByResourceTypeResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary struct {
	// This parameter is expired. The resource type by which statistics are collected.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The total number of resources in the region.
	ResourceCount *int64 `json:"ResourceCount,omitempty" xml:"ResourceCount,omitempty"`
	// The resource type by which statistics are collected.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary) SetGroupName(v string) *GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary {
	s.GroupName = &v
	return s
}

func (s *GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary) SetResourceCount(v int64) *GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary {
	s.ResourceCount = &v
	return s
}

func (s *GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary) SetResourceType(v string) *GetAggregateResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary {
	s.ResourceType = &v
	return s
}

type GetAggregateResourceCountsGroupByResourceTypeResponse struct {
	Headers    map[string]*string                                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateResourceCountsGroupByResourceTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateResourceCountsGroupByResourceTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceCountsGroupByResourceTypeResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceCountsGroupByResourceTypeResponse) SetHeaders(v map[string]*string) *GetAggregateResourceCountsGroupByResourceTypeResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateResourceCountsGroupByResourceTypeResponse) SetStatusCode(v int32) *GetAggregateResourceCountsGroupByResourceTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateResourceCountsGroupByResourceTypeResponse) SetBody(v *GetAggregateResourceCountsGroupByResourceTypeResponseBody) *GetAggregateResourceCountsGroupByResourceTypeResponse {
	s.Body = v
	return s
}

type GetAggregateResourceInventoryRequest struct {
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
}

func (s GetAggregateResourceInventoryRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceInventoryRequest) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceInventoryRequest) SetAggregatorId(v string) *GetAggregateResourceInventoryRequest {
	s.AggregatorId = &v
	return s
}

type GetAggregateResourceInventoryResponseBody struct {
	RequestId         *string                                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ResourceInventory *GetAggregateResourceInventoryResponseBodyResourceInventory `json:"ResourceInventory,omitempty" xml:"ResourceInventory,omitempty" type:"Struct"`
}

func (s GetAggregateResourceInventoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceInventoryResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceInventoryResponseBody) SetRequestId(v string) *GetAggregateResourceInventoryResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAggregateResourceInventoryResponseBody) SetResourceInventory(v *GetAggregateResourceInventoryResponseBodyResourceInventory) *GetAggregateResourceInventoryResponseBody {
	s.ResourceInventory = v
	return s
}

type GetAggregateResourceInventoryResponseBodyResourceInventory struct {
	DownloadUrl                   *string `json:"DownloadUrl,omitempty" xml:"DownloadUrl,omitempty"`
	ResourceInventoryGenerateTime *int64  `json:"ResourceInventoryGenerateTime,omitempty" xml:"ResourceInventoryGenerateTime,omitempty"`
	Status                        *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetAggregateResourceInventoryResponseBodyResourceInventory) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceInventoryResponseBodyResourceInventory) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceInventoryResponseBodyResourceInventory) SetDownloadUrl(v string) *GetAggregateResourceInventoryResponseBodyResourceInventory {
	s.DownloadUrl = &v
	return s
}

func (s *GetAggregateResourceInventoryResponseBodyResourceInventory) SetResourceInventoryGenerateTime(v int64) *GetAggregateResourceInventoryResponseBodyResourceInventory {
	s.ResourceInventoryGenerateTime = &v
	return s
}

func (s *GetAggregateResourceInventoryResponseBodyResourceInventory) SetStatus(v string) *GetAggregateResourceInventoryResponseBodyResourceInventory {
	s.Status = &v
	return s
}

type GetAggregateResourceInventoryResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregateResourceInventoryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregateResourceInventoryResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregateResourceInventoryResponse) GoString() string {
	return s.String()
}

func (s *GetAggregateResourceInventoryResponse) SetHeaders(v map[string]*string) *GetAggregateResourceInventoryResponse {
	s.Headers = v
	return s
}

func (s *GetAggregateResourceInventoryResponse) SetStatusCode(v int32) *GetAggregateResourceInventoryResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregateResourceInventoryResponse) SetBody(v *GetAggregateResourceInventoryResponseBody) *GetAggregateResourceInventoryResponse {
	s.Body = v
	return s
}

type GetAggregatorRequest struct {
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
}

func (s GetAggregatorRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAggregatorRequest) GoString() string {
	return s.String()
}

func (s *GetAggregatorRequest) SetAggregatorId(v string) *GetAggregatorRequest {
	s.AggregatorId = &v
	return s
}

type GetAggregatorResponseBody struct {
	// The details of the account group.
	Aggregator *GetAggregatorResponseBodyAggregator `json:"Aggregator,omitempty" xml:"Aggregator,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetAggregatorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAggregatorResponseBody) GoString() string {
	return s.String()
}

func (s *GetAggregatorResponseBody) SetAggregator(v *GetAggregatorResponseBodyAggregator) *GetAggregatorResponseBody {
	s.Aggregator = v
	return s
}

func (s *GetAggregatorResponseBody) SetRequestId(v string) *GetAggregatorResponseBody {
	s.RequestId = &v
	return s
}

type GetAggregatorResponseBodyAggregator struct {
	// The ID of the management account used to create the account group.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The number of member accounts in the account group.
	AggregatorAccountCount *int64 `json:"AggregatorAccountCount,omitempty" xml:"AggregatorAccountCount,omitempty"`
	// The information about the member accounts in the account group.
	AggregatorAccounts []*GetAggregatorResponseBodyAggregatorAggregatorAccounts `json:"AggregatorAccounts,omitempty" xml:"AggregatorAccounts,omitempty" type:"Repeated"`
	// The timestamp when the account group was created.
	AggregatorCreateTimestamp *string `json:"AggregatorCreateTimestamp,omitempty" xml:"AggregatorCreateTimestamp,omitempty"`
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The name of the account group.
	AggregatorName *string `json:"AggregatorName,omitempty" xml:"AggregatorName,omitempty"`
	// The status of the account group. Valid values:
	//
	// *   0: The account group is being created.
	// *   1: The account group has been created.
	AggregatorStatus *int32 `json:"AggregatorStatus,omitempty" xml:"AggregatorStatus,omitempty"`
	// The type of the account group. Valid values:
	//
	// *   RD: global account group
	// *   CUSTOM: custom account group
	AggregatorType *string `json:"AggregatorType,omitempty" xml:"AggregatorType,omitempty"`
	// The description of the account group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
}

func (s GetAggregatorResponseBodyAggregator) String() string {
	return tea.Prettify(s)
}

func (s GetAggregatorResponseBodyAggregator) GoString() string {
	return s.String()
}

func (s *GetAggregatorResponseBodyAggregator) SetAccountId(v int64) *GetAggregatorResponseBodyAggregator {
	s.AccountId = &v
	return s
}

func (s *GetAggregatorResponseBodyAggregator) SetAggregatorAccountCount(v int64) *GetAggregatorResponseBodyAggregator {
	s.AggregatorAccountCount = &v
	return s
}

func (s *GetAggregatorResponseBodyAggregator) SetAggregatorAccounts(v []*GetAggregatorResponseBodyAggregatorAggregatorAccounts) *GetAggregatorResponseBodyAggregator {
	s.AggregatorAccounts = v
	return s
}

func (s *GetAggregatorResponseBodyAggregator) SetAggregatorCreateTimestamp(v string) *GetAggregatorResponseBodyAggregator {
	s.AggregatorCreateTimestamp = &v
	return s
}

func (s *GetAggregatorResponseBodyAggregator) SetAggregatorId(v string) *GetAggregatorResponseBodyAggregator {
	s.AggregatorId = &v
	return s
}

func (s *GetAggregatorResponseBodyAggregator) SetAggregatorName(v string) *GetAggregatorResponseBodyAggregator {
	s.AggregatorName = &v
	return s
}

func (s *GetAggregatorResponseBodyAggregator) SetAggregatorStatus(v int32) *GetAggregatorResponseBodyAggregator {
	s.AggregatorStatus = &v
	return s
}

func (s *GetAggregatorResponseBodyAggregator) SetAggregatorType(v string) *GetAggregatorResponseBodyAggregator {
	s.AggregatorType = &v
	return s
}

func (s *GetAggregatorResponseBodyAggregator) SetDescription(v string) *GetAggregatorResponseBodyAggregator {
	s.Description = &v
	return s
}

type GetAggregatorResponseBodyAggregatorAggregatorAccounts struct {
	// The ID of the member account.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The name of the member account.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The affiliation of the member account. The value is fixed to ResourceDirectory.
	AccountType *string `json:"AccountType,omitempty" xml:"AccountType,omitempty"`
	// The status of the configuration recorder for the member account. Valid values:
	//
	// *   REGISTRABLE: The configuration recorder has not been registered.
	// *   BUILDING: The configuration recorder is being deployed.
	// *   REGISTERED: The configuration recorder has been registered.
	// *   REBUILDING: The configuration recorder is being redeployed.
	RecorderStatus *string `json:"RecorderStatus,omitempty" xml:"RecorderStatus,omitempty"`
}

func (s GetAggregatorResponseBodyAggregatorAggregatorAccounts) String() string {
	return tea.Prettify(s)
}

func (s GetAggregatorResponseBodyAggregatorAggregatorAccounts) GoString() string {
	return s.String()
}

func (s *GetAggregatorResponseBodyAggregatorAggregatorAccounts) SetAccountId(v int64) *GetAggregatorResponseBodyAggregatorAggregatorAccounts {
	s.AccountId = &v
	return s
}

func (s *GetAggregatorResponseBodyAggregatorAggregatorAccounts) SetAccountName(v string) *GetAggregatorResponseBodyAggregatorAggregatorAccounts {
	s.AccountName = &v
	return s
}

func (s *GetAggregatorResponseBodyAggregatorAggregatorAccounts) SetAccountType(v string) *GetAggregatorResponseBodyAggregatorAggregatorAccounts {
	s.AccountType = &v
	return s
}

func (s *GetAggregatorResponseBodyAggregatorAggregatorAccounts) SetRecorderStatus(v string) *GetAggregatorResponseBodyAggregatorAggregatorAccounts {
	s.RecorderStatus = &v
	return s
}

type GetAggregatorResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetAggregatorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetAggregatorResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAggregatorResponse) GoString() string {
	return s.String()
}

func (s *GetAggregatorResponse) SetHeaders(v map[string]*string) *GetAggregatorResponse {
	s.Headers = v
	return s
}

func (s *GetAggregatorResponse) SetStatusCode(v int32) *GetAggregatorResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAggregatorResponse) SetBody(v *GetAggregatorResponseBody) *GetAggregatorResponse {
	s.Body = v
	return s
}

type GetCompliancePackRequest struct {
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListCompliancePacks](~~263332~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
}

func (s GetCompliancePackRequest) String() string {
	return tea.Prettify(s)
}

func (s GetCompliancePackRequest) GoString() string {
	return s.String()
}

func (s *GetCompliancePackRequest) SetCompliancePackId(v string) *GetCompliancePackRequest {
	s.CompliancePackId = &v
	return s
}

type GetCompliancePackResponseBody struct {
	// The details of the compliance package.
	CompliancePack *GetCompliancePackResponseBodyCompliancePack `json:"CompliancePack,omitempty" xml:"CompliancePack,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetCompliancePackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetCompliancePackResponseBody) GoString() string {
	return s.String()
}

func (s *GetCompliancePackResponseBody) SetCompliancePack(v *GetCompliancePackResponseBodyCompliancePack) *GetCompliancePackResponseBody {
	s.CompliancePack = v
	return s
}

func (s *GetCompliancePackResponseBody) SetRequestId(v string) *GetCompliancePackResponseBody {
	s.RequestId = &v
	return s
}

type GetCompliancePackResponseBodyCompliancePack struct {
	// The ID of the Alibaba Cloud account to which the compliance package belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The name of the compliance package.
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
	// The ID of the compliance package template.
	CompliancePackTemplateId *string `json:"CompliancePackTemplateId,omitempty" xml:"CompliancePackTemplateId,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high
	// *   2: medium
	// *   3: low
	ConfigRules []*GetCompliancePackResponseBodyCompliancePackConfigRules `json:"ConfigRules,omitempty" xml:"ConfigRules,omitempty" type:"Repeated"`
	// The timestamp when the compliance package was created. Unit: milliseconds.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The description of the compliance package.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The risk level of the resources that are not compliant with the rules in the compliance package. Valid values:
	//
	// *   1: high
	// *   2: medium
	// *   3: low
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The resource group for which the compliance package took effect.
	Scope *GetCompliancePackResponseBodyCompliancePackScope `json:"Scope,omitempty" xml:"Scope,omitempty" type:"Struct"`
	// The status of the compliance package. Valid values:
	//
	// *   ACTIVE: The compliance package is normal.
	// *   CREATING: The compliance package is being created.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetCompliancePackResponseBodyCompliancePack) String() string {
	return tea.Prettify(s)
}

func (s GetCompliancePackResponseBodyCompliancePack) GoString() string {
	return s.String()
}

func (s *GetCompliancePackResponseBodyCompliancePack) SetAccountId(v int64) *GetCompliancePackResponseBodyCompliancePack {
	s.AccountId = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePack) SetCompliancePackId(v string) *GetCompliancePackResponseBodyCompliancePack {
	s.CompliancePackId = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePack) SetCompliancePackName(v string) *GetCompliancePackResponseBodyCompliancePack {
	s.CompliancePackName = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePack) SetCompliancePackTemplateId(v string) *GetCompliancePackResponseBodyCompliancePack {
	s.CompliancePackTemplateId = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePack) SetConfigRules(v []*GetCompliancePackResponseBodyCompliancePackConfigRules) *GetCompliancePackResponseBodyCompliancePack {
	s.ConfigRules = v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePack) SetCreateTimestamp(v int64) *GetCompliancePackResponseBodyCompliancePack {
	s.CreateTimestamp = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePack) SetDescription(v string) *GetCompliancePackResponseBodyCompliancePack {
	s.Description = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePack) SetRiskLevel(v int32) *GetCompliancePackResponseBodyCompliancePack {
	s.RiskLevel = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePack) SetScope(v *GetCompliancePackResponseBodyCompliancePackScope) *GetCompliancePackResponseBodyCompliancePack {
	s.Scope = v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePack) SetStatus(v string) *GetCompliancePackResponseBodyCompliancePack {
	s.Status = &v
	return s
}

type GetCompliancePackResponseBodyCompliancePackConfigRules struct {
	// The rule ID.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The details of the input parameter of the rule.
	ConfigRuleParameters []*GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters `json:"ConfigRuleParameters,omitempty" xml:"ConfigRuleParameters,omitempty" type:"Repeated"`
	// The description of the rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The identifier of the managed rule.
	ManagedRuleIdentifier *string `json:"ManagedRuleIdentifier,omitempty" xml:"ManagedRuleIdentifier,omitempty"`
	ResourceTypesScope    *string `json:"ResourceTypesScope,omitempty" xml:"ResourceTypesScope,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high
	// *   2: medium
	// *   3: low
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s GetCompliancePackResponseBodyCompliancePackConfigRules) String() string {
	return tea.Prettify(s)
}

func (s GetCompliancePackResponseBodyCompliancePackConfigRules) GoString() string {
	return s.String()
}

func (s *GetCompliancePackResponseBodyCompliancePackConfigRules) SetConfigRuleId(v string) *GetCompliancePackResponseBodyCompliancePackConfigRules {
	s.ConfigRuleId = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePackConfigRules) SetConfigRuleName(v string) *GetCompliancePackResponseBodyCompliancePackConfigRules {
	s.ConfigRuleName = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePackConfigRules) SetConfigRuleParameters(v []*GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters) *GetCompliancePackResponseBodyCompliancePackConfigRules {
	s.ConfigRuleParameters = v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePackConfigRules) SetDescription(v string) *GetCompliancePackResponseBodyCompliancePackConfigRules {
	s.Description = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePackConfigRules) SetManagedRuleIdentifier(v string) *GetCompliancePackResponseBodyCompliancePackConfigRules {
	s.ManagedRuleIdentifier = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePackConfigRules) SetResourceTypesScope(v string) *GetCompliancePackResponseBodyCompliancePackConfigRules {
	s.ResourceTypesScope = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePackConfigRules) SetRiskLevel(v int32) *GetCompliancePackResponseBodyCompliancePackConfigRules {
	s.RiskLevel = &v
	return s
}

type GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters struct {
	// The name of the input parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The value of the input parameter.
	ParameterValue *string `json:"ParameterValue,omitempty" xml:"ParameterValue,omitempty"`
	// Indicates whether the input parameter is required. Valid values:
	//
	// *   true: The input parameter is required.
	// *   false: The input parameter is optional.
	Required *bool `json:"Required,omitempty" xml:"Required,omitempty"`
}

func (s GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters) String() string {
	return tea.Prettify(s)
}

func (s GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters) GoString() string {
	return s.String()
}

func (s *GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters) SetParameterName(v string) *GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters {
	s.ParameterName = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters) SetParameterValue(v string) *GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters {
	s.ParameterValue = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters) SetRequired(v bool) *GetCompliancePackResponseBodyCompliancePackConfigRulesConfigRuleParameters {
	s.Required = &v
	return s
}

type GetCompliancePackResponseBodyCompliancePackScope struct {
	// The ID of the resource that you do not want to evaluate by using the compliance package.
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The ID of the region whose resources you want to evaluate by using the compliance package.
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group whose resources you want to evaluate by using the compliance package.
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The tag key of the resource that you want to evaluate by using the compliance package.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value of the resource that you want to evaluate by using the compliance package.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s GetCompliancePackResponseBodyCompliancePackScope) String() string {
	return tea.Prettify(s)
}

func (s GetCompliancePackResponseBodyCompliancePackScope) GoString() string {
	return s.String()
}

func (s *GetCompliancePackResponseBodyCompliancePackScope) SetExcludeResourceIdsScope(v string) *GetCompliancePackResponseBodyCompliancePackScope {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePackScope) SetRegionIdsScope(v string) *GetCompliancePackResponseBodyCompliancePackScope {
	s.RegionIdsScope = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePackScope) SetResourceGroupIdsScope(v string) *GetCompliancePackResponseBodyCompliancePackScope {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePackScope) SetTagKeyScope(v string) *GetCompliancePackResponseBodyCompliancePackScope {
	s.TagKeyScope = &v
	return s
}

func (s *GetCompliancePackResponseBodyCompliancePackScope) SetTagValueScope(v string) *GetCompliancePackResponseBodyCompliancePackScope {
	s.TagValueScope = &v
	return s
}

type GetCompliancePackResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetCompliancePackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetCompliancePackResponse) String() string {
	return tea.Prettify(s)
}

func (s GetCompliancePackResponse) GoString() string {
	return s.String()
}

func (s *GetCompliancePackResponse) SetHeaders(v map[string]*string) *GetCompliancePackResponse {
	s.Headers = v
	return s
}

func (s *GetCompliancePackResponse) SetStatusCode(v int32) *GetCompliancePackResponse {
	s.StatusCode = &v
	return s
}

func (s *GetCompliancePackResponse) SetBody(v *GetCompliancePackResponseBody) *GetCompliancePackResponse {
	s.Body = v
	return s
}

type GetCompliancePackReportRequest struct {
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListCompliancePacks](~~263332~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
}

func (s GetCompliancePackReportRequest) String() string {
	return tea.Prettify(s)
}

func (s GetCompliancePackReportRequest) GoString() string {
	return s.String()
}

func (s *GetCompliancePackReportRequest) SetCompliancePackId(v string) *GetCompliancePackReportRequest {
	s.CompliancePackId = &v
	return s
}

type GetCompliancePackReportResponseBody struct {
	// The information about the compliance evaluation report.
	CompliancePackReport *GetCompliancePackReportResponseBodyCompliancePackReport `json:"CompliancePackReport,omitempty" xml:"CompliancePackReport,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetCompliancePackReportResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetCompliancePackReportResponseBody) GoString() string {
	return s.String()
}

func (s *GetCompliancePackReportResponseBody) SetCompliancePackReport(v *GetCompliancePackReportResponseBodyCompliancePackReport) *GetCompliancePackReportResponseBody {
	s.CompliancePackReport = v
	return s
}

func (s *GetCompliancePackReportResponseBody) SetRequestId(v string) *GetCompliancePackReportResponseBody {
	s.RequestId = &v
	return s
}

type GetCompliancePackReportResponseBodyCompliancePackReport struct {
	// The ID of the Alibaba Cloud account to which the compliance package belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The timestamp when the compliance evaluation report was generated. Unit: milliseconds.
	ReportCreateTimestamp *int64 `json:"ReportCreateTimestamp,omitempty" xml:"ReportCreateTimestamp,omitempty"`
	// The status of the compliance evaluation report. Valid values:
	//
	// *   NONE: The compliance evaluation report is not generated.
	// *   CREATING: The compliance evaluation report is being generated.
	// *   COMPLETE: The compliance evaluation report is generated.
	ReportStatus *string `json:"ReportStatus,omitempty" xml:"ReportStatus,omitempty"`
	// The URL that is used to download the compliance evaluation report.
	ReportUrl *string `json:"ReportUrl,omitempty" xml:"ReportUrl,omitempty"`
}

func (s GetCompliancePackReportResponseBodyCompliancePackReport) String() string {
	return tea.Prettify(s)
}

func (s GetCompliancePackReportResponseBodyCompliancePackReport) GoString() string {
	return s.String()
}

func (s *GetCompliancePackReportResponseBodyCompliancePackReport) SetAccountId(v int64) *GetCompliancePackReportResponseBodyCompliancePackReport {
	s.AccountId = &v
	return s
}

func (s *GetCompliancePackReportResponseBodyCompliancePackReport) SetCompliancePackId(v string) *GetCompliancePackReportResponseBodyCompliancePackReport {
	s.CompliancePackId = &v
	return s
}

func (s *GetCompliancePackReportResponseBodyCompliancePackReport) SetReportCreateTimestamp(v int64) *GetCompliancePackReportResponseBodyCompliancePackReport {
	s.ReportCreateTimestamp = &v
	return s
}

func (s *GetCompliancePackReportResponseBodyCompliancePackReport) SetReportStatus(v string) *GetCompliancePackReportResponseBodyCompliancePackReport {
	s.ReportStatus = &v
	return s
}

func (s *GetCompliancePackReportResponseBodyCompliancePackReport) SetReportUrl(v string) *GetCompliancePackReportResponseBodyCompliancePackReport {
	s.ReportUrl = &v
	return s
}

type GetCompliancePackReportResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetCompliancePackReportResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetCompliancePackReportResponse) String() string {
	return tea.Prettify(s)
}

func (s GetCompliancePackReportResponse) GoString() string {
	return s.String()
}

func (s *GetCompliancePackReportResponse) SetHeaders(v map[string]*string) *GetCompliancePackReportResponse {
	s.Headers = v
	return s
}

func (s *GetCompliancePackReportResponse) SetStatusCode(v int32) *GetCompliancePackReportResponse {
	s.StatusCode = &v
	return s
}

func (s *GetCompliancePackReportResponse) SetBody(v *GetCompliancePackReportResponseBody) *GetCompliancePackReportResponse {
	s.Body = v
	return s
}

type GetComplianceSummaryResponseBody struct {
	ComplianceSummary *GetComplianceSummaryResponseBodyComplianceSummary `json:"ComplianceSummary,omitempty" xml:"ComplianceSummary,omitempty" type:"Struct"`
	RequestId         *string                                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetComplianceSummaryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetComplianceSummaryResponseBody) GoString() string {
	return s.String()
}

func (s *GetComplianceSummaryResponseBody) SetComplianceSummary(v *GetComplianceSummaryResponseBodyComplianceSummary) *GetComplianceSummaryResponseBody {
	s.ComplianceSummary = v
	return s
}

func (s *GetComplianceSummaryResponseBody) SetRequestId(v string) *GetComplianceSummaryResponseBody {
	s.RequestId = &v
	return s
}

type GetComplianceSummaryResponseBodyComplianceSummary struct {
	ComplianceSummaryByConfigRule *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule `json:"ComplianceSummaryByConfigRule,omitempty" xml:"ComplianceSummaryByConfigRule,omitempty" type:"Struct"`
	ComplianceSummaryByResource   *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource   `json:"ComplianceSummaryByResource,omitempty" xml:"ComplianceSummaryByResource,omitempty" type:"Struct"`
}

func (s GetComplianceSummaryResponseBodyComplianceSummary) String() string {
	return tea.Prettify(s)
}

func (s GetComplianceSummaryResponseBodyComplianceSummary) GoString() string {
	return s.String()
}

func (s *GetComplianceSummaryResponseBodyComplianceSummary) SetComplianceSummaryByConfigRule(v *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule) *GetComplianceSummaryResponseBodyComplianceSummary {
	s.ComplianceSummaryByConfigRule = v
	return s
}

func (s *GetComplianceSummaryResponseBodyComplianceSummary) SetComplianceSummaryByResource(v *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource) *GetComplianceSummaryResponseBodyComplianceSummary {
	s.ComplianceSummaryByResource = v
	return s
}

type GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule struct {
	ComplianceSummaryTimestamp *int64 `json:"ComplianceSummaryTimestamp,omitempty" xml:"ComplianceSummaryTimestamp,omitempty"`
	CompliantCount             *int32 `json:"CompliantCount,omitempty" xml:"CompliantCount,omitempty"`
	NonCompliantCount          *int32 `json:"NonCompliantCount,omitempty" xml:"NonCompliantCount,omitempty"`
	TotalCount                 *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule) String() string {
	return tea.Prettify(s)
}

func (s GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule) GoString() string {
	return s.String()
}

func (s *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule) SetComplianceSummaryTimestamp(v int64) *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule {
	s.ComplianceSummaryTimestamp = &v
	return s
}

func (s *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule) SetCompliantCount(v int32) *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule {
	s.CompliantCount = &v
	return s
}

func (s *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule) SetNonCompliantCount(v int32) *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule {
	s.NonCompliantCount = &v
	return s
}

func (s *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule) SetTotalCount(v int64) *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByConfigRule {
	s.TotalCount = &v
	return s
}

type GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource struct {
	ComplianceSummaryTimestamp *int64 `json:"ComplianceSummaryTimestamp,omitempty" xml:"ComplianceSummaryTimestamp,omitempty"`
	CompliantCount             *int32 `json:"CompliantCount,omitempty" xml:"CompliantCount,omitempty"`
	NonCompliantCount          *int32 `json:"NonCompliantCount,omitempty" xml:"NonCompliantCount,omitempty"`
	TotalCount                 *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource) String() string {
	return tea.Prettify(s)
}

func (s GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource) GoString() string {
	return s.String()
}

func (s *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource) SetComplianceSummaryTimestamp(v int64) *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource {
	s.ComplianceSummaryTimestamp = &v
	return s
}

func (s *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource) SetCompliantCount(v int32) *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource {
	s.CompliantCount = &v
	return s
}

func (s *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource) SetNonCompliantCount(v int32) *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource {
	s.NonCompliantCount = &v
	return s
}

func (s *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource) SetTotalCount(v int64) *GetComplianceSummaryResponseBodyComplianceSummaryComplianceSummaryByResource {
	s.TotalCount = &v
	return s
}

type GetComplianceSummaryResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetComplianceSummaryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetComplianceSummaryResponse) String() string {
	return tea.Prettify(s)
}

func (s GetComplianceSummaryResponse) GoString() string {
	return s.String()
}

func (s *GetComplianceSummaryResponse) SetHeaders(v map[string]*string) *GetComplianceSummaryResponse {
	s.Headers = v
	return s
}

func (s *GetComplianceSummaryResponse) SetStatusCode(v int32) *GetComplianceSummaryResponse {
	s.StatusCode = &v
	return s
}

func (s *GetComplianceSummaryResponse) SetBody(v *GetComplianceSummaryResponseBody) *GetComplianceSummaryResponse {
	s.Body = v
	return s
}

type GetConfigDeliveryChannelRequest struct {
	// The ID of the delivery channel.
	//
	// For more information about how to obtain the ID of a delivery channel, see [DescribeDeliveryChannels](~~429841~~).
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
}

func (s GetConfigDeliveryChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s GetConfigDeliveryChannelRequest) GoString() string {
	return s.String()
}

func (s *GetConfigDeliveryChannelRequest) SetDeliveryChannelId(v string) *GetConfigDeliveryChannelRequest {
	s.DeliveryChannelId = &v
	return s
}

type GetConfigDeliveryChannelResponseBody struct {
	// The information about the delivery channel.
	DeliveryChannel *GetConfigDeliveryChannelResponseBodyDeliveryChannel `json:"DeliveryChannel,omitempty" xml:"DeliveryChannel,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetConfigDeliveryChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetConfigDeliveryChannelResponseBody) GoString() string {
	return s.String()
}

func (s *GetConfigDeliveryChannelResponseBody) SetDeliveryChannel(v *GetConfigDeliveryChannelResponseBodyDeliveryChannel) *GetConfigDeliveryChannelResponseBody {
	s.DeliveryChannel = v
	return s
}

func (s *GetConfigDeliveryChannelResponseBody) SetRequestId(v string) *GetConfigDeliveryChannelResponseBody {
	s.RequestId = &v
	return s
}

type GetConfigDeliveryChannelResponseBodyDeliveryChannel struct {
	// The ID of your Alibaba Cloud account.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// Indicates whether the specified destination receives resource change logs. If the value of this parameter is true, Cloud Config delivers the resource change logs to OSS, Log Service, or MNS when the configurations of the resources change. Valid values:
	//
	// *   true: The specified destination receives resource change logs.
	// *   false: The specified destination does not receive resource change logs.
	ConfigurationItemChangeNotification *bool `json:"ConfigurationItemChangeNotification,omitempty" xml:"ConfigurationItemChangeNotification,omitempty"`
	// Indicates whether the specified destination receives scheduled resource snapshots. Cloud Config delivers scheduled resource snapshots at `04:00Z` and `16:00Z` to OSS, MNS, or Log Service every day. The time is displayed in UTC. Valid values:
	//
	// *   true: The specified destination receives scheduled resource snapshots.
	// *   false: The specified destination does not receive scheduled resource snapshots.
	ConfigurationSnapshot *bool `json:"ConfigurationSnapshot,omitempty" xml:"ConfigurationSnapshot,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the role assumed by the delivery channel.
	DeliveryChannelAssumeRoleArn *string `json:"DeliveryChannelAssumeRoleArn,omitempty" xml:"DeliveryChannelAssumeRoleArn,omitempty"`
	// The rule that is attached to the delivery channel. This parameter is available when you deliver data of all types to MNS or deliver snapshots to Log Service.
	//
	// *   If the value of the DeliveryChannelType parameter is MNS, take note of the following settings of the lowest risk level and resource types of the events to which you subscribed:
	//
	//     *   The setting of the lowest risk level for the events to which you want to subscribe is in the following format: `{"filterType":"RuleRiskLevel","value":"1","multiple":false}`.
	//
	//         The `value` field indicates the lowest risk level of the events to which you want to subscribe. Valid values: 1, 2, and 3. The value 1 indicates the high risk level, the value 2 indicates the medium risk level, and the value 3 indicates the low risk level.
	//
	//     *   The setting of the resource types of the events to which you want to subscribe is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//         The `values` field indicates the resource types of the events to which you want to subscribe. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	//
	// *   If you set the DeliveryChannelType parameter to SLS, the setting of the resource types of the snapshots to which you want to deliver is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//     The `values` field specifies the resource types of the snapshots to which you want to deliver. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	DeliveryChannelCondition *string `json:"DeliveryChannelCondition,omitempty" xml:"DeliveryChannelCondition,omitempty"`
	// The ID of the delivery channel.
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
	// The name of the delivery channel.
	DeliveryChannelName *string `json:"DeliveryChannelName,omitempty" xml:"DeliveryChannelName,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the delivery destination.
	//
	// *   If the value of the DeliveryChannelType parameter is OSS, the value of this parameter is the ARN of the destination OSS bucket.
	// *   If the value of the DeliveryChannelType parameter is MNS, the value of this parameter is the ARN of the destination MNS topic.
	// *   If the value of the DeliveryChannelType parameter is SLS, the value of this parameter is the ARN of the destination Log Service Logstore.
	DeliveryChannelTargetArn *string `json:"DeliveryChannelTargetArn,omitempty" xml:"DeliveryChannelTargetArn,omitempty"`
	// The type of the delivery channel. Valid values:
	//
	// *   OSS: Object Storage Service (OSS)
	// *   MNS: Message Service (MNS)
	// *   SLS: Log Service
	DeliveryChannelType *string `json:"DeliveryChannelType,omitempty" xml:"DeliveryChannelType,omitempty"`
	// The time when Cloud Config delivers scheduled resources snapshots every day.
	//
	// Format: `HH:mmZ`. This time is displayed in UTC.
	DeliverySnapshotTime *string `json:"DeliverySnapshotTime,omitempty" xml:"DeliverySnapshotTime,omitempty"`
	// The description of the delivery channel.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the specified destination receives resource non-compliance events. If the value of this parameter is true, Cloud Config delivers resource non-compliance events to Log Service or MNS when resources are evaluated as non-compliant. Valid values:
	//
	// *   true: The specified destination receives resource non-compliance events.
	// *   false: The specified destination does not receive resource non-compliance events.
	NonCompliantNotification *bool `json:"NonCompliantNotification,omitempty" xml:"NonCompliantNotification,omitempty"`
	// The ARN of the OSS bucket to which you want to transfer the delivery data when the size of the data exceeds the specified upper limit of the delivery channel.
	OversizedDataOSSTargetArn *string `json:"OversizedDataOSSTargetArn,omitempty" xml:"OversizedDataOSSTargetArn,omitempty"`
	// The status of the delivery channel. Valid values:
	//
	// *   0: The delivery channel is disabled.
	// *   1: The delivery channel is enabled.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetConfigDeliveryChannelResponseBodyDeliveryChannel) String() string {
	return tea.Prettify(s)
}

func (s GetConfigDeliveryChannelResponseBodyDeliveryChannel) GoString() string {
	return s.String()
}

func (s *GetConfigDeliveryChannelResponseBodyDeliveryChannel) SetAccountId(v int64) *GetConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.AccountId = &v
	return s
}

func (s *GetConfigDeliveryChannelResponseBodyDeliveryChannel) SetConfigurationItemChangeNotification(v bool) *GetConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.ConfigurationItemChangeNotification = &v
	return s
}

func (s *GetConfigDeliveryChannelResponseBodyDeliveryChannel) SetConfigurationSnapshot(v bool) *GetConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.ConfigurationSnapshot = &v
	return s
}

func (s *GetConfigDeliveryChannelResponseBodyDeliveryChannel) SetDeliveryChannelAssumeRoleArn(v string) *GetConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.DeliveryChannelAssumeRoleArn = &v
	return s
}

func (s *GetConfigDeliveryChannelResponseBodyDeliveryChannel) SetDeliveryChannelCondition(v string) *GetConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.DeliveryChannelCondition = &v
	return s
}

func (s *GetConfigDeliveryChannelResponseBodyDeliveryChannel) SetDeliveryChannelId(v string) *GetConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.DeliveryChannelId = &v
	return s
}

func (s *GetConfigDeliveryChannelResponseBodyDeliveryChannel) SetDeliveryChannelName(v string) *GetConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.DeliveryChannelName = &v
	return s
}

func (s *GetConfigDeliveryChannelResponseBodyDeliveryChannel) SetDeliveryChannelTargetArn(v string) *GetConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.DeliveryChannelTargetArn = &v
	return s
}

func (s *GetConfigDeliveryChannelResponseBodyDeliveryChannel) SetDeliveryChannelType(v string) *GetConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.DeliveryChannelType = &v
	return s
}

func (s *GetConfigDeliveryChannelResponseBodyDeliveryChannel) SetDeliverySnapshotTime(v string) *GetConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.DeliverySnapshotTime = &v
	return s
}

func (s *GetConfigDeliveryChannelResponseBodyDeliveryChannel) SetDescription(v string) *GetConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.Description = &v
	return s
}

func (s *GetConfigDeliveryChannelResponseBodyDeliveryChannel) SetNonCompliantNotification(v bool) *GetConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.NonCompliantNotification = &v
	return s
}

func (s *GetConfigDeliveryChannelResponseBodyDeliveryChannel) SetOversizedDataOSSTargetArn(v string) *GetConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.OversizedDataOSSTargetArn = &v
	return s
}

func (s *GetConfigDeliveryChannelResponseBodyDeliveryChannel) SetStatus(v int32) *GetConfigDeliveryChannelResponseBodyDeliveryChannel {
	s.Status = &v
	return s
}

type GetConfigDeliveryChannelResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetConfigDeliveryChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetConfigDeliveryChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s GetConfigDeliveryChannelResponse) GoString() string {
	return s.String()
}

func (s *GetConfigDeliveryChannelResponse) SetHeaders(v map[string]*string) *GetConfigDeliveryChannelResponse {
	s.Headers = v
	return s
}

func (s *GetConfigDeliveryChannelResponse) SetStatusCode(v int32) *GetConfigDeliveryChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *GetConfigDeliveryChannelResponse) SetBody(v *GetConfigDeliveryChannelResponseBody) *GetConfigDeliveryChannelResponse {
	s.Body = v
	return s
}

type GetConfigRuleRequest struct {
	// The rule ID.
	//
	// For more information about how to obtain the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
}

func (s GetConfigRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleRequest) GoString() string {
	return s.String()
}

func (s *GetConfigRuleRequest) SetConfigRuleId(v string) *GetConfigRuleRequest {
	s.ConfigRuleId = &v
	return s
}

type GetConfigRuleResponseBody struct {
	// The details of the rule.
	ConfigRule *GetConfigRuleResponseBodyConfigRule `json:"ConfigRule,omitempty" xml:"ConfigRule,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetConfigRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleResponseBody) GoString() string {
	return s.String()
}

func (s *GetConfigRuleResponseBody) SetConfigRule(v *GetConfigRuleResponseBodyConfigRule) *GetConfigRuleResponseBody {
	s.ConfigRule = v
	return s
}

func (s *GetConfigRuleResponseBody) SetRequestId(v string) *GetConfigRuleResponseBody {
	s.RequestId = &v
	return s
}

type GetConfigRuleResponseBodyConfigRule struct {
	// The ID of the Alibaba Cloud account to which the rule belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The details of compliance evaluation results.
	Compliance *GetConfigRuleResponseBodyConfigRuleCompliance `json:"Compliance,omitempty" xml:"Compliance,omitempty" type:"Struct"`
	// The ARN of the managed rule.
	ConfigRuleArn *string `json:"ConfigRuleArn,omitempty" xml:"ConfigRuleArn,omitempty"`
	// The information about compliance evaluations performed by the rule.
	ConfigRuleEvaluationStatus *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus `json:"ConfigRuleEvaluationStatus,omitempty" xml:"ConfigRuleEvaluationStatus,omitempty" type:"Struct"`
	// The rule ID.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the defense rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The status of the rule. Valid values:
	//
	// *   ACTIVE: The rule was being used to monitor resource configurations.
	// *   DELETING: The rule was being deleted.
	// *   EVALUATING: The rule was triggered and is being used to monitor resource configurations.
	// *   INACTIVE: The rule was disabled.
	ConfigRuleState *string `json:"ConfigRuleState,omitempty" xml:"ConfigRuleState,omitempty"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The rule was triggered by configuration changes.
	// *   ScheduledNotification: The rule was periodically triggered.
	ConfigRuleTriggerTypes *string `json:"ConfigRuleTriggerTypes,omitempty" xml:"ConfigRuleTriggerTypes,omitempty"`
	// The information about the creation of the rule.
	CreateBy *GetConfigRuleResponseBodyConfigRuleCreateBy `json:"CreateBy,omitempty" xml:"CreateBy,omitempty" type:"Struct"`
	// The timestamp when the rule was created. Unit: milliseconds.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The description of the managed rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the resource excluded from the compliance evaluations performed by the rule.
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The details of the input parameters of the rule.
	InputParameters map[string]interface{} `json:"InputParameters,omitempty" xml:"InputParameters,omitempty"`
	// The details of the managed rule.
	ManagedRule *GetConfigRuleResponseBodyConfigRuleManagedRule `json:"ManagedRule,omitempty" xml:"ManagedRule,omitempty" type:"Struct"`
	// The interval at which the rule was triggered. Valid values:
	//
	// *   One_Hour: 1 hour.
	// *   Three_Hours: 3 hours.
	// *   Six_Hours: 6 hours.
	// *   Twelve_Hours: 12 hours.
	// *   TwentyFour_Hours: 24 hours.
	//
	// > This parameter is returned if the managed rule is periodically triggered.
	MaximumExecutionFrequency *string `json:"MaximumExecutionFrequency,omitempty" xml:"MaximumExecutionFrequency,omitempty"`
	// The timestamp when the rule was last updated. Unit: milliseconds.
	ModifiedTimestamp *int64 `json:"ModifiedTimestamp,omitempty" xml:"ModifiedTimestamp,omitempty"`
	// The ID of the region to which the rule applies.
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group to which the rule applies.
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The type of the resource to be evaluated by the rule.
	ResourceTypesScope *string `json:"ResourceTypesScope,omitempty" xml:"ResourceTypesScope,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high
	// *   2: medium
	// *   3: low
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The effective scope of the rule.
	Scope *GetConfigRuleResponseBodyConfigRuleScope `json:"Scope,omitempty" xml:"Scope,omitempty" type:"Struct"`
	// The information about how the rule was created.
	Source *GetConfigRuleResponseBodyConfigRuleSource `json:"Source,omitempty" xml:"Source,omitempty" type:"Struct"`
	// The ID of the member account to which the rule does not apply, which means that the resources within the member account are not evaluated based on the rule.
	//
	// > This parameter applies only to a managed rule.
	TagKeyLogicScope *string `json:"TagKeyLogicScope,omitempty" xml:"TagKeyLogicScope,omitempty"`
	// The tag key used to filter resources. The rule applies only to the resources with the specified tag key.
	//
	// > The `TagKeyScope` and `TagValueScope` parameters are returned at the same time.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value used to filter resources. The rule applies only to the resources with the specified tag value.
	//
	// > The `TagKeyScope` and `TagValueScope` parameters are returned at the same time.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s GetConfigRuleResponseBodyConfigRule) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleResponseBodyConfigRule) GoString() string {
	return s.String()
}

func (s *GetConfigRuleResponseBodyConfigRule) SetAccountId(v int64) *GetConfigRuleResponseBodyConfigRule {
	s.AccountId = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetCompliance(v *GetConfigRuleResponseBodyConfigRuleCompliance) *GetConfigRuleResponseBodyConfigRule {
	s.Compliance = v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetConfigRuleArn(v string) *GetConfigRuleResponseBodyConfigRule {
	s.ConfigRuleArn = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetConfigRuleEvaluationStatus(v *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) *GetConfigRuleResponseBodyConfigRule {
	s.ConfigRuleEvaluationStatus = v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetConfigRuleId(v string) *GetConfigRuleResponseBodyConfigRule {
	s.ConfigRuleId = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetConfigRuleName(v string) *GetConfigRuleResponseBodyConfigRule {
	s.ConfigRuleName = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetConfigRuleState(v string) *GetConfigRuleResponseBodyConfigRule {
	s.ConfigRuleState = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetConfigRuleTriggerTypes(v string) *GetConfigRuleResponseBodyConfigRule {
	s.ConfigRuleTriggerTypes = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetCreateBy(v *GetConfigRuleResponseBodyConfigRuleCreateBy) *GetConfigRuleResponseBodyConfigRule {
	s.CreateBy = v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetCreateTimestamp(v int64) *GetConfigRuleResponseBodyConfigRule {
	s.CreateTimestamp = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetDescription(v string) *GetConfigRuleResponseBodyConfigRule {
	s.Description = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetExcludeResourceIdsScope(v string) *GetConfigRuleResponseBodyConfigRule {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetInputParameters(v map[string]interface{}) *GetConfigRuleResponseBodyConfigRule {
	s.InputParameters = v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetManagedRule(v *GetConfigRuleResponseBodyConfigRuleManagedRule) *GetConfigRuleResponseBodyConfigRule {
	s.ManagedRule = v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetMaximumExecutionFrequency(v string) *GetConfigRuleResponseBodyConfigRule {
	s.MaximumExecutionFrequency = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetModifiedTimestamp(v int64) *GetConfigRuleResponseBodyConfigRule {
	s.ModifiedTimestamp = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetRegionIdsScope(v string) *GetConfigRuleResponseBodyConfigRule {
	s.RegionIdsScope = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetResourceGroupIdsScope(v string) *GetConfigRuleResponseBodyConfigRule {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetResourceTypesScope(v string) *GetConfigRuleResponseBodyConfigRule {
	s.ResourceTypesScope = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetRiskLevel(v int32) *GetConfigRuleResponseBodyConfigRule {
	s.RiskLevel = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetScope(v *GetConfigRuleResponseBodyConfigRuleScope) *GetConfigRuleResponseBodyConfigRule {
	s.Scope = v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetSource(v *GetConfigRuleResponseBodyConfigRuleSource) *GetConfigRuleResponseBodyConfigRule {
	s.Source = v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetTagKeyLogicScope(v string) *GetConfigRuleResponseBodyConfigRule {
	s.TagKeyLogicScope = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetTagKeyScope(v string) *GetConfigRuleResponseBodyConfigRule {
	s.TagKeyScope = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRule) SetTagValueScope(v string) *GetConfigRuleResponseBodyConfigRule {
	s.TagValueScope = &v
	return s
}

type GetConfigRuleResponseBodyConfigRuleCompliance struct {
	// The statistics on the compliance evaluation results by compliance type. Valid values:
	//
	// *   COMPLIANT: The resource was evaluated as compliant.
	// *   NON_COMPLIANT: The resource was evaluated as incompliant.
	// *   NOT_APPLICABLE: The rule did not apply to your resource.
	// *   INSUFFICIENT_DATA: No resource data was available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The number of evaluated resources.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s GetConfigRuleResponseBodyConfigRuleCompliance) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleResponseBodyConfigRuleCompliance) GoString() string {
	return s.String()
}

func (s *GetConfigRuleResponseBodyConfigRuleCompliance) SetComplianceType(v string) *GetConfigRuleResponseBodyConfigRuleCompliance {
	s.ComplianceType = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleCompliance) SetCount(v int32) *GetConfigRuleResponseBodyConfigRuleCompliance {
	s.Count = &v
	return s
}

type GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus struct {
	// The timestamp when the rule was first triggered. Unit: milliseconds.
	FirstActivatedTimestamp *int64 `json:"FirstActivatedTimestamp,omitempty" xml:"FirstActivatedTimestamp,omitempty"`
	// Indicates whether resources were evaluated based on the rule. Valid values:
	//
	// *   true: Resources were evaluated based on the rule.
	// *   false: Resources were not evaluated based on the rule.
	FirstEvaluationStarted *bool `json:"FirstEvaluationStarted,omitempty" xml:"FirstEvaluationStarted,omitempty"`
	// The error code returned for the last failed compliance evaluation.
	LastErrorCode *string `json:"LastErrorCode,omitempty" xml:"LastErrorCode,omitempty"`
	// The error message returned for the last failed compliance evaluation.
	LastErrorMessage *string `json:"LastErrorMessage,omitempty" xml:"LastErrorMessage,omitempty"`
	// The timestamp when the last failed compliance evaluation of the rule ended. Unit: milliseconds.
	LastFailedEvaluationTimestamp *int64 `json:"LastFailedEvaluationTimestamp,omitempty" xml:"LastFailedEvaluationTimestamp,omitempty"`
	// The timestamp when the last failed compliance evaluation of the rule started. Unit: milliseconds.
	LastFailedInvocationTimestamp *int64 `json:"LastFailedInvocationTimestamp,omitempty" xml:"LastFailedInvocationTimestamp,omitempty"`
	// The timestamp when the last successful compliance evaluation of the rule ended. Unit: milliseconds.
	LastSuccessfulEvaluationTimestamp *int64 `json:"LastSuccessfulEvaluationTimestamp,omitempty" xml:"LastSuccessfulEvaluationTimestamp,omitempty"`
	// The timestamp when the last successful compliance evaluation of the rule started. Unit: milliseconds.
	LastSuccessfulInvocationTimestamp *int64 `json:"LastSuccessfulInvocationTimestamp,omitempty" xml:"LastSuccessfulInvocationTimestamp,omitempty"`
}

func (s GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) GoString() string {
	return s.String()
}

func (s *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetFirstActivatedTimestamp(v int64) *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.FirstActivatedTimestamp = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetFirstEvaluationStarted(v bool) *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.FirstEvaluationStarted = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetLastErrorCode(v string) *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.LastErrorCode = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetLastErrorMessage(v string) *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.LastErrorMessage = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetLastFailedEvaluationTimestamp(v int64) *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.LastFailedEvaluationTimestamp = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetLastFailedInvocationTimestamp(v int64) *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.LastFailedInvocationTimestamp = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetLastSuccessfulEvaluationTimestamp(v int64) *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.LastSuccessfulEvaluationTimestamp = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus) SetLastSuccessfulInvocationTimestamp(v int64) *GetConfigRuleResponseBodyConfigRuleConfigRuleEvaluationStatus {
	s.LastSuccessfulInvocationTimestamp = &v
	return s
}

type GetConfigRuleResponseBodyConfigRuleCreateBy struct {
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The name of the compliance package.
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
	// The ID of the account that was used to create the rule.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The name of the account that was used to create the rule.
	CreatorName *string `json:"CreatorName,omitempty" xml:"CreatorName,omitempty"`
}

func (s GetConfigRuleResponseBodyConfigRuleCreateBy) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleResponseBodyConfigRuleCreateBy) GoString() string {
	return s.String()
}

func (s *GetConfigRuleResponseBodyConfigRuleCreateBy) SetCompliancePackId(v string) *GetConfigRuleResponseBodyConfigRuleCreateBy {
	s.CompliancePackId = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleCreateBy) SetCompliancePackName(v string) *GetConfigRuleResponseBodyConfigRuleCreateBy {
	s.CompliancePackName = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleCreateBy) SetCreatorId(v string) *GetConfigRuleResponseBodyConfigRuleCreateBy {
	s.CreatorId = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleCreateBy) SetCreatorName(v string) *GetConfigRuleResponseBodyConfigRuleCreateBy {
	s.CreatorName = &v
	return s
}

type GetConfigRuleResponseBodyConfigRuleManagedRule struct {
	// The required input parameters of the managed rule.
	CompulsoryInputParameterDetails map[string]interface{} `json:"CompulsoryInputParameterDetails,omitempty" xml:"CompulsoryInputParameterDetails,omitempty"`
	// The description of the managed rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the managed rule.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The list of rule tags.
	Labels []*string `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	// The name of the managed rule.
	ManagedRuleName *string `json:"ManagedRuleName,omitempty" xml:"ManagedRuleName,omitempty"`
	// The optional input parameters of the managed rule.
	OptionalInputParameterDetails map[string]interface{} `json:"OptionalInputParameterDetails,omitempty" xml:"OptionalInputParameterDetails,omitempty"`
	// The interval at which the rule is triggered. Valid values:
	//
	// *   One_Hour: 1 hour
	// *   Three_Hours: 3 hours
	// *   Six_Hours: 6 hours
	// *   Twelve_Hours: 12 hours
	// *   TwentyFour_Hours: 24 hours
	//
	// > This parameter is returned if the rule is periodically triggered.
	SourceDetails []*GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails `json:"SourceDetails,omitempty" xml:"SourceDetails,omitempty" type:"Repeated"`
}

func (s GetConfigRuleResponseBodyConfigRuleManagedRule) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleResponseBodyConfigRuleManagedRule) GoString() string {
	return s.String()
}

func (s *GetConfigRuleResponseBodyConfigRuleManagedRule) SetCompulsoryInputParameterDetails(v map[string]interface{}) *GetConfigRuleResponseBodyConfigRuleManagedRule {
	s.CompulsoryInputParameterDetails = v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleManagedRule) SetDescription(v string) *GetConfigRuleResponseBodyConfigRuleManagedRule {
	s.Description = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleManagedRule) SetIdentifier(v string) *GetConfigRuleResponseBodyConfigRuleManagedRule {
	s.Identifier = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleManagedRule) SetLabels(v []*string) *GetConfigRuleResponseBodyConfigRuleManagedRule {
	s.Labels = v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleManagedRule) SetManagedRuleName(v string) *GetConfigRuleResponseBodyConfigRuleManagedRule {
	s.ManagedRuleName = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleManagedRule) SetOptionalInputParameterDetails(v map[string]interface{}) *GetConfigRuleResponseBodyConfigRuleManagedRule {
	s.OptionalInputParameterDetails = v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleManagedRule) SetSourceDetails(v []*GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails) *GetConfigRuleResponseBodyConfigRuleManagedRule {
	s.SourceDetails = v
	return s
}

type GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails struct {
	// The event source.
	//
	// > Only events related to Cloud Config are supported. The value is fixed to aliyun.config.
	EventSource *string `json:"EventSource,omitempty" xml:"EventSource,omitempty"`
	// The interval at which the rule was triggered. Valid values:
	//
	// *   One_Hour: 1 hour.
	// *   Three_Hours: 3 hours.
	// *   Six_Hours: 6 hours.
	// *   Twelve_Hours: 12 hours.
	// *   TwentyFour_Hours: 24 hours.
	//
	// > This parameter is returned if the managed rule is periodically triggered.
	MaximumExecutionFrequency *string `json:"MaximumExecutionFrequency,omitempty" xml:"MaximumExecutionFrequency,omitempty"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The rule was triggered by configuration changes.
	// *   ScheduledNotification: The rule was periodically triggered.
	MessageType *string `json:"MessageType,omitempty" xml:"MessageType,omitempty"`
}

func (s GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails) GoString() string {
	return s.String()
}

func (s *GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails) SetEventSource(v string) *GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails {
	s.EventSource = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails) SetMaximumExecutionFrequency(v string) *GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails {
	s.MaximumExecutionFrequency = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails) SetMessageType(v string) *GetConfigRuleResponseBodyConfigRuleManagedRuleSourceDetails {
	s.MessageType = &v
	return s
}

type GetConfigRuleResponseBodyConfigRuleScope struct {
	// The types of the resources to be evaluated against the rule. You can also view the resource types by using the ResourceTypesScope parameter.
	ComplianceResourceTypes []*string `json:"ComplianceResourceTypes,omitempty" xml:"ComplianceResourceTypes,omitempty" type:"Repeated"`
}

func (s GetConfigRuleResponseBodyConfigRuleScope) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleResponseBodyConfigRuleScope) GoString() string {
	return s.String()
}

func (s *GetConfigRuleResponseBodyConfigRuleScope) SetComplianceResourceTypes(v []*string) *GetConfigRuleResponseBodyConfigRuleScope {
	s.ComplianceResourceTypes = v
	return s
}

type GetConfigRuleResponseBodyConfigRuleSource struct {
	// The identifier of the evaluation rule.
	//
	// *   If the rule was created based on a managed rule, the value of this parameter is the name of the managed rule.
	// *   If the rule is a custom rule, the value of this parameter is the Alibaba Cloud Resource Name (ARN) of the relevant function in Function Compute.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The method that is used to create the rule. Valid values:
	//
	// *   CUSTOM_FC: a custom rule.
	// *   ALIYUN: a managed rule.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The interval at which the rule is triggered. Valid values:
	//
	// *   One_Hour: 1 hour
	// *   Three_Hours: 3 hours
	// *   Six_Hours: 6 hours
	// *   Twelve_Hours: 12 hours
	// *   TwentyFour_Hours: 24 hours
	//
	// > This parameter is returned if the rule is periodically triggered.
	SourceDetails []*GetConfigRuleResponseBodyConfigRuleSourceSourceDetails `json:"SourceDetails,omitempty" xml:"SourceDetails,omitempty" type:"Repeated"`
}

func (s GetConfigRuleResponseBodyConfigRuleSource) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleResponseBodyConfigRuleSource) GoString() string {
	return s.String()
}

func (s *GetConfigRuleResponseBodyConfigRuleSource) SetIdentifier(v string) *GetConfigRuleResponseBodyConfigRuleSource {
	s.Identifier = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleSource) SetOwner(v string) *GetConfigRuleResponseBodyConfigRuleSource {
	s.Owner = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleSource) SetSourceDetails(v []*GetConfigRuleResponseBodyConfigRuleSourceSourceDetails) *GetConfigRuleResponseBodyConfigRuleSource {
	s.SourceDetails = v
	return s
}

type GetConfigRuleResponseBodyConfigRuleSourceSourceDetails struct {
	// The event source.
	//
	// > Only events related to Cloud Config are supported. The value is fixed to aliyun.config.
	EventSource *string `json:"EventSource,omitempty" xml:"EventSource,omitempty"`
	// The interval at which the rule was triggered. Valid values:
	//
	// *   One_Hour: 1 hour.
	// *   Three_Hours: 3 hours.
	// *   Six_Hours: 6 hours.
	// *   Twelve_Hours: 12 hours.
	// *   TwentyFour_Hours: 24 hours.
	//
	// > This parameter is returned if the managed rule is periodically triggered.
	MaximumExecutionFrequency *string `json:"MaximumExecutionFrequency,omitempty" xml:"MaximumExecutionFrequency,omitempty"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The rule was triggered by configuration changes.
	// *   ScheduledNotification: The rule was periodically triggered.
	MessageType *string `json:"MessageType,omitempty" xml:"MessageType,omitempty"`
}

func (s GetConfigRuleResponseBodyConfigRuleSourceSourceDetails) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleResponseBodyConfigRuleSourceSourceDetails) GoString() string {
	return s.String()
}

func (s *GetConfigRuleResponseBodyConfigRuleSourceSourceDetails) SetEventSource(v string) *GetConfigRuleResponseBodyConfigRuleSourceSourceDetails {
	s.EventSource = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleSourceSourceDetails) SetMaximumExecutionFrequency(v string) *GetConfigRuleResponseBodyConfigRuleSourceSourceDetails {
	s.MaximumExecutionFrequency = &v
	return s
}

func (s *GetConfigRuleResponseBodyConfigRuleSourceSourceDetails) SetMessageType(v string) *GetConfigRuleResponseBodyConfigRuleSourceSourceDetails {
	s.MessageType = &v
	return s
}

type GetConfigRuleResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetConfigRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetConfigRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleResponse) GoString() string {
	return s.String()
}

func (s *GetConfigRuleResponse) SetHeaders(v map[string]*string) *GetConfigRuleResponse {
	s.Headers = v
	return s
}

func (s *GetConfigRuleResponse) SetStatusCode(v int32) *GetConfigRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *GetConfigRuleResponse) SetBody(v *GetConfigRuleResponseBody) *GetConfigRuleResponse {
	s.Body = v
	return s
}

type GetConfigRuleComplianceByPackRequest struct {
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListCompliancePacks](~~263332~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
}

func (s GetConfigRuleComplianceByPackRequest) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleComplianceByPackRequest) GoString() string {
	return s.String()
}

func (s *GetConfigRuleComplianceByPackRequest) SetCompliancePackId(v string) *GetConfigRuleComplianceByPackRequest {
	s.CompliancePackId = &v
	return s
}

type GetConfigRuleComplianceByPackResponseBody struct {
	// The information about the compliance evaluation results returned.
	ConfigRuleComplianceResult *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult `json:"ConfigRuleComplianceResult,omitempty" xml:"ConfigRuleComplianceResult,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetConfigRuleComplianceByPackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleComplianceByPackResponseBody) GoString() string {
	return s.String()
}

func (s *GetConfigRuleComplianceByPackResponseBody) SetConfigRuleComplianceResult(v *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult) *GetConfigRuleComplianceByPackResponseBody {
	s.ConfigRuleComplianceResult = v
	return s
}

func (s *GetConfigRuleComplianceByPackResponseBody) SetRequestId(v string) *GetConfigRuleComplianceByPackResponseBody {
	s.RequestId = &v
	return s
}

type GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult struct {
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The rule enabled in the compliance package and the compliance evaluation result returned by the rule.
	ConfigRuleCompliances []*GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances `json:"ConfigRuleCompliances,omitempty" xml:"ConfigRuleCompliances,omitempty" type:"Repeated"`
	// The number of rules against which specific resources are evaluated as non-compliant.
	NonCompliantCount *int32 `json:"NonCompliantCount,omitempty" xml:"NonCompliantCount,omitempty"`
	// The total number of rules enabled in the compliance package.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult) GoString() string {
	return s.String()
}

func (s *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult) SetCompliancePackId(v string) *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult {
	s.CompliancePackId = &v
	return s
}

func (s *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult) SetConfigRuleCompliances(v []*GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances) *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult {
	s.ConfigRuleCompliances = v
	return s
}

func (s *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult) SetNonCompliantCount(v int32) *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult {
	s.NonCompliantCount = &v
	return s
}

func (s *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult) SetTotalCount(v int32) *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResult {
	s.TotalCount = &v
	return s
}

type GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances struct {
	// The compliance evaluation result. Valid values:
	//
	// *   COMPLIANT: The relevant resources are evaluated as compliant.
	// *   NON_COMPLIANT: The relevant resources are evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to your resources.
	// *   INSUFFICIENT_DATA: No resource data is available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The ID of the rule enabled in the compliance package.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the rule enabled in the compliance package.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
}

func (s GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances) GoString() string {
	return s.String()
}

func (s *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances) SetComplianceType(v string) *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances {
	s.ComplianceType = &v
	return s
}

func (s *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances) SetConfigRuleId(v string) *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances {
	s.ConfigRuleId = &v
	return s
}

func (s *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances) SetConfigRuleName(v string) *GetConfigRuleComplianceByPackResponseBodyConfigRuleComplianceResultConfigRuleCompliances {
	s.ConfigRuleName = &v
	return s
}

type GetConfigRuleComplianceByPackResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetConfigRuleComplianceByPackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetConfigRuleComplianceByPackResponse) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleComplianceByPackResponse) GoString() string {
	return s.String()
}

func (s *GetConfigRuleComplianceByPackResponse) SetHeaders(v map[string]*string) *GetConfigRuleComplianceByPackResponse {
	s.Headers = v
	return s
}

func (s *GetConfigRuleComplianceByPackResponse) SetStatusCode(v int32) *GetConfigRuleComplianceByPackResponse {
	s.StatusCode = &v
	return s
}

func (s *GetConfigRuleComplianceByPackResponse) SetBody(v *GetConfigRuleComplianceByPackResponseBody) *GetConfigRuleComplianceByPackResponse {
	s.Body = v
	return s
}

type GetConfigRuleSummaryByRiskLevelResponseBody struct {
	// The summary of compliance evaluation results by rule risk level.
	ConfigRuleSummaries []*GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries `json:"ConfigRuleSummaries,omitempty" xml:"ConfigRuleSummaries,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetConfigRuleSummaryByRiskLevelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleSummaryByRiskLevelResponseBody) GoString() string {
	return s.String()
}

func (s *GetConfigRuleSummaryByRiskLevelResponseBody) SetConfigRuleSummaries(v []*GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries) *GetConfigRuleSummaryByRiskLevelResponseBody {
	s.ConfigRuleSummaries = v
	return s
}

func (s *GetConfigRuleSummaryByRiskLevelResponseBody) SetRequestId(v string) *GetConfigRuleSummaryByRiskLevelResponseBody {
	s.RequestId = &v
	return s
}

type GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries struct {
	// The number of rules against which specific resources are evaluated as compliant.
	CompliantCount *int32 `json:"CompliantCount,omitempty" xml:"CompliantCount,omitempty"`
	// The number of rules against which specific resources are evaluated as non-compliant.
	NonCompliantCount *int32 `json:"NonCompliantCount,omitempty" xml:"NonCompliantCount,omitempty"`
	// The risk level of the resources that are not compliant with the rules. Valid values:
	//
	// *   1: high risk level.
	// *   2: medium risk level.
	// *   3: low risk level.
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries) GoString() string {
	return s.String()
}

func (s *GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries) SetCompliantCount(v int32) *GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries {
	s.CompliantCount = &v
	return s
}

func (s *GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries) SetNonCompliantCount(v int32) *GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries {
	s.NonCompliantCount = &v
	return s
}

func (s *GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries) SetRiskLevel(v int32) *GetConfigRuleSummaryByRiskLevelResponseBodyConfigRuleSummaries {
	s.RiskLevel = &v
	return s
}

type GetConfigRuleSummaryByRiskLevelResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetConfigRuleSummaryByRiskLevelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetConfigRuleSummaryByRiskLevelResponse) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRuleSummaryByRiskLevelResponse) GoString() string {
	return s.String()
}

func (s *GetConfigRuleSummaryByRiskLevelResponse) SetHeaders(v map[string]*string) *GetConfigRuleSummaryByRiskLevelResponse {
	s.Headers = v
	return s
}

func (s *GetConfigRuleSummaryByRiskLevelResponse) SetStatusCode(v int32) *GetConfigRuleSummaryByRiskLevelResponse {
	s.StatusCode = &v
	return s
}

func (s *GetConfigRuleSummaryByRiskLevelResponse) SetBody(v *GetConfigRuleSummaryByRiskLevelResponseBody) *GetConfigRuleSummaryByRiskLevelResponse {
	s.Body = v
	return s
}

type GetConfigRulesReportRequest struct {
	// The ID of the compliance evaluation report.
	ReportId *string `json:"ReportId,omitempty" xml:"ReportId,omitempty"`
}

func (s GetConfigRulesReportRequest) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRulesReportRequest) GoString() string {
	return s.String()
}

func (s *GetConfigRulesReportRequest) SetReportId(v string) *GetConfigRulesReportRequest {
	s.ReportId = &v
	return s
}

type GetConfigRulesReportResponseBody struct {
	// The information about the compliance evaluation report.
	ConfigRulesReport *GetConfigRulesReportResponseBodyConfigRulesReport `json:"ConfigRulesReport,omitempty" xml:"ConfigRulesReport,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetConfigRulesReportResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRulesReportResponseBody) GoString() string {
	return s.String()
}

func (s *GetConfigRulesReportResponseBody) SetConfigRulesReport(v *GetConfigRulesReportResponseBodyConfigRulesReport) *GetConfigRulesReportResponseBody {
	s.ConfigRulesReport = v
	return s
}

func (s *GetConfigRulesReportResponseBody) SetRequestId(v string) *GetConfigRulesReportResponseBody {
	s.RequestId = &v
	return s
}

type GetConfigRulesReportResponseBodyConfigRulesReport struct {
	// The ID of the Alibaba Cloud account to which the rules belong.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The timestamp when the compliance evaluation report was generated. Unit: milliseconds.
	ReportCreateTimestamp *int64 `json:"ReportCreateTimestamp,omitempty" xml:"ReportCreateTimestamp,omitempty"`
	// The ID of the compliance evaluation report.
	ReportId *string `json:"ReportId,omitempty" xml:"ReportId,omitempty"`
	// The status of the compliance evaluation report. Valid values:
	//
	// *   NONE: The compliance evaluation report is not generated.
	// *   CREATING: The compliance evaluation report is being generated.
	// *   COMPLETE: The compliance evaluation report is generated.
	ReportStatus *string `json:"ReportStatus,omitempty" xml:"ReportStatus,omitempty"`
	// The URL that is used to download the compliance evaluation report.
	ReportUrl *string `json:"ReportUrl,omitempty" xml:"ReportUrl,omitempty"`
}

func (s GetConfigRulesReportResponseBodyConfigRulesReport) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRulesReportResponseBodyConfigRulesReport) GoString() string {
	return s.String()
}

func (s *GetConfigRulesReportResponseBodyConfigRulesReport) SetAccountId(v int64) *GetConfigRulesReportResponseBodyConfigRulesReport {
	s.AccountId = &v
	return s
}

func (s *GetConfigRulesReportResponseBodyConfigRulesReport) SetReportCreateTimestamp(v int64) *GetConfigRulesReportResponseBodyConfigRulesReport {
	s.ReportCreateTimestamp = &v
	return s
}

func (s *GetConfigRulesReportResponseBodyConfigRulesReport) SetReportId(v string) *GetConfigRulesReportResponseBodyConfigRulesReport {
	s.ReportId = &v
	return s
}

func (s *GetConfigRulesReportResponseBodyConfigRulesReport) SetReportStatus(v string) *GetConfigRulesReportResponseBodyConfigRulesReport {
	s.ReportStatus = &v
	return s
}

func (s *GetConfigRulesReportResponseBodyConfigRulesReport) SetReportUrl(v string) *GetConfigRulesReportResponseBodyConfigRulesReport {
	s.ReportUrl = &v
	return s
}

type GetConfigRulesReportResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetConfigRulesReportResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetConfigRulesReportResponse) String() string {
	return tea.Prettify(s)
}

func (s GetConfigRulesReportResponse) GoString() string {
	return s.String()
}

func (s *GetConfigRulesReportResponse) SetHeaders(v map[string]*string) *GetConfigRulesReportResponse {
	s.Headers = v
	return s
}

func (s *GetConfigRulesReportResponse) SetStatusCode(v int32) *GetConfigRulesReportResponse {
	s.StatusCode = &v
	return s
}

func (s *GetConfigRulesReportResponse) SetBody(v *GetConfigRulesReportResponseBody) *GetConfigRulesReportResponse {
	s.Body = v
	return s
}

type GetConfigurationRecorderResponseBody struct {
	ConfigurationRecorder *GetConfigurationRecorderResponseBodyConfigurationRecorder `json:"ConfigurationRecorder,omitempty" xml:"ConfigurationRecorder,omitempty" type:"Struct"`
	RequestId             *string                                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetConfigurationRecorderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetConfigurationRecorderResponseBody) GoString() string {
	return s.String()
}

func (s *GetConfigurationRecorderResponseBody) SetConfigurationRecorder(v *GetConfigurationRecorderResponseBodyConfigurationRecorder) *GetConfigurationRecorderResponseBody {
	s.ConfigurationRecorder = v
	return s
}

func (s *GetConfigurationRecorderResponseBody) SetRequestId(v string) *GetConfigurationRecorderResponseBody {
	s.RequestId = &v
	return s
}

type GetConfigurationRecorderResponseBodyConfigurationRecorder struct {
	ConfigurationRecorderStatus *string   `json:"ConfigurationRecorderStatus,omitempty" xml:"ConfigurationRecorderStatus,omitempty"`
	ResourceTypes               []*string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty" type:"Repeated"`
}

func (s GetConfigurationRecorderResponseBodyConfigurationRecorder) String() string {
	return tea.Prettify(s)
}

func (s GetConfigurationRecorderResponseBodyConfigurationRecorder) GoString() string {
	return s.String()
}

func (s *GetConfigurationRecorderResponseBodyConfigurationRecorder) SetConfigurationRecorderStatus(v string) *GetConfigurationRecorderResponseBodyConfigurationRecorder {
	s.ConfigurationRecorderStatus = &v
	return s
}

func (s *GetConfigurationRecorderResponseBodyConfigurationRecorder) SetResourceTypes(v []*string) *GetConfigurationRecorderResponseBodyConfigurationRecorder {
	s.ResourceTypes = v
	return s
}

type GetConfigurationRecorderResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetConfigurationRecorderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetConfigurationRecorderResponse) String() string {
	return tea.Prettify(s)
}

func (s GetConfigurationRecorderResponse) GoString() string {
	return s.String()
}

func (s *GetConfigurationRecorderResponse) SetHeaders(v map[string]*string) *GetConfigurationRecorderResponse {
	s.Headers = v
	return s
}

func (s *GetConfigurationRecorderResponse) SetStatusCode(v int32) *GetConfigurationRecorderResponse {
	s.StatusCode = &v
	return s
}

func (s *GetConfigurationRecorderResponse) SetBody(v *GetConfigurationRecorderResponseBody) *GetConfigurationRecorderResponse {
	s.Body = v
	return s
}

type GetDiscoveredResourceRequest struct {
	// The ID of the region in which the resource resides.
	//
	// For more information about how to query the region ID of a resource, see [ListDiscoveredResources](~~411702~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The ID of the resource.
	//
	// For more information about how to query the ID of a resource, see [ListDiscoveredResources](~~411702~~).
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource.
	//
	// For more information about how to query the type of a resource, see [ListDiscoveredResources](~~411702~~).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s GetDiscoveredResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDiscoveredResourceRequest) GoString() string {
	return s.String()
}

func (s *GetDiscoveredResourceRequest) SetRegion(v string) *GetDiscoveredResourceRequest {
	s.Region = &v
	return s
}

func (s *GetDiscoveredResourceRequest) SetResourceId(v string) *GetDiscoveredResourceRequest {
	s.ResourceId = &v
	return s
}

func (s *GetDiscoveredResourceRequest) SetResourceType(v string) *GetDiscoveredResourceRequest {
	s.ResourceType = &v
	return s
}

type GetDiscoveredResourceResponseBody struct {
	// The information about the resource.
	DiscoveredResourceDetail *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail `json:"DiscoveredResourceDetail,omitempty" xml:"DiscoveredResourceDetail,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetDiscoveredResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDiscoveredResourceResponseBody) GoString() string {
	return s.String()
}

func (s *GetDiscoveredResourceResponseBody) SetDiscoveredResourceDetail(v *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail) *GetDiscoveredResourceResponseBody {
	s.DiscoveredResourceDetail = v
	return s
}

func (s *GetDiscoveredResourceResponseBody) SetRequestId(v string) *GetDiscoveredResourceResponseBody {
	s.RequestId = &v
	return s
}

type GetDiscoveredResourceResponseBodyDiscoveredResourceDetail struct {
	// The ID of the Alibaba Cloud account to which the resource belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the zone in which the resource resides.
	AvailabilityZone *string `json:"AvailabilityZone,omitempty" xml:"AvailabilityZone,omitempty"`
	// The configuration of the resource.
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
	// The ID of the region in which the resource resides.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The timestamp when the resource was created.
	ResourceCreationTime *int64 `json:"ResourceCreationTime,omitempty" xml:"ResourceCreationTime,omitempty"`
	// Indicates whether the resource is deleted. Valid values:
	//
	// *   1: The resource is retained.
	// *   0: The resource is deleted.
	ResourceDeleted *int32 `json:"ResourceDeleted,omitempty" xml:"ResourceDeleted,omitempty"`
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The name of the resource.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The status of the resource. The parameter value varies based on the resource type and may be left empty. Examples:
	//
	// *   If the value of the ResourceType parameter is ACS::ECS::Instance, the resource is an Elastic Compute Service (ECS) instance that has a specific state. In this case, the valid values of this parameter are Running and Stopped.
	// *   If the value of the ResourceType parameter is ACS::OSS::Bucket, the resource is an Object Storage Service (OSS) bucket that does not have a specific state. In this case, this parameter is left empty.
	ResourceStatus *string `json:"ResourceStatus,omitempty" xml:"ResourceStatus,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags of the resource.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s GetDiscoveredResourceResponseBodyDiscoveredResourceDetail) String() string {
	return tea.Prettify(s)
}

func (s GetDiscoveredResourceResponseBodyDiscoveredResourceDetail) GoString() string {
	return s.String()
}

func (s *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetAccountId(v int64) *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.AccountId = &v
	return s
}

func (s *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetAvailabilityZone(v string) *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.AvailabilityZone = &v
	return s
}

func (s *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetConfiguration(v string) *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.Configuration = &v
	return s
}

func (s *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetRegion(v string) *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.Region = &v
	return s
}

func (s *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetResourceCreationTime(v int64) *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.ResourceCreationTime = &v
	return s
}

func (s *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetResourceDeleted(v int32) *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.ResourceDeleted = &v
	return s
}

func (s *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetResourceId(v string) *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.ResourceId = &v
	return s
}

func (s *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetResourceName(v string) *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.ResourceName = &v
	return s
}

func (s *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetResourceStatus(v string) *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.ResourceStatus = &v
	return s
}

func (s *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetResourceType(v string) *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.ResourceType = &v
	return s
}

func (s *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail) SetTags(v string) *GetDiscoveredResourceResponseBodyDiscoveredResourceDetail {
	s.Tags = &v
	return s
}

type GetDiscoveredResourceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDiscoveredResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDiscoveredResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDiscoveredResourceResponse) GoString() string {
	return s.String()
}

func (s *GetDiscoveredResourceResponse) SetHeaders(v map[string]*string) *GetDiscoveredResourceResponse {
	s.Headers = v
	return s
}

func (s *GetDiscoveredResourceResponse) SetStatusCode(v int32) *GetDiscoveredResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDiscoveredResourceResponse) SetBody(v *GetDiscoveredResourceResponseBody) *GetDiscoveredResourceResponse {
	s.Body = v
	return s
}

type GetDiscoveredResourceCountsGroupByRegionRequest struct {
	// The type of the resource.
	//
	// For more information about how to query the type of a resource, see [ListDiscoveredResources](~~169620~~).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s GetDiscoveredResourceCountsGroupByRegionRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDiscoveredResourceCountsGroupByRegionRequest) GoString() string {
	return s.String()
}

func (s *GetDiscoveredResourceCountsGroupByRegionRequest) SetResourceType(v string) *GetDiscoveredResourceCountsGroupByRegionRequest {
	s.ResourceType = &v
	return s
}

type GetDiscoveredResourceCountsGroupByRegionResponseBody struct {
	// The statistics on resources.
	DiscoveredResourceCountsSummary []*GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary `json:"DiscoveredResourceCountsSummary,omitempty" xml:"DiscoveredResourceCountsSummary,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetDiscoveredResourceCountsGroupByRegionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDiscoveredResourceCountsGroupByRegionResponseBody) GoString() string {
	return s.String()
}

func (s *GetDiscoveredResourceCountsGroupByRegionResponseBody) SetDiscoveredResourceCountsSummary(v []*GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary) *GetDiscoveredResourceCountsGroupByRegionResponseBody {
	s.DiscoveredResourceCountsSummary = v
	return s
}

func (s *GetDiscoveredResourceCountsGroupByRegionResponseBody) SetRequestId(v string) *GetDiscoveredResourceCountsGroupByRegionResponseBody {
	s.RequestId = &v
	return s
}

type GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary struct {
	// The dimension by which statistics are collected.
	//
	// >  In most cases, the `Region` parameter is returned instead of the GroupName parameter.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the region by which statistics are collected.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The total number of resources in the region.
	ResourceCount *int64 `json:"ResourceCount,omitempty" xml:"ResourceCount,omitempty"`
}

func (s GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary) String() string {
	return tea.Prettify(s)
}

func (s GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary) GoString() string {
	return s.String()
}

func (s *GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary) SetGroupName(v string) *GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary {
	s.GroupName = &v
	return s
}

func (s *GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary) SetRegion(v string) *GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary {
	s.Region = &v
	return s
}

func (s *GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary) SetResourceCount(v int64) *GetDiscoveredResourceCountsGroupByRegionResponseBodyDiscoveredResourceCountsSummary {
	s.ResourceCount = &v
	return s
}

type GetDiscoveredResourceCountsGroupByRegionResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDiscoveredResourceCountsGroupByRegionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDiscoveredResourceCountsGroupByRegionResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDiscoveredResourceCountsGroupByRegionResponse) GoString() string {
	return s.String()
}

func (s *GetDiscoveredResourceCountsGroupByRegionResponse) SetHeaders(v map[string]*string) *GetDiscoveredResourceCountsGroupByRegionResponse {
	s.Headers = v
	return s
}

func (s *GetDiscoveredResourceCountsGroupByRegionResponse) SetStatusCode(v int32) *GetDiscoveredResourceCountsGroupByRegionResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDiscoveredResourceCountsGroupByRegionResponse) SetBody(v *GetDiscoveredResourceCountsGroupByRegionResponseBody) *GetDiscoveredResourceCountsGroupByRegionResponse {
	s.Body = v
	return s
}

type GetDiscoveredResourceCountsGroupByResourceTypeRequest struct {
	// The ID of the region where the resource resides.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
}

func (s GetDiscoveredResourceCountsGroupByResourceTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDiscoveredResourceCountsGroupByResourceTypeRequest) GoString() string {
	return s.String()
}

func (s *GetDiscoveredResourceCountsGroupByResourceTypeRequest) SetRegion(v string) *GetDiscoveredResourceCountsGroupByResourceTypeRequest {
	s.Region = &v
	return s
}

type GetDiscoveredResourceCountsGroupByResourceTypeResponseBody struct {
	// The statistics on the resources.
	DiscoveredResourceCountsSummary []*GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary `json:"DiscoveredResourceCountsSummary,omitempty" xml:"DiscoveredResourceCountsSummary,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetDiscoveredResourceCountsGroupByResourceTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDiscoveredResourceCountsGroupByResourceTypeResponseBody) GoString() string {
	return s.String()
}

func (s *GetDiscoveredResourceCountsGroupByResourceTypeResponseBody) SetDiscoveredResourceCountsSummary(v []*GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary) *GetDiscoveredResourceCountsGroupByResourceTypeResponseBody {
	s.DiscoveredResourceCountsSummary = v
	return s
}

func (s *GetDiscoveredResourceCountsGroupByResourceTypeResponseBody) SetRequestId(v string) *GetDiscoveredResourceCountsGroupByResourceTypeResponseBody {
	s.RequestId = &v
	return s
}

type GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary struct {
	// The resource type by which the statistics are collected.
	//
	// >  We recommend that you use the `ResourceType` parameter.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The total number of resources.
	ResourceCount *int64 `json:"ResourceCount,omitempty" xml:"ResourceCount,omitempty"`
	// The resource type by which the statistics are collected.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary) String() string {
	return tea.Prettify(s)
}

func (s GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary) GoString() string {
	return s.String()
}

func (s *GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary) SetGroupName(v string) *GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary {
	s.GroupName = &v
	return s
}

func (s *GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary) SetResourceCount(v int64) *GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary {
	s.ResourceCount = &v
	return s
}

func (s *GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary) SetResourceType(v string) *GetDiscoveredResourceCountsGroupByResourceTypeResponseBodyDiscoveredResourceCountsSummary {
	s.ResourceType = &v
	return s
}

type GetDiscoveredResourceCountsGroupByResourceTypeResponse struct {
	Headers    map[string]*string                                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDiscoveredResourceCountsGroupByResourceTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDiscoveredResourceCountsGroupByResourceTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDiscoveredResourceCountsGroupByResourceTypeResponse) GoString() string {
	return s.String()
}

func (s *GetDiscoveredResourceCountsGroupByResourceTypeResponse) SetHeaders(v map[string]*string) *GetDiscoveredResourceCountsGroupByResourceTypeResponse {
	s.Headers = v
	return s
}

func (s *GetDiscoveredResourceCountsGroupByResourceTypeResponse) SetStatusCode(v int32) *GetDiscoveredResourceCountsGroupByResourceTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDiscoveredResourceCountsGroupByResourceTypeResponse) SetBody(v *GetDiscoveredResourceCountsGroupByResourceTypeResponseBody) *GetDiscoveredResourceCountsGroupByResourceTypeResponse {
	s.Body = v
	return s
}

type GetIntegratedServiceStatusRequest struct {
	// The product code of the cloud product. Valid values:
	//
	// cadt: Cloud Architecture Design Tool
	ServiceCode *string `json:"ServiceCode,omitempty" xml:"ServiceCode,omitempty"`
}

func (s GetIntegratedServiceStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s GetIntegratedServiceStatusRequest) GoString() string {
	return s.String()
}

func (s *GetIntegratedServiceStatusRequest) SetServiceCode(v string) *GetIntegratedServiceStatusRequest {
	s.ServiceCode = &v
	return s
}

type GetIntegratedServiceStatusResponseBody struct {
	// Indicates whether the product has been integrated. Valid values:
	//
	// *   true
	// *   false
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetIntegratedServiceStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetIntegratedServiceStatusResponseBody) GoString() string {
	return s.String()
}

func (s *GetIntegratedServiceStatusResponseBody) SetData(v bool) *GetIntegratedServiceStatusResponseBody {
	s.Data = &v
	return s
}

func (s *GetIntegratedServiceStatusResponseBody) SetRequestId(v string) *GetIntegratedServiceStatusResponseBody {
	s.RequestId = &v
	return s
}

type GetIntegratedServiceStatusResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetIntegratedServiceStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetIntegratedServiceStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s GetIntegratedServiceStatusResponse) GoString() string {
	return s.String()
}

func (s *GetIntegratedServiceStatusResponse) SetHeaders(v map[string]*string) *GetIntegratedServiceStatusResponse {
	s.Headers = v
	return s
}

func (s *GetIntegratedServiceStatusResponse) SetStatusCode(v int32) *GetIntegratedServiceStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *GetIntegratedServiceStatusResponse) SetBody(v *GetIntegratedServiceStatusResponseBody) *GetIntegratedServiceStatusResponse {
	s.Body = v
	return s
}

type GetManagedRuleRequest struct {
	// The identifier of the managed rule.
	//
	// You can call the [ListManagedRules](~~421144~~) operation to obtain the managed rule identifier.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
}

func (s GetManagedRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s GetManagedRuleRequest) GoString() string {
	return s.String()
}

func (s *GetManagedRuleRequest) SetIdentifier(v string) *GetManagedRuleRequest {
	s.Identifier = &v
	return s
}

type GetManagedRuleResponseBody struct {
	// The details of the managed rule.
	ManagedRule *GetManagedRuleResponseBodyManagedRule `json:"ManagedRule,omitempty" xml:"ManagedRule,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetManagedRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetManagedRuleResponseBody) GoString() string {
	return s.String()
}

func (s *GetManagedRuleResponseBody) SetManagedRule(v *GetManagedRuleResponseBodyManagedRule) *GetManagedRuleResponseBody {
	s.ManagedRule = v
	return s
}

func (s *GetManagedRuleResponseBody) SetRequestId(v string) *GetManagedRuleResponseBody {
	s.RequestId = &v
	return s
}

type GetManagedRuleResponseBodyManagedRule struct {
	// The settings of the required input parameters for the managed rule.
	CompulsoryInputParameterDetails map[string]interface{} `json:"CompulsoryInputParameterDetails,omitempty" xml:"CompulsoryInputParameterDetails,omitempty"`
	// The name of the managed rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The description of the managed rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The URL of the topic that provides guidance on remediation for the managed rule.
	HelpUrls *string `json:"HelpUrls,omitempty" xml:"HelpUrls,omitempty"`
	// The identifier of the managed rule.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The tags of the managed rule.
	Labels []*string `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	// The settings of the optional input parameters for the managed rule.
	OptionalInputParameterDetails map[string]interface{} `json:"OptionalInputParameterDetails,omitempty" xml:"OptionalInputParameterDetails,omitempty"`
	// The risk level of the resources that are not compliant with the managed rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The effective scope of the managed rule.
	Scope *GetManagedRuleResponseBodyManagedRuleScope `json:"Scope,omitempty" xml:"Scope,omitempty" type:"Struct"`
	// The information about the trigger type of the managed rule.
	SourceDetails []*GetManagedRuleResponseBodyManagedRuleSourceDetails `json:"SourceDetails,omitempty" xml:"SourceDetails,omitempty" type:"Repeated"`
}

func (s GetManagedRuleResponseBodyManagedRule) String() string {
	return tea.Prettify(s)
}

func (s GetManagedRuleResponseBodyManagedRule) GoString() string {
	return s.String()
}

func (s *GetManagedRuleResponseBodyManagedRule) SetCompulsoryInputParameterDetails(v map[string]interface{}) *GetManagedRuleResponseBodyManagedRule {
	s.CompulsoryInputParameterDetails = v
	return s
}

func (s *GetManagedRuleResponseBodyManagedRule) SetConfigRuleName(v string) *GetManagedRuleResponseBodyManagedRule {
	s.ConfigRuleName = &v
	return s
}

func (s *GetManagedRuleResponseBodyManagedRule) SetDescription(v string) *GetManagedRuleResponseBodyManagedRule {
	s.Description = &v
	return s
}

func (s *GetManagedRuleResponseBodyManagedRule) SetHelpUrls(v string) *GetManagedRuleResponseBodyManagedRule {
	s.HelpUrls = &v
	return s
}

func (s *GetManagedRuleResponseBodyManagedRule) SetIdentifier(v string) *GetManagedRuleResponseBodyManagedRule {
	s.Identifier = &v
	return s
}

func (s *GetManagedRuleResponseBodyManagedRule) SetLabels(v []*string) *GetManagedRuleResponseBodyManagedRule {
	s.Labels = v
	return s
}

func (s *GetManagedRuleResponseBodyManagedRule) SetOptionalInputParameterDetails(v map[string]interface{}) *GetManagedRuleResponseBodyManagedRule {
	s.OptionalInputParameterDetails = v
	return s
}

func (s *GetManagedRuleResponseBodyManagedRule) SetRiskLevel(v int32) *GetManagedRuleResponseBodyManagedRule {
	s.RiskLevel = &v
	return s
}

func (s *GetManagedRuleResponseBodyManagedRule) SetScope(v *GetManagedRuleResponseBodyManagedRuleScope) *GetManagedRuleResponseBodyManagedRule {
	s.Scope = v
	return s
}

func (s *GetManagedRuleResponseBodyManagedRule) SetSourceDetails(v []*GetManagedRuleResponseBodyManagedRuleSourceDetails) *GetManagedRuleResponseBodyManagedRule {
	s.SourceDetails = v
	return s
}

type GetManagedRuleResponseBodyManagedRuleScope struct {
	// The type of resource to which the managed rule applies.
	ComplianceResourceTypes []*string `json:"ComplianceResourceTypes,omitempty" xml:"ComplianceResourceTypes,omitempty" type:"Repeated"`
}

func (s GetManagedRuleResponseBodyManagedRuleScope) String() string {
	return tea.Prettify(s)
}

func (s GetManagedRuleResponseBodyManagedRuleScope) GoString() string {
	return s.String()
}

func (s *GetManagedRuleResponseBodyManagedRuleScope) SetComplianceResourceTypes(v []*string) *GetManagedRuleResponseBodyManagedRuleScope {
	s.ComplianceResourceTypes = v
	return s
}

type GetManagedRuleResponseBodyManagedRuleSourceDetails struct {
	// The interval at which the managed rule is triggered. Valid values:
	//
	// *   One_Hour: 1 hour.
	// *   Three_Hours: 3 hours.
	// *   Six_Hours: 6 hours.
	// *   Twelve_Hours: 12 hours
	// *   TwentyFour_Hours: 24 hours
	MaximumExecutionFrequency *string `json:"MaximumExecutionFrequency,omitempty" xml:"MaximumExecutionFrequency,omitempty"`
	// The trigger type of the managed rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The managed rule is triggered by configuration changes.
	// *   ScheduledNotification: The managed rule is periodically triggered.
	MessageType *string `json:"MessageType,omitempty" xml:"MessageType,omitempty"`
}

func (s GetManagedRuleResponseBodyManagedRuleSourceDetails) String() string {
	return tea.Prettify(s)
}

func (s GetManagedRuleResponseBodyManagedRuleSourceDetails) GoString() string {
	return s.String()
}

func (s *GetManagedRuleResponseBodyManagedRuleSourceDetails) SetMaximumExecutionFrequency(v string) *GetManagedRuleResponseBodyManagedRuleSourceDetails {
	s.MaximumExecutionFrequency = &v
	return s
}

func (s *GetManagedRuleResponseBodyManagedRuleSourceDetails) SetMessageType(v string) *GetManagedRuleResponseBodyManagedRuleSourceDetails {
	s.MessageType = &v
	return s
}

type GetManagedRuleResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetManagedRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetManagedRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s GetManagedRuleResponse) GoString() string {
	return s.String()
}

func (s *GetManagedRuleResponse) SetHeaders(v map[string]*string) *GetManagedRuleResponse {
	s.Headers = v
	return s
}

func (s *GetManagedRuleResponse) SetStatusCode(v int32) *GetManagedRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *GetManagedRuleResponse) SetBody(v *GetManagedRuleResponseBody) *GetManagedRuleResponse {
	s.Body = v
	return s
}

type GetRemediationTemplateRequest struct {
	TemplateIdentifier *string `json:"TemplateIdentifier,omitempty" xml:"TemplateIdentifier,omitempty"`
}

func (s GetRemediationTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s GetRemediationTemplateRequest) GoString() string {
	return s.String()
}

func (s *GetRemediationTemplateRequest) SetTemplateIdentifier(v string) *GetRemediationTemplateRequest {
	s.TemplateIdentifier = &v
	return s
}

type GetRemediationTemplateResponseBody struct {
	RemediationTemplates []*GetRemediationTemplateResponseBodyRemediationTemplates `json:"RemediationTemplates,omitempty" xml:"RemediationTemplates,omitempty" type:"Repeated"`
	RequestId            *string                                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetRemediationTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetRemediationTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *GetRemediationTemplateResponseBody) SetRemediationTemplates(v []*GetRemediationTemplateResponseBodyRemediationTemplates) *GetRemediationTemplateResponseBody {
	s.RemediationTemplates = v
	return s
}

func (s *GetRemediationTemplateResponseBody) SetRequestId(v string) *GetRemediationTemplateResponseBody {
	s.RequestId = &v
	return s
}

type GetRemediationTemplateResponseBodyRemediationTemplates struct {
	ManagedRuleIdentifier *string `json:"ManagedRuleIdentifier,omitempty" xml:"ManagedRuleIdentifier,omitempty"`
	RemediationType       *string `json:"RemediationType,omitempty" xml:"RemediationType,omitempty"`
	TemplateDefinition    *string `json:"TemplateDefinition,omitempty" xml:"TemplateDefinition,omitempty"`
	TemplateDescription   *string `json:"TemplateDescription,omitempty" xml:"TemplateDescription,omitempty"`
	TemplateIdentifier    *string `json:"TemplateIdentifier,omitempty" xml:"TemplateIdentifier,omitempty"`
	TemplateName          *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
}

func (s GetRemediationTemplateResponseBodyRemediationTemplates) String() string {
	return tea.Prettify(s)
}

func (s GetRemediationTemplateResponseBodyRemediationTemplates) GoString() string {
	return s.String()
}

func (s *GetRemediationTemplateResponseBodyRemediationTemplates) SetManagedRuleIdentifier(v string) *GetRemediationTemplateResponseBodyRemediationTemplates {
	s.ManagedRuleIdentifier = &v
	return s
}

func (s *GetRemediationTemplateResponseBodyRemediationTemplates) SetRemediationType(v string) *GetRemediationTemplateResponseBodyRemediationTemplates {
	s.RemediationType = &v
	return s
}

func (s *GetRemediationTemplateResponseBodyRemediationTemplates) SetTemplateDefinition(v string) *GetRemediationTemplateResponseBodyRemediationTemplates {
	s.TemplateDefinition = &v
	return s
}

func (s *GetRemediationTemplateResponseBodyRemediationTemplates) SetTemplateDescription(v string) *GetRemediationTemplateResponseBodyRemediationTemplates {
	s.TemplateDescription = &v
	return s
}

func (s *GetRemediationTemplateResponseBodyRemediationTemplates) SetTemplateIdentifier(v string) *GetRemediationTemplateResponseBodyRemediationTemplates {
	s.TemplateIdentifier = &v
	return s
}

func (s *GetRemediationTemplateResponseBodyRemediationTemplates) SetTemplateName(v string) *GetRemediationTemplateResponseBodyRemediationTemplates {
	s.TemplateName = &v
	return s
}

type GetRemediationTemplateResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetRemediationTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetRemediationTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s GetRemediationTemplateResponse) GoString() string {
	return s.String()
}

func (s *GetRemediationTemplateResponse) SetHeaders(v map[string]*string) *GetRemediationTemplateResponse {
	s.Headers = v
	return s
}

func (s *GetRemediationTemplateResponse) SetStatusCode(v int32) *GetRemediationTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *GetRemediationTemplateResponse) SetBody(v *GetRemediationTemplateResponseBody) *GetRemediationTemplateResponse {
	s.Body = v
	return s
}

type GetResourceComplianceByConfigRuleRequest struct {
	// The compliance evaluation results to be returned. Valid values:
	//
	// *   COMPLIANT: The relevant resources are evaluated as compliant.
	// *   NON_COMPLIANT: The relevant resources are evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to your resources.
	// *   INSUFFICIENT_DATA: No resource data is available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The ID of the rule.
	//
	// For more information about how to obtain the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
}

func (s GetResourceComplianceByConfigRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceByConfigRuleRequest) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceByConfigRuleRequest) SetComplianceType(v string) *GetResourceComplianceByConfigRuleRequest {
	s.ComplianceType = &v
	return s
}

func (s *GetResourceComplianceByConfigRuleRequest) SetConfigRuleId(v string) *GetResourceComplianceByConfigRuleRequest {
	s.ConfigRuleId = &v
	return s
}

type GetResourceComplianceByConfigRuleResponseBody struct {
	// The compliance evaluation results returned.
	ComplianceResult *GetResourceComplianceByConfigRuleResponseBodyComplianceResult `json:"ComplianceResult,omitempty" xml:"ComplianceResult,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetResourceComplianceByConfigRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceByConfigRuleResponseBody) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceByConfigRuleResponseBody) SetComplianceResult(v *GetResourceComplianceByConfigRuleResponseBodyComplianceResult) *GetResourceComplianceByConfigRuleResponseBody {
	s.ComplianceResult = v
	return s
}

func (s *GetResourceComplianceByConfigRuleResponseBody) SetRequestId(v string) *GetResourceComplianceByConfigRuleResponseBody {
	s.RequestId = &v
	return s
}

type GetResourceComplianceByConfigRuleResponseBodyComplianceResult struct {
	// The information about the compliance evaluation.
	Compliances []*GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances `json:"Compliances,omitempty" xml:"Compliances,omitempty" type:"Repeated"`
	// The total number of evaluated resources.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetResourceComplianceByConfigRuleResponseBodyComplianceResult) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceByConfigRuleResponseBodyComplianceResult) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceByConfigRuleResponseBodyComplianceResult) SetCompliances(v []*GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances) *GetResourceComplianceByConfigRuleResponseBodyComplianceResult {
	s.Compliances = v
	return s
}

func (s *GetResourceComplianceByConfigRuleResponseBodyComplianceResult) SetTotalCount(v int64) *GetResourceComplianceByConfigRuleResponseBodyComplianceResult {
	s.TotalCount = &v
	return s
}

type GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances struct {
	// The compliance evaluation result. Valid values:
	//
	// *   COMPLIANT: The relevant resources are evaluated as compliant.
	// *   NON_COMPLIANT: The relevant resources are evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to your resources.
	// *   INSUFFICIENT_DATA: No resource data is available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The number of resources that have the compliance evaluation result. For example, if the value of the `ComplianceType` parameter is `COMPLIANT`, this parameter value indicates the number of compliant resources.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances) SetComplianceType(v string) *GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances {
	s.ComplianceType = &v
	return s
}

func (s *GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances) SetCount(v int32) *GetResourceComplianceByConfigRuleResponseBodyComplianceResultCompliances {
	s.Count = &v
	return s
}

type GetResourceComplianceByConfigRuleResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetResourceComplianceByConfigRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetResourceComplianceByConfigRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceByConfigRuleResponse) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceByConfigRuleResponse) SetHeaders(v map[string]*string) *GetResourceComplianceByConfigRuleResponse {
	s.Headers = v
	return s
}

func (s *GetResourceComplianceByConfigRuleResponse) SetStatusCode(v int32) *GetResourceComplianceByConfigRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *GetResourceComplianceByConfigRuleResponse) SetBody(v *GetResourceComplianceByConfigRuleResponseBody) *GetResourceComplianceByConfigRuleResponse {
	s.Body = v
	return s
}

type GetResourceComplianceByPackRequest struct {
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListCompliancePacks](~~263332~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
}

func (s GetResourceComplianceByPackRequest) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceByPackRequest) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceByPackRequest) SetCompliancePackId(v string) *GetResourceComplianceByPackRequest {
	s.CompliancePackId = &v
	return s
}

type GetResourceComplianceByPackResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The compliance evaluation results returned.
	ResourceComplianceResult *GetResourceComplianceByPackResponseBodyResourceComplianceResult `json:"ResourceComplianceResult,omitempty" xml:"ResourceComplianceResult,omitempty" type:"Struct"`
}

func (s GetResourceComplianceByPackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceByPackResponseBody) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceByPackResponseBody) SetRequestId(v string) *GetResourceComplianceByPackResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetResourceComplianceByPackResponseBody) SetResourceComplianceResult(v *GetResourceComplianceByPackResponseBodyResourceComplianceResult) *GetResourceComplianceByPackResponseBody {
	s.ResourceComplianceResult = v
	return s
}

type GetResourceComplianceByPackResponseBodyResourceComplianceResult struct {
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The number of non-compliant resources.
	NonCompliantCount *int32 `json:"NonCompliantCount,omitempty" xml:"NonCompliantCount,omitempty"`
	// The total number of resources.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetResourceComplianceByPackResponseBodyResourceComplianceResult) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceByPackResponseBodyResourceComplianceResult) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceByPackResponseBodyResourceComplianceResult) SetCompliancePackId(v string) *GetResourceComplianceByPackResponseBodyResourceComplianceResult {
	s.CompliancePackId = &v
	return s
}

func (s *GetResourceComplianceByPackResponseBodyResourceComplianceResult) SetNonCompliantCount(v int32) *GetResourceComplianceByPackResponseBodyResourceComplianceResult {
	s.NonCompliantCount = &v
	return s
}

func (s *GetResourceComplianceByPackResponseBodyResourceComplianceResult) SetTotalCount(v int32) *GetResourceComplianceByPackResponseBodyResourceComplianceResult {
	s.TotalCount = &v
	return s
}

type GetResourceComplianceByPackResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetResourceComplianceByPackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetResourceComplianceByPackResponse) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceByPackResponse) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceByPackResponse) SetHeaders(v map[string]*string) *GetResourceComplianceByPackResponse {
	s.Headers = v
	return s
}

func (s *GetResourceComplianceByPackResponse) SetStatusCode(v int32) *GetResourceComplianceByPackResponse {
	s.StatusCode = &v
	return s
}

func (s *GetResourceComplianceByPackResponse) SetBody(v *GetResourceComplianceByPackResponseBody) *GetResourceComplianceByPackResponse {
	s.Body = v
	return s
}

type GetResourceComplianceGroupByRegionRequest struct {
	// The rule IDs. Separate multiple rule IDs with commas (,).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s GetResourceComplianceGroupByRegionRequest) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceGroupByRegionRequest) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceGroupByRegionRequest) SetConfigRuleIds(v string) *GetResourceComplianceGroupByRegionRequest {
	s.ConfigRuleIds = &v
	return s
}

type GetResourceComplianceGroupByRegionResponseBody struct {
	// The queried evaluation results.
	ComplianceResult *GetResourceComplianceGroupByRegionResponseBodyComplianceResult `json:"ComplianceResult,omitempty" xml:"ComplianceResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetResourceComplianceGroupByRegionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceGroupByRegionResponseBody) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceGroupByRegionResponseBody) SetComplianceResult(v *GetResourceComplianceGroupByRegionResponseBodyComplianceResult) *GetResourceComplianceGroupByRegionResponseBody {
	s.ComplianceResult = v
	return s
}

func (s *GetResourceComplianceGroupByRegionResponseBody) SetRequestId(v string) *GetResourceComplianceGroupByRegionResponseBody {
	s.RequestId = &v
	return s
}

type GetResourceComplianceGroupByRegionResponseBodyComplianceResult struct {
	// The evaluation results grouped by region.
	ComplianceResultList []*GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList `json:"ComplianceResultList,omitempty" xml:"ComplianceResultList,omitempty" type:"Repeated"`
}

func (s GetResourceComplianceGroupByRegionResponseBodyComplianceResult) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceGroupByRegionResponseBodyComplianceResult) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceGroupByRegionResponseBodyComplianceResult) SetComplianceResultList(v []*GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList) *GetResourceComplianceGroupByRegionResponseBodyComplianceResult {
	s.ComplianceResultList = v
	return s
}

type GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList struct {
	// The queried evaluation results.
	Compliances []*GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances `json:"Compliances,omitempty" xml:"Compliances,omitempty" type:"Repeated"`
	// The region ID of the evaluated resource.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList) SetCompliances(v []*GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances) *GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList {
	s.Compliances = v
	return s
}

func (s *GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList) SetRegionId(v string) *GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultList {
	s.RegionId = &v
	return s
}

type GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances struct {
	// The evaluation result. Valid values:
	//
	// *   COMPLIANT: The resource is evaluated as compliant.
	// *   NON_COMPLIANT: The resource is evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to the resource.
	// *   INSUFFICIENT_DATA: No data is available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The total number of evaluation results.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances) SetComplianceType(v string) *GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances {
	s.ComplianceType = &v
	return s
}

func (s *GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances) SetCount(v int64) *GetResourceComplianceGroupByRegionResponseBodyComplianceResultComplianceResultListCompliances {
	s.Count = &v
	return s
}

type GetResourceComplianceGroupByRegionResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetResourceComplianceGroupByRegionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetResourceComplianceGroupByRegionResponse) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceGroupByRegionResponse) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceGroupByRegionResponse) SetHeaders(v map[string]*string) *GetResourceComplianceGroupByRegionResponse {
	s.Headers = v
	return s
}

func (s *GetResourceComplianceGroupByRegionResponse) SetStatusCode(v int32) *GetResourceComplianceGroupByRegionResponse {
	s.StatusCode = &v
	return s
}

func (s *GetResourceComplianceGroupByRegionResponse) SetBody(v *GetResourceComplianceGroupByRegionResponseBody) *GetResourceComplianceGroupByRegionResponse {
	s.Body = v
	return s
}

type GetResourceComplianceGroupByResourceTypeRequest struct {
	// The rule IDs. Separate multiple rule IDs with commas (,).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s GetResourceComplianceGroupByResourceTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceGroupByResourceTypeRequest) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceGroupByResourceTypeRequest) SetConfigRuleIds(v string) *GetResourceComplianceGroupByResourceTypeRequest {
	s.ConfigRuleIds = &v
	return s
}

type GetResourceComplianceGroupByResourceTypeResponseBody struct {
	// The queried evaluation results.
	ComplianceResult *GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResult `json:"ComplianceResult,omitempty" xml:"ComplianceResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetResourceComplianceGroupByResourceTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceGroupByResourceTypeResponseBody) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceGroupByResourceTypeResponseBody) SetComplianceResult(v *GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResult) *GetResourceComplianceGroupByResourceTypeResponseBody {
	s.ComplianceResult = v
	return s
}

func (s *GetResourceComplianceGroupByResourceTypeResponseBody) SetRequestId(v string) *GetResourceComplianceGroupByResourceTypeResponseBody {
	s.RequestId = &v
	return s
}

type GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResult struct {
	// The evaluation results grouped by resource type.
	ComplianceResultList []*GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList `json:"ComplianceResultList,omitempty" xml:"ComplianceResultList,omitempty" type:"Repeated"`
}

func (s GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResult) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResult) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResult) SetComplianceResultList(v []*GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList) *GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResult {
	s.ComplianceResultList = v
	return s
}

type GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList struct {
	// The queried evaluation results.
	Compliances []*GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances `json:"Compliances,omitempty" xml:"Compliances,omitempty" type:"Repeated"`
	// The type of the evaluated resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList) SetCompliances(v []*GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances) *GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList {
	s.Compliances = v
	return s
}

func (s *GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList) SetResourceType(v string) *GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultList {
	s.ResourceType = &v
	return s
}

type GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances struct {
	// The evaluation result. Valid values:
	//
	// *   COMPLIANT: The resource is evaluated as compliant.
	// *   NON_COMPLIANT: The resource is evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to the resource.
	// *   INSUFFICIENT_DATA: No data is available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The total number of evaluation results.
	Count *int64 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances) SetComplianceType(v string) *GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances {
	s.ComplianceType = &v
	return s
}

func (s *GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances) SetCount(v int64) *GetResourceComplianceGroupByResourceTypeResponseBodyComplianceResultComplianceResultListCompliances {
	s.Count = &v
	return s
}

type GetResourceComplianceGroupByResourceTypeResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetResourceComplianceGroupByResourceTypeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetResourceComplianceGroupByResourceTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceGroupByResourceTypeResponse) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceGroupByResourceTypeResponse) SetHeaders(v map[string]*string) *GetResourceComplianceGroupByResourceTypeResponse {
	s.Headers = v
	return s
}

func (s *GetResourceComplianceGroupByResourceTypeResponse) SetStatusCode(v int32) *GetResourceComplianceGroupByResourceTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *GetResourceComplianceGroupByResourceTypeResponse) SetBody(v *GetResourceComplianceGroupByResourceTypeResponseBody) *GetResourceComplianceGroupByResourceTypeResponse {
	s.Body = v
	return s
}

type GetResourceComplianceTimelineRequest struct {
	// The timestamp that specifies the end of the time range to query. The default value is the time when the GetResourceComplianceTimeline operation is called. Unit: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The maximum number of entries to return for a single request. Valid values: 1 to 100.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used to initiate the next request. If the response of the current request is truncated, this token is used to initiate another request and obtain the remaining entries.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region where the resource resides.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The ID of the resource.
	//
	// For more information about how to obtain the ID of a resource, see [ListDiscoveredResources](~~169620~~).
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource.
	//
	// For more information about how to obtain the type of a resource, see [ListDiscoveredResources](~~169620~~).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The timestamp that specifies the beginning of the time range to query. By default, Cloud Config retrieves the compliance evaluations in the last 30 days for the specified resource. Unit: milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s GetResourceComplianceTimelineRequest) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceTimelineRequest) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceTimelineRequest) SetEndTime(v int64) *GetResourceComplianceTimelineRequest {
	s.EndTime = &v
	return s
}

func (s *GetResourceComplianceTimelineRequest) SetMaxResults(v int32) *GetResourceComplianceTimelineRequest {
	s.MaxResults = &v
	return s
}

func (s *GetResourceComplianceTimelineRequest) SetNextToken(v string) *GetResourceComplianceTimelineRequest {
	s.NextToken = &v
	return s
}

func (s *GetResourceComplianceTimelineRequest) SetRegion(v string) *GetResourceComplianceTimelineRequest {
	s.Region = &v
	return s
}

func (s *GetResourceComplianceTimelineRequest) SetResourceId(v string) *GetResourceComplianceTimelineRequest {
	s.ResourceId = &v
	return s
}

func (s *GetResourceComplianceTimelineRequest) SetResourceType(v string) *GetResourceComplianceTimelineRequest {
	s.ResourceType = &v
	return s
}

func (s *GetResourceComplianceTimelineRequest) SetStartTime(v int64) *GetResourceComplianceTimelineRequest {
	s.StartTime = &v
	return s
}

type GetResourceComplianceTimelineResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the compliance timeline.
	ResourceComplianceTimeline *GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline `json:"ResourceComplianceTimeline,omitempty" xml:"ResourceComplianceTimeline,omitempty" type:"Struct"`
}

func (s GetResourceComplianceTimelineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceTimelineResponseBody) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceTimelineResponseBody) SetRequestId(v string) *GetResourceComplianceTimelineResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetResourceComplianceTimelineResponseBody) SetResourceComplianceTimeline(v *GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline) *GetResourceComplianceTimelineResponseBody {
	s.ResourceComplianceTimeline = v
	return s
}

type GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline struct {
	// The compliance evaluation records on the compliance timeline.
	ComplianceList []*GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList `json:"ComplianceList,omitempty" xml:"ComplianceList,omitempty" type:"Repeated"`
	// The maximum number of entries that can be returned for a single request.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used to initiate the next request.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline) SetComplianceList(v []*GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) *GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline {
	s.ComplianceList = v
	return s
}

func (s *GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline) SetMaxResults(v int32) *GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline {
	s.MaxResults = &v
	return s
}

func (s *GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline) SetNextToken(v string) *GetResourceComplianceTimelineResponseBodyResourceComplianceTimeline {
	s.NextToken = &v
	return s
}

type GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList struct {
	// The ID of the Alibaba Cloud account to which the resource belongs.
	AccountId *string `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The zone where the resource resides.
	AvailabilityZone *string `json:"AvailabilityZone,omitempty" xml:"AvailabilityZone,omitempty"`
	// The timestamp when the compliance evaluation was recorded. Unit: milliseconds.
	CaptureTime *int64 `json:"CaptureTime,omitempty" xml:"CaptureTime,omitempty"`
	// The information about the rules that evaluated the resource and the compliance evaluation result.
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
	// The details of the configuration change that triggered the compliance evaluation.
	ConfigurationDiff *string `json:"ConfigurationDiff,omitempty" xml:"ConfigurationDiff,omitempty"`
	// The ID of the region where the resource resides.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The timestamp when the resource was created. Unit: milliseconds.
	ResourceCreateTime *int64 `json:"ResourceCreateTime,omitempty" xml:"ResourceCreateTime,omitempty"`
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The name of the resource.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The status of the resource. The parameter value varies with the resource type and may be left empty. Examples:
	//
	// *   If the ResourceType parameter is set to ACS::ECS::Instance, the resource is an Elastic Compute Service (ECS) instance that has a specific state. In this case, valid values of this parameter include Running and Stopped.
	// *   If the ResourceType parameter is set to ACS::OSS::Bucket, the resource is an Object Storage Service (OSS) bucket that does not have a specific state. In this case, this parameter is left empty.
	ResourceStatus *string `json:"ResourceStatus,omitempty" xml:"ResourceStatus,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags of the resource.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetAccountId(v string) *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.AccountId = &v
	return s
}

func (s *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetAvailabilityZone(v string) *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.AvailabilityZone = &v
	return s
}

func (s *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetCaptureTime(v int64) *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.CaptureTime = &v
	return s
}

func (s *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetConfiguration(v string) *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.Configuration = &v
	return s
}

func (s *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetConfigurationDiff(v string) *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.ConfigurationDiff = &v
	return s
}

func (s *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetRegion(v string) *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.Region = &v
	return s
}

func (s *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetResourceCreateTime(v int64) *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.ResourceCreateTime = &v
	return s
}

func (s *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetResourceId(v string) *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.ResourceId = &v
	return s
}

func (s *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetResourceName(v string) *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.ResourceName = &v
	return s
}

func (s *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetResourceStatus(v string) *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.ResourceStatus = &v
	return s
}

func (s *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetResourceType(v string) *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.ResourceType = &v
	return s
}

func (s *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList) SetTags(v string) *GetResourceComplianceTimelineResponseBodyResourceComplianceTimelineComplianceList {
	s.Tags = &v
	return s
}

type GetResourceComplianceTimelineResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetResourceComplianceTimelineResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetResourceComplianceTimelineResponse) String() string {
	return tea.Prettify(s)
}

func (s GetResourceComplianceTimelineResponse) GoString() string {
	return s.String()
}

func (s *GetResourceComplianceTimelineResponse) SetHeaders(v map[string]*string) *GetResourceComplianceTimelineResponse {
	s.Headers = v
	return s
}

func (s *GetResourceComplianceTimelineResponse) SetStatusCode(v int32) *GetResourceComplianceTimelineResponse {
	s.StatusCode = &v
	return s
}

func (s *GetResourceComplianceTimelineResponse) SetBody(v *GetResourceComplianceTimelineResponseBody) *GetResourceComplianceTimelineResponse {
	s.Body = v
	return s
}

type GetResourceConfigurationTimelineRequest struct {
	// The timestamp that specifies the end of the time range to query. The default value is the time when the GetResourceConfigurationTimeline operation is called. Unit: milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The maximum number of entries to return for a single request. Valid values: 1 to 100.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used to initiate the next request. If the response of the current request is truncated, this token is used to initiate another request and obtain the remaining entries.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region in which the resource resides.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The ID of the resource.
	//
	// For more information about how to obtain the ID of a resource, see [ListDiscoveredResources](~~169620~~).
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource.
	//
	// For more information about how to obtain the type of a resource, see [ListDiscoveredResources](~~169620~~).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The timestamp that specifies the beginning of the time range to query. By default, Cloud Config retrieves the configuration changes in the last 30 days for the specified resource. Unit: milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s GetResourceConfigurationTimelineRequest) String() string {
	return tea.Prettify(s)
}

func (s GetResourceConfigurationTimelineRequest) GoString() string {
	return s.String()
}

func (s *GetResourceConfigurationTimelineRequest) SetEndTime(v int64) *GetResourceConfigurationTimelineRequest {
	s.EndTime = &v
	return s
}

func (s *GetResourceConfigurationTimelineRequest) SetMaxResults(v int32) *GetResourceConfigurationTimelineRequest {
	s.MaxResults = &v
	return s
}

func (s *GetResourceConfigurationTimelineRequest) SetNextToken(v string) *GetResourceConfigurationTimelineRequest {
	s.NextToken = &v
	return s
}

func (s *GetResourceConfigurationTimelineRequest) SetRegion(v string) *GetResourceConfigurationTimelineRequest {
	s.Region = &v
	return s
}

func (s *GetResourceConfigurationTimelineRequest) SetResourceId(v string) *GetResourceConfigurationTimelineRequest {
	s.ResourceId = &v
	return s
}

func (s *GetResourceConfigurationTimelineRequest) SetResourceType(v string) *GetResourceConfigurationTimelineRequest {
	s.ResourceType = &v
	return s
}

func (s *GetResourceConfigurationTimelineRequest) SetStartTime(v int64) *GetResourceConfigurationTimelineRequest {
	s.StartTime = &v
	return s
}

type GetResourceConfigurationTimelineResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the configuration timeline.
	ResourceConfigurationTimeline *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline `json:"ResourceConfigurationTimeline,omitempty" xml:"ResourceConfigurationTimeline,omitempty" type:"Struct"`
}

func (s GetResourceConfigurationTimelineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetResourceConfigurationTimelineResponseBody) GoString() string {
	return s.String()
}

func (s *GetResourceConfigurationTimelineResponseBody) SetRequestId(v string) *GetResourceConfigurationTimelineResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetResourceConfigurationTimelineResponseBody) SetResourceConfigurationTimeline(v *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline) *GetResourceConfigurationTimelineResponseBody {
	s.ResourceConfigurationTimeline = v
	return s
}

type GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline struct {
	// The configuration changes on the configuration timeline.
	ConfigurationList []*GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList `json:"ConfigurationList,omitempty" xml:"ConfigurationList,omitempty" type:"Repeated"`
	// The maximum number of entries returned for a single request.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used to initiate the next request.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline) String() string {
	return tea.Prettify(s)
}

func (s GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline) GoString() string {
	return s.String()
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline) SetConfigurationList(v []*GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline {
	s.ConfigurationList = v
	return s
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline) SetMaxResults(v int32) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline {
	s.MaxResults = &v
	return s
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline) SetNextToken(v string) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimeline {
	s.NextToken = &v
	return s
}

type GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList struct {
	// The ID of the Alibaba Cloud account to which the resource belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the zone.
	AvailabilityZone *string `json:"AvailabilityZone,omitempty" xml:"AvailabilityZone,omitempty"`
	// The timestamp when the resource change snapshot was recorded. Unit: milliseconds.
	CaptureTime *string `json:"CaptureTime,omitempty" xml:"CaptureTime,omitempty"`
	// The details of the resource change that triggered the compliance evaluation.
	ConfigurationDiff *string `json:"ConfigurationDiff,omitempty" xml:"ConfigurationDiff,omitempty"`
	// The ID of the region in which the resource resides.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The details of each resource that is associated with the current resource, including the region ID, resource relationship, resource ID, and resource type.
	Relationship *string `json:"Relationship,omitempty" xml:"Relationship,omitempty"`
	// The change records of the resource relationship.
	RelationshipDiff *string `json:"RelationshipDiff,omitempty" xml:"RelationshipDiff,omitempty"`
	// The timestamp when the resource was created. Unit: milliseconds.
	ResourceCreateTime *string `json:"ResourceCreateTime,omitempty" xml:"ResourceCreateTime,omitempty"`
	// The type of the resource change event involved. Valid values:
	//
	// *   DISCOVERED: A resource is created.
	// *   DISCOVERED_REVISED: A resource is created by periodic remediation tasks.
	// *   MODIFY: A resource is modified.
	// *   MODIFY_REVISED: A resource is modified by periodic remediation tasks.
	// *   REMOVE: A resource is deleted.
	//
	// >
	// *   To ensure the integrity of resources, periodic remediation tasks are executed to check data and generate events that indicate the creation of new resources. Such events are infrequent.
	// *   The time when a resource change event is generated by a periodic remediation task is considered as the detection time of Cloud Config. The detection time is later than the time when the resource is modified.
	ResourceEventType *string `json:"ResourceEventType,omitempty" xml:"ResourceEventType,omitempty"`
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The name of the resource.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags of the resource.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) String() string {
	return tea.Prettify(s)
}

func (s GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) GoString() string {
	return s.String()
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetAccountId(v int64) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.AccountId = &v
	return s
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetAvailabilityZone(v string) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.AvailabilityZone = &v
	return s
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetCaptureTime(v string) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.CaptureTime = &v
	return s
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetConfigurationDiff(v string) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.ConfigurationDiff = &v
	return s
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetRegion(v string) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.Region = &v
	return s
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetRelationship(v string) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.Relationship = &v
	return s
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetRelationshipDiff(v string) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.RelationshipDiff = &v
	return s
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetResourceCreateTime(v string) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.ResourceCreateTime = &v
	return s
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetResourceEventType(v string) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.ResourceEventType = &v
	return s
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetResourceId(v string) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.ResourceId = &v
	return s
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetResourceName(v string) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.ResourceName = &v
	return s
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetResourceType(v string) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.ResourceType = &v
	return s
}

func (s *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList) SetTags(v string) *GetResourceConfigurationTimelineResponseBodyResourceConfigurationTimelineConfigurationList {
	s.Tags = &v
	return s
}

type GetResourceConfigurationTimelineResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetResourceConfigurationTimelineResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetResourceConfigurationTimelineResponse) String() string {
	return tea.Prettify(s)
}

func (s GetResourceConfigurationTimelineResponse) GoString() string {
	return s.String()
}

func (s *GetResourceConfigurationTimelineResponse) SetHeaders(v map[string]*string) *GetResourceConfigurationTimelineResponse {
	s.Headers = v
	return s
}

func (s *GetResourceConfigurationTimelineResponse) SetStatusCode(v int32) *GetResourceConfigurationTimelineResponse {
	s.StatusCode = &v
	return s
}

func (s *GetResourceConfigurationTimelineResponse) SetBody(v *GetResourceConfigurationTimelineResponseBody) *GetResourceConfigurationTimelineResponse {
	s.Body = v
	return s
}

type GetResourceInventoryResponseBody struct {
	RequestId         *string                                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ResourceInventory *GetResourceInventoryResponseBodyResourceInventory `json:"ResourceInventory,omitempty" xml:"ResourceInventory,omitempty" type:"Struct"`
}

func (s GetResourceInventoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetResourceInventoryResponseBody) GoString() string {
	return s.String()
}

func (s *GetResourceInventoryResponseBody) SetRequestId(v string) *GetResourceInventoryResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetResourceInventoryResponseBody) SetResourceInventory(v *GetResourceInventoryResponseBodyResourceInventory) *GetResourceInventoryResponseBody {
	s.ResourceInventory = v
	return s
}

type GetResourceInventoryResponseBodyResourceInventory struct {
	DownloadUrl                   *string `json:"DownloadUrl,omitempty" xml:"DownloadUrl,omitempty"`
	ResourceInventoryGenerateTime *int64  `json:"ResourceInventoryGenerateTime,omitempty" xml:"ResourceInventoryGenerateTime,omitempty"`
	Status                        *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetResourceInventoryResponseBodyResourceInventory) String() string {
	return tea.Prettify(s)
}

func (s GetResourceInventoryResponseBodyResourceInventory) GoString() string {
	return s.String()
}

func (s *GetResourceInventoryResponseBodyResourceInventory) SetDownloadUrl(v string) *GetResourceInventoryResponseBodyResourceInventory {
	s.DownloadUrl = &v
	return s
}

func (s *GetResourceInventoryResponseBodyResourceInventory) SetResourceInventoryGenerateTime(v int64) *GetResourceInventoryResponseBodyResourceInventory {
	s.ResourceInventoryGenerateTime = &v
	return s
}

func (s *GetResourceInventoryResponseBodyResourceInventory) SetStatus(v string) *GetResourceInventoryResponseBodyResourceInventory {
	s.Status = &v
	return s
}

type GetResourceInventoryResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetResourceInventoryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetResourceInventoryResponse) String() string {
	return tea.Prettify(s)
}

func (s GetResourceInventoryResponse) GoString() string {
	return s.String()
}

func (s *GetResourceInventoryResponse) SetHeaders(v map[string]*string) *GetResourceInventoryResponse {
	s.Headers = v
	return s
}

func (s *GetResourceInventoryResponse) SetStatusCode(v int32) *GetResourceInventoryResponse {
	s.StatusCode = &v
	return s
}

func (s *GetResourceInventoryResponse) SetBody(v *GetResourceInventoryResponseBody) *GetResourceInventoryResponse {
	s.Body = v
	return s
}

type GetSupportedResourceRelationConfigRequest struct {
	// The resource type.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s GetSupportedResourceRelationConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSupportedResourceRelationConfigRequest) GoString() string {
	return s.String()
}

func (s *GetSupportedResourceRelationConfigRequest) SetResourceType(v string) *GetSupportedResourceRelationConfigRequest {
	s.ResourceType = &v
	return s
}

type GetSupportedResourceRelationConfigResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The supported resource relationships.
	ResourceRelationConfigList []*GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList `json:"ResourceRelationConfigList,omitempty" xml:"ResourceRelationConfigList,omitempty" type:"Repeated"`
}

func (s GetSupportedResourceRelationConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSupportedResourceRelationConfigResponseBody) GoString() string {
	return s.String()
}

func (s *GetSupportedResourceRelationConfigResponseBody) SetRequestId(v string) *GetSupportedResourceRelationConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSupportedResourceRelationConfigResponseBody) SetResourceRelationConfigList(v []*GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList) *GetSupportedResourceRelationConfigResponseBody {
	s.ResourceRelationConfigList = v
	return s
}

type GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList struct {
	// The relationship type.
	RelationType *string `json:"RelationType,omitempty" xml:"RelationType,omitempty"`
	// The resource type.
	TargetResourceType *string `json:"TargetResourceType,omitempty" xml:"TargetResourceType,omitempty"`
}

func (s GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList) String() string {
	return tea.Prettify(s)
}

func (s GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList) GoString() string {
	return s.String()
}

func (s *GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList) SetRelationType(v string) *GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList {
	s.RelationType = &v
	return s
}

func (s *GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList) SetTargetResourceType(v string) *GetSupportedResourceRelationConfigResponseBodyResourceRelationConfigList {
	s.TargetResourceType = &v
	return s
}

type GetSupportedResourceRelationConfigResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSupportedResourceRelationConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSupportedResourceRelationConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSupportedResourceRelationConfigResponse) GoString() string {
	return s.String()
}

func (s *GetSupportedResourceRelationConfigResponse) SetHeaders(v map[string]*string) *GetSupportedResourceRelationConfigResponse {
	s.Headers = v
	return s
}

func (s *GetSupportedResourceRelationConfigResponse) SetStatusCode(v int32) *GetSupportedResourceRelationConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSupportedResourceRelationConfigResponse) SetBody(v *GetSupportedResourceRelationConfigResponseBody) *GetSupportedResourceRelationConfigResponse {
	s.Body = v
	return s
}

type IgnoreAggregateEvaluationResultsRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the rule.
	//
	// For more information about how to obtain the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The date from which the system automatically re-evaluates the ignored incompliant resources.
	//
	// >  If you leave this parameter empty, the system does not automatically re-evaluate the ignored incompliant resources. You must manually re-evaluate the ignored incompliant resources.
	IgnoreDate *string `json:"IgnoreDate,omitempty" xml:"IgnoreDate,omitempty"`
	// The reason why you ignore the resource.
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
	// The resources to be ignored.
	Resources []*IgnoreAggregateEvaluationResultsRequestResources `json:"Resources,omitempty" xml:"Resources,omitempty" type:"Repeated"`
}

func (s IgnoreAggregateEvaluationResultsRequest) String() string {
	return tea.Prettify(s)
}

func (s IgnoreAggregateEvaluationResultsRequest) GoString() string {
	return s.String()
}

func (s *IgnoreAggregateEvaluationResultsRequest) SetAggregatorId(v string) *IgnoreAggregateEvaluationResultsRequest {
	s.AggregatorId = &v
	return s
}

func (s *IgnoreAggregateEvaluationResultsRequest) SetConfigRuleId(v string) *IgnoreAggregateEvaluationResultsRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *IgnoreAggregateEvaluationResultsRequest) SetIgnoreDate(v string) *IgnoreAggregateEvaluationResultsRequest {
	s.IgnoreDate = &v
	return s
}

func (s *IgnoreAggregateEvaluationResultsRequest) SetReason(v string) *IgnoreAggregateEvaluationResultsRequest {
	s.Reason = &v
	return s
}

func (s *IgnoreAggregateEvaluationResultsRequest) SetResources(v []*IgnoreAggregateEvaluationResultsRequestResources) *IgnoreAggregateEvaluationResultsRequest {
	s.Resources = v
	return s
}

type IgnoreAggregateEvaluationResultsRequestResources struct {
	// The ID of the region in which the resource resides.
	//
	// For more information about how to obtain the ID of a region, see [ListAggregateDiscoveredResources](~~265983~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The ID of the Alibaba Cloud account to which the resources belong.
	//
	// >  You must specify the ID of the current management account or a member account in the account group of the management account.
	ResourceAccountId *int64 `json:"ResourceAccountId,omitempty" xml:"ResourceAccountId,omitempty"`
	// The ID of the resource.
	//
	// For more information about how to query the ID of a resource, see [ListAggregateDiscoveredResources](~~265983~~).
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource.
	//
	// For more information about how to query the type of a resource, see [ListAggregateDiscoveredResources](~~265983~~).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s IgnoreAggregateEvaluationResultsRequestResources) String() string {
	return tea.Prettify(s)
}

func (s IgnoreAggregateEvaluationResultsRequestResources) GoString() string {
	return s.String()
}

func (s *IgnoreAggregateEvaluationResultsRequestResources) SetRegion(v string) *IgnoreAggregateEvaluationResultsRequestResources {
	s.Region = &v
	return s
}

func (s *IgnoreAggregateEvaluationResultsRequestResources) SetResourceAccountId(v int64) *IgnoreAggregateEvaluationResultsRequestResources {
	s.ResourceAccountId = &v
	return s
}

func (s *IgnoreAggregateEvaluationResultsRequestResources) SetResourceId(v string) *IgnoreAggregateEvaluationResultsRequestResources {
	s.ResourceId = &v
	return s
}

func (s *IgnoreAggregateEvaluationResultsRequestResources) SetResourceType(v string) *IgnoreAggregateEvaluationResultsRequestResources {
	s.ResourceType = &v
	return s
}

type IgnoreAggregateEvaluationResultsShrinkRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the rule.
	//
	// For more information about how to obtain the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The date from which the system automatically re-evaluates the ignored incompliant resources.
	//
	// >  If you leave this parameter empty, the system does not automatically re-evaluate the ignored incompliant resources. You must manually re-evaluate the ignored incompliant resources.
	IgnoreDate *string `json:"IgnoreDate,omitempty" xml:"IgnoreDate,omitempty"`
	// The reason why you ignore the resource.
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
	// The resources to be ignored.
	ResourcesShrink *string `json:"Resources,omitempty" xml:"Resources,omitempty"`
}

func (s IgnoreAggregateEvaluationResultsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s IgnoreAggregateEvaluationResultsShrinkRequest) GoString() string {
	return s.String()
}

func (s *IgnoreAggregateEvaluationResultsShrinkRequest) SetAggregatorId(v string) *IgnoreAggregateEvaluationResultsShrinkRequest {
	s.AggregatorId = &v
	return s
}

func (s *IgnoreAggregateEvaluationResultsShrinkRequest) SetConfigRuleId(v string) *IgnoreAggregateEvaluationResultsShrinkRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *IgnoreAggregateEvaluationResultsShrinkRequest) SetIgnoreDate(v string) *IgnoreAggregateEvaluationResultsShrinkRequest {
	s.IgnoreDate = &v
	return s
}

func (s *IgnoreAggregateEvaluationResultsShrinkRequest) SetReason(v string) *IgnoreAggregateEvaluationResultsShrinkRequest {
	s.Reason = &v
	return s
}

func (s *IgnoreAggregateEvaluationResultsShrinkRequest) SetResourcesShrink(v string) *IgnoreAggregateEvaluationResultsShrinkRequest {
	s.ResourcesShrink = &v
	return s
}

type IgnoreAggregateEvaluationResultsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s IgnoreAggregateEvaluationResultsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s IgnoreAggregateEvaluationResultsResponseBody) GoString() string {
	return s.String()
}

func (s *IgnoreAggregateEvaluationResultsResponseBody) SetRequestId(v string) *IgnoreAggregateEvaluationResultsResponseBody {
	s.RequestId = &v
	return s
}

type IgnoreAggregateEvaluationResultsResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *IgnoreAggregateEvaluationResultsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s IgnoreAggregateEvaluationResultsResponse) String() string {
	return tea.Prettify(s)
}

func (s IgnoreAggregateEvaluationResultsResponse) GoString() string {
	return s.String()
}

func (s *IgnoreAggregateEvaluationResultsResponse) SetHeaders(v map[string]*string) *IgnoreAggregateEvaluationResultsResponse {
	s.Headers = v
	return s
}

func (s *IgnoreAggregateEvaluationResultsResponse) SetStatusCode(v int32) *IgnoreAggregateEvaluationResultsResponse {
	s.StatusCode = &v
	return s
}

func (s *IgnoreAggregateEvaluationResultsResponse) SetBody(v *IgnoreAggregateEvaluationResultsResponseBody) *IgnoreAggregateEvaluationResultsResponse {
	s.Body = v
	return s
}

type IgnoreEvaluationResultsRequest struct {
	// The ID of the rule.
	//
	// For more information about how to obtain the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The date from which the system automatically re-evaluates the ignored incompliant resources.
	//
	// >  If you leave this parameter empty, the system does not automatically re-evaluate the ignored incompliant resources. You must manually re-evaluate the ignored incompliant resources.
	IgnoreDate *string `json:"IgnoreDate,omitempty" xml:"IgnoreDate,omitempty"`
	// The reason why you want to ignore the resource.
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
	// The resources to be ignored.
	Resources []*IgnoreEvaluationResultsRequestResources `json:"Resources,omitempty" xml:"Resources,omitempty" type:"Repeated"`
}

func (s IgnoreEvaluationResultsRequest) String() string {
	return tea.Prettify(s)
}

func (s IgnoreEvaluationResultsRequest) GoString() string {
	return s.String()
}

func (s *IgnoreEvaluationResultsRequest) SetConfigRuleId(v string) *IgnoreEvaluationResultsRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *IgnoreEvaluationResultsRequest) SetIgnoreDate(v string) *IgnoreEvaluationResultsRequest {
	s.IgnoreDate = &v
	return s
}

func (s *IgnoreEvaluationResultsRequest) SetReason(v string) *IgnoreEvaluationResultsRequest {
	s.Reason = &v
	return s
}

func (s *IgnoreEvaluationResultsRequest) SetResources(v []*IgnoreEvaluationResultsRequestResources) *IgnoreEvaluationResultsRequest {
	s.Resources = v
	return s
}

type IgnoreEvaluationResultsRequestResources struct {
	// The ID of the region in which the resource resides.
	//
	// For more information about how to obtain the ID of the region in which a resource resides, see [ListDiscoveredResources](~~169620~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The ID of the Alibaba Cloud account to which the resources belong.
	ResourceAccountId *int64 `json:"ResourceAccountId,omitempty" xml:"ResourceAccountId,omitempty"`
	// The ID of the resource.
	//
	// For more information about how to obtain the ID of a resource, see [ListDiscoveredResources](~~169620~~).
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource.
	//
	// For more information about how to obtain the type of a resource, see [ListDiscoveredResources](~~169620~~).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s IgnoreEvaluationResultsRequestResources) String() string {
	return tea.Prettify(s)
}

func (s IgnoreEvaluationResultsRequestResources) GoString() string {
	return s.String()
}

func (s *IgnoreEvaluationResultsRequestResources) SetRegion(v string) *IgnoreEvaluationResultsRequestResources {
	s.Region = &v
	return s
}

func (s *IgnoreEvaluationResultsRequestResources) SetResourceAccountId(v int64) *IgnoreEvaluationResultsRequestResources {
	s.ResourceAccountId = &v
	return s
}

func (s *IgnoreEvaluationResultsRequestResources) SetResourceId(v string) *IgnoreEvaluationResultsRequestResources {
	s.ResourceId = &v
	return s
}

func (s *IgnoreEvaluationResultsRequestResources) SetResourceType(v string) *IgnoreEvaluationResultsRequestResources {
	s.ResourceType = &v
	return s
}

type IgnoreEvaluationResultsShrinkRequest struct {
	// The ID of the rule.
	//
	// For more information about how to obtain the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The date from which the system automatically re-evaluates the ignored incompliant resources.
	//
	// >  If you leave this parameter empty, the system does not automatically re-evaluate the ignored incompliant resources. You must manually re-evaluate the ignored incompliant resources.
	IgnoreDate *string `json:"IgnoreDate,omitempty" xml:"IgnoreDate,omitempty"`
	// The reason why you want to ignore the resource.
	Reason *string `json:"Reason,omitempty" xml:"Reason,omitempty"`
	// The resources to be ignored.
	ResourcesShrink *string `json:"Resources,omitempty" xml:"Resources,omitempty"`
}

func (s IgnoreEvaluationResultsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s IgnoreEvaluationResultsShrinkRequest) GoString() string {
	return s.String()
}

func (s *IgnoreEvaluationResultsShrinkRequest) SetConfigRuleId(v string) *IgnoreEvaluationResultsShrinkRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *IgnoreEvaluationResultsShrinkRequest) SetIgnoreDate(v string) *IgnoreEvaluationResultsShrinkRequest {
	s.IgnoreDate = &v
	return s
}

func (s *IgnoreEvaluationResultsShrinkRequest) SetReason(v string) *IgnoreEvaluationResultsShrinkRequest {
	s.Reason = &v
	return s
}

func (s *IgnoreEvaluationResultsShrinkRequest) SetResourcesShrink(v string) *IgnoreEvaluationResultsShrinkRequest {
	s.ResourcesShrink = &v
	return s
}

type IgnoreEvaluationResultsResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s IgnoreEvaluationResultsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s IgnoreEvaluationResultsResponseBody) GoString() string {
	return s.String()
}

func (s *IgnoreEvaluationResultsResponseBody) SetRequestId(v string) *IgnoreEvaluationResultsResponseBody {
	s.RequestId = &v
	return s
}

type IgnoreEvaluationResultsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *IgnoreEvaluationResultsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s IgnoreEvaluationResultsResponse) String() string {
	return tea.Prettify(s)
}

func (s IgnoreEvaluationResultsResponse) GoString() string {
	return s.String()
}

func (s *IgnoreEvaluationResultsResponse) SetHeaders(v map[string]*string) *IgnoreEvaluationResultsResponse {
	s.Headers = v
	return s
}

func (s *IgnoreEvaluationResultsResponse) SetStatusCode(v int32) *IgnoreEvaluationResultsResponse {
	s.StatusCode = &v
	return s
}

func (s *IgnoreEvaluationResultsResponse) SetBody(v *IgnoreEvaluationResultsResponseBody) *IgnoreEvaluationResultsResponse {
	s.Body = v
	return s
}

type ListAggregateCompliancePacksRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The number of the page to return.
	//
	// Pages start from page 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	//
	// Valid values: 1 to 100. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The status of the one or more compliance packages to be queried. Valid values:
	//
	// *   ACTIVE: compliance packages that are available for use.
	// *   CREATING: compliance packages that are being created.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListAggregateCompliancePacksRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateCompliancePacksRequest) GoString() string {
	return s.String()
}

func (s *ListAggregateCompliancePacksRequest) SetAggregatorId(v string) *ListAggregateCompliancePacksRequest {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregateCompliancePacksRequest) SetPageNumber(v int32) *ListAggregateCompliancePacksRequest {
	s.PageNumber = &v
	return s
}

func (s *ListAggregateCompliancePacksRequest) SetPageSize(v int32) *ListAggregateCompliancePacksRequest {
	s.PageSize = &v
	return s
}

func (s *ListAggregateCompliancePacksRequest) SetStatus(v string) *ListAggregateCompliancePacksRequest {
	s.Status = &v
	return s
}

type ListAggregateCompliancePacksResponseBody struct {
	// The information about the compliance packages.
	CompliancePacksResult *ListAggregateCompliancePacksResponseBodyCompliancePacksResult `json:"CompliancePacksResult,omitempty" xml:"CompliancePacksResult,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAggregateCompliancePacksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateCompliancePacksResponseBody) GoString() string {
	return s.String()
}

func (s *ListAggregateCompliancePacksResponseBody) SetCompliancePacksResult(v *ListAggregateCompliancePacksResponseBodyCompliancePacksResult) *ListAggregateCompliancePacksResponseBody {
	s.CompliancePacksResult = v
	return s
}

func (s *ListAggregateCompliancePacksResponseBody) SetRequestId(v string) *ListAggregateCompliancePacksResponseBody {
	s.RequestId = &v
	return s
}

type ListAggregateCompliancePacksResponseBodyCompliancePacksResult struct {
	// The details of the compliance package.
	CompliancePacks []*ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks `json:"CompliancePacks,omitempty" xml:"CompliancePacks,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of compliance packages returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListAggregateCompliancePacksResponseBodyCompliancePacksResult) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateCompliancePacksResponseBodyCompliancePacksResult) GoString() string {
	return s.String()
}

func (s *ListAggregateCompliancePacksResponseBodyCompliancePacksResult) SetCompliancePacks(v []*ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) *ListAggregateCompliancePacksResponseBodyCompliancePacksResult {
	s.CompliancePacks = v
	return s
}

func (s *ListAggregateCompliancePacksResponseBodyCompliancePacksResult) SetPageNumber(v int32) *ListAggregateCompliancePacksResponseBodyCompliancePacksResult {
	s.PageNumber = &v
	return s
}

func (s *ListAggregateCompliancePacksResponseBodyCompliancePacksResult) SetPageSize(v int32) *ListAggregateCompliancePacksResponseBodyCompliancePacksResult {
	s.PageSize = &v
	return s
}

func (s *ListAggregateCompliancePacksResponseBodyCompliancePacksResult) SetTotalCount(v int64) *ListAggregateCompliancePacksResponseBodyCompliancePacksResult {
	s.TotalCount = &v
	return s
}

type ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks struct {
	// The ID of the management account to which the compliance package belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The name of the compliance package.
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
	// The ID of the compliance package template.
	CompliancePackTemplateId *string `json:"CompliancePackTemplateId,omitempty" xml:"CompliancePackTemplateId,omitempty"`
	// The timestamp when the compliance package was created. Unit: milliseconds.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The description of the compliance package.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The risk level of the resources that are not compliant with the managed rules in the compliance package. Valid values:
	//
	// *   1: high risk level.
	// *   2: medium risk level.
	// *   3: low risk level.
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The status of the compliance package. Valid values:
	//
	// *   ACTIVE: The compliance package is available for use.
	// *   CREATING: The compliance package is being created.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) GoString() string {
	return s.String()
}

func (s *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetAccountId(v int64) *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.AccountId = &v
	return s
}

func (s *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetAggregatorId(v string) *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetCompliancePackId(v string) *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.CompliancePackId = &v
	return s
}

func (s *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetCompliancePackName(v string) *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.CompliancePackName = &v
	return s
}

func (s *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetCompliancePackTemplateId(v string) *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.CompliancePackTemplateId = &v
	return s
}

func (s *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetCreateTimestamp(v int64) *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.CreateTimestamp = &v
	return s
}

func (s *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetDescription(v string) *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.Description = &v
	return s
}

func (s *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetRiskLevel(v int32) *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.RiskLevel = &v
	return s
}

func (s *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetStatus(v string) *ListAggregateCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.Status = &v
	return s
}

type ListAggregateCompliancePacksResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAggregateCompliancePacksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAggregateCompliancePacksResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateCompliancePacksResponse) GoString() string {
	return s.String()
}

func (s *ListAggregateCompliancePacksResponse) SetHeaders(v map[string]*string) *ListAggregateCompliancePacksResponse {
	s.Headers = v
	return s
}

func (s *ListAggregateCompliancePacksResponse) SetStatusCode(v int32) *ListAggregateCompliancePacksResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAggregateCompliancePacksResponse) SetBody(v *ListAggregateCompliancePacksResponseBody) *ListAggregateCompliancePacksResponse {
	s.Body = v
	return s
}

type ListAggregateConfigDeliveryChannelsRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The IDs of the delivery channels. Separate multiple IDs with commas (,).
	DeliveryChannelIds *string `json:"DeliveryChannelIds,omitempty" xml:"DeliveryChannelIds,omitempty"`
}

func (s ListAggregateConfigDeliveryChannelsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigDeliveryChannelsRequest) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigDeliveryChannelsRequest) SetAggregatorId(v string) *ListAggregateConfigDeliveryChannelsRequest {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsRequest) SetDeliveryChannelIds(v string) *ListAggregateConfigDeliveryChannelsRequest {
	s.DeliveryChannelIds = &v
	return s
}

type ListAggregateConfigDeliveryChannelsResponseBody struct {
	// The information about the delivery channels.
	DeliveryChannels []*ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels `json:"DeliveryChannels,omitempty" xml:"DeliveryChannels,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAggregateConfigDeliveryChannelsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigDeliveryChannelsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigDeliveryChannelsResponseBody) SetDeliveryChannels(v []*ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) *ListAggregateConfigDeliveryChannelsResponseBody {
	s.DeliveryChannels = v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponseBody) SetRequestId(v string) *ListAggregateConfigDeliveryChannelsResponseBody {
	s.RequestId = &v
	return s
}

type ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels struct {
	// The ID of the member in the account group.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// Indicates whether the specified destination receives resource change logs. If the value of this parameter is true, Cloud Config delivers the resource change logs to OSS, Log Service, or MNS when the configurations of the resources change. Valid values:
	//
	// *   true: The specified destination receives resource change logs.
	// *   false: The specified destination does not receive resource change logs.
	ConfigurationItemChangeNotification *bool `json:"ConfigurationItemChangeNotification,omitempty" xml:"ConfigurationItemChangeNotification,omitempty"`
	// Indicates whether the specified destination receives scheduled resource snapshots. Cloud Config delivers scheduled resource snapshots at `04:00Z` and `16:00Z` to OSS, MNS, or Log Service every day. The time is displayed in UTC. Valid values:
	//
	// *   true: The specified destination receives scheduled resource snapshots.
	// *   false: The specified destination does not receive scheduled resource snapshots.
	ConfigurationSnapshot *bool `json:"ConfigurationSnapshot,omitempty" xml:"ConfigurationSnapshot,omitempty"`
	// The ARN of the role that is assigned to the delivery channel.
	DeliveryChannelAssumeRoleArn *string `json:"DeliveryChannelAssumeRoleArn,omitempty" xml:"DeliveryChannelAssumeRoleArn,omitempty"`
	// The rule that is attached to the delivery channel. This parameter is available when you deliver data of all types to MNS or deliver snapshots to Log Service.
	//
	// *   If the value of the DeliveryChannelType parameter is MNS, take note of the following settings of the lowest risk level and resource types of the events to which you subscribed:
	//
	//     *   The lowest risk level of the events to which you want to subscribe is in the following format: `{"filterType":"RuleRiskLevel","value":"1","multiple":false}`.
	//
	//         The `value` field indicates the risk level of the events to which you want to subscribe. Valid values: 1, 2, and 3. The value 1 indicates the high risk level, the value 2 indicates the medium risk level, and the value 3 indicates the low risk level.
	//
	//     *   The setting of the resource types of the events to which you want to subscribe is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//         The `values` field indicates the resource types of the events to which you want to subscribe. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	//
	// *   If you set the DeliveryChannelType parameter to SLS, the setting of the resource types of the snapshots to which you want to deliver is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//     The `values` field specifies the resource types of the snapshots to which you want to deliver. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	DeliveryChannelCondition *string `json:"DeliveryChannelCondition,omitempty" xml:"DeliveryChannelCondition,omitempty"`
	// The ID of the delivery channel.
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
	// The name of the delivery channel.
	DeliveryChannelName *string `json:"DeliveryChannelName,omitempty" xml:"DeliveryChannelName,omitempty"`
	// The ARN of the delivery destination.
	//
	// *   If the value of the DeliveryChannelType parameter is OSS, the value of this parameter is the ARN of the destination OSS bucket.
	// *   If the value of the DeliveryChannelType parameter is MNS, the value of this parameter is the ARN of the destination MNS topic.
	// *   If the value of the DeliveryChannelType parameter is SLS, the value of this parameter is the ARN of the destination Log Service Logstore.
	DeliveryChannelTargetArn *string `json:"DeliveryChannelTargetArn,omitempty" xml:"DeliveryChannelTargetArn,omitempty"`
	// The type of the delivery channel. Valid values:
	//
	// *   OSS: Object Storage Service (OSS)
	// *   MNS: Message Service (MNS)
	// *   SLS: Log Service
	DeliveryChannelType *string `json:"DeliveryChannelType,omitempty" xml:"DeliveryChannelType,omitempty"`
	// The time when Cloud Config delivers scheduled resources snapshots every day.
	//
	// Format: `HH:mmZ`. This time is displayed in UTC.
	DeliverySnapshotTime *string `json:"DeliverySnapshotTime,omitempty" xml:"DeliverySnapshotTime,omitempty"`
	// The description of the delivery channel.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the specified destination receives resource non-compliance events. If the value of this parameter is true, Cloud Config delivers resource non-compliance events to Log Service or MNS when resources are evaluated as non-compliant. Valid values:
	//
	// *   true: The specified destination receives resource non-compliance events.
	// *   false: The specified destination does not receive resource non-compliance events.
	NonCompliantNotification *bool `json:"NonCompliantNotification,omitempty" xml:"NonCompliantNotification,omitempty"`
	// The ARN of the OSS bucket to which the delivered data is transferred when the size of the data exceeds the specified upper limit of the delivery channel.
	OversizedDataOSSTargetArn *string `json:"OversizedDataOSSTargetArn,omitempty" xml:"OversizedDataOSSTargetArn,omitempty"`
	// The status of the delivery channel. Valid values:
	//
	// *   0: The delivery channel is disabled.
	// *   1: The delivery channel is enabled.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) SetAccountId(v int64) *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.AccountId = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) SetAggregatorId(v string) *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) SetConfigurationItemChangeNotification(v bool) *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.ConfigurationItemChangeNotification = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) SetConfigurationSnapshot(v bool) *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.ConfigurationSnapshot = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDeliveryChannelAssumeRoleArn(v string) *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.DeliveryChannelAssumeRoleArn = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDeliveryChannelCondition(v string) *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.DeliveryChannelCondition = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDeliveryChannelId(v string) *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.DeliveryChannelId = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDeliveryChannelName(v string) *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.DeliveryChannelName = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDeliveryChannelTargetArn(v string) *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.DeliveryChannelTargetArn = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDeliveryChannelType(v string) *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.DeliveryChannelType = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDeliverySnapshotTime(v string) *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.DeliverySnapshotTime = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDescription(v string) *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.Description = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) SetNonCompliantNotification(v bool) *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.NonCompliantNotification = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) SetOversizedDataOSSTargetArn(v string) *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.OversizedDataOSSTargetArn = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels) SetStatus(v int32) *ListAggregateConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.Status = &v
	return s
}

type ListAggregateConfigDeliveryChannelsResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAggregateConfigDeliveryChannelsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAggregateConfigDeliveryChannelsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigDeliveryChannelsResponse) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigDeliveryChannelsResponse) SetHeaders(v map[string]*string) *ListAggregateConfigDeliveryChannelsResponse {
	s.Headers = v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponse) SetStatusCode(v int32) *ListAggregateConfigDeliveryChannelsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAggregateConfigDeliveryChannelsResponse) SetBody(v *ListAggregateConfigDeliveryChannelsResponseBody) *ListAggregateConfigDeliveryChannelsResponse {
	s.Body = v
	return s
}

type ListAggregateConfigRuleEvaluationResultsRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListAggregateCompliancePacks](~~262059~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The compliance evaluation results of the resources. Valid values:
	//
	// *   COMPLIANT: The resources are evaluated as compliant.
	// *   NON_COMPLIANT: The resources are evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to the resources.
	// *   INSUFFICIENT_DATA: No data is available.
	// *   IGNORED: The resources are ignored during compliance evaluation.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The ID of the rule.
	//
	// For more information about how to obtain the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The maximum number of entries to return in a request. Valid values: 1 to 100.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used to initiate the next request. If the response to the current request is truncated, this token is used to initiate another request and obtain the remaining entries.``
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region whose resources you want to evaluate. Separate multiple region IDs with commas (,).
	Regions           *string `json:"Regions,omitempty" xml:"Regions,omitempty"`
	ResourceAccountId *int64  `json:"ResourceAccountId,omitempty" xml:"ResourceAccountId,omitempty"`
	// The ID of the resource group whose resources you want to evaluate. Separate multiple resource group IDs with commas (,).
	ResourceGroupIds *string `json:"ResourceGroupIds,omitempty" xml:"ResourceGroupIds,omitempty"`
	// Deprecated
	ResourceOwnerId *int64 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resources that you want to evaluate. Separate multiple resource types with commas (,).
	ResourceTypes *string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty"`
}

func (s ListAggregateConfigRuleEvaluationResultsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRuleEvaluationResultsRequest) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRuleEvaluationResultsRequest) SetAggregatorId(v string) *ListAggregateConfigRuleEvaluationResultsRequest {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsRequest) SetCompliancePackId(v string) *ListAggregateConfigRuleEvaluationResultsRequest {
	s.CompliancePackId = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsRequest) SetComplianceType(v string) *ListAggregateConfigRuleEvaluationResultsRequest {
	s.ComplianceType = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsRequest) SetConfigRuleId(v string) *ListAggregateConfigRuleEvaluationResultsRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsRequest) SetMaxResults(v int32) *ListAggregateConfigRuleEvaluationResultsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsRequest) SetNextToken(v string) *ListAggregateConfigRuleEvaluationResultsRequest {
	s.NextToken = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsRequest) SetRegions(v string) *ListAggregateConfigRuleEvaluationResultsRequest {
	s.Regions = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsRequest) SetResourceAccountId(v int64) *ListAggregateConfigRuleEvaluationResultsRequest {
	s.ResourceAccountId = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsRequest) SetResourceGroupIds(v string) *ListAggregateConfigRuleEvaluationResultsRequest {
	s.ResourceGroupIds = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsRequest) SetResourceOwnerId(v int64) *ListAggregateConfigRuleEvaluationResultsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsRequest) SetResourceTypes(v string) *ListAggregateConfigRuleEvaluationResultsRequest {
	s.ResourceTypes = &v
	return s
}

type ListAggregateConfigRuleEvaluationResultsResponseBody struct {
	// The information about the compliance evaluation results returned.
	EvaluationResults *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults `json:"EvaluationResults,omitempty" xml:"EvaluationResults,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAggregateConfigRuleEvaluationResultsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRuleEvaluationResultsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBody) SetEvaluationResults(v *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults) *ListAggregateConfigRuleEvaluationResultsResponseBody {
	s.EvaluationResults = v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBody) SetRequestId(v string) *ListAggregateConfigRuleEvaluationResultsResponseBody {
	s.RequestId = &v
	return s
}

type ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults struct {
	// The details of the compliance evaluation results.
	EvaluationResultList []*ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList `json:"EvaluationResultList,omitempty" xml:"EvaluationResultList,omitempty" type:"Repeated"`
	// The maximum number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that was used to initiate the next request.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults) SetEvaluationResultList(v []*ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults {
	s.EvaluationResultList = v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults) SetMaxResults(v int32) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults {
	s.MaxResults = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults) SetNextToken(v string) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResults {
	s.NextToken = &v
	return s
}

type ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList struct {
	// The annotation to the resource that is evaluated as incompliant. The following section describe the parameters that can be returned:
	//
	// *   `configuration`: the current resource configuration that is evaluated as incompliant by using the rule.
	// *   `desiredValue`: the expected resource configuration that is evaluated as compliant by using the rule.
	// *   `operator`: the operator that is used to compare the current configuration with the expected configuration of the resource.
	// *   `property`: the JSON path of the current configuration in the resource property struct.
	// *   `reason`: the reason why the resource is evaluated as incompliant.
	Annotation *string `json:"Annotation,omitempty" xml:"Annotation,omitempty"`
	// The compliance evaluation result of the resources. Valid values:
	//
	// *   COMPLIANT: The resources are evaluated as compliant.
	// *   NON_COMPLIANT: The resources are evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to the resources.
	// *   INSUFFICIENT_DATA: No resource data is available.
	// *   IGNORED: The resources are ignored during compliance evaluation.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The timestamp when the rule was triggered for the compliance evaluation. Unit: milliseconds.
	ConfigRuleInvokedTimestamp *int64 `json:"ConfigRuleInvokedTimestamp,omitempty" xml:"ConfigRuleInvokedTimestamp,omitempty"`
	// The identifier of the compliance evaluation result.
	EvaluationResultIdentifier *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier `json:"EvaluationResultIdentifier,omitempty" xml:"EvaluationResultIdentifier,omitempty" type:"Struct"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The rule is triggered by configuration changes.
	// *   ScheduledNotification: The rule is periodically triggered.
	InvokingEventMessageType *string `json:"InvokingEventMessageType,omitempty" xml:"InvokingEventMessageType,omitempty"`
	// Indicates whether the remediation template is enabled. Valid values:
	//
	// - true: The remediation template is enabled.
	// - false: The remediation template is disabled.
	RemediationEnabled *bool `json:"RemediationEnabled,omitempty" xml:"RemediationEnabled,omitempty"`
	// The timestamp when the compliance evaluation result was generated. Unit: milliseconds.
	ResultRecordedTimestamp *int64 `json:"ResultRecordedTimestamp,omitempty" xml:"ResultRecordedTimestamp,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetAnnotation(v string) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.Annotation = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetComplianceType(v string) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.ComplianceType = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetConfigRuleInvokedTimestamp(v int64) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.ConfigRuleInvokedTimestamp = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetEvaluationResultIdentifier(v *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.EvaluationResultIdentifier = v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetInvokingEventMessageType(v string) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.InvokingEventMessageType = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetRemediationEnabled(v bool) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.RemediationEnabled = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetResultRecordedTimestamp(v int64) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.ResultRecordedTimestamp = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetRiskLevel(v int32) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.RiskLevel = &v
	return s
}

type ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier struct {
	// The information about the evaluated resource in the compliance evaluation result.
	EvaluationResultQualifier *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier `json:"EvaluationResultQualifier,omitempty" xml:"EvaluationResultQualifier,omitempty" type:"Struct"`
	// The timestamp when the compliance evaluation was performed. Unit: milliseconds.
	//
	// >  This timestamp indicates the time when the rule was triggered. You can obtain the timestamp from the value of the `ConfigRuleInvokedTimestamp` parameter.
	OrderingTimestamp *int64 `json:"OrderingTimestamp,omitempty" xml:"OrderingTimestamp,omitempty"`
}

func (s ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) SetEvaluationResultQualifier(v *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier {
	s.EvaluationResultQualifier = v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) SetOrderingTimestamp(v int64) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier {
	s.OrderingTimestamp = &v
	return s
}

type ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier struct {
	// The ID of the compliance package to which the rule belongs.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the rule.
	ConfigRuleArn *string `json:"ConfigRuleArn,omitempty" xml:"ConfigRuleArn,omitempty"`
	// The ID of the rule.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The date on which the system automatically re-evaluates the ignored incompliant resources.
	//
	// >  If this parameter is left empty, the system does not automatically re-evaluate the ignored incompliant resources. You must manually re-evaluate the ignored incompliant resources.
	IgnoreDate *string `json:"IgnoreDate,omitempty" xml:"IgnoreDate,omitempty"`
	// The ID of the region where the resource resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The name of the resource.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The ID of the Alibaba Cloud account to which the resource belongs.
	ResourceOwnerId *int64 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetCompliancePackId(v string) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.CompliancePackId = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetConfigRuleArn(v string) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ConfigRuleArn = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetConfigRuleId(v string) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ConfigRuleId = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetConfigRuleName(v string) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ConfigRuleName = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetIgnoreDate(v string) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.IgnoreDate = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetRegionId(v string) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.RegionId = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetResourceId(v string) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ResourceId = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetResourceName(v string) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ResourceName = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetResourceOwnerId(v int64) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetResourceType(v string) *ListAggregateConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ResourceType = &v
	return s
}

type ListAggregateConfigRuleEvaluationResultsResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAggregateConfigRuleEvaluationResultsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAggregateConfigRuleEvaluationResultsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRuleEvaluationResultsResponse) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRuleEvaluationResultsResponse) SetHeaders(v map[string]*string) *ListAggregateConfigRuleEvaluationResultsResponse {
	s.Headers = v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponse) SetStatusCode(v int32) *ListAggregateConfigRuleEvaluationResultsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationResultsResponse) SetBody(v *ListAggregateConfigRuleEvaluationResultsResponseBody) *ListAggregateConfigRuleEvaluationResultsResponse {
	s.Body = v
	return s
}

type ListAggregateConfigRuleEvaluationStatisticsRequest struct {
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
}

func (s ListAggregateConfigRuleEvaluationStatisticsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRuleEvaluationStatisticsRequest) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRuleEvaluationStatisticsRequest) SetAggregatorId(v string) *ListAggregateConfigRuleEvaluationStatisticsRequest {
	s.AggregatorId = &v
	return s
}

type ListAggregateConfigRuleEvaluationStatisticsResponseBody struct {
	EvaluationResults []*ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults `json:"EvaluationResults,omitempty" xml:"EvaluationResults,omitempty" type:"Repeated"`
	RequestId         *string                                                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAggregateConfigRuleEvaluationStatisticsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRuleEvaluationStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRuleEvaluationStatisticsResponseBody) SetEvaluationResults(v []*ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) *ListAggregateConfigRuleEvaluationStatisticsResponseBody {
	s.EvaluationResults = v
	return s
}

func (s *ListAggregateConfigRuleEvaluationStatisticsResponseBody) SetRequestId(v string) *ListAggregateConfigRuleEvaluationStatisticsResponseBody {
	s.RequestId = &v
	return s
}

type ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults struct {
	AggregatorId            *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	NonCompliantResourceCnt *int32  `json:"NonCompliantResourceCnt,omitempty" xml:"NonCompliantResourceCnt,omitempty"`
	NonCompliantRuleCnt     *int32  `json:"NonCompliantRuleCnt,omitempty" xml:"NonCompliantRuleCnt,omitempty"`
	StatisticDate           *string `json:"StatisticDate,omitempty" xml:"StatisticDate,omitempty"`
	TotalResourceCnt        *int32  `json:"TotalResourceCnt,omitempty" xml:"TotalResourceCnt,omitempty"`
	TotalRuleCnt            *int32  `json:"TotalRuleCnt,omitempty" xml:"TotalRuleCnt,omitempty"`
}

func (s ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) SetAggregatorId(v string) *ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) SetNonCompliantResourceCnt(v int32) *ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults {
	s.NonCompliantResourceCnt = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) SetNonCompliantRuleCnt(v int32) *ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults {
	s.NonCompliantRuleCnt = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) SetStatisticDate(v string) *ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults {
	s.StatisticDate = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) SetTotalResourceCnt(v int32) *ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults {
	s.TotalResourceCnt = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) SetTotalRuleCnt(v int32) *ListAggregateConfigRuleEvaluationStatisticsResponseBodyEvaluationResults {
	s.TotalRuleCnt = &v
	return s
}

type ListAggregateConfigRuleEvaluationStatisticsResponse struct {
	Headers    map[string]*string                                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAggregateConfigRuleEvaluationStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAggregateConfigRuleEvaluationStatisticsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRuleEvaluationStatisticsResponse) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRuleEvaluationStatisticsResponse) SetHeaders(v map[string]*string) *ListAggregateConfigRuleEvaluationStatisticsResponse {
	s.Headers = v
	return s
}

func (s *ListAggregateConfigRuleEvaluationStatisticsResponse) SetStatusCode(v int32) *ListAggregateConfigRuleEvaluationStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAggregateConfigRuleEvaluationStatisticsResponse) SetBody(v *ListAggregateConfigRuleEvaluationStatisticsResponseBody) *ListAggregateConfigRuleEvaluationStatisticsResponse {
	s.Body = v
	return s
}

type ListAggregateConfigRulesRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The compliance evaluation result. Valid values:
	//
	// *   COMPLIANT: The resource was evaluated as compliant.
	// *   NON_COMPLIANT: The resource was evaluated as incompliant.
	// *   NOT_APPLICABLE: The rule did not apply to your resources.
	// *   INSUFFICIENT_DATA: No resource data was available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The name of the rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The status of the rule. Valid values:
	//
	// *   ACTIVE: The rule is being used to monitor resource configurations.
	// *   DELETING: The rule is being deleted.
	// *   EVALUATING: The rule is triggered and is being used to monitor resource configurations.
	// *   INACTIVE: The rule is disabled.
	ConfigRuleState *string `json:"ConfigRuleState,omitempty" xml:"ConfigRuleState,omitempty"`
	// The keyword that you want to use to query the rules.
	//
	// You can perform a fuzzy search by rule ID, rule name, rule description, or managed rule ID.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The number of the page to return.
	//
	// Minimum value: 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	//
	// Valid values: 1 to 100. Minimum value: 1. Default value: 10.
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceTypes *string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty"`
	// The risk level of the resources that do not comply with the rule. Valid values:
	//
	// *   1: high
	// *   2: medium
	// *   3: low
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s ListAggregateConfigRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRulesRequest) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRulesRequest) SetAggregatorId(v string) *ListAggregateConfigRulesRequest {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregateConfigRulesRequest) SetComplianceType(v string) *ListAggregateConfigRulesRequest {
	s.ComplianceType = &v
	return s
}

func (s *ListAggregateConfigRulesRequest) SetConfigRuleName(v string) *ListAggregateConfigRulesRequest {
	s.ConfigRuleName = &v
	return s
}

func (s *ListAggregateConfigRulesRequest) SetConfigRuleState(v string) *ListAggregateConfigRulesRequest {
	s.ConfigRuleState = &v
	return s
}

func (s *ListAggregateConfigRulesRequest) SetKeyword(v string) *ListAggregateConfigRulesRequest {
	s.Keyword = &v
	return s
}

func (s *ListAggregateConfigRulesRequest) SetPageNumber(v int32) *ListAggregateConfigRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListAggregateConfigRulesRequest) SetPageSize(v int32) *ListAggregateConfigRulesRequest {
	s.PageSize = &v
	return s
}

func (s *ListAggregateConfigRulesRequest) SetResourceTypes(v string) *ListAggregateConfigRulesRequest {
	s.ResourceTypes = &v
	return s
}

func (s *ListAggregateConfigRulesRequest) SetRiskLevel(v int32) *ListAggregateConfigRulesRequest {
	s.RiskLevel = &v
	return s
}

type ListAggregateConfigRulesResponseBody struct {
	// The queried rules.
	ConfigRules *ListAggregateConfigRulesResponseBodyConfigRules `json:"ConfigRules,omitempty" xml:"ConfigRules,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAggregateConfigRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRulesResponseBody) SetConfigRules(v *ListAggregateConfigRulesResponseBodyConfigRules) *ListAggregateConfigRulesResponseBody {
	s.ConfigRules = v
	return s
}

func (s *ListAggregateConfigRulesResponseBody) SetRequestId(v string) *ListAggregateConfigRulesResponseBody {
	s.RequestId = &v
	return s
}

type ListAggregateConfigRulesResponseBodyConfigRules struct {
	// The details of the rule.
	ConfigRuleList []*ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList `json:"ConfigRuleList,omitempty" xml:"ConfigRuleList,omitempty" type:"Repeated"`
	// The number of the page returned.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of rules.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListAggregateConfigRulesResponseBodyConfigRules) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRulesResponseBodyConfigRules) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRulesResponseBodyConfigRules) SetConfigRuleList(v []*ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) *ListAggregateConfigRulesResponseBodyConfigRules {
	s.ConfigRuleList = v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRules) SetPageNumber(v int32) *ListAggregateConfigRulesResponseBodyConfigRules {
	s.PageNumber = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRules) SetPageSize(v int32) *ListAggregateConfigRulesResponseBodyConfigRules {
	s.PageSize = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRules) SetTotalCount(v int64) *ListAggregateConfigRulesResponseBodyConfigRules {
	s.TotalCount = &v
	return s
}

type ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList struct {
	// The ID of the management account to which the rule belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The type of the remediation template. Valid value: OOS, which indicates Operation Orchestration Service.
	AutomationType *string `json:"AutomationType,omitempty" xml:"AutomationType,omitempty"`
	// The compliance evaluation result.
	Compliance *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance `json:"Compliance,omitempty" xml:"Compliance,omitempty" type:"Struct"`
	// The ARN of the rule.
	ConfigRuleArn *string `json:"ConfigRuleArn,omitempty" xml:"ConfigRuleArn,omitempty"`
	// The rule ID.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The rule name.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The status of the rule. Valid values:
	//
	// *   ACTIVE: The rule is enabled.
	// *   DELETING: The rule is being deleted.
	// *   EVALUATING: The rule is triggered and is being used to monitor resource configurations.
	// *   INACTIVE: The rule is disabled.
	ConfigRuleState *string `json:"ConfigRuleState,omitempty" xml:"ConfigRuleState,omitempty"`
	// The information about the creation of the rule.
	CreateBy *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy `json:"CreateBy,omitempty" xml:"CreateBy,omitempty" type:"Struct"`
	// The description of the rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The types of resources evaluated by the rule. Multiple resource types are separated with commas (,).
	ResourceTypesScope *string `json:"ResourceTypesScope,omitempty" xml:"ResourceTypesScope,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high
	// *   2: medium
	// *   3: low
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The ID of the rule.
	//
	// *   If the rule is a managed rule, the value of this parameter is the name of the managed rule.
	// *   If the rule is a custom rule, the value of this parameter is the Alibaba Cloud Resource Name (ARN) of the relevant function in Function Compute.
	SourceIdentifier *string `json:"SourceIdentifier,omitempty" xml:"SourceIdentifier,omitempty"`
	// The type of the rule. Valid values:
	//
	// *   CUSTOM_FC: custom rule
	// *   ALIYUN: managed rule
	SourceOwner *string `json:"SourceOwner,omitempty" xml:"SourceOwner,omitempty"`
	// The tags of the rule.
	Tags []*ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) SetAccountId(v int64) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.AccountId = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) SetAutomationType(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.AutomationType = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) SetCompliance(v *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.Compliance = v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) SetConfigRuleArn(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.ConfigRuleArn = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) SetConfigRuleId(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.ConfigRuleId = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) SetConfigRuleName(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.ConfigRuleName = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) SetConfigRuleState(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.ConfigRuleState = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) SetCreateBy(v *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.CreateBy = v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) SetDescription(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.Description = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) SetResourceTypesScope(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.ResourceTypesScope = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) SetRiskLevel(v int32) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.RiskLevel = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) SetSourceIdentifier(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.SourceIdentifier = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) SetSourceOwner(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.SourceOwner = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList) SetTags(v []*ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.Tags = v
	return s
}

type ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance struct {
	// The compliance evaluation result. Valid values:
	//
	// *   COMPLIANT: The resource is evaluated as compliant.
	// *   NON_COMPLIANT: The resource is evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to the resource.
	// *   INSUFFICIENT_DATA: No resource data is available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The number of evaluated resources.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance) SetComplianceType(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance {
	s.ComplianceType = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance) SetCount(v int32) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCompliance {
	s.Count = &v
	return s
}

type ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy struct {
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The name of the account group.
	AggregatorName *string `json:"AggregatorName,omitempty" xml:"AggregatorName,omitempty"`
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The name of the compliance package.
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
	// The ID of the management account that was used to create the rule.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The name of the management account that was used to create the rule.
	CreatorName *string `json:"CreatorName,omitempty" xml:"CreatorName,omitempty"`
	// The type of the creator of the rule. Valid value: AGGREGATOR, which indicates an account group.
	CreatorType *string `json:"CreatorType,omitempty" xml:"CreatorType,omitempty"`
}

func (s ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy) SetAggregatorId(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy) SetAggregatorName(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy {
	s.AggregatorName = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy) SetCompliancePackId(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy {
	s.CompliancePackId = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy) SetCompliancePackName(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy {
	s.CompliancePackName = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy) SetCreatorId(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy {
	s.CreatorId = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy) SetCreatorName(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy {
	s.CreatorName = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy) SetCreatorType(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy {
	s.CreatorType = &v
	return s
}

type ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags struct {
	// The tag key of the rule.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value of the rule.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags) SetKey(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags {
	s.Key = &v
	return s
}

func (s *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags) SetValue(v string) *ListAggregateConfigRulesResponseBodyConfigRulesConfigRuleListTags {
	s.Value = &v
	return s
}

type ListAggregateConfigRulesResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAggregateConfigRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAggregateConfigRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateConfigRulesResponse) GoString() string {
	return s.String()
}

func (s *ListAggregateConfigRulesResponse) SetHeaders(v map[string]*string) *ListAggregateConfigRulesResponse {
	s.Headers = v
	return s
}

func (s *ListAggregateConfigRulesResponse) SetStatusCode(v int32) *ListAggregateConfigRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAggregateConfigRulesResponse) SetBody(v *ListAggregateConfigRulesResponseBody) *ListAggregateConfigRulesResponse {
	s.Body = v
	return s
}

type ListAggregateDiscoveredResourcesRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The maximum number of entries to return for a single request. Valid values: 1 to 100.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The `token` that you want to use to initiate the current request. If the response of the previous request is truncated, you can use this token to initiate another request and obtain the remaining entries.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region in which the resource resides. Separate multiple region IDs with commas (,).
	Regions *string `json:"Regions,omitempty" xml:"Regions,omitempty"`
	// 账号组内待查询资源所属的阿里云账号ID。
	// > 参数ResourceAccountId和ResourceOwnerId二选一，推荐使用本参数。
	ResourceAccountId *int64 `json:"ResourceAccountId,omitempty" xml:"ResourceAccountId,omitempty"`
	// The status of the resource. Valid values:
	//
	// *   0: The resource is deleted.
	// *   1 (default): The resource is retained.
	ResourceDeleted *int32 `json:"ResourceDeleted,omitempty" xml:"ResourceDeleted,omitempty"`
	// The resource ID.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// Deprecated
	ResourceOwnerId *int64 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource. Separate multiple resource types with commas (,).
	ResourceTypes *string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty"`
}

func (s ListAggregateDiscoveredResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateDiscoveredResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListAggregateDiscoveredResourcesRequest) SetAggregatorId(v string) *ListAggregateDiscoveredResourcesRequest {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesRequest) SetMaxResults(v int32) *ListAggregateDiscoveredResourcesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesRequest) SetNextToken(v string) *ListAggregateDiscoveredResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesRequest) SetRegions(v string) *ListAggregateDiscoveredResourcesRequest {
	s.Regions = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesRequest) SetResourceAccountId(v int64) *ListAggregateDiscoveredResourcesRequest {
	s.ResourceAccountId = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesRequest) SetResourceDeleted(v int32) *ListAggregateDiscoveredResourcesRequest {
	s.ResourceDeleted = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesRequest) SetResourceId(v string) *ListAggregateDiscoveredResourcesRequest {
	s.ResourceId = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesRequest) SetResourceOwnerId(v int64) *ListAggregateDiscoveredResourcesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesRequest) SetResourceTypes(v string) *ListAggregateDiscoveredResourcesRequest {
	s.ResourceTypes = &v
	return s
}

type ListAggregateDiscoveredResourcesResponseBody struct {
	// The list of the resources.
	DiscoveredResourceProfiles *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles `json:"DiscoveredResourceProfiles,omitempty" xml:"DiscoveredResourceProfiles,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAggregateDiscoveredResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateDiscoveredResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListAggregateDiscoveredResourcesResponseBody) SetDiscoveredResourceProfiles(v *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles) *ListAggregateDiscoveredResourcesResponseBody {
	s.DiscoveredResourceProfiles = v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponseBody) SetRequestId(v string) *ListAggregateDiscoveredResourcesResponseBody {
	s.RequestId = &v
	return s
}

type ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles struct {
	// The details of the resources.
	DiscoveredResourceProfileList []*ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList `json:"DiscoveredResourceProfileList,omitempty" xml:"DiscoveredResourceProfileList,omitempty" type:"Repeated"`
	// The maximum number of entries returned on each page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that was used to initiate the next request.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The total number of resources.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles) GoString() string {
	return s.String()
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles) SetDiscoveredResourceProfileList(v []*ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles {
	s.DiscoveredResourceProfileList = v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles) SetMaxResults(v int32) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles {
	s.MaxResults = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles) SetNextToken(v string) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles {
	s.NextToken = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles) SetTotalCount(v int32) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfiles {
	s.TotalCount = &v
	return s
}

type ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList struct {
	// The ID of the Alibaba Cloud account to which the resource belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the zone where the resource resides.
	AvailabilityZone *string `json:"AvailabilityZone,omitempty" xml:"AvailabilityZone,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The timestamp when the resource was created. Unit: milliseconds.
	ResourceCreationTime *int64 `json:"ResourceCreationTime,omitempty" xml:"ResourceCreationTime,omitempty"`
	// The status of the resource. Valid values:
	//
	// *   0: The resource was deleted.
	// *   1: The resource was retained.
	ResourceDeleted *int32 `json:"ResourceDeleted,omitempty" xml:"ResourceDeleted,omitempty"`
	// The resource ID.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The name of the resource.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The ID of the Alibaba Cloud account to which the resource belongs.
	ResourceOwnerId *int64 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The status of the resource. The value of this parameter varies based on the resource type and may be empty. Examples:
	//
	// *   If the value of the ResourceType parameter is ACS::ECS::Instance, the resource is an Elastic Compute Service (ECS) instance that is in a specific state. In this case, the valid values of this parameter are Running and Stopped.
	// *   If the value of the ResourceType parameter is ACS::OSS::Bucket, the resource is an Object Storage Service (OSS) bucket that is not in a specific state. In this case, this parameter is empty.
	ResourceStatus *string `json:"ResourceStatus,omitempty" xml:"ResourceStatus,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags of the resource.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The build version of the resource.
	Version *int64 `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) GoString() string {
	return s.String()
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetAccountId(v int64) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.AccountId = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetAvailabilityZone(v string) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.AvailabilityZone = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetRegion(v string) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.Region = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetResourceCreationTime(v int64) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.ResourceCreationTime = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetResourceDeleted(v int32) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.ResourceDeleted = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetResourceId(v string) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.ResourceId = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetResourceName(v string) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.ResourceName = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetResourceOwnerId(v int64) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetResourceStatus(v string) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.ResourceStatus = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetResourceType(v string) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.ResourceType = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetTags(v string) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.Tags = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetVersion(v int64) *ListAggregateDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.Version = &v
	return s
}

type ListAggregateDiscoveredResourcesResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAggregateDiscoveredResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAggregateDiscoveredResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateDiscoveredResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListAggregateDiscoveredResourcesResponse) SetHeaders(v map[string]*string) *ListAggregateDiscoveredResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponse) SetStatusCode(v int32) *ListAggregateDiscoveredResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAggregateDiscoveredResourcesResponse) SetBody(v *ListAggregateDiscoveredResourcesResponseBody) *ListAggregateDiscoveredResourcesResponse {
	s.Body = v
	return s
}

type ListAggregateRemediationExecutionsRequest struct {
	AggregatorId      *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	ConfigRuleId      *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	ExecutionStatus   *string `json:"ExecutionStatus,omitempty" xml:"ExecutionStatus,omitempty"`
	MaxResults        *int64  `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken         *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	ResourceAccountId *int64  `json:"ResourceAccountId,omitempty" xml:"ResourceAccountId,omitempty"`
}

func (s ListAggregateRemediationExecutionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateRemediationExecutionsRequest) GoString() string {
	return s.String()
}

func (s *ListAggregateRemediationExecutionsRequest) SetAggregatorId(v string) *ListAggregateRemediationExecutionsRequest {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregateRemediationExecutionsRequest) SetConfigRuleId(v string) *ListAggregateRemediationExecutionsRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *ListAggregateRemediationExecutionsRequest) SetExecutionStatus(v string) *ListAggregateRemediationExecutionsRequest {
	s.ExecutionStatus = &v
	return s
}

func (s *ListAggregateRemediationExecutionsRequest) SetMaxResults(v int64) *ListAggregateRemediationExecutionsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListAggregateRemediationExecutionsRequest) SetNextToken(v string) *ListAggregateRemediationExecutionsRequest {
	s.NextToken = &v
	return s
}

func (s *ListAggregateRemediationExecutionsRequest) SetResourceAccountId(v int64) *ListAggregateRemediationExecutionsRequest {
	s.ResourceAccountId = &v
	return s
}

type ListAggregateRemediationExecutionsResponseBody struct {
	RemediationExecutionData *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData `json:"RemediationExecutionData,omitempty" xml:"RemediationExecutionData,omitempty" type:"Struct"`
	RequestId                *string                                                                 `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAggregateRemediationExecutionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateRemediationExecutionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAggregateRemediationExecutionsResponseBody) SetRemediationExecutionData(v *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData) *ListAggregateRemediationExecutionsResponseBody {
	s.RemediationExecutionData = v
	return s
}

func (s *ListAggregateRemediationExecutionsResponseBody) SetRequestId(v string) *ListAggregateRemediationExecutionsResponseBody {
	s.RequestId = &v
	return s
}

type ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData struct {
	MaxResults            *int64                                                                                         `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken             *string                                                                                        `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RemediationExecutions []*ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions `json:"RemediationExecutions,omitempty" xml:"RemediationExecutions,omitempty" type:"Repeated"`
}

func (s ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData) GoString() string {
	return s.String()
}

func (s *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData) SetMaxResults(v int64) *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData {
	s.MaxResults = &v
	return s
}

func (s *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData) SetNextToken(v string) *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData {
	s.NextToken = &v
	return s
}

func (s *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData) SetRemediationExecutions(v []*ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionData {
	s.RemediationExecutions = v
	return s
}

type ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions struct {
	ExecutionCreateDate    *string `json:"ExecutionCreateDate,omitempty" xml:"ExecutionCreateDate,omitempty"`
	ExecutionInvocationId  *string `json:"ExecutionInvocationId,omitempty" xml:"ExecutionInvocationId,omitempty"`
	ExecutionResourceIds   *string `json:"ExecutionResourceIds,omitempty" xml:"ExecutionResourceIds,omitempty"`
	ExecutionResourceType  *string `json:"ExecutionResourceType,omitempty" xml:"ExecutionResourceType,omitempty"`
	ExecutionStatus        *string `json:"ExecutionStatus,omitempty" xml:"ExecutionStatus,omitempty"`
	ExecutionStatusMessage *string `json:"ExecutionStatusMessage,omitempty" xml:"ExecutionStatusMessage,omitempty"`
}

func (s ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) GoString() string {
	return s.String()
}

func (s *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) SetExecutionCreateDate(v string) *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions {
	s.ExecutionCreateDate = &v
	return s
}

func (s *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) SetExecutionInvocationId(v string) *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions {
	s.ExecutionInvocationId = &v
	return s
}

func (s *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) SetExecutionResourceIds(v string) *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions {
	s.ExecutionResourceIds = &v
	return s
}

func (s *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) SetExecutionResourceType(v string) *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions {
	s.ExecutionResourceType = &v
	return s
}

func (s *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) SetExecutionStatus(v string) *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions {
	s.ExecutionStatus = &v
	return s
}

func (s *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) SetExecutionStatusMessage(v string) *ListAggregateRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions {
	s.ExecutionStatusMessage = &v
	return s
}

type ListAggregateRemediationExecutionsResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAggregateRemediationExecutionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAggregateRemediationExecutionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateRemediationExecutionsResponse) GoString() string {
	return s.String()
}

func (s *ListAggregateRemediationExecutionsResponse) SetHeaders(v map[string]*string) *ListAggregateRemediationExecutionsResponse {
	s.Headers = v
	return s
}

func (s *ListAggregateRemediationExecutionsResponse) SetStatusCode(v int32) *ListAggregateRemediationExecutionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAggregateRemediationExecutionsResponse) SetBody(v *ListAggregateRemediationExecutionsResponseBody) *ListAggregateRemediationExecutionsResponse {
	s.Body = v
	return s
}

type ListAggregateRemediationsRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The rule IDs. Separate multiple rule IDs with commas (,).
	//
	// For more information about how to obtain the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
}

func (s ListAggregateRemediationsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateRemediationsRequest) GoString() string {
	return s.String()
}

func (s *ListAggregateRemediationsRequest) SetAggregatorId(v string) *ListAggregateRemediationsRequest {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregateRemediationsRequest) SetConfigRuleIds(v string) *ListAggregateRemediationsRequest {
	s.ConfigRuleIds = &v
	return s
}

type ListAggregateRemediationsResponseBody struct {
	// An array that contains remediation templates.
	Remediations []*ListAggregateRemediationsResponseBodyRemediations `json:"Remediations,omitempty" xml:"Remediations,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAggregateRemediationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateRemediationsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAggregateRemediationsResponseBody) SetRemediations(v []*ListAggregateRemediationsResponseBodyRemediations) *ListAggregateRemediationsResponseBody {
	s.Remediations = v
	return s
}

func (s *ListAggregateRemediationsResponseBody) SetRequestId(v string) *ListAggregateRemediationsResponseBody {
	s.RequestId = &v
	return s
}

type ListAggregateRemediationsResponseBodyRemediations struct {
	// The ID of the Alibaba Cloud account to which the resource belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The rule ID.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The execution mode of the remediation template. Valid values:
	//
	// *   NON_EXECUTION: The remediation template is not executed.
	// *   AUTO_EXECUTION: The remediation template is automatically executed.
	// *   MANUAL_EXECUTION: The remediation template is manually executed.
	// *   NOT_CONFIG: The execution mode is not specified.
	InvokeType *string `json:"InvokeType,omitempty" xml:"InvokeType,omitempty"`
	// The ID of the last successful execution of the remediation template.
	LastSuccessfulInvocationId *string `json:"LastSuccessfulInvocationId,omitempty" xml:"LastSuccessfulInvocationId,omitempty"`
	// The timestamp of the last successful execution of the remediation template. Unit: milliseconds.
	LastSuccessfulInvocationTime *int64 `json:"LastSuccessfulInvocationTime,omitempty" xml:"LastSuccessfulInvocationTime,omitempty"`
	// The mode of the last successful execution of the remediation template. Valid values:
	//
	// *   NON_EXECUTION: The remediation template is not executed.
	// *   AUTO_EXECUTION: The remediation template is automatically executed.
	// *   MANUAL_EXECUTION: The remediation template is manually executed.
	// *   NOT_CONFIG: The execution mode is not specified.
	LastSuccessfulInvocationType *string `json:"LastSuccessfulInvocationType,omitempty" xml:"LastSuccessfulInvocationType,omitempty"`
	// The converted configuration of the remediation template. This parameter is returned only for an OOS remediation template.
	RemediaitonOriginParams *string `json:"RemediaitonOriginParams,omitempty" xml:"RemediaitonOriginParams,omitempty"`
	// The ID of the remediation template.
	RemediationId *string `json:"RemediationId,omitempty" xml:"RemediationId,omitempty"`
	// The source of remediation template. Valid values:
	//
	// *   ALIYUN: official template.
	// *   CUSTOM: custom template.
	// *   NONE: none.
	RemediationSourceType *string `json:"RemediationSourceType,omitempty" xml:"RemediationSourceType,omitempty"`
	// The ID of the remediation template.
	RemediationTemplateId *string `json:"RemediationTemplateId,omitempty" xml:"RemediationTemplateId,omitempty"`
	// The type of the remediation template. Valid values:
	//
	// *   OOS: Operation Orchestration Service (official remediation).
	// *   FC: Function Compute (custom remediation).
	RemediationType *string `json:"RemediationType,omitempty" xml:"RemediationType,omitempty"`
}

func (s ListAggregateRemediationsResponseBodyRemediations) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateRemediationsResponseBodyRemediations) GoString() string {
	return s.String()
}

func (s *ListAggregateRemediationsResponseBodyRemediations) SetAccountId(v int64) *ListAggregateRemediationsResponseBodyRemediations {
	s.AccountId = &v
	return s
}

func (s *ListAggregateRemediationsResponseBodyRemediations) SetAggregatorId(v string) *ListAggregateRemediationsResponseBodyRemediations {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregateRemediationsResponseBodyRemediations) SetConfigRuleId(v string) *ListAggregateRemediationsResponseBodyRemediations {
	s.ConfigRuleId = &v
	return s
}

func (s *ListAggregateRemediationsResponseBodyRemediations) SetInvokeType(v string) *ListAggregateRemediationsResponseBodyRemediations {
	s.InvokeType = &v
	return s
}

func (s *ListAggregateRemediationsResponseBodyRemediations) SetLastSuccessfulInvocationId(v string) *ListAggregateRemediationsResponseBodyRemediations {
	s.LastSuccessfulInvocationId = &v
	return s
}

func (s *ListAggregateRemediationsResponseBodyRemediations) SetLastSuccessfulInvocationTime(v int64) *ListAggregateRemediationsResponseBodyRemediations {
	s.LastSuccessfulInvocationTime = &v
	return s
}

func (s *ListAggregateRemediationsResponseBodyRemediations) SetLastSuccessfulInvocationType(v string) *ListAggregateRemediationsResponseBodyRemediations {
	s.LastSuccessfulInvocationType = &v
	return s
}

func (s *ListAggregateRemediationsResponseBodyRemediations) SetRemediaitonOriginParams(v string) *ListAggregateRemediationsResponseBodyRemediations {
	s.RemediaitonOriginParams = &v
	return s
}

func (s *ListAggregateRemediationsResponseBodyRemediations) SetRemediationId(v string) *ListAggregateRemediationsResponseBodyRemediations {
	s.RemediationId = &v
	return s
}

func (s *ListAggregateRemediationsResponseBodyRemediations) SetRemediationSourceType(v string) *ListAggregateRemediationsResponseBodyRemediations {
	s.RemediationSourceType = &v
	return s
}

func (s *ListAggregateRemediationsResponseBodyRemediations) SetRemediationTemplateId(v string) *ListAggregateRemediationsResponseBodyRemediations {
	s.RemediationTemplateId = &v
	return s
}

func (s *ListAggregateRemediationsResponseBodyRemediations) SetRemediationType(v string) *ListAggregateRemediationsResponseBodyRemediations {
	s.RemediationType = &v
	return s
}

type ListAggregateRemediationsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAggregateRemediationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAggregateRemediationsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateRemediationsResponse) GoString() string {
	return s.String()
}

func (s *ListAggregateRemediationsResponse) SetHeaders(v map[string]*string) *ListAggregateRemediationsResponse {
	s.Headers = v
	return s
}

func (s *ListAggregateRemediationsResponse) SetStatusCode(v int32) *ListAggregateRemediationsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAggregateRemediationsResponse) SetBody(v *ListAggregateRemediationsResponseBody) *ListAggregateRemediationsResponse {
	s.Body = v
	return s
}

type ListAggregateResourceEvaluationResultsRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The compliance evaluation result of the resources. Valid values:
	//
	// *   COMPLIANT: The resources are evaluated as compliant.
	// *   NON_COMPLIANT: The resources are evaluated as incompliant.
	// *   NOT_APPLICABLE: The rule does not apply to your resources.
	// *   INSUFFICIENT_DATA: No resource data is available.
	// *   IGNORED: The resource is ignored during compliance evaluation.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The maximum number of entries to return for a single request. Valid values: 1 to 100.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that you want to use to initiate the current request. If the response of the previous request is truncated, you can use this token to initiate another request and obtain the remaining entries.``
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region where one or more resources that you want to query reside. For example, the value `global` indicates global regions and the value `cn-hangzhou` indicates the China (Hangzhou) region.
	//
	// For more information about how to obtain the ID of a region, see [ListAggregateDiscoveredResources](~~265983~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The ID of the resource.
	//
	// For more information about how to obtain the ID of a resource, see [ListAggregateDiscoveredResources](~~265983~~).
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource.
	//
	// For more information about how to query the type of a resource, see [ListAggregateDiscoveredResources](~~265983~~).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ListAggregateResourceEvaluationResultsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourceEvaluationResultsRequest) GoString() string {
	return s.String()
}

func (s *ListAggregateResourceEvaluationResultsRequest) SetAggregatorId(v string) *ListAggregateResourceEvaluationResultsRequest {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsRequest) SetComplianceType(v string) *ListAggregateResourceEvaluationResultsRequest {
	s.ComplianceType = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsRequest) SetMaxResults(v int32) *ListAggregateResourceEvaluationResultsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsRequest) SetNextToken(v string) *ListAggregateResourceEvaluationResultsRequest {
	s.NextToken = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsRequest) SetRegion(v string) *ListAggregateResourceEvaluationResultsRequest {
	s.Region = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsRequest) SetResourceId(v string) *ListAggregateResourceEvaluationResultsRequest {
	s.ResourceId = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsRequest) SetResourceType(v string) *ListAggregateResourceEvaluationResultsRequest {
	s.ResourceType = &v
	return s
}

type ListAggregateResourceEvaluationResultsResponseBody struct {
	// The information about the compliance evaluation results returned.
	EvaluationResults *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults `json:"EvaluationResults,omitempty" xml:"EvaluationResults,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAggregateResourceEvaluationResultsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourceEvaluationResultsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAggregateResourceEvaluationResultsResponseBody) SetEvaluationResults(v *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults) *ListAggregateResourceEvaluationResultsResponseBody {
	s.EvaluationResults = v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBody) SetRequestId(v string) *ListAggregateResourceEvaluationResultsResponseBody {
	s.RequestId = &v
	return s
}

type ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults struct {
	// The details of the compliance evaluation result.
	EvaluationResultList []*ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList `json:"EvaluationResultList,omitempty" xml:"EvaluationResultList,omitempty" type:"Repeated"`
	// The maximum number of entries returned on each page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that was used to initiate the next request.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults) GoString() string {
	return s.String()
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults) SetEvaluationResultList(v []*ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults {
	s.EvaluationResultList = v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults) SetMaxResults(v int32) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults {
	s.MaxResults = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults) SetNextToken(v string) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResults {
	s.NextToken = &v
	return s
}

type ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList struct {
	// The annotation to the resource that is evaluated as incompliant.
	Annotation *string `json:"Annotation,omitempty" xml:"Annotation,omitempty"`
	// The compliance evaluation result of the resources. Valid values:
	//
	// *   COMPLIANT: The resources are evaluated as compliant.
	// *   NON_COMPLIANT: The resources are evaluated as incompliant.
	// *   NOT_APPLICABLE: The rule does not apply to your resources.
	// *   INSUFFICIENT_DATA: No resource data is available.
	// *   IGNORED: The resource is ignored during compliance evaluation.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The timestamp when the rule was triggered. Unit: milliseconds.
	ConfigRuleInvokedTimestamp *int64 `json:"ConfigRuleInvokedTimestamp,omitempty" xml:"ConfigRuleInvokedTimestamp,omitempty"`
	// The identifying information about the compliance evaluation result.
	EvaluationResultIdentifier *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier `json:"EvaluationResultIdentifier,omitempty" xml:"EvaluationResultIdentifier,omitempty" type:"Struct"`
	// The trigger type of the managed rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The managed rule is triggered by configuration changes.
	// *   ScheduledNotification: The managed rule is periodically triggered.
	InvokingEventMessageType *string `json:"InvokingEventMessageType,omitempty" xml:"InvokingEventMessageType,omitempty"`
	// Indicates whether the remediation template is enabled. Valid values:
	//
	// - true: The remediation template is enabled.
	// - false: The remediation template is disabled.
	RemediationEnabled *bool `json:"RemediationEnabled,omitempty" xml:"RemediationEnabled,omitempty"`
	// The timestamp when the compliance evaluation result was recorded. Unit: milliseconds.
	ResultRecordedTimestamp *int64 `json:"ResultRecordedTimestamp,omitempty" xml:"ResultRecordedTimestamp,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) GoString() string {
	return s.String()
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetAnnotation(v string) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.Annotation = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetComplianceType(v string) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.ComplianceType = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetConfigRuleInvokedTimestamp(v int64) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.ConfigRuleInvokedTimestamp = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetEvaluationResultIdentifier(v *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.EvaluationResultIdentifier = v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetInvokingEventMessageType(v string) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.InvokingEventMessageType = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetRemediationEnabled(v bool) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.RemediationEnabled = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetResultRecordedTimestamp(v int64) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.ResultRecordedTimestamp = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetRiskLevel(v int32) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.RiskLevel = &v
	return s
}

type ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier struct {
	// The information about the evaluated resource in the compliance evaluation result.
	EvaluationResultQualifier *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier `json:"EvaluationResultQualifier,omitempty" xml:"EvaluationResultQualifier,omitempty" type:"Struct"`
	// The timestamp when the compliance evaluation was performed. Unit: milliseconds.
	OrderingTimestamp *int64 `json:"OrderingTimestamp,omitempty" xml:"OrderingTimestamp,omitempty"`
}

func (s ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) GoString() string {
	return s.String()
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) SetEvaluationResultQualifier(v *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier {
	s.EvaluationResultQualifier = v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) SetOrderingTimestamp(v int64) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier {
	s.OrderingTimestamp = &v
	return s
}

type ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier struct {
	// The Alibaba Cloud Resource Name (ARN) of the rule.
	ConfigRuleArn *string `json:"ConfigRuleArn,omitempty" xml:"ConfigRuleArn,omitempty"`
	// The ID of the rule.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the monitoring rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The date from which the system automatically re-evaluates the ignored incompliant resources.
	//
	// >  If the value of this parameter is left empty, the system does not automatically re-evaluate the ignored incompliant resources. You must manually re-evaluate the ignored incompliant resources.
	IgnoreDate *string `json:"IgnoreDate,omitempty" xml:"IgnoreDate,omitempty"`
	// The ID of the region where the resource resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The name of the resource.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) GoString() string {
	return s.String()
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetConfigRuleArn(v string) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ConfigRuleArn = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetConfigRuleId(v string) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ConfigRuleId = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetConfigRuleName(v string) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ConfigRuleName = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetIgnoreDate(v string) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.IgnoreDate = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetRegionId(v string) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.RegionId = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetResourceId(v string) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ResourceId = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetResourceName(v string) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ResourceName = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetResourceType(v string) *ListAggregateResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ResourceType = &v
	return s
}

type ListAggregateResourceEvaluationResultsResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAggregateResourceEvaluationResultsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAggregateResourceEvaluationResultsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourceEvaluationResultsResponse) GoString() string {
	return s.String()
}

func (s *ListAggregateResourceEvaluationResultsResponse) SetHeaders(v map[string]*string) *ListAggregateResourceEvaluationResultsResponse {
	s.Headers = v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponse) SetStatusCode(v int32) *ListAggregateResourceEvaluationResultsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAggregateResourceEvaluationResultsResponse) SetBody(v *ListAggregateResourceEvaluationResultsResponseBody) *ListAggregateResourceEvaluationResultsResponse {
	s.Body = v
	return s
}

type ListAggregateResourceRelationsRequest struct {
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The maximum number of entries to return for a single request. Valid values: 1 to 1000.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region in which the resource resides.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The type of the relationship between the resource and the object.
	//
	// Valid values:
	//
	// *   IsContained: The object is included as part of the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   IsAttachedTo: The object is added to the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   IsAssociatedIn: The object is associated with the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Contains: The actual value contains the expected value.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	RelationType *string `json:"RelationType,omitempty" xml:"RelationType,omitempty"`
	// The ID of the Alibaba Cloud account to which the resources in the account group belong.
	ResourceAccountId *int64 `json:"ResourceAccountId,omitempty" xml:"ResourceAccountId,omitempty"`
	// The resource ID.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The ID of the resource that is associated with the object.
	TargetResourceId *string `json:"TargetResourceId,omitempty" xml:"TargetResourceId,omitempty"`
	// The type of the resource that is associated with the object.
	TargetResourceType *string `json:"TargetResourceType,omitempty" xml:"TargetResourceType,omitempty"`
}

func (s ListAggregateResourceRelationsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourceRelationsRequest) GoString() string {
	return s.String()
}

func (s *ListAggregateResourceRelationsRequest) SetAggregatorId(v string) *ListAggregateResourceRelationsRequest {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregateResourceRelationsRequest) SetMaxResults(v int32) *ListAggregateResourceRelationsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListAggregateResourceRelationsRequest) SetNextToken(v string) *ListAggregateResourceRelationsRequest {
	s.NextToken = &v
	return s
}

func (s *ListAggregateResourceRelationsRequest) SetRegion(v string) *ListAggregateResourceRelationsRequest {
	s.Region = &v
	return s
}

func (s *ListAggregateResourceRelationsRequest) SetRelationType(v string) *ListAggregateResourceRelationsRequest {
	s.RelationType = &v
	return s
}

func (s *ListAggregateResourceRelationsRequest) SetResourceAccountId(v int64) *ListAggregateResourceRelationsRequest {
	s.ResourceAccountId = &v
	return s
}

func (s *ListAggregateResourceRelationsRequest) SetResourceId(v string) *ListAggregateResourceRelationsRequest {
	s.ResourceId = &v
	return s
}

func (s *ListAggregateResourceRelationsRequest) SetResourceType(v string) *ListAggregateResourceRelationsRequest {
	s.ResourceType = &v
	return s
}

func (s *ListAggregateResourceRelationsRequest) SetTargetResourceId(v string) *ListAggregateResourceRelationsRequest {
	s.TargetResourceId = &v
	return s
}

func (s *ListAggregateResourceRelationsRequest) SetTargetResourceType(v string) *ListAggregateResourceRelationsRequest {
	s.TargetResourceType = &v
	return s
}

type ListAggregateResourceRelationsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The result of the relationship.
	ResourceRelations *ListAggregateResourceRelationsResponseBodyResourceRelations `json:"ResourceRelations,omitempty" xml:"ResourceRelations,omitempty" type:"Struct"`
}

func (s ListAggregateResourceRelationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourceRelationsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAggregateResourceRelationsResponseBody) SetRequestId(v string) *ListAggregateResourceRelationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAggregateResourceRelationsResponseBody) SetResourceRelations(v *ListAggregateResourceRelationsResponseBodyResourceRelations) *ListAggregateResourceRelationsResponseBody {
	s.ResourceRelations = v
	return s
}

type ListAggregateResourceRelationsResponseBodyResourceRelations struct {
	// The maximum number of entries returned on each page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that was used to initiate the next request.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The type of the relationship between the resource and the object.
	//
	// Valid values:
	//
	// *   IsContained: The object is included as part of the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   IsAttachedTo: The object is added to the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   IsAssociatedIn: The object is associated with the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Contains: The actual value contains the expected value.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	ResourceRelationList []*ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList `json:"ResourceRelationList,omitempty" xml:"ResourceRelationList,omitempty" type:"Repeated"`
}

func (s ListAggregateResourceRelationsResponseBodyResourceRelations) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourceRelationsResponseBodyResourceRelations) GoString() string {
	return s.String()
}

func (s *ListAggregateResourceRelationsResponseBodyResourceRelations) SetMaxResults(v int32) *ListAggregateResourceRelationsResponseBodyResourceRelations {
	s.MaxResults = &v
	return s
}

func (s *ListAggregateResourceRelationsResponseBodyResourceRelations) SetNextToken(v string) *ListAggregateResourceRelationsResponseBodyResourceRelations {
	s.NextToken = &v
	return s
}

func (s *ListAggregateResourceRelationsResponseBodyResourceRelations) SetResourceRelationList(v []*ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList) *ListAggregateResourceRelationsResponseBodyResourceRelations {
	s.ResourceRelationList = v
	return s
}

type ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList struct {
	// The ID of the Alibaba Cloud account to which the resource belongs.
	AccountId *int32 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The type of the relationship between the resource and the object.
	//
	// Valid values:
	//
	// *   IsContained: The object is included as part of the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   IsAttachedTo: The object is added to the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   IsAssociatedIn: The object is associated with the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Contains: The object contains the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	RelationType *string `json:"RelationType,omitempty" xml:"RelationType,omitempty"`
	// The resource ID.
	SourceResourceId *string `json:"SourceResourceId,omitempty" xml:"SourceResourceId,omitempty"`
	// The ID of the region to which the current resource belongs.
	SourceResourceRegionId *string `json:"SourceResourceRegionId,omitempty" xml:"SourceResourceRegionId,omitempty"`
	// The type of the resource.
	SourceResourceType *string `json:"SourceResourceType,omitempty" xml:"SourceResourceType,omitempty"`
	// The ID of the resource that is associated with the object.
	TargetResourceId *string `json:"TargetResourceId,omitempty" xml:"TargetResourceId,omitempty"`
	// The type of the resource that is associated with the object.
	TargetResourceType *string `json:"TargetResourceType,omitempty" xml:"TargetResourceType,omitempty"`
}

func (s ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList) GoString() string {
	return s.String()
}

func (s *ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList) SetAccountId(v int32) *ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList {
	s.AccountId = &v
	return s
}

func (s *ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList) SetRelationType(v string) *ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList {
	s.RelationType = &v
	return s
}

func (s *ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList) SetSourceResourceId(v string) *ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList {
	s.SourceResourceId = &v
	return s
}

func (s *ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList) SetSourceResourceRegionId(v string) *ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList {
	s.SourceResourceRegionId = &v
	return s
}

func (s *ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList) SetSourceResourceType(v string) *ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList {
	s.SourceResourceType = &v
	return s
}

func (s *ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList) SetTargetResourceId(v string) *ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList {
	s.TargetResourceId = &v
	return s
}

func (s *ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList) SetTargetResourceType(v string) *ListAggregateResourceRelationsResponseBodyResourceRelationsResourceRelationList {
	s.TargetResourceType = &v
	return s
}

type ListAggregateResourceRelationsResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAggregateResourceRelationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAggregateResourceRelationsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourceRelationsResponse) GoString() string {
	return s.String()
}

func (s *ListAggregateResourceRelationsResponse) SetHeaders(v map[string]*string) *ListAggregateResourceRelationsResponse {
	s.Headers = v
	return s
}

func (s *ListAggregateResourceRelationsResponse) SetStatusCode(v int32) *ListAggregateResourceRelationsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAggregateResourceRelationsResponse) SetBody(v *ListAggregateResourceRelationsResponseBody) *ListAggregateResourceRelationsResponse {
	s.Body = v
	return s
}

type ListAggregateResourcesByAdvancedSearchRequest struct {
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	Sql          *string `json:"Sql,omitempty" xml:"Sql,omitempty"`
}

func (s ListAggregateResourcesByAdvancedSearchRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourcesByAdvancedSearchRequest) GoString() string {
	return s.String()
}

func (s *ListAggregateResourcesByAdvancedSearchRequest) SetAggregatorId(v string) *ListAggregateResourcesByAdvancedSearchRequest {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregateResourcesByAdvancedSearchRequest) SetSql(v string) *ListAggregateResourcesByAdvancedSearchRequest {
	s.Sql = &v
	return s
}

type ListAggregateResourcesByAdvancedSearchResponseBody struct {
	QueryResults *ListAggregateResourcesByAdvancedSearchResponseBodyQueryResults `json:"QueryResults,omitempty" xml:"QueryResults,omitempty" type:"Struct"`
	RequestId    *string                                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAggregateResourcesByAdvancedSearchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourcesByAdvancedSearchResponseBody) GoString() string {
	return s.String()
}

func (s *ListAggregateResourcesByAdvancedSearchResponseBody) SetQueryResults(v *ListAggregateResourcesByAdvancedSearchResponseBodyQueryResults) *ListAggregateResourcesByAdvancedSearchResponseBody {
	s.QueryResults = v
	return s
}

func (s *ListAggregateResourcesByAdvancedSearchResponseBody) SetRequestId(v string) *ListAggregateResourcesByAdvancedSearchResponseBody {
	s.RequestId = &v
	return s
}

type ListAggregateResourcesByAdvancedSearchResponseBodyQueryResults struct {
	QueryResultList *ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList `json:"QueryResultList,omitempty" xml:"QueryResultList,omitempty" type:"Struct"`
}

func (s ListAggregateResourcesByAdvancedSearchResponseBodyQueryResults) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourcesByAdvancedSearchResponseBodyQueryResults) GoString() string {
	return s.String()
}

func (s *ListAggregateResourcesByAdvancedSearchResponseBodyQueryResults) SetQueryResultList(v *ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList) *ListAggregateResourcesByAdvancedSearchResponseBodyQueryResults {
	s.QueryResultList = v
	return s
}

type ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList struct {
	Columns []*string     `json:"Columns,omitempty" xml:"Columns,omitempty" type:"Repeated"`
	Values  []interface{} `json:"Values,omitempty" xml:"Values,omitempty" type:"Repeated"`
}

func (s ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList) GoString() string {
	return s.String()
}

func (s *ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList) SetColumns(v []*string) *ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList {
	s.Columns = v
	return s
}

func (s *ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList) SetValues(v []interface{}) *ListAggregateResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList {
	s.Values = v
	return s
}

type ListAggregateResourcesByAdvancedSearchResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAggregateResourcesByAdvancedSearchResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAggregateResourcesByAdvancedSearchResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAggregateResourcesByAdvancedSearchResponse) GoString() string {
	return s.String()
}

func (s *ListAggregateResourcesByAdvancedSearchResponse) SetHeaders(v map[string]*string) *ListAggregateResourcesByAdvancedSearchResponse {
	s.Headers = v
	return s
}

func (s *ListAggregateResourcesByAdvancedSearchResponse) SetStatusCode(v int32) *ListAggregateResourcesByAdvancedSearchResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAggregateResourcesByAdvancedSearchResponse) SetBody(v *ListAggregateResourcesByAdvancedSearchResponseBody) *ListAggregateResourcesByAdvancedSearchResponse {
	s.Body = v
	return s
}

type ListAggregatorsRequest struct {
	// The maximum number of entries to return for a single request. Valid values: 1 to 100.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used to initiate the next request. If the response of the current request is truncated, this token is used to initiate another request and obtain the remaining entries.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s ListAggregatorsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAggregatorsRequest) GoString() string {
	return s.String()
}

func (s *ListAggregatorsRequest) SetMaxResults(v int32) *ListAggregatorsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListAggregatorsRequest) SetNextToken(v string) *ListAggregatorsRequest {
	s.NextToken = &v
	return s
}

type ListAggregatorsResponseBody struct {
	// The account groups returned.
	AggregatorsResult *ListAggregatorsResponseBodyAggregatorsResult `json:"AggregatorsResult,omitempty" xml:"AggregatorsResult,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListAggregatorsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAggregatorsResponseBody) GoString() string {
	return s.String()
}

func (s *ListAggregatorsResponseBody) SetAggregatorsResult(v *ListAggregatorsResponseBodyAggregatorsResult) *ListAggregatorsResponseBody {
	s.AggregatorsResult = v
	return s
}

func (s *ListAggregatorsResponseBody) SetRequestId(v string) *ListAggregatorsResponseBody {
	s.RequestId = &v
	return s
}

type ListAggregatorsResponseBodyAggregatorsResult struct {
	// The information about the account groups.
	Aggregators []*ListAggregatorsResponseBodyAggregatorsResultAggregators `json:"Aggregators,omitempty" xml:"Aggregators,omitempty" type:"Repeated"`
	// The token that is used to initiate the next request. If the response of the current request is truncated, this token is used to initiate another request and obtain the remaining entries.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s ListAggregatorsResponseBodyAggregatorsResult) String() string {
	return tea.Prettify(s)
}

func (s ListAggregatorsResponseBodyAggregatorsResult) GoString() string {
	return s.String()
}

func (s *ListAggregatorsResponseBodyAggregatorsResult) SetAggregators(v []*ListAggregatorsResponseBodyAggregatorsResultAggregators) *ListAggregatorsResponseBodyAggregatorsResult {
	s.Aggregators = v
	return s
}

func (s *ListAggregatorsResponseBodyAggregatorsResult) SetNextToken(v string) *ListAggregatorsResponseBodyAggregatorsResult {
	s.NextToken = &v
	return s
}

type ListAggregatorsResponseBodyAggregatorsResultAggregators struct {
	// The ID of the management account used to create the account group.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The number of member accounts in the account group.
	AggregatorAccountCount *int64 `json:"AggregatorAccountCount,omitempty" xml:"AggregatorAccountCount,omitempty"`
	// The timestamp when the account group was created.
	AggregatorCreateTimestamp *int64 `json:"AggregatorCreateTimestamp,omitempty" xml:"AggregatorCreateTimestamp,omitempty"`
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The name of the account group.
	AggregatorName *string `json:"AggregatorName,omitempty" xml:"AggregatorName,omitempty"`
	// The status of the account group. Valid values:
	//
	// *   0: being created.
	// *   1: created.
	AggregatorStatus *int32 `json:"AggregatorStatus,omitempty" xml:"AggregatorStatus,omitempty"`
	// The type of the account group. Valid values:
	//
	// *   RD: global account group.
	// *   CUSTOM: custom account group.
	AggregatorType *string `json:"AggregatorType,omitempty" xml:"AggregatorType,omitempty"`
	// The description of the account group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
}

func (s ListAggregatorsResponseBodyAggregatorsResultAggregators) String() string {
	return tea.Prettify(s)
}

func (s ListAggregatorsResponseBodyAggregatorsResultAggregators) GoString() string {
	return s.String()
}

func (s *ListAggregatorsResponseBodyAggregatorsResultAggregators) SetAccountId(v int64) *ListAggregatorsResponseBodyAggregatorsResultAggregators {
	s.AccountId = &v
	return s
}

func (s *ListAggregatorsResponseBodyAggregatorsResultAggregators) SetAggregatorAccountCount(v int64) *ListAggregatorsResponseBodyAggregatorsResultAggregators {
	s.AggregatorAccountCount = &v
	return s
}

func (s *ListAggregatorsResponseBodyAggregatorsResultAggregators) SetAggregatorCreateTimestamp(v int64) *ListAggregatorsResponseBodyAggregatorsResultAggregators {
	s.AggregatorCreateTimestamp = &v
	return s
}

func (s *ListAggregatorsResponseBodyAggregatorsResultAggregators) SetAggregatorId(v string) *ListAggregatorsResponseBodyAggregatorsResultAggregators {
	s.AggregatorId = &v
	return s
}

func (s *ListAggregatorsResponseBodyAggregatorsResultAggregators) SetAggregatorName(v string) *ListAggregatorsResponseBodyAggregatorsResultAggregators {
	s.AggregatorName = &v
	return s
}

func (s *ListAggregatorsResponseBodyAggregatorsResultAggregators) SetAggregatorStatus(v int32) *ListAggregatorsResponseBodyAggregatorsResultAggregators {
	s.AggregatorStatus = &v
	return s
}

func (s *ListAggregatorsResponseBodyAggregatorsResultAggregators) SetAggregatorType(v string) *ListAggregatorsResponseBodyAggregatorsResultAggregators {
	s.AggregatorType = &v
	return s
}

func (s *ListAggregatorsResponseBodyAggregatorsResultAggregators) SetDescription(v string) *ListAggregatorsResponseBodyAggregatorsResultAggregators {
	s.Description = &v
	return s
}

type ListAggregatorsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAggregatorsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAggregatorsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAggregatorsResponse) GoString() string {
	return s.String()
}

func (s *ListAggregatorsResponse) SetHeaders(v map[string]*string) *ListAggregatorsResponse {
	s.Headers = v
	return s
}

func (s *ListAggregatorsResponse) SetStatusCode(v int32) *ListAggregatorsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAggregatorsResponse) SetBody(v *ListAggregatorsResponseBody) *ListAggregatorsResponse {
	s.Body = v
	return s
}

type ListCompliancePackTemplatesRequest struct {
	// The ID of the compliance package template.
	//
	// For more information about how to obtain the ID of a compliance package template, see [ListCompliancePackTemplates](~~261176~~).
	CompliancePackTemplateId *string `json:"CompliancePackTemplateId,omitempty" xml:"CompliancePackTemplateId,omitempty"`
	// The page number.
	//
	// Pages start from page 1. Default value: 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// Valid values: 1 to 100. Minimum value: 1. Default value: 10.
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceTypes *string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty"`
}

func (s ListCompliancePackTemplatesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCompliancePackTemplatesRequest) GoString() string {
	return s.String()
}

func (s *ListCompliancePackTemplatesRequest) SetCompliancePackTemplateId(v string) *ListCompliancePackTemplatesRequest {
	s.CompliancePackTemplateId = &v
	return s
}

func (s *ListCompliancePackTemplatesRequest) SetPageNumber(v int32) *ListCompliancePackTemplatesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListCompliancePackTemplatesRequest) SetPageSize(v int32) *ListCompliancePackTemplatesRequest {
	s.PageSize = &v
	return s
}

func (s *ListCompliancePackTemplatesRequest) SetResourceTypes(v string) *ListCompliancePackTemplatesRequest {
	s.ResourceTypes = &v
	return s
}

type ListCompliancePackTemplatesResponseBody struct {
	// The information about the compliance package templates.
	CompliancePackTemplatesResult *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult `json:"CompliancePackTemplatesResult,omitempty" xml:"CompliancePackTemplatesResult,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListCompliancePackTemplatesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCompliancePackTemplatesResponseBody) GoString() string {
	return s.String()
}

func (s *ListCompliancePackTemplatesResponseBody) SetCompliancePackTemplatesResult(v *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult) *ListCompliancePackTemplatesResponseBody {
	s.CompliancePackTemplatesResult = v
	return s
}

func (s *ListCompliancePackTemplatesResponseBody) SetRequestId(v string) *ListCompliancePackTemplatesResponseBody {
	s.RequestId = &v
	return s
}

type ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult struct {
	// The compliance package templates.
	CompliancePackTemplates []*ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates `json:"CompliancePackTemplates,omitempty" xml:"CompliancePackTemplates,omitempty" type:"Repeated"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of the compliance package templates returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult) String() string {
	return tea.Prettify(s)
}

func (s ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult) GoString() string {
	return s.String()
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult) SetCompliancePackTemplates(v []*ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult {
	s.CompliancePackTemplates = v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult) SetPageNumber(v int32) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult {
	s.PageNumber = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult) SetPageSize(v int32) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult {
	s.PageSize = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult) SetTotalCount(v int64) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResult {
	s.TotalCount = &v
	return s
}

type ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates struct {
	// The ID of the compliance package template.
	CompliancePackTemplateId *string `json:"CompliancePackTemplateId,omitempty" xml:"CompliancePackTemplateId,omitempty"`
	// The name of the compliance package template.
	CompliancePackTemplateName *string `json:"CompliancePackTemplateName,omitempty" xml:"CompliancePackTemplateName,omitempty"`
	// The information about managed rules in the compliance package.
	ConfigRules []*ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules `json:"ConfigRules,omitempty" xml:"ConfigRules,omitempty" type:"Repeated"`
	// The description of the compliance package.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The tag of the compliance package.
	Labels *string `json:"Labels,omitempty" xml:"Labels,omitempty"`
	// The time when the compliance package was last updated.
	LastUpdate *int32 `json:"LastUpdate,omitempty" xml:"LastUpdate,omitempty"`
	// The risk level of the resources that are not compliant with the managed rules in the compliance package. Valid values:
	//
	// *   1: high
	// *   2: medium
	// *   3: low
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates) String() string {
	return tea.Prettify(s)
}

func (s ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates) GoString() string {
	return s.String()
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates) SetCompliancePackTemplateId(v string) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates {
	s.CompliancePackTemplateId = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates) SetCompliancePackTemplateName(v string) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates {
	s.CompliancePackTemplateName = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates) SetConfigRules(v []*ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates {
	s.ConfigRules = v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates) SetDescription(v string) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates {
	s.Description = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates) SetLabels(v string) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates {
	s.Labels = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates) SetLastUpdate(v int32) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates {
	s.LastUpdate = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates) SetRiskLevel(v int32) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplates {
	s.RiskLevel = &v
	return s
}

type ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules struct {
	// The input parameters of the managed rule.
	ConfigRuleParameters []*ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters `json:"ConfigRuleParameters,omitempty" xml:"ConfigRuleParameters,omitempty" type:"Repeated"`
	// The description of the regulation. This parameter is available only for regulation compliance packages.
	ControlDescription *string `json:"ControlDescription,omitempty" xml:"ControlDescription,omitempty"`
	// The ID of the regulation.
	//
	// > This parameter is available only for regulation compliance packages.
	ControlId *string `json:"ControlId,omitempty" xml:"ControlId,omitempty"`
	// Indicates whether the rule was enabled together with the compliance package. Default value: false. The value true indicates that the rule was enabled together with the compliance package. Valid values:
	//
	// *   true
	// *   false
	DefaultEnable *bool `json:"DefaultEnable,omitempty" xml:"DefaultEnable,omitempty"`
	// The description of the managed rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The identifier of the managed rule.
	ManagedRuleIdentifier *string `json:"ManagedRuleIdentifier,omitempty" xml:"ManagedRuleIdentifier,omitempty"`
	// The name of the managed rule.
	ManagedRuleName *string `json:"ManagedRuleName,omitempty" xml:"ManagedRuleName,omitempty"`
	// The type of the resource evaluated based on the rule.
	ResourceTypesScope *string `json:"ResourceTypesScope,omitempty" xml:"ResourceTypesScope,omitempty"`
	// The risk level of the resources that are not compliant with the managed rule. Valid values:
	//
	// *   1: high
	// *   2: medium
	// *   3: low
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules) String() string {
	return tea.Prettify(s)
}

func (s ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules) GoString() string {
	return s.String()
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules) SetConfigRuleParameters(v []*ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules {
	s.ConfigRuleParameters = v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules) SetControlDescription(v string) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules {
	s.ControlDescription = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules) SetControlId(v string) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules {
	s.ControlId = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules) SetDefaultEnable(v bool) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules {
	s.DefaultEnable = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules) SetDescription(v string) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules {
	s.Description = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules) SetManagedRuleIdentifier(v string) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules {
	s.ManagedRuleIdentifier = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules) SetManagedRuleName(v string) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules {
	s.ManagedRuleName = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules) SetResourceTypesScope(v string) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules {
	s.ResourceTypesScope = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules) SetRiskLevel(v int32) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRules {
	s.RiskLevel = &v
	return s
}

type ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters struct {
	// The name of the input parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The value of the input parameter.
	ParameterValue *string `json:"ParameterValue,omitempty" xml:"ParameterValue,omitempty"`
	// Indicates whether the input parameter is required. Valid values:
	//
	// *   true: The parameter is required.
	// *   false: The input parameter is optional.
	Required *bool `json:"Required,omitempty" xml:"Required,omitempty"`
}

func (s ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters) String() string {
	return tea.Prettify(s)
}

func (s ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters) GoString() string {
	return s.String()
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters) SetParameterName(v string) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters {
	s.ParameterName = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters) SetParameterValue(v string) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters {
	s.ParameterValue = &v
	return s
}

func (s *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters) SetRequired(v bool) *ListCompliancePackTemplatesResponseBodyCompliancePackTemplatesResultCompliancePackTemplatesConfigRulesConfigRuleParameters {
	s.Required = &v
	return s
}

type ListCompliancePackTemplatesResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListCompliancePackTemplatesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListCompliancePackTemplatesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCompliancePackTemplatesResponse) GoString() string {
	return s.String()
}

func (s *ListCompliancePackTemplatesResponse) SetHeaders(v map[string]*string) *ListCompliancePackTemplatesResponse {
	s.Headers = v
	return s
}

func (s *ListCompliancePackTemplatesResponse) SetStatusCode(v int32) *ListCompliancePackTemplatesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCompliancePackTemplatesResponse) SetBody(v *ListCompliancePackTemplatesResponseBody) *ListCompliancePackTemplatesResponse {
	s.Body = v
	return s
}

type ListCompliancePacksRequest struct {
	// The number of the page to return.
	//
	// Pages start from page 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	//
	// Valid values: 1 to 100. Pages start from page 1. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The status of the compliance package to be queried. Valid values:
	//
	// *   ACTIVE: The compliance package is active.
	// *   CREATING: The compliance package is being created.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListCompliancePacksRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCompliancePacksRequest) GoString() string {
	return s.String()
}

func (s *ListCompliancePacksRequest) SetPageNumber(v int32) *ListCompliancePacksRequest {
	s.PageNumber = &v
	return s
}

func (s *ListCompliancePacksRequest) SetPageSize(v int32) *ListCompliancePacksRequest {
	s.PageSize = &v
	return s
}

func (s *ListCompliancePacksRequest) SetStatus(v string) *ListCompliancePacksRequest {
	s.Status = &v
	return s
}

type ListCompliancePacksResponseBody struct {
	// The compliance packages returned.
	CompliancePacksResult *ListCompliancePacksResponseBodyCompliancePacksResult `json:"CompliancePacksResult,omitempty" xml:"CompliancePacksResult,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListCompliancePacksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCompliancePacksResponseBody) GoString() string {
	return s.String()
}

func (s *ListCompliancePacksResponseBody) SetCompliancePacksResult(v *ListCompliancePacksResponseBodyCompliancePacksResult) *ListCompliancePacksResponseBody {
	s.CompliancePacksResult = v
	return s
}

func (s *ListCompliancePacksResponseBody) SetRequestId(v string) *ListCompliancePacksResponseBody {
	s.RequestId = &v
	return s
}

type ListCompliancePacksResponseBodyCompliancePacksResult struct {
	// The details of the compliance package.
	CompliancePacks []*ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks `json:"CompliancePacks,omitempty" xml:"CompliancePacks,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of compliance packages returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListCompliancePacksResponseBodyCompliancePacksResult) String() string {
	return tea.Prettify(s)
}

func (s ListCompliancePacksResponseBodyCompliancePacksResult) GoString() string {
	return s.String()
}

func (s *ListCompliancePacksResponseBodyCompliancePacksResult) SetCompliancePacks(v []*ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) *ListCompliancePacksResponseBodyCompliancePacksResult {
	s.CompliancePacks = v
	return s
}

func (s *ListCompliancePacksResponseBodyCompliancePacksResult) SetPageNumber(v int32) *ListCompliancePacksResponseBodyCompliancePacksResult {
	s.PageNumber = &v
	return s
}

func (s *ListCompliancePacksResponseBodyCompliancePacksResult) SetPageSize(v int32) *ListCompliancePacksResponseBodyCompliancePacksResult {
	s.PageSize = &v
	return s
}

func (s *ListCompliancePacksResponseBodyCompliancePacksResult) SetTotalCount(v int64) *ListCompliancePacksResponseBodyCompliancePacksResult {
	s.TotalCount = &v
	return s
}

type ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks struct {
	// The ID of the Alibaba Cloud account to which the compliance package belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The name of the compliance package.
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
	// The ID of the compliance package template based on which the compliance package was created.
	CompliancePackTemplateId *string `json:"CompliancePackTemplateId,omitempty" xml:"CompliancePackTemplateId,omitempty"`
	// The timestamp when the compliance package was created. Unit: milliseconds.
	CreateTimestamp *int64 `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	// The description of the compliance package.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The risk level of the resources that are not compliant with the managed rules in the compliance package. Valid values:
	//
	// *   1: high risk level.
	// *   2: medium risk level.
	// *   3: low risk level.
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The status of the compliance package. Valid values:
	//
	// *   ACTIVE: The compliance package is active.
	// *   CREATING: The compliance package is being created.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) String() string {
	return tea.Prettify(s)
}

func (s ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) GoString() string {
	return s.String()
}

func (s *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetAccountId(v int64) *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.AccountId = &v
	return s
}

func (s *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetCompliancePackId(v string) *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.CompliancePackId = &v
	return s
}

func (s *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetCompliancePackName(v string) *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.CompliancePackName = &v
	return s
}

func (s *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetCompliancePackTemplateId(v string) *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.CompliancePackTemplateId = &v
	return s
}

func (s *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetCreateTimestamp(v int64) *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.CreateTimestamp = &v
	return s
}

func (s *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetDescription(v string) *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.Description = &v
	return s
}

func (s *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetRiskLevel(v int32) *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.RiskLevel = &v
	return s
}

func (s *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks) SetStatus(v string) *ListCompliancePacksResponseBodyCompliancePacksResultCompliancePacks {
	s.Status = &v
	return s
}

type ListCompliancePacksResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListCompliancePacksResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListCompliancePacksResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCompliancePacksResponse) GoString() string {
	return s.String()
}

func (s *ListCompliancePacksResponse) SetHeaders(v map[string]*string) *ListCompliancePacksResponse {
	s.Headers = v
	return s
}

func (s *ListCompliancePacksResponse) SetStatusCode(v int32) *ListCompliancePacksResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCompliancePacksResponse) SetBody(v *ListCompliancePacksResponseBody) *ListCompliancePacksResponse {
	s.Body = v
	return s
}

type ListConfigDeliveryChannelsRequest struct {
	// The ID of the delivery channel. Separate multiple IDs with commas (,).
	DeliveryChannelIds *string `json:"DeliveryChannelIds,omitempty" xml:"DeliveryChannelIds,omitempty"`
}

func (s ListConfigDeliveryChannelsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListConfigDeliveryChannelsRequest) GoString() string {
	return s.String()
}

func (s *ListConfigDeliveryChannelsRequest) SetDeliveryChannelIds(v string) *ListConfigDeliveryChannelsRequest {
	s.DeliveryChannelIds = &v
	return s
}

type ListConfigDeliveryChannelsResponseBody struct {
	// The information about the delivery channels.
	DeliveryChannels []*ListConfigDeliveryChannelsResponseBodyDeliveryChannels `json:"DeliveryChannels,omitempty" xml:"DeliveryChannels,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListConfigDeliveryChannelsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListConfigDeliveryChannelsResponseBody) GoString() string {
	return s.String()
}

func (s *ListConfigDeliveryChannelsResponseBody) SetDeliveryChannels(v []*ListConfigDeliveryChannelsResponseBodyDeliveryChannels) *ListConfigDeliveryChannelsResponseBody {
	s.DeliveryChannels = v
	return s
}

func (s *ListConfigDeliveryChannelsResponseBody) SetRequestId(v string) *ListConfigDeliveryChannelsResponseBody {
	s.RequestId = &v
	return s
}

type ListConfigDeliveryChannelsResponseBodyDeliveryChannels struct {
	// The ID of your Alibaba Cloud account.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// Indicates whether the specified destination receives resource change logs. If the value of this parameter is true, Cloud Config delivers the resource change logs to OSS, Log Service, or MNS when the configurations of the resources change. Valid values:
	//
	// *   true: The specified destination receives resource change logs.
	// *   false: The specified destination does not receive resource change logs.
	ConfigurationItemChangeNotification *bool `json:"ConfigurationItemChangeNotification,omitempty" xml:"ConfigurationItemChangeNotification,omitempty"`
	// Indicates whether the specified destination receives scheduled resource snapshots. Cloud Config delivers scheduled resource snapshots at `04:00Z` and `16:00Z` to OSS, MNS, or Log Service every day. The time is displayed in UTC. Valid values:
	//
	// *   true: The specified destination receives scheduled resource snapshots.
	// *   false: The specified destination does not receive scheduled resource snapshots.
	ConfigurationSnapshot *bool `json:"ConfigurationSnapshot,omitempty" xml:"ConfigurationSnapshot,omitempty"`
	// The ARN of the role assumed by the delivery channel.
	DeliveryChannelAssumeRoleArn *string `json:"DeliveryChannelAssumeRoleArn,omitempty" xml:"DeliveryChannelAssumeRoleArn,omitempty"`
	// The rule that is attached to the delivery channel. This parameter is available when you deliver data of all types to MNS or deliver snapshots to Log Service.
	//
	// *   If the value of the DeliveryChannelType parameter is MNS, take note of the following settings of the lowest risk level and resource types of the events to which you subscribed:
	//
	//     *   The setting of the lowest risk level for the events to which you want to subscribe is in the following format: `{"filterType":"RuleRiskLevel","value":"1","multiple":false}`.
	//
	//         The `value` field indicates the lowest risk level of the events to which you want to subscribe. Valid values: 1, 2, and 3. The value 1 indicates the high risk level, the value 2 indicates the medium risk level, and the value 3 indicates the low risk level.
	//
	//     *   The setting of the resource types of the events to which you want to subscribe is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//         The `values` field indicates the resource types of the events to which you want to subscribe. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	//
	// *   If you set the DeliveryChannelType parameter to SLS, the setting of the resource types of the snapshots to which you want to deliver is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//     The `values` field specifies the resource types of the snapshots to which you want to deliver. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	DeliveryChannelCondition *string `json:"DeliveryChannelCondition,omitempty" xml:"DeliveryChannelCondition,omitempty"`
	// The ID of the delivery channel.
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
	// The name of the delivery channel.
	DeliveryChannelName *string `json:"DeliveryChannelName,omitempty" xml:"DeliveryChannelName,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the delivery destination.
	//
	// *   If the value of the DeliveryChannelType parameter is OSS, the value of this parameter is the ARN of the destination OSS bucket.
	// *   If the value of the DeliveryChannelType parameter is MNS, the value of this parameter is the ARN of the destination MNS topic.
	// *   If the value of the DeliveryChannelType parameter is SLS, the value of this parameter is the ARN of the destination Log Service Logstore.
	DeliveryChannelTargetArn *string `json:"DeliveryChannelTargetArn,omitempty" xml:"DeliveryChannelTargetArn,omitempty"`
	// The type of the delivery channel. Valid values:
	//
	// *   OSS: Object Storage Service (OSS)
	// *   MNS: Message Service (MNS)
	// *   SLS: Log Service
	DeliveryChannelType *string `json:"DeliveryChannelType,omitempty" xml:"DeliveryChannelType,omitempty"`
	// The time when Cloud Config delivers scheduled resources snapshots every day.
	//
	// Format: `HH:mmZ`. This time is displayed in UTC.
	DeliverySnapshotTime *string `json:"DeliverySnapshotTime,omitempty" xml:"DeliverySnapshotTime,omitempty"`
	// The description of the delivery channel.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether the specified destination receives resource non-compliance events. If the value of this parameter is true, Cloud Config delivers resource non-compliance events to Log Service or MNS when resources are evaluated as non-compliant. Valid values:
	//
	// *   true: The specified destination receives resource non-compliance events.
	// *   false: The specified destination does not receive resource non-compliance events.
	NonCompliantNotification *bool `json:"NonCompliantNotification,omitempty" xml:"NonCompliantNotification,omitempty"`
	// The ARN of the OSS bucket to which you want to transfer the delivery data when the size of the data exceeds the specified upper limit of the delivery channel.
	OversizedDataOSSTargetArn *string `json:"OversizedDataOSSTargetArn,omitempty" xml:"OversizedDataOSSTargetArn,omitempty"`
	// The status of the delivery channel. Valid values:
	//
	// *   0: The delivery channel is disabled.
	// *   1: The delivery channel is enabled.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListConfigDeliveryChannelsResponseBodyDeliveryChannels) String() string {
	return tea.Prettify(s)
}

func (s ListConfigDeliveryChannelsResponseBodyDeliveryChannels) GoString() string {
	return s.String()
}

func (s *ListConfigDeliveryChannelsResponseBodyDeliveryChannels) SetAccountId(v int64) *ListConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.AccountId = &v
	return s
}

func (s *ListConfigDeliveryChannelsResponseBodyDeliveryChannels) SetConfigurationItemChangeNotification(v bool) *ListConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.ConfigurationItemChangeNotification = &v
	return s
}

func (s *ListConfigDeliveryChannelsResponseBodyDeliveryChannels) SetConfigurationSnapshot(v bool) *ListConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.ConfigurationSnapshot = &v
	return s
}

func (s *ListConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDeliveryChannelAssumeRoleArn(v string) *ListConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.DeliveryChannelAssumeRoleArn = &v
	return s
}

func (s *ListConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDeliveryChannelCondition(v string) *ListConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.DeliveryChannelCondition = &v
	return s
}

func (s *ListConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDeliveryChannelId(v string) *ListConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.DeliveryChannelId = &v
	return s
}

func (s *ListConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDeliveryChannelName(v string) *ListConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.DeliveryChannelName = &v
	return s
}

func (s *ListConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDeliveryChannelTargetArn(v string) *ListConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.DeliveryChannelTargetArn = &v
	return s
}

func (s *ListConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDeliveryChannelType(v string) *ListConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.DeliveryChannelType = &v
	return s
}

func (s *ListConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDeliverySnapshotTime(v string) *ListConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.DeliverySnapshotTime = &v
	return s
}

func (s *ListConfigDeliveryChannelsResponseBodyDeliveryChannels) SetDescription(v string) *ListConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.Description = &v
	return s
}

func (s *ListConfigDeliveryChannelsResponseBodyDeliveryChannels) SetNonCompliantNotification(v bool) *ListConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.NonCompliantNotification = &v
	return s
}

func (s *ListConfigDeliveryChannelsResponseBodyDeliveryChannels) SetOversizedDataOSSTargetArn(v string) *ListConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.OversizedDataOSSTargetArn = &v
	return s
}

func (s *ListConfigDeliveryChannelsResponseBodyDeliveryChannels) SetStatus(v int32) *ListConfigDeliveryChannelsResponseBodyDeliveryChannels {
	s.Status = &v
	return s
}

type ListConfigDeliveryChannelsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListConfigDeliveryChannelsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListConfigDeliveryChannelsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListConfigDeliveryChannelsResponse) GoString() string {
	return s.String()
}

func (s *ListConfigDeliveryChannelsResponse) SetHeaders(v map[string]*string) *ListConfigDeliveryChannelsResponse {
	s.Headers = v
	return s
}

func (s *ListConfigDeliveryChannelsResponse) SetStatusCode(v int32) *ListConfigDeliveryChannelsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListConfigDeliveryChannelsResponse) SetBody(v *ListConfigDeliveryChannelsResponseBody) *ListConfigDeliveryChannelsResponse {
	s.Body = v
	return s
}

type ListConfigRuleEvaluationResultsRequest struct {
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListCompliancePacks](~~263332~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The compliance evaluation result of resources. Valid values:
	//
	// *   COMPLIANT: The resources are evaluated as compliant.
	// *   NON_COMPLIANT: The resources are evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to the resources.
	// *   INSUFFICIENT_DATA: No resource data is available.
	// *   IGNORED: The resource is ignored during compliance evaluation.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The ID of the rule.
	//
	// For more information about how to obtain the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The maximum number of entries to return in a request. Valid values: 1 to 100.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that is used to initiate the next request. If the response to the current request is truncated, this token is used to initiate another request and obtain the remaining entries.``
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region where the resources that you want to evaluate reside. Separate multiple region IDs with commas (,).
	Regions *string `json:"Regions,omitempty" xml:"Regions,omitempty"`
	// The ID of the resource group to which the resources that you want to evaluate belong. Separate multiple resource group IDs with commas (,).
	ResourceGroupIds *string `json:"ResourceGroupIds,omitempty" xml:"ResourceGroupIds,omitempty"`
	// The type of the resources that you want to evaluate. Separate multiple resource types with commas (,).
	ResourceTypes *string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty"`
}

func (s ListConfigRuleEvaluationResultsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRuleEvaluationResultsRequest) GoString() string {
	return s.String()
}

func (s *ListConfigRuleEvaluationResultsRequest) SetCompliancePackId(v string) *ListConfigRuleEvaluationResultsRequest {
	s.CompliancePackId = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsRequest) SetComplianceType(v string) *ListConfigRuleEvaluationResultsRequest {
	s.ComplianceType = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsRequest) SetConfigRuleId(v string) *ListConfigRuleEvaluationResultsRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsRequest) SetMaxResults(v int32) *ListConfigRuleEvaluationResultsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsRequest) SetNextToken(v string) *ListConfigRuleEvaluationResultsRequest {
	s.NextToken = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsRequest) SetRegions(v string) *ListConfigRuleEvaluationResultsRequest {
	s.Regions = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsRequest) SetResourceGroupIds(v string) *ListConfigRuleEvaluationResultsRequest {
	s.ResourceGroupIds = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsRequest) SetResourceTypes(v string) *ListConfigRuleEvaluationResultsRequest {
	s.ResourceTypes = &v
	return s
}

type ListConfigRuleEvaluationResultsResponseBody struct {
	// The compliance evaluation result returned.
	EvaluationResults *ListConfigRuleEvaluationResultsResponseBodyEvaluationResults `json:"EvaluationResults,omitempty" xml:"EvaluationResults,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListConfigRuleEvaluationResultsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRuleEvaluationResultsResponseBody) GoString() string {
	return s.String()
}

func (s *ListConfigRuleEvaluationResultsResponseBody) SetEvaluationResults(v *ListConfigRuleEvaluationResultsResponseBodyEvaluationResults) *ListConfigRuleEvaluationResultsResponseBody {
	s.EvaluationResults = v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBody) SetRequestId(v string) *ListConfigRuleEvaluationResultsResponseBody {
	s.RequestId = &v
	return s
}

type ListConfigRuleEvaluationResultsResponseBodyEvaluationResults struct {
	// The details of the compliance evaluation result.
	EvaluationResultList []*ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList `json:"EvaluationResultList,omitempty" xml:"EvaluationResultList,omitempty" type:"Repeated"`
	// The maximum number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that was used to initiate the next request.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s ListConfigRuleEvaluationResultsResponseBodyEvaluationResults) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRuleEvaluationResultsResponseBodyEvaluationResults) GoString() string {
	return s.String()
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResults) SetEvaluationResultList(v []*ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResults {
	s.EvaluationResultList = v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResults) SetMaxResults(v int32) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResults {
	s.MaxResults = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResults) SetNextToken(v string) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResults {
	s.NextToken = &v
	return s
}

type ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList struct {
	// The annotation to the resource that is evaluated as non-compliant. The following parameters may be returned:
	//
	// *   `configuration`: the current resource configuration that is evaluated as non-compliant.
	// *   `desiredValue`: the expected resource configuration that is evaluated as compliant.
	// *   `operator`: the operator that compares the current configuration with the expected configuration of the resource.
	// *   `property`: the JSON path of the current configuration in the resource property struct.
	// *   `reason`: the reason why the resource is evaluated as non-compliant.
	Annotation *string `json:"Annotation,omitempty" xml:"Annotation,omitempty"`
	// The compliance evaluation result of the resources. Valid values:
	//
	// *   COMPLIANT: The resources are evaluated as compliant.
	// *   NON_COMPLIANT: The resources are evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to the resources.
	// *   INSUFFICIENT_DATA: No resource data is available.
	// *   IGNORED: The resource is ignored during compliance evaluation.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The timestamp when the rule was triggered for the compliance evaluation. Unit: milliseconds.
	ConfigRuleInvokedTimestamp *int64 `json:"ConfigRuleInvokedTimestamp,omitempty" xml:"ConfigRuleInvokedTimestamp,omitempty"`
	// The identifier of the compliance evaluation result.
	EvaluationResultIdentifier *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier `json:"EvaluationResultIdentifier,omitempty" xml:"EvaluationResultIdentifier,omitempty" type:"Struct"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The rule is triggered by configuration changes.
	// *   ScheduledNotification: The rule is periodically triggered.
	InvokingEventMessageType *string `json:"InvokingEventMessageType,omitempty" xml:"InvokingEventMessageType,omitempty"`
	// Indicates whether the remediation template is enabled. Valid values:
	//
	// - true: The remediation template is enabled.
	// - false: The remediation template is disabled.
	RemediationEnabled *bool `json:"RemediationEnabled,omitempty" xml:"RemediationEnabled,omitempty"`
	// The timestamp when the compliance evaluation result was recorded. Unit: milliseconds.
	ResultRecordedTimestamp *int64 `json:"ResultRecordedTimestamp,omitempty" xml:"ResultRecordedTimestamp,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) GoString() string {
	return s.String()
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetAnnotation(v string) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.Annotation = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetComplianceType(v string) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.ComplianceType = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetConfigRuleInvokedTimestamp(v int64) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.ConfigRuleInvokedTimestamp = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetEvaluationResultIdentifier(v *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.EvaluationResultIdentifier = v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetInvokingEventMessageType(v string) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.InvokingEventMessageType = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetRemediationEnabled(v bool) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.RemediationEnabled = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetResultRecordedTimestamp(v int64) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.ResultRecordedTimestamp = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetRiskLevel(v int32) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.RiskLevel = &v
	return s
}

type ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier struct {
	// The information about the evaluated resource in the compliance evaluation result.
	EvaluationResultQualifier *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier `json:"EvaluationResultQualifier,omitempty" xml:"EvaluationResultQualifier,omitempty" type:"Struct"`
	// The timestamp when the compliance evaluation was performed. Unit: milliseconds.
	OrderingTimestamp *int64 `json:"OrderingTimestamp,omitempty" xml:"OrderingTimestamp,omitempty"`
}

func (s ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) GoString() string {
	return s.String()
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) SetEvaluationResultQualifier(v *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier {
	s.EvaluationResultQualifier = v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) SetOrderingTimestamp(v int64) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier {
	s.OrderingTimestamp = &v
	return s
}

type ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier struct {
	// The ID of the compliance package to which the rule belongs.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the rule.
	ConfigRuleArn *string `json:"ConfigRuleArn,omitempty" xml:"ConfigRuleArn,omitempty"`
	// The ID of the rule.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The date on which the system automatically re-evaluates the ignored incompliant resources.
	//
	// >  If this parameter is left empty, the system does not automatically re-evaluate the ignored incompliant resources. You must manually re-evaluate the ignored incompliant resources.
	IgnoreDate *string `json:"IgnoreDate,omitempty" xml:"IgnoreDate,omitempty"`
	// The ID of the region where the resource resides.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The name of the resource.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The ID of the Alibaba Cloud account to which the resources belong.
	ResourceOwnerId *int64 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) GoString() string {
	return s.String()
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetCompliancePackId(v string) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.CompliancePackId = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetConfigRuleArn(v string) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ConfigRuleArn = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetConfigRuleId(v string) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ConfigRuleId = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetConfigRuleName(v string) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ConfigRuleName = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetIgnoreDate(v string) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.IgnoreDate = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetRegionId(v string) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.RegionId = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetResourceId(v string) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ResourceId = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetResourceName(v string) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ResourceName = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetResourceOwnerId(v int64) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetResourceType(v string) *ListConfigRuleEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ResourceType = &v
	return s
}

type ListConfigRuleEvaluationResultsResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListConfigRuleEvaluationResultsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListConfigRuleEvaluationResultsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRuleEvaluationResultsResponse) GoString() string {
	return s.String()
}

func (s *ListConfigRuleEvaluationResultsResponse) SetHeaders(v map[string]*string) *ListConfigRuleEvaluationResultsResponse {
	s.Headers = v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponse) SetStatusCode(v int32) *ListConfigRuleEvaluationResultsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListConfigRuleEvaluationResultsResponse) SetBody(v *ListConfigRuleEvaluationResultsResponseBody) *ListConfigRuleEvaluationResultsResponse {
	s.Body = v
	return s
}

type ListConfigRuleEvaluationStatisticsResponseBody struct {
	EvaluationResults []*ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults `json:"EvaluationResults,omitempty" xml:"EvaluationResults,omitempty" type:"Repeated"`
	RequestId         *string                                                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListConfigRuleEvaluationStatisticsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRuleEvaluationStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *ListConfigRuleEvaluationStatisticsResponseBody) SetEvaluationResults(v []*ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) *ListConfigRuleEvaluationStatisticsResponseBody {
	s.EvaluationResults = v
	return s
}

func (s *ListConfigRuleEvaluationStatisticsResponseBody) SetRequestId(v string) *ListConfigRuleEvaluationStatisticsResponseBody {
	s.RequestId = &v
	return s
}

type ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults struct {
	NonCompliantResourceCnt *int32  `json:"NonCompliantResourceCnt,omitempty" xml:"NonCompliantResourceCnt,omitempty"`
	NonCompliantRuleCnt     *int32  `json:"NonCompliantRuleCnt,omitempty" xml:"NonCompliantRuleCnt,omitempty"`
	StatisticDate           *string `json:"StatisticDate,omitempty" xml:"StatisticDate,omitempty"`
	TotalResourceCnt        *int32  `json:"TotalResourceCnt,omitempty" xml:"TotalResourceCnt,omitempty"`
	TotalRuleCnt            *int32  `json:"TotalRuleCnt,omitempty" xml:"TotalRuleCnt,omitempty"`
}

func (s ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) GoString() string {
	return s.String()
}

func (s *ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) SetNonCompliantResourceCnt(v int32) *ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults {
	s.NonCompliantResourceCnt = &v
	return s
}

func (s *ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) SetNonCompliantRuleCnt(v int32) *ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults {
	s.NonCompliantRuleCnt = &v
	return s
}

func (s *ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) SetStatisticDate(v string) *ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults {
	s.StatisticDate = &v
	return s
}

func (s *ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) SetTotalResourceCnt(v int32) *ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults {
	s.TotalResourceCnt = &v
	return s
}

func (s *ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults) SetTotalRuleCnt(v int32) *ListConfigRuleEvaluationStatisticsResponseBodyEvaluationResults {
	s.TotalRuleCnt = &v
	return s
}

type ListConfigRuleEvaluationStatisticsResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListConfigRuleEvaluationStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListConfigRuleEvaluationStatisticsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRuleEvaluationStatisticsResponse) GoString() string {
	return s.String()
}

func (s *ListConfigRuleEvaluationStatisticsResponse) SetHeaders(v map[string]*string) *ListConfigRuleEvaluationStatisticsResponse {
	s.Headers = v
	return s
}

func (s *ListConfigRuleEvaluationStatisticsResponse) SetStatusCode(v int32) *ListConfigRuleEvaluationStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListConfigRuleEvaluationStatisticsResponse) SetBody(v *ListConfigRuleEvaluationStatisticsResponseBody) *ListConfigRuleEvaluationStatisticsResponse {
	s.Body = v
	return s
}

type ListConfigRulesRequest struct {
	// The compliance evaluation result. Valid values:
	//
	// *   COMPLIANT: The resources are evaluated as compliant.
	// *   NON_COMPLIANT: The resources are evaluated as non-compliant.
	// *   NOT_APPLICABLE: The rule does not apply to the resources.
	// *   INSUFFICIENT_DATA: No resource data is available.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The name of the rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The status of the rule. Valid values:
	//
	// *   ACTIVE: The rule is enabled.
	// *   DELETING: The rule is being deleted.
	// *   EVALUATING: The rule is triggered and is being used to monitor resource configurations.
	// *   INACTIVE: The rule is disabled.
	ConfigRuleState *string `json:"ConfigRuleState,omitempty" xml:"ConfigRuleState,omitempty"`
	// The query keyword.
	//
	// You can perform a fuzzy search by rule ID, rule name, rule description, or managed rule ID.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The page number.
	//
	// Pages start from page 1. Default value: 1
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	//
	// Valid values: 1 to 100. Minimum value: 1. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of the resources to be evaluated based on the rule.
	ResourceTypes *string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high
	// *   2: medium
	// *   3: low
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s ListConfigRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRulesRequest) GoString() string {
	return s.String()
}

func (s *ListConfigRulesRequest) SetComplianceType(v string) *ListConfigRulesRequest {
	s.ComplianceType = &v
	return s
}

func (s *ListConfigRulesRequest) SetConfigRuleName(v string) *ListConfigRulesRequest {
	s.ConfigRuleName = &v
	return s
}

func (s *ListConfigRulesRequest) SetConfigRuleState(v string) *ListConfigRulesRequest {
	s.ConfigRuleState = &v
	return s
}

func (s *ListConfigRulesRequest) SetKeyword(v string) *ListConfigRulesRequest {
	s.Keyword = &v
	return s
}

func (s *ListConfigRulesRequest) SetPageNumber(v int32) *ListConfigRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListConfigRulesRequest) SetPageSize(v int32) *ListConfigRulesRequest {
	s.PageSize = &v
	return s
}

func (s *ListConfigRulesRequest) SetResourceTypes(v string) *ListConfigRulesRequest {
	s.ResourceTypes = &v
	return s
}

func (s *ListConfigRulesRequest) SetRiskLevel(v int32) *ListConfigRulesRequest {
	s.RiskLevel = &v
	return s
}

type ListConfigRulesResponseBody struct {
	// The queried rules.
	ConfigRules *ListConfigRulesResponseBodyConfigRules `json:"ConfigRules,omitempty" xml:"ConfigRules,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListConfigRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListConfigRulesResponseBody) SetConfigRules(v *ListConfigRulesResponseBodyConfigRules) *ListConfigRulesResponseBody {
	s.ConfigRules = v
	return s
}

func (s *ListConfigRulesResponseBody) SetRequestId(v string) *ListConfigRulesResponseBody {
	s.RequestId = &v
	return s
}

type ListConfigRulesResponseBodyConfigRules struct {
	// The types of resources evaluated by the rule. Separate multiple resource types with commas (,).
	ConfigRuleList []*ListConfigRulesResponseBodyConfigRulesConfigRuleList `json:"ConfigRuleList,omitempty" xml:"ConfigRuleList,omitempty" type:"Repeated"`
	// The page number.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of rules.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListConfigRulesResponseBodyConfigRules) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRulesResponseBodyConfigRules) GoString() string {
	return s.String()
}

func (s *ListConfigRulesResponseBodyConfigRules) SetConfigRuleList(v []*ListConfigRulesResponseBodyConfigRulesConfigRuleList) *ListConfigRulesResponseBodyConfigRules {
	s.ConfigRuleList = v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRules) SetPageNumber(v int32) *ListConfigRulesResponseBodyConfigRules {
	s.PageNumber = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRules) SetPageSize(v int32) *ListConfigRulesResponseBodyConfigRules {
	s.PageSize = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRules) SetTotalCount(v int64) *ListConfigRulesResponseBodyConfigRules {
	s.TotalCount = &v
	return s
}

type ListConfigRulesResponseBodyConfigRulesConfigRuleList struct {
	AccountId          *int64                                                          `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	AutomationType     *string                                                         `json:"AutomationType,omitempty" xml:"AutomationType,omitempty"`
	Compliance         *ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance `json:"Compliance,omitempty" xml:"Compliance,omitempty" type:"Struct"`
	ConfigRuleArn      *string                                                         `json:"ConfigRuleArn,omitempty" xml:"ConfigRuleArn,omitempty"`
	ConfigRuleId       *string                                                         `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	ConfigRuleName     *string                                                         `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	ConfigRuleState    *string                                                         `json:"ConfigRuleState,omitempty" xml:"ConfigRuleState,omitempty"`
	CreateBy           *ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy   `json:"CreateBy,omitempty" xml:"CreateBy,omitempty" type:"Struct"`
	Description        *string                                                         `json:"Description,omitempty" xml:"Description,omitempty"`
	ResourceTypesScope *string                                                         `json:"ResourceTypesScope,omitempty" xml:"ResourceTypesScope,omitempty"`
	RiskLevel          *int32                                                          `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	SourceIdentifier   *string                                                         `json:"SourceIdentifier,omitempty" xml:"SourceIdentifier,omitempty"`
	SourceOwner        *string                                                         `json:"SourceOwner,omitempty" xml:"SourceOwner,omitempty"`
	Tags               []*ListConfigRulesResponseBodyConfigRulesConfigRuleListTags     `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListConfigRulesResponseBodyConfigRulesConfigRuleList) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRulesResponseBodyConfigRulesConfigRuleList) GoString() string {
	return s.String()
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleList) SetAccountId(v int64) *ListConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.AccountId = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleList) SetAutomationType(v string) *ListConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.AutomationType = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleList) SetCompliance(v *ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance) *ListConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.Compliance = v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleList) SetConfigRuleArn(v string) *ListConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.ConfigRuleArn = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleList) SetConfigRuleId(v string) *ListConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.ConfigRuleId = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleList) SetConfigRuleName(v string) *ListConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.ConfigRuleName = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleList) SetConfigRuleState(v string) *ListConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.ConfigRuleState = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleList) SetCreateBy(v *ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy) *ListConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.CreateBy = v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleList) SetDescription(v string) *ListConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.Description = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleList) SetResourceTypesScope(v string) *ListConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.ResourceTypesScope = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleList) SetRiskLevel(v int32) *ListConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.RiskLevel = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleList) SetSourceIdentifier(v string) *ListConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.SourceIdentifier = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleList) SetSourceOwner(v string) *ListConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.SourceOwner = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleList) SetTags(v []*ListConfigRulesResponseBodyConfigRulesConfigRuleListTags) *ListConfigRulesResponseBodyConfigRulesConfigRuleList {
	s.Tags = v
	return s
}

type ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance struct {
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	Count          *int32  `json:"Count,omitempty" xml:"Count,omitempty"`
}

func (s ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance) GoString() string {
	return s.String()
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance) SetComplianceType(v string) *ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance {
	s.ComplianceType = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance) SetCount(v int32) *ListConfigRulesResponseBodyConfigRulesConfigRuleListCompliance {
	s.Count = &v
	return s
}

type ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy struct {
	CompliancePackId   *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
}

func (s ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy) GoString() string {
	return s.String()
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy) SetCompliancePackId(v string) *ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy {
	s.CompliancePackId = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy) SetCompliancePackName(v string) *ListConfigRulesResponseBodyConfigRulesConfigRuleListCreateBy {
	s.CompliancePackName = &v
	return s
}

type ListConfigRulesResponseBodyConfigRulesConfigRuleListTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListConfigRulesResponseBodyConfigRulesConfigRuleListTags) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRulesResponseBodyConfigRulesConfigRuleListTags) GoString() string {
	return s.String()
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleListTags) SetKey(v string) *ListConfigRulesResponseBodyConfigRulesConfigRuleListTags {
	s.Key = &v
	return s
}

func (s *ListConfigRulesResponseBodyConfigRulesConfigRuleListTags) SetValue(v string) *ListConfigRulesResponseBodyConfigRulesConfigRuleListTags {
	s.Value = &v
	return s
}

type ListConfigRulesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListConfigRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListConfigRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListConfigRulesResponse) GoString() string {
	return s.String()
}

func (s *ListConfigRulesResponse) SetHeaders(v map[string]*string) *ListConfigRulesResponse {
	s.Headers = v
	return s
}

func (s *ListConfigRulesResponse) SetStatusCode(v int32) *ListConfigRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListConfigRulesResponse) SetBody(v *ListConfigRulesResponseBody) *ListConfigRulesResponse {
	s.Body = v
	return s
}

type ListDiscoveredResourcesRequest struct {
	// The maximum number of entries returned for a single request. Valid values: 1 to 100.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The `token` that you want to use to initiate the current request. If the response of the previous request is truncated, you can use this token to initiate another request and obtain the remaining entries.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region where the resource resides. Separate multiple region IDs with commas (,).
	Regions *string `json:"Regions,omitempty" xml:"Regions,omitempty"`
	// The status of the resource. Valid values:
	//
	// *   0: The resource is deleted.
	// *   1 (default): The resource is retained.
	ResourceDeleted *int32 `json:"ResourceDeleted,omitempty" xml:"ResourceDeleted,omitempty"`
	// The resource ID.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource. Separate multiple resource types with commas (,).
	ResourceTypes *string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty"`
}

func (s ListDiscoveredResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDiscoveredResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListDiscoveredResourcesRequest) SetMaxResults(v int32) *ListDiscoveredResourcesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListDiscoveredResourcesRequest) SetNextToken(v string) *ListDiscoveredResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListDiscoveredResourcesRequest) SetRegions(v string) *ListDiscoveredResourcesRequest {
	s.Regions = &v
	return s
}

func (s *ListDiscoveredResourcesRequest) SetResourceDeleted(v int32) *ListDiscoveredResourcesRequest {
	s.ResourceDeleted = &v
	return s
}

func (s *ListDiscoveredResourcesRequest) SetResourceId(v string) *ListDiscoveredResourcesRequest {
	s.ResourceId = &v
	return s
}

func (s *ListDiscoveredResourcesRequest) SetResourceTypes(v string) *ListDiscoveredResourcesRequest {
	s.ResourceTypes = &v
	return s
}

type ListDiscoveredResourcesResponseBody struct {
	// The resources.
	DiscoveredResourceProfiles *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles `json:"DiscoveredResourceProfiles,omitempty" xml:"DiscoveredResourceProfiles,omitempty" type:"Struct"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListDiscoveredResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDiscoveredResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListDiscoveredResourcesResponseBody) SetDiscoveredResourceProfiles(v *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles) *ListDiscoveredResourcesResponseBody {
	s.DiscoveredResourceProfiles = v
	return s
}

func (s *ListDiscoveredResourcesResponseBody) SetRequestId(v string) *ListDiscoveredResourcesResponseBody {
	s.RequestId = &v
	return s
}

type ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles struct {
	// The details of the resources.
	DiscoveredResourceProfileList []*ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList `json:"DiscoveredResourceProfileList,omitempty" xml:"DiscoveredResourceProfileList,omitempty" type:"Repeated"`
	// The maximum number of entries returned on each page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The ID of the Alibaba Cloud account to which the resource belongs.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The total number of resources.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles) String() string {
	return tea.Prettify(s)
}

func (s ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles) GoString() string {
	return s.String()
}

func (s *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles) SetDiscoveredResourceProfileList(v []*ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles {
	s.DiscoveredResourceProfileList = v
	return s
}

func (s *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles) SetMaxResults(v int32) *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles {
	s.MaxResults = &v
	return s
}

func (s *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles) SetNextToken(v string) *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles {
	s.NextToken = &v
	return s
}

func (s *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles) SetTotalCount(v int32) *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfiles {
	s.TotalCount = &v
	return s
}

type ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList struct {
	// The ID of the Alibaba Cloud account to which the resource belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The zone.
	AvailabilityZone *string `json:"AvailabilityZone,omitempty" xml:"AvailabilityZone,omitempty"`
	// The region ID.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The timestamp when the resource was created. Unit: milliseconds.
	ResourceCreationTime *int64 `json:"ResourceCreationTime,omitempty" xml:"ResourceCreationTime,omitempty"`
	// The status of the resource. Valid values:
	//
	// *   0: The resource is deleted.
	// *   1: The resource is retained.
	ResourceDeleted *int32 `json:"ResourceDeleted,omitempty" xml:"ResourceDeleted,omitempty"`
	// The resource ID.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The name of the resource.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The status of the resource. The value of this parameter varies based on the resource type and may be empty. Examples:
	//
	// *   If the value of the ResourceType parameter is ACS::ECS::Instance, the resource is an Elastic Compute Service (ECS) instance that is in a specific state. In this case, the valid values of this parameter are Running and Stopped.
	// *   If the value of the ResourceType parameter is ACS::OSS::Bucket, the resource is an Object Storage Service (OSS) bucket that is not in a specific state. In this case, this parameter is empty.
	ResourceStatus *string `json:"ResourceStatus,omitempty" xml:"ResourceStatus,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags of the resource.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The version of the resource change.
	Version *int64 `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) String() string {
	return tea.Prettify(s)
}

func (s ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) GoString() string {
	return s.String()
}

func (s *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetAccountId(v int64) *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.AccountId = &v
	return s
}

func (s *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetAvailabilityZone(v string) *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.AvailabilityZone = &v
	return s
}

func (s *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetRegion(v string) *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.Region = &v
	return s
}

func (s *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetResourceCreationTime(v int64) *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.ResourceCreationTime = &v
	return s
}

func (s *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetResourceDeleted(v int32) *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.ResourceDeleted = &v
	return s
}

func (s *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetResourceId(v string) *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.ResourceId = &v
	return s
}

func (s *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetResourceName(v string) *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.ResourceName = &v
	return s
}

func (s *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetResourceStatus(v string) *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.ResourceStatus = &v
	return s
}

func (s *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetResourceType(v string) *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.ResourceType = &v
	return s
}

func (s *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetTags(v string) *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.Tags = &v
	return s
}

func (s *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList) SetVersion(v int64) *ListDiscoveredResourcesResponseBodyDiscoveredResourceProfilesDiscoveredResourceProfileList {
	s.Version = &v
	return s
}

type ListDiscoveredResourcesResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDiscoveredResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDiscoveredResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDiscoveredResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListDiscoveredResourcesResponse) SetHeaders(v map[string]*string) *ListDiscoveredResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListDiscoveredResourcesResponse) SetStatusCode(v int32) *ListDiscoveredResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDiscoveredResourcesResponse) SetBody(v *ListDiscoveredResourcesResponseBody) *ListDiscoveredResourcesResponse {
	s.Body = v
	return s
}

type ListIntegratedServiceResponseBody struct {
	Data      []*ListIntegratedServiceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	RequestId *string                                  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListIntegratedServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListIntegratedServiceResponseBody) GoString() string {
	return s.String()
}

func (s *ListIntegratedServiceResponseBody) SetData(v []*ListIntegratedServiceResponseBodyData) *ListIntegratedServiceResponseBody {
	s.Data = v
	return s
}

func (s *ListIntegratedServiceResponseBody) SetRequestId(v string) *ListIntegratedServiceResponseBody {
	s.RequestId = &v
	return s
}

type ListIntegratedServiceResponseBodyData struct {
	ServiceCode *string `json:"ServiceCode,omitempty" xml:"ServiceCode,omitempty"`
	ServiceName *string `json:"ServiceName,omitempty" xml:"ServiceName,omitempty"`
	Status      *bool   `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListIntegratedServiceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListIntegratedServiceResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListIntegratedServiceResponseBodyData) SetServiceCode(v string) *ListIntegratedServiceResponseBodyData {
	s.ServiceCode = &v
	return s
}

func (s *ListIntegratedServiceResponseBodyData) SetServiceName(v string) *ListIntegratedServiceResponseBodyData {
	s.ServiceName = &v
	return s
}

func (s *ListIntegratedServiceResponseBodyData) SetStatus(v bool) *ListIntegratedServiceResponseBodyData {
	s.Status = &v
	return s
}

type ListIntegratedServiceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListIntegratedServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListIntegratedServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListIntegratedServiceResponse) GoString() string {
	return s.String()
}

func (s *ListIntegratedServiceResponse) SetHeaders(v map[string]*string) *ListIntegratedServiceResponse {
	s.Headers = v
	return s
}

func (s *ListIntegratedServiceResponse) SetStatusCode(v int32) *ListIntegratedServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *ListIntegratedServiceResponse) SetBody(v *ListIntegratedServiceResponseBody) *ListIntegratedServiceResponse {
	s.Body = v
	return s
}

type ListManagedRulesRequest struct {
	// The keyword that you want to use to filter managed rules.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The number of the page to return.
	//
	// Pages start from page 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	//
	// Valid values: 1 to 100. Minimum value: 1. Default value: 10
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceTypes *string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty"`
	// The risk level that you want to use to filter managed rules. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s ListManagedRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListManagedRulesRequest) GoString() string {
	return s.String()
}

func (s *ListManagedRulesRequest) SetKeyword(v string) *ListManagedRulesRequest {
	s.Keyword = &v
	return s
}

func (s *ListManagedRulesRequest) SetPageNumber(v int32) *ListManagedRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListManagedRulesRequest) SetPageSize(v int32) *ListManagedRulesRequest {
	s.PageSize = &v
	return s
}

func (s *ListManagedRulesRequest) SetResourceTypes(v string) *ListManagedRulesRequest {
	s.ResourceTypes = &v
	return s
}

func (s *ListManagedRulesRequest) SetRiskLevel(v int32) *ListManagedRulesRequest {
	s.RiskLevel = &v
	return s
}

type ListManagedRulesResponseBody struct {
	// The managed rules.
	ManagedRules *ListManagedRulesResponseBodyManagedRules `json:"ManagedRules,omitempty" xml:"ManagedRules,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListManagedRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListManagedRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListManagedRulesResponseBody) SetManagedRules(v *ListManagedRulesResponseBodyManagedRules) *ListManagedRulesResponseBody {
	s.ManagedRules = v
	return s
}

func (s *ListManagedRulesResponseBody) SetRequestId(v string) *ListManagedRulesResponseBody {
	s.RequestId = &v
	return s
}

type ListManagedRulesResponseBodyManagedRules struct {
	// The name of the remediation template.
	ManagedRuleList []*ListManagedRulesResponseBodyManagedRulesManagedRuleList `json:"ManagedRuleList,omitempty" xml:"ManagedRuleList,omitempty" type:"Repeated"`
	// The page number of the returned page. Minimum value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Valid values: 1 to 500.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of managed rules returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListManagedRulesResponseBodyManagedRules) String() string {
	return tea.Prettify(s)
}

func (s ListManagedRulesResponseBodyManagedRules) GoString() string {
	return s.String()
}

func (s *ListManagedRulesResponseBodyManagedRules) SetManagedRuleList(v []*ListManagedRulesResponseBodyManagedRulesManagedRuleList) *ListManagedRulesResponseBodyManagedRules {
	s.ManagedRuleList = v
	return s
}

func (s *ListManagedRulesResponseBodyManagedRules) SetPageNumber(v int32) *ListManagedRulesResponseBodyManagedRules {
	s.PageNumber = &v
	return s
}

func (s *ListManagedRulesResponseBodyManagedRules) SetPageSize(v int32) *ListManagedRulesResponseBodyManagedRules {
	s.PageSize = &v
	return s
}

func (s *ListManagedRulesResponseBodyManagedRules) SetTotalCount(v int64) *ListManagedRulesResponseBodyManagedRules {
	s.TotalCount = &v
	return s
}

type ListManagedRulesResponseBodyManagedRulesManagedRuleList struct {
	// The name of the managed rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The description of the managed rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The URL of the topic that describes how the managed rule remediates the incompliant configurations.
	HelpUrls *string `json:"HelpUrls,omitempty" xml:"HelpUrls,omitempty"`
	// The unique identifier of the managed rule.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The tags of the managed rule.
	Labels                        []*string `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	RemediationTemplateIdentifier *string   `json:"RemediationTemplateIdentifier,omitempty" xml:"RemediationTemplateIdentifier,omitempty"`
	RemediationTemplateName       *string   `json:"RemediationTemplateName,omitempty" xml:"RemediationTemplateName,omitempty"`
	// The risk level of the resources that do not comply with the managed rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel                 *int32                                                        `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	Scope                     *ListManagedRulesResponseBodyManagedRulesManagedRuleListScope `json:"Scope,omitempty" xml:"Scope,omitempty" type:"Struct"`
	SupportPreviewManagedRule *bool                                                         `json:"SupportPreviewManagedRule,omitempty" xml:"SupportPreviewManagedRule,omitempty"`
}

func (s ListManagedRulesResponseBodyManagedRulesManagedRuleList) String() string {
	return tea.Prettify(s)
}

func (s ListManagedRulesResponseBodyManagedRulesManagedRuleList) GoString() string {
	return s.String()
}

func (s *ListManagedRulesResponseBodyManagedRulesManagedRuleList) SetConfigRuleName(v string) *ListManagedRulesResponseBodyManagedRulesManagedRuleList {
	s.ConfigRuleName = &v
	return s
}

func (s *ListManagedRulesResponseBodyManagedRulesManagedRuleList) SetDescription(v string) *ListManagedRulesResponseBodyManagedRulesManagedRuleList {
	s.Description = &v
	return s
}

func (s *ListManagedRulesResponseBodyManagedRulesManagedRuleList) SetHelpUrls(v string) *ListManagedRulesResponseBodyManagedRulesManagedRuleList {
	s.HelpUrls = &v
	return s
}

func (s *ListManagedRulesResponseBodyManagedRulesManagedRuleList) SetIdentifier(v string) *ListManagedRulesResponseBodyManagedRulesManagedRuleList {
	s.Identifier = &v
	return s
}

func (s *ListManagedRulesResponseBodyManagedRulesManagedRuleList) SetLabels(v []*string) *ListManagedRulesResponseBodyManagedRulesManagedRuleList {
	s.Labels = v
	return s
}

func (s *ListManagedRulesResponseBodyManagedRulesManagedRuleList) SetRemediationTemplateIdentifier(v string) *ListManagedRulesResponseBodyManagedRulesManagedRuleList {
	s.RemediationTemplateIdentifier = &v
	return s
}

func (s *ListManagedRulesResponseBodyManagedRulesManagedRuleList) SetRemediationTemplateName(v string) *ListManagedRulesResponseBodyManagedRulesManagedRuleList {
	s.RemediationTemplateName = &v
	return s
}

func (s *ListManagedRulesResponseBodyManagedRulesManagedRuleList) SetRiskLevel(v int32) *ListManagedRulesResponseBodyManagedRulesManagedRuleList {
	s.RiskLevel = &v
	return s
}

func (s *ListManagedRulesResponseBodyManagedRulesManagedRuleList) SetScope(v *ListManagedRulesResponseBodyManagedRulesManagedRuleListScope) *ListManagedRulesResponseBodyManagedRulesManagedRuleList {
	s.Scope = v
	return s
}

func (s *ListManagedRulesResponseBodyManagedRulesManagedRuleList) SetSupportPreviewManagedRule(v bool) *ListManagedRulesResponseBodyManagedRulesManagedRuleList {
	s.SupportPreviewManagedRule = &v
	return s
}

type ListManagedRulesResponseBodyManagedRulesManagedRuleListScope struct {
	ComplianceResourceTypes []*string `json:"ComplianceResourceTypes,omitempty" xml:"ComplianceResourceTypes,omitempty" type:"Repeated"`
}

func (s ListManagedRulesResponseBodyManagedRulesManagedRuleListScope) String() string {
	return tea.Prettify(s)
}

func (s ListManagedRulesResponseBodyManagedRulesManagedRuleListScope) GoString() string {
	return s.String()
}

func (s *ListManagedRulesResponseBodyManagedRulesManagedRuleListScope) SetComplianceResourceTypes(v []*string) *ListManagedRulesResponseBodyManagedRulesManagedRuleListScope {
	s.ComplianceResourceTypes = v
	return s
}

type ListManagedRulesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListManagedRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListManagedRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListManagedRulesResponse) GoString() string {
	return s.String()
}

func (s *ListManagedRulesResponse) SetHeaders(v map[string]*string) *ListManagedRulesResponse {
	s.Headers = v
	return s
}

func (s *ListManagedRulesResponse) SetStatusCode(v int32) *ListManagedRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListManagedRulesResponse) SetBody(v *ListManagedRulesResponseBody) *ListManagedRulesResponse {
	s.Body = v
	return s
}

type ListPreManagedRulesRequest struct {
	// The number of the page to return.
	//
	// Pages start from page 1. Default value: 1.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	//
	// Default value: 10.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of the resource.
	ResourceTypes []*string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty" type:"Repeated"`
}

func (s ListPreManagedRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPreManagedRulesRequest) GoString() string {
	return s.String()
}

func (s *ListPreManagedRulesRequest) SetPageNumber(v int64) *ListPreManagedRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListPreManagedRulesRequest) SetPageSize(v int64) *ListPreManagedRulesRequest {
	s.PageSize = &v
	return s
}

func (s *ListPreManagedRulesRequest) SetResourceTypes(v []*string) *ListPreManagedRulesRequest {
	s.ResourceTypes = v
	return s
}

type ListPreManagedRulesShrinkRequest struct {
	// The number of the page to return.
	//
	// Pages start from page 1. Default value: 1.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	//
	// Default value: 10.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of the resource.
	ResourceTypesShrink *string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty"`
}

func (s ListPreManagedRulesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPreManagedRulesShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListPreManagedRulesShrinkRequest) SetPageNumber(v int64) *ListPreManagedRulesShrinkRequest {
	s.PageNumber = &v
	return s
}

func (s *ListPreManagedRulesShrinkRequest) SetPageSize(v int64) *ListPreManagedRulesShrinkRequest {
	s.PageSize = &v
	return s
}

func (s *ListPreManagedRulesShrinkRequest) SetResourceTypesShrink(v string) *ListPreManagedRulesShrinkRequest {
	s.ResourceTypesShrink = &v
	return s
}

type ListPreManagedRulesResponseBody struct {
	// The evaluation rules.
	ManagedRules []*ListPreManagedRulesResponseBodyManagedRules `json:"ManagedRules,omitempty" xml:"ManagedRules,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListPreManagedRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPreManagedRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListPreManagedRulesResponseBody) SetManagedRules(v []*ListPreManagedRulesResponseBodyManagedRules) *ListPreManagedRulesResponseBody {
	s.ManagedRules = v
	return s
}

func (s *ListPreManagedRulesResponseBody) SetPageNumber(v int64) *ListPreManagedRulesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListPreManagedRulesResponseBody) SetPageSize(v int64) *ListPreManagedRulesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListPreManagedRulesResponseBody) SetRequestId(v string) *ListPreManagedRulesResponseBody {
	s.RequestId = &v
	return s
}

type ListPreManagedRulesResponseBodyManagedRules struct {
	// The required input parameters of the evaluation rule.
	CompulsoryInputParameterDetails map[string]interface{} `json:"CompulsoryInputParameterDetails,omitempty" xml:"CompulsoryInputParameterDetails,omitempty"`
	// The name of the evaluation rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The description of the evaluation rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The URL of the topic that describes how the managed rule remediates the incompliant configurations.
	HelpUrls *string `json:"HelpUrls,omitempty" xml:"HelpUrls,omitempty"`
	// The identifier of the evaluation rule.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The details of the optional input parameters of the evaluation rule.
	OptionalInputParameterDetails map[string]interface{} `json:"OptionalInputParameterDetails,omitempty" xml:"OptionalInputParameterDetails,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ListPreManagedRulesResponseBodyManagedRules) String() string {
	return tea.Prettify(s)
}

func (s ListPreManagedRulesResponseBodyManagedRules) GoString() string {
	return s.String()
}

func (s *ListPreManagedRulesResponseBodyManagedRules) SetCompulsoryInputParameterDetails(v map[string]interface{}) *ListPreManagedRulesResponseBodyManagedRules {
	s.CompulsoryInputParameterDetails = v
	return s
}

func (s *ListPreManagedRulesResponseBodyManagedRules) SetConfigRuleName(v string) *ListPreManagedRulesResponseBodyManagedRules {
	s.ConfigRuleName = &v
	return s
}

func (s *ListPreManagedRulesResponseBodyManagedRules) SetDescription(v string) *ListPreManagedRulesResponseBodyManagedRules {
	s.Description = &v
	return s
}

func (s *ListPreManagedRulesResponseBodyManagedRules) SetHelpUrls(v string) *ListPreManagedRulesResponseBodyManagedRules {
	s.HelpUrls = &v
	return s
}

func (s *ListPreManagedRulesResponseBodyManagedRules) SetIdentifier(v string) *ListPreManagedRulesResponseBodyManagedRules {
	s.Identifier = &v
	return s
}

func (s *ListPreManagedRulesResponseBodyManagedRules) SetOptionalInputParameterDetails(v map[string]interface{}) *ListPreManagedRulesResponseBodyManagedRules {
	s.OptionalInputParameterDetails = v
	return s
}

func (s *ListPreManagedRulesResponseBodyManagedRules) SetResourceType(v string) *ListPreManagedRulesResponseBodyManagedRules {
	s.ResourceType = &v
	return s
}

type ListPreManagedRulesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListPreManagedRulesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListPreManagedRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPreManagedRulesResponse) GoString() string {
	return s.String()
}

func (s *ListPreManagedRulesResponse) SetHeaders(v map[string]*string) *ListPreManagedRulesResponse {
	s.Headers = v
	return s
}

func (s *ListPreManagedRulesResponse) SetStatusCode(v int32) *ListPreManagedRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPreManagedRulesResponse) SetBody(v *ListPreManagedRulesResponseBody) *ListPreManagedRulesResponse {
	s.Body = v
	return s
}

type ListRemediationExecutionsRequest struct {
	ConfigRuleId    *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	ExecutionStatus *string `json:"ExecutionStatus,omitempty" xml:"ExecutionStatus,omitempty"`
	MaxResults      *int64  `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken       *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s ListRemediationExecutionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListRemediationExecutionsRequest) GoString() string {
	return s.String()
}

func (s *ListRemediationExecutionsRequest) SetConfigRuleId(v string) *ListRemediationExecutionsRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *ListRemediationExecutionsRequest) SetExecutionStatus(v string) *ListRemediationExecutionsRequest {
	s.ExecutionStatus = &v
	return s
}

func (s *ListRemediationExecutionsRequest) SetMaxResults(v int64) *ListRemediationExecutionsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListRemediationExecutionsRequest) SetNextToken(v string) *ListRemediationExecutionsRequest {
	s.NextToken = &v
	return s
}

type ListRemediationExecutionsResponseBody struct {
	RemediationExecutionData *ListRemediationExecutionsResponseBodyRemediationExecutionData `json:"RemediationExecutionData,omitempty" xml:"RemediationExecutionData,omitempty" type:"Struct"`
	RequestId                *string                                                        `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListRemediationExecutionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListRemediationExecutionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListRemediationExecutionsResponseBody) SetRemediationExecutionData(v *ListRemediationExecutionsResponseBodyRemediationExecutionData) *ListRemediationExecutionsResponseBody {
	s.RemediationExecutionData = v
	return s
}

func (s *ListRemediationExecutionsResponseBody) SetRequestId(v string) *ListRemediationExecutionsResponseBody {
	s.RequestId = &v
	return s
}

type ListRemediationExecutionsResponseBodyRemediationExecutionData struct {
	MaxResults            *int64                                                                                `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken             *string                                                                               `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RemediationExecutions []*ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions `json:"RemediationExecutions,omitempty" xml:"RemediationExecutions,omitempty" type:"Repeated"`
}

func (s ListRemediationExecutionsResponseBodyRemediationExecutionData) String() string {
	return tea.Prettify(s)
}

func (s ListRemediationExecutionsResponseBodyRemediationExecutionData) GoString() string {
	return s.String()
}

func (s *ListRemediationExecutionsResponseBodyRemediationExecutionData) SetMaxResults(v int64) *ListRemediationExecutionsResponseBodyRemediationExecutionData {
	s.MaxResults = &v
	return s
}

func (s *ListRemediationExecutionsResponseBodyRemediationExecutionData) SetNextToken(v string) *ListRemediationExecutionsResponseBodyRemediationExecutionData {
	s.NextToken = &v
	return s
}

func (s *ListRemediationExecutionsResponseBodyRemediationExecutionData) SetRemediationExecutions(v []*ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) *ListRemediationExecutionsResponseBodyRemediationExecutionData {
	s.RemediationExecutions = v
	return s
}

type ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions struct {
	ExecutionCreateDate    *string `json:"ExecutionCreateDate,omitempty" xml:"ExecutionCreateDate,omitempty"`
	ExecutionInvocationId  *string `json:"ExecutionInvocationId,omitempty" xml:"ExecutionInvocationId,omitempty"`
	ExecutionResourceIds   *string `json:"ExecutionResourceIds,omitempty" xml:"ExecutionResourceIds,omitempty"`
	ExecutionResourceType  *string `json:"ExecutionResourceType,omitempty" xml:"ExecutionResourceType,omitempty"`
	ExecutionStatus        *string `json:"ExecutionStatus,omitempty" xml:"ExecutionStatus,omitempty"`
	ExecutionStatusMessage *string `json:"ExecutionStatusMessage,omitempty" xml:"ExecutionStatusMessage,omitempty"`
}

func (s ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) String() string {
	return tea.Prettify(s)
}

func (s ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) GoString() string {
	return s.String()
}

func (s *ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) SetExecutionCreateDate(v string) *ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions {
	s.ExecutionCreateDate = &v
	return s
}

func (s *ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) SetExecutionInvocationId(v string) *ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions {
	s.ExecutionInvocationId = &v
	return s
}

func (s *ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) SetExecutionResourceIds(v string) *ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions {
	s.ExecutionResourceIds = &v
	return s
}

func (s *ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) SetExecutionResourceType(v string) *ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions {
	s.ExecutionResourceType = &v
	return s
}

func (s *ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) SetExecutionStatus(v string) *ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions {
	s.ExecutionStatus = &v
	return s
}

func (s *ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions) SetExecutionStatusMessage(v string) *ListRemediationExecutionsResponseBodyRemediationExecutionDataRemediationExecutions {
	s.ExecutionStatusMessage = &v
	return s
}

type ListRemediationExecutionsResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListRemediationExecutionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListRemediationExecutionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListRemediationExecutionsResponse) GoString() string {
	return s.String()
}

func (s *ListRemediationExecutionsResponse) SetHeaders(v map[string]*string) *ListRemediationExecutionsResponse {
	s.Headers = v
	return s
}

func (s *ListRemediationExecutionsResponse) SetStatusCode(v int32) *ListRemediationExecutionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListRemediationExecutionsResponse) SetBody(v *ListRemediationExecutionsResponseBody) *ListRemediationExecutionsResponse {
	s.Body = v
	return s
}

type ListRemediationTemplatesRequest struct {
	// The identifier of the managed rule.
	//
	// You can call the [ListCompliancePackTemplates](~~261176~~) operation to obtain the managed rule identifier.
	ManagedRuleIdentifier *string `json:"ManagedRuleIdentifier,omitempty" xml:"ManagedRuleIdentifier,omitempty"`
	// The page number. Pages start from page 1.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values: 1 to 100.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of the remediation template. Valid value: OOS, which stands for Operation Orchestration Service.
	RemediationType *string `json:"RemediationType,omitempty" xml:"RemediationType,omitempty"`
}

func (s ListRemediationTemplatesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListRemediationTemplatesRequest) GoString() string {
	return s.String()
}

func (s *ListRemediationTemplatesRequest) SetManagedRuleIdentifier(v string) *ListRemediationTemplatesRequest {
	s.ManagedRuleIdentifier = &v
	return s
}

func (s *ListRemediationTemplatesRequest) SetPageNumber(v int64) *ListRemediationTemplatesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListRemediationTemplatesRequest) SetPageSize(v int64) *ListRemediationTemplatesRequest {
	s.PageSize = &v
	return s
}

func (s *ListRemediationTemplatesRequest) SetRemediationType(v string) *ListRemediationTemplatesRequest {
	s.RemediationType = &v
	return s
}

type ListRemediationTemplatesResponseBody struct {
	// The page number. Pages start from page 1.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values: 1 to 100.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The queried remediation templates.
	RemediationTemplates []*ListRemediationTemplatesResponseBodyRemediationTemplates `json:"RemediationTemplates,omitempty" xml:"RemediationTemplates,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of remediation templates.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListRemediationTemplatesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListRemediationTemplatesResponseBody) GoString() string {
	return s.String()
}

func (s *ListRemediationTemplatesResponseBody) SetPageNumber(v int64) *ListRemediationTemplatesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListRemediationTemplatesResponseBody) SetPageSize(v int64) *ListRemediationTemplatesResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListRemediationTemplatesResponseBody) SetRemediationTemplates(v []*ListRemediationTemplatesResponseBodyRemediationTemplates) *ListRemediationTemplatesResponseBody {
	s.RemediationTemplates = v
	return s
}

func (s *ListRemediationTemplatesResponseBody) SetRequestId(v string) *ListRemediationTemplatesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListRemediationTemplatesResponseBody) SetTotalCount(v string) *ListRemediationTemplatesResponseBody {
	s.TotalCount = &v
	return s
}

type ListRemediationTemplatesResponseBodyRemediationTemplates struct {
	// The type of the remediation template. Valid value: OOS, which indicates Operation Orchestration Service.
	RemediationType *string `json:"RemediationType,omitempty" xml:"RemediationType,omitempty"`
	// The definition of the remediation template.
	TemplateDefinition *string `json:"TemplateDefinition,omitempty" xml:"TemplateDefinition,omitempty"`
	// The description of the remediation template.
	TemplateDescription *string `json:"TemplateDescription,omitempty" xml:"TemplateDescription,omitempty"`
	// The ID of the remediation template.
	TemplateIdentifier *string `json:"TemplateIdentifier,omitempty" xml:"TemplateIdentifier,omitempty"`
	// The name of the remediation template.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
}

func (s ListRemediationTemplatesResponseBodyRemediationTemplates) String() string {
	return tea.Prettify(s)
}

func (s ListRemediationTemplatesResponseBodyRemediationTemplates) GoString() string {
	return s.String()
}

func (s *ListRemediationTemplatesResponseBodyRemediationTemplates) SetRemediationType(v string) *ListRemediationTemplatesResponseBodyRemediationTemplates {
	s.RemediationType = &v
	return s
}

func (s *ListRemediationTemplatesResponseBodyRemediationTemplates) SetTemplateDefinition(v string) *ListRemediationTemplatesResponseBodyRemediationTemplates {
	s.TemplateDefinition = &v
	return s
}

func (s *ListRemediationTemplatesResponseBodyRemediationTemplates) SetTemplateDescription(v string) *ListRemediationTemplatesResponseBodyRemediationTemplates {
	s.TemplateDescription = &v
	return s
}

func (s *ListRemediationTemplatesResponseBodyRemediationTemplates) SetTemplateIdentifier(v string) *ListRemediationTemplatesResponseBodyRemediationTemplates {
	s.TemplateIdentifier = &v
	return s
}

func (s *ListRemediationTemplatesResponseBodyRemediationTemplates) SetTemplateName(v string) *ListRemediationTemplatesResponseBodyRemediationTemplates {
	s.TemplateName = &v
	return s
}

type ListRemediationTemplatesResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListRemediationTemplatesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListRemediationTemplatesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListRemediationTemplatesResponse) GoString() string {
	return s.String()
}

func (s *ListRemediationTemplatesResponse) SetHeaders(v map[string]*string) *ListRemediationTemplatesResponse {
	s.Headers = v
	return s
}

func (s *ListRemediationTemplatesResponse) SetStatusCode(v int32) *ListRemediationTemplatesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListRemediationTemplatesResponse) SetBody(v *ListRemediationTemplatesResponseBody) *ListRemediationTemplatesResponse {
	s.Body = v
	return s
}

type ListRemediationsRequest struct {
	// The rule IDs. Separate multiple rule IDs with commas (,).
	//
	// For more information about how to obtain the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleIds *string `json:"ConfigRuleIds,omitempty" xml:"ConfigRuleIds,omitempty"`
	// The page number. Pages start from page 1.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values: 1 to 50.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListRemediationsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListRemediationsRequest) GoString() string {
	return s.String()
}

func (s *ListRemediationsRequest) SetConfigRuleIds(v string) *ListRemediationsRequest {
	s.ConfigRuleIds = &v
	return s
}

func (s *ListRemediationsRequest) SetPageNumber(v int64) *ListRemediationsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListRemediationsRequest) SetPageSize(v int64) *ListRemediationsRequest {
	s.PageSize = &v
	return s
}

type ListRemediationsResponseBody struct {
	// The page number. Pages start from page 1.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries per page. Valid values: 1 to 50.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The converted configuration of the remediation template. This parameter is returned only for an OOS remediation template.
	Remediations []*ListRemediationsResponseBodyRemediations `json:"Remediations,omitempty" xml:"Remediations,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of remediation settings.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListRemediationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListRemediationsResponseBody) GoString() string {
	return s.String()
}

func (s *ListRemediationsResponseBody) SetPageNumber(v int64) *ListRemediationsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListRemediationsResponseBody) SetPageSize(v int64) *ListRemediationsResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListRemediationsResponseBody) SetRemediations(v []*ListRemediationsResponseBodyRemediations) *ListRemediationsResponseBody {
	s.Remediations = v
	return s
}

func (s *ListRemediationsResponseBody) SetRequestId(v string) *ListRemediationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListRemediationsResponseBody) SetTotalCount(v string) *ListRemediationsResponseBody {
	s.TotalCount = &v
	return s
}

type ListRemediationsResponseBodyRemediations struct {
	// The ID of the Alibaba Cloud account to which the resource belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The rule ID.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The execution mode of the remediation template. Valid values:
	//
	// *   NON_EXECUTION: The remediation template was not executed.
	// *   AUTO_EXECUTION: The remediation template was automatically executed.
	// *   MANUAL_EXECUTION: The remediation template was manually executed.
	// *   NOT_CONFIG: The execution mode was not specified.
	InvokeType *string `json:"InvokeType,omitempty" xml:"InvokeType,omitempty"`
	// The ID of the last successful execution of the remediation template.
	LastSuccessfulInvocationId *string `json:"LastSuccessfulInvocationId,omitempty" xml:"LastSuccessfulInvocationId,omitempty"`
	// The timestamp of the last successful execution of the remediation template Unit: milliseconds.
	LastSuccessfulInvocationTime *int64 `json:"LastSuccessfulInvocationTime,omitempty" xml:"LastSuccessfulInvocationTime,omitempty"`
	// The mode of the last successful execution of the remediation template. Valid values:
	//
	// *   NON_EXECUTION: The remediation template was not executed.
	// *   AUTO_EXECUTION: The remediation template was automatically executed.
	// *   MANUAL_EXECUTION: The remediation template was manually executed.
	// *   NOT_CONFIG: The execution mode was not specified.
	LastSuccessfulInvocationType *string `json:"LastSuccessfulInvocationType,omitempty" xml:"LastSuccessfulInvocationType,omitempty"`
	// The ID of the remediation template.
	RemediationId *string `json:"RemediationId,omitempty" xml:"RemediationId,omitempty"`
	// The converted configuration of the remediation template. This parameter is available only for an OOS remediation template.
	RemediationOriginParams *string `json:"RemediationOriginParams,omitempty" xml:"RemediationOriginParams,omitempty"`
	// The source of remediation. Valid values:
	//
	// *   ALIYUN: official template.
	// *   CUSTOM: custom template.
	// *   NONE: none.
	RemediationSourceType *string `json:"RemediationSourceType,omitempty" xml:"RemediationSourceType,omitempty"`
	// The ID of the remediation template.
	RemediationTemplateId *string `json:"RemediationTemplateId,omitempty" xml:"RemediationTemplateId,omitempty"`
	// The type of the remediation template. Valid values:
	//
	// *   OOS: Operation Orchestration Service (official remediation)
	// *   FC: Function Compute (custom remediation)
	RemediationType *string `json:"RemediationType,omitempty" xml:"RemediationType,omitempty"`
}

func (s ListRemediationsResponseBodyRemediations) String() string {
	return tea.Prettify(s)
}

func (s ListRemediationsResponseBodyRemediations) GoString() string {
	return s.String()
}

func (s *ListRemediationsResponseBodyRemediations) SetAccountId(v int64) *ListRemediationsResponseBodyRemediations {
	s.AccountId = &v
	return s
}

func (s *ListRemediationsResponseBodyRemediations) SetConfigRuleId(v string) *ListRemediationsResponseBodyRemediations {
	s.ConfigRuleId = &v
	return s
}

func (s *ListRemediationsResponseBodyRemediations) SetInvokeType(v string) *ListRemediationsResponseBodyRemediations {
	s.InvokeType = &v
	return s
}

func (s *ListRemediationsResponseBodyRemediations) SetLastSuccessfulInvocationId(v string) *ListRemediationsResponseBodyRemediations {
	s.LastSuccessfulInvocationId = &v
	return s
}

func (s *ListRemediationsResponseBodyRemediations) SetLastSuccessfulInvocationTime(v int64) *ListRemediationsResponseBodyRemediations {
	s.LastSuccessfulInvocationTime = &v
	return s
}

func (s *ListRemediationsResponseBodyRemediations) SetLastSuccessfulInvocationType(v string) *ListRemediationsResponseBodyRemediations {
	s.LastSuccessfulInvocationType = &v
	return s
}

func (s *ListRemediationsResponseBodyRemediations) SetRemediationId(v string) *ListRemediationsResponseBodyRemediations {
	s.RemediationId = &v
	return s
}

func (s *ListRemediationsResponseBodyRemediations) SetRemediationOriginParams(v string) *ListRemediationsResponseBodyRemediations {
	s.RemediationOriginParams = &v
	return s
}

func (s *ListRemediationsResponseBodyRemediations) SetRemediationSourceType(v string) *ListRemediationsResponseBodyRemediations {
	s.RemediationSourceType = &v
	return s
}

func (s *ListRemediationsResponseBodyRemediations) SetRemediationTemplateId(v string) *ListRemediationsResponseBodyRemediations {
	s.RemediationTemplateId = &v
	return s
}

func (s *ListRemediationsResponseBodyRemediations) SetRemediationType(v string) *ListRemediationsResponseBodyRemediations {
	s.RemediationType = &v
	return s
}

type ListRemediationsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListRemediationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListRemediationsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListRemediationsResponse) GoString() string {
	return s.String()
}

func (s *ListRemediationsResponse) SetHeaders(v map[string]*string) *ListRemediationsResponse {
	s.Headers = v
	return s
}

func (s *ListRemediationsResponse) SetStatusCode(v int32) *ListRemediationsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListRemediationsResponse) SetBody(v *ListRemediationsResponseBody) *ListRemediationsResponse {
	s.Body = v
	return s
}

type ListResourceEvaluationResultsRequest struct {
	// The compliance evaluation result of the resources. Valid values:
	//
	// *   COMPLIANT: The resources are evaluated as compliant.
	// *   NON_COMPLIANT: The resources are evaluated as incompliant.
	// *   NOT_APPLICABLE: The rule does not apply to your resources.
	// *   INSUFFICIENT_DATA: No resource data is available.
	// *   IGNORED: The resource is ignored during compliance evaluation.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The maximum number of entries to return for a single request. Valid values: 1 to 100.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that you want to use to initiate the current request. If the response of the previous request is truncated, you can use this token to initiate another request and obtain the remaining entries.``
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region where one or more resources you want to query reside. For example, the value `global` indicates global regions and the value `cn-hangzhou` indicates the China (Hangzhou) region.
	//
	// For more information about how to obtain the ID of the region where a resource resides, see [ListDiscoveredResources](~~169620~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The ID of the resource.
	//
	// For more information about how to obtain the ID of a resource, see [ListDiscoveredResources](~~169620~~).
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource.
	//
	// For more information about how to query the type of a resource, see [ListDiscoveredResources](~~169620~~).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ListResourceEvaluationResultsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListResourceEvaluationResultsRequest) GoString() string {
	return s.String()
}

func (s *ListResourceEvaluationResultsRequest) SetComplianceType(v string) *ListResourceEvaluationResultsRequest {
	s.ComplianceType = &v
	return s
}

func (s *ListResourceEvaluationResultsRequest) SetMaxResults(v int32) *ListResourceEvaluationResultsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListResourceEvaluationResultsRequest) SetNextToken(v string) *ListResourceEvaluationResultsRequest {
	s.NextToken = &v
	return s
}

func (s *ListResourceEvaluationResultsRequest) SetRegion(v string) *ListResourceEvaluationResultsRequest {
	s.Region = &v
	return s
}

func (s *ListResourceEvaluationResultsRequest) SetResourceId(v string) *ListResourceEvaluationResultsRequest {
	s.ResourceId = &v
	return s
}

func (s *ListResourceEvaluationResultsRequest) SetResourceType(v string) *ListResourceEvaluationResultsRequest {
	s.ResourceType = &v
	return s
}

type ListResourceEvaluationResultsResponseBody struct {
	// The information about the compliance evaluation results returned.
	EvaluationResults *ListResourceEvaluationResultsResponseBodyEvaluationResults `json:"EvaluationResults,omitempty" xml:"EvaluationResults,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListResourceEvaluationResultsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListResourceEvaluationResultsResponseBody) GoString() string {
	return s.String()
}

func (s *ListResourceEvaluationResultsResponseBody) SetEvaluationResults(v *ListResourceEvaluationResultsResponseBodyEvaluationResults) *ListResourceEvaluationResultsResponseBody {
	s.EvaluationResults = v
	return s
}

func (s *ListResourceEvaluationResultsResponseBody) SetRequestId(v string) *ListResourceEvaluationResultsResponseBody {
	s.RequestId = &v
	return s
}

type ListResourceEvaluationResultsResponseBodyEvaluationResults struct {
	// The details of the compliance evaluation result.
	EvaluationResultList []*ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList `json:"EvaluationResultList,omitempty" xml:"EvaluationResultList,omitempty" type:"Repeated"`
	// The maximum number of entries to return for a single request.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that was used to initiate the next request.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s ListResourceEvaluationResultsResponseBodyEvaluationResults) String() string {
	return tea.Prettify(s)
}

func (s ListResourceEvaluationResultsResponseBodyEvaluationResults) GoString() string {
	return s.String()
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResults) SetEvaluationResultList(v []*ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) *ListResourceEvaluationResultsResponseBodyEvaluationResults {
	s.EvaluationResultList = v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResults) SetMaxResults(v int32) *ListResourceEvaluationResultsResponseBodyEvaluationResults {
	s.MaxResults = &v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResults) SetNextToken(v string) *ListResourceEvaluationResultsResponseBodyEvaluationResults {
	s.NextToken = &v
	return s
}

type ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList struct {
	// The annotation to the resource that is evaluated as incompliant. The following section describes the parameters that can be returned:
	//
	// *   `configuration`: the current resource configuration that is evaluated as incompliant by using the rule.
	// *   `desiredValue`: the expected resource configuration that is evaluated as compliant by using the rule.
	// *   `operator`: the operator that is used to compare the current configuration with the expected configuration of the resource.
	// *   `property`: the JSON path of the current configuration in the resource property struct.
	// *   `reason`: the reason why the resource is evaluated as incompliant.
	Annotation *string `json:"Annotation,omitempty" xml:"Annotation,omitempty"`
	// The compliance evaluation result of the resources. Valid values:
	//
	// *   COMPLIANT: The resources are evaluated as compliant.
	// *   NON_COMPLIANT: The resources are evaluated as incompliant.
	// *   NOT_APPLICABLE: The rule does not apply to your resources.
	// *   INSUFFICIENT_DATA: No resource data is available.
	// *   IGNORED: The resource is ignored during compliance evaluation.
	ComplianceType *string `json:"ComplianceType,omitempty" xml:"ComplianceType,omitempty"`
	// The timestamp when the rule was triggered for the compliance evaluation. Unit: milliseconds.
	ConfigRuleInvokedTimestamp *int64 `json:"ConfigRuleInvokedTimestamp,omitempty" xml:"ConfigRuleInvokedTimestamp,omitempty"`
	// The identifying information about the compliance evaluation result.
	EvaluationResultIdentifier *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier `json:"EvaluationResultIdentifier,omitempty" xml:"EvaluationResultIdentifier,omitempty" type:"Struct"`
	// The trigger type of the managed rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The managed rule is triggered by configuration changes.
	// *   ScheduledNotification: The managed rule is periodically triggered.
	InvokingEventMessageType *string `json:"InvokingEventMessageType,omitempty" xml:"InvokingEventMessageType,omitempty"`
	// Indicates whether the remediation template is enabled. Valid values:
	//
	// - true: The remediation template is enabled.
	// - false: The remediation template is disabled.
	RemediationEnabled *bool `json:"RemediationEnabled,omitempty" xml:"RemediationEnabled,omitempty"`
	// The timestamp when the compliance evaluation result was recorded. Unit: milliseconds.
	ResultRecordedTimestamp *int64 `json:"ResultRecordedTimestamp,omitempty" xml:"ResultRecordedTimestamp,omitempty"`
	// The risk level of the resources that do not comply with the rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) String() string {
	return tea.Prettify(s)
}

func (s ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) GoString() string {
	return s.String()
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetAnnotation(v string) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.Annotation = &v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetComplianceType(v string) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.ComplianceType = &v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetConfigRuleInvokedTimestamp(v int64) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.ConfigRuleInvokedTimestamp = &v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetEvaluationResultIdentifier(v *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.EvaluationResultIdentifier = v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetInvokingEventMessageType(v string) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.InvokingEventMessageType = &v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetRemediationEnabled(v bool) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.RemediationEnabled = &v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetResultRecordedTimestamp(v int64) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.ResultRecordedTimestamp = &v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList) SetRiskLevel(v int32) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultList {
	s.RiskLevel = &v
	return s
}

type ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier struct {
	// The information about the evaluated resource returned in the compliance evaluation result.
	EvaluationResultQualifier *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier `json:"EvaluationResultQualifier,omitempty" xml:"EvaluationResultQualifier,omitempty" type:"Struct"`
	// The timestamp when the compliance evaluation was performed. Unit: milliseconds.
	OrderingTimestamp *int64 `json:"OrderingTimestamp,omitempty" xml:"OrderingTimestamp,omitempty"`
}

func (s ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) String() string {
	return tea.Prettify(s)
}

func (s ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) GoString() string {
	return s.String()
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) SetEvaluationResultQualifier(v *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier {
	s.EvaluationResultQualifier = v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier) SetOrderingTimestamp(v int64) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifier {
	s.OrderingTimestamp = &v
	return s
}

type ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier struct {
	// The Alibaba Cloud Resource Name (ARN) of the rule.
	ConfigRuleArn *string `json:"ConfigRuleArn,omitempty" xml:"ConfigRuleArn,omitempty"`
	// The ID of the rule.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the monitoring rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The date from which the system automatically re-evaluates the ignored incompliant resources.
	//
	// >  If the value of this parameter is left empty, the system does not automatically re-evaluate the ignored incompliant resources. You must re-evaluate the ignored incompliant resources.
	IgnoreDate *string `json:"IgnoreDate,omitempty" xml:"IgnoreDate,omitempty"`
	// The ID of the region where your resources reside.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The name of the resource.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) String() string {
	return tea.Prettify(s)
}

func (s ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) GoString() string {
	return s.String()
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetConfigRuleArn(v string) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ConfigRuleArn = &v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetConfigRuleId(v string) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ConfigRuleId = &v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetConfigRuleName(v string) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ConfigRuleName = &v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetIgnoreDate(v string) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.IgnoreDate = &v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetRegionId(v string) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.RegionId = &v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetResourceId(v string) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ResourceId = &v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetResourceName(v string) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ResourceName = &v
	return s
}

func (s *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier) SetResourceType(v string) *ListResourceEvaluationResultsResponseBodyEvaluationResultsEvaluationResultListEvaluationResultIdentifierEvaluationResultQualifier {
	s.ResourceType = &v
	return s
}

type ListResourceEvaluationResultsResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListResourceEvaluationResultsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListResourceEvaluationResultsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListResourceEvaluationResultsResponse) GoString() string {
	return s.String()
}

func (s *ListResourceEvaluationResultsResponse) SetHeaders(v map[string]*string) *ListResourceEvaluationResultsResponse {
	s.Headers = v
	return s
}

func (s *ListResourceEvaluationResultsResponse) SetStatusCode(v int32) *ListResourceEvaluationResultsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListResourceEvaluationResultsResponse) SetBody(v *ListResourceEvaluationResultsResponseBody) *ListResourceEvaluationResultsResponse {
	s.Body = v
	return s
}

type ListResourceRelationsRequest struct {
	// The maximum number of entries to return for a single request. Valid values: 1 to 1000.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region in which the resource resides.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The type of the relationship between the resource and the object.
	//
	// Valid values:
	//
	// *   IsContained: The object is included as part of the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   IsAttachedTo: The object is added to the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   IsAssociatedIn: The object is associated with the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Contains: The actual value contains the expected value.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	RelationType *string `json:"RelationType,omitempty" xml:"RelationType,omitempty"`
	// The resource ID.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The ID of the resource that is associated with the object.
	TargetResourceId *string `json:"TargetResourceId,omitempty" xml:"TargetResourceId,omitempty"`
	// The type of the resource that is associated with the object.
	TargetResourceType *string `json:"TargetResourceType,omitempty" xml:"TargetResourceType,omitempty"`
}

func (s ListResourceRelationsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListResourceRelationsRequest) GoString() string {
	return s.String()
}

func (s *ListResourceRelationsRequest) SetMaxResults(v int32) *ListResourceRelationsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListResourceRelationsRequest) SetNextToken(v string) *ListResourceRelationsRequest {
	s.NextToken = &v
	return s
}

func (s *ListResourceRelationsRequest) SetRegion(v string) *ListResourceRelationsRequest {
	s.Region = &v
	return s
}

func (s *ListResourceRelationsRequest) SetRelationType(v string) *ListResourceRelationsRequest {
	s.RelationType = &v
	return s
}

func (s *ListResourceRelationsRequest) SetResourceId(v string) *ListResourceRelationsRequest {
	s.ResourceId = &v
	return s
}

func (s *ListResourceRelationsRequest) SetResourceType(v string) *ListResourceRelationsRequest {
	s.ResourceType = &v
	return s
}

func (s *ListResourceRelationsRequest) SetTargetResourceId(v string) *ListResourceRelationsRequest {
	s.TargetResourceId = &v
	return s
}

func (s *ListResourceRelationsRequest) SetTargetResourceType(v string) *ListResourceRelationsRequest {
	s.TargetResourceType = &v
	return s
}

type ListResourceRelationsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The result of the relationship.
	ResourceRelations *ListResourceRelationsResponseBodyResourceRelations `json:"ResourceRelations,omitempty" xml:"ResourceRelations,omitempty" type:"Struct"`
}

func (s ListResourceRelationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListResourceRelationsResponseBody) GoString() string {
	return s.String()
}

func (s *ListResourceRelationsResponseBody) SetRequestId(v string) *ListResourceRelationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListResourceRelationsResponseBody) SetResourceRelations(v *ListResourceRelationsResponseBodyResourceRelations) *ListResourceRelationsResponseBody {
	s.ResourceRelations = v
	return s
}

type ListResourceRelationsResponseBodyResourceRelations struct {
	// The maximum number of entries returned on each page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that was used to initiate the next request.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The type of the relationship between the resource and the object.
	//
	// Valid values:
	//
	// *   IsContained: The object is included as part of the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   IsAttachedTo: The object is added to the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   IsAssociatedIn: The object is associated with the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Contains: The actual value contains the expected value.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	ResourceRelationList []*ListResourceRelationsResponseBodyResourceRelationsResourceRelationList `json:"ResourceRelationList,omitempty" xml:"ResourceRelationList,omitempty" type:"Repeated"`
}

func (s ListResourceRelationsResponseBodyResourceRelations) String() string {
	return tea.Prettify(s)
}

func (s ListResourceRelationsResponseBodyResourceRelations) GoString() string {
	return s.String()
}

func (s *ListResourceRelationsResponseBodyResourceRelations) SetMaxResults(v int32) *ListResourceRelationsResponseBodyResourceRelations {
	s.MaxResults = &v
	return s
}

func (s *ListResourceRelationsResponseBodyResourceRelations) SetNextToken(v string) *ListResourceRelationsResponseBodyResourceRelations {
	s.NextToken = &v
	return s
}

func (s *ListResourceRelationsResponseBodyResourceRelations) SetResourceRelationList(v []*ListResourceRelationsResponseBodyResourceRelationsResourceRelationList) *ListResourceRelationsResponseBodyResourceRelations {
	s.ResourceRelationList = v
	return s
}

type ListResourceRelationsResponseBodyResourceRelationsResourceRelationList struct {
	// The ID of the Alibaba Cloud account to which the resource belongs.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The type of the relationship between the resource and the object.
	//
	// Valid values:
	//
	// *   IsContained: The object is included as part of the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   IsAttachedTo: The object is added to the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   IsAssociatedIn: The object is associated with the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	// *   Contains: The object contains the resource.
	//
	//     <!-- -->
	//
	//     <!-- -->
	//
	//     <!-- -->
	RelationType *string `json:"RelationType,omitempty" xml:"RelationType,omitempty"`
	// The resource ID.
	SourceResourceId *string `json:"SourceResourceId,omitempty" xml:"SourceResourceId,omitempty"`
	// The ID of the region to which the current resource belongs.
	SourceResourceRegionId *string `json:"SourceResourceRegionId,omitempty" xml:"SourceResourceRegionId,omitempty"`
	// The type of the resource.
	SourceResourceType *string `json:"SourceResourceType,omitempty" xml:"SourceResourceType,omitempty"`
	// The ID of the resource that is associated with the object.
	TargetResourceId *string `json:"TargetResourceId,omitempty" xml:"TargetResourceId,omitempty"`
	// The type of the resource that is associated with the object.
	TargetResourceType *string `json:"TargetResourceType,omitempty" xml:"TargetResourceType,omitempty"`
}

func (s ListResourceRelationsResponseBodyResourceRelationsResourceRelationList) String() string {
	return tea.Prettify(s)
}

func (s ListResourceRelationsResponseBodyResourceRelationsResourceRelationList) GoString() string {
	return s.String()
}

func (s *ListResourceRelationsResponseBodyResourceRelationsResourceRelationList) SetAccountId(v int64) *ListResourceRelationsResponseBodyResourceRelationsResourceRelationList {
	s.AccountId = &v
	return s
}

func (s *ListResourceRelationsResponseBodyResourceRelationsResourceRelationList) SetRelationType(v string) *ListResourceRelationsResponseBodyResourceRelationsResourceRelationList {
	s.RelationType = &v
	return s
}

func (s *ListResourceRelationsResponseBodyResourceRelationsResourceRelationList) SetSourceResourceId(v string) *ListResourceRelationsResponseBodyResourceRelationsResourceRelationList {
	s.SourceResourceId = &v
	return s
}

func (s *ListResourceRelationsResponseBodyResourceRelationsResourceRelationList) SetSourceResourceRegionId(v string) *ListResourceRelationsResponseBodyResourceRelationsResourceRelationList {
	s.SourceResourceRegionId = &v
	return s
}

func (s *ListResourceRelationsResponseBodyResourceRelationsResourceRelationList) SetSourceResourceType(v string) *ListResourceRelationsResponseBodyResourceRelationsResourceRelationList {
	s.SourceResourceType = &v
	return s
}

func (s *ListResourceRelationsResponseBodyResourceRelationsResourceRelationList) SetTargetResourceId(v string) *ListResourceRelationsResponseBodyResourceRelationsResourceRelationList {
	s.TargetResourceId = &v
	return s
}

func (s *ListResourceRelationsResponseBodyResourceRelationsResourceRelationList) SetTargetResourceType(v string) *ListResourceRelationsResponseBodyResourceRelationsResourceRelationList {
	s.TargetResourceType = &v
	return s
}

type ListResourceRelationsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListResourceRelationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListResourceRelationsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListResourceRelationsResponse) GoString() string {
	return s.String()
}

func (s *ListResourceRelationsResponse) SetHeaders(v map[string]*string) *ListResourceRelationsResponse {
	s.Headers = v
	return s
}

func (s *ListResourceRelationsResponse) SetStatusCode(v int32) *ListResourceRelationsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListResourceRelationsResponse) SetBody(v *ListResourceRelationsResponseBody) *ListResourceRelationsResponse {
	s.Body = v
	return s
}

type ListResourcesByAdvancedSearchRequest struct {
	Sql *string `json:"Sql,omitempty" xml:"Sql,omitempty"`
}

func (s ListResourcesByAdvancedSearchRequest) String() string {
	return tea.Prettify(s)
}

func (s ListResourcesByAdvancedSearchRequest) GoString() string {
	return s.String()
}

func (s *ListResourcesByAdvancedSearchRequest) SetSql(v string) *ListResourcesByAdvancedSearchRequest {
	s.Sql = &v
	return s
}

type ListResourcesByAdvancedSearchResponseBody struct {
	QueryResults *ListResourcesByAdvancedSearchResponseBodyQueryResults `json:"QueryResults,omitempty" xml:"QueryResults,omitempty" type:"Struct"`
	RequestId    *string                                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListResourcesByAdvancedSearchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListResourcesByAdvancedSearchResponseBody) GoString() string {
	return s.String()
}

func (s *ListResourcesByAdvancedSearchResponseBody) SetQueryResults(v *ListResourcesByAdvancedSearchResponseBodyQueryResults) *ListResourcesByAdvancedSearchResponseBody {
	s.QueryResults = v
	return s
}

func (s *ListResourcesByAdvancedSearchResponseBody) SetRequestId(v string) *ListResourcesByAdvancedSearchResponseBody {
	s.RequestId = &v
	return s
}

type ListResourcesByAdvancedSearchResponseBodyQueryResults struct {
	QueryResultList *ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList `json:"QueryResultList,omitempty" xml:"QueryResultList,omitempty" type:"Struct"`
}

func (s ListResourcesByAdvancedSearchResponseBodyQueryResults) String() string {
	return tea.Prettify(s)
}

func (s ListResourcesByAdvancedSearchResponseBodyQueryResults) GoString() string {
	return s.String()
}

func (s *ListResourcesByAdvancedSearchResponseBodyQueryResults) SetQueryResultList(v *ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList) *ListResourcesByAdvancedSearchResponseBodyQueryResults {
	s.QueryResultList = v
	return s
}

type ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList struct {
	Columns []*string     `json:"Columns,omitempty" xml:"Columns,omitempty" type:"Repeated"`
	Values  []interface{} `json:"Values,omitempty" xml:"Values,omitempty" type:"Repeated"`
}

func (s ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList) String() string {
	return tea.Prettify(s)
}

func (s ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList) GoString() string {
	return s.String()
}

func (s *ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList) SetColumns(v []*string) *ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList {
	s.Columns = v
	return s
}

func (s *ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList) SetValues(v []interface{}) *ListResourcesByAdvancedSearchResponseBodyQueryResultsQueryResultList {
	s.Values = v
	return s
}

type ListResourcesByAdvancedSearchResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListResourcesByAdvancedSearchResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListResourcesByAdvancedSearchResponse) String() string {
	return tea.Prettify(s)
}

func (s ListResourcesByAdvancedSearchResponse) GoString() string {
	return s.String()
}

func (s *ListResourcesByAdvancedSearchResponse) SetHeaders(v map[string]*string) *ListResourcesByAdvancedSearchResponse {
	s.Headers = v
	return s
}

func (s *ListResourcesByAdvancedSearchResponse) SetStatusCode(v int32) *ListResourcesByAdvancedSearchResponse {
	s.StatusCode = &v
	return s
}

func (s *ListResourcesByAdvancedSearchResponse) SetBody(v *ListResourcesByAdvancedSearchResponseBody) *ListResourcesByAdvancedSearchResponse {
	s.Body = v
	return s
}

type ListSupportedProductsRequest struct {
	MaxResults *int32  `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken  *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s ListSupportedProductsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSupportedProductsRequest) GoString() string {
	return s.String()
}

func (s *ListSupportedProductsRequest) SetMaxResults(v int32) *ListSupportedProductsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListSupportedProductsRequest) SetNextToken(v string) *ListSupportedProductsRequest {
	s.NextToken = &v
	return s
}

type ListSupportedProductsResponseBody struct {
	MaxResults *string                                      `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken  *string                                      `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	Products   []*ListSupportedProductsResponseBodyProducts `json:"Products,omitempty" xml:"Products,omitempty" type:"Repeated"`
	RequestId  *string                                      `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListSupportedProductsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSupportedProductsResponseBody) GoString() string {
	return s.String()
}

func (s *ListSupportedProductsResponseBody) SetMaxResults(v string) *ListSupportedProductsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListSupportedProductsResponseBody) SetNextToken(v string) *ListSupportedProductsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListSupportedProductsResponseBody) SetProducts(v []*ListSupportedProductsResponseBodyProducts) *ListSupportedProductsResponseBody {
	s.Products = v
	return s
}

func (s *ListSupportedProductsResponseBody) SetRequestId(v string) *ListSupportedProductsResponseBody {
	s.RequestId = &v
	return s
}

type ListSupportedProductsResponseBodyProducts struct {
	ProductNameEn    *string                                                      `json:"ProductNameEn,omitempty" xml:"ProductNameEn,omitempty"`
	ProductNameZh    *string                                                      `json:"ProductNameZh,omitempty" xml:"ProductNameZh,omitempty"`
	ResourceTypeList []*ListSupportedProductsResponseBodyProductsResourceTypeList `json:"ResourceTypeList,omitempty" xml:"ResourceTypeList,omitempty" type:"Repeated"`
}

func (s ListSupportedProductsResponseBodyProducts) String() string {
	return tea.Prettify(s)
}

func (s ListSupportedProductsResponseBodyProducts) GoString() string {
	return s.String()
}

func (s *ListSupportedProductsResponseBodyProducts) SetProductNameEn(v string) *ListSupportedProductsResponseBodyProducts {
	s.ProductNameEn = &v
	return s
}

func (s *ListSupportedProductsResponseBodyProducts) SetProductNameZh(v string) *ListSupportedProductsResponseBodyProducts {
	s.ProductNameZh = &v
	return s
}

func (s *ListSupportedProductsResponseBodyProducts) SetResourceTypeList(v []*ListSupportedProductsResponseBodyProductsResourceTypeList) *ListSupportedProductsResponseBodyProducts {
	s.ResourceTypeList = v
	return s
}

type ListSupportedProductsResponseBodyProductsResourceTypeList struct {
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	TypeNameEn   *string `json:"TypeNameEn,omitempty" xml:"TypeNameEn,omitempty"`
	TypeNameZh   *string `json:"TypeNameZh,omitempty" xml:"TypeNameZh,omitempty"`
	TypePageLink *string `json:"TypePageLink,omitempty" xml:"TypePageLink,omitempty"`
}

func (s ListSupportedProductsResponseBodyProductsResourceTypeList) String() string {
	return tea.Prettify(s)
}

func (s ListSupportedProductsResponseBodyProductsResourceTypeList) GoString() string {
	return s.String()
}

func (s *ListSupportedProductsResponseBodyProductsResourceTypeList) SetResourceType(v string) *ListSupportedProductsResponseBodyProductsResourceTypeList {
	s.ResourceType = &v
	return s
}

func (s *ListSupportedProductsResponseBodyProductsResourceTypeList) SetTypeNameEn(v string) *ListSupportedProductsResponseBodyProductsResourceTypeList {
	s.TypeNameEn = &v
	return s
}

func (s *ListSupportedProductsResponseBodyProductsResourceTypeList) SetTypeNameZh(v string) *ListSupportedProductsResponseBodyProductsResourceTypeList {
	s.TypeNameZh = &v
	return s
}

func (s *ListSupportedProductsResponseBodyProductsResourceTypeList) SetTypePageLink(v string) *ListSupportedProductsResponseBodyProductsResourceTypeList {
	s.TypePageLink = &v
	return s
}

type ListSupportedProductsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListSupportedProductsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListSupportedProductsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSupportedProductsResponse) GoString() string {
	return s.String()
}

func (s *ListSupportedProductsResponse) SetHeaders(v map[string]*string) *ListSupportedProductsResponse {
	s.Headers = v
	return s
}

func (s *ListSupportedProductsResponse) SetStatusCode(v int32) *ListSupportedProductsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSupportedProductsResponse) SetBody(v *ListSupportedProductsResponseBody) *ListSupportedProductsResponse {
	s.Body = v
	return s
}

type ListTagResourcesRequest struct {
	// The pagination token that is used in the next request to retrieve a new page of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The region ID of the tag.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource ID.
	//
	// You can add tags to up to 50 resources.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The resource type. Valid values:
	//
	// *   `ACS::Config::Rule`
	// *   `ACS::Config::AggregateConfigRule`
	// *   `ACS::Config::Aggregator`
	// *   `ACS::Config::CompliancePack`
	// *   `ACS::Config::AggregateCompliancePack`
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags of the resource.
	//
	// You can add up to 20 tags to a resource.
	Tag []*ListTagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) SetNextToken(v string) *ListTagResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesRequest) SetRegionId(v string) *ListTagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceId(v []*string) *ListTagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetTag(v []*ListTagResourcesRequestTag) *ListTagResourcesRequest {
	s.Tag = v
	return s
}

type ListTagResourcesRequestTag struct {
	// The key of the tag that is added to the resource.
	//
	// You can add up to 20 tag keys to a resource.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag that is added to the resource.
	//
	// You can add up to 20 tag values to a resource.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequestTag) SetKey(v string) *ListTagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *ListTagResourcesRequestTag) SetValue(v string) *ListTagResourcesRequestTag {
	s.Value = &v
	return s
}

type ListTagResourcesShrinkRequest struct {
	// The pagination token that is used in the next request to retrieve a new page of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The region ID of the tag.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource ID.
	//
	// You can add tags to up to 50 resources.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The resource type. Valid values:
	//
	// *   `ACS::Config::Rule`
	// *   `ACS::Config::AggregateConfigRule`
	// *   `ACS::Config::Aggregator`
	// *   `ACS::Config::CompliancePack`
	// *   `ACS::Config::AggregateCompliancePack`
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags of the resource.
	//
	// You can add up to 20 tags to a resource.
	TagShrink *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s ListTagResourcesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesShrinkRequest) SetNextToken(v string) *ListTagResourcesShrinkRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesShrinkRequest) SetRegionId(v string) *ListTagResourcesShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagResourcesShrinkRequest) SetResourceId(v []*string) *ListTagResourcesShrinkRequest {
	s.ResourceId = v
	return s
}

func (s *ListTagResourcesShrinkRequest) SetResourceType(v string) *ListTagResourcesShrinkRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesShrinkRequest) SetTagShrink(v string) *ListTagResourcesShrinkRequest {
	s.TagShrink = &v
	return s
}

type ListTagResourcesResponseBody struct {
	// The pagination token that is used in the next request to retrieve a new page of results.
	//
	// > If this parameter is left empty, no subsequent query exists.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The tags of the resource.
	TagResources *ListTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Struct"`
}

func (s ListTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) SetNextToken(v string) *ListTagResourcesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetRequestId(v string) *ListTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v *ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type ListTagResourcesResponseBodyTagResources struct {
	TagResource []*ListTagResourcesResponseBodyTagResourcesTagResource `json:"TagResource,omitempty" xml:"TagResource,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagResource(v []*ListTagResourcesResponseBodyTagResourcesTagResource) *ListTagResourcesResponseBodyTagResources {
	s.TagResource = v
	return s
}

type ListTagResourcesResponseBodyTagResourcesTagResource struct {
	// The resource ID.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The resource type.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// A tag key.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// A tag value.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceId(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceType(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagKey(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagValue(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagValue = &v
	return s
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

type PutEvaluationsRequest struct {
	// Specifies whether to enable the delete mode. Valid values:
	//
	// *   true: enables the delete mode
	// *   false (default): disables the delete mode
	//
	// > This parameter is valid only when you manually trigger or periodically trigger custom rules to evaluate resources. If you enable the delete mode, the evaluation results that are not updated during the current evaluation are automatically deleted.
	DeleteMode *bool `json:"DeleteMode,omitempty" xml:"DeleteMode,omitempty"`
	// The evaluation results.
	Evaluations *string `json:"Evaluations,omitempty" xml:"Evaluations,omitempty"`
	// The callback token. When Cloud Config triggers a custom rule to evaluate resources, the token information is sent to Function Compute as an input parameter. The token must be specified when you submit the evaluation results.
	ResultToken *string `json:"ResultToken,omitempty" xml:"ResultToken,omitempty"`
}

func (s PutEvaluationsRequest) String() string {
	return tea.Prettify(s)
}

func (s PutEvaluationsRequest) GoString() string {
	return s.String()
}

func (s *PutEvaluationsRequest) SetDeleteMode(v bool) *PutEvaluationsRequest {
	s.DeleteMode = &v
	return s
}

func (s *PutEvaluationsRequest) SetEvaluations(v string) *PutEvaluationsRequest {
	s.Evaluations = &v
	return s
}

func (s *PutEvaluationsRequest) SetResultToken(v string) *PutEvaluationsRequest {
	s.ResultToken = &v
	return s
}

type PutEvaluationsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The submission status of the evaluation results of the custom rule. Valid values:
	//
	// *   true: The evaluation results are submitted.
	// *   false: The evaluation results failed to be submitted.
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s PutEvaluationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PutEvaluationsResponseBody) GoString() string {
	return s.String()
}

func (s *PutEvaluationsResponseBody) SetRequestId(v string) *PutEvaluationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *PutEvaluationsResponseBody) SetResult(v bool) *PutEvaluationsResponseBody {
	s.Result = &v
	return s
}

type PutEvaluationsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PutEvaluationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PutEvaluationsResponse) String() string {
	return tea.Prettify(s)
}

func (s PutEvaluationsResponse) GoString() string {
	return s.String()
}

func (s *PutEvaluationsResponse) SetHeaders(v map[string]*string) *PutEvaluationsResponse {
	s.Headers = v
	return s
}

func (s *PutEvaluationsResponse) SetStatusCode(v int32) *PutEvaluationsResponse {
	s.StatusCode = &v
	return s
}

func (s *PutEvaluationsResponse) SetBody(v *PutEvaluationsResponseBody) *PutEvaluationsResponse {
	s.Body = v
	return s
}

type RevertAggregateEvaluationResultsRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the rule in the account group.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The resources that you want to re-evaluate.
	Resources []*RevertAggregateEvaluationResultsRequestResources `json:"Resources,omitempty" xml:"Resources,omitempty" type:"Repeated"`
}

func (s RevertAggregateEvaluationResultsRequest) String() string {
	return tea.Prettify(s)
}

func (s RevertAggregateEvaluationResultsRequest) GoString() string {
	return s.String()
}

func (s *RevertAggregateEvaluationResultsRequest) SetAggregatorId(v string) *RevertAggregateEvaluationResultsRequest {
	s.AggregatorId = &v
	return s
}

func (s *RevertAggregateEvaluationResultsRequest) SetConfigRuleId(v string) *RevertAggregateEvaluationResultsRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *RevertAggregateEvaluationResultsRequest) SetResources(v []*RevertAggregateEvaluationResultsRequestResources) *RevertAggregateEvaluationResultsRequest {
	s.Resources = v
	return s
}

type RevertAggregateEvaluationResultsRequestResources struct {
	// The ID of the region where the resource resides.
	//
	// For more information about how to obtain the ID of a region, see [ListAggregateDiscoveredResources](~~265983~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The ID of the Alibaba Cloud account to which the resource belongs.
	//
	// > You must specify the ID of the current management account or a member account in the account group of the management account.
	ResourceAccountId *int64 `json:"ResourceAccountId,omitempty" xml:"ResourceAccountId,omitempty"`
	// The resource ID.
	//
	// For more information about how to query the ID of a resource, see [ListAggregateDiscoveredResources](~~265983~~).
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of resource.
	//
	// For more information about how to obtain the type of a resource, see [ListAggregateDiscoveredResources](~~265983~~).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s RevertAggregateEvaluationResultsRequestResources) String() string {
	return tea.Prettify(s)
}

func (s RevertAggregateEvaluationResultsRequestResources) GoString() string {
	return s.String()
}

func (s *RevertAggregateEvaluationResultsRequestResources) SetRegion(v string) *RevertAggregateEvaluationResultsRequestResources {
	s.Region = &v
	return s
}

func (s *RevertAggregateEvaluationResultsRequestResources) SetResourceAccountId(v int64) *RevertAggregateEvaluationResultsRequestResources {
	s.ResourceAccountId = &v
	return s
}

func (s *RevertAggregateEvaluationResultsRequestResources) SetResourceId(v string) *RevertAggregateEvaluationResultsRequestResources {
	s.ResourceId = &v
	return s
}

func (s *RevertAggregateEvaluationResultsRequestResources) SetResourceType(v string) *RevertAggregateEvaluationResultsRequestResources {
	s.ResourceType = &v
	return s
}

type RevertAggregateEvaluationResultsShrinkRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the rule in the account group.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The resources that you want to re-evaluate.
	ResourcesShrink *string `json:"Resources,omitempty" xml:"Resources,omitempty"`
}

func (s RevertAggregateEvaluationResultsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s RevertAggregateEvaluationResultsShrinkRequest) GoString() string {
	return s.String()
}

func (s *RevertAggregateEvaluationResultsShrinkRequest) SetAggregatorId(v string) *RevertAggregateEvaluationResultsShrinkRequest {
	s.AggregatorId = &v
	return s
}

func (s *RevertAggregateEvaluationResultsShrinkRequest) SetConfigRuleId(v string) *RevertAggregateEvaluationResultsShrinkRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *RevertAggregateEvaluationResultsShrinkRequest) SetResourcesShrink(v string) *RevertAggregateEvaluationResultsShrinkRequest {
	s.ResourcesShrink = &v
	return s
}

type RevertAggregateEvaluationResultsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RevertAggregateEvaluationResultsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RevertAggregateEvaluationResultsResponseBody) GoString() string {
	return s.String()
}

func (s *RevertAggregateEvaluationResultsResponseBody) SetRequestId(v string) *RevertAggregateEvaluationResultsResponseBody {
	s.RequestId = &v
	return s
}

type RevertAggregateEvaluationResultsResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RevertAggregateEvaluationResultsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RevertAggregateEvaluationResultsResponse) String() string {
	return tea.Prettify(s)
}

func (s RevertAggregateEvaluationResultsResponse) GoString() string {
	return s.String()
}

func (s *RevertAggregateEvaluationResultsResponse) SetHeaders(v map[string]*string) *RevertAggregateEvaluationResultsResponse {
	s.Headers = v
	return s
}

func (s *RevertAggregateEvaluationResultsResponse) SetStatusCode(v int32) *RevertAggregateEvaluationResultsResponse {
	s.StatusCode = &v
	return s
}

func (s *RevertAggregateEvaluationResultsResponse) SetBody(v *RevertAggregateEvaluationResultsResponseBody) *RevertAggregateEvaluationResultsResponse {
	s.Body = v
	return s
}

type RevertEvaluationResultsRequest struct {
	// The rule ID.
	//
	// For more information about how to obtain the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The resources that are to be re-evaluated.
	Resources []*RevertEvaluationResultsRequestResources `json:"Resources,omitempty" xml:"Resources,omitempty" type:"Repeated"`
}

func (s RevertEvaluationResultsRequest) String() string {
	return tea.Prettify(s)
}

func (s RevertEvaluationResultsRequest) GoString() string {
	return s.String()
}

func (s *RevertEvaluationResultsRequest) SetConfigRuleId(v string) *RevertEvaluationResultsRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *RevertEvaluationResultsRequest) SetResources(v []*RevertEvaluationResultsRequestResources) *RevertEvaluationResultsRequest {
	s.Resources = v
	return s
}

type RevertEvaluationResultsRequestResources struct {
	// The ID of the region in which the resource resides.
	//
	// For more information about how to obtain the ID of the region in which a resource resides, see [ListDiscoveredResources](~~169620~~).
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The ID of the Alibaba Cloud account to which the resource belongs.
	ResourceAccountId *int64 `json:"ResourceAccountId,omitempty" xml:"ResourceAccountId,omitempty"`
	// The resource ID.
	//
	// For more information about how to obtain the ID of a resource, see [ListDiscoveredResources](~~169620~~).
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The resource type.
	//
	// For more information about how to query the type of a resource, see [ListDiscoveredResources](~~169620~~).
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s RevertEvaluationResultsRequestResources) String() string {
	return tea.Prettify(s)
}

func (s RevertEvaluationResultsRequestResources) GoString() string {
	return s.String()
}

func (s *RevertEvaluationResultsRequestResources) SetRegion(v string) *RevertEvaluationResultsRequestResources {
	s.Region = &v
	return s
}

func (s *RevertEvaluationResultsRequestResources) SetResourceAccountId(v int64) *RevertEvaluationResultsRequestResources {
	s.ResourceAccountId = &v
	return s
}

func (s *RevertEvaluationResultsRequestResources) SetResourceId(v string) *RevertEvaluationResultsRequestResources {
	s.ResourceId = &v
	return s
}

func (s *RevertEvaluationResultsRequestResources) SetResourceType(v string) *RevertEvaluationResultsRequestResources {
	s.ResourceType = &v
	return s
}

type RevertEvaluationResultsShrinkRequest struct {
	// The rule ID.
	//
	// For more information about how to obtain the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The resources that are to be re-evaluated.
	ResourcesShrink *string `json:"Resources,omitempty" xml:"Resources,omitempty"`
}

func (s RevertEvaluationResultsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s RevertEvaluationResultsShrinkRequest) GoString() string {
	return s.String()
}

func (s *RevertEvaluationResultsShrinkRequest) SetConfigRuleId(v string) *RevertEvaluationResultsShrinkRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *RevertEvaluationResultsShrinkRequest) SetResourcesShrink(v string) *RevertEvaluationResultsShrinkRequest {
	s.ResourcesShrink = &v
	return s
}

type RevertEvaluationResultsResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RevertEvaluationResultsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RevertEvaluationResultsResponseBody) GoString() string {
	return s.String()
}

func (s *RevertEvaluationResultsResponseBody) SetRequestId(v string) *RevertEvaluationResultsResponseBody {
	s.RequestId = &v
	return s
}

type RevertEvaluationResultsResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RevertEvaluationResultsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RevertEvaluationResultsResponse) String() string {
	return tea.Prettify(s)
}

func (s RevertEvaluationResultsResponse) GoString() string {
	return s.String()
}

func (s *RevertEvaluationResultsResponse) SetHeaders(v map[string]*string) *RevertEvaluationResultsResponse {
	s.Headers = v
	return s
}

func (s *RevertEvaluationResultsResponse) SetStatusCode(v int32) *RevertEvaluationResultsResponse {
	s.StatusCode = &v
	return s
}

func (s *RevertEvaluationResultsResponse) SetBody(v *RevertEvaluationResultsResponseBody) *RevertEvaluationResultsResponse {
	s.Body = v
	return s
}

type StartAggregateConfigRuleEvaluationRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListAggregateCompliancePacks](~~262059~~).
	//
	// > You must configure either the `CompliancePackId` or `ConfigRuleId` parameter.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The rule ID.
	//
	// For more information about how to obtain the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// Specifies whether to re-evaluate the ignored incompliant resource. Valid values:
	//
	// *   true: The ignored incompliant resource based on the rule are re-evaluated.
	// *   false: The ignored incompliant resource based on the rule are not re-evaluated.
	RevertEvaluation *bool `json:"RevertEvaluation,omitempty" xml:"RevertEvaluation,omitempty"`
}

func (s StartAggregateConfigRuleEvaluationRequest) String() string {
	return tea.Prettify(s)
}

func (s StartAggregateConfigRuleEvaluationRequest) GoString() string {
	return s.String()
}

func (s *StartAggregateConfigRuleEvaluationRequest) SetAggregatorId(v string) *StartAggregateConfigRuleEvaluationRequest {
	s.AggregatorId = &v
	return s
}

func (s *StartAggregateConfigRuleEvaluationRequest) SetCompliancePackId(v string) *StartAggregateConfigRuleEvaluationRequest {
	s.CompliancePackId = &v
	return s
}

func (s *StartAggregateConfigRuleEvaluationRequest) SetConfigRuleId(v string) *StartAggregateConfigRuleEvaluationRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *StartAggregateConfigRuleEvaluationRequest) SetRevertEvaluation(v bool) *StartAggregateConfigRuleEvaluationRequest {
	s.RevertEvaluation = &v
	return s
}

type StartAggregateConfigRuleEvaluationResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the involved resources were evaluated. Valid values:
	//
	// *   true: The involved resources were evaluated.
	// *   false: The involved resources were not evaluated
	Result *bool `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s StartAggregateConfigRuleEvaluationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartAggregateConfigRuleEvaluationResponseBody) GoString() string {
	return s.String()
}

func (s *StartAggregateConfigRuleEvaluationResponseBody) SetRequestId(v string) *StartAggregateConfigRuleEvaluationResponseBody {
	s.RequestId = &v
	return s
}

func (s *StartAggregateConfigRuleEvaluationResponseBody) SetResult(v bool) *StartAggregateConfigRuleEvaluationResponseBody {
	s.Result = &v
	return s
}

type StartAggregateConfigRuleEvaluationResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StartAggregateConfigRuleEvaluationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StartAggregateConfigRuleEvaluationResponse) String() string {
	return tea.Prettify(s)
}

func (s StartAggregateConfigRuleEvaluationResponse) GoString() string {
	return s.String()
}

func (s *StartAggregateConfigRuleEvaluationResponse) SetHeaders(v map[string]*string) *StartAggregateConfigRuleEvaluationResponse {
	s.Headers = v
	return s
}

func (s *StartAggregateConfigRuleEvaluationResponse) SetStatusCode(v int32) *StartAggregateConfigRuleEvaluationResponse {
	s.StatusCode = &v
	return s
}

func (s *StartAggregateConfigRuleEvaluationResponse) SetBody(v *StartAggregateConfigRuleEvaluationResponseBody) *StartAggregateConfigRuleEvaluationResponse {
	s.Body = v
	return s
}

type StartAggregateRemediationRequest struct {
	// The ID of the account group.
	//
	// For information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The rule ID.
	//
	// For more information about how to obtain the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The ID of the Alibaba Cloud account to which the resources to be remediated belong. If this parameter is left empty, non-compliant resources of all accounts in the account group are remediated.
	//
	// > You must specify the ID of the current management account or a member account in the account group of the management account.
	ResourceAccountId *int64 `json:"ResourceAccountId,omitempty" xml:"ResourceAccountId,omitempty"`
}

func (s StartAggregateRemediationRequest) String() string {
	return tea.Prettify(s)
}

func (s StartAggregateRemediationRequest) GoString() string {
	return s.String()
}

func (s *StartAggregateRemediationRequest) SetAggregatorId(v string) *StartAggregateRemediationRequest {
	s.AggregatorId = &v
	return s
}

func (s *StartAggregateRemediationRequest) SetConfigRuleId(v string) *StartAggregateRemediationRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *StartAggregateRemediationRequest) SetResourceAccountId(v int64) *StartAggregateRemediationRequest {
	s.ResourceAccountId = &v
	return s
}

type StartAggregateRemediationResponseBody struct {
	// Indicates whether the request was successful. Valid values:
	//
	// *   true
	// *   false
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StartAggregateRemediationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartAggregateRemediationResponseBody) GoString() string {
	return s.String()
}

func (s *StartAggregateRemediationResponseBody) SetData(v bool) *StartAggregateRemediationResponseBody {
	s.Data = &v
	return s
}

func (s *StartAggregateRemediationResponseBody) SetRequestId(v string) *StartAggregateRemediationResponseBody {
	s.RequestId = &v
	return s
}

type StartAggregateRemediationResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StartAggregateRemediationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StartAggregateRemediationResponse) String() string {
	return tea.Prettify(s)
}

func (s StartAggregateRemediationResponse) GoString() string {
	return s.String()
}

func (s *StartAggregateRemediationResponse) SetHeaders(v map[string]*string) *StartAggregateRemediationResponse {
	s.Headers = v
	return s
}

func (s *StartAggregateRemediationResponse) SetStatusCode(v int32) *StartAggregateRemediationResponse {
	s.StatusCode = &v
	return s
}

func (s *StartAggregateRemediationResponse) SetBody(v *StartAggregateRemediationResponseBody) *StartAggregateRemediationResponse {
	s.Body = v
	return s
}

type StartConfigRuleEvaluationRequest struct {
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	ConfigRuleId     *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	RevertEvaluation *bool   `json:"RevertEvaluation,omitempty" xml:"RevertEvaluation,omitempty"`
}

func (s StartConfigRuleEvaluationRequest) String() string {
	return tea.Prettify(s)
}

func (s StartConfigRuleEvaluationRequest) GoString() string {
	return s.String()
}

func (s *StartConfigRuleEvaluationRequest) SetCompliancePackId(v string) *StartConfigRuleEvaluationRequest {
	s.CompliancePackId = &v
	return s
}

func (s *StartConfigRuleEvaluationRequest) SetConfigRuleId(v string) *StartConfigRuleEvaluationRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *StartConfigRuleEvaluationRequest) SetRevertEvaluation(v bool) *StartConfigRuleEvaluationRequest {
	s.RevertEvaluation = &v
	return s
}

type StartConfigRuleEvaluationResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Result    *bool   `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s StartConfigRuleEvaluationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartConfigRuleEvaluationResponseBody) GoString() string {
	return s.String()
}

func (s *StartConfigRuleEvaluationResponseBody) SetRequestId(v string) *StartConfigRuleEvaluationResponseBody {
	s.RequestId = &v
	return s
}

func (s *StartConfigRuleEvaluationResponseBody) SetResult(v bool) *StartConfigRuleEvaluationResponseBody {
	s.Result = &v
	return s
}

type StartConfigRuleEvaluationResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StartConfigRuleEvaluationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StartConfigRuleEvaluationResponse) String() string {
	return tea.Prettify(s)
}

func (s StartConfigRuleEvaluationResponse) GoString() string {
	return s.String()
}

func (s *StartConfigRuleEvaluationResponse) SetHeaders(v map[string]*string) *StartConfigRuleEvaluationResponse {
	s.Headers = v
	return s
}

func (s *StartConfigRuleEvaluationResponse) SetStatusCode(v int32) *StartConfigRuleEvaluationResponse {
	s.StatusCode = &v
	return s
}

func (s *StartConfigRuleEvaluationResponse) SetBody(v *StartConfigRuleEvaluationResponseBody) *StartConfigRuleEvaluationResponse {
	s.Body = v
	return s
}

type StartConfigurationRecorderResponseBody struct {
	ConfigurationRecorder *StartConfigurationRecorderResponseBodyConfigurationRecorder `json:"ConfigurationRecorder,omitempty" xml:"ConfigurationRecorder,omitempty" type:"Struct"`
	RequestId             *string                                                      `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StartConfigurationRecorderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartConfigurationRecorderResponseBody) GoString() string {
	return s.String()
}

func (s *StartConfigurationRecorderResponseBody) SetConfigurationRecorder(v *StartConfigurationRecorderResponseBodyConfigurationRecorder) *StartConfigurationRecorderResponseBody {
	s.ConfigurationRecorder = v
	return s
}

func (s *StartConfigurationRecorderResponseBody) SetRequestId(v string) *StartConfigurationRecorderResponseBody {
	s.RequestId = &v
	return s
}

type StartConfigurationRecorderResponseBodyConfigurationRecorder struct {
	ConfigurationRecorderStatus *string   `json:"ConfigurationRecorderStatus,omitempty" xml:"ConfigurationRecorderStatus,omitempty"`
	ResourceTypes               []*string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty" type:"Repeated"`
}

func (s StartConfigurationRecorderResponseBodyConfigurationRecorder) String() string {
	return tea.Prettify(s)
}

func (s StartConfigurationRecorderResponseBodyConfigurationRecorder) GoString() string {
	return s.String()
}

func (s *StartConfigurationRecorderResponseBodyConfigurationRecorder) SetConfigurationRecorderStatus(v string) *StartConfigurationRecorderResponseBodyConfigurationRecorder {
	s.ConfigurationRecorderStatus = &v
	return s
}

func (s *StartConfigurationRecorderResponseBodyConfigurationRecorder) SetResourceTypes(v []*string) *StartConfigurationRecorderResponseBodyConfigurationRecorder {
	s.ResourceTypes = v
	return s
}

type StartConfigurationRecorderResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StartConfigurationRecorderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StartConfigurationRecorderResponse) String() string {
	return tea.Prettify(s)
}

func (s StartConfigurationRecorderResponse) GoString() string {
	return s.String()
}

func (s *StartConfigurationRecorderResponse) SetHeaders(v map[string]*string) *StartConfigurationRecorderResponse {
	s.Headers = v
	return s
}

func (s *StartConfigurationRecorderResponse) SetStatusCode(v int32) *StartConfigurationRecorderResponse {
	s.StatusCode = &v
	return s
}

func (s *StartConfigurationRecorderResponse) SetBody(v *StartConfigurationRecorderResponseBody) *StartConfigurationRecorderResponse {
	s.Body = v
	return s
}

type StartRemediationRequest struct {
	// The rule ID.
	//
	// For more information about how to obtain the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
}

func (s StartRemediationRequest) String() string {
	return tea.Prettify(s)
}

func (s StartRemediationRequest) GoString() string {
	return s.String()
}

func (s *StartRemediationRequest) SetConfigRuleId(v string) *StartRemediationRequest {
	s.ConfigRuleId = &v
	return s
}

type StartRemediationResponseBody struct {
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StartRemediationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartRemediationResponseBody) GoString() string {
	return s.String()
}

func (s *StartRemediationResponseBody) SetData(v bool) *StartRemediationResponseBody {
	s.Data = &v
	return s
}

func (s *StartRemediationResponseBody) SetRequestId(v string) *StartRemediationResponseBody {
	s.RequestId = &v
	return s
}

type StartRemediationResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StartRemediationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StartRemediationResponse) String() string {
	return tea.Prettify(s)
}

func (s StartRemediationResponse) GoString() string {
	return s.String()
}

func (s *StartRemediationResponse) SetHeaders(v map[string]*string) *StartRemediationResponse {
	s.Headers = v
	return s
}

func (s *StartRemediationResponse) SetStatusCode(v int32) *StartRemediationResponse {
	s.StatusCode = &v
	return s
}

func (s *StartRemediationResponse) SetBody(v *StartRemediationResponseBody) *StartRemediationResponse {
	s.Body = v
	return s
}

type StopConfigurationRecorderResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	StopConfigurationRecorderResult *bool `json:"StopConfigurationRecorderResult,omitempty" xml:"StopConfigurationRecorderResult,omitempty"`
}

func (s StopConfigurationRecorderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopConfigurationRecorderResponseBody) GoString() string {
	return s.String()
}

func (s *StopConfigurationRecorderResponseBody) SetRequestId(v string) *StopConfigurationRecorderResponseBody {
	s.RequestId = &v
	return s
}

func (s *StopConfigurationRecorderResponseBody) SetStopConfigurationRecorderResult(v bool) *StopConfigurationRecorderResponseBody {
	s.StopConfigurationRecorderResult = &v
	return s
}

type StopConfigurationRecorderResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StopConfigurationRecorderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StopConfigurationRecorderResponse) String() string {
	return tea.Prettify(s)
}

func (s StopConfigurationRecorderResponse) GoString() string {
	return s.String()
}

func (s *StopConfigurationRecorderResponse) SetHeaders(v map[string]*string) *StopConfigurationRecorderResponse {
	s.Headers = v
	return s
}

func (s *StopConfigurationRecorderResponse) SetStatusCode(v int32) *StopConfigurationRecorderResponse {
	s.StatusCode = &v
	return s
}

func (s *StopConfigurationRecorderResponse) SetBody(v *StopConfigurationRecorderResponseBody) *StopConfigurationRecorderResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	// The region ID of the tags.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource IDs. You can add tags to up to 50 resources.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The resource type. Valid values:
	//
	// *   `ACS::Config::Rule`
	// *   `ACS::Config::AggregateConfigRule`
	// *   `ACS::Config::Aggregator`
	// *   `ACS::Config::CompliancePack`
	// *   `ACS::Config::AggregateCompliancePack`
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag value of the resource.
	//
	// You can specify up to 20 tag values.
	Tag []*TagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetRegionId(v string) *TagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceId(v []*string) *TagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTag(v []*TagResourcesRequestTag) *TagResourcesRequest {
	s.Tag = v
	return s
}

type TagResourcesRequestTag struct {
	// The key of the tag that is added to the resource.
	//
	// You can add up to 20 tag keys to a resource.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag that is added to the resource.
	//
	// You can add up to 20 tag values to a resource.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTag) SetKey(v string) *TagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTag) SetValue(v string) *TagResourcesRequestTag {
	s.Value = &v
	return s
}

type TagResourcesShrinkRequest struct {
	// The region ID of the tags.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource IDs. You can add tags to up to 50 resources.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The resource type. Valid values:
	//
	// *   `ACS::Config::Rule`
	// *   `ACS::Config::AggregateConfigRule`
	// *   `ACS::Config::Aggregator`
	// *   `ACS::Config::CompliancePack`
	// *   `ACS::Config::AggregateCompliancePack`
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag value of the resource.
	//
	// You can specify up to 20 tag values.
	TagShrink *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
}

func (s TagResourcesShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesShrinkRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesShrinkRequest) SetRegionId(v string) *TagResourcesShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *TagResourcesShrinkRequest) SetResourceId(v []*string) *TagResourcesShrinkRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesShrinkRequest) SetResourceType(v string) *TagResourcesShrinkRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesShrinkRequest) SetTagShrink(v string) *TagResourcesShrinkRequest {
	s.TagShrink = &v
	return s
}

type TagResourcesResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type UntagResourcesRequest struct {
	// Specifies whether to remove all tags from the resource. Valid values:
	//
	// *   true: All tags are removed from the resource.
	// *   false (default): The specified tags are removed from the resource.
	All *bool `json:"All,omitempty" xml:"All,omitempty"`
	// The region ID of the tag.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The resource ID.
	//
	// You can remove tags from up to 50 resources at a time.
	ResourceId []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	// The resource type. Valid values:
	//
	// *   `ACS::Config::Rule`
	// *   `ACS::Config::AggregateConfigRule`
	// *   `ACS::Config::Aggregator`
	// *   `ACS::Config::CompliancePack`
	// *   `ACS::Config::AggregateCompliancePack`
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tags of the resource.
	TagKey []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetRegionId(v string) *UntagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceId(v []*string) *UntagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKey(v []*string) *UntagResourcesRequest {
	s.TagKey = v
	return s
}

type UntagResourcesResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

type UpdateAggregateCompliancePackRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The client token that you want to use to ensure the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.``
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListAggregateCompliancePacks](~~262059~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The name of the compliance package.
	//
	// For more information about how to obtain the name of a compliance package, see [ListAggregateCompliancePacks](~~262059~~).
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
	// The rules in the compliance package.
	//
	// If you leave this parameter empty, the rules in the compliance package remain unchanged. If you configure this parameter, Cloud Config replaces the existing rules in the compliance package with the specified rules.
	ConfigRules []*UpdateAggregateCompliancePackRequestConfigRules `json:"ConfigRules,omitempty" xml:"ConfigRules,omitempty" type:"Repeated"`
	// The description of the compliance package.
	//
	// For more information about how to obtain the description of a compliance package, see [ListCompliancePacks](~~262059~~).
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the resource that you do not want to evaluate by using the compliance package. Separate multiple resource IDs with commas (,).
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The ID of the region whose resources you want to evaluate by using the compliance package. Separate multiple region IDs with commas (,).
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group whose resources you want to evaluate by using the compliance package. Separate multiple resource group IDs with commas (,).
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The risk level of the resources that are not compliant with the rules in the compliance package. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The tag key of the resource that you want to evaluate by using the compliance package.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value of the resource that you want to evaluate by using the compliance package.
	//
	// >  You must configure the TagValueScope parameter together with the TagKeyScope parameter.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s UpdateAggregateCompliancePackRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateCompliancePackRequest) GoString() string {
	return s.String()
}

func (s *UpdateAggregateCompliancePackRequest) SetAggregatorId(v string) *UpdateAggregateCompliancePackRequest {
	s.AggregatorId = &v
	return s
}

func (s *UpdateAggregateCompliancePackRequest) SetClientToken(v string) *UpdateAggregateCompliancePackRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateAggregateCompliancePackRequest) SetCompliancePackId(v string) *UpdateAggregateCompliancePackRequest {
	s.CompliancePackId = &v
	return s
}

func (s *UpdateAggregateCompliancePackRequest) SetCompliancePackName(v string) *UpdateAggregateCompliancePackRequest {
	s.CompliancePackName = &v
	return s
}

func (s *UpdateAggregateCompliancePackRequest) SetConfigRules(v []*UpdateAggregateCompliancePackRequestConfigRules) *UpdateAggregateCompliancePackRequest {
	s.ConfigRules = v
	return s
}

func (s *UpdateAggregateCompliancePackRequest) SetDescription(v string) *UpdateAggregateCompliancePackRequest {
	s.Description = &v
	return s
}

func (s *UpdateAggregateCompliancePackRequest) SetExcludeResourceIdsScope(v string) *UpdateAggregateCompliancePackRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *UpdateAggregateCompliancePackRequest) SetRegionIdsScope(v string) *UpdateAggregateCompliancePackRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *UpdateAggregateCompliancePackRequest) SetResourceGroupIdsScope(v string) *UpdateAggregateCompliancePackRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *UpdateAggregateCompliancePackRequest) SetRiskLevel(v int32) *UpdateAggregateCompliancePackRequest {
	s.RiskLevel = &v
	return s
}

func (s *UpdateAggregateCompliancePackRequest) SetTagKeyScope(v string) *UpdateAggregateCompliancePackRequest {
	s.TagKeyScope = &v
	return s
}

func (s *UpdateAggregateCompliancePackRequest) SetTagValueScope(v string) *UpdateAggregateCompliancePackRequest {
	s.TagValueScope = &v
	return s
}

type UpdateAggregateCompliancePackRequestConfigRules struct {
	// The ID of the rule. If you configure this parameter, Cloud Config adds the rule of the specified ID to the compliance package.
	//
	// You only need to configure the `ManagedRuleIdentifier` or `ConfigRuleId` parameter. If you configure both parameters, the value of the `ConfigRuleId` parameter takes precedence. For more information about how to obtain the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The input parameter settings of the rule.
	ConfigRuleParameters []*UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters `json:"ConfigRuleParameters,omitempty" xml:"ConfigRuleParameters,omitempty" type:"Repeated"`
	// The description of the rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the managed rule. Cloud Config automatically creates a managed rule based on the specified ID and adds the rule to the compliance package.
	//
	// You only need to configure the `ManagedRuleIdentifier` or `ConfigRuleId` parameter. If you configure both parameters, the value of the `ConfigRuleId` parameter takes precedence. For more information about how to obtain the ID of a managed rule, see [ListCompliancePackTemplates](~~261176~~).
	ManagedRuleIdentifier *string `json:"ManagedRuleIdentifier,omitempty" xml:"ManagedRuleIdentifier,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s UpdateAggregateCompliancePackRequestConfigRules) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateCompliancePackRequestConfigRules) GoString() string {
	return s.String()
}

func (s *UpdateAggregateCompliancePackRequestConfigRules) SetConfigRuleId(v string) *UpdateAggregateCompliancePackRequestConfigRules {
	s.ConfigRuleId = &v
	return s
}

func (s *UpdateAggregateCompliancePackRequestConfigRules) SetConfigRuleName(v string) *UpdateAggregateCompliancePackRequestConfigRules {
	s.ConfigRuleName = &v
	return s
}

func (s *UpdateAggregateCompliancePackRequestConfigRules) SetConfigRuleParameters(v []*UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters) *UpdateAggregateCompliancePackRequestConfigRules {
	s.ConfigRuleParameters = v
	return s
}

func (s *UpdateAggregateCompliancePackRequestConfigRules) SetDescription(v string) *UpdateAggregateCompliancePackRequestConfigRules {
	s.Description = &v
	return s
}

func (s *UpdateAggregateCompliancePackRequestConfigRules) SetManagedRuleIdentifier(v string) *UpdateAggregateCompliancePackRequestConfigRules {
	s.ManagedRuleIdentifier = &v
	return s
}

func (s *UpdateAggregateCompliancePackRequestConfigRules) SetRiskLevel(v int32) *UpdateAggregateCompliancePackRequestConfigRules {
	s.RiskLevel = &v
	return s
}

type UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters struct {
	// The name of the input parameter.
	//
	// You must configure the `ParameterName` and `ParameterValue` parameters or neither of them. If the managed rule has an input parameter but no default value exists, you must configure this parameter. For more information about how to obtain the name of an input parameter for a managed rule, see [ListCompliancePackTemplates](~~261176~~).
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The value of the input parameter.
	//
	// You must configure the `ParameterName` and `ParameterValue` parameters or neither of them. If the managed rule has an input parameter but no default value exists you must configure this parameter. For more information about how to obtain the value of an input parameter for a managed rule, see [ListCompliancePackTemplates](~~261176~~).
	ParameterValue *string `json:"ParameterValue,omitempty" xml:"ParameterValue,omitempty"`
}

func (s UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters) GoString() string {
	return s.String()
}

func (s *UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters) SetParameterName(v string) *UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters {
	s.ParameterName = &v
	return s
}

func (s *UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters) SetParameterValue(v string) *UpdateAggregateCompliancePackRequestConfigRulesConfigRuleParameters {
	s.ParameterValue = &v
	return s
}

type UpdateAggregateCompliancePackShrinkRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The client token that you want to use to ensure the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.``
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListAggregateCompliancePacks](~~262059~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The name of the compliance package.
	//
	// For more information about how to obtain the name of a compliance package, see [ListAggregateCompliancePacks](~~262059~~).
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
	// The rules in the compliance package.
	//
	// If you leave this parameter empty, the rules in the compliance package remain unchanged. If you configure this parameter, Cloud Config replaces the existing rules in the compliance package with the specified rules.
	ConfigRulesShrink *string `json:"ConfigRules,omitempty" xml:"ConfigRules,omitempty"`
	// The description of the compliance package.
	//
	// For more information about how to obtain the description of a compliance package, see [ListCompliancePacks](~~262059~~).
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the resource that you do not want to evaluate by using the compliance package. Separate multiple resource IDs with commas (,).
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The ID of the region whose resources you want to evaluate by using the compliance package. Separate multiple region IDs with commas (,).
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group whose resources you want to evaluate by using the compliance package. Separate multiple resource group IDs with commas (,).
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The risk level of the resources that are not compliant with the rules in the compliance package. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The tag key of the resource that you want to evaluate by using the compliance package.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value of the resource that you want to evaluate by using the compliance package.
	//
	// >  You must configure the TagValueScope parameter together with the TagKeyScope parameter.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s UpdateAggregateCompliancePackShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateCompliancePackShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateAggregateCompliancePackShrinkRequest) SetAggregatorId(v string) *UpdateAggregateCompliancePackShrinkRequest {
	s.AggregatorId = &v
	return s
}

func (s *UpdateAggregateCompliancePackShrinkRequest) SetClientToken(v string) *UpdateAggregateCompliancePackShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateAggregateCompliancePackShrinkRequest) SetCompliancePackId(v string) *UpdateAggregateCompliancePackShrinkRequest {
	s.CompliancePackId = &v
	return s
}

func (s *UpdateAggregateCompliancePackShrinkRequest) SetCompliancePackName(v string) *UpdateAggregateCompliancePackShrinkRequest {
	s.CompliancePackName = &v
	return s
}

func (s *UpdateAggregateCompliancePackShrinkRequest) SetConfigRulesShrink(v string) *UpdateAggregateCompliancePackShrinkRequest {
	s.ConfigRulesShrink = &v
	return s
}

func (s *UpdateAggregateCompliancePackShrinkRequest) SetDescription(v string) *UpdateAggregateCompliancePackShrinkRequest {
	s.Description = &v
	return s
}

func (s *UpdateAggregateCompliancePackShrinkRequest) SetExcludeResourceIdsScope(v string) *UpdateAggregateCompliancePackShrinkRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *UpdateAggregateCompliancePackShrinkRequest) SetRegionIdsScope(v string) *UpdateAggregateCompliancePackShrinkRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *UpdateAggregateCompliancePackShrinkRequest) SetResourceGroupIdsScope(v string) *UpdateAggregateCompliancePackShrinkRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *UpdateAggregateCompliancePackShrinkRequest) SetRiskLevel(v int32) *UpdateAggregateCompliancePackShrinkRequest {
	s.RiskLevel = &v
	return s
}

func (s *UpdateAggregateCompliancePackShrinkRequest) SetTagKeyScope(v string) *UpdateAggregateCompliancePackShrinkRequest {
	s.TagKeyScope = &v
	return s
}

func (s *UpdateAggregateCompliancePackShrinkRequest) SetTagValueScope(v string) *UpdateAggregateCompliancePackShrinkRequest {
	s.TagValueScope = &v
	return s
}

type UpdateAggregateCompliancePackResponseBody struct {
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAggregateCompliancePackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateCompliancePackResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAggregateCompliancePackResponseBody) SetCompliancePackId(v string) *UpdateAggregateCompliancePackResponseBody {
	s.CompliancePackId = &v
	return s
}

func (s *UpdateAggregateCompliancePackResponseBody) SetRequestId(v string) *UpdateAggregateCompliancePackResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAggregateCompliancePackResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAggregateCompliancePackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAggregateCompliancePackResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateCompliancePackResponse) GoString() string {
	return s.String()
}

func (s *UpdateAggregateCompliancePackResponse) SetHeaders(v map[string]*string) *UpdateAggregateCompliancePackResponse {
	s.Headers = v
	return s
}

func (s *UpdateAggregateCompliancePackResponse) SetStatusCode(v int32) *UpdateAggregateCompliancePackResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAggregateCompliancePackResponse) SetBody(v *UpdateAggregateCompliancePackResponseBody) *UpdateAggregateCompliancePackResponse {
	s.Body = v
	return s
}

type UpdateAggregateConfigDeliveryChannelRequest struct {
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of the account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The `token` can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [Ensure idempotence](~~25693~~)
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to deliver resource change logs. If you set this parameter to true, Cloud Config delivers resource change logs to OSS, Log Service, or MNS when the configurations of the resources change. Valid values:
	//
	// *   true: Cloud Config delivers resource change logs.
	// *   false (default): Cloud Config does not deliver resource change logs.
	//
	// > This parameter is available for delivery channels of the OSS, SLS, and MNS types.
	ConfigurationItemChangeNotification *bool `json:"ConfigurationItemChangeNotification,omitempty" xml:"ConfigurationItemChangeNotification,omitempty"`
	// Specifies whether to deliver scheduled resource snapshots. Cloud Config delivers scheduled resource snapshots at `04:00Z` and `16:00Z` to OSS, MNS, or Log Service every day. The time is displayed in UTC. Valid values:
	//
	// *   true: Cloud Config delivers scheduled resource snapshots.
	// *   false (default): Cloud Config does not deliver scheduled resource snapshots.
	ConfigurationSnapshot *bool `json:"ConfigurationSnapshot,omitempty" xml:"ConfigurationSnapshot,omitempty"`
	// The rule that is attached to the delivery channel. This parameter is available when you deliver data of all types to MNS or deliver snapshots to Log Service.
	//
	// *   If the value of the DeliveryChannelType parameter is MNS, take note of the following settings of the lowest risk level and resource types of the events to which you subscribed:
	//
	//     *   The lowest risk level of the events to which you want to subscribe is in the following format: `{"filterType":"RuleRiskLevel","value":"1","multiple":false}`.
	//
	//         The `value` field indicates the lowest risk level of the events to which you subscribed. Valid values: 1, 2, and 3, where 1 indicates the high risk level, 2 indicates the medium risk level, and 3 indicates the low risk level.
	//
	//     *   The setting of the resource types of the events to which you want to subscribe is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//         The `values` field indicates the resource types of the events to which you subscribed. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	//
	// *   If you set the DeliveryChannelType parameter to SLS, the setting of the resource types of the snapshots to which you want to deliver is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//     The `values` field specifies the resource types of the snapshots to which you want to deliver. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	DeliveryChannelCondition *string `json:"DeliveryChannelCondition,omitempty" xml:"DeliveryChannelCondition,omitempty"`
	// The ID of the delivery channel.
	//
	// For more information about how to obtain the ID of a delivery channel, see [ListAggregateConfigDeliveryChannels](~~429842~~).
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
	// The name of the delivery channel.
	DeliveryChannelName *string `json:"DeliveryChannelName,omitempty" xml:"DeliveryChannelName,omitempty"`
	// The ARN of the delivery destination. Valid values:
	//
	// *   `acs:oss:{RegionId}:{accountId}:{bucketName}` if your delivery destination is an OSS bucket. Example: `acs:oss:cn-shanghai:100931896542****:new-bucket`.
	// *   `acs:mns:{RegionId}:{accountId}:/topics/{topicName}` if your delivery destination is an MNS topic. Example: `acs:mns:cn-shanghai:100931896542****:/topics/topic1`.
	// *   `acs:log:{RegionId}:{accountId}:project/{projectName}/logstore/{logstoreName}` if your delivery destination is a Log Service Logstore. Example: `acs:log:cn-shanghai:100931896542****:project/project1/logstore/logstore1`.
	DeliveryChannelTargetArn *string `json:"DeliveryChannelTargetArn,omitempty" xml:"DeliveryChannelTargetArn,omitempty"`
	// The time when Cloud Config delivers scheduled resources snapshots every day.
	//
	// Format: `HH:mmZ`. This time is displayed in UTC.
	//
	// > When you enable the scheduled resource delivery feature, you can specify a custom delivery time for this parameter. If you do not configure this parameter, Cloud Config automatically delivers scheduled resource snapshots at `04:00Z` and `16:00Z` every day.
	DeliverySnapshotTime *string `json:"DeliverySnapshotTime,omitempty" xml:"DeliverySnapshotTime,omitempty"`
	// The description of the delivery channel.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to deliver resource non-compliance events. If you set this parameter to true, Cloud Config delivers resource non-compliance events to Log Service or MNS when resources are considered non-compliant. Valid values:
	//
	// *   true: Cloud Config delivers resource non-compliance events.
	// *   false (default): Cloud Config does not deliver resource non-compliance events.
	//
	// > This parameter is available only for delivery channels of the SLS or MNS type.
	NonCompliantNotification *bool `json:"NonCompliantNotification,omitempty" xml:"NonCompliantNotification,omitempty"`
	// The ARN of the OSS bucket to which the delivered data is transferred when the size of the data exceeds the specified upper limit of the delivery channel. Format: `acs:oss:{RegionId}:{accountId}:{bucketName}`.
	//
	// If you do not configure this parameter, Cloud Config delivers only summary data.
	//
	// > This parameter is available only for delivery channels of the SLS or MNS type. The upper limit on the storage size of delivery channels of the SLS type is 1 MB, and the upper limit on the storage size of delivery channels of the MNS type is 64 KB.
	OversizedDataOSSTargetArn *string `json:"OversizedDataOSSTargetArn,omitempty" xml:"OversizedDataOSSTargetArn,omitempty"`
	// Specifies whether to enable the delivery channel. Valid values:
	//
	// *   0: The delivery channel is disabled. Cloud Config retains the most recent delivery configuration and stops resource data delivery.
	// *   1 (default): The delivery channel is enabled.
	Status *int64 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateAggregateConfigDeliveryChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateConfigDeliveryChannelRequest) GoString() string {
	return s.String()
}

func (s *UpdateAggregateConfigDeliveryChannelRequest) SetAggregatorId(v string) *UpdateAggregateConfigDeliveryChannelRequest {
	s.AggregatorId = &v
	return s
}

func (s *UpdateAggregateConfigDeliveryChannelRequest) SetClientToken(v string) *UpdateAggregateConfigDeliveryChannelRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateAggregateConfigDeliveryChannelRequest) SetConfigurationItemChangeNotification(v bool) *UpdateAggregateConfigDeliveryChannelRequest {
	s.ConfigurationItemChangeNotification = &v
	return s
}

func (s *UpdateAggregateConfigDeliveryChannelRequest) SetConfigurationSnapshot(v bool) *UpdateAggregateConfigDeliveryChannelRequest {
	s.ConfigurationSnapshot = &v
	return s
}

func (s *UpdateAggregateConfigDeliveryChannelRequest) SetDeliveryChannelCondition(v string) *UpdateAggregateConfigDeliveryChannelRequest {
	s.DeliveryChannelCondition = &v
	return s
}

func (s *UpdateAggregateConfigDeliveryChannelRequest) SetDeliveryChannelId(v string) *UpdateAggregateConfigDeliveryChannelRequest {
	s.DeliveryChannelId = &v
	return s
}

func (s *UpdateAggregateConfigDeliveryChannelRequest) SetDeliveryChannelName(v string) *UpdateAggregateConfigDeliveryChannelRequest {
	s.DeliveryChannelName = &v
	return s
}

func (s *UpdateAggregateConfigDeliveryChannelRequest) SetDeliveryChannelTargetArn(v string) *UpdateAggregateConfigDeliveryChannelRequest {
	s.DeliveryChannelTargetArn = &v
	return s
}

func (s *UpdateAggregateConfigDeliveryChannelRequest) SetDeliverySnapshotTime(v string) *UpdateAggregateConfigDeliveryChannelRequest {
	s.DeliverySnapshotTime = &v
	return s
}

func (s *UpdateAggregateConfigDeliveryChannelRequest) SetDescription(v string) *UpdateAggregateConfigDeliveryChannelRequest {
	s.Description = &v
	return s
}

func (s *UpdateAggregateConfigDeliveryChannelRequest) SetNonCompliantNotification(v bool) *UpdateAggregateConfigDeliveryChannelRequest {
	s.NonCompliantNotification = &v
	return s
}

func (s *UpdateAggregateConfigDeliveryChannelRequest) SetOversizedDataOSSTargetArn(v string) *UpdateAggregateConfigDeliveryChannelRequest {
	s.OversizedDataOSSTargetArn = &v
	return s
}

func (s *UpdateAggregateConfigDeliveryChannelRequest) SetStatus(v int64) *UpdateAggregateConfigDeliveryChannelRequest {
	s.Status = &v
	return s
}

type UpdateAggregateConfigDeliveryChannelResponseBody struct {
	// The ID of the delivery channel.
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAggregateConfigDeliveryChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateConfigDeliveryChannelResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAggregateConfigDeliveryChannelResponseBody) SetDeliveryChannelId(v string) *UpdateAggregateConfigDeliveryChannelResponseBody {
	s.DeliveryChannelId = &v
	return s
}

func (s *UpdateAggregateConfigDeliveryChannelResponseBody) SetRequestId(v string) *UpdateAggregateConfigDeliveryChannelResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAggregateConfigDeliveryChannelResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAggregateConfigDeliveryChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAggregateConfigDeliveryChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateConfigDeliveryChannelResponse) GoString() string {
	return s.String()
}

func (s *UpdateAggregateConfigDeliveryChannelResponse) SetHeaders(v map[string]*string) *UpdateAggregateConfigDeliveryChannelResponse {
	s.Headers = v
	return s
}

func (s *UpdateAggregateConfigDeliveryChannelResponse) SetStatusCode(v int32) *UpdateAggregateConfigDeliveryChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAggregateConfigDeliveryChannelResponse) SetBody(v *UpdateAggregateConfigDeliveryChannelResponseBody) *UpdateAggregateConfigDeliveryChannelResponse {
	s.Body = v
	return s
}

type UpdateAggregateConfigRuleRequest struct {
	// The ID of the account group.
	//
	// For more information about how to query the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the rule.
	//
	// For more information about how to query the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the rule.
	//
	// For more information about how to query the name of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The rule is triggered by configuration changes.
	// *   ScheduledNotification: The rule is periodically triggered.
	//
	// >  This parameter applies only to a custom rule.
	ConfigRuleTriggerTypes *string `json:"ConfigRuleTriggerTypes,omitempty" xml:"ConfigRuleTriggerTypes,omitempty"`
	// The description of the rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the member account to which the rule does not apply, which means that the resources within the member account are not evaluated based on the rule. Separate multiple member account IDs with commas (,).
	//
	// >  This parameter applies only to a managed rule.
	ExcludeAccountIdsScope *string `json:"ExcludeAccountIdsScope,omitempty" xml:"ExcludeAccountIdsScope,omitempty"`
	// The ID of the resource directory to which the rule does not apply, which means that the resources within member accounts in the resource directory are not evaluated based on the rule. Separate multiple resource directory IDs with commas (,).
	//
	// >
	// *   This parameter applies only to a rule of a global account group.
	// *   This parameter applies only to a managed rule.
	ExcludeFolderIdsScope *string `json:"ExcludeFolderIdsScope,omitempty" xml:"ExcludeFolderIdsScope,omitempty"`
	// The ID of the resource to be excluded from the compliance evaluations performed by the rule. Separate multiple resource IDs with commas (,).
	//
	// >  This parameter applies only to a managed rule.
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The ID of the resource directory to which the rule applies, which means that the resources within member accounts in the resource directory are evaluated based on the rule.
	//
	// >
	// *   This parameter applies only to a rule of a global account group.
	// *   This parameter applies only to a managed rule.
	FolderIdsScope *string `json:"FolderIdsScope,omitempty" xml:"FolderIdsScope,omitempty"`
	// The input parameters of the rule.
	InputParameters map[string]interface{} `json:"InputParameters,omitempty" xml:"InputParameters,omitempty"`
	// The intervals at which the rule is triggered. Valid values:
	//
	// *   One_Hour: 1 hour
	// *   Three_Hours: 3 hours
	// *   Six_Hours: 6 hours
	// *   Twelve_Hours: 12 hours
	// *   TwentyFour_Hours: 24 hours
	//
	// >  This parameter is required if the `ConfigRuleTriggerTypes` parameter is set to `ScheduledNotification`.
	MaximumExecutionFrequency *string `json:"MaximumExecutionFrequency,omitempty" xml:"MaximumExecutionFrequency,omitempty"`
	// The ID of the region to which the rule applies. Separate multiple region IDs with commas (,).
	//
	// >  This parameter applies only to a managed rule.
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group to which the rule applies. Separate multiple resource group IDs with commas (,).
	//
	// >  This parameter applies only to a managed rule.
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The type of the resource to be evaluated by the rule. Separate multiple resource types with commas (,).
	ResourceTypesScope []*string `json:"ResourceTypesScope,omitempty" xml:"ResourceTypesScope,omitempty" type:"Repeated"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The logical relationship among the tag keys if you specify multiple tag keys for the `TagKeyScope` parameter. For example, if you set the `TagKeyScope` parameter to `ECS,OSS` and the TagKeyLogicScope parameter to `AND`, the rule applies to resources with both the `ECS` and `OSS` tag keys. Valid values:
	//
	// *   AND
	// *   OR
	TagKeyLogicScope *string `json:"TagKeyLogicScope,omitempty" xml:"TagKeyLogicScope,omitempty"`
	// The tag key used to filter resources. The rule applies only to the resources with the specified tag key.
	//
	// >  This parameter applies only to a managed rule. You must set the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value used to filter resources. The rule applies only to the resources with the specified tag value.
	//
	// >  This parameter applies only to a managed rule. You must set the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s UpdateAggregateConfigRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateConfigRuleRequest) GoString() string {
	return s.String()
}

func (s *UpdateAggregateConfigRuleRequest) SetAggregatorId(v string) *UpdateAggregateConfigRuleRequest {
	s.AggregatorId = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetClientToken(v string) *UpdateAggregateConfigRuleRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetConfigRuleId(v string) *UpdateAggregateConfigRuleRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetConfigRuleName(v string) *UpdateAggregateConfigRuleRequest {
	s.ConfigRuleName = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetConfigRuleTriggerTypes(v string) *UpdateAggregateConfigRuleRequest {
	s.ConfigRuleTriggerTypes = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetDescription(v string) *UpdateAggregateConfigRuleRequest {
	s.Description = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetExcludeAccountIdsScope(v string) *UpdateAggregateConfigRuleRequest {
	s.ExcludeAccountIdsScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetExcludeFolderIdsScope(v string) *UpdateAggregateConfigRuleRequest {
	s.ExcludeFolderIdsScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetExcludeResourceIdsScope(v string) *UpdateAggregateConfigRuleRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetFolderIdsScope(v string) *UpdateAggregateConfigRuleRequest {
	s.FolderIdsScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetInputParameters(v map[string]interface{}) *UpdateAggregateConfigRuleRequest {
	s.InputParameters = v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetMaximumExecutionFrequency(v string) *UpdateAggregateConfigRuleRequest {
	s.MaximumExecutionFrequency = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetRegionIdsScope(v string) *UpdateAggregateConfigRuleRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetResourceGroupIdsScope(v string) *UpdateAggregateConfigRuleRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetResourceTypesScope(v []*string) *UpdateAggregateConfigRuleRequest {
	s.ResourceTypesScope = v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetRiskLevel(v int32) *UpdateAggregateConfigRuleRequest {
	s.RiskLevel = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetTagKeyLogicScope(v string) *UpdateAggregateConfigRuleRequest {
	s.TagKeyLogicScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetTagKeyScope(v string) *UpdateAggregateConfigRuleRequest {
	s.TagKeyScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleRequest) SetTagValueScope(v string) *UpdateAggregateConfigRuleRequest {
	s.TagValueScope = &v
	return s
}

type UpdateAggregateConfigRuleShrinkRequest struct {
	// The ID of the account group.
	//
	// For more information about how to query the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the rule.
	//
	// For more information about how to query the ID of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the rule.
	//
	// For more information about how to query the name of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The rule is triggered by configuration changes.
	// *   ScheduledNotification: The rule is periodically triggered.
	//
	// >  This parameter applies only to a custom rule.
	ConfigRuleTriggerTypes *string `json:"ConfigRuleTriggerTypes,omitempty" xml:"ConfigRuleTriggerTypes,omitempty"`
	// The description of the rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the member account to which the rule does not apply, which means that the resources within the member account are not evaluated based on the rule. Separate multiple member account IDs with commas (,).
	//
	// >  This parameter applies only to a managed rule.
	ExcludeAccountIdsScope *string `json:"ExcludeAccountIdsScope,omitempty" xml:"ExcludeAccountIdsScope,omitempty"`
	// The ID of the resource directory to which the rule does not apply, which means that the resources within member accounts in the resource directory are not evaluated based on the rule. Separate multiple resource directory IDs with commas (,).
	//
	// >
	// *   This parameter applies only to a rule of a global account group.
	// *   This parameter applies only to a managed rule.
	ExcludeFolderIdsScope *string `json:"ExcludeFolderIdsScope,omitempty" xml:"ExcludeFolderIdsScope,omitempty"`
	// The ID of the resource to be excluded from the compliance evaluations performed by the rule. Separate multiple resource IDs with commas (,).
	//
	// >  This parameter applies only to a managed rule.
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The ID of the resource directory to which the rule applies, which means that the resources within member accounts in the resource directory are evaluated based on the rule.
	//
	// >
	// *   This parameter applies only to a rule of a global account group.
	// *   This parameter applies only to a managed rule.
	FolderIdsScope *string `json:"FolderIdsScope,omitempty" xml:"FolderIdsScope,omitempty"`
	// The input parameters of the rule.
	InputParametersShrink *string `json:"InputParameters,omitempty" xml:"InputParameters,omitempty"`
	// The intervals at which the rule is triggered. Valid values:
	//
	// *   One_Hour: 1 hour
	// *   Three_Hours: 3 hours
	// *   Six_Hours: 6 hours
	// *   Twelve_Hours: 12 hours
	// *   TwentyFour_Hours: 24 hours
	//
	// >  This parameter is required if the `ConfigRuleTriggerTypes` parameter is set to `ScheduledNotification`.
	MaximumExecutionFrequency *string `json:"MaximumExecutionFrequency,omitempty" xml:"MaximumExecutionFrequency,omitempty"`
	// The ID of the region to which the rule applies. Separate multiple region IDs with commas (,).
	//
	// >  This parameter applies only to a managed rule.
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group to which the rule applies. Separate multiple resource group IDs with commas (,).
	//
	// >  This parameter applies only to a managed rule.
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The type of the resource to be evaluated by the rule. Separate multiple resource types with commas (,).
	ResourceTypesScopeShrink *string `json:"ResourceTypesScope,omitempty" xml:"ResourceTypesScope,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The logical relationship among the tag keys if you specify multiple tag keys for the `TagKeyScope` parameter. For example, if you set the `TagKeyScope` parameter to `ECS,OSS` and the TagKeyLogicScope parameter to `AND`, the rule applies to resources with both the `ECS` and `OSS` tag keys. Valid values:
	//
	// *   AND
	// *   OR
	TagKeyLogicScope *string `json:"TagKeyLogicScope,omitempty" xml:"TagKeyLogicScope,omitempty"`
	// The tag key used to filter resources. The rule applies only to the resources with the specified tag key.
	//
	// >  This parameter applies only to a managed rule. You must set the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value used to filter resources. The rule applies only to the resources with the specified tag value.
	//
	// >  This parameter applies only to a managed rule. You must set the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s UpdateAggregateConfigRuleShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateConfigRuleShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetAggregatorId(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.AggregatorId = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetClientToken(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetConfigRuleId(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetConfigRuleName(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.ConfigRuleName = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetConfigRuleTriggerTypes(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.ConfigRuleTriggerTypes = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetDescription(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.Description = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetExcludeAccountIdsScope(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.ExcludeAccountIdsScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetExcludeFolderIdsScope(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.ExcludeFolderIdsScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetExcludeResourceIdsScope(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetFolderIdsScope(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.FolderIdsScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetInputParametersShrink(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.InputParametersShrink = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetMaximumExecutionFrequency(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.MaximumExecutionFrequency = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetRegionIdsScope(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetResourceGroupIdsScope(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetResourceTypesScopeShrink(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.ResourceTypesScopeShrink = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetRiskLevel(v int32) *UpdateAggregateConfigRuleShrinkRequest {
	s.RiskLevel = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetTagKeyLogicScope(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.TagKeyLogicScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetTagKeyScope(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.TagKeyScope = &v
	return s
}

func (s *UpdateAggregateConfigRuleShrinkRequest) SetTagValueScope(v string) *UpdateAggregateConfigRuleShrinkRequest {
	s.TagValueScope = &v
	return s
}

type UpdateAggregateConfigRuleResponseBody struct {
	// The ID of the rule.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAggregateConfigRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateConfigRuleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAggregateConfigRuleResponseBody) SetConfigRuleId(v string) *UpdateAggregateConfigRuleResponseBody {
	s.ConfigRuleId = &v
	return s
}

func (s *UpdateAggregateConfigRuleResponseBody) SetRequestId(v string) *UpdateAggregateConfigRuleResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAggregateConfigRuleResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAggregateConfigRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAggregateConfigRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateConfigRuleResponse) GoString() string {
	return s.String()
}

func (s *UpdateAggregateConfigRuleResponse) SetHeaders(v map[string]*string) *UpdateAggregateConfigRuleResponse {
	s.Headers = v
	return s
}

func (s *UpdateAggregateConfigRuleResponse) SetStatusCode(v int32) *UpdateAggregateConfigRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAggregateConfigRuleResponse) SetBody(v *UpdateAggregateConfigRuleResponseBody) *UpdateAggregateConfigRuleResponse {
	s.Body = v
	return s
}

type UpdateAggregateRemediationRequest struct {
	// The ID of the account group.
	//
	// You can the [ListAggregators](~~255797~~) operation to obtain the ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The execution mode of the remediation. Valid values:
	//
	// *   NON_EXECUTION: The remediation is not executed.
	// *   AUTO_EXECUTION: The remediation is automatically executed.
	// *   MANUAL_EXECUTION: The remediation is manually executed.
	// *   NOT_CONFIG: The execution mode is not specified.
	InvokeType *string `json:"InvokeType,omitempty" xml:"InvokeType,omitempty"`
	// The desired parameter values of the remediation setting.
	Params *string `json:"Params,omitempty" xml:"Params,omitempty"`
	// The ID of the remediation setting.
	//
	// You can call the [ListAggregateRemediations](~~270036~~) operation to obtain the ID of the remediation setting.
	RemediationId *string `json:"RemediationId,omitempty" xml:"RemediationId,omitempty"`
	// The ID of the remediation template.
	//
	// You can call the [ListRemediationTemplates](~~270066~~) operation to obtain the ID of the remediation template.
	RemediationTemplateId *string `json:"RemediationTemplateId,omitempty" xml:"RemediationTemplateId,omitempty"`
	// The type of the remediation template. Valid values:
	//
	// *   OOS: Operation Orchestration Service (OOS)
	// *   FC: Function Compute. You can use Function Compute to configure custom remediation settings.
	RemediationType *string `json:"RemediationType,omitempty" xml:"RemediationType,omitempty"`
	// The type of the rule for which the remediation template is configured. Valid values:
	//
	// *   ALIYUN: managed rule.
	// *   CUSTOM: custom rule.
	// *   NONE: The rule is not specified.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s UpdateAggregateRemediationRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateRemediationRequest) GoString() string {
	return s.String()
}

func (s *UpdateAggregateRemediationRequest) SetAggregatorId(v string) *UpdateAggregateRemediationRequest {
	s.AggregatorId = &v
	return s
}

func (s *UpdateAggregateRemediationRequest) SetInvokeType(v string) *UpdateAggregateRemediationRequest {
	s.InvokeType = &v
	return s
}

func (s *UpdateAggregateRemediationRequest) SetParams(v string) *UpdateAggregateRemediationRequest {
	s.Params = &v
	return s
}

func (s *UpdateAggregateRemediationRequest) SetRemediationId(v string) *UpdateAggregateRemediationRequest {
	s.RemediationId = &v
	return s
}

func (s *UpdateAggregateRemediationRequest) SetRemediationTemplateId(v string) *UpdateAggregateRemediationRequest {
	s.RemediationTemplateId = &v
	return s
}

func (s *UpdateAggregateRemediationRequest) SetRemediationType(v string) *UpdateAggregateRemediationRequest {
	s.RemediationType = &v
	return s
}

func (s *UpdateAggregateRemediationRequest) SetSourceType(v string) *UpdateAggregateRemediationRequest {
	s.SourceType = &v
	return s
}

type UpdateAggregateRemediationResponseBody struct {
	// The ID of the remediation setting.
	RemediationId *string `json:"RemediationId,omitempty" xml:"RemediationId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAggregateRemediationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateRemediationResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAggregateRemediationResponseBody) SetRemediationId(v string) *UpdateAggregateRemediationResponseBody {
	s.RemediationId = &v
	return s
}

func (s *UpdateAggregateRemediationResponseBody) SetRequestId(v string) *UpdateAggregateRemediationResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAggregateRemediationResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAggregateRemediationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAggregateRemediationResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregateRemediationResponse) GoString() string {
	return s.String()
}

func (s *UpdateAggregateRemediationResponse) SetHeaders(v map[string]*string) *UpdateAggregateRemediationResponse {
	s.Headers = v
	return s
}

func (s *UpdateAggregateRemediationResponse) SetStatusCode(v int32) *UpdateAggregateRemediationResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAggregateRemediationResponse) SetBody(v *UpdateAggregateRemediationResponseBody) *UpdateAggregateRemediationResponse {
	s.Body = v
	return s
}

type UpdateAggregatorRequest struct {
	// The information about the member accounts in the account group.
	//
	// >  When you modify the configurations of an account group, this parameter can be left empty. In this case, the member account list is not updated. If you want to update the member account list, you must set the `AccountId`, `AccountName` and `AccountType` parameters.
	AggregatorAccounts []*UpdateAggregatorRequestAggregatorAccounts `json:"AggregatorAccounts,omitempty" xml:"AggregatorAccounts,omitempty" type:"Repeated"`
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The name of the account group.
	//
	// For more information about how to obtain the name of an account group, see [ListAggregators](~~255797~~).
	AggregatorName *string `json:"AggregatorName,omitempty" xml:"AggregatorName,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the account group.
	//
	// For more information about how to obtain the description of an account group, see [ListAggregators](~~255797~~).
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
}

func (s UpdateAggregatorRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregatorRequest) GoString() string {
	return s.String()
}

func (s *UpdateAggregatorRequest) SetAggregatorAccounts(v []*UpdateAggregatorRequestAggregatorAccounts) *UpdateAggregatorRequest {
	s.AggregatorAccounts = v
	return s
}

func (s *UpdateAggregatorRequest) SetAggregatorId(v string) *UpdateAggregatorRequest {
	s.AggregatorId = &v
	return s
}

func (s *UpdateAggregatorRequest) SetAggregatorName(v string) *UpdateAggregatorRequest {
	s.AggregatorName = &v
	return s
}

func (s *UpdateAggregatorRequest) SetClientToken(v string) *UpdateAggregatorRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateAggregatorRequest) SetDescription(v string) *UpdateAggregatorRequest {
	s.Description = &v
	return s
}

type UpdateAggregatorRequestAggregatorAccounts struct {
	// The member account ID, which indicates the Alibaba Cloud account ID of the member account.
	//
	// For more information about how to obtain the ID of a member account, see [ListAccounts](~~160016~~).
	//
	// >  If you want to update the member account list, you must set the `AccountId`, `AccountName` and `AccountType` parameters.
	AccountId *int64 `json:"AccountId,omitempty" xml:"AccountId,omitempty"`
	// The member account name, which indicates the name of the Alibaba Cloud account that corresponds to the member account.
	//
	// For more information about how to obtain the name of a member account, see [ListAccounts](~~160016~~).
	//
	// >  If you want to update the member account list, you must set the `AccountId`, `AccountName` and `AccountType` parameters.
	AccountName *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	// The affiliation of the member account. You can set this parameter to only ResourceDirectory.
	//
	// >  If you want to update the member account list, you must set the `AccountId`, `AccountName` and `AccountType` parameters.
	AccountType *string `json:"AccountType,omitempty" xml:"AccountType,omitempty"`
}

func (s UpdateAggregatorRequestAggregatorAccounts) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregatorRequestAggregatorAccounts) GoString() string {
	return s.String()
}

func (s *UpdateAggregatorRequestAggregatorAccounts) SetAccountId(v int64) *UpdateAggregatorRequestAggregatorAccounts {
	s.AccountId = &v
	return s
}

func (s *UpdateAggregatorRequestAggregatorAccounts) SetAccountName(v string) *UpdateAggregatorRequestAggregatorAccounts {
	s.AccountName = &v
	return s
}

func (s *UpdateAggregatorRequestAggregatorAccounts) SetAccountType(v string) *UpdateAggregatorRequestAggregatorAccounts {
	s.AccountType = &v
	return s
}

type UpdateAggregatorShrinkRequest struct {
	// The information about the member accounts in the account group.
	//
	// >  When you modify the configurations of an account group, this parameter can be left empty. In this case, the member account list is not updated. If you want to update the member account list, you must set the `AccountId`, `AccountName` and `AccountType` parameters.
	AggregatorAccountsShrink *string `json:"AggregatorAccounts,omitempty" xml:"AggregatorAccounts,omitempty"`
	// The ID of the account group.
	//
	// For more information about how to obtain the ID of an account group, see [ListAggregators](~~255797~~).
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The name of the account group.
	//
	// For more information about how to obtain the name of an account group, see [ListAggregators](~~255797~~).
	AggregatorName *string `json:"AggregatorName,omitempty" xml:"AggregatorName,omitempty"`
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the account group.
	//
	// For more information about how to obtain the description of an account group, see [ListAggregators](~~255797~~).
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
}

func (s UpdateAggregatorShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregatorShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateAggregatorShrinkRequest) SetAggregatorAccountsShrink(v string) *UpdateAggregatorShrinkRequest {
	s.AggregatorAccountsShrink = &v
	return s
}

func (s *UpdateAggregatorShrinkRequest) SetAggregatorId(v string) *UpdateAggregatorShrinkRequest {
	s.AggregatorId = &v
	return s
}

func (s *UpdateAggregatorShrinkRequest) SetAggregatorName(v string) *UpdateAggregatorShrinkRequest {
	s.AggregatorName = &v
	return s
}

func (s *UpdateAggregatorShrinkRequest) SetClientToken(v string) *UpdateAggregatorShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateAggregatorShrinkRequest) SetDescription(v string) *UpdateAggregatorShrinkRequest {
	s.Description = &v
	return s
}

type UpdateAggregatorResponseBody struct {
	// The ID of the account group.
	AggregatorId *string `json:"AggregatorId,omitempty" xml:"AggregatorId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateAggregatorResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregatorResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateAggregatorResponseBody) SetAggregatorId(v string) *UpdateAggregatorResponseBody {
	s.AggregatorId = &v
	return s
}

func (s *UpdateAggregatorResponseBody) SetRequestId(v string) *UpdateAggregatorResponseBody {
	s.RequestId = &v
	return s
}

type UpdateAggregatorResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateAggregatorResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateAggregatorResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateAggregatorResponse) GoString() string {
	return s.String()
}

func (s *UpdateAggregatorResponse) SetHeaders(v map[string]*string) *UpdateAggregatorResponse {
	s.Headers = v
	return s
}

func (s *UpdateAggregatorResponse) SetStatusCode(v int32) *UpdateAggregatorResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateAggregatorResponse) SetBody(v *UpdateAggregatorResponseBody) *UpdateAggregatorResponse {
	s.Body = v
	return s
}

type UpdateCompliancePackRequest struct {
	// The client token that you want to use to ensure the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.``
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListCompliancePacks](~~263332~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The name of the compliance package.
	//
	// For more information about how to obtain the name of a compliance package, see [ListCompliancePacks](~~263332~~).
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
	// The rules in the compliance package.
	//
	// If you leave this parameter empty, the rules in the compliance package remain unchanged. If you configure this parameter, Cloud Config replaces the existing rules in the compliance package with the specified rules.
	ConfigRules []*UpdateCompliancePackRequestConfigRules `json:"ConfigRules,omitempty" xml:"ConfigRules,omitempty" type:"Repeated"`
	// The description of the compliance package.
	//
	// For more information about how to obtain the description of a compliance package, see [ListCompliancePacks](~~263332~~).
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the resource that you do not want to evaluate by using the compliance package. Separate multiple resource IDs with commas (,).
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The ID of the region whose resources you want to evaluate by using the compliance package. Separate multiple region IDs with commas (,).
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group whose resources you want to evaluate by using the compliance package. Separate multiple resource group IDs with commas (,).
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The risk level of the resources that are not compliant with the rules in the compliance package. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The tag key of the resource that you want to evaluate by using the compliance package.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value of the resource that you want to evaluate by using the compliance package.
	//
	// >  You must configure the TagValueScope parameter together with the TagValueScope parameter.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s UpdateCompliancePackRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCompliancePackRequest) GoString() string {
	return s.String()
}

func (s *UpdateCompliancePackRequest) SetClientToken(v string) *UpdateCompliancePackRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateCompliancePackRequest) SetCompliancePackId(v string) *UpdateCompliancePackRequest {
	s.CompliancePackId = &v
	return s
}

func (s *UpdateCompliancePackRequest) SetCompliancePackName(v string) *UpdateCompliancePackRequest {
	s.CompliancePackName = &v
	return s
}

func (s *UpdateCompliancePackRequest) SetConfigRules(v []*UpdateCompliancePackRequestConfigRules) *UpdateCompliancePackRequest {
	s.ConfigRules = v
	return s
}

func (s *UpdateCompliancePackRequest) SetDescription(v string) *UpdateCompliancePackRequest {
	s.Description = &v
	return s
}

func (s *UpdateCompliancePackRequest) SetExcludeResourceIdsScope(v string) *UpdateCompliancePackRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *UpdateCompliancePackRequest) SetRegionIdsScope(v string) *UpdateCompliancePackRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *UpdateCompliancePackRequest) SetResourceGroupIdsScope(v string) *UpdateCompliancePackRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *UpdateCompliancePackRequest) SetRiskLevel(v int32) *UpdateCompliancePackRequest {
	s.RiskLevel = &v
	return s
}

func (s *UpdateCompliancePackRequest) SetTagKeyScope(v string) *UpdateCompliancePackRequest {
	s.TagKeyScope = &v
	return s
}

func (s *UpdateCompliancePackRequest) SetTagValueScope(v string) *UpdateCompliancePackRequest {
	s.TagValueScope = &v
	return s
}

type UpdateCompliancePackRequestConfigRules struct {
	// The ID of the rule. If you configure this parameter, Cloud Config adds the rule of the specified ID to the compliance package.
	//
	// You only need to configure the `ManagedRuleIdentifier` or `ConfigRuleId` parameter. If you configure both parameters, the value of the `ConfigRuleId` parameter takes precedence. For more information about how to obtain the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the rule.
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The details of the input parameters of the rule.
	ConfigRuleParameters []*UpdateCompliancePackRequestConfigRulesConfigRuleParameters `json:"ConfigRuleParameters,omitempty" xml:"ConfigRuleParameters,omitempty" type:"Repeated"`
	// The description of the rule.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the managed rule. Cloud Config automatically create a managed rule of the specified ID and adds the rule to the compliance package.
	//
	// You only need to configure the `ManagedRuleIdentifier` or `ConfigRuleId` parameter. If you configure both parameters, the value of the `ConfigRuleId` parameter take precedence. For more information about how to obtain the ID of a managed rule, see [ListCompliancePackTemplates](~~261176~~).
	ManagedRuleIdentifier *string `json:"ManagedRuleIdentifier,omitempty" xml:"ManagedRuleIdentifier,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
}

func (s UpdateCompliancePackRequestConfigRules) String() string {
	return tea.Prettify(s)
}

func (s UpdateCompliancePackRequestConfigRules) GoString() string {
	return s.String()
}

func (s *UpdateCompliancePackRequestConfigRules) SetConfigRuleId(v string) *UpdateCompliancePackRequestConfigRules {
	s.ConfigRuleId = &v
	return s
}

func (s *UpdateCompliancePackRequestConfigRules) SetConfigRuleName(v string) *UpdateCompliancePackRequestConfigRules {
	s.ConfigRuleName = &v
	return s
}

func (s *UpdateCompliancePackRequestConfigRules) SetConfigRuleParameters(v []*UpdateCompliancePackRequestConfigRulesConfigRuleParameters) *UpdateCompliancePackRequestConfigRules {
	s.ConfigRuleParameters = v
	return s
}

func (s *UpdateCompliancePackRequestConfigRules) SetDescription(v string) *UpdateCompliancePackRequestConfigRules {
	s.Description = &v
	return s
}

func (s *UpdateCompliancePackRequestConfigRules) SetManagedRuleIdentifier(v string) *UpdateCompliancePackRequestConfigRules {
	s.ManagedRuleIdentifier = &v
	return s
}

func (s *UpdateCompliancePackRequestConfigRules) SetRiskLevel(v int32) *UpdateCompliancePackRequestConfigRules {
	s.RiskLevel = &v
	return s
}

type UpdateCompliancePackRequestConfigRulesConfigRuleParameters struct {
	// The name of the input parameter.
	//
	// You must configure the `ParameterName` and `ParameterValue` parameters or neither of them. If the managed rule has an input parameter but no default value exists, you must configure this parameter. For more information about how to obtain the name of an input parameter for a managed rule, see [ListCompliancePackTemplates](~~261176~~).
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The value of the input parameter.
	//
	// You must configure the `ParameterName` and `ParameterValue` parameters or neither of them. If the managed rule has an input parameter but no default value exists, you must configure this parameter. For more information about how to obtain the value of an input parameter for a managed rule, see [ListCompliancePackTemplates](~~261176~~).
	ParameterValue *string `json:"ParameterValue,omitempty" xml:"ParameterValue,omitempty"`
}

func (s UpdateCompliancePackRequestConfigRulesConfigRuleParameters) String() string {
	return tea.Prettify(s)
}

func (s UpdateCompliancePackRequestConfigRulesConfigRuleParameters) GoString() string {
	return s.String()
}

func (s *UpdateCompliancePackRequestConfigRulesConfigRuleParameters) SetParameterName(v string) *UpdateCompliancePackRequestConfigRulesConfigRuleParameters {
	s.ParameterName = &v
	return s
}

func (s *UpdateCompliancePackRequestConfigRulesConfigRuleParameters) SetParameterValue(v string) *UpdateCompliancePackRequestConfigRulesConfigRuleParameters {
	s.ParameterValue = &v
	return s
}

type UpdateCompliancePackShrinkRequest struct {
	// The client token that you want to use to ensure the idempotency of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.``
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the compliance package.
	//
	// For more information about how to obtain the ID of a compliance package, see [ListCompliancePacks](~~263332~~).
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The name of the compliance package.
	//
	// For more information about how to obtain the name of a compliance package, see [ListCompliancePacks](~~263332~~).
	CompliancePackName *string `json:"CompliancePackName,omitempty" xml:"CompliancePackName,omitempty"`
	// The rules in the compliance package.
	//
	// If you leave this parameter empty, the rules in the compliance package remain unchanged. If you configure this parameter, Cloud Config replaces the existing rules in the compliance package with the specified rules.
	ConfigRulesShrink *string `json:"ConfigRules,omitempty" xml:"ConfigRules,omitempty"`
	// The description of the compliance package.
	//
	// For more information about how to obtain the description of a compliance package, see [ListCompliancePacks](~~263332~~).
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the resource that you do not want to evaluate by using the compliance package. Separate multiple resource IDs with commas (,).
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The ID of the region whose resources you want to evaluate by using the compliance package. Separate multiple region IDs with commas (,).
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group whose resources you want to evaluate by using the compliance package. Separate multiple resource group IDs with commas (,).
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The risk level of the resources that are not compliant with the rules in the compliance package. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The tag key of the resource that you want to evaluate by using the compliance package.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag value of the resource that you want to evaluate by using the compliance package.
	//
	// >  You must configure the TagValueScope parameter together with the TagValueScope parameter.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s UpdateCompliancePackShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCompliancePackShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateCompliancePackShrinkRequest) SetClientToken(v string) *UpdateCompliancePackShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateCompliancePackShrinkRequest) SetCompliancePackId(v string) *UpdateCompliancePackShrinkRequest {
	s.CompliancePackId = &v
	return s
}

func (s *UpdateCompliancePackShrinkRequest) SetCompliancePackName(v string) *UpdateCompliancePackShrinkRequest {
	s.CompliancePackName = &v
	return s
}

func (s *UpdateCompliancePackShrinkRequest) SetConfigRulesShrink(v string) *UpdateCompliancePackShrinkRequest {
	s.ConfigRulesShrink = &v
	return s
}

func (s *UpdateCompliancePackShrinkRequest) SetDescription(v string) *UpdateCompliancePackShrinkRequest {
	s.Description = &v
	return s
}

func (s *UpdateCompliancePackShrinkRequest) SetExcludeResourceIdsScope(v string) *UpdateCompliancePackShrinkRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *UpdateCompliancePackShrinkRequest) SetRegionIdsScope(v string) *UpdateCompliancePackShrinkRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *UpdateCompliancePackShrinkRequest) SetResourceGroupIdsScope(v string) *UpdateCompliancePackShrinkRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *UpdateCompliancePackShrinkRequest) SetRiskLevel(v int32) *UpdateCompliancePackShrinkRequest {
	s.RiskLevel = &v
	return s
}

func (s *UpdateCompliancePackShrinkRequest) SetTagKeyScope(v string) *UpdateCompliancePackShrinkRequest {
	s.TagKeyScope = &v
	return s
}

func (s *UpdateCompliancePackShrinkRequest) SetTagValueScope(v string) *UpdateCompliancePackShrinkRequest {
	s.TagValueScope = &v
	return s
}

type UpdateCompliancePackResponseBody struct {
	// The ID of the compliance package.
	CompliancePackId *string `json:"CompliancePackId,omitempty" xml:"CompliancePackId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateCompliancePackResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateCompliancePackResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateCompliancePackResponseBody) SetCompliancePackId(v string) *UpdateCompliancePackResponseBody {
	s.CompliancePackId = &v
	return s
}

func (s *UpdateCompliancePackResponseBody) SetRequestId(v string) *UpdateCompliancePackResponseBody {
	s.RequestId = &v
	return s
}

type UpdateCompliancePackResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateCompliancePackResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateCompliancePackResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateCompliancePackResponse) GoString() string {
	return s.String()
}

func (s *UpdateCompliancePackResponse) SetHeaders(v map[string]*string) *UpdateCompliancePackResponse {
	s.Headers = v
	return s
}

func (s *UpdateCompliancePackResponse) SetStatusCode(v int32) *UpdateCompliancePackResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateCompliancePackResponse) SetBody(v *UpdateCompliancePackResponseBody) *UpdateCompliancePackResponse {
	s.Body = v
	return s
}

type UpdateConfigDeliveryChannelRequest struct {
	// The client token that is used to ensure the idempotency of the request. You can use the client to generate the token, but you must ensure that the token is unique among different requests.
	//
	// The `token` can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to deliver resource change logs. If you set this parameter to true, Cloud Config delivers resource change logs to OSS, Log Service, or MNS when the configurations of the resources change. Valid values:
	//
	// *   true: Cloud Config delivers resource change logs.
	// *   false (default): Cloud Config does not deliver resource change logs.
	//
	// > This parameter is available for delivery channels of the OSS, SLS, and MNS types.
	ConfigurationItemChangeNotification *bool `json:"ConfigurationItemChangeNotification,omitempty" xml:"ConfigurationItemChangeNotification,omitempty"`
	// Specifies whether to deliver scheduled resource snapshots. Cloud Config delivers scheduled resource snapshots at `04:00Z` and `16:00Z` to OSS, MNS, or Log Service every day. The time is displayed in UTC. Valid values:
	//
	// *   true: Cloud Config delivers scheduled resource snapshots.
	// *   false (default): Cloud Config does not deliver scheduled resource snapshots.
	ConfigurationSnapshot *bool `json:"ConfigurationSnapshot,omitempty" xml:"ConfigurationSnapshot,omitempty"`
	// The rule that you want to attach to the delivery channel. This parameter is available when you deliver data of all types to MNS or deliver snapshots to Log Service.
	//
	// *   If the value of the DeliveryChannelType parameter is MNS, take note of the following settings of the lowest risk level and resource types of the events to which you subscribed:
	//
	//     *   The setting of the lowest risk level for the events to which you want to subscribe is in the following format: `{"filterType":"RuleRiskLevel","value":"1","multiple":false}`.
	//
	//         The `value` field indicates the lowest risk level of the events to which you want to subscribe. Valid values: 1, 2, and 3. The value 1 indicates the high risk level, the value 2 indicates the medium risk level, and the value 3 indicates the low risk level.
	//
	//     *   The setting of the resource types of the events to which you want to subscribe is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//         The `values` field indicates the resource types of the events to which you want to subscribe. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	//
	// *   If you set the DeliveryChannelType parameter to SLS, the setting of the resource types of the snapshots to which you want to deliver is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//     The `values` field specifies the resource types of the snapshots to which you want to deliver. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	DeliveryChannelCondition *string `json:"DeliveryChannelCondition,omitempty" xml:"DeliveryChannelCondition,omitempty"`
	// The ID of the delivery channel.
	//
	// For more information about how to obtain the ID of a delivery channel, see [DescribeDeliveryChannels](~~429841~~).
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
	// The name of the delivery channel.
	DeliveryChannelName *string `json:"DeliveryChannelName,omitempty" xml:"DeliveryChannelName,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the delivery destination. Valid values:
	//
	// *   `acs:oss:{RegionId}:{accountId}:{bucketName}` if your delivery destination is an OSS bucket. Example: `acs:oss:cn-shanghai:100931896542****:new-bucket`.
	// *   `acs:mns:{RegionId}:{accountId}:/topics/{topicName}` if your delivery destination is an MNS topic. Example: `acs:mns:cn-shanghai:100931896542****:/topics/topic1`.
	// *   `acs:log:{RegionId}:{accountId}:project/{projectName}/logstore/{logstoreName}` if your delivery destination is a Log Service Logstore. Example: `acs:log:cn-shanghai:100931896542****:project/project1/logstore/logstore1`.
	DeliveryChannelTargetArn *string `json:"DeliveryChannelTargetArn,omitempty" xml:"DeliveryChannelTargetArn,omitempty"`
	// The time when you want Cloud Config to deliver scheduled resource snapshots every day.
	//
	// Format: `HH:mmZ`. This time is displayed in UTC.
	//
	// > When you enable the scheduled resource delivery feature, you can configure this parameter to specify a custom delivery time. If you do not configure this parameter, Cloud Config automatically delivers scheduled resource snapshots at `04:00Z` and `16:00Z` every day.
	DeliverySnapshotTime *string `json:"DeliverySnapshotTime,omitempty" xml:"DeliverySnapshotTime,omitempty"`
	// The description of the delivery channel.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to deliver resource non-compliance events. If you set this parameter to true, Cloud Config delivers resource non-compliance events to Log Service or MNS when resources are considered non-compliant. Valid values:
	//
	// *   true: Cloud Config delivers resource non-compliance events.
	// *   false (default): Cloud Config does not deliver resource non-compliance events.
	//
	// > This parameter is available only for delivery channels of the SLS or MNS type.
	NonCompliantNotification *bool `json:"NonCompliantNotification,omitempty" xml:"NonCompliantNotification,omitempty"`
	// The ARN of the OSS bucket to which you want to transfer the delivery data when the size of the data exceeds the specified upper limit of the delivery channel. Format: `acs:oss:{RegionId}:{accountId}:{bucketName}`.
	//
	// If you do not configure this parameter, Cloud Config delivers only summary data.
	//
	// > This parameter is available only for delivery channels of the SLS or MNS type. The maximum storage size of delivery channels of the SLS type is 1 MB, and the maximum storage size of delivery channels of the MNS type is 64 KB.
	OversizedDataOSSTargetArn *string `json:"OversizedDataOSSTargetArn,omitempty" xml:"OversizedDataOSSTargetArn,omitempty"`
	// Specifies whether to enable the delivery channel. Valid values:
	//
	// *   0: Cloud Config disables the delivery channel. Cloud Config retains the most recent delivery configuration and stops resource data delivery.
	// *   1 (default): Cloud Config enables the delivery channel.
	Status *int64 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateConfigDeliveryChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigDeliveryChannelRequest) GoString() string {
	return s.String()
}

func (s *UpdateConfigDeliveryChannelRequest) SetClientToken(v string) *UpdateConfigDeliveryChannelRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateConfigDeliveryChannelRequest) SetConfigurationItemChangeNotification(v bool) *UpdateConfigDeliveryChannelRequest {
	s.ConfigurationItemChangeNotification = &v
	return s
}

func (s *UpdateConfigDeliveryChannelRequest) SetConfigurationSnapshot(v bool) *UpdateConfigDeliveryChannelRequest {
	s.ConfigurationSnapshot = &v
	return s
}

func (s *UpdateConfigDeliveryChannelRequest) SetDeliveryChannelCondition(v string) *UpdateConfigDeliveryChannelRequest {
	s.DeliveryChannelCondition = &v
	return s
}

func (s *UpdateConfigDeliveryChannelRequest) SetDeliveryChannelId(v string) *UpdateConfigDeliveryChannelRequest {
	s.DeliveryChannelId = &v
	return s
}

func (s *UpdateConfigDeliveryChannelRequest) SetDeliveryChannelName(v string) *UpdateConfigDeliveryChannelRequest {
	s.DeliveryChannelName = &v
	return s
}

func (s *UpdateConfigDeliveryChannelRequest) SetDeliveryChannelTargetArn(v string) *UpdateConfigDeliveryChannelRequest {
	s.DeliveryChannelTargetArn = &v
	return s
}

func (s *UpdateConfigDeliveryChannelRequest) SetDeliverySnapshotTime(v string) *UpdateConfigDeliveryChannelRequest {
	s.DeliverySnapshotTime = &v
	return s
}

func (s *UpdateConfigDeliveryChannelRequest) SetDescription(v string) *UpdateConfigDeliveryChannelRequest {
	s.Description = &v
	return s
}

func (s *UpdateConfigDeliveryChannelRequest) SetNonCompliantNotification(v bool) *UpdateConfigDeliveryChannelRequest {
	s.NonCompliantNotification = &v
	return s
}

func (s *UpdateConfigDeliveryChannelRequest) SetOversizedDataOSSTargetArn(v string) *UpdateConfigDeliveryChannelRequest {
	s.OversizedDataOSSTargetArn = &v
	return s
}

func (s *UpdateConfigDeliveryChannelRequest) SetStatus(v int64) *UpdateConfigDeliveryChannelRequest {
	s.Status = &v
	return s
}

type UpdateConfigDeliveryChannelResponseBody struct {
	// The ID of the delivery channel.
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateConfigDeliveryChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigDeliveryChannelResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateConfigDeliveryChannelResponseBody) SetDeliveryChannelId(v string) *UpdateConfigDeliveryChannelResponseBody {
	s.DeliveryChannelId = &v
	return s
}

func (s *UpdateConfigDeliveryChannelResponseBody) SetRequestId(v string) *UpdateConfigDeliveryChannelResponseBody {
	s.RequestId = &v
	return s
}

type UpdateConfigDeliveryChannelResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateConfigDeliveryChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateConfigDeliveryChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigDeliveryChannelResponse) GoString() string {
	return s.String()
}

func (s *UpdateConfigDeliveryChannelResponse) SetHeaders(v map[string]*string) *UpdateConfigDeliveryChannelResponse {
	s.Headers = v
	return s
}

func (s *UpdateConfigDeliveryChannelResponse) SetStatusCode(v int32) *UpdateConfigDeliveryChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateConfigDeliveryChannelResponse) SetBody(v *UpdateConfigDeliveryChannelResponseBody) *UpdateConfigDeliveryChannelResponse {
	s.Body = v
	return s
}

type UpdateConfigRuleRequest struct {
	// The client token that you want to use to ensure the idempotency of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.``
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the rule.
	//
	// For more information about how to query the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the rule.
	//
	// For more information about how to query the name of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The rule is triggered by configuration changes.
	// *   ScheduledNotification: The rule is periodically triggered.
	//
	// >  This parameter applies only to custom rules.
	ConfigRuleTriggerTypes *string `json:"ConfigRuleTriggerTypes,omitempty" xml:"ConfigRuleTriggerTypes,omitempty"`
	// The description of the rule. You can enter up to 500 characters.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the resource to be excluded from the compliance evaluations performed by the rule. Separate multiple resource IDs with commas (,).
	//
	// >  This parameter applies only to managed rules.
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The input parameters of the rule.
	InputParameters map[string]interface{} `json:"InputParameters,omitempty" xml:"InputParameters,omitempty"`
	// The intervals at which the rule is triggered. Valid values:
	//
	// *   One_Hour: 1 hour.
	// *   Three_Hours: 3 hours.
	// *   Six_Hours: 6 hours.
	// *   Twelve_Hours: 12 hours.
	// *   TwentyFour_Hours (default): 24 hours.
	//
	// >  This parameter is required if you set the `ConfigRuleTriggerTypes` parameter to `ScheduledNotification`.
	MaximumExecutionFrequency *string `json:"MaximumExecutionFrequency,omitempty" xml:"MaximumExecutionFrequency,omitempty"`
	// The ID of the region to which the rule applies. Separate multiple region IDs with commas (,).
	//
	// >  This parameter applies only to managed rules.
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group to which the rule applies. Separate multiple resource group IDs with commas (,).
	//
	// >  This parameter applies only to managed rules.
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The type of the resource to be evaluated by the rule. Separate multiple resource types with commas (,).
	ResourceTypesScope []*string `json:"ResourceTypesScope,omitempty" xml:"ResourceTypesScope,omitempty" type:"Repeated"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The logical relationship among the tag keys if you specify multiple tag keys by using the `TagKeyScope` parameter. For example, if the `TagKeyScope` parameter is set to `ECS,OSS` and the TagKeyLogicScope parameter is set to `AND`, the rule applies to resources with both the `ECS` and `OSS` tag keys. Valid values:
	//
	// *   AND: logical AND
	// *   OR: logical OR
	TagKeyLogicScope *string `json:"TagKeyLogicScope,omitempty" xml:"TagKeyLogicScope,omitempty"`
	// The tag key used to filter resources. The rule applies only to the resources with the specified tag key.
	//
	// >  This parameter applies only to managed rules. You must configure the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag key used to filter resources. The rule applies only to the resources with the specified tag key.
	//
	// >  This parameter applies only to managed rules. You must configure the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s UpdateConfigRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigRuleRequest) GoString() string {
	return s.String()
}

func (s *UpdateConfigRuleRequest) SetClientToken(v string) *UpdateConfigRuleRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateConfigRuleRequest) SetConfigRuleId(v string) *UpdateConfigRuleRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *UpdateConfigRuleRequest) SetConfigRuleName(v string) *UpdateConfigRuleRequest {
	s.ConfigRuleName = &v
	return s
}

func (s *UpdateConfigRuleRequest) SetConfigRuleTriggerTypes(v string) *UpdateConfigRuleRequest {
	s.ConfigRuleTriggerTypes = &v
	return s
}

func (s *UpdateConfigRuleRequest) SetDescription(v string) *UpdateConfigRuleRequest {
	s.Description = &v
	return s
}

func (s *UpdateConfigRuleRequest) SetExcludeResourceIdsScope(v string) *UpdateConfigRuleRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *UpdateConfigRuleRequest) SetInputParameters(v map[string]interface{}) *UpdateConfigRuleRequest {
	s.InputParameters = v
	return s
}

func (s *UpdateConfigRuleRequest) SetMaximumExecutionFrequency(v string) *UpdateConfigRuleRequest {
	s.MaximumExecutionFrequency = &v
	return s
}

func (s *UpdateConfigRuleRequest) SetRegionIdsScope(v string) *UpdateConfigRuleRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *UpdateConfigRuleRequest) SetResourceGroupIdsScope(v string) *UpdateConfigRuleRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *UpdateConfigRuleRequest) SetResourceTypesScope(v []*string) *UpdateConfigRuleRequest {
	s.ResourceTypesScope = v
	return s
}

func (s *UpdateConfigRuleRequest) SetRiskLevel(v int32) *UpdateConfigRuleRequest {
	s.RiskLevel = &v
	return s
}

func (s *UpdateConfigRuleRequest) SetTagKeyLogicScope(v string) *UpdateConfigRuleRequest {
	s.TagKeyLogicScope = &v
	return s
}

func (s *UpdateConfigRuleRequest) SetTagKeyScope(v string) *UpdateConfigRuleRequest {
	s.TagKeyScope = &v
	return s
}

func (s *UpdateConfigRuleRequest) SetTagValueScope(v string) *UpdateConfigRuleRequest {
	s.TagValueScope = &v
	return s
}

type UpdateConfigRuleShrinkRequest struct {
	// The client token that you want to use to ensure the idempotency of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.``
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the rule.
	//
	// For more information about how to query the ID of a rule, see [ListConfigRules](~~169607~~).
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The name of the rule.
	//
	// For more information about how to query the name of a rule, see [ListAggregateConfigRules](~~264148~~).
	ConfigRuleName *string `json:"ConfigRuleName,omitempty" xml:"ConfigRuleName,omitempty"`
	// The trigger type of the rule. Valid values:
	//
	// *   ConfigurationItemChangeNotification: The rule is triggered by configuration changes.
	// *   ScheduledNotification: The rule is periodically triggered.
	//
	// >  This parameter applies only to custom rules.
	ConfigRuleTriggerTypes *string `json:"ConfigRuleTriggerTypes,omitempty" xml:"ConfigRuleTriggerTypes,omitempty"`
	// The description of the rule. You can enter up to 500 characters.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the resource to be excluded from the compliance evaluations performed by the rule. Separate multiple resource IDs with commas (,).
	//
	// >  This parameter applies only to managed rules.
	ExcludeResourceIdsScope *string `json:"ExcludeResourceIdsScope,omitempty" xml:"ExcludeResourceIdsScope,omitempty"`
	// The input parameters of the rule.
	InputParametersShrink *string `json:"InputParameters,omitempty" xml:"InputParameters,omitempty"`
	// The intervals at which the rule is triggered. Valid values:
	//
	// *   One_Hour: 1 hour.
	// *   Three_Hours: 3 hours.
	// *   Six_Hours: 6 hours.
	// *   Twelve_Hours: 12 hours.
	// *   TwentyFour_Hours (default): 24 hours.
	//
	// >  This parameter is required if you set the `ConfigRuleTriggerTypes` parameter to `ScheduledNotification`.
	MaximumExecutionFrequency *string `json:"MaximumExecutionFrequency,omitempty" xml:"MaximumExecutionFrequency,omitempty"`
	// The ID of the region to which the rule applies. Separate multiple region IDs with commas (,).
	//
	// >  This parameter applies only to managed rules.
	RegionIdsScope *string `json:"RegionIdsScope,omitempty" xml:"RegionIdsScope,omitempty"`
	// The ID of the resource group to which the rule applies. Separate multiple resource group IDs with commas (,).
	//
	// >  This parameter applies only to managed rules.
	ResourceGroupIdsScope *string `json:"ResourceGroupIdsScope,omitempty" xml:"ResourceGroupIdsScope,omitempty"`
	// The type of the resource to be evaluated by the rule. Separate multiple resource types with commas (,).
	ResourceTypesScopeShrink *string `json:"ResourceTypesScope,omitempty" xml:"ResourceTypesScope,omitempty"`
	// The risk level of the resources that are not compliant with the rule. Valid values:
	//
	// *   1: high risk level
	// *   2: medium risk level
	// *   3: low risk level
	RiskLevel *int32 `json:"RiskLevel,omitempty" xml:"RiskLevel,omitempty"`
	// The logical relationship among the tag keys if you specify multiple tag keys by using the `TagKeyScope` parameter. For example, if the `TagKeyScope` parameter is set to `ECS,OSS` and the TagKeyLogicScope parameter is set to `AND`, the rule applies to resources with both the `ECS` and `OSS` tag keys. Valid values:
	//
	// *   AND: logical AND
	// *   OR: logical OR
	TagKeyLogicScope *string `json:"TagKeyLogicScope,omitempty" xml:"TagKeyLogicScope,omitempty"`
	// The tag key used to filter resources. The rule applies only to the resources with the specified tag key.
	//
	// >  This parameter applies only to managed rules. You must configure the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagKeyScope *string `json:"TagKeyScope,omitempty" xml:"TagKeyScope,omitempty"`
	// The tag key used to filter resources. The rule applies only to the resources with the specified tag key.
	//
	// >  This parameter applies only to managed rules. You must configure the `TagKeyScope` and `TagValueScope` parameters at the same time.
	TagValueScope *string `json:"TagValueScope,omitempty" xml:"TagValueScope,omitempty"`
}

func (s UpdateConfigRuleShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigRuleShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateConfigRuleShrinkRequest) SetClientToken(v string) *UpdateConfigRuleShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateConfigRuleShrinkRequest) SetConfigRuleId(v string) *UpdateConfigRuleShrinkRequest {
	s.ConfigRuleId = &v
	return s
}

func (s *UpdateConfigRuleShrinkRequest) SetConfigRuleName(v string) *UpdateConfigRuleShrinkRequest {
	s.ConfigRuleName = &v
	return s
}

func (s *UpdateConfigRuleShrinkRequest) SetConfigRuleTriggerTypes(v string) *UpdateConfigRuleShrinkRequest {
	s.ConfigRuleTriggerTypes = &v
	return s
}

func (s *UpdateConfigRuleShrinkRequest) SetDescription(v string) *UpdateConfigRuleShrinkRequest {
	s.Description = &v
	return s
}

func (s *UpdateConfigRuleShrinkRequest) SetExcludeResourceIdsScope(v string) *UpdateConfigRuleShrinkRequest {
	s.ExcludeResourceIdsScope = &v
	return s
}

func (s *UpdateConfigRuleShrinkRequest) SetInputParametersShrink(v string) *UpdateConfigRuleShrinkRequest {
	s.InputParametersShrink = &v
	return s
}

func (s *UpdateConfigRuleShrinkRequest) SetMaximumExecutionFrequency(v string) *UpdateConfigRuleShrinkRequest {
	s.MaximumExecutionFrequency = &v
	return s
}

func (s *UpdateConfigRuleShrinkRequest) SetRegionIdsScope(v string) *UpdateConfigRuleShrinkRequest {
	s.RegionIdsScope = &v
	return s
}

func (s *UpdateConfigRuleShrinkRequest) SetResourceGroupIdsScope(v string) *UpdateConfigRuleShrinkRequest {
	s.ResourceGroupIdsScope = &v
	return s
}

func (s *UpdateConfigRuleShrinkRequest) SetResourceTypesScopeShrink(v string) *UpdateConfigRuleShrinkRequest {
	s.ResourceTypesScopeShrink = &v
	return s
}

func (s *UpdateConfigRuleShrinkRequest) SetRiskLevel(v int32) *UpdateConfigRuleShrinkRequest {
	s.RiskLevel = &v
	return s
}

func (s *UpdateConfigRuleShrinkRequest) SetTagKeyLogicScope(v string) *UpdateConfigRuleShrinkRequest {
	s.TagKeyLogicScope = &v
	return s
}

func (s *UpdateConfigRuleShrinkRequest) SetTagKeyScope(v string) *UpdateConfigRuleShrinkRequest {
	s.TagKeyScope = &v
	return s
}

func (s *UpdateConfigRuleShrinkRequest) SetTagValueScope(v string) *UpdateConfigRuleShrinkRequest {
	s.TagValueScope = &v
	return s
}

type UpdateConfigRuleResponseBody struct {
	// The ID of the rule.
	ConfigRuleId *string `json:"ConfigRuleId,omitempty" xml:"ConfigRuleId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateConfigRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigRuleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateConfigRuleResponseBody) SetConfigRuleId(v string) *UpdateConfigRuleResponseBody {
	s.ConfigRuleId = &v
	return s
}

func (s *UpdateConfigRuleResponseBody) SetRequestId(v string) *UpdateConfigRuleResponseBody {
	s.RequestId = &v
	return s
}

type UpdateConfigRuleResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateConfigRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateConfigRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigRuleResponse) GoString() string {
	return s.String()
}

func (s *UpdateConfigRuleResponse) SetHeaders(v map[string]*string) *UpdateConfigRuleResponse {
	s.Headers = v
	return s
}

func (s *UpdateConfigRuleResponse) SetStatusCode(v int32) *UpdateConfigRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateConfigRuleResponse) SetBody(v *UpdateConfigRuleResponseBody) *UpdateConfigRuleResponse {
	s.Body = v
	return s
}

type UpdateConfigurationRecorderRequest struct {
	ResourceTypes *string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty"`
}

func (s UpdateConfigurationRecorderRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigurationRecorderRequest) GoString() string {
	return s.String()
}

func (s *UpdateConfigurationRecorderRequest) SetResourceTypes(v string) *UpdateConfigurationRecorderRequest {
	s.ResourceTypes = &v
	return s
}

type UpdateConfigurationRecorderResponseBody struct {
	ConfigurationRecorder *UpdateConfigurationRecorderResponseBodyConfigurationRecorder `json:"ConfigurationRecorder,omitempty" xml:"ConfigurationRecorder,omitempty" type:"Struct"`
	RequestId             *string                                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateConfigurationRecorderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigurationRecorderResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateConfigurationRecorderResponseBody) SetConfigurationRecorder(v *UpdateConfigurationRecorderResponseBodyConfigurationRecorder) *UpdateConfigurationRecorderResponseBody {
	s.ConfigurationRecorder = v
	return s
}

func (s *UpdateConfigurationRecorderResponseBody) SetRequestId(v string) *UpdateConfigurationRecorderResponseBody {
	s.RequestId = &v
	return s
}

type UpdateConfigurationRecorderResponseBodyConfigurationRecorder struct {
	ConfigurationRecorderStatus *string   `json:"ConfigurationRecorderStatus,omitempty" xml:"ConfigurationRecorderStatus,omitempty"`
	ResourceTypes               []*string `json:"ResourceTypes,omitempty" xml:"ResourceTypes,omitempty" type:"Repeated"`
}

func (s UpdateConfigurationRecorderResponseBodyConfigurationRecorder) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigurationRecorderResponseBodyConfigurationRecorder) GoString() string {
	return s.String()
}

func (s *UpdateConfigurationRecorderResponseBodyConfigurationRecorder) SetConfigurationRecorderStatus(v string) *UpdateConfigurationRecorderResponseBodyConfigurationRecorder {
	s.ConfigurationRecorderStatus = &v
	return s
}

func (s *UpdateConfigurationRecorderResponseBodyConfigurationRecorder) SetResourceTypes(v []*string) *UpdateConfigurationRecorderResponseBodyConfigurationRecorder {
	s.ResourceTypes = v
	return s
}

type UpdateConfigurationRecorderResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateConfigurationRecorderResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateConfigurationRecorderResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateConfigurationRecorderResponse) GoString() string {
	return s.String()
}

func (s *UpdateConfigurationRecorderResponse) SetHeaders(v map[string]*string) *UpdateConfigurationRecorderResponse {
	s.Headers = v
	return s
}

func (s *UpdateConfigurationRecorderResponse) SetStatusCode(v int32) *UpdateConfigurationRecorderResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateConfigurationRecorderResponse) SetBody(v *UpdateConfigurationRecorderResponseBody) *UpdateConfigurationRecorderResponse {
	s.Body = v
	return s
}

type UpdateDeliveryChannelRequest struct {
	// The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.
	//
	// The `token` can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [Ensure idempotence](~~25693~~)
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to deliver resource change logs. If the value of this parameter is true, Cloud Config delivers the resource change logs to OSS, Log Service, or MNS when the configurations of the resources change. Valid values:
	//
	// *   true
	// *   false (default)
	//
	// > This parameter is available for delivery channels of the OSS, Log Service, and MNS types.
	ConfigurationItemChangeNotification *bool `json:"ConfigurationItemChangeNotification,omitempty" xml:"ConfigurationItemChangeNotification,omitempty"`
	// Specifies whether to deliver scheduled resource snapshots to the OSS bucket. If the value of this parameter is true, the scheduled resource snapshots are delivered to the specified OSS bucket at 00:00:00 and 12:00:00 on a daily basis. Valid values:
	//
	// *   true
	// *   false (default)
	//
	// > This parameter is applicable only to delivery channels of the OSS type.
	ConfigurationSnapshot *bool `json:"ConfigurationSnapshot,omitempty" xml:"ConfigurationSnapshot,omitempty"`
	// The ARN of the role that you want to assign to the delivery channel. Specify the ARN in the following format: `acs:ram::{accountId}:role/aliyunserviceroleforconfig`.
	DeliveryChannelAssumeRoleArn *string `json:"DeliveryChannelAssumeRoleArn,omitempty" xml:"DeliveryChannelAssumeRoleArn,omitempty"`
	// The rule that is attached to the delivery channel. This parameter is available only for delivery channels of the MNS type.
	//
	// This parameter specifies the lowest risk level and the resource types for the events to which you want to subscribe.
	//
	// *   The setting of the lowest risk level for the events to which you want to subscribe is in the following format: `{"filterType":"RuleRiskLevel","value":"1","multiple":false}`.
	//
	//     The `value` field specifies the lowest risk level of the events to which you want to subscribe. Valid values: 1, 2, and 3. The value 1 indicates the high risk level. The value 2 indicates the medium risk level. The value 3 indicates the low risk level.
	//
	// *   The setting of the resource types of the events to which you want to subscribe is in the following format: `{"filterType":"ResourceType","values":["ACS::ACK::Cluster","ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage"],"multiple":true}`.
	//
	//     The `values` field specifies the resource types of the events to which you want to subscribe. The value of the field is a JSON array. Examples:
	//
	// `[{"filterType":"ResourceType","values":["ACS::ActionTrail::Trail","ACS::CBWP::CommonBandwidthPackage","ACS::CDN::Domain","ACS::CEN::CenBandwidthPackage","ACS::CEN::CenInstance","ACS::CEN::Flowlog","ACS::DdosCoo::Instance"],"multiple":true}]`
	DeliveryChannelCondition *string `json:"DeliveryChannelCondition,omitempty" xml:"DeliveryChannelCondition,omitempty"`
	// The ID of the delivery channel.
	//
	// For more information about how to obtain the ID of the delivery channel, see [DescribeDeliveryChannels](~~174466~~).
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
	// The name of the delivery channel.
	//
	// > If you do not configure this parameter, this parameter is left empty.
	DeliveryChannelName *string `json:"DeliveryChannelName,omitempty" xml:"DeliveryChannelName,omitempty"`
	// The ARN of the delivery destination. Valid values:
	//
	// *   `acs:oss:{RegionId}:{accountId}:{bucketName}` if your delivery destination is an OSS bucket. Example: `acs:oss:cn-shanghai:100931896542****:new-bucket`.
	// *   `acs:mns:{RegionId}:{accountId}:/topics/{topicName}` if your delivery destination is an MNS topic. Example: `acs:mns:cn-shanghai:100931896542****:/topics/topic1`.
	// *   `acs:log:{RegionId}:{accountId}:project/{projectName}/logstore/{logstoreName}` if your delivery destination is a Log Service Logstore. Example: `acs:log:cn-shanghai:100931896542****:project/project1/logstore/logstore1`.
	DeliveryChannelTargetArn *string `json:"DeliveryChannelTargetArn,omitempty" xml:"DeliveryChannelTargetArn,omitempty"`
	// The description of the delivery channel.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to deliver resource non-compliance events. If the value of this parameter is true, Cloud Config delivers resource non-compliance events to Log Service or MNS when resources are evaluated as non-compliant. Valid values:
	//
	// *   true
	// *   false (default)
	//
	// > This parameter is available only for delivery channels of the Log Service or MNS type.
	NonCompliantNotification *bool `json:"NonCompliantNotification,omitempty" xml:"NonCompliantNotification,omitempty"`
	// The ARN of the OSS bucket to which you want to transfer the delivery data when the size of the data exceeds the specified upper limit of the delivery channel. Format: `acs:oss:{RegionId}:{accountId}:{bucketName}`.
	//
	// If you do not configure this parameter, Cloud Config delivers only summary data.
	//
	// > This parameter is available only for delivery channels of the Log Service or MNS type. The maximum storage size of delivery channels of the Log Service type is 1 MB, and the maximum storage size of delivery channels of the MNS type is 64 KB.
	OversizedDataOSSTargetArn *string `json:"OversizedDataOSSTargetArn,omitempty" xml:"OversizedDataOSSTargetArn,omitempty"`
	// Specifies whether to enable the delivery channel. Valid values:
	//
	// *   0: The delivery channel is disabled for Cloud Config. Cloud Config retains the most recent delivery configuration and stops resource data delivery.
	// *   1 (default): The delivery channel is enabled for Cloud Config.
	Status *int64 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateDeliveryChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDeliveryChannelRequest) GoString() string {
	return s.String()
}

func (s *UpdateDeliveryChannelRequest) SetClientToken(v string) *UpdateDeliveryChannelRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateDeliveryChannelRequest) SetConfigurationItemChangeNotification(v bool) *UpdateDeliveryChannelRequest {
	s.ConfigurationItemChangeNotification = &v
	return s
}

func (s *UpdateDeliveryChannelRequest) SetConfigurationSnapshot(v bool) *UpdateDeliveryChannelRequest {
	s.ConfigurationSnapshot = &v
	return s
}

func (s *UpdateDeliveryChannelRequest) SetDeliveryChannelAssumeRoleArn(v string) *UpdateDeliveryChannelRequest {
	s.DeliveryChannelAssumeRoleArn = &v
	return s
}

func (s *UpdateDeliveryChannelRequest) SetDeliveryChannelCondition(v string) *UpdateDeliveryChannelRequest {
	s.DeliveryChannelCondition = &v
	return s
}

func (s *UpdateDeliveryChannelRequest) SetDeliveryChannelId(v string) *UpdateDeliveryChannelRequest {
	s.DeliveryChannelId = &v
	return s
}

func (s *UpdateDeliveryChannelRequest) SetDeliveryChannelName(v string) *UpdateDeliveryChannelRequest {
	s.DeliveryChannelName = &v
	return s
}

func (s *UpdateDeliveryChannelRequest) SetDeliveryChannelTargetArn(v string) *UpdateDeliveryChannelRequest {
	s.DeliveryChannelTargetArn = &v
	return s
}

func (s *UpdateDeliveryChannelRequest) SetDescription(v string) *UpdateDeliveryChannelRequest {
	s.Description = &v
	return s
}

func (s *UpdateDeliveryChannelRequest) SetNonCompliantNotification(v bool) *UpdateDeliveryChannelRequest {
	s.NonCompliantNotification = &v
	return s
}

func (s *UpdateDeliveryChannelRequest) SetOversizedDataOSSTargetArn(v string) *UpdateDeliveryChannelRequest {
	s.OversizedDataOSSTargetArn = &v
	return s
}

func (s *UpdateDeliveryChannelRequest) SetStatus(v int64) *UpdateDeliveryChannelRequest {
	s.Status = &v
	return s
}

type UpdateDeliveryChannelResponseBody struct {
	// The ID of the delivery channel.
	DeliveryChannelId *string `json:"DeliveryChannelId,omitempty" xml:"DeliveryChannelId,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDeliveryChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDeliveryChannelResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDeliveryChannelResponseBody) SetDeliveryChannelId(v string) *UpdateDeliveryChannelResponseBody {
	s.DeliveryChannelId = &v
	return s
}

func (s *UpdateDeliveryChannelResponseBody) SetRequestId(v string) *UpdateDeliveryChannelResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDeliveryChannelResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDeliveryChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDeliveryChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDeliveryChannelResponse) GoString() string {
	return s.String()
}

func (s *UpdateDeliveryChannelResponse) SetHeaders(v map[string]*string) *UpdateDeliveryChannelResponse {
	s.Headers = v
	return s
}

func (s *UpdateDeliveryChannelResponse) SetStatusCode(v int32) *UpdateDeliveryChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDeliveryChannelResponse) SetBody(v *UpdateDeliveryChannelResponseBody) *UpdateDeliveryChannelResponse {
	s.Body = v
	return s
}

type UpdateIntegratedServiceStatusRequest struct {
	// The product code of the cloud product. Valid values:
	//
	// *   cadt: Cloud Architecture Design Tool
	ServiceCode *string `json:"ServiceCode,omitempty" xml:"ServiceCode,omitempty"`
	// Specifies whether you want the product to be integrated. Valid values:
	//
	// *   true
	// *   false
	Status *bool `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateIntegratedServiceStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateIntegratedServiceStatusRequest) GoString() string {
	return s.String()
}

func (s *UpdateIntegratedServiceStatusRequest) SetServiceCode(v string) *UpdateIntegratedServiceStatusRequest {
	s.ServiceCode = &v
	return s
}

func (s *UpdateIntegratedServiceStatusRequest) SetStatus(v bool) *UpdateIntegratedServiceStatusRequest {
	s.Status = &v
	return s
}

type UpdateIntegratedServiceStatusResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateIntegratedServiceStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateIntegratedServiceStatusResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateIntegratedServiceStatusResponseBody) SetRequestId(v string) *UpdateIntegratedServiceStatusResponseBody {
	s.RequestId = &v
	return s
}

type UpdateIntegratedServiceStatusResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateIntegratedServiceStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateIntegratedServiceStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateIntegratedServiceStatusResponse) GoString() string {
	return s.String()
}

func (s *UpdateIntegratedServiceStatusResponse) SetHeaders(v map[string]*string) *UpdateIntegratedServiceStatusResponse {
	s.Headers = v
	return s
}

func (s *UpdateIntegratedServiceStatusResponse) SetStatusCode(v int32) *UpdateIntegratedServiceStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateIntegratedServiceStatusResponse) SetBody(v *UpdateIntegratedServiceStatusResponseBody) *UpdateIntegratedServiceStatusResponse {
	s.Body = v
	return s
}

type UpdateRemediationRequest struct {
	// The client token that is used to ensure the idempotency of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The execution mode of the remediation. Valid values:
	//
	// *   NON_EXECUTION: The remediation is not executed.
	// *   AUTO_EXECUTION: The remediation is automatically executed.
	// *   MANUAL_EXECUTION: The remediation is manually executed.
	// *   NOT_CONFIG: The execution mode is not specified.
	InvokeType *string `json:"InvokeType,omitempty" xml:"InvokeType,omitempty"`
	// The desired parameter values of the remediation setting.
	Params *string `json:"Params,omitempty" xml:"Params,omitempty"`
	// The ID of the remediation setting.
	//
	// You can call the [ListRemediations](~~270772~~) operation to obtain the ID of the remediation setting.
	RemediationId *string `json:"RemediationId,omitempty" xml:"RemediationId,omitempty"`
	// The ID of the remediation template.
	//
	// You can call the [ListRemediationTemplates](~~270066~~) operation to obtain the ID of the remediation template.
	RemediationTemplateId *string `json:"RemediationTemplateId,omitempty" xml:"RemediationTemplateId,omitempty"`
	// The type of the remediation template. Valid values:
	//
	// *   OOS: Operation Orchestration Service (OOS)
	// *   FC: Function Compute. You can use Function Compute to configure custom remediation settings.
	RemediationType *string `json:"RemediationType,omitempty" xml:"RemediationType,omitempty"`
	// The source of the remediation setting. Valid values:
	//
	// *   ALIYUN: the default remediation setting of Alibaba Cloud.
	// *   CUSTOM: a custom remediation setting.
	// *   NONE: The source is not specified.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s UpdateRemediationRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateRemediationRequest) GoString() string {
	return s.String()
}

func (s *UpdateRemediationRequest) SetClientToken(v string) *UpdateRemediationRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateRemediationRequest) SetInvokeType(v string) *UpdateRemediationRequest {
	s.InvokeType = &v
	return s
}

func (s *UpdateRemediationRequest) SetParams(v string) *UpdateRemediationRequest {
	s.Params = &v
	return s
}

func (s *UpdateRemediationRequest) SetRemediationId(v string) *UpdateRemediationRequest {
	s.RemediationId = &v
	return s
}

func (s *UpdateRemediationRequest) SetRemediationTemplateId(v string) *UpdateRemediationRequest {
	s.RemediationTemplateId = &v
	return s
}

func (s *UpdateRemediationRequest) SetRemediationType(v string) *UpdateRemediationRequest {
	s.RemediationType = &v
	return s
}

func (s *UpdateRemediationRequest) SetSourceType(v string) *UpdateRemediationRequest {
	s.SourceType = &v
	return s
}

type UpdateRemediationResponseBody struct {
	// The ID of the remediation setting.
	RemediationId *string `json:"RemediationId,omitempty" xml:"RemediationId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateRemediationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateRemediationResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateRemediationResponseBody) SetRemediationId(v string) *UpdateRemediationResponseBody {
	s.RemediationId = &v
	return s
}

func (s *UpdateRemediationResponseBody) SetRequestId(v string) *UpdateRemediationResponseBody {
	s.RequestId = &v
	return s
}

type UpdateRemediationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateRemediationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateRemediationResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateRemediationResponse) GoString() string {
	return s.String()
}

func (s *UpdateRemediationResponse) SetHeaders(v map[string]*string) *UpdateRemediationResponse {
	s.Headers = v
	return s
}

func (s *UpdateRemediationResponse) SetStatusCode(v int32) *UpdateRemediationResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateRemediationResponse) SetBody(v *UpdateRemediationResponseBody) *UpdateRemediationResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("central")
	client.EndpointMap = map[string]*string{
		"cn-shanghai":    tea.String("config.cn-shanghai.aliyuncs.com"),
		"ap-southeast-1": tea.String("config.ap-southeast-1.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("config"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to enable the `cr-5772ba41209e007b****` rule in the `ca-a4e5626622af0079****` account group.
 *
 * @param request ActiveAggregateConfigRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ActiveAggregateConfigRulesResponse
 */
func (client *Client) ActiveAggregateConfigRulesWithOptions(request *ActiveAggregateConfigRulesRequest, runtime *util.RuntimeOptions) (_result *ActiveAggregateConfigRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ActiveAggregateConfigRules"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ActiveAggregateConfigRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to enable the `cr-5772ba41209e007b****` rule in the `ca-a4e5626622af0079****` account group.
 *
 * @param request ActiveAggregateConfigRulesRequest
 * @return ActiveAggregateConfigRulesResponse
 */
func (client *Client) ActiveAggregateConfigRules(request *ActiveAggregateConfigRulesRequest) (_result *ActiveAggregateConfigRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ActiveAggregateConfigRulesResponse{}
	_body, _err := client.ActiveAggregateConfigRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ActiveConfigRulesWithOptions(request *ActiveConfigRulesRequest, runtime *util.RuntimeOptions) (_result *ActiveConfigRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ActiveConfigRules"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ActiveConfigRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ActiveConfigRules(request *ActiveConfigRulesRequest) (_result *ActiveConfigRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ActiveConfigRulesResponse{}
	_body, _err := client.ActiveConfigRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The sample request in this topic shows you how to add the `cr-6cc4626622af00e7****` rule in the `ca-75b4626622af00c3****` account group to the `cp-5bb1626622af00bd****` compliance package.
 *
 * @param request AttachAggregateConfigRuleToCompliancePackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachAggregateConfigRuleToCompliancePackResponse
 */
func (client *Client) AttachAggregateConfigRuleToCompliancePackWithOptions(request *AttachAggregateConfigRuleToCompliancePackRequest, runtime *util.RuntimeOptions) (_result *AttachAggregateConfigRuleToCompliancePackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackId)) {
		query["CompliancePackId"] = request.CompliancePackId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachAggregateConfigRuleToCompliancePack"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachAggregateConfigRuleToCompliancePackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The sample request in this topic shows you how to add the `cr-6cc4626622af00e7****` rule in the `ca-75b4626622af00c3****` account group to the `cp-5bb1626622af00bd****` compliance package.
 *
 * @param request AttachAggregateConfigRuleToCompliancePackRequest
 * @return AttachAggregateConfigRuleToCompliancePackResponse
 */
func (client *Client) AttachAggregateConfigRuleToCompliancePack(request *AttachAggregateConfigRuleToCompliancePackRequest) (_result *AttachAggregateConfigRuleToCompliancePackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachAggregateConfigRuleToCompliancePackResponse{}
	_body, _err := client.AttachAggregateConfigRuleToCompliancePackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to add the `cr-6cc4626622af00e7****` rule to the `cp-5bb1626622af00bd****` compliance package.
 *
 * @param request AttachConfigRuleToCompliancePackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachConfigRuleToCompliancePackResponse
 */
func (client *Client) AttachConfigRuleToCompliancePackWithOptions(request *AttachConfigRuleToCompliancePackRequest, runtime *util.RuntimeOptions) (_result *AttachConfigRuleToCompliancePackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CompliancePackId)) {
		query["CompliancePackId"] = request.CompliancePackId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachConfigRuleToCompliancePack"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachConfigRuleToCompliancePackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to add the `cr-6cc4626622af00e7****` rule to the `cp-5bb1626622af00bd****` compliance package.
 *
 * @param request AttachConfigRuleToCompliancePackRequest
 * @return AttachConfigRuleToCompliancePackResponse
 */
func (client *Client) AttachConfigRuleToCompliancePack(request *AttachConfigRuleToCompliancePackRequest) (_result *AttachConfigRuleToCompliancePackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachConfigRuleToCompliancePackResponse{}
	_body, _err := client.AttachConfigRuleToCompliancePackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CopyCompliancePacksWithOptions(request *CopyCompliancePacksRequest, runtime *util.RuntimeOptions) (_result *CopyCompliancePacksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesAggregatorIds)) {
		query["DesAggregatorIds"] = request.DesAggregatorIds
	}

	if !tea.BoolValue(util.IsUnset(request.SrcAggregatorId)) {
		query["SrcAggregatorId"] = request.SrcAggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.SrcCompliancePackIds)) {
		query["SrcCompliancePackIds"] = request.SrcCompliancePackIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CopyCompliancePacks"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CopyCompliancePacksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CopyCompliancePacks(request *CopyCompliancePacksRequest) (_result *CopyCompliancePacksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CopyCompliancePacksResponse{}
	_body, _err := client.CopyCompliancePacksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CopyConfigRulesWithOptions(request *CopyConfigRulesRequest, runtime *util.RuntimeOptions) (_result *CopyConfigRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DesAggregatorIds)) {
		query["DesAggregatorIds"] = request.DesAggregatorIds
	}

	if !tea.BoolValue(util.IsUnset(request.SrcAggregatorId)) {
		query["SrcAggregatorId"] = request.SrcAggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.SrcConfigRuleIds)) {
		query["SrcConfigRuleIds"] = request.SrcConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CopyConfigRules"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CopyConfigRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CopyConfigRules(request *CopyConfigRulesRequest) (_result *CopyConfigRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CopyConfigRulesResponse{}
	_body, _err := client.CopyConfigRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateAdvancedSearchFileWithOptions(request *CreateAdvancedSearchFileRequest, runtime *util.RuntimeOptions) (_result *CreateAdvancedSearchFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Sql)) {
		query["Sql"] = request.Sql
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAdvancedSearchFile"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAdvancedSearchFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateAdvancedSearchFile(request *CreateAdvancedSearchFileRequest) (_result *CreateAdvancedSearchFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAdvancedSearchFileResponse{}
	_body, _err := client.CreateAdvancedSearchFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateAggregateAdvancedSearchFileWithOptions(request *CreateAggregateAdvancedSearchFileRequest, runtime *util.RuntimeOptions) (_result *CreateAggregateAdvancedSearchFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.Sql)) {
		query["Sql"] = request.Sql
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAggregateAdvancedSearchFile"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAggregateAdvancedSearchFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateAggregateAdvancedSearchFile(request *CreateAggregateAdvancedSearchFileRequest) (_result *CreateAggregateAdvancedSearchFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAggregateAdvancedSearchFileResponse{}
	_body, _err := client.CreateAggregateAdvancedSearchFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can use your management account to create up to five compliance packages for each account group.
 * This topic provides an example on how to create a compliance package named ClassifiedProtectionPreCheck for the `ca-f632626622af0079****` account group. The compliance package contains the `eip-bandwidth-limit` managed rule.
 *
 * @param tmpReq CreateAggregateCompliancePackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAggregateCompliancePackResponse
 */
func (client *Client) CreateAggregateCompliancePackWithOptions(tmpReq *CreateAggregateCompliancePackRequest, runtime *util.RuntimeOptions) (_result *CreateAggregateCompliancePackResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateAggregateCompliancePackShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ConfigRules)) {
		request.ConfigRulesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ConfigRules, tea.String("ConfigRules"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		body["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackName)) {
		body["CompliancePackName"] = request.CompliancePackName
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackTemplateId)) {
		body["CompliancePackTemplateId"] = request.CompliancePackTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRulesShrink)) {
		body["ConfigRules"] = request.ConfigRulesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultEnable)) {
		body["DefaultEnable"] = request.DefaultEnable
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeResourceIdsScope)) {
		body["ExcludeResourceIdsScope"] = request.ExcludeResourceIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.RegionIdsScope)) {
		body["RegionIdsScope"] = request.RegionIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupIdsScope)) {
		body["ResourceGroupIdsScope"] = request.ResourceGroupIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.RiskLevel)) {
		body["RiskLevel"] = request.RiskLevel
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeyScope)) {
		body["TagKeyScope"] = request.TagKeyScope
	}

	if !tea.BoolValue(util.IsUnset(request.TagValueScope)) {
		body["TagValueScope"] = request.TagValueScope
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAggregateCompliancePack"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAggregateCompliancePackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can use your management account to create up to five compliance packages for each account group.
 * This topic provides an example on how to create a compliance package named ClassifiedProtectionPreCheck for the `ca-f632626622af0079****` account group. The compliance package contains the `eip-bandwidth-limit` managed rule.
 *
 * @param request CreateAggregateCompliancePackRequest
 * @return CreateAggregateCompliancePackResponse
 */
func (client *Client) CreateAggregateCompliancePack(request *CreateAggregateCompliancePackRequest) (_result *CreateAggregateCompliancePackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAggregateCompliancePackResponse{}
	_body, _err := client.CreateAggregateCompliancePackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In this example, a delivery channel is created for an account group. The ID of the account group is `ca-a4e5626622af0079****`. The type of the delivery channel is `OSS` and the Alibaba Cloud Resource Name (ARN) of the delivery destination is `acs:oss:cn-shanghai:100931896542****:new-bucket`. The result indicates that the delivery channel is created. The ID of the delivery channel is `cdc-8e45ff4e06a3a8****`.
 *
 * @param request CreateAggregateConfigDeliveryChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAggregateConfigDeliveryChannelResponse
 */
func (client *Client) CreateAggregateConfigDeliveryChannelWithOptions(request *CreateAggregateConfigDeliveryChannelRequest, runtime *util.RuntimeOptions) (_result *CreateAggregateConfigDeliveryChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigurationItemChangeNotification)) {
		query["ConfigurationItemChangeNotification"] = request.ConfigurationItemChangeNotification
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigurationSnapshot)) {
		query["ConfigurationSnapshot"] = request.ConfigurationSnapshot
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelCondition)) {
		query["DeliveryChannelCondition"] = request.DeliveryChannelCondition
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelName)) {
		query["DeliveryChannelName"] = request.DeliveryChannelName
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelTargetArn)) {
		query["DeliveryChannelTargetArn"] = request.DeliveryChannelTargetArn
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelType)) {
		query["DeliveryChannelType"] = request.DeliveryChannelType
	}

	if !tea.BoolValue(util.IsUnset(request.DeliverySnapshotTime)) {
		query["DeliverySnapshotTime"] = request.DeliverySnapshotTime
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.NonCompliantNotification)) {
		query["NonCompliantNotification"] = request.NonCompliantNotification
	}

	if !tea.BoolValue(util.IsUnset(request.OversizedDataOSSTargetArn)) {
		query["OversizedDataOSSTargetArn"] = request.OversizedDataOSSTargetArn
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAggregateConfigDeliveryChannel"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAggregateConfigDeliveryChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In this example, a delivery channel is created for an account group. The ID of the account group is `ca-a4e5626622af0079****`. The type of the delivery channel is `OSS` and the Alibaba Cloud Resource Name (ARN) of the delivery destination is `acs:oss:cn-shanghai:100931896542****:new-bucket`. The result indicates that the delivery channel is created. The ID of the delivery channel is `cdc-8e45ff4e06a3a8****`.
 *
 * @param request CreateAggregateConfigDeliveryChannelRequest
 * @return CreateAggregateConfigDeliveryChannelResponse
 */
func (client *Client) CreateAggregateConfigDeliveryChannel(request *CreateAggregateConfigDeliveryChannelRequest) (_result *CreateAggregateConfigDeliveryChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAggregateConfigDeliveryChannelResponse{}
	_body, _err := client.CreateAggregateConfigDeliveryChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Limits
 * You can create up to 200 rules for each management account.
 * ### Usage notes
 * This topic provides an example on how to create a rule based on the required-tags managed rule in the `ca-a4e5626622af0079****` account group. The returned result shows that the rule is created and its ID is `cr-4e3d626622af0080****`.
 *
 * @param tmpReq CreateAggregateConfigRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAggregateConfigRuleResponse
 */
func (client *Client) CreateAggregateConfigRuleWithOptions(tmpReq *CreateAggregateConfigRuleRequest, runtime *util.RuntimeOptions) (_result *CreateAggregateConfigRuleResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateAggregateConfigRuleShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.InputParameters)) {
		request.InputParametersShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.InputParameters, tea.String("InputParameters"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.ResourceTypesScope)) {
		request.ResourceTypesScopeShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ResourceTypesScope, tea.String("ResourceTypesScope"), tea.String("simple"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		body["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleName)) {
		body["ConfigRuleName"] = request.ConfigRuleName
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleTriggerTypes)) {
		body["ConfigRuleTriggerTypes"] = request.ConfigRuleTriggerTypes
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeAccountIdsScope)) {
		body["ExcludeAccountIdsScope"] = request.ExcludeAccountIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeFolderIdsScope)) {
		body["ExcludeFolderIdsScope"] = request.ExcludeFolderIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeResourceIdsScope)) {
		body["ExcludeResourceIdsScope"] = request.ExcludeResourceIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.FolderIdsScope)) {
		body["FolderIdsScope"] = request.FolderIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.InputParametersShrink)) {
		body["InputParameters"] = request.InputParametersShrink
	}

	if !tea.BoolValue(util.IsUnset(request.MaximumExecutionFrequency)) {
		body["MaximumExecutionFrequency"] = request.MaximumExecutionFrequency
	}

	if !tea.BoolValue(util.IsUnset(request.RegionIdsScope)) {
		body["RegionIdsScope"] = request.RegionIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupIdsScope)) {
		body["ResourceGroupIdsScope"] = request.ResourceGroupIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceTypesScopeShrink)) {
		body["ResourceTypesScope"] = request.ResourceTypesScopeShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RiskLevel)) {
		body["RiskLevel"] = request.RiskLevel
	}

	if !tea.BoolValue(util.IsUnset(request.SourceIdentifier)) {
		body["SourceIdentifier"] = request.SourceIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.SourceOwner)) {
		body["SourceOwner"] = request.SourceOwner
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeyLogicScope)) {
		body["TagKeyLogicScope"] = request.TagKeyLogicScope
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeyScope)) {
		body["TagKeyScope"] = request.TagKeyScope
	}

	if !tea.BoolValue(util.IsUnset(request.TagValueScope)) {
		body["TagValueScope"] = request.TagValueScope
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAggregateConfigRule"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAggregateConfigRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Limits
 * You can create up to 200 rules for each management account.
 * ### Usage notes
 * This topic provides an example on how to create a rule based on the required-tags managed rule in the `ca-a4e5626622af0079****` account group. The returned result shows that the rule is created and its ID is `cr-4e3d626622af0080****`.
 *
 * @param request CreateAggregateConfigRuleRequest
 * @return CreateAggregateConfigRuleResponse
 */
func (client *Client) CreateAggregateConfigRule(request *CreateAggregateConfigRuleRequest) (_result *CreateAggregateConfigRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAggregateConfigRuleResponse{}
	_body, _err := client.CreateAggregateConfigRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to create a remediation template for the rule whose ID is `cr-6b7c626622af00b4****` in the account group whose ID is `ca-6b4a626622af0012****`. The returned result shows that a remediation template is created and the ID of the remediation template is `crr-909ba2d4716700eb****`.
 *
 * @param request CreateAggregateRemediationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAggregateRemediationResponse
 */
func (client *Client) CreateAggregateRemediationWithOptions(request *CreateAggregateRemediationRequest, runtime *util.RuntimeOptions) (_result *CreateAggregateRemediationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		body["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		body["ConfigRuleId"] = request.ConfigRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.InvokeType)) {
		body["InvokeType"] = request.InvokeType
	}

	if !tea.BoolValue(util.IsUnset(request.Params)) {
		body["Params"] = request.Params
	}

	if !tea.BoolValue(util.IsUnset(request.RemediationTemplateId)) {
		body["RemediationTemplateId"] = request.RemediationTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.RemediationType)) {
		body["RemediationType"] = request.RemediationType
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		body["SourceType"] = request.SourceType
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAggregateRemediation"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAggregateRemediationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to create a remediation template for the rule whose ID is `cr-6b7c626622af00b4****` in the account group whose ID is `ca-6b4a626622af0012****`. The returned result shows that a remediation template is created and the ID of the remediation template is `crr-909ba2d4716700eb****`.
 *
 * @param request CreateAggregateRemediationRequest
 * @return CreateAggregateRemediationResponse
 */
func (client *Client) CreateAggregateRemediation(request *CreateAggregateRemediationRequest) (_result *CreateAggregateRemediationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAggregateRemediationResponse{}
	_body, _err := client.CreateAggregateRemediationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Each management account can create a maximum of five account groups. Each account group can contain a maximum of 200 member accounts.
 * Cloud Config supports the following types of account groups:
 * *   Global account group: The global account group contains all the member accounts that are added to the resource directory. A management account can create only one global account group.
 * *   Custom account group: If you create a custom account group, you must manually add all or specific member accounts from the resource directory to the custom account group.
 * This topic provides an example on how to create an account group of the `CUSTOM` type. The custom account group is named `Test_Group`, and its description is `Test account group`. The custom account group contains the following two member accounts:
 * *   Member account ID: `171322098523****`. Member account name: `Alice`.
 * *   Member account ID: `100532098349****`. Member account name: `Tom`.
 *
 * @param tmpReq CreateAggregatorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAggregatorResponse
 */
func (client *Client) CreateAggregatorWithOptions(tmpReq *CreateAggregatorRequest, runtime *util.RuntimeOptions) (_result *CreateAggregatorResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateAggregatorShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.AggregatorAccounts)) {
		request.AggregatorAccountsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.AggregatorAccounts, tea.String("AggregatorAccounts"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorAccountsShrink)) {
		body["AggregatorAccounts"] = request.AggregatorAccountsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.AggregatorName)) {
		body["AggregatorName"] = request.AggregatorName
	}

	if !tea.BoolValue(util.IsUnset(request.AggregatorType)) {
		body["AggregatorType"] = request.AggregatorType
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateAggregator"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateAggregatorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Each management account can create a maximum of five account groups. Each account group can contain a maximum of 200 member accounts.
 * Cloud Config supports the following types of account groups:
 * *   Global account group: The global account group contains all the member accounts that are added to the resource directory. A management account can create only one global account group.
 * *   Custom account group: If you create a custom account group, you must manually add all or specific member accounts from the resource directory to the custom account group.
 * This topic provides an example on how to create an account group of the `CUSTOM` type. The custom account group is named `Test_Group`, and its description is `Test account group`. The custom account group contains the following two member accounts:
 * *   Member account ID: `171322098523****`. Member account name: `Alice`.
 * *   Member account ID: `100532098349****`. Member account name: `Tom`.
 *
 * @param request CreateAggregatorRequest
 * @return CreateAggregatorResponse
 */
func (client *Client) CreateAggregator(request *CreateAggregatorRequest) (_result *CreateAggregatorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateAggregatorResponse{}
	_body, _err := client.CreateAggregatorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Each ordinary account can create up to five compliance packages.
 * This topic provides an example on how to create a compliance package named ClassifiedProtectionPreCheck. The compliance package contains a managed rule named `eip-bandwidth-limit`.
 *
 * @param tmpReq CreateCompliancePackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCompliancePackResponse
 */
func (client *Client) CreateCompliancePackWithOptions(tmpReq *CreateCompliancePackRequest, runtime *util.RuntimeOptions) (_result *CreateCompliancePackResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateCompliancePackShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ConfigRules)) {
		request.ConfigRulesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ConfigRules, tea.String("ConfigRules"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackName)) {
		body["CompliancePackName"] = request.CompliancePackName
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackTemplateId)) {
		body["CompliancePackTemplateId"] = request.CompliancePackTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRulesShrink)) {
		body["ConfigRules"] = request.ConfigRulesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.DefaultEnable)) {
		body["DefaultEnable"] = request.DefaultEnable
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeResourceIdsScope)) {
		body["ExcludeResourceIdsScope"] = request.ExcludeResourceIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.RegionIdsScope)) {
		body["RegionIdsScope"] = request.RegionIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupIdsScope)) {
		body["ResourceGroupIdsScope"] = request.ResourceGroupIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.RiskLevel)) {
		body["RiskLevel"] = request.RiskLevel
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeyScope)) {
		body["TagKeyScope"] = request.TagKeyScope
	}

	if !tea.BoolValue(util.IsUnset(request.TagValueScope)) {
		body["TagValueScope"] = request.TagValueScope
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCompliancePack"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCompliancePackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Each ordinary account can create up to five compliance packages.
 * This topic provides an example on how to create a compliance package named ClassifiedProtectionPreCheck. The compliance package contains a managed rule named `eip-bandwidth-limit`.
 *
 * @param request CreateCompliancePackRequest
 * @return CreateCompliancePackResponse
 */
func (client *Client) CreateCompliancePack(request *CreateCompliancePackRequest) (_result *CreateCompliancePackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCompliancePackResponse{}
	_body, _err := client.CreateCompliancePackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In this example, a delivery channel is created. The type of the delivery channel is `OSS` and the Alibaba Cloud Resource Name (ARN) of the delivery destination is `acs:oss:cn-shanghai:100931896542****:new-bucket`. The result indicates that the delivery channel is created, and the ID of the delivery channel is `cdc-8e45ff4e06a3a8****`.
 *
 * @param request CreateConfigDeliveryChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConfigDeliveryChannelResponse
 */
func (client *Client) CreateConfigDeliveryChannelWithOptions(request *CreateConfigDeliveryChannelRequest, runtime *util.RuntimeOptions) (_result *CreateConfigDeliveryChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigurationItemChangeNotification)) {
		query["ConfigurationItemChangeNotification"] = request.ConfigurationItemChangeNotification
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigurationSnapshot)) {
		query["ConfigurationSnapshot"] = request.ConfigurationSnapshot
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelCondition)) {
		query["DeliveryChannelCondition"] = request.DeliveryChannelCondition
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelName)) {
		query["DeliveryChannelName"] = request.DeliveryChannelName
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelTargetArn)) {
		query["DeliveryChannelTargetArn"] = request.DeliveryChannelTargetArn
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelType)) {
		query["DeliveryChannelType"] = request.DeliveryChannelType
	}

	if !tea.BoolValue(util.IsUnset(request.DeliverySnapshotTime)) {
		query["DeliverySnapshotTime"] = request.DeliverySnapshotTime
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.NonCompliantNotification)) {
		query["NonCompliantNotification"] = request.NonCompliantNotification
	}

	if !tea.BoolValue(util.IsUnset(request.OversizedDataOSSTargetArn)) {
		query["OversizedDataOSSTargetArn"] = request.OversizedDataOSSTargetArn
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateConfigDeliveryChannel"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateConfigDeliveryChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In this example, a delivery channel is created. The type of the delivery channel is `OSS` and the Alibaba Cloud Resource Name (ARN) of the delivery destination is `acs:oss:cn-shanghai:100931896542****:new-bucket`. The result indicates that the delivery channel is created, and the ID of the delivery channel is `cdc-8e45ff4e06a3a8****`.
 *
 * @param request CreateConfigDeliveryChannelRequest
 * @return CreateConfigDeliveryChannelResponse
 */
func (client *Client) CreateConfigDeliveryChannel(request *CreateConfigDeliveryChannelRequest) (_result *CreateConfigDeliveryChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateConfigDeliveryChannelResponse{}
	_body, _err := client.CreateConfigDeliveryChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Limits
 * You can use an ordinary account to create up to 200 rules.
 * ### Usage notes
 * This topic provides an example on how to create a managed rule named required-tags. The returned result indicates that the rule is created and the ID of the rule is `cr-5772ba41209e007b****`.
 *
 * @param tmpReq CreateConfigRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConfigRuleResponse
 */
func (client *Client) CreateConfigRuleWithOptions(tmpReq *CreateConfigRuleRequest, runtime *util.RuntimeOptions) (_result *CreateConfigRuleResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateConfigRuleShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.InputParameters)) {
		request.InputParametersShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.InputParameters, tea.String("InputParameters"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.ResourceTypesScope)) {
		request.ResourceTypesScopeShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ResourceTypesScope, tea.String("ResourceTypesScope"), tea.String("simple"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleName)) {
		body["ConfigRuleName"] = request.ConfigRuleName
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleTriggerTypes)) {
		body["ConfigRuleTriggerTypes"] = request.ConfigRuleTriggerTypes
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeResourceIdsScope)) {
		body["ExcludeResourceIdsScope"] = request.ExcludeResourceIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.InputParametersShrink)) {
		body["InputParameters"] = request.InputParametersShrink
	}

	if !tea.BoolValue(util.IsUnset(request.MaximumExecutionFrequency)) {
		body["MaximumExecutionFrequency"] = request.MaximumExecutionFrequency
	}

	if !tea.BoolValue(util.IsUnset(request.RegionIdsScope)) {
		body["RegionIdsScope"] = request.RegionIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupIdsScope)) {
		body["ResourceGroupIdsScope"] = request.ResourceGroupIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceTypesScopeShrink)) {
		body["ResourceTypesScope"] = request.ResourceTypesScopeShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RiskLevel)) {
		body["RiskLevel"] = request.RiskLevel
	}

	if !tea.BoolValue(util.IsUnset(request.SourceIdentifier)) {
		body["SourceIdentifier"] = request.SourceIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.SourceOwner)) {
		body["SourceOwner"] = request.SourceOwner
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeyLogicScope)) {
		body["TagKeyLogicScope"] = request.TagKeyLogicScope
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeyScope)) {
		body["TagKeyScope"] = request.TagKeyScope
	}

	if !tea.BoolValue(util.IsUnset(request.TagValueScope)) {
		body["TagValueScope"] = request.TagValueScope
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateConfigRule"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateConfigRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Limits
 * You can use an ordinary account to create up to 200 rules.
 * ### Usage notes
 * This topic provides an example on how to create a managed rule named required-tags. The returned result indicates that the rule is created and the ID of the rule is `cr-5772ba41209e007b****`.
 *
 * @param request CreateConfigRuleRequest
 * @return CreateConfigRuleResponse
 */
func (client *Client) CreateConfigRule(request *CreateConfigRuleRequest) (_result *CreateConfigRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateConfigRuleResponse{}
	_body, _err := client.CreateConfigRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated : CreateDeliveryChannel is deprecated, please use Config::2020-09-07::CreateConfigDeliveryChannel,Config::2020-09-07::CreateAggregateConfigDeliveryChannel instead.
 * In this example, a delivery channel is created. The type of the delivery channel is `OSS`, the Alibaba Cloud Resource Name (ARN) of the delivery destination is `acs:oss:cn-shanghai:100931896542****:new-bucket`, and the ARN of the role that is assigned to the delivery channel is `acs:ram::100931896542****:role/aliyunserviceroleforconfig`. The returned result shows that the delivery channel is created, and the ID of the delivery channel is `cdc-8e45ff4e06a3a8****`.
 *
 * @param request CreateDeliveryChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDeliveryChannelResponse
 */
// Deprecated
func (client *Client) CreateDeliveryChannelWithOptions(request *CreateDeliveryChannelRequest, runtime *util.RuntimeOptions) (_result *CreateDeliveryChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigurationItemChangeNotification)) {
		body["ConfigurationItemChangeNotification"] = request.ConfigurationItemChangeNotification
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigurationSnapshot)) {
		body["ConfigurationSnapshot"] = request.ConfigurationSnapshot
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelAssumeRoleArn)) {
		body["DeliveryChannelAssumeRoleArn"] = request.DeliveryChannelAssumeRoleArn
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelCondition)) {
		body["DeliveryChannelCondition"] = request.DeliveryChannelCondition
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelName)) {
		body["DeliveryChannelName"] = request.DeliveryChannelName
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelTargetArn)) {
		body["DeliveryChannelTargetArn"] = request.DeliveryChannelTargetArn
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelType)) {
		body["DeliveryChannelType"] = request.DeliveryChannelType
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.NonCompliantNotification)) {
		body["NonCompliantNotification"] = request.NonCompliantNotification
	}

	if !tea.BoolValue(util.IsUnset(request.OversizedDataOSSTargetArn)) {
		body["OversizedDataOSSTargetArn"] = request.OversizedDataOSSTargetArn
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDeliveryChannel"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDeliveryChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated : CreateDeliveryChannel is deprecated, please use Config::2020-09-07::CreateConfigDeliveryChannel,Config::2020-09-07::CreateAggregateConfigDeliveryChannel instead.
 * In this example, a delivery channel is created. The type of the delivery channel is `OSS`, the Alibaba Cloud Resource Name (ARN) of the delivery destination is `acs:oss:cn-shanghai:100931896542****:new-bucket`, and the ARN of the role that is assigned to the delivery channel is `acs:ram::100931896542****:role/aliyunserviceroleforconfig`. The returned result shows that the delivery channel is created, and the ID of the delivery channel is `cdc-8e45ff4e06a3a8****`.
 *
 * @param request CreateDeliveryChannelRequest
 * @return CreateDeliveryChannelResponse
 */
// Deprecated
func (client *Client) CreateDeliveryChannel(request *CreateDeliveryChannelRequest) (_result *CreateDeliveryChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDeliveryChannelResponse{}
	_body, _err := client.CreateDeliveryChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to create a remediation template for the rule `cr-8a973ac2e2be00a2****`. The returned result shows that a remediation template is created and the ID of the remediation template is `crr-909ba2d4716700eb****`.
 *
 * @param request CreateRemediationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRemediationResponse
 */
func (client *Client) CreateRemediationWithOptions(request *CreateRemediationRequest, runtime *util.RuntimeOptions) (_result *CreateRemediationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		body["ConfigRuleId"] = request.ConfigRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.InvokeType)) {
		body["InvokeType"] = request.InvokeType
	}

	if !tea.BoolValue(util.IsUnset(request.Params)) {
		body["Params"] = request.Params
	}

	if !tea.BoolValue(util.IsUnset(request.RemediationTemplateId)) {
		body["RemediationTemplateId"] = request.RemediationTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.RemediationType)) {
		body["RemediationType"] = request.RemediationType
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		body["SourceType"] = request.SourceType
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateRemediation"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateRemediationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to create a remediation template for the rule `cr-8a973ac2e2be00a2****`. The returned result shows that a remediation template is created and the ID of the remediation template is `crr-909ba2d4716700eb****`.
 *
 * @param request CreateRemediationRequest
 * @return CreateRemediationResponse
 */
func (client *Client) CreateRemediation(request *CreateRemediationRequest) (_result *CreateRemediationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateRemediationResponse{}
	_body, _err := client.CreateRemediationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to disable the `cr-5772ba41209e007b****` rule in the `ca-04b3fd170e340007****` account group.
 *
 * @param request DeactiveAggregateConfigRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeactiveAggregateConfigRulesResponse
 */
func (client *Client) DeactiveAggregateConfigRulesWithOptions(request *DeactiveAggregateConfigRulesRequest, runtime *util.RuntimeOptions) (_result *DeactiveAggregateConfigRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeactiveAggregateConfigRules"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeactiveAggregateConfigRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to disable the `cr-5772ba41209e007b****` rule in the `ca-04b3fd170e340007****` account group.
 *
 * @param request DeactiveAggregateConfigRulesRequest
 * @return DeactiveAggregateConfigRulesResponse
 */
func (client *Client) DeactiveAggregateConfigRules(request *DeactiveAggregateConfigRulesRequest) (_result *DeactiveAggregateConfigRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeactiveAggregateConfigRulesResponse{}
	_body, _err := client.DeactiveAggregateConfigRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In this example, the `cr-19a56457e0d90058****` rule is used.
 *
 * @param request DeactiveConfigRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeactiveConfigRulesResponse
 */
func (client *Client) DeactiveConfigRulesWithOptions(request *DeactiveConfigRulesRequest, runtime *util.RuntimeOptions) (_result *DeactiveConfigRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeactiveConfigRules"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeactiveConfigRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In this example, the `cr-19a56457e0d90058****` rule is used.
 *
 * @param request DeactiveConfigRulesRequest
 * @return DeactiveConfigRulesResponse
 */
func (client *Client) DeactiveConfigRules(request *DeactiveConfigRulesRequest) (_result *DeactiveConfigRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeactiveConfigRulesResponse{}
	_body, _err := client.DeactiveConfigRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to delete the `cp-541e626622af0087****` compliance package from the `ca-04b3fd170e340007****` account group.
 *
 * @param request DeleteAggregateCompliancePacksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAggregateCompliancePacksResponse
 */
func (client *Client) DeleteAggregateCompliancePacksWithOptions(request *DeleteAggregateCompliancePacksRequest, runtime *util.RuntimeOptions) (_result *DeleteAggregateCompliancePacksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		body["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackIds)) {
		body["CompliancePackIds"] = request.CompliancePackIds
	}

	if !tea.BoolValue(util.IsUnset(request.DeleteRule)) {
		body["DeleteRule"] = request.DeleteRule
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAggregateCompliancePacks"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAggregateCompliancePacksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to delete the `cp-541e626622af0087****` compliance package from the `ca-04b3fd170e340007****` account group.
 *
 * @param request DeleteAggregateCompliancePacksRequest
 * @return DeleteAggregateCompliancePacksResponse
 */
func (client *Client) DeleteAggregateCompliancePacks(request *DeleteAggregateCompliancePacksRequest) (_result *DeleteAggregateCompliancePacksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAggregateCompliancePacksResponse{}
	_body, _err := client.DeleteAggregateCompliancePacksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to delete the `cdc-38c3013b46c9002c****` delivery channel from the `ca-23c6626622af0041****` account group. The returned result shows that the `cdc-38c3013b46c9002c****` delivery channel is deleted.
 *
 * @param request DeleteAggregateConfigDeliveryChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAggregateConfigDeliveryChannelResponse
 */
func (client *Client) DeleteAggregateConfigDeliveryChannelWithOptions(request *DeleteAggregateConfigDeliveryChannelRequest, runtime *util.RuntimeOptions) (_result *DeleteAggregateConfigDeliveryChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelId)) {
		query["DeliveryChannelId"] = request.DeliveryChannelId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAggregateConfigDeliveryChannel"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAggregateConfigDeliveryChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to delete the `cdc-38c3013b46c9002c****` delivery channel from the `ca-23c6626622af0041****` account group. The returned result shows that the `cdc-38c3013b46c9002c****` delivery channel is deleted.
 *
 * @param request DeleteAggregateConfigDeliveryChannelRequest
 * @return DeleteAggregateConfigDeliveryChannelResponse
 */
func (client *Client) DeleteAggregateConfigDeliveryChannel(request *DeleteAggregateConfigDeliveryChannelRequest) (_result *DeleteAggregateConfigDeliveryChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAggregateConfigDeliveryChannelResponse{}
	_body, _err := client.DeleteAggregateConfigDeliveryChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Background information
 * You can delete a rule in the Cloud Config console. After you delete the rule, the configurations of the rule are deleted.
 * ### Usage notes
 * This topic provides an example on how to delete the `cr-4e3d626622af0080****` rule from the `ca-a4e5626622af0079****` account group.
 *
 * @param request DeleteAggregateConfigRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAggregateConfigRulesResponse
 */
func (client *Client) DeleteAggregateConfigRulesWithOptions(request *DeleteAggregateConfigRulesRequest, runtime *util.RuntimeOptions) (_result *DeleteAggregateConfigRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAggregateConfigRules"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAggregateConfigRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Background information
 * You can delete a rule in the Cloud Config console. After you delete the rule, the configurations of the rule are deleted.
 * ### Usage notes
 * This topic provides an example on how to delete the `cr-4e3d626622af0080****` rule from the `ca-a4e5626622af0079****` account group.
 *
 * @param request DeleteAggregateConfigRulesRequest
 * @return DeleteAggregateConfigRulesResponse
 */
func (client *Client) DeleteAggregateConfigRules(request *DeleteAggregateConfigRulesRequest) (_result *DeleteAggregateConfigRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAggregateConfigRulesResponse{}
	_body, _err := client.DeleteAggregateConfigRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to delete the remediation template whose ID is `crr-909ba2d4716700eb****` from the account group whose ID is `ca-6b4a626622af0012****`. The returned result shows that the remediation template whose ID is `crr-909ba2d4716700eb****` is deleted.
 *
 * @param request DeleteAggregateRemediationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAggregateRemediationsResponse
 */
func (client *Client) DeleteAggregateRemediationsWithOptions(request *DeleteAggregateRemediationsRequest, runtime *util.RuntimeOptions) (_result *DeleteAggregateRemediationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		body["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.RemediationIds)) {
		body["RemediationIds"] = request.RemediationIds
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAggregateRemediations"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAggregateRemediationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to delete the remediation template whose ID is `crr-909ba2d4716700eb****` from the account group whose ID is `ca-6b4a626622af0012****`. The returned result shows that the remediation template whose ID is `crr-909ba2d4716700eb****` is deleted.
 *
 * @param request DeleteAggregateRemediationsRequest
 * @return DeleteAggregateRemediationsResponse
 */
func (client *Client) DeleteAggregateRemediations(request *DeleteAggregateRemediationsRequest) (_result *DeleteAggregateRemediationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAggregateRemediationsResponse{}
	_body, _err := client.DeleteAggregateRemediationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to delete the account group whose ID is `ca-9190626622af00a9****`.
 *
 * @param request DeleteAggregatorsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAggregatorsResponse
 */
func (client *Client) DeleteAggregatorsWithOptions(request *DeleteAggregatorsRequest, runtime *util.RuntimeOptions) (_result *DeleteAggregatorsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorIds)) {
		body["AggregatorIds"] = request.AggregatorIds
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteAggregators"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteAggregatorsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to delete the account group whose ID is `ca-9190626622af00a9****`.
 *
 * @param request DeleteAggregatorsRequest
 * @return DeleteAggregatorsResponse
 */
func (client *Client) DeleteAggregators(request *DeleteAggregatorsRequest) (_result *DeleteAggregatorsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteAggregatorsResponse{}
	_body, _err := client.DeleteAggregatorsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to delete the `cp-541e626622af0087****` compliance package.
 *
 * @param request DeleteCompliancePacksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCompliancePacksResponse
 */
func (client *Client) DeleteCompliancePacksWithOptions(request *DeleteCompliancePacksRequest, runtime *util.RuntimeOptions) (_result *DeleteCompliancePacksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackIds)) {
		body["CompliancePackIds"] = request.CompliancePackIds
	}

	if !tea.BoolValue(util.IsUnset(request.DeleteRule)) {
		body["DeleteRule"] = request.DeleteRule
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCompliancePacks"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCompliancePacksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to delete the `cp-541e626622af0087****` compliance package.
 *
 * @param request DeleteCompliancePacksRequest
 * @return DeleteCompliancePacksResponse
 */
func (client *Client) DeleteCompliancePacks(request *DeleteCompliancePacksRequest) (_result *DeleteCompliancePacksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCompliancePacksResponse{}
	_body, _err := client.DeleteCompliancePacksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to delete the `cdc-38c3013b46c9002c****` delivery channel. The returned result shows that the `cdc-38c3013b46c9002c****` delivery channel is deleted.
 *
 * @param request DeleteConfigDeliveryChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConfigDeliveryChannelResponse
 */
func (client *Client) DeleteConfigDeliveryChannelWithOptions(request *DeleteConfigDeliveryChannelRequest, runtime *util.RuntimeOptions) (_result *DeleteConfigDeliveryChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelId)) {
		query["DeliveryChannelId"] = request.DeliveryChannelId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteConfigDeliveryChannel"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteConfigDeliveryChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to delete the `cdc-38c3013b46c9002c****` delivery channel. The returned result shows that the `cdc-38c3013b46c9002c****` delivery channel is deleted.
 *
 * @param request DeleteConfigDeliveryChannelRequest
 * @return DeleteConfigDeliveryChannelResponse
 */
func (client *Client) DeleteConfigDeliveryChannel(request *DeleteConfigDeliveryChannelRequest) (_result *DeleteConfigDeliveryChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteConfigDeliveryChannelResponse{}
	_body, _err := client.DeleteConfigDeliveryChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In this example, the rule whose ID is cr-9908626622af0035\\*\\*\\*\\* is deleted.
 *
 * @param request DeleteConfigRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConfigRulesResponse
 */
func (client *Client) DeleteConfigRulesWithOptions(request *DeleteConfigRulesRequest, runtime *util.RuntimeOptions) (_result *DeleteConfigRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteConfigRules"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteConfigRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In this example, the rule whose ID is cr-9908626622af0035\\*\\*\\*\\* is deleted.
 *
 * @param request DeleteConfigRulesRequest
 * @return DeleteConfigRulesResponse
 */
func (client *Client) DeleteConfigRules(request *DeleteConfigRulesRequest) (_result *DeleteConfigRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteConfigRulesResponse{}
	_body, _err := client.DeleteConfigRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to delete the remediation template `crr-909ba2d4716700eb****`. The returned result shows that the remediation template whose ID is `crr-909ba2d4716700eb****` is deleted.
 *
 * @param request DeleteRemediationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRemediationsResponse
 */
func (client *Client) DeleteRemediationsWithOptions(request *DeleteRemediationsRequest, runtime *util.RuntimeOptions) (_result *DeleteRemediationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RemediationIds)) {
		body["RemediationIds"] = request.RemediationIds
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRemediations"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRemediationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to delete the remediation template `crr-909ba2d4716700eb****`. The returned result shows that the remediation template whose ID is `crr-909ba2d4716700eb****` is deleted.
 *
 * @param request DeleteRemediationsRequest
 * @return DeleteRemediationsResponse
 */
func (client *Client) DeleteRemediations(request *DeleteRemediationsRequest) (_result *DeleteRemediationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRemediationsResponse{}
	_body, _err := client.DeleteRemediationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRemediationWithOptions(request *DescribeRemediationRequest, runtime *util.RuntimeOptions) (_result *DescribeRemediationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRemediation"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRemediationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRemediation(request *DescribeRemediationRequest) (_result *DescribeRemediationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRemediationResponse{}
	_body, _err := client.DescribeRemediationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The sample request in this topic shows you how to remove the `cr-6cc4626622af00e7****` rule in the `ca-75b4626622af00c3****` account group from the `cp-5bb1626622af00bd****` compliance package.
 * ## Prerequisites
 * One or more rules in an account group are added to a compliance package.
 *
 * @param request DetachAggregateConfigRuleToCompliancePackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachAggregateConfigRuleToCompliancePackResponse
 */
func (client *Client) DetachAggregateConfigRuleToCompliancePackWithOptions(request *DetachAggregateConfigRuleToCompliancePackRequest, runtime *util.RuntimeOptions) (_result *DetachAggregateConfigRuleToCompliancePackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackId)) {
		query["CompliancePackId"] = request.CompliancePackId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachAggregateConfigRuleToCompliancePack"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachAggregateConfigRuleToCompliancePackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The sample request in this topic shows you how to remove the `cr-6cc4626622af00e7****` rule in the `ca-75b4626622af00c3****` account group from the `cp-5bb1626622af00bd****` compliance package.
 * ## Prerequisites
 * One or more rules in an account group are added to a compliance package.
 *
 * @param request DetachAggregateConfigRuleToCompliancePackRequest
 * @return DetachAggregateConfigRuleToCompliancePackResponse
 */
func (client *Client) DetachAggregateConfigRuleToCompliancePack(request *DetachAggregateConfigRuleToCompliancePackRequest) (_result *DetachAggregateConfigRuleToCompliancePackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachAggregateConfigRuleToCompliancePackResponse{}
	_body, _err := client.DetachAggregateConfigRuleToCompliancePackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Prerequisites
 * One or more rules are added to a compliance package.
 * ### Usage notes
 * This topic provides an example on how to remove the `cr-6cc4626622af00e7****` rule from the `cp-5bb1626622af00bd****` compliance package.
 *
 * @param request DetachConfigRuleToCompliancePackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachConfigRuleToCompliancePackResponse
 */
func (client *Client) DetachConfigRuleToCompliancePackWithOptions(request *DetachConfigRuleToCompliancePackRequest, runtime *util.RuntimeOptions) (_result *DetachConfigRuleToCompliancePackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CompliancePackId)) {
		query["CompliancePackId"] = request.CompliancePackId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachConfigRuleToCompliancePack"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachConfigRuleToCompliancePackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Prerequisites
 * One or more rules are added to a compliance package.
 * ### Usage notes
 * This topic provides an example on how to remove the `cr-6cc4626622af00e7****` rule from the `cp-5bb1626622af00bd****` compliance package.
 *
 * @param request DetachConfigRuleToCompliancePackRequest
 * @return DetachConfigRuleToCompliancePackResponse
 */
func (client *Client) DetachConfigRuleToCompliancePack(request *DetachConfigRuleToCompliancePackRequest) (_result *DetachConfigRuleToCompliancePackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachConfigRuleToCompliancePackResponse{}
	_body, _err := client.DetachConfigRuleToCompliancePackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EvaluatePreConfigRulesWithOptions(tmpReq *EvaluatePreConfigRulesRequest, runtime *util.RuntimeOptions) (_result *EvaluatePreConfigRulesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &EvaluatePreConfigRulesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ResourceEvaluateItems)) {
		request.ResourceEvaluateItemsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ResourceEvaluateItems, tea.String("ResourceEvaluateItems"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnableManagedRules)) {
		body["EnableManagedRules"] = request.EnableManagedRules
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceEvaluateItemsShrink)) {
		body["ResourceEvaluateItems"] = request.ResourceEvaluateItemsShrink
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("EvaluatePreConfigRules"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EvaluatePreConfigRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EvaluatePreConfigRules(request *EvaluatePreConfigRulesRequest) (_result *EvaluatePreConfigRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EvaluatePreConfigRulesResponse{}
	_body, _err := client.EvaluatePreConfigRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation to generate the latest compliance evaluation report. To download the report, call the GetAggregateConfigRulesReport operation. For more information, see [GetAggregateCompliancePackReport](~~262699~~).
 * This topic provides an example on how to generate a compliance evaluation report based on the `cp-fdc8626622af00f9****` compliance package in the `ca-f632626622af0079****` account group.
 *
 * @param request GenerateAggregateCompliancePackReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateAggregateCompliancePackReportResponse
 */
func (client *Client) GenerateAggregateCompliancePackReportWithOptions(request *GenerateAggregateCompliancePackReportRequest, runtime *util.RuntimeOptions) (_result *GenerateAggregateCompliancePackReportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		body["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackId)) {
		body["CompliancePackId"] = request.CompliancePackId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GenerateAggregateCompliancePackReport"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GenerateAggregateCompliancePackReportResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation to generate the latest compliance evaluation report. To download the report, call the GetAggregateConfigRulesReport operation. For more information, see [GetAggregateCompliancePackReport](~~262699~~).
 * This topic provides an example on how to generate a compliance evaluation report based on the `cp-fdc8626622af00f9****` compliance package in the `ca-f632626622af0079****` account group.
 *
 * @param request GenerateAggregateCompliancePackReportRequest
 * @return GenerateAggregateCompliancePackReportResponse
 */
func (client *Client) GenerateAggregateCompliancePackReport(request *GenerateAggregateCompliancePackReportRequest) (_result *GenerateAggregateCompliancePackReportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GenerateAggregateCompliancePackReportResponse{}
	_body, _err := client.GenerateAggregateCompliancePackReportWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation to generate the latest compliance evaluation report. To download the report, call the GetAggregateConfigRulesReport operation. For more information, see [GetAggregateConfigRulesReport](~~262706~~).
 * The topic provides an example on how to generate a compliance evaluation report based on all rules in the `ca-f632626622af0079****` account group.
 *
 * @param request GenerateAggregateConfigRulesReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateAggregateConfigRulesReportResponse
 */
func (client *Client) GenerateAggregateConfigRulesReportWithOptions(request *GenerateAggregateConfigRulesReportRequest, runtime *util.RuntimeOptions) (_result *GenerateAggregateConfigRulesReportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		body["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		body["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GenerateAggregateConfigRulesReport"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GenerateAggregateConfigRulesReportResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation to generate the latest compliance evaluation report. To download the report, call the GetAggregateConfigRulesReport operation. For more information, see [GetAggregateConfigRulesReport](~~262706~~).
 * The topic provides an example on how to generate a compliance evaluation report based on all rules in the `ca-f632626622af0079****` account group.
 *
 * @param request GenerateAggregateConfigRulesReportRequest
 * @return GenerateAggregateConfigRulesReportResponse
 */
func (client *Client) GenerateAggregateConfigRulesReport(request *GenerateAggregateConfigRulesReportRequest) (_result *GenerateAggregateConfigRulesReportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GenerateAggregateConfigRulesReportResponse{}
	_body, _err := client.GenerateAggregateConfigRulesReportWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GenerateAggregateResourceInventoryWithOptions(request *GenerateAggregateResourceInventoryRequest, runtime *util.RuntimeOptions) (_result *GenerateAggregateResourceInventoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountIds)) {
		query["AccountIds"] = request.AccountIds
	}

	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.Regions)) {
		query["Regions"] = request.Regions
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceTypes)) {
		query["ResourceTypes"] = request.ResourceTypes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GenerateAggregateResourceInventory"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GenerateAggregateResourceInventoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GenerateAggregateResourceInventory(request *GenerateAggregateResourceInventoryRequest) (_result *GenerateAggregateResourceInventoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GenerateAggregateResourceInventoryResponse{}
	_body, _err := client.GenerateAggregateResourceInventoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > You can call this operation to generate the latest compliance evaluation report. To download the report, call the GetCompliancePackReport operation. For more information, see [GetCompliancePackReport](~~263347~~).
 * This topic provides an example on how to generate a compliance evaluation report based on the `cp-a8a8626622af0082****` compliance package.
 *
 * @param request GenerateCompliancePackReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateCompliancePackReportResponse
 */
func (client *Client) GenerateCompliancePackReportWithOptions(request *GenerateCompliancePackReportRequest, runtime *util.RuntimeOptions) (_result *GenerateCompliancePackReportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackId)) {
		body["CompliancePackId"] = request.CompliancePackId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GenerateCompliancePackReport"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GenerateCompliancePackReportResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > You can call this operation to generate the latest compliance evaluation report. To download the report, call the GetCompliancePackReport operation. For more information, see [GetCompliancePackReport](~~263347~~).
 * This topic provides an example on how to generate a compliance evaluation report based on the `cp-a8a8626622af0082****` compliance package.
 *
 * @param request GenerateCompliancePackReportRequest
 * @return GenerateCompliancePackReportResponse
 */
func (client *Client) GenerateCompliancePackReport(request *GenerateCompliancePackReportRequest) (_result *GenerateCompliancePackReportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GenerateCompliancePackReportResponse{}
	_body, _err := client.GenerateCompliancePackReportWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  You can call this operation to generate the latest compliance evaluation report. To download the report, call the GetConfigRulesReport operation. For more information, see [GetConfigRulesReport](~~263608~~).
 * This topic provides an example of how to generate a compliance evaluation report based on all existing rules.
 *
 * @param request GenerateConfigRulesReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateConfigRulesReportResponse
 */
func (client *Client) GenerateConfigRulesReportWithOptions(request *GenerateConfigRulesReportRequest, runtime *util.RuntimeOptions) (_result *GenerateConfigRulesReportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		body["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GenerateConfigRulesReport"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GenerateConfigRulesReportResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  You can call this operation to generate the latest compliance evaluation report. To download the report, call the GetConfigRulesReport operation. For more information, see [GetConfigRulesReport](~~263608~~).
 * This topic provides an example of how to generate a compliance evaluation report based on all existing rules.
 *
 * @param request GenerateConfigRulesReportRequest
 * @return GenerateConfigRulesReportResponse
 */
func (client *Client) GenerateConfigRulesReport(request *GenerateConfigRulesReportRequest) (_result *GenerateConfigRulesReportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GenerateConfigRulesReportResponse{}
	_body, _err := client.GenerateConfigRulesReportWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GenerateResourceInventoryWithOptions(request *GenerateResourceInventoryRequest, runtime *util.RuntimeOptions) (_result *GenerateResourceInventoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Regions)) {
		query["Regions"] = request.Regions
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceTypes)) {
		query["ResourceTypes"] = request.ResourceTypes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GenerateResourceInventory"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GenerateResourceInventoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GenerateResourceInventory(request *GenerateResourceInventoryRequest) (_result *GenerateResourceInventoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GenerateResourceInventoryResponse{}
	_body, _err := client.GenerateResourceInventoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAdvancedSearchFileWithOptions(runtime *util.RuntimeOptions) (_result *GetAdvancedSearchFileResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("GetAdvancedSearchFile"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAdvancedSearchFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAdvancedSearchFile() (_result *GetAdvancedSearchFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAdvancedSearchFileResponse{}
	_body, _err := client.GetAdvancedSearchFileWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the compliance evaluation results of member accounts for which the `cp-541e626622af0087****` compliance package takes effect in the `ca-04b3fd170e340007****` account group. The returned result shows that two member accounts are monitored by the compliance package and they are both evaluated as compliant.
 *
 * @param request GetAggregateAccountComplianceByPackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggregateAccountComplianceByPackResponse
 */
func (client *Client) GetAggregateAccountComplianceByPackWithOptions(request *GetAggregateAccountComplianceByPackRequest, runtime *util.RuntimeOptions) (_result *GetAggregateAccountComplianceByPackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateAccountComplianceByPack"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateAccountComplianceByPackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the compliance evaluation results of member accounts for which the `cp-541e626622af0087****` compliance package takes effect in the `ca-04b3fd170e340007****` account group. The returned result shows that two member accounts are monitored by the compliance package and they are both evaluated as compliant.
 *
 * @param request GetAggregateAccountComplianceByPackRequest
 * @return GetAggregateAccountComplianceByPackResponse
 */
func (client *Client) GetAggregateAccountComplianceByPack(request *GetAggregateAccountComplianceByPackRequest) (_result *GetAggregateAccountComplianceByPackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateAccountComplianceByPackResponse{}
	_body, _err := client.GetAggregateAccountComplianceByPackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAggregateAdvancedSearchFileWithOptions(request *GetAggregateAdvancedSearchFileRequest, runtime *util.RuntimeOptions) (_result *GetAggregateAdvancedSearchFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateAdvancedSearchFile"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateAdvancedSearchFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAggregateAdvancedSearchFile(request *GetAggregateAdvancedSearchFileRequest) (_result *GetAggregateAdvancedSearchFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateAdvancedSearchFileResponse{}
	_body, _err := client.GetAggregateAdvancedSearchFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The topic provides an example on how to query the details of a compliance package whose ID is `cp-fdc8626622af00f9****` in an account group whose ID is `ca-f632626622af0079****`.
 *
 * @param request GetAggregateCompliancePackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggregateCompliancePackResponse
 */
func (client *Client) GetAggregateCompliancePackWithOptions(request *GetAggregateCompliancePackRequest, runtime *util.RuntimeOptions) (_result *GetAggregateCompliancePackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateCompliancePack"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateCompliancePackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The topic provides an example on how to query the details of a compliance package whose ID is `cp-fdc8626622af00f9****` in an account group whose ID is `ca-f632626622af0079****`.
 *
 * @param request GetAggregateCompliancePackRequest
 * @return GetAggregateCompliancePackResponse
 */
func (client *Client) GetAggregateCompliancePack(request *GetAggregateCompliancePackRequest) (_result *GetAggregateCompliancePackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateCompliancePackResponse{}
	_body, _err := client.GetAggregateCompliancePackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > Before you call this operation, you must call the GenerateAggregateCompliancePackReport operation to generate the latest compliance evaluation report based on a compliance package. For more information, see [GenerateAggregateCompliancePackReport](~~262687~~).
 * This topic provides an example on how to query the compliance evaluation report that is generated based on the `cp-fdc8626622af00f9****` compliance package in the `ca-f632626622af0079****` account group.
 *
 * @param request GetAggregateCompliancePackReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggregateCompliancePackReportResponse
 */
func (client *Client) GetAggregateCompliancePackReportWithOptions(request *GetAggregateCompliancePackReportRequest, runtime *util.RuntimeOptions) (_result *GetAggregateCompliancePackReportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateCompliancePackReport"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateCompliancePackReportResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > Before you call this operation, you must call the GenerateAggregateCompliancePackReport operation to generate the latest compliance evaluation report based on a compliance package. For more information, see [GenerateAggregateCompliancePackReport](~~262687~~).
 * This topic provides an example on how to query the compliance evaluation report that is generated based on the `cp-fdc8626622af00f9****` compliance package in the `ca-f632626622af0079****` account group.
 *
 * @param request GetAggregateCompliancePackReportRequest
 * @return GetAggregateCompliancePackReportResponse
 */
func (client *Client) GetAggregateCompliancePackReport(request *GetAggregateCompliancePackReportRequest) (_result *GetAggregateCompliancePackReportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateCompliancePackReportResponse{}
	_body, _err := client.GetAggregateCompliancePackReportWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAggregateComplianceSummaryWithOptions(request *GetAggregateComplianceSummaryRequest, runtime *util.RuntimeOptions) (_result *GetAggregateComplianceSummaryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateComplianceSummary"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateComplianceSummaryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAggregateComplianceSummary(request *GetAggregateComplianceSummaryRequest) (_result *GetAggregateComplianceSummaryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateComplianceSummaryResponse{}
	_body, _err := client.GetAggregateComplianceSummaryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAggregateConfigDeliveryChannelWithOptions(request *GetAggregateConfigDeliveryChannelRequest, runtime *util.RuntimeOptions) (_result *GetAggregateConfigDeliveryChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelId)) {
		query["DeliveryChannelId"] = request.DeliveryChannelId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateConfigDeliveryChannel"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateConfigDeliveryChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAggregateConfigDeliveryChannel(request *GetAggregateConfigDeliveryChannelRequest) (_result *GetAggregateConfigDeliveryChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateConfigDeliveryChannelResponse{}
	_body, _err := client.GetAggregateConfigDeliveryChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This example shows how to query the details of the `cr-7f7d626622af0041****` rule in the `ca-7f00626622af0041****` account group.
 *
 * @param request GetAggregateConfigRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggregateConfigRuleResponse
 */
func (client *Client) GetAggregateConfigRuleWithOptions(request *GetAggregateConfigRuleRequest, runtime *util.RuntimeOptions) (_result *GetAggregateConfigRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		query["ConfigRuleId"] = request.ConfigRuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateConfigRule"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateConfigRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This example shows how to query the details of the `cr-7f7d626622af0041****` rule in the `ca-7f00626622af0041****` account group.
 *
 * @param request GetAggregateConfigRuleRequest
 * @return GetAggregateConfigRuleResponse
 */
func (client *Client) GetAggregateConfigRule(request *GetAggregateConfigRuleRequest) (_result *GetAggregateConfigRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateConfigRuleResponse{}
	_body, _err := client.GetAggregateConfigRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the compliance evaluation results based on rules in the `cp-541e626622af0087****` compliance package that is created for the `ca-04b3fd170e340007****` account group. The return result shows a total of `one` rule. `No resources` are evaluated as non-compliant based on the rule.
 *
 * @param request GetAggregateConfigRuleComplianceByPackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggregateConfigRuleComplianceByPackResponse
 */
func (client *Client) GetAggregateConfigRuleComplianceByPackWithOptions(request *GetAggregateConfigRuleComplianceByPackRequest, runtime *util.RuntimeOptions) (_result *GetAggregateConfigRuleComplianceByPackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateConfigRuleComplianceByPack"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateConfigRuleComplianceByPackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the compliance evaluation results based on rules in the `cp-541e626622af0087****` compliance package that is created for the `ca-04b3fd170e340007****` account group. The return result shows a total of `one` rule. `No resources` are evaluated as non-compliant based on the rule.
 *
 * @param request GetAggregateConfigRuleComplianceByPackRequest
 * @return GetAggregateConfigRuleComplianceByPackResponse
 */
func (client *Client) GetAggregateConfigRuleComplianceByPack(request *GetAggregateConfigRuleComplianceByPackRequest) (_result *GetAggregateConfigRuleComplianceByPackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateConfigRuleComplianceByPackResponse{}
	_body, _err := client.GetAggregateConfigRuleComplianceByPackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the summary of compliance evaluation results by rule risk level in the `ca-3a58626622af0005****` account group. The returned result shows four rules that are specified with the high risk level. One of the rules detects non-compliant resources, and the resources evaluated by the remaining three are compliant.
 *
 * @param request GetAggregateConfigRuleSummaryByRiskLevelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggregateConfigRuleSummaryByRiskLevelResponse
 */
func (client *Client) GetAggregateConfigRuleSummaryByRiskLevelWithOptions(request *GetAggregateConfigRuleSummaryByRiskLevelRequest, runtime *util.RuntimeOptions) (_result *GetAggregateConfigRuleSummaryByRiskLevelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateConfigRuleSummaryByRiskLevel"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateConfigRuleSummaryByRiskLevelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the summary of compliance evaluation results by rule risk level in the `ca-3a58626622af0005****` account group. The returned result shows four rules that are specified with the high risk level. One of the rules detects non-compliant resources, and the resources evaluated by the remaining three are compliant.
 *
 * @param request GetAggregateConfigRuleSummaryByRiskLevelRequest
 * @return GetAggregateConfigRuleSummaryByRiskLevelResponse
 */
func (client *Client) GetAggregateConfigRuleSummaryByRiskLevel(request *GetAggregateConfigRuleSummaryByRiskLevelRequest) (_result *GetAggregateConfigRuleSummaryByRiskLevelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateConfigRuleSummaryByRiskLevelResponse{}
	_body, _err := client.GetAggregateConfigRuleSummaryByRiskLevelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > Before you call this operation, you must call the GenerateAggregateConfigRulesReport operation to generate the latest compliance evaluation report based on all rules in an account group. For more information, see [GenerateAggregateConfigRulesReport](~~262701~~).
 * This topic provides an example on how to query the compliance evaluation report that is generated based on all rules in the `ca-f632626622af0079****` account group.
 *
 * @param request GetAggregateConfigRulesReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggregateConfigRulesReportResponse
 */
func (client *Client) GetAggregateConfigRulesReportWithOptions(request *GetAggregateConfigRulesReportRequest, runtime *util.RuntimeOptions) (_result *GetAggregateConfigRulesReportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ReportId)) {
		query["ReportId"] = request.ReportId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateConfigRulesReport"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateConfigRulesReportResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > Before you call this operation, you must call the GenerateAggregateConfigRulesReport operation to generate the latest compliance evaluation report based on all rules in an account group. For more information, see [GenerateAggregateConfigRulesReport](~~262701~~).
 * This topic provides an example on how to query the compliance evaluation report that is generated based on all rules in the `ca-f632626622af0079****` account group.
 *
 * @param request GetAggregateConfigRulesReportRequest
 * @return GetAggregateConfigRulesReportResponse
 */
func (client *Client) GetAggregateConfigRulesReport(request *GetAggregateConfigRulesReportRequest) (_result *GetAggregateConfigRulesReportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateConfigRulesReportResponse{}
	_body, _err := client.GetAggregateConfigRulesReportWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the `new-bucket` resource in the `ca-5885626622af0008****` account group.
 *
 * @param request GetAggregateDiscoveredResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggregateDiscoveredResourceResponse
 */
func (client *Client) GetAggregateDiscoveredResourceWithOptions(request *GetAggregateDiscoveredResourceRequest, runtime *util.RuntimeOptions) (_result *GetAggregateDiscoveredResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateDiscoveredResource"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateDiscoveredResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the `new-bucket` resource in the `ca-5885626622af0008****` account group.
 *
 * @param request GetAggregateDiscoveredResourceRequest
 * @return GetAggregateDiscoveredResourceResponse
 */
func (client *Client) GetAggregateDiscoveredResource(request *GetAggregateDiscoveredResourceRequest) (_result *GetAggregateDiscoveredResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateDiscoveredResourceResponse{}
	_body, _err := client.GetAggregateDiscoveredResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the compliance evaluation results based on the `cr-d369626622af008e****` rule in the `ca-a4e5626622af0079****` account group. The return result shows that a total of 10 resources are evaluated by the rule and five of them are evaluated as compliant.
 *
 * @param request GetAggregateResourceComplianceByConfigRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggregateResourceComplianceByConfigRuleResponse
 */
func (client *Client) GetAggregateResourceComplianceByConfigRuleWithOptions(request *GetAggregateResourceComplianceByConfigRuleRequest, runtime *util.RuntimeOptions) (_result *GetAggregateResourceComplianceByConfigRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ComplianceType)) {
		query["ComplianceType"] = request.ComplianceType
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		query["ConfigRuleId"] = request.ConfigRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceAccountId)) {
		query["ResourceAccountId"] = request.ResourceAccountId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateResourceComplianceByConfigRule"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateResourceComplianceByConfigRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the compliance evaluation results based on the `cr-d369626622af008e****` rule in the `ca-a4e5626622af0079****` account group. The return result shows that a total of 10 resources are evaluated by the rule and five of them are evaluated as compliant.
 *
 * @param request GetAggregateResourceComplianceByConfigRuleRequest
 * @return GetAggregateResourceComplianceByConfigRuleResponse
 */
func (client *Client) GetAggregateResourceComplianceByConfigRule(request *GetAggregateResourceComplianceByConfigRuleRequest) (_result *GetAggregateResourceComplianceByConfigRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateResourceComplianceByConfigRuleResponse{}
	_body, _err := client.GetAggregateResourceComplianceByConfigRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the compliance evaluation results of resources monitored based on the `cp-fdc8626622af00f9****` compliance package in the `ca-f632626622af0079****`account group. The returned result shows that the total number of monitored resources is `10` and the number of non-compliant resources is `7`.
 *
 * @param request GetAggregateResourceComplianceByPackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggregateResourceComplianceByPackResponse
 */
func (client *Client) GetAggregateResourceComplianceByPackWithOptions(request *GetAggregateResourceComplianceByPackRequest, runtime *util.RuntimeOptions) (_result *GetAggregateResourceComplianceByPackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateResourceComplianceByPack"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateResourceComplianceByPackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the compliance evaluation results of resources monitored based on the `cp-fdc8626622af00f9****` compliance package in the `ca-f632626622af0079****`account group. The returned result shows that the total number of monitored resources is `10` and the number of non-compliant resources is `7`.
 *
 * @param request GetAggregateResourceComplianceByPackRequest
 * @return GetAggregateResourceComplianceByPackResponse
 */
func (client *Client) GetAggregateResourceComplianceByPack(request *GetAggregateResourceComplianceByPackRequest) (_result *GetAggregateResourceComplianceByPackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateResourceComplianceByPackResponse{}
	_body, _err := client.GetAggregateResourceComplianceByPackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAggregateResourceComplianceGroupByRegionWithOptions(request *GetAggregateResourceComplianceGroupByRegionRequest, runtime *util.RuntimeOptions) (_result *GetAggregateResourceComplianceGroupByRegionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateResourceComplianceGroupByRegion"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateResourceComplianceGroupByRegionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAggregateResourceComplianceGroupByRegion(request *GetAggregateResourceComplianceGroupByRegionRequest) (_result *GetAggregateResourceComplianceGroupByRegionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateResourceComplianceGroupByRegionResponse{}
	_body, _err := client.GetAggregateResourceComplianceGroupByRegionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAggregateResourceComplianceGroupByResourceTypeWithOptions(request *GetAggregateResourceComplianceGroupByResourceTypeRequest, runtime *util.RuntimeOptions) (_result *GetAggregateResourceComplianceGroupByResourceTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateResourceComplianceGroupByResourceType"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateResourceComplianceGroupByResourceTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAggregateResourceComplianceGroupByResourceType(request *GetAggregateResourceComplianceGroupByResourceTypeRequest) (_result *GetAggregateResourceComplianceGroupByResourceTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateResourceComplianceGroupByResourceTypeResponse{}
	_body, _err := client.GetAggregateResourceComplianceGroupByResourceTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the compliance timeline of the `new-bucket` resource that resides in the `cn-hangzhou` region within the `100931896542****` member account of the `ca-5885626622af0008****` account group. The new-bucket resource is an Object Storage Service (OSS) bucket. The return result shows the following two timestamps on the compliance timeline: `1625200295276` and `1625200228510`. The first timestamp indicates 12:31:35 on July 2, 2021 (UTC+8), and the second timestamp indicates 12:30:28 on July 2, 2021 (UTC+8).
 *
 * @param request GetAggregateResourceComplianceTimelineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggregateResourceComplianceTimelineResponse
 */
func (client *Client) GetAggregateResourceComplianceTimelineWithOptions(request *GetAggregateResourceComplianceTimelineRequest, runtime *util.RuntimeOptions) (_result *GetAggregateResourceComplianceTimelineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateResourceComplianceTimeline"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateResourceComplianceTimelineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the compliance timeline of the `new-bucket` resource that resides in the `cn-hangzhou` region within the `100931896542****` member account of the `ca-5885626622af0008****` account group. The new-bucket resource is an Object Storage Service (OSS) bucket. The return result shows the following two timestamps on the compliance timeline: `1625200295276` and `1625200228510`. The first timestamp indicates 12:31:35 on July 2, 2021 (UTC+8), and the second timestamp indicates 12:30:28 on July 2, 2021 (UTC+8).
 *
 * @param request GetAggregateResourceComplianceTimelineRequest
 * @return GetAggregateResourceComplianceTimelineResponse
 */
func (client *Client) GetAggregateResourceComplianceTimeline(request *GetAggregateResourceComplianceTimelineRequest) (_result *GetAggregateResourceComplianceTimelineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateResourceComplianceTimelineResponse{}
	_body, _err := client.GetAggregateResourceComplianceTimelineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the configuration timeline of the `new-bucket` resource that resides in the `cn-hangzhou` region within the `100931896542****` member account of the `ca-5885626622af0008****` account group. The new-bucket resource is an Object Storage Service (OSS) bucket. The return result shows that the timestamp when the resource configuration changes is `1624961112000`. The timestamp indicates 18:05:12 on June 29, 2021 (UTC+8).
 *
 * @param request GetAggregateResourceConfigurationTimelineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggregateResourceConfigurationTimelineResponse
 */
func (client *Client) GetAggregateResourceConfigurationTimelineWithOptions(request *GetAggregateResourceConfigurationTimelineRequest, runtime *util.RuntimeOptions) (_result *GetAggregateResourceConfigurationTimelineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateResourceConfigurationTimeline"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateResourceConfigurationTimelineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the configuration timeline of the `new-bucket` resource that resides in the `cn-hangzhou` region within the `100931896542****` member account of the `ca-5885626622af0008****` account group. The new-bucket resource is an Object Storage Service (OSS) bucket. The return result shows that the timestamp when the resource configuration changes is `1624961112000`. The timestamp indicates 18:05:12 on June 29, 2021 (UTC+8).
 *
 * @param request GetAggregateResourceConfigurationTimelineRequest
 * @return GetAggregateResourceConfigurationTimelineResponse
 */
func (client *Client) GetAggregateResourceConfigurationTimeline(request *GetAggregateResourceConfigurationTimelineRequest) (_result *GetAggregateResourceConfigurationTimelineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateResourceConfigurationTimelineResponse{}
	_body, _err := client.GetAggregateResourceConfigurationTimelineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the statistics on the resources in an account group named `ca-a260626622af0005****` by region. The returned result shows that a total of `10` resources exist in the `cn-hangzhou` region.
 *
 * @param request GetAggregateResourceCountsGroupByRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggregateResourceCountsGroupByRegionResponse
 */
func (client *Client) GetAggregateResourceCountsGroupByRegionWithOptions(request *GetAggregateResourceCountsGroupByRegionRequest, runtime *util.RuntimeOptions) (_result *GetAggregateResourceCountsGroupByRegionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.FolderId)) {
		query["FolderId"] = request.FolderId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceAccountId)) {
		query["ResourceAccountId"] = request.ResourceAccountId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateResourceCountsGroupByRegion"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateResourceCountsGroupByRegionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the statistics on the resources in an account group named `ca-a260626622af0005****` by region. The returned result shows that a total of `10` resources exist in the `cn-hangzhou` region.
 *
 * @param request GetAggregateResourceCountsGroupByRegionRequest
 * @return GetAggregateResourceCountsGroupByRegionResponse
 */
func (client *Client) GetAggregateResourceCountsGroupByRegion(request *GetAggregateResourceCountsGroupByRegionRequest) (_result *GetAggregateResourceCountsGroupByRegionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateResourceCountsGroupByRegionResponse{}
	_body, _err := client.GetAggregateResourceCountsGroupByRegionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the statistics on the resources in an account group whose ID is `ca-a260626622af0005****` by resource type. The returned result shows that the account group has a total of `seven` resources of the `ACS::RAM::Role` resource type.
 *
 * @param request GetAggregateResourceCountsGroupByResourceTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggregateResourceCountsGroupByResourceTypeResponse
 */
func (client *Client) GetAggregateResourceCountsGroupByResourceTypeWithOptions(request *GetAggregateResourceCountsGroupByResourceTypeRequest, runtime *util.RuntimeOptions) (_result *GetAggregateResourceCountsGroupByResourceTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.FolderId)) {
		query["FolderId"] = request.FolderId
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceAccountId)) {
		query["ResourceAccountId"] = request.ResourceAccountId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateResourceCountsGroupByResourceType"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateResourceCountsGroupByResourceTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the statistics on the resources in an account group whose ID is `ca-a260626622af0005****` by resource type. The returned result shows that the account group has a total of `seven` resources of the `ACS::RAM::Role` resource type.
 *
 * @param request GetAggregateResourceCountsGroupByResourceTypeRequest
 * @return GetAggregateResourceCountsGroupByResourceTypeResponse
 */
func (client *Client) GetAggregateResourceCountsGroupByResourceType(request *GetAggregateResourceCountsGroupByResourceTypeRequest) (_result *GetAggregateResourceCountsGroupByResourceTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateResourceCountsGroupByResourceTypeResponse{}
	_body, _err := client.GetAggregateResourceCountsGroupByResourceTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAggregateResourceInventoryWithOptions(request *GetAggregateResourceInventoryRequest, runtime *util.RuntimeOptions) (_result *GetAggregateResourceInventoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregateResourceInventory"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregateResourceInventoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAggregateResourceInventory(request *GetAggregateResourceInventoryRequest) (_result *GetAggregateResourceInventoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregateResourceInventoryResponse{}
	_body, _err := client.GetAggregateResourceInventoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the details of the `ca-88ea626622af0055****` account group. The return result shows that the account group is named `Test_Group`, its description is `Test account group`, and it is of the `CUSTOM` type. The account group is in the `1` state, which indicates that it is created.
 *
 * @param request GetAggregatorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAggregatorResponse
 */
func (client *Client) GetAggregatorWithOptions(request *GetAggregatorRequest, runtime *util.RuntimeOptions) (_result *GetAggregatorResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAggregator"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAggregatorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the details of the `ca-88ea626622af0055****` account group. The return result shows that the account group is named `Test_Group`, its description is `Test account group`, and it is of the `CUSTOM` type. The account group is in the `1` state, which indicates that it is created.
 *
 * @param request GetAggregatorRequest
 * @return GetAggregatorResponse
 */
func (client *Client) GetAggregator(request *GetAggregatorRequest) (_result *GetAggregatorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAggregatorResponse{}
	_body, _err := client.GetAggregatorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the details of a compliance package whose ID is `cp-fdc8626622af00f9****`. The returned result shows that the name of the compliance package is `ClassifiedProtectionPreCheck`, the compliance package is in the `ACTIVE` state, and the risk level of the rules in the compliance package is `1`, which indicates high risk level.
 *
 * @param request GetCompliancePackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCompliancePackResponse
 */
func (client *Client) GetCompliancePackWithOptions(request *GetCompliancePackRequest, runtime *util.RuntimeOptions) (_result *GetCompliancePackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetCompliancePack"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetCompliancePackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the details of a compliance package whose ID is `cp-fdc8626622af00f9****`. The returned result shows that the name of the compliance package is `ClassifiedProtectionPreCheck`, the compliance package is in the `ACTIVE` state, and the risk level of the rules in the compliance package is `1`, which indicates high risk level.
 *
 * @param request GetCompliancePackRequest
 * @return GetCompliancePackResponse
 */
func (client *Client) GetCompliancePack(request *GetCompliancePackRequest) (_result *GetCompliancePackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetCompliancePackResponse{}
	_body, _err := client.GetCompliancePackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > Before you call this operation, you must call the GenerateCompliancePackReport operation to generate the latest compliance evaluation report based on a compliance package. For more information, see [GenerateCompliancePackReport](~~263525~~).
 * This topic provides an example on how to query the compliance evaluation report that is generated based on the `cp-fdc8626622af00f9****` compliance package.
 *
 * @param request GetCompliancePackReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCompliancePackReportResponse
 */
func (client *Client) GetCompliancePackReportWithOptions(request *GetCompliancePackReportRequest, runtime *util.RuntimeOptions) (_result *GetCompliancePackReportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetCompliancePackReport"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetCompliancePackReportResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > Before you call this operation, you must call the GenerateCompliancePackReport operation to generate the latest compliance evaluation report based on a compliance package. For more information, see [GenerateCompliancePackReport](~~263525~~).
 * This topic provides an example on how to query the compliance evaluation report that is generated based on the `cp-fdc8626622af00f9****` compliance package.
 *
 * @param request GetCompliancePackReportRequest
 * @return GetCompliancePackReportResponse
 */
func (client *Client) GetCompliancePackReport(request *GetCompliancePackReportRequest) (_result *GetCompliancePackReportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetCompliancePackReportResponse{}
	_body, _err := client.GetCompliancePackReportWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetComplianceSummaryWithOptions(runtime *util.RuntimeOptions) (_result *GetComplianceSummaryResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("GetComplianceSummary"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetComplianceSummaryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetComplianceSummary() (_result *GetComplianceSummaryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetComplianceSummaryResponse{}
	_body, _err := client.GetComplianceSummaryWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetConfigDeliveryChannelWithOptions(request *GetConfigDeliveryChannelRequest, runtime *util.RuntimeOptions) (_result *GetConfigDeliveryChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelId)) {
		query["DeliveryChannelId"] = request.DeliveryChannelId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetConfigDeliveryChannel"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetConfigDeliveryChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetConfigDeliveryChannel(request *GetConfigDeliveryChannelRequest) (_result *GetConfigDeliveryChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetConfigDeliveryChannelResponse{}
	_body, _err := client.GetConfigDeliveryChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the details of the `cr-7f7d626622af0041****` rule.
 *
 * @param request GetConfigRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetConfigRuleResponse
 */
func (client *Client) GetConfigRuleWithOptions(request *GetConfigRuleRequest, runtime *util.RuntimeOptions) (_result *GetConfigRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		query["ConfigRuleId"] = request.ConfigRuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetConfigRule"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetConfigRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the details of the `cr-7f7d626622af0041****` rule.
 *
 * @param request GetConfigRuleRequest
 * @return GetConfigRuleResponse
 */
func (client *Client) GetConfigRule(request *GetConfigRuleRequest) (_result *GetConfigRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetConfigRuleResponse{}
	_body, _err := client.GetConfigRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In this topic, the `cp-541e626622af0087****` compliance package is used as an example. The return result shows a total of one rule against which specific resources are evaluated as compliant.
 *
 * @param request GetConfigRuleComplianceByPackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetConfigRuleComplianceByPackResponse
 */
func (client *Client) GetConfigRuleComplianceByPackWithOptions(request *GetConfigRuleComplianceByPackRequest, runtime *util.RuntimeOptions) (_result *GetConfigRuleComplianceByPackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetConfigRuleComplianceByPack"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetConfigRuleComplianceByPackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In this topic, the `cp-541e626622af0087****` compliance package is used as an example. The return result shows a total of one rule against which specific resources are evaluated as compliant.
 *
 * @param request GetConfigRuleComplianceByPackRequest
 * @return GetConfigRuleComplianceByPackResponse
 */
func (client *Client) GetConfigRuleComplianceByPack(request *GetConfigRuleComplianceByPackRequest) (_result *GetConfigRuleComplianceByPackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetConfigRuleComplianceByPackResponse{}
	_body, _err := client.GetConfigRuleComplianceByPackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example of how to query the summary of compliance evaluation results by rule risk level. The return result shows four rules that are specified with the high risk level. One of them detects non-compliant resources, and the resources evaluated by the remaining three are all compliant.
 *
 * @param request GetConfigRuleSummaryByRiskLevelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetConfigRuleSummaryByRiskLevelResponse
 */
func (client *Client) GetConfigRuleSummaryByRiskLevelWithOptions(runtime *util.RuntimeOptions) (_result *GetConfigRuleSummaryByRiskLevelResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("GetConfigRuleSummaryByRiskLevel"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetConfigRuleSummaryByRiskLevelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example of how to query the summary of compliance evaluation results by rule risk level. The return result shows four rules that are specified with the high risk level. One of them detects non-compliant resources, and the resources evaluated by the remaining three are all compliant.
 *
 * @return GetConfigRuleSummaryByRiskLevelResponse
 */
func (client *Client) GetConfigRuleSummaryByRiskLevel() (_result *GetConfigRuleSummaryByRiskLevelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetConfigRuleSummaryByRiskLevelResponse{}
	_body, _err := client.GetConfigRuleSummaryByRiskLevelWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * >  Before you call this operation, you must call the GenerateConfigRulesReport operation to generate the latest compliance evaluation report based on all existing rules. For more information, see [GenerateConfigRulesReport](~~263601~~).
 * This topic provides an example of how to query the compliance evaluation report that is generated based on all existing rules.
 *
 * @param request GetConfigRulesReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetConfigRulesReportResponse
 */
func (client *Client) GetConfigRulesReportWithOptions(request *GetConfigRulesReportRequest, runtime *util.RuntimeOptions) (_result *GetConfigRulesReportResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ReportId)) {
		query["ReportId"] = request.ReportId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetConfigRulesReport"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetConfigRulesReportResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * >  Before you call this operation, you must call the GenerateConfigRulesReport operation to generate the latest compliance evaluation report based on all existing rules. For more information, see [GenerateConfigRulesReport](~~263601~~).
 * This topic provides an example of how to query the compliance evaluation report that is generated based on all existing rules.
 *
 * @param request GetConfigRulesReportRequest
 * @return GetConfigRulesReportResponse
 */
func (client *Client) GetConfigRulesReport(request *GetConfigRulesReportRequest) (_result *GetConfigRulesReportResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetConfigRulesReportResponse{}
	_body, _err := client.GetConfigRulesReportWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetConfigurationRecorderWithOptions(runtime *util.RuntimeOptions) (_result *GetConfigurationRecorderResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("GetConfigurationRecorder"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetConfigurationRecorderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetConfigurationRecorder() (_result *GetConfigurationRecorderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetConfigurationRecorderResponse{}
	_body, _err := client.GetConfigurationRecorderWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the details of the `new-bucket` resource.
 *
 * @param request GetDiscoveredResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDiscoveredResourceResponse
 */
func (client *Client) GetDiscoveredResourceWithOptions(request *GetDiscoveredResourceRequest, runtime *util.RuntimeOptions) (_result *GetDiscoveredResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDiscoveredResource"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDiscoveredResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the details of the `new-bucket` resource.
 *
 * @param request GetDiscoveredResourceRequest
 * @return GetDiscoveredResourceResponse
 */
func (client *Client) GetDiscoveredResource(request *GetDiscoveredResourceRequest) (_result *GetDiscoveredResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDiscoveredResourceResponse{}
	_body, _err := client.GetDiscoveredResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example of how to query the statistics on resources by region. The returned result shows that a total of 10 resources exist in the `cn-hangzhou` region.
 *
 * @param request GetDiscoveredResourceCountsGroupByRegionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDiscoveredResourceCountsGroupByRegionResponse
 */
func (client *Client) GetDiscoveredResourceCountsGroupByRegionWithOptions(request *GetDiscoveredResourceCountsGroupByRegionRequest, runtime *util.RuntimeOptions) (_result *GetDiscoveredResourceCountsGroupByRegionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDiscoveredResourceCountsGroupByRegion"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDiscoveredResourceCountsGroupByRegionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example of how to query the statistics on resources by region. The returned result shows that a total of 10 resources exist in the `cn-hangzhou` region.
 *
 * @param request GetDiscoveredResourceCountsGroupByRegionRequest
 * @return GetDiscoveredResourceCountsGroupByRegionResponse
 */
func (client *Client) GetDiscoveredResourceCountsGroupByRegion(request *GetDiscoveredResourceCountsGroupByRegionRequest) (_result *GetDiscoveredResourceCountsGroupByRegionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDiscoveredResourceCountsGroupByRegionResponse{}
	_body, _err := client.GetDiscoveredResourceCountsGroupByRegionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic describes how to query the statistics on resources by resource type. The returned result shows that a total of 10 resources of the `ACS::ECS::Instance` resource type exist.
 *
 * @param request GetDiscoveredResourceCountsGroupByResourceTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDiscoveredResourceCountsGroupByResourceTypeResponse
 */
func (client *Client) GetDiscoveredResourceCountsGroupByResourceTypeWithOptions(request *GetDiscoveredResourceCountsGroupByResourceTypeRequest, runtime *util.RuntimeOptions) (_result *GetDiscoveredResourceCountsGroupByResourceTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDiscoveredResourceCountsGroupByResourceType"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDiscoveredResourceCountsGroupByResourceTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic describes how to query the statistics on resources by resource type. The returned result shows that a total of 10 resources of the `ACS::ECS::Instance` resource type exist.
 *
 * @param request GetDiscoveredResourceCountsGroupByResourceTypeRequest
 * @return GetDiscoveredResourceCountsGroupByResourceTypeResponse
 */
func (client *Client) GetDiscoveredResourceCountsGroupByResourceType(request *GetDiscoveredResourceCountsGroupByResourceTypeRequest) (_result *GetDiscoveredResourceCountsGroupByResourceTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDiscoveredResourceCountsGroupByResourceTypeResponse{}
	_body, _err := client.GetDiscoveredResourceCountsGroupByResourceTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetIntegratedServiceStatusWithOptions(request *GetIntegratedServiceStatusRequest, runtime *util.RuntimeOptions) (_result *GetIntegratedServiceStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ServiceCode)) {
		body["ServiceCode"] = request.ServiceCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetIntegratedServiceStatus"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetIntegratedServiceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetIntegratedServiceStatus(request *GetIntegratedServiceStatusRequest) (_result *GetIntegratedServiceStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetIntegratedServiceStatusResponse{}
	_body, _err := client.GetIntegratedServiceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In this topic, the `cdn-domain-https-enabled` managed rule is used as an example.
 *
 * @param request GetManagedRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetManagedRuleResponse
 */
func (client *Client) GetManagedRuleWithOptions(request *GetManagedRuleRequest, runtime *util.RuntimeOptions) (_result *GetManagedRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Identifier)) {
		query["Identifier"] = request.Identifier
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetManagedRule"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetManagedRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In this topic, the `cdn-domain-https-enabled` managed rule is used as an example.
 *
 * @param request GetManagedRuleRequest
 * @return GetManagedRuleResponse
 */
func (client *Client) GetManagedRule(request *GetManagedRuleRequest) (_result *GetManagedRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetManagedRuleResponse{}
	_body, _err := client.GetManagedRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetRemediationTemplateWithOptions(request *GetRemediationTemplateRequest, runtime *util.RuntimeOptions) (_result *GetRemediationTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateIdentifier)) {
		query["TemplateIdentifier"] = request.TemplateIdentifier
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetRemediationTemplate"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetRemediationTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetRemediationTemplate(request *GetRemediationTemplateRequest) (_result *GetRemediationTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetRemediationTemplateResponse{}
	_body, _err := client.GetRemediationTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In this topic, the `cr-d369626622af008e****` rule is used as an example. The return result shows that a total of 10 resources are evaluated by the rule and `five` of them are evaluated as compliant.
 *
 * @param request GetResourceComplianceByConfigRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetResourceComplianceByConfigRuleResponse
 */
func (client *Client) GetResourceComplianceByConfigRuleWithOptions(request *GetResourceComplianceByConfigRuleRequest, runtime *util.RuntimeOptions) (_result *GetResourceComplianceByConfigRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetResourceComplianceByConfigRule"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetResourceComplianceByConfigRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In this topic, the `cr-d369626622af008e****` rule is used as an example. The return result shows that a total of 10 resources are evaluated by the rule and `five` of them are evaluated as compliant.
 *
 * @param request GetResourceComplianceByConfigRuleRequest
 * @return GetResourceComplianceByConfigRuleResponse
 */
func (client *Client) GetResourceComplianceByConfigRule(request *GetResourceComplianceByConfigRuleRequest) (_result *GetResourceComplianceByConfigRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetResourceComplianceByConfigRuleResponse{}
	_body, _err := client.GetResourceComplianceByConfigRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the compliance evaluation results of resources monitored by using the `cp-541e626622af0087****` compliance package. The returned result shows a total of 10 resources and seven of them are evaluated as non-compliant.
 *
 * @param request GetResourceComplianceByPackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetResourceComplianceByPackResponse
 */
func (client *Client) GetResourceComplianceByPackWithOptions(request *GetResourceComplianceByPackRequest, runtime *util.RuntimeOptions) (_result *GetResourceComplianceByPackResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetResourceComplianceByPack"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetResourceComplianceByPackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the compliance evaluation results of resources monitored by using the `cp-541e626622af0087****` compliance package. The returned result shows a total of 10 resources and seven of them are evaluated as non-compliant.
 *
 * @param request GetResourceComplianceByPackRequest
 * @return GetResourceComplianceByPackResponse
 */
func (client *Client) GetResourceComplianceByPack(request *GetResourceComplianceByPackRequest) (_result *GetResourceComplianceByPackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetResourceComplianceByPackResponse{}
	_body, _err := client.GetResourceComplianceByPackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetResourceComplianceGroupByRegionWithOptions(request *GetResourceComplianceGroupByRegionRequest, runtime *util.RuntimeOptions) (_result *GetResourceComplianceGroupByRegionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetResourceComplianceGroupByRegion"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetResourceComplianceGroupByRegionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetResourceComplianceGroupByRegion(request *GetResourceComplianceGroupByRegionRequest) (_result *GetResourceComplianceGroupByRegionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetResourceComplianceGroupByRegionResponse{}
	_body, _err := client.GetResourceComplianceGroupByRegionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetResourceComplianceGroupByResourceTypeWithOptions(request *GetResourceComplianceGroupByResourceTypeRequest, runtime *util.RuntimeOptions) (_result *GetResourceComplianceGroupByResourceTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetResourceComplianceGroupByResourceType"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetResourceComplianceGroupByResourceTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetResourceComplianceGroupByResourceType(request *GetResourceComplianceGroupByResourceTypeRequest) (_result *GetResourceComplianceGroupByResourceTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetResourceComplianceGroupByResourceTypeResponse{}
	_body, _err := client.GetResourceComplianceGroupByResourceTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the compliance timeline of the `new-bucket` resource that resides in the `cn-hangzhou` region. The resource is an Object Storage Service (OSS) bucket. The return result shows the following two timestamps on the compliance timeline: `1625200295276` and `1625200228510`. The first timestamp indicates 12:31:35 on July 2, 2021 (UTC+8) and the second timestamp indicates 12:30:28 on July 2, 2021 (UTC+8).
 *
 * @param request GetResourceComplianceTimelineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetResourceComplianceTimelineResponse
 */
func (client *Client) GetResourceComplianceTimelineWithOptions(request *GetResourceComplianceTimelineRequest, runtime *util.RuntimeOptions) (_result *GetResourceComplianceTimelineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetResourceComplianceTimeline"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetResourceComplianceTimelineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the compliance timeline of the `new-bucket` resource that resides in the `cn-hangzhou` region. The resource is an Object Storage Service (OSS) bucket. The return result shows the following two timestamps on the compliance timeline: `1625200295276` and `1625200228510`. The first timestamp indicates 12:31:35 on July 2, 2021 (UTC+8) and the second timestamp indicates 12:30:28 on July 2, 2021 (UTC+8).
 *
 * @param request GetResourceComplianceTimelineRequest
 * @return GetResourceComplianceTimelineResponse
 */
func (client *Client) GetResourceComplianceTimeline(request *GetResourceComplianceTimelineRequest) (_result *GetResourceComplianceTimelineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetResourceComplianceTimelineResponse{}
	_body, _err := client.GetResourceComplianceTimelineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the configuration timeline of the `new-bucket` resource that resides in the `cn-hangzhou` region. The new-bucket resource is an Object Storage Service (OSS) bucket. The return result shows that the timestamp when the resource configuration changes is `1624961112000`. The timestamp indicates 18:05:12 on June 29, 2021 (UTC+8).
 *
 * @param request GetResourceConfigurationTimelineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetResourceConfigurationTimelineResponse
 */
func (client *Client) GetResourceConfigurationTimelineWithOptions(request *GetResourceConfigurationTimelineRequest, runtime *util.RuntimeOptions) (_result *GetResourceConfigurationTimelineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetResourceConfigurationTimeline"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetResourceConfigurationTimelineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query the configuration timeline of the `new-bucket` resource that resides in the `cn-hangzhou` region. The new-bucket resource is an Object Storage Service (OSS) bucket. The return result shows that the timestamp when the resource configuration changes is `1624961112000`. The timestamp indicates 18:05:12 on June 29, 2021 (UTC+8).
 *
 * @param request GetResourceConfigurationTimelineRequest
 * @return GetResourceConfigurationTimelineResponse
 */
func (client *Client) GetResourceConfigurationTimeline(request *GetResourceConfigurationTimelineRequest) (_result *GetResourceConfigurationTimelineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetResourceConfigurationTimelineResponse{}
	_body, _err := client.GetResourceConfigurationTimelineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetResourceInventoryWithOptions(runtime *util.RuntimeOptions) (_result *GetResourceInventoryResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("GetResourceInventory"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetResourceInventoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetResourceInventory() (_result *GetResourceInventoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetResourceInventoryResponse{}
	_body, _err := client.GetResourceInventoryWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example to show how to query the resource relationships that are supported by the ACS::ECS::Instance resource type.
 *
 * @param request GetSupportedResourceRelationConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSupportedResourceRelationConfigResponse
 */
func (client *Client) GetSupportedResourceRelationConfigWithOptions(request *GetSupportedResourceRelationConfigRequest, runtime *util.RuntimeOptions) (_result *GetSupportedResourceRelationConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSupportedResourceRelationConfig"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSupportedResourceRelationConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example to show how to query the resource relationships that are supported by the ACS::ECS::Instance resource type.
 *
 * @param request GetSupportedResourceRelationConfigRequest
 * @return GetSupportedResourceRelationConfigResponse
 */
func (client *Client) GetSupportedResourceRelationConfig(request *GetSupportedResourceRelationConfigRequest) (_result *GetSupportedResourceRelationConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSupportedResourceRelationConfigResponse{}
	_body, _err := client.GetSupportedResourceRelationConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you ignore a resource that is evaluated as incompliant by using a rule, the resource is still evaluated by using the rule, but the compliance result is Ignored.
 * This example shows how to ignore the `lb-hp3a3b4ztyfm2plgm****` incompliant resource that is evaluated by using the `cr-7e72626622af0051***` rule in the `120886317861****` member account of the `ca-5b6c626622af008f****` account group. The ID of the region where the resource resides is `cn-beijing`, and the type of the resource is `ACS::SLB::LoadBalancer`.
 *
 * @param tmpReq IgnoreAggregateEvaluationResultsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return IgnoreAggregateEvaluationResultsResponse
 */
func (client *Client) IgnoreAggregateEvaluationResultsWithOptions(tmpReq *IgnoreAggregateEvaluationResultsRequest, runtime *util.RuntimeOptions) (_result *IgnoreAggregateEvaluationResultsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &IgnoreAggregateEvaluationResultsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Resources)) {
		request.ResourcesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Resources, tea.String("Resources"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		body["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		body["ConfigRuleId"] = request.ConfigRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.IgnoreDate)) {
		body["IgnoreDate"] = request.IgnoreDate
	}

	if !tea.BoolValue(util.IsUnset(request.Reason)) {
		body["Reason"] = request.Reason
	}

	if !tea.BoolValue(util.IsUnset(request.ResourcesShrink)) {
		body["Resources"] = request.ResourcesShrink
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("IgnoreAggregateEvaluationResults"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &IgnoreAggregateEvaluationResultsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you ignore a resource that is evaluated as incompliant by using a rule, the resource is still evaluated by using the rule, but the compliance result is Ignored.
 * This example shows how to ignore the `lb-hp3a3b4ztyfm2plgm****` incompliant resource that is evaluated by using the `cr-7e72626622af0051***` rule in the `120886317861****` member account of the `ca-5b6c626622af008f****` account group. The ID of the region where the resource resides is `cn-beijing`, and the type of the resource is `ACS::SLB::LoadBalancer`.
 *
 * @param request IgnoreAggregateEvaluationResultsRequest
 * @return IgnoreAggregateEvaluationResultsResponse
 */
func (client *Client) IgnoreAggregateEvaluationResults(request *IgnoreAggregateEvaluationResultsRequest) (_result *IgnoreAggregateEvaluationResultsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &IgnoreAggregateEvaluationResultsResponse{}
	_body, _err := client.IgnoreAggregateEvaluationResultsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you ignore a resource that is evaluated as incompliant by using a rule, the resource is still evaluated by using the rule, but the compliance result is Ignored.
 * This example shows how to ignore the `lb-hp3a3b4ztyfm2plgm****` resource that is evaluated as incompliant by using the `cr-7e72626622af0051****` rule in the `100931896542****` account. The ID of the region in which the resource resides is `cn-beijing`, and the type of the resource is `ACS::SLB::LoadBalancer`.
 *
 * @param tmpReq IgnoreEvaluationResultsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return IgnoreEvaluationResultsResponse
 */
func (client *Client) IgnoreEvaluationResultsWithOptions(tmpReq *IgnoreEvaluationResultsRequest, runtime *util.RuntimeOptions) (_result *IgnoreEvaluationResultsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &IgnoreEvaluationResultsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Resources)) {
		request.ResourcesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Resources, tea.String("Resources"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		body["ConfigRuleId"] = request.ConfigRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.IgnoreDate)) {
		body["IgnoreDate"] = request.IgnoreDate
	}

	if !tea.BoolValue(util.IsUnset(request.Reason)) {
		body["Reason"] = request.Reason
	}

	if !tea.BoolValue(util.IsUnset(request.ResourcesShrink)) {
		body["Resources"] = request.ResourcesShrink
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("IgnoreEvaluationResults"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &IgnoreEvaluationResultsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you ignore a resource that is evaluated as incompliant by using a rule, the resource is still evaluated by using the rule, but the compliance result is Ignored.
 * This example shows how to ignore the `lb-hp3a3b4ztyfm2plgm****` resource that is evaluated as incompliant by using the `cr-7e72626622af0051****` rule in the `100931896542****` account. The ID of the region in which the resource resides is `cn-beijing`, and the type of the resource is `ACS::SLB::LoadBalancer`.
 *
 * @param request IgnoreEvaluationResultsRequest
 * @return IgnoreEvaluationResultsResponse
 */
func (client *Client) IgnoreEvaluationResults(request *IgnoreEvaluationResultsRequest) (_result *IgnoreEvaluationResultsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &IgnoreEvaluationResultsResponse{}
	_body, _err := client.IgnoreEvaluationResultsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In this topic, the `ca-f632626622af0079****` account group is used as an example. The return result shows one compliance package whose ID is `cp-fdc8626622af00f9****`.
 *
 * @param request ListAggregateCompliancePacksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAggregateCompliancePacksResponse
 */
func (client *Client) ListAggregateCompliancePacksWithOptions(request *ListAggregateCompliancePacksRequest, runtime *util.RuntimeOptions) (_result *ListAggregateCompliancePacksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAggregateCompliancePacks"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAggregateCompliancePacksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In this topic, the `ca-f632626622af0079****` account group is used as an example. The return result shows one compliance package whose ID is `cp-fdc8626622af00f9****`.
 *
 * @param request ListAggregateCompliancePacksRequest
 * @return ListAggregateCompliancePacksResponse
 */
func (client *Client) ListAggregateCompliancePacks(request *ListAggregateCompliancePacksRequest) (_result *ListAggregateCompliancePacksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAggregateCompliancePacksResponse{}
	_body, _err := client.ListAggregateCompliancePacksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAggregateConfigDeliveryChannelsWithOptions(request *ListAggregateConfigDeliveryChannelsRequest, runtime *util.RuntimeOptions) (_result *ListAggregateConfigDeliveryChannelsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelIds)) {
		query["DeliveryChannelIds"] = request.DeliveryChannelIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAggregateConfigDeliveryChannels"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAggregateConfigDeliveryChannelsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAggregateConfigDeliveryChannels(request *ListAggregateConfigDeliveryChannelsRequest) (_result *ListAggregateConfigDeliveryChannelsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAggregateConfigDeliveryChannelsResponse{}
	_body, _err := client.ListAggregateConfigDeliveryChannelsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the compliance evaluation results of resources based on the `cr-888f626622af00ae****` rule in the `ca-d1e3326622af00cb****` account group. The returned result indicates that the `Bucket-test` resource is evaluated as `NON_COMPLIANT` by using the rule. The resource is an Object Storage Service (OSS) bucket.
 *
 * @param request ListAggregateConfigRuleEvaluationResultsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAggregateConfigRuleEvaluationResultsResponse
 */
func (client *Client) ListAggregateConfigRuleEvaluationResultsWithOptions(request *ListAggregateConfigRuleEvaluationResultsRequest, runtime *util.RuntimeOptions) (_result *ListAggregateConfigRuleEvaluationResultsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackId)) {
		query["CompliancePackId"] = request.CompliancePackId
	}

	if !tea.BoolValue(util.IsUnset(request.ComplianceType)) {
		query["ComplianceType"] = request.ComplianceType
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		query["ConfigRuleId"] = request.ConfigRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.Regions)) {
		query["Regions"] = request.Regions
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceAccountId)) {
		query["ResourceAccountId"] = request.ResourceAccountId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupIds)) {
		query["ResourceGroupIds"] = request.ResourceGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceTypes)) {
		query["ResourceTypes"] = request.ResourceTypes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAggregateConfigRuleEvaluationResults"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAggregateConfigRuleEvaluationResultsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the compliance evaluation results of resources based on the `cr-888f626622af00ae****` rule in the `ca-d1e3326622af00cb****` account group. The returned result indicates that the `Bucket-test` resource is evaluated as `NON_COMPLIANT` by using the rule. The resource is an Object Storage Service (OSS) bucket.
 *
 * @param request ListAggregateConfigRuleEvaluationResultsRequest
 * @return ListAggregateConfigRuleEvaluationResultsResponse
 */
func (client *Client) ListAggregateConfigRuleEvaluationResults(request *ListAggregateConfigRuleEvaluationResultsRequest) (_result *ListAggregateConfigRuleEvaluationResultsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAggregateConfigRuleEvaluationResultsResponse{}
	_body, _err := client.ListAggregateConfigRuleEvaluationResultsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAggregateConfigRuleEvaluationStatisticsWithOptions(request *ListAggregateConfigRuleEvaluationStatisticsRequest, runtime *util.RuntimeOptions) (_result *ListAggregateConfigRuleEvaluationStatisticsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAggregateConfigRuleEvaluationStatistics"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAggregateConfigRuleEvaluationStatisticsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAggregateConfigRuleEvaluationStatistics(request *ListAggregateConfigRuleEvaluationStatisticsRequest) (_result *ListAggregateConfigRuleEvaluationStatisticsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAggregateConfigRuleEvaluationStatisticsResponse{}
	_body, _err := client.ListAggregateConfigRuleEvaluationStatisticsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the rules in an account group whose ID is `ca-f632626622af0079****`. The returned result shows a total of one rule and two evaluated resources. The resources are both evaluated as `COMPLIANT`.
 *
 * @param request ListAggregateConfigRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAggregateConfigRulesResponse
 */
func (client *Client) ListAggregateConfigRulesWithOptions(request *ListAggregateConfigRulesRequest, runtime *util.RuntimeOptions) (_result *ListAggregateConfigRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ComplianceType)) {
		query["ComplianceType"] = request.ComplianceType
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleName)) {
		query["ConfigRuleName"] = request.ConfigRuleName
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleState)) {
		query["ConfigRuleState"] = request.ConfigRuleState
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceTypes)) {
		query["ResourceTypes"] = request.ResourceTypes
	}

	if !tea.BoolValue(util.IsUnset(request.RiskLevel)) {
		query["RiskLevel"] = request.RiskLevel
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAggregateConfigRules"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAggregateConfigRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the rules in an account group whose ID is `ca-f632626622af0079****`. The returned result shows a total of one rule and two evaluated resources. The resources are both evaluated as `COMPLIANT`.
 *
 * @param request ListAggregateConfigRulesRequest
 * @return ListAggregateConfigRulesResponse
 */
func (client *Client) ListAggregateConfigRules(request *ListAggregateConfigRulesRequest) (_result *ListAggregateConfigRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAggregateConfigRulesResponse{}
	_body, _err := client.ListAggregateConfigRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query a list of resources in the `ca-c560626622af0005****` account group. The returned result shows that eight resources exist in the account group.
 *
 * @param request ListAggregateDiscoveredResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAggregateDiscoveredResourcesResponse
 */
func (client *Client) ListAggregateDiscoveredResourcesWithOptions(request *ListAggregateDiscoveredResourcesRequest, runtime *util.RuntimeOptions) (_result *ListAggregateDiscoveredResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.Regions)) {
		query["Regions"] = request.Regions
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceAccountId)) {
		query["ResourceAccountId"] = request.ResourceAccountId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceDeleted)) {
		query["ResourceDeleted"] = request.ResourceDeleted
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceTypes)) {
		query["ResourceTypes"] = request.ResourceTypes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAggregateDiscoveredResources"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAggregateDiscoveredResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query a list of resources in the `ca-c560626622af0005****` account group. The returned result shows that eight resources exist in the account group.
 *
 * @param request ListAggregateDiscoveredResourcesRequest
 * @return ListAggregateDiscoveredResourcesResponse
 */
func (client *Client) ListAggregateDiscoveredResources(request *ListAggregateDiscoveredResourcesRequest) (_result *ListAggregateDiscoveredResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAggregateDiscoveredResourcesResponse{}
	_body, _err := client.ListAggregateDiscoveredResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAggregateRemediationExecutionsWithOptions(request *ListAggregateRemediationExecutionsRequest, runtime *util.RuntimeOptions) (_result *ListAggregateRemediationExecutionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		query["ConfigRuleId"] = request.ConfigRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.ExecutionStatus)) {
		query["ExecutionStatus"] = request.ExecutionStatus
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceAccountId)) {
		query["ResourceAccountId"] = request.ResourceAccountId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAggregateRemediationExecutions"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAggregateRemediationExecutionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAggregateRemediationExecutions(request *ListAggregateRemediationExecutionsRequest) (_result *ListAggregateRemediationExecutionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAggregateRemediationExecutionsResponse{}
	_body, _err := client.ListAggregateRemediationExecutionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the remediation templates of the rule whose ID is `cr-6b7c626622af00b4****` in the account group whose ID is `ca-6b4a626622af0012****`.
 *
 * @param request ListAggregateRemediationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAggregateRemediationsResponse
 */
func (client *Client) ListAggregateRemediationsWithOptions(request *ListAggregateRemediationsRequest, runtime *util.RuntimeOptions) (_result *ListAggregateRemediationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAggregateRemediations"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAggregateRemediationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the remediation templates of the rule whose ID is `cr-6b7c626622af00b4****` in the account group whose ID is `ca-6b4a626622af0012****`.
 *
 * @param request ListAggregateRemediationsRequest
 * @return ListAggregateRemediationsResponse
 */
func (client *Client) ListAggregateRemediations(request *ListAggregateRemediationsRequest) (_result *ListAggregateRemediationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAggregateRemediationsResponse{}
	_body, _err := client.ListAggregateRemediationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This example shows how to query the compliance evaluation result of the `23642660635396****` resource in the `ca-7f00626622af0041****` account group. The resource is a RAM user. The returned result indicates that the resource is evaluated as `NON_COMPLIANT` by using the `cr-7f7d626622af0041****` rule.
 *
 * @param request ListAggregateResourceEvaluationResultsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAggregateResourceEvaluationResultsResponse
 */
func (client *Client) ListAggregateResourceEvaluationResultsWithOptions(request *ListAggregateResourceEvaluationResultsRequest, runtime *util.RuntimeOptions) (_result *ListAggregateResourceEvaluationResultsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ComplianceType)) {
		query["ComplianceType"] = request.ComplianceType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAggregateResourceEvaluationResults"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAggregateResourceEvaluationResultsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This example shows how to query the compliance evaluation result of the `23642660635396****` resource in the `ca-7f00626622af0041****` account group. The resource is a RAM user. The returned result indicates that the resource is evaluated as `NON_COMPLIANT` by using the `cr-7f7d626622af0041****` rule.
 *
 * @param request ListAggregateResourceEvaluationResultsRequest
 * @return ListAggregateResourceEvaluationResultsResponse
 */
func (client *Client) ListAggregateResourceEvaluationResults(request *ListAggregateResourceEvaluationResultsRequest) (_result *ListAggregateResourceEvaluationResultsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAggregateResourceEvaluationResultsResponse{}
	_body, _err := client.ListAggregateResourceEvaluationResultsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the disks that are associated with an Elastic Compute Service (ECS) instance in an account group.
 *
 * @param request ListAggregateResourceRelationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAggregateResourceRelationsResponse
 */
func (client *Client) ListAggregateResourceRelationsWithOptions(request *ListAggregateResourceRelationsRequest, runtime *util.RuntimeOptions) (_result *ListAggregateResourceRelationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.RelationType)) {
		query["RelationType"] = request.RelationType
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceAccountId)) {
		query["ResourceAccountId"] = request.ResourceAccountId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TargetResourceId)) {
		query["TargetResourceId"] = request.TargetResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetResourceType)) {
		query["TargetResourceType"] = request.TargetResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAggregateResourceRelations"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAggregateResourceRelationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the disks that are associated with an Elastic Compute Service (ECS) instance in an account group.
 *
 * @param request ListAggregateResourceRelationsRequest
 * @return ListAggregateResourceRelationsResponse
 */
func (client *Client) ListAggregateResourceRelations(request *ListAggregateResourceRelationsRequest) (_result *ListAggregateResourceRelationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAggregateResourceRelationsResponse{}
	_body, _err := client.ListAggregateResourceRelationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAggregateResourcesByAdvancedSearchWithOptions(request *ListAggregateResourcesByAdvancedSearchRequest, runtime *util.RuntimeOptions) (_result *ListAggregateResourcesByAdvancedSearchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.Sql)) {
		query["Sql"] = request.Sql
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAggregateResourcesByAdvancedSearch"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAggregateResourcesByAdvancedSearchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAggregateResourcesByAdvancedSearch(request *ListAggregateResourcesByAdvancedSearchRequest) (_result *ListAggregateResourcesByAdvancedSearchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAggregateResourcesByAdvancedSearchResponse{}
	_body, _err := client.ListAggregateResourcesByAdvancedSearchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query account groups. A maximum of 10 entries can be returned for the request. As shown in the responses, the account group returned is named as `Test_Group`, its description is `Test account group`, and it is of the `CUSTOM` type, which indicates a custom account group. The account group contains two member accounts.
 *
 * @param request ListAggregatorsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAggregatorsResponse
 */
func (client *Client) ListAggregatorsWithOptions(request *ListAggregatorsRequest, runtime *util.RuntimeOptions) (_result *ListAggregatorsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAggregators"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAggregatorsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The sample request in this topic shows you how to query account groups. A maximum of 10 entries can be returned for the request. As shown in the responses, the account group returned is named as `Test_Group`, its description is `Test account group`, and it is of the `CUSTOM` type, which indicates a custom account group. The account group contains two member accounts.
 *
 * @param request ListAggregatorsRequest
 * @return ListAggregatorsResponse
 */
func (client *Client) ListAggregators(request *ListAggregatorsRequest) (_result *ListAggregatorsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAggregatorsResponse{}
	_body, _err := client.ListAggregatorsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the details of a compliance package template whose ID is `ct-d254ff4e06a300cf****`. The returned result indicates that the template name is `BestPracticesForNetwork`, the template ID is `ct-d254ff4e06a300cf****`, and the ID of the managed rule of the template is `slb-servercertificate-expired-check`.
 *
 * @param request ListCompliancePackTemplatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCompliancePackTemplatesResponse
 */
func (client *Client) ListCompliancePackTemplatesWithOptions(request *ListCompliancePackTemplatesRequest, runtime *util.RuntimeOptions) (_result *ListCompliancePackTemplatesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CompliancePackTemplateId)) {
		query["CompliancePackTemplateId"] = request.CompliancePackTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceTypes)) {
		query["ResourceTypes"] = request.ResourceTypes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCompliancePackTemplates"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCompliancePackTemplatesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the details of a compliance package template whose ID is `ct-d254ff4e06a300cf****`. The returned result indicates that the template name is `BestPracticesForNetwork`, the template ID is `ct-d254ff4e06a300cf****`, and the ID of the managed rule of the template is `slb-servercertificate-expired-check`.
 *
 * @param request ListCompliancePackTemplatesRequest
 * @return ListCompliancePackTemplatesResponse
 */
func (client *Client) ListCompliancePackTemplates(request *ListCompliancePackTemplatesRequest) (_result *ListCompliancePackTemplatesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCompliancePackTemplatesResponse{}
	_body, _err := client.ListCompliancePackTemplatesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example of how to query compliance packages. The return result shows the details of the `cp-fdc8626622af00f9****` compliance package.
 *
 * @param request ListCompliancePacksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCompliancePacksResponse
 */
func (client *Client) ListCompliancePacksWithOptions(request *ListCompliancePacksRequest, runtime *util.RuntimeOptions) (_result *ListCompliancePacksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCompliancePacks"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCompliancePacksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example of how to query compliance packages. The return result shows the details of the `cp-fdc8626622af00f9****` compliance package.
 *
 * @param request ListCompliancePacksRequest
 * @return ListCompliancePacksResponse
 */
func (client *Client) ListCompliancePacks(request *ListCompliancePacksRequest) (_result *ListCompliancePacksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCompliancePacksResponse{}
	_body, _err := client.ListCompliancePacksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListConfigDeliveryChannelsWithOptions(request *ListConfigDeliveryChannelsRequest, runtime *util.RuntimeOptions) (_result *ListConfigDeliveryChannelsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelIds)) {
		query["DeliveryChannelIds"] = request.DeliveryChannelIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListConfigDeliveryChannels"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListConfigDeliveryChannelsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListConfigDeliveryChannels(request *ListConfigDeliveryChannelsRequest) (_result *ListConfigDeliveryChannelsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListConfigDeliveryChannelsResponse{}
	_body, _err := client.ListConfigDeliveryChannelsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the compliance evaluation result of resources based on a rule whose ID is `cr-cac56457e0d900d3****`. The returned result indicates that the `i-hp3e4kvhzqn2s11t****` resource is evaluated as `NON_COMPLIANT` by using the rule. The resource is an Elastic Compute Service (ECS) instance.
 *
 * @param request ListConfigRuleEvaluationResultsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListConfigRuleEvaluationResultsResponse
 */
func (client *Client) ListConfigRuleEvaluationResultsWithOptions(request *ListConfigRuleEvaluationResultsRequest, runtime *util.RuntimeOptions) (_result *ListConfigRuleEvaluationResultsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListConfigRuleEvaluationResults"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListConfigRuleEvaluationResultsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the compliance evaluation result of resources based on a rule whose ID is `cr-cac56457e0d900d3****`. The returned result indicates that the `i-hp3e4kvhzqn2s11t****` resource is evaluated as `NON_COMPLIANT` by using the rule. The resource is an Elastic Compute Service (ECS) instance.
 *
 * @param request ListConfigRuleEvaluationResultsRequest
 * @return ListConfigRuleEvaluationResultsResponse
 */
func (client *Client) ListConfigRuleEvaluationResults(request *ListConfigRuleEvaluationResultsRequest) (_result *ListConfigRuleEvaluationResultsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListConfigRuleEvaluationResultsResponse{}
	_body, _err := client.ListConfigRuleEvaluationResultsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListConfigRuleEvaluationStatisticsWithOptions(runtime *util.RuntimeOptions) (_result *ListConfigRuleEvaluationStatisticsResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("ListConfigRuleEvaluationStatistics"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListConfigRuleEvaluationStatisticsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListConfigRuleEvaluationStatistics() (_result *ListConfigRuleEvaluationStatisticsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListConfigRuleEvaluationStatisticsResponse{}
	_body, _err := client.ListConfigRuleEvaluationStatisticsWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the rules of the current account. The response shows that the current account has a total of one rule and three evaluated resources. The resources are evaluated as compliant.
 *
 * @param request ListConfigRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListConfigRulesResponse
 */
func (client *Client) ListConfigRulesWithOptions(request *ListConfigRulesRequest, runtime *util.RuntimeOptions) (_result *ListConfigRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ComplianceType)) {
		query["ComplianceType"] = request.ComplianceType
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleName)) {
		query["ConfigRuleName"] = request.ConfigRuleName
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleState)) {
		query["ConfigRuleState"] = request.ConfigRuleState
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceTypes)) {
		query["ResourceTypes"] = request.ResourceTypes
	}

	if !tea.BoolValue(util.IsUnset(request.RiskLevel)) {
		query["RiskLevel"] = request.RiskLevel
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListConfigRules"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListConfigRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the rules of the current account. The response shows that the current account has a total of one rule and three evaluated resources. The resources are evaluated as compliant.
 *
 * @param request ListConfigRulesRequest
 * @return ListConfigRulesResponse
 */
func (client *Client) ListConfigRules(request *ListConfigRulesRequest) (_result *ListConfigRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListConfigRulesResponse{}
	_body, _err := client.ListConfigRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to call the ListDiscoveredResources operation to query the resources in the current Alibaba Cloud account. The returned result indicates that a total of eight resources exist in the account.
 *
 * @param request ListDiscoveredResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDiscoveredResourcesResponse
 */
func (client *Client) ListDiscoveredResourcesWithOptions(request *ListDiscoveredResourcesRequest, runtime *util.RuntimeOptions) (_result *ListDiscoveredResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.Regions)) {
		query["Regions"] = request.Regions
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceDeleted)) {
		query["ResourceDeleted"] = request.ResourceDeleted
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceTypes)) {
		query["ResourceTypes"] = request.ResourceTypes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDiscoveredResources"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDiscoveredResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to call the ListDiscoveredResources operation to query the resources in the current Alibaba Cloud account. The returned result indicates that a total of eight resources exist in the account.
 *
 * @param request ListDiscoveredResourcesRequest
 * @return ListDiscoveredResourcesResponse
 */
func (client *Client) ListDiscoveredResources(request *ListDiscoveredResourcesRequest) (_result *ListDiscoveredResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDiscoveredResourcesResponse{}
	_body, _err := client.ListDiscoveredResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListIntegratedServiceWithOptions(runtime *util.RuntimeOptions) (_result *ListIntegratedServiceResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("ListIntegratedService"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListIntegratedServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListIntegratedService() (_result *ListIntegratedServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListIntegratedServiceResponse{}
	_body, _err := client.ListIntegratedServiceWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic describes how to query the managed rules of Alibaba Cloud CDN by using the `CDN` keyword. The returned result shows that only one managed rule exists. You can view the rule details in the result.
 *
 * @param request ListManagedRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListManagedRulesResponse
 */
func (client *Client) ListManagedRulesWithOptions(request *ListManagedRulesRequest, runtime *util.RuntimeOptions) (_result *ListManagedRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceTypes)) {
		query["ResourceTypes"] = request.ResourceTypes
	}

	if !tea.BoolValue(util.IsUnset(request.RiskLevel)) {
		query["RiskLevel"] = request.RiskLevel
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListManagedRules"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListManagedRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic describes how to query the managed rules of Alibaba Cloud CDN by using the `CDN` keyword. The returned result shows that only one managed rule exists. You can view the rule details in the result.
 *
 * @param request ListManagedRulesRequest
 * @return ListManagedRulesResponse
 */
func (client *Client) ListManagedRules(request *ListManagedRulesRequest) (_result *ListManagedRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListManagedRulesResponse{}
	_body, _err := client.ListManagedRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListPreManagedRulesWithOptions(tmpReq *ListPreManagedRulesRequest, runtime *util.RuntimeOptions) (_result *ListPreManagedRulesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListPreManagedRulesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ResourceTypes)) {
		request.ResourceTypesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ResourceTypes, tea.String("ResourceTypes"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceTypesShrink)) {
		body["ResourceTypes"] = request.ResourceTypesShrink
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPreManagedRules"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPreManagedRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListPreManagedRules(request *ListPreManagedRulesRequest) (_result *ListPreManagedRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListPreManagedRulesResponse{}
	_body, _err := client.ListPreManagedRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListRemediationExecutionsWithOptions(request *ListRemediationExecutionsRequest, runtime *util.RuntimeOptions) (_result *ListRemediationExecutionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		query["ConfigRuleId"] = request.ConfigRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.ExecutionStatus)) {
		query["ExecutionStatus"] = request.ExecutionStatus
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListRemediationExecutions"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListRemediationExecutionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListRemediationExecutions(request *ListRemediationExecutionsRequest) (_result *ListRemediationExecutionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListRemediationExecutionsResponse{}
	_body, _err := client.ListRemediationExecutionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In this topic, the `oss-bucket-public-write-prohibited` managed rule is used as an example. The return result shows the details of the remediation template of the `OOS` type for the managed rule. OOS represents Operation Orchestration Service.
 *
 * @param request ListRemediationTemplatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRemediationTemplatesResponse
 */
func (client *Client) ListRemediationTemplatesWithOptions(request *ListRemediationTemplatesRequest, runtime *util.RuntimeOptions) (_result *ListRemediationTemplatesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ManagedRuleIdentifier)) {
		query["ManagedRuleIdentifier"] = request.ManagedRuleIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RemediationType)) {
		query["RemediationType"] = request.RemediationType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListRemediationTemplates"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListRemediationTemplatesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In this topic, the `oss-bucket-public-write-prohibited` managed rule is used as an example. The return result shows the details of the remediation template of the `OOS` type for the managed rule. OOS represents Operation Orchestration Service.
 *
 * @param request ListRemediationTemplatesRequest
 * @return ListRemediationTemplatesResponse
 */
func (client *Client) ListRemediationTemplates(request *ListRemediationTemplatesRequest) (_result *ListRemediationTemplatesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListRemediationTemplatesResponse{}
	_body, _err := client.ListRemediationTemplatesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the remediation templates for the rule whose ID is `cr-6b7c626622af00b4****`.
 *
 * @param request ListRemediationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRemediationsResponse
 */
func (client *Client) ListRemediationsWithOptions(request *ListRemediationsRequest, runtime *util.RuntimeOptions) (_result *ListRemediationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigRuleIds)) {
		query["ConfigRuleIds"] = request.ConfigRuleIds
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListRemediations"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListRemediationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the remediation templates for the rule whose ID is `cr-6b7c626622af00b4****`.
 *
 * @param request ListRemediationsRequest
 * @return ListRemediationsResponse
 */
func (client *Client) ListRemediations(request *ListRemediationsRequest) (_result *ListRemediationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListRemediationsResponse{}
	_body, _err := client.ListRemediationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In this example, the compliance evaluation result of the `23642660635396****` resource is queried and the resource is a RAM user. The returned result indicates that the resource is evaluated as `NON_COMPLIANT` by using the `cr-7f7d626622af0041****` rule.
 *
 * @param request ListResourceEvaluationResultsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListResourceEvaluationResultsResponse
 */
func (client *Client) ListResourceEvaluationResultsWithOptions(request *ListResourceEvaluationResultsRequest, runtime *util.RuntimeOptions) (_result *ListResourceEvaluationResultsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ComplianceType)) {
		query["ComplianceType"] = request.ComplianceType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListResourceEvaluationResults"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListResourceEvaluationResultsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In this example, the compliance evaluation result of the `23642660635396****` resource is queried and the resource is a RAM user. The returned result indicates that the resource is evaluated as `NON_COMPLIANT` by using the `cr-7f7d626622af0041****` rule.
 *
 * @param request ListResourceEvaluationResultsRequest
 * @return ListResourceEvaluationResultsResponse
 */
func (client *Client) ListResourceEvaluationResults(request *ListResourceEvaluationResultsRequest) (_result *ListResourceEvaluationResultsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListResourceEvaluationResultsResponse{}
	_body, _err := client.ListResourceEvaluationResultsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to query the disks that are associated with an Elastic Compute Service (ECS) instance within the current Alibaba Cloud account.
 *
 * @param request ListResourceRelationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListResourceRelationsResponse
 */
func (client *Client) ListResourceRelationsWithOptions(request *ListResourceRelationsRequest, runtime *util.RuntimeOptions) (_result *ListResourceRelationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.Region)) {
		query["Region"] = request.Region
	}

	if !tea.BoolValue(util.IsUnset(request.RelationType)) {
		query["RelationType"] = request.RelationType
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TargetResourceId)) {
		query["TargetResourceId"] = request.TargetResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetResourceType)) {
		query["TargetResourceType"] = request.TargetResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListResourceRelations"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListResourceRelationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to query the disks that are associated with an Elastic Compute Service (ECS) instance within the current Alibaba Cloud account.
 *
 * @param request ListResourceRelationsRequest
 * @return ListResourceRelationsResponse
 */
func (client *Client) ListResourceRelations(request *ListResourceRelationsRequest) (_result *ListResourceRelationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListResourceRelationsResponse{}
	_body, _err := client.ListResourceRelationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListResourcesByAdvancedSearchWithOptions(request *ListResourcesByAdvancedSearchRequest, runtime *util.RuntimeOptions) (_result *ListResourcesByAdvancedSearchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Sql)) {
		query["Sql"] = request.Sql
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListResourcesByAdvancedSearch"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListResourcesByAdvancedSearchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListResourcesByAdvancedSearch(request *ListResourcesByAdvancedSearchRequest) (_result *ListResourcesByAdvancedSearchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListResourcesByAdvancedSearchResponse{}
	_body, _err := client.ListResourcesByAdvancedSearchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSupportedProductsWithOptions(request *ListSupportedProductsRequest, runtime *util.RuntimeOptions) (_result *ListSupportedProductsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSupportedProducts"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSupportedProductsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSupportedProducts(request *ListSupportedProductsRequest) (_result *ListSupportedProductsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSupportedProductsResponse{}
	_body, _err := client.ListSupportedProductsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTagResourcesWithOptions(tmpReq *ListTagResourcesRequest, runtime *util.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListTagResourcesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Tag)) {
		request.TagShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tag, tea.String("Tag"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		body["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		body["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		body["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		body["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagShrink)) {
		body["Tag"] = request.TagShrink
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResources"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PutEvaluationsWithOptions(request *PutEvaluationsRequest, runtime *util.RuntimeOptions) (_result *PutEvaluationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeleteMode)) {
		body["DeleteMode"] = request.DeleteMode
	}

	if !tea.BoolValue(util.IsUnset(request.Evaluations)) {
		body["Evaluations"] = request.Evaluations
	}

	if !tea.BoolValue(util.IsUnset(request.ResultToken)) {
		body["ResultToken"] = request.ResultToken
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("PutEvaluations"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PutEvaluationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PutEvaluations(request *PutEvaluationsRequest) (_result *PutEvaluationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PutEvaluationsResponse{}
	_body, _err := client.PutEvaluationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Prerequisites
 * One or more non-compliant resources that are evaluated based on a rule are ignored.
 * ### Usage notes
 * The sample request in this topic shows you how to re-evaluate the `lb-hp3a3b4ztyfm2plgm****` non-compliant resource that is evaluated by the `cr-7e72626622af0051***` rule in the `120886317861****` member account of the `ca-5b6c626622af008f****` account group. The ID of the region in which the resource resides is `cn-beijing`, and the type of the resource is `ACS::SLB::LoadBalancer`.
 *
 * @param tmpReq RevertAggregateEvaluationResultsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevertAggregateEvaluationResultsResponse
 */
func (client *Client) RevertAggregateEvaluationResultsWithOptions(tmpReq *RevertAggregateEvaluationResultsRequest, runtime *util.RuntimeOptions) (_result *RevertAggregateEvaluationResultsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &RevertAggregateEvaluationResultsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Resources)) {
		request.ResourcesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Resources, tea.String("Resources"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		body["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		body["ConfigRuleId"] = request.ConfigRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourcesShrink)) {
		body["Resources"] = request.ResourcesShrink
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("RevertAggregateEvaluationResults"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RevertAggregateEvaluationResultsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Prerequisites
 * One or more non-compliant resources that are evaluated based on a rule are ignored.
 * ### Usage notes
 * The sample request in this topic shows you how to re-evaluate the `lb-hp3a3b4ztyfm2plgm****` non-compliant resource that is evaluated by the `cr-7e72626622af0051***` rule in the `120886317861****` member account of the `ca-5b6c626622af008f****` account group. The ID of the region in which the resource resides is `cn-beijing`, and the type of the resource is `ACS::SLB::LoadBalancer`.
 *
 * @param request RevertAggregateEvaluationResultsRequest
 * @return RevertAggregateEvaluationResultsResponse
 */
func (client *Client) RevertAggregateEvaluationResults(request *RevertAggregateEvaluationResultsRequest) (_result *RevertAggregateEvaluationResultsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RevertAggregateEvaluationResultsResponse{}
	_body, _err := client.RevertAggregateEvaluationResultsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ### Prerequisites
 * One or more non-compliant resources that are evaluated by a rule are ignored.
 * ### Usage notes
 * The sample request in this topic shows you how to re-evaluate the `lb-hp3a3b4ztyfm2plgm****` non-compliant resource that is evaluated by the `cr-7e72626622af0051****` rule. The ID of the region in which the resource resides is `cn-beijing`, and the type of the resource is `ACS::SLB::LoadBalancer`.``
 *
 * @param tmpReq RevertEvaluationResultsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevertEvaluationResultsResponse
 */
func (client *Client) RevertEvaluationResultsWithOptions(tmpReq *RevertEvaluationResultsRequest, runtime *util.RuntimeOptions) (_result *RevertEvaluationResultsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &RevertEvaluationResultsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Resources)) {
		request.ResourcesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Resources, tea.String("Resources"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		body["ConfigRuleId"] = request.ConfigRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourcesShrink)) {
		body["Resources"] = request.ResourcesShrink
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("RevertEvaluationResults"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RevertEvaluationResultsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ### Prerequisites
 * One or more non-compliant resources that are evaluated by a rule are ignored.
 * ### Usage notes
 * The sample request in this topic shows you how to re-evaluate the `lb-hp3a3b4ztyfm2plgm****` non-compliant resource that is evaluated by the `cr-7e72626622af0051****` rule. The ID of the region in which the resource resides is `cn-beijing`, and the type of the resource is `ACS::SLB::LoadBalancer`.``
 *
 * @param request RevertEvaluationResultsRequest
 * @return RevertEvaluationResultsResponse
 */
func (client *Client) RevertEvaluationResults(request *RevertEvaluationResultsRequest) (_result *RevertEvaluationResultsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RevertEvaluationResultsResponse{}
	_body, _err := client.RevertEvaluationResultsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * > After you call this operation, the compliance evaluation is performed only once. To query the compliance evaluation results returned by the rule, call the ListAggregateConfigRuleEvaluationResults operation. For more information, see [ListAggregateConfigRuleEvaluationResults](~~265979~~).
 * The sample request in this topic shows how to use the `cr-c169626622af009f****` rule in the `ca-3a58626622af0005****` account group to evaluate resources.
 *
 * @param request StartAggregateConfigRuleEvaluationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartAggregateConfigRuleEvaluationResponse
 */
func (client *Client) StartAggregateConfigRuleEvaluationWithOptions(request *StartAggregateConfigRuleEvaluationRequest, runtime *util.RuntimeOptions) (_result *StartAggregateConfigRuleEvaluationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackId)) {
		query["CompliancePackId"] = request.CompliancePackId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		query["ConfigRuleId"] = request.ConfigRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.RevertEvaluation)) {
		query["RevertEvaluation"] = request.RevertEvaluation
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartAggregateConfigRuleEvaluation"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartAggregateConfigRuleEvaluationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * > After you call this operation, the compliance evaluation is performed only once. To query the compliance evaluation results returned by the rule, call the ListAggregateConfigRuleEvaluationResults operation. For more information, see [ListAggregateConfigRuleEvaluationResults](~~265979~~).
 * The sample request in this topic shows how to use the `cr-c169626622af009f****` rule in the `ca-3a58626622af0005****` account group to evaluate resources.
 *
 * @param request StartAggregateConfigRuleEvaluationRequest
 * @return StartAggregateConfigRuleEvaluationResponse
 */
func (client *Client) StartAggregateConfigRuleEvaluation(request *StartAggregateConfigRuleEvaluationRequest) (_result *StartAggregateConfigRuleEvaluationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartAggregateConfigRuleEvaluationResponse{}
	_body, _err := client.StartAggregateConfigRuleEvaluationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to manually perform a remediation operation by using the rule whose ID is `cr-6b7c626622af00b4****` in the account group whose ID is `ca-6b4a626622af0012****`. The return result shows that the manual execution is successful.
 *
 * @param request StartAggregateRemediationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartAggregateRemediationResponse
 */
func (client *Client) StartAggregateRemediationWithOptions(request *StartAggregateRemediationRequest, runtime *util.RuntimeOptions) (_result *StartAggregateRemediationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		query["ConfigRuleId"] = request.ConfigRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceAccountId)) {
		query["ResourceAccountId"] = request.ResourceAccountId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartAggregateRemediation"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartAggregateRemediationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to manually perform a remediation operation by using the rule whose ID is `cr-6b7c626622af00b4****` in the account group whose ID is `ca-6b4a626622af0012****`. The return result shows that the manual execution is successful.
 *
 * @param request StartAggregateRemediationRequest
 * @return StartAggregateRemediationResponse
 */
func (client *Client) StartAggregateRemediation(request *StartAggregateRemediationRequest) (_result *StartAggregateRemediationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartAggregateRemediationResponse{}
	_body, _err := client.StartAggregateRemediationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StartConfigRuleEvaluationWithOptions(request *StartConfigRuleEvaluationRequest, runtime *util.RuntimeOptions) (_result *StartConfigRuleEvaluationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CompliancePackId)) {
		query["CompliancePackId"] = request.CompliancePackId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		query["ConfigRuleId"] = request.ConfigRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.RevertEvaluation)) {
		query["RevertEvaluation"] = request.RevertEvaluation
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartConfigRuleEvaluation"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartConfigRuleEvaluationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StartConfigRuleEvaluation(request *StartConfigRuleEvaluationRequest) (_result *StartConfigRuleEvaluationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartConfigRuleEvaluationResponse{}
	_body, _err := client.StartConfigRuleEvaluationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StartConfigurationRecorderWithOptions(runtime *util.RuntimeOptions) (_result *StartConfigurationRecorderResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("StartConfigurationRecorder"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartConfigurationRecorderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StartConfigurationRecorder() (_result *StartConfigurationRecorderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartConfigurationRecorderResponse{}
	_body, _err := client.StartConfigurationRecorderWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to perform a remediation operation by using the rule whose ID is `cr-8a973ac2e2be00a2****`. The returned result shows that the manual execution is successful.
 *
 * @param request StartRemediationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartRemediationResponse
 */
func (client *Client) StartRemediationWithOptions(request *StartRemediationRequest, runtime *util.RuntimeOptions) (_result *StartRemediationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		query["ConfigRuleId"] = request.ConfigRuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartRemediation"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartRemediationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to perform a remediation operation by using the rule whose ID is `cr-8a973ac2e2be00a2****`. The returned result shows that the manual execution is successful.
 *
 * @param request StartRemediationRequest
 * @return StartRemediationResponse
 */
func (client *Client) StartRemediation(request *StartRemediationRequest) (_result *StartRemediationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartRemediationResponse{}
	_body, _err := client.StartRemediationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StopConfigurationRecorderWithOptions(runtime *util.RuntimeOptions) (_result *StopConfigurationRecorderResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("StopConfigurationRecorder"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopConfigurationRecorderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StopConfigurationRecorder() (_result *StopConfigurationRecorderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopConfigurationRecorderResponse{}
	_body, _err := client.StopConfigurationRecorderWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TagResourcesWithOptions(tmpReq *TagResourcesRequest, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &TagResourcesShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Tag)) {
		request.TagShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tag, tea.String("Tag"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		body["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		body["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		body["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagShrink)) {
		body["Tag"] = request.TagShrink
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		body["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		body["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		body["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		body["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKey)) {
		body["TagKey"] = request.TagKey
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to change the value of a parameter for a managed rule whose ID is `eip-bandwidth-limit` to `20`. The managed rule is included in the `cp-fdc8626622af00f9****` compliance package in the `ca-f632626622af0079****` account group.
 *
 * @param tmpReq UpdateAggregateCompliancePackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAggregateCompliancePackResponse
 */
func (client *Client) UpdateAggregateCompliancePackWithOptions(tmpReq *UpdateAggregateCompliancePackRequest, runtime *util.RuntimeOptions) (_result *UpdateAggregateCompliancePackResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateAggregateCompliancePackShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ConfigRules)) {
		request.ConfigRulesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ConfigRules, tea.String("ConfigRules"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		body["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackId)) {
		body["CompliancePackId"] = request.CompliancePackId
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackName)) {
		body["CompliancePackName"] = request.CompliancePackName
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRulesShrink)) {
		body["ConfigRules"] = request.ConfigRulesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeResourceIdsScope)) {
		body["ExcludeResourceIdsScope"] = request.ExcludeResourceIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.RegionIdsScope)) {
		body["RegionIdsScope"] = request.RegionIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupIdsScope)) {
		body["ResourceGroupIdsScope"] = request.ResourceGroupIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.RiskLevel)) {
		body["RiskLevel"] = request.RiskLevel
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeyScope)) {
		body["TagKeyScope"] = request.TagKeyScope
	}

	if !tea.BoolValue(util.IsUnset(request.TagValueScope)) {
		body["TagValueScope"] = request.TagValueScope
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAggregateCompliancePack"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAggregateCompliancePackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to change the value of a parameter for a managed rule whose ID is `eip-bandwidth-limit` to `20`. The managed rule is included in the `cp-fdc8626622af00f9****` compliance package in the `ca-f632626622af0079****` account group.
 *
 * @param request UpdateAggregateCompliancePackRequest
 * @return UpdateAggregateCompliancePackResponse
 */
func (client *Client) UpdateAggregateCompliancePack(request *UpdateAggregateCompliancePackRequest) (_result *UpdateAggregateCompliancePackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAggregateCompliancePackResponse{}
	_body, _err := client.UpdateAggregateCompliancePackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to disable a delivery channel in an account group. The ID of the account group is `ca-a4e5626622af0079****`, and the ID of the delivery channel is `cdc-8e45ff4e06a3a8****`. The Status parameter is set to `0`. After the delivery channel is disabled, Cloud Config retains the most recent delivery configuration and stops resource data delivery.
 *
 * @param request UpdateAggregateConfigDeliveryChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAggregateConfigDeliveryChannelResponse
 */
func (client *Client) UpdateAggregateConfigDeliveryChannelWithOptions(request *UpdateAggregateConfigDeliveryChannelRequest, runtime *util.RuntimeOptions) (_result *UpdateAggregateConfigDeliveryChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		query["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigurationItemChangeNotification)) {
		query["ConfigurationItemChangeNotification"] = request.ConfigurationItemChangeNotification
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigurationSnapshot)) {
		query["ConfigurationSnapshot"] = request.ConfigurationSnapshot
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelCondition)) {
		query["DeliveryChannelCondition"] = request.DeliveryChannelCondition
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelId)) {
		query["DeliveryChannelId"] = request.DeliveryChannelId
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelName)) {
		query["DeliveryChannelName"] = request.DeliveryChannelName
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelTargetArn)) {
		query["DeliveryChannelTargetArn"] = request.DeliveryChannelTargetArn
	}

	if !tea.BoolValue(util.IsUnset(request.DeliverySnapshotTime)) {
		query["DeliverySnapshotTime"] = request.DeliverySnapshotTime
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.NonCompliantNotification)) {
		query["NonCompliantNotification"] = request.NonCompliantNotification
	}

	if !tea.BoolValue(util.IsUnset(request.OversizedDataOSSTargetArn)) {
		query["OversizedDataOSSTargetArn"] = request.OversizedDataOSSTargetArn
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAggregateConfigDeliveryChannel"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAggregateConfigDeliveryChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to disable a delivery channel in an account group. The ID of the account group is `ca-a4e5626622af0079****`, and the ID of the delivery channel is `cdc-8e45ff4e06a3a8****`. The Status parameter is set to `0`. After the delivery channel is disabled, Cloud Config retains the most recent delivery configuration and stops resource data delivery.
 *
 * @param request UpdateAggregateConfigDeliveryChannelRequest
 * @return UpdateAggregateConfigDeliveryChannelResponse
 */
func (client *Client) UpdateAggregateConfigDeliveryChannel(request *UpdateAggregateConfigDeliveryChannelRequest) (_result *UpdateAggregateConfigDeliveryChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAggregateConfigDeliveryChannelResponse{}
	_body, _err := client.UpdateAggregateConfigDeliveryChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The sample request in this topic shows you how to change the risk level specified for the `cr-4e3d626622af0080****` managed rule to `3`, which indicates low risk level, in the `ca-a4e5626622af0079****` account group.
 *
 * @param tmpReq UpdateAggregateConfigRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAggregateConfigRuleResponse
 */
func (client *Client) UpdateAggregateConfigRuleWithOptions(tmpReq *UpdateAggregateConfigRuleRequest, runtime *util.RuntimeOptions) (_result *UpdateAggregateConfigRuleResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateAggregateConfigRuleShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.InputParameters)) {
		request.InputParametersShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.InputParameters, tea.String("InputParameters"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.ResourceTypesScope)) {
		request.ResourceTypesScopeShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ResourceTypesScope, tea.String("ResourceTypesScope"), tea.String("simple"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		body["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		body["ConfigRuleId"] = request.ConfigRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleName)) {
		body["ConfigRuleName"] = request.ConfigRuleName
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleTriggerTypes)) {
		body["ConfigRuleTriggerTypes"] = request.ConfigRuleTriggerTypes
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeAccountIdsScope)) {
		body["ExcludeAccountIdsScope"] = request.ExcludeAccountIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeFolderIdsScope)) {
		body["ExcludeFolderIdsScope"] = request.ExcludeFolderIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeResourceIdsScope)) {
		body["ExcludeResourceIdsScope"] = request.ExcludeResourceIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.FolderIdsScope)) {
		body["FolderIdsScope"] = request.FolderIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.InputParametersShrink)) {
		body["InputParameters"] = request.InputParametersShrink
	}

	if !tea.BoolValue(util.IsUnset(request.MaximumExecutionFrequency)) {
		body["MaximumExecutionFrequency"] = request.MaximumExecutionFrequency
	}

	if !tea.BoolValue(util.IsUnset(request.RegionIdsScope)) {
		body["RegionIdsScope"] = request.RegionIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupIdsScope)) {
		body["ResourceGroupIdsScope"] = request.ResourceGroupIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceTypesScopeShrink)) {
		body["ResourceTypesScope"] = request.ResourceTypesScopeShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RiskLevel)) {
		body["RiskLevel"] = request.RiskLevel
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeyLogicScope)) {
		body["TagKeyLogicScope"] = request.TagKeyLogicScope
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeyScope)) {
		body["TagKeyScope"] = request.TagKeyScope
	}

	if !tea.BoolValue(util.IsUnset(request.TagValueScope)) {
		body["TagValueScope"] = request.TagValueScope
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAggregateConfigRule"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAggregateConfigRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The sample request in this topic shows you how to change the risk level specified for the `cr-4e3d626622af0080****` managed rule to `3`, which indicates low risk level, in the `ca-a4e5626622af0079****` account group.
 *
 * @param request UpdateAggregateConfigRuleRequest
 * @return UpdateAggregateConfigRuleResponse
 */
func (client *Client) UpdateAggregateConfigRule(request *UpdateAggregateConfigRuleRequest) (_result *UpdateAggregateConfigRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAggregateConfigRuleResponse{}
	_body, _err := client.UpdateAggregateConfigRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic describes how to change the execution mode of the `crr-909ba2d4716700eb****` remediation setting for a rule in the `ca-6b4a626622af0012****` account group to `AUTO_EXECUTION`, which specifies automatic remediation. This topic also provides a sample request.
 *
 * @param request UpdateAggregateRemediationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAggregateRemediationResponse
 */
func (client *Client) UpdateAggregateRemediationWithOptions(request *UpdateAggregateRemediationRequest, runtime *util.RuntimeOptions) (_result *UpdateAggregateRemediationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		body["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.InvokeType)) {
		body["InvokeType"] = request.InvokeType
	}

	if !tea.BoolValue(util.IsUnset(request.Params)) {
		body["Params"] = request.Params
	}

	if !tea.BoolValue(util.IsUnset(request.RemediationId)) {
		body["RemediationId"] = request.RemediationId
	}

	if !tea.BoolValue(util.IsUnset(request.RemediationTemplateId)) {
		body["RemediationTemplateId"] = request.RemediationTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.RemediationType)) {
		body["RemediationType"] = request.RemediationType
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		body["SourceType"] = request.SourceType
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAggregateRemediation"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAggregateRemediationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic describes how to change the execution mode of the `crr-909ba2d4716700eb****` remediation setting for a rule in the `ca-6b4a626622af0012****` account group to `AUTO_EXECUTION`, which specifies automatic remediation. This topic also provides a sample request.
 *
 * @param request UpdateAggregateRemediationRequest
 * @return UpdateAggregateRemediationResponse
 */
func (client *Client) UpdateAggregateRemediation(request *UpdateAggregateRemediationRequest) (_result *UpdateAggregateRemediationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAggregateRemediationResponse{}
	_body, _err := client.UpdateAggregateRemediationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The sample request in this topic shows you how to add a member account to the account group whose ID is `ca-dacf86d8314e00eb****`. The member account ID is `173808452267****` and the member account name is `Tony`. The member account belongs to `ResourceDirectory`.
 *
 * @param tmpReq UpdateAggregatorRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAggregatorResponse
 */
func (client *Client) UpdateAggregatorWithOptions(tmpReq *UpdateAggregatorRequest, runtime *util.RuntimeOptions) (_result *UpdateAggregatorResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateAggregatorShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.AggregatorAccounts)) {
		request.AggregatorAccountsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.AggregatorAccounts, tea.String("AggregatorAccounts"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AggregatorAccountsShrink)) {
		body["AggregatorAccounts"] = request.AggregatorAccountsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.AggregatorId)) {
		body["AggregatorId"] = request.AggregatorId
	}

	if !tea.BoolValue(util.IsUnset(request.AggregatorName)) {
		body["AggregatorName"] = request.AggregatorName
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateAggregator"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateAggregatorResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The sample request in this topic shows you how to add a member account to the account group whose ID is `ca-dacf86d8314e00eb****`. The member account ID is `173808452267****` and the member account name is `Tony`. The member account belongs to `ResourceDirectory`.
 *
 * @param request UpdateAggregatorRequest
 * @return UpdateAggregatorResponse
 */
func (client *Client) UpdateAggregator(request *UpdateAggregatorRequest) (_result *UpdateAggregatorResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateAggregatorResponse{}
	_body, _err := client.UpdateAggregatorWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to change the value of a parameter for a managed rule whose ID is `eip-bandwidth-limit` to `20`. The managed rule is included in the `cp-a8a8626622af0082****` compliance package.
 *
 * @param tmpReq UpdateCompliancePackRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateCompliancePackResponse
 */
func (client *Client) UpdateCompliancePackWithOptions(tmpReq *UpdateCompliancePackRequest, runtime *util.RuntimeOptions) (_result *UpdateCompliancePackResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateCompliancePackShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.ConfigRules)) {
		request.ConfigRulesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ConfigRules, tea.String("ConfigRules"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackId)) {
		body["CompliancePackId"] = request.CompliancePackId
	}

	if !tea.BoolValue(util.IsUnset(request.CompliancePackName)) {
		body["CompliancePackName"] = request.CompliancePackName
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRulesShrink)) {
		body["ConfigRules"] = request.ConfigRulesShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeResourceIdsScope)) {
		body["ExcludeResourceIdsScope"] = request.ExcludeResourceIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.RegionIdsScope)) {
		body["RegionIdsScope"] = request.RegionIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupIdsScope)) {
		body["ResourceGroupIdsScope"] = request.ResourceGroupIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.RiskLevel)) {
		body["RiskLevel"] = request.RiskLevel
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeyScope)) {
		body["TagKeyScope"] = request.TagKeyScope
	}

	if !tea.BoolValue(util.IsUnset(request.TagValueScope)) {
		body["TagValueScope"] = request.TagValueScope
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCompliancePack"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateCompliancePackResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to change the value of a parameter for a managed rule whose ID is `eip-bandwidth-limit` to `20`. The managed rule is included in the `cp-a8a8626622af0082****` compliance package.
 *
 * @param request UpdateCompliancePackRequest
 * @return UpdateCompliancePackResponse
 */
func (client *Client) UpdateCompliancePack(request *UpdateCompliancePackRequest) (_result *UpdateCompliancePackResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateCompliancePackResponse{}
	_body, _err := client.UpdateCompliancePackWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In this example, a delivery channel is disabled. The ID of the delivery channel is `cdc-8e45ff4e06a3a8****```. The Status parameter is set to 0. After the delivery channel is disabled, Cloud Config retains the most recent delivery configuration and stops the delivery of resource data.
 *
 * @param request UpdateConfigDeliveryChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateConfigDeliveryChannelResponse
 */
func (client *Client) UpdateConfigDeliveryChannelWithOptions(request *UpdateConfigDeliveryChannelRequest, runtime *util.RuntimeOptions) (_result *UpdateConfigDeliveryChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigurationItemChangeNotification)) {
		query["ConfigurationItemChangeNotification"] = request.ConfigurationItemChangeNotification
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigurationSnapshot)) {
		query["ConfigurationSnapshot"] = request.ConfigurationSnapshot
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelCondition)) {
		query["DeliveryChannelCondition"] = request.DeliveryChannelCondition
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelId)) {
		query["DeliveryChannelId"] = request.DeliveryChannelId
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelName)) {
		query["DeliveryChannelName"] = request.DeliveryChannelName
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelTargetArn)) {
		query["DeliveryChannelTargetArn"] = request.DeliveryChannelTargetArn
	}

	if !tea.BoolValue(util.IsUnset(request.DeliverySnapshotTime)) {
		query["DeliverySnapshotTime"] = request.DeliverySnapshotTime
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.NonCompliantNotification)) {
		query["NonCompliantNotification"] = request.NonCompliantNotification
	}

	if !tea.BoolValue(util.IsUnset(request.OversizedDataOSSTargetArn)) {
		query["OversizedDataOSSTargetArn"] = request.OversizedDataOSSTargetArn
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateConfigDeliveryChannel"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateConfigDeliveryChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In this example, a delivery channel is disabled. The ID of the delivery channel is `cdc-8e45ff4e06a3a8****```. The Status parameter is set to 0. After the delivery channel is disabled, Cloud Config retains the most recent delivery configuration and stops the delivery of resource data.
 *
 * @param request UpdateConfigDeliveryChannelRequest
 * @return UpdateConfigDeliveryChannelResponse
 */
func (client *Client) UpdateConfigDeliveryChannel(request *UpdateConfigDeliveryChannelRequest) (_result *UpdateConfigDeliveryChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateConfigDeliveryChannelResponse{}
	_body, _err := client.UpdateConfigDeliveryChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic provides an example on how to change the risk level of a managed rule whose ID is `cr-a260626622af0005****` to `3` (low risk level).
 *
 * @param tmpReq UpdateConfigRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateConfigRuleResponse
 */
func (client *Client) UpdateConfigRuleWithOptions(tmpReq *UpdateConfigRuleRequest, runtime *util.RuntimeOptions) (_result *UpdateConfigRuleResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateConfigRuleShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.InputParameters)) {
		request.InputParametersShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.InputParameters, tea.String("InputParameters"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.ResourceTypesScope)) {
		request.ResourceTypesScopeShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ResourceTypesScope, tea.String("ResourceTypesScope"), tea.String("simple"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleId)) {
		body["ConfigRuleId"] = request.ConfigRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleName)) {
		body["ConfigRuleName"] = request.ConfigRuleName
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigRuleTriggerTypes)) {
		body["ConfigRuleTriggerTypes"] = request.ConfigRuleTriggerTypes
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeResourceIdsScope)) {
		body["ExcludeResourceIdsScope"] = request.ExcludeResourceIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.InputParametersShrink)) {
		body["InputParameters"] = request.InputParametersShrink
	}

	if !tea.BoolValue(util.IsUnset(request.MaximumExecutionFrequency)) {
		body["MaximumExecutionFrequency"] = request.MaximumExecutionFrequency
	}

	if !tea.BoolValue(util.IsUnset(request.RegionIdsScope)) {
		body["RegionIdsScope"] = request.RegionIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupIdsScope)) {
		body["ResourceGroupIdsScope"] = request.ResourceGroupIdsScope
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceTypesScopeShrink)) {
		body["ResourceTypesScope"] = request.ResourceTypesScopeShrink
	}

	if !tea.BoolValue(util.IsUnset(request.RiskLevel)) {
		body["RiskLevel"] = request.RiskLevel
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeyLogicScope)) {
		body["TagKeyLogicScope"] = request.TagKeyLogicScope
	}

	if !tea.BoolValue(util.IsUnset(request.TagKeyScope)) {
		body["TagKeyScope"] = request.TagKeyScope
	}

	if !tea.BoolValue(util.IsUnset(request.TagValueScope)) {
		body["TagValueScope"] = request.TagValueScope
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateConfigRule"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateConfigRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic provides an example on how to change the risk level of a managed rule whose ID is `cr-a260626622af0005****` to `3` (low risk level).
 *
 * @param request UpdateConfigRuleRequest
 * @return UpdateConfigRuleResponse
 */
func (client *Client) UpdateConfigRule(request *UpdateConfigRuleRequest) (_result *UpdateConfigRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateConfigRuleResponse{}
	_body, _err := client.UpdateConfigRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateConfigurationRecorderWithOptions(request *UpdateConfigurationRecorderRequest, runtime *util.RuntimeOptions) (_result *UpdateConfigurationRecorderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceTypes)) {
		body["ResourceTypes"] = request.ResourceTypes
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateConfigurationRecorder"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateConfigurationRecorderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateConfigurationRecorder(request *UpdateConfigurationRecorderRequest) (_result *UpdateConfigurationRecorderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateConfigurationRecorderResponse{}
	_body, _err := client.UpdateConfigurationRecorderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated : UpdateDeliveryChannel is deprecated, please use Config::2020-09-07::UpdateConfigDeliveryChannel,Config::2020-09-07::UpdateAggregateConfigDeliveryChannel instead.
 * This topic provides an example on how to change the status of the delivery channel whose ID is `cdc-8e45ff4e06a3a8****` to 0, which indicates that the delivery channel is disabled. After the delivery channel is disabled, Cloud Config retains the last delivery configuration and stops resource data delivery.
 *
 * @param request UpdateDeliveryChannelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDeliveryChannelResponse
 */
// Deprecated
func (client *Client) UpdateDeliveryChannelWithOptions(request *UpdateDeliveryChannelRequest, runtime *util.RuntimeOptions) (_result *UpdateDeliveryChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigurationItemChangeNotification)) {
		body["ConfigurationItemChangeNotification"] = request.ConfigurationItemChangeNotification
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigurationSnapshot)) {
		body["ConfigurationSnapshot"] = request.ConfigurationSnapshot
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelAssumeRoleArn)) {
		body["DeliveryChannelAssumeRoleArn"] = request.DeliveryChannelAssumeRoleArn
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelCondition)) {
		body["DeliveryChannelCondition"] = request.DeliveryChannelCondition
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelId)) {
		body["DeliveryChannelId"] = request.DeliveryChannelId
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelName)) {
		body["DeliveryChannelName"] = request.DeliveryChannelName
	}

	if !tea.BoolValue(util.IsUnset(request.DeliveryChannelTargetArn)) {
		body["DeliveryChannelTargetArn"] = request.DeliveryChannelTargetArn
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.NonCompliantNotification)) {
		body["NonCompliantNotification"] = request.NonCompliantNotification
	}

	if !tea.BoolValue(util.IsUnset(request.OversizedDataOSSTargetArn)) {
		body["OversizedDataOSSTargetArn"] = request.OversizedDataOSSTargetArn
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		body["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDeliveryChannel"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDeliveryChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated : UpdateDeliveryChannel is deprecated, please use Config::2020-09-07::UpdateConfigDeliveryChannel,Config::2020-09-07::UpdateAggregateConfigDeliveryChannel instead.
 * This topic provides an example on how to change the status of the delivery channel whose ID is `cdc-8e45ff4e06a3a8****` to 0, which indicates that the delivery channel is disabled. After the delivery channel is disabled, Cloud Config retains the last delivery configuration and stops resource data delivery.
 *
 * @param request UpdateDeliveryChannelRequest
 * @return UpdateDeliveryChannelResponse
 */
// Deprecated
func (client *Client) UpdateDeliveryChannel(request *UpdateDeliveryChannelRequest) (_result *UpdateDeliveryChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDeliveryChannelResponse{}
	_body, _err := client.UpdateDeliveryChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateIntegratedServiceStatusWithOptions(request *UpdateIntegratedServiceStatusRequest, runtime *util.RuntimeOptions) (_result *UpdateIntegratedServiceStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ServiceCode)) {
		body["ServiceCode"] = request.ServiceCode
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		body["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateIntegratedServiceStatus"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateIntegratedServiceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateIntegratedServiceStatus(request *UpdateIntegratedServiceStatusRequest) (_result *UpdateIntegratedServiceStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateIntegratedServiceStatusResponse{}
	_body, _err := client.UpdateIntegratedServiceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This topic describes how to change the execution mode of the `crr-909ba2d4716700eb****` remediation setting to `AUTO_EXECUTION`, which specifies automatic remediation. This topic also provides a sample request.
 *
 * @param request UpdateRemediationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRemediationResponse
 */
func (client *Client) UpdateRemediationWithOptions(request *UpdateRemediationRequest, runtime *util.RuntimeOptions) (_result *UpdateRemediationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		body["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.InvokeType)) {
		body["InvokeType"] = request.InvokeType
	}

	if !tea.BoolValue(util.IsUnset(request.Params)) {
		body["Params"] = request.Params
	}

	if !tea.BoolValue(util.IsUnset(request.RemediationId)) {
		body["RemediationId"] = request.RemediationId
	}

	if !tea.BoolValue(util.IsUnset(request.RemediationTemplateId)) {
		body["RemediationTemplateId"] = request.RemediationTemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.RemediationType)) {
		body["RemediationType"] = request.RemediationType
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		body["SourceType"] = request.SourceType
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateRemediation"),
		Version:     tea.String("2020-09-07"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateRemediationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This topic describes how to change the execution mode of the `crr-909ba2d4716700eb****` remediation setting to `AUTO_EXECUTION`, which specifies automatic remediation. This topic also provides a sample request.
 *
 * @param request UpdateRemediationRequest
 * @return UpdateRemediationResponse
 */
func (client *Client) UpdateRemediation(request *UpdateRemediationRequest) (_result *UpdateRemediationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateRemediationResponse{}
	_body, _err := client.UpdateRemediationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
