// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type ActiveFlowLogRequest struct {
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, ClientToken is set to the value of RequestId. The value of RequestId may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the flow log.
	FlowLogId    *string `json:"FlowLogId,omitempty" xml:"FlowLogId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the flow log is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ActiveFlowLogRequest) String() string {
	return tea.Prettify(s)
}

func (s ActiveFlowLogRequest) GoString() string {
	return s.String()
}

func (s *ActiveFlowLogRequest) SetCenId(v string) *ActiveFlowLogRequest {
	s.CenId = &v
	return s
}

func (s *ActiveFlowLogRequest) SetClientToken(v string) *ActiveFlowLogRequest {
	s.ClientToken = &v
	return s
}

func (s *ActiveFlowLogRequest) SetFlowLogId(v string) *ActiveFlowLogRequest {
	s.FlowLogId = &v
	return s
}

func (s *ActiveFlowLogRequest) SetOwnerAccount(v string) *ActiveFlowLogRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ActiveFlowLogRequest) SetOwnerId(v int64) *ActiveFlowLogRequest {
	s.OwnerId = &v
	return s
}

func (s *ActiveFlowLogRequest) SetRegionId(v string) *ActiveFlowLogRequest {
	s.RegionId = &v
	return s
}

func (s *ActiveFlowLogRequest) SetResourceOwnerAccount(v string) *ActiveFlowLogRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ActiveFlowLogRequest) SetResourceOwnerId(v int64) *ActiveFlowLogRequest {
	s.ResourceOwnerId = &v
	return s
}

type ActiveFlowLogResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call is successful.
	//
	// *   **true**: yes
	// *   **false**: no
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ActiveFlowLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ActiveFlowLogResponseBody) GoString() string {
	return s.String()
}

func (s *ActiveFlowLogResponseBody) SetRequestId(v string) *ActiveFlowLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *ActiveFlowLogResponseBody) SetSuccess(v string) *ActiveFlowLogResponseBody {
	s.Success = &v
	return s
}

type ActiveFlowLogResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ActiveFlowLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ActiveFlowLogResponse) String() string {
	return tea.Prettify(s)
}

func (s ActiveFlowLogResponse) GoString() string {
	return s.String()
}

func (s *ActiveFlowLogResponse) SetHeaders(v map[string]*string) *ActiveFlowLogResponse {
	s.Headers = v
	return s
}

func (s *ActiveFlowLogResponse) SetStatusCode(v int32) *ActiveFlowLogResponse {
	s.StatusCode = &v
	return s
}

func (s *ActiveFlowLogResponse) SetBody(v *ActiveFlowLogResponseBody) *ActiveFlowLogResponse {
	s.Body = v
	return s
}

type AddTrafficMatchRuleToTrafficMarkingPolicyRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request format, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the traffic marking policy.
	TrafficMarkingPolicyId *string `json:"TrafficMarkingPolicyId,omitempty" xml:"TrafficMarkingPolicyId,omitempty"`
	// The traffic classification rules.
	//
	// You can specify at most 50 traffic classification rules.
	TrafficMatchRules []*AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules `json:"TrafficMatchRules,omitempty" xml:"TrafficMatchRules,omitempty" type:"Repeated"`
}

func (s AddTrafficMatchRuleToTrafficMarkingPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s AddTrafficMatchRuleToTrafficMarkingPolicyRequest) GoString() string {
	return s.String()
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequest) SetClientToken(v string) *AddTrafficMatchRuleToTrafficMarkingPolicyRequest {
	s.ClientToken = &v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequest) SetDryRun(v bool) *AddTrafficMatchRuleToTrafficMarkingPolicyRequest {
	s.DryRun = &v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequest) SetOwnerAccount(v string) *AddTrafficMatchRuleToTrafficMarkingPolicyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequest) SetOwnerId(v int64) *AddTrafficMatchRuleToTrafficMarkingPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequest) SetResourceOwnerAccount(v string) *AddTrafficMatchRuleToTrafficMarkingPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequest) SetResourceOwnerId(v int64) *AddTrafficMatchRuleToTrafficMarkingPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequest) SetTrafficMarkingPolicyId(v string) *AddTrafficMatchRuleToTrafficMarkingPolicyRequest {
	s.TrafficMarkingPolicyId = &v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequest) SetTrafficMatchRules(v []*AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) *AddTrafficMatchRuleToTrafficMarkingPolicyRequest {
	s.TrafficMatchRules = v
	return s
}

type AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules struct {
	// The destination CIDR block that is used to match packets.
	//
	// The traffic classification rule matches the packets whose destination IP addresses fall within the specified destination CIDR block. If you do not set this parameter, packets are considered a match regardless of the DSCP value.
	DstCidr *string `json:"DstCidr,omitempty" xml:"DstCidr,omitempty"`
	// The destination port range that is used to match packets. Valid values: **-1** and **1** to **65535**.
	//
	// The traffic classification rule matches the packets whose destination ports fall within the destination port range. If you do not set this parameter, packets are considered a match regardless of the DSCP value.
	//
	// You can specify at most two ports. Take note of the following rules:
	//
	// *   If you enter only one port number such as 1, the system matches the packets whose destination port is port 1.
	// *   If you enter two port numbers such as 1 and 200, the system matches the packets whose destination ports fall between 1 and 200.
	// *   If you enter two port numbers and one of them is -1, the other port number must also be -1. In this case, packets are considered a match regardless of the destination port.
	DstPortRange []*int32 `json:"DstPortRange,omitempty" xml:"DstPortRange,omitempty" type:"Repeated"`
	// The differentiated services code point (DSCP) value that is used to match packets. Valid values: **0** to **63**.
	//
	// The traffic classification rule matches the packets that contain the specified DSCP value. If you do not set this parameter, packets are considered a match regardless of the DSCP value.
	//
	// >  The DSCP value that you specify for this parameter is the DSCP value that packets carry before they are transmitted over the inter-region connection.
	MatchDscp *int32 `json:"MatchDscp,omitempty" xml:"MatchDscp,omitempty"`
	// The protocol that is used to match packets.
	//
	// Valid values: **HTTP**, **HTTPS**, **TCP**, **UDP**, **SSH**, and **Telnet**. For more information, log on to the [Cloud Enterprise Network (CEN) console](https://cen.console.aliyun.com/cen/list).
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The source CIDR block that is used to match packets.
	//
	// The traffic classification rule matches the packets whose source IP addresses fall within the specified source CIDR block. If you do not set this parameter, packets are considered a match regardless of the source IP address.
	SrcCidr *string `json:"SrcCidr,omitempty" xml:"SrcCidr,omitempty"`
	// The source port range that is used to match packets. Valid values: **-1** and **1** to **65535**.
	//
	// The traffic classification rule matches the packets whose source ports fall within the source port range. If you do not set this parameter, packets are considered a match regardless of the source port.
	//
	// You can specify at most two ports. Take note of the following rules:
	//
	// *   If you enter only one port number such as 1, the system matches the packets whose source port is 1.
	// *   If you enter two port numbers such as 1 and 200, the system matches the packets whose source ports fall between 1 and 200.
	// *   If you enter two port numbers and one of them is -1, the other port number must also be -1. In this case, packets are considered a match regardless of the source port.
	SrcPortRange []*int32 `json:"SrcPortRange,omitempty" xml:"SrcPortRange,omitempty" type:"Repeated"`
	// The description of the traffic classification rule.
	//
	// The description must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The description must start with a letter.
	TrafficMatchRuleDescription *string `json:"TrafficMatchRuleDescription,omitempty" xml:"TrafficMatchRuleDescription,omitempty"`
	// The name of the traffic classification rule.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	TrafficMatchRuleName *string `json:"TrafficMatchRuleName,omitempty" xml:"TrafficMatchRuleName,omitempty"`
}

func (s AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) String() string {
	return tea.Prettify(s)
}

func (s AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) GoString() string {
	return s.String()
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetDstCidr(v string) *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.DstCidr = &v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetDstPortRange(v []*int32) *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.DstPortRange = v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetMatchDscp(v int32) *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.MatchDscp = &v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetProtocol(v string) *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.Protocol = &v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetSrcCidr(v string) *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.SrcCidr = &v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetSrcPortRange(v []*int32) *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.SrcPortRange = v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetTrafficMatchRuleDescription(v string) *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.TrafficMatchRuleDescription = &v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetTrafficMatchRuleName(v string) *AddTrafficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.TrafficMatchRuleName = &v
	return s
}

type AddTrafficMatchRuleToTrafficMarkingPolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddTrafficMatchRuleToTrafficMarkingPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddTrafficMatchRuleToTrafficMarkingPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyResponseBody) SetRequestId(v string) *AddTrafficMatchRuleToTrafficMarkingPolicyResponseBody {
	s.RequestId = &v
	return s
}

type AddTrafficMatchRuleToTrafficMarkingPolicyResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddTrafficMatchRuleToTrafficMarkingPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddTrafficMatchRuleToTrafficMarkingPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s AddTrafficMatchRuleToTrafficMarkingPolicyResponse) GoString() string {
	return s.String()
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyResponse) SetHeaders(v map[string]*string) *AddTrafficMatchRuleToTrafficMarkingPolicyResponse {
	s.Headers = v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyResponse) SetStatusCode(v int32) *AddTrafficMatchRuleToTrafficMarkingPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *AddTrafficMatchRuleToTrafficMarkingPolicyResponse) SetBody(v *AddTrafficMatchRuleToTrafficMarkingPolicyResponseBody) *AddTrafficMatchRuleToTrafficMarkingPolicyResponse {
	s.Body = v
	return s
}

type AddTraficMatchRuleToTrafficMarkingPolicyRequest struct {
	ClientToken            *string                                                             `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun                 *bool                                                               `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount           *string                                                             `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64                                                              `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount   *string                                                             `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId        *int64                                                              `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TrafficMarkingPolicyId *string                                                             `json:"TrafficMarkingPolicyId,omitempty" xml:"TrafficMarkingPolicyId,omitempty"`
	TrafficMatchRules      []*AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules `json:"TrafficMatchRules,omitempty" xml:"TrafficMatchRules,omitempty" type:"Repeated"`
}

func (s AddTraficMatchRuleToTrafficMarkingPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s AddTraficMatchRuleToTrafficMarkingPolicyRequest) GoString() string {
	return s.String()
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequest) SetClientToken(v string) *AddTraficMatchRuleToTrafficMarkingPolicyRequest {
	s.ClientToken = &v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequest) SetDryRun(v bool) *AddTraficMatchRuleToTrafficMarkingPolicyRequest {
	s.DryRun = &v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequest) SetOwnerAccount(v string) *AddTraficMatchRuleToTrafficMarkingPolicyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequest) SetOwnerId(v int64) *AddTraficMatchRuleToTrafficMarkingPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequest) SetResourceOwnerAccount(v string) *AddTraficMatchRuleToTrafficMarkingPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequest) SetResourceOwnerId(v int64) *AddTraficMatchRuleToTrafficMarkingPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequest) SetTrafficMarkingPolicyId(v string) *AddTraficMatchRuleToTrafficMarkingPolicyRequest {
	s.TrafficMarkingPolicyId = &v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequest) SetTrafficMatchRules(v []*AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) *AddTraficMatchRuleToTrafficMarkingPolicyRequest {
	s.TrafficMatchRules = v
	return s
}

type AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules struct {
	DstCidr                     *string  `json:"DstCidr,omitempty" xml:"DstCidr,omitempty"`
	DstPortRange                []*int32 `json:"DstPortRange,omitempty" xml:"DstPortRange,omitempty" type:"Repeated"`
	MatchDscp                   *int32   `json:"MatchDscp,omitempty" xml:"MatchDscp,omitempty"`
	Protocol                    *string  `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	SrcCidr                     *string  `json:"SrcCidr,omitempty" xml:"SrcCidr,omitempty"`
	SrcPortRange                []*int32 `json:"SrcPortRange,omitempty" xml:"SrcPortRange,omitempty" type:"Repeated"`
	TrafficMatchRuleDescription *string  `json:"TrafficMatchRuleDescription,omitempty" xml:"TrafficMatchRuleDescription,omitempty"`
	TrafficMatchRuleName        *string  `json:"TrafficMatchRuleName,omitempty" xml:"TrafficMatchRuleName,omitempty"`
}

func (s AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) String() string {
	return tea.Prettify(s)
}

func (s AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) GoString() string {
	return s.String()
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetDstCidr(v string) *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.DstCidr = &v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetDstPortRange(v []*int32) *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.DstPortRange = v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetMatchDscp(v int32) *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.MatchDscp = &v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetProtocol(v string) *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.Protocol = &v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetSrcCidr(v string) *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.SrcCidr = &v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetSrcPortRange(v []*int32) *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.SrcPortRange = v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetTrafficMatchRuleDescription(v string) *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.TrafficMatchRuleDescription = &v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules) SetTrafficMatchRuleName(v string) *AddTraficMatchRuleToTrafficMarkingPolicyRequestTrafficMatchRules {
	s.TrafficMatchRuleName = &v
	return s
}

type AddTraficMatchRuleToTrafficMarkingPolicyResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddTraficMatchRuleToTrafficMarkingPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddTraficMatchRuleToTrafficMarkingPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyResponseBody) SetRequestId(v string) *AddTraficMatchRuleToTrafficMarkingPolicyResponseBody {
	s.RequestId = &v
	return s
}

type AddTraficMatchRuleToTrafficMarkingPolicyResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddTraficMatchRuleToTrafficMarkingPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddTraficMatchRuleToTrafficMarkingPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s AddTraficMatchRuleToTrafficMarkingPolicyResponse) GoString() string {
	return s.String()
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyResponse) SetHeaders(v map[string]*string) *AddTraficMatchRuleToTrafficMarkingPolicyResponse {
	s.Headers = v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyResponse) SetStatusCode(v int32) *AddTraficMatchRuleToTrafficMarkingPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *AddTraficMatchRuleToTrafficMarkingPolicyResponse) SetBody(v *AddTraficMatchRuleToTrafficMarkingPolicyResponseBody) *AddTraficMatchRuleToTrafficMarkingPolicyResponse {
	s.Body = v
	return s
}

type AssociateCenBandwidthPackageRequest struct {
	// The ID of the bandwidth plan.
	CenBandwidthPackageId *string `json:"CenBandwidthPackageId,omitempty" xml:"CenBandwidthPackageId,omitempty"`
	// The ID of the CEN instance.
	CenId                *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AssociateCenBandwidthPackageRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateCenBandwidthPackageRequest) GoString() string {
	return s.String()
}

func (s *AssociateCenBandwidthPackageRequest) SetCenBandwidthPackageId(v string) *AssociateCenBandwidthPackageRequest {
	s.CenBandwidthPackageId = &v
	return s
}

func (s *AssociateCenBandwidthPackageRequest) SetCenId(v string) *AssociateCenBandwidthPackageRequest {
	s.CenId = &v
	return s
}

func (s *AssociateCenBandwidthPackageRequest) SetOwnerAccount(v string) *AssociateCenBandwidthPackageRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AssociateCenBandwidthPackageRequest) SetOwnerId(v int64) *AssociateCenBandwidthPackageRequest {
	s.OwnerId = &v
	return s
}

func (s *AssociateCenBandwidthPackageRequest) SetResourceOwnerAccount(v string) *AssociateCenBandwidthPackageRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AssociateCenBandwidthPackageRequest) SetResourceOwnerId(v int64) *AssociateCenBandwidthPackageRequest {
	s.ResourceOwnerId = &v
	return s
}

type AssociateCenBandwidthPackageResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateCenBandwidthPackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateCenBandwidthPackageResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateCenBandwidthPackageResponseBody) SetRequestId(v string) *AssociateCenBandwidthPackageResponseBody {
	s.RequestId = &v
	return s
}

type AssociateCenBandwidthPackageResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateCenBandwidthPackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateCenBandwidthPackageResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateCenBandwidthPackageResponse) GoString() string {
	return s.String()
}

func (s *AssociateCenBandwidthPackageResponse) SetHeaders(v map[string]*string) *AssociateCenBandwidthPackageResponse {
	s.Headers = v
	return s
}

func (s *AssociateCenBandwidthPackageResponse) SetStatusCode(v int32) *AssociateCenBandwidthPackageResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateCenBandwidthPackageResponse) SetBody(v *AssociateCenBandwidthPackageResponseBody) *AssociateCenBandwidthPackageResponse {
	s.Body = v
	return s
}

type AssociateTransitRouterAttachmentWithRouteTableRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run to check information such as the permissions and the instance status. Default values:
	//
	// *   **false** (default): performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the DryRunOperation error code is returned.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the route table of the Enterprise Edition transit router.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
}

func (s AssociateTransitRouterAttachmentWithRouteTableRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateTransitRouterAttachmentWithRouteTableRequest) GoString() string {
	return s.String()
}

func (s *AssociateTransitRouterAttachmentWithRouteTableRequest) SetClientToken(v string) *AssociateTransitRouterAttachmentWithRouteTableRequest {
	s.ClientToken = &v
	return s
}

func (s *AssociateTransitRouterAttachmentWithRouteTableRequest) SetDryRun(v bool) *AssociateTransitRouterAttachmentWithRouteTableRequest {
	s.DryRun = &v
	return s
}

func (s *AssociateTransitRouterAttachmentWithRouteTableRequest) SetOwnerAccount(v string) *AssociateTransitRouterAttachmentWithRouteTableRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AssociateTransitRouterAttachmentWithRouteTableRequest) SetOwnerId(v int64) *AssociateTransitRouterAttachmentWithRouteTableRequest {
	s.OwnerId = &v
	return s
}

func (s *AssociateTransitRouterAttachmentWithRouteTableRequest) SetResourceOwnerAccount(v string) *AssociateTransitRouterAttachmentWithRouteTableRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AssociateTransitRouterAttachmentWithRouteTableRequest) SetResourceOwnerId(v int64) *AssociateTransitRouterAttachmentWithRouteTableRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AssociateTransitRouterAttachmentWithRouteTableRequest) SetTransitRouterAttachmentId(v string) *AssociateTransitRouterAttachmentWithRouteTableRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *AssociateTransitRouterAttachmentWithRouteTableRequest) SetTransitRouterRouteTableId(v string) *AssociateTransitRouterAttachmentWithRouteTableRequest {
	s.TransitRouterRouteTableId = &v
	return s
}

type AssociateTransitRouterAttachmentWithRouteTableResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateTransitRouterAttachmentWithRouteTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateTransitRouterAttachmentWithRouteTableResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateTransitRouterAttachmentWithRouteTableResponseBody) SetRequestId(v string) *AssociateTransitRouterAttachmentWithRouteTableResponseBody {
	s.RequestId = &v
	return s
}

type AssociateTransitRouterAttachmentWithRouteTableResponse struct {
	Headers    map[string]*string                                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateTransitRouterAttachmentWithRouteTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateTransitRouterAttachmentWithRouteTableResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateTransitRouterAttachmentWithRouteTableResponse) GoString() string {
	return s.String()
}

func (s *AssociateTransitRouterAttachmentWithRouteTableResponse) SetHeaders(v map[string]*string) *AssociateTransitRouterAttachmentWithRouteTableResponse {
	s.Headers = v
	return s
}

func (s *AssociateTransitRouterAttachmentWithRouteTableResponse) SetStatusCode(v int32) *AssociateTransitRouterAttachmentWithRouteTableResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateTransitRouterAttachmentWithRouteTableResponse) SetBody(v *AssociateTransitRouterAttachmentWithRouteTableResponseBody) *AssociateTransitRouterAttachmentWithRouteTableResponse {
	s.Body = v
	return s
}

type AssociateTransitRouterMulticastDomainRequest struct {
	ClientToken                    *string   `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun                         *bool     `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount                   *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                        *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount           *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId                *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TransitRouterAttachmentId      *string   `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	TransitRouterMulticastDomainId *string   `json:"TransitRouterMulticastDomainId,omitempty" xml:"TransitRouterMulticastDomainId,omitempty"`
	VSwitchIds                     []*string `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Repeated"`
}

func (s AssociateTransitRouterMulticastDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s AssociateTransitRouterMulticastDomainRequest) GoString() string {
	return s.String()
}

func (s *AssociateTransitRouterMulticastDomainRequest) SetClientToken(v string) *AssociateTransitRouterMulticastDomainRequest {
	s.ClientToken = &v
	return s
}

func (s *AssociateTransitRouterMulticastDomainRequest) SetDryRun(v bool) *AssociateTransitRouterMulticastDomainRequest {
	s.DryRun = &v
	return s
}

func (s *AssociateTransitRouterMulticastDomainRequest) SetOwnerAccount(v string) *AssociateTransitRouterMulticastDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AssociateTransitRouterMulticastDomainRequest) SetOwnerId(v int64) *AssociateTransitRouterMulticastDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *AssociateTransitRouterMulticastDomainRequest) SetResourceOwnerAccount(v string) *AssociateTransitRouterMulticastDomainRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AssociateTransitRouterMulticastDomainRequest) SetResourceOwnerId(v int64) *AssociateTransitRouterMulticastDomainRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *AssociateTransitRouterMulticastDomainRequest) SetTransitRouterAttachmentId(v string) *AssociateTransitRouterMulticastDomainRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *AssociateTransitRouterMulticastDomainRequest) SetTransitRouterMulticastDomainId(v string) *AssociateTransitRouterMulticastDomainRequest {
	s.TransitRouterMulticastDomainId = &v
	return s
}

func (s *AssociateTransitRouterMulticastDomainRequest) SetVSwitchIds(v []*string) *AssociateTransitRouterMulticastDomainRequest {
	s.VSwitchIds = v
	return s
}

type AssociateTransitRouterMulticastDomainResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AssociateTransitRouterMulticastDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AssociateTransitRouterMulticastDomainResponseBody) GoString() string {
	return s.String()
}

func (s *AssociateTransitRouterMulticastDomainResponseBody) SetRequestId(v string) *AssociateTransitRouterMulticastDomainResponseBody {
	s.RequestId = &v
	return s
}

type AssociateTransitRouterMulticastDomainResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AssociateTransitRouterMulticastDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AssociateTransitRouterMulticastDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s AssociateTransitRouterMulticastDomainResponse) GoString() string {
	return s.String()
}

func (s *AssociateTransitRouterMulticastDomainResponse) SetHeaders(v map[string]*string) *AssociateTransitRouterMulticastDomainResponse {
	s.Headers = v
	return s
}

func (s *AssociateTransitRouterMulticastDomainResponse) SetStatusCode(v int32) *AssociateTransitRouterMulticastDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *AssociateTransitRouterMulticastDomainResponse) SetBody(v *AssociateTransitRouterMulticastDomainResponseBody) *AssociateTransitRouterMulticastDomainResponse {
	s.Body = v
	return s
}

type AttachCenChildInstanceRequest struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the network instance that you want to attach to the CEN instance.
	ChildInstanceId *string `json:"ChildInstanceId,omitempty" xml:"ChildInstanceId,omitempty"`
	// The ID of the Alibaba Cloud account to which the network instance belongs.
	//
	// > If the network instance and the CEN instance belong to different Alibaba Cloud accounts, this parameter is required.
	ChildInstanceOwnerId *int64 `json:"ChildInstanceOwnerId,omitempty" xml:"ChildInstanceOwnerId,omitempty"`
	// The ID of the region where the network instance is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	ChildInstanceRegionId *string `json:"ChildInstanceRegionId,omitempty" xml:"ChildInstanceRegionId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: VPC
	// *   **VBR**: VBR
	// *   **CCN**: CCN instance
	ChildInstanceType    *string `json:"ChildInstanceType,omitempty" xml:"ChildInstanceType,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s AttachCenChildInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachCenChildInstanceRequest) GoString() string {
	return s.String()
}

func (s *AttachCenChildInstanceRequest) SetCenId(v string) *AttachCenChildInstanceRequest {
	s.CenId = &v
	return s
}

func (s *AttachCenChildInstanceRequest) SetChildInstanceId(v string) *AttachCenChildInstanceRequest {
	s.ChildInstanceId = &v
	return s
}

func (s *AttachCenChildInstanceRequest) SetChildInstanceOwnerId(v int64) *AttachCenChildInstanceRequest {
	s.ChildInstanceOwnerId = &v
	return s
}

func (s *AttachCenChildInstanceRequest) SetChildInstanceRegionId(v string) *AttachCenChildInstanceRequest {
	s.ChildInstanceRegionId = &v
	return s
}

func (s *AttachCenChildInstanceRequest) SetChildInstanceType(v string) *AttachCenChildInstanceRequest {
	s.ChildInstanceType = &v
	return s
}

func (s *AttachCenChildInstanceRequest) SetOwnerAccount(v string) *AttachCenChildInstanceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *AttachCenChildInstanceRequest) SetOwnerId(v int64) *AttachCenChildInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *AttachCenChildInstanceRequest) SetResourceOwnerAccount(v string) *AttachCenChildInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *AttachCenChildInstanceRequest) SetResourceOwnerId(v int64) *AttachCenChildInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type AttachCenChildInstanceResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AttachCenChildInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachCenChildInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *AttachCenChildInstanceResponseBody) SetRequestId(v string) *AttachCenChildInstanceResponseBody {
	s.RequestId = &v
	return s
}

type AttachCenChildInstanceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachCenChildInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachCenChildInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachCenChildInstanceResponse) GoString() string {
	return s.String()
}

func (s *AttachCenChildInstanceResponse) SetHeaders(v map[string]*string) *AttachCenChildInstanceResponse {
	s.Headers = v
	return s
}

func (s *AttachCenChildInstanceResponse) SetStatusCode(v int32) *AttachCenChildInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachCenChildInstanceResponse) SetBody(v *AttachCenChildInstanceResponseBody) *AttachCenChildInstanceResponse {
	s.Body = v
	return s
}

type CheckTransitRouterServiceRequest struct {
	ClientToken          *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s CheckTransitRouterServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckTransitRouterServiceRequest) GoString() string {
	return s.String()
}

func (s *CheckTransitRouterServiceRequest) SetClientToken(v string) *CheckTransitRouterServiceRequest {
	s.ClientToken = &v
	return s
}

func (s *CheckTransitRouterServiceRequest) SetOwnerAccount(v string) *CheckTransitRouterServiceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CheckTransitRouterServiceRequest) SetOwnerId(v int64) *CheckTransitRouterServiceRequest {
	s.OwnerId = &v
	return s
}

func (s *CheckTransitRouterServiceRequest) SetResourceOwnerAccount(v string) *CheckTransitRouterServiceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CheckTransitRouterServiceRequest) SetResourceOwnerId(v int64) *CheckTransitRouterServiceRequest {
	s.ResourceOwnerId = &v
	return s
}

type CheckTransitRouterServiceResponseBody struct {
	Enabled   *string `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CheckTransitRouterServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckTransitRouterServiceResponseBody) GoString() string {
	return s.String()
}

func (s *CheckTransitRouterServiceResponseBody) SetEnabled(v string) *CheckTransitRouterServiceResponseBody {
	s.Enabled = &v
	return s
}

func (s *CheckTransitRouterServiceResponseBody) SetRequestId(v string) *CheckTransitRouterServiceResponseBody {
	s.RequestId = &v
	return s
}

type CheckTransitRouterServiceResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CheckTransitRouterServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CheckTransitRouterServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckTransitRouterServiceResponse) GoString() string {
	return s.String()
}

func (s *CheckTransitRouterServiceResponse) SetHeaders(v map[string]*string) *CheckTransitRouterServiceResponse {
	s.Headers = v
	return s
}

func (s *CheckTransitRouterServiceResponse) SetStatusCode(v int32) *CheckTransitRouterServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckTransitRouterServiceResponse) SetBody(v *CheckTransitRouterServiceResponseBody) *CheckTransitRouterServiceResponse {
	s.Body = v
	return s
}

type CreateCenRequest struct {
	// The tag keys of the resources.
	//
	// The tag keys cannot be an empty string. The tag keys can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The operation that you want to perform. Set the value to **CreateCen**.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the request.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The tags.
	ProtectionLevel      *string `json:"ProtectionLevel,omitempty" xml:"ProtectionLevel,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Creates a Cloud Enterprise Network (CEN) instance.
	Tag []*CreateCenRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s CreateCenRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCenRequest) GoString() string {
	return s.String()
}

func (s *CreateCenRequest) SetClientToken(v string) *CreateCenRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateCenRequest) SetDescription(v string) *CreateCenRequest {
	s.Description = &v
	return s
}

func (s *CreateCenRequest) SetName(v string) *CreateCenRequest {
	s.Name = &v
	return s
}

func (s *CreateCenRequest) SetOwnerAccount(v string) *CreateCenRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateCenRequest) SetOwnerId(v int64) *CreateCenRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateCenRequest) SetProtectionLevel(v string) *CreateCenRequest {
	s.ProtectionLevel = &v
	return s
}

func (s *CreateCenRequest) SetResourceOwnerAccount(v string) *CreateCenRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateCenRequest) SetResourceOwnerId(v int64) *CreateCenRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateCenRequest) SetTag(v []*CreateCenRequestTag) *CreateCenRequest {
	s.Tag = v
	return s
}

type CreateCenRequestTag struct {
	// CreateCen
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// WB656982
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateCenRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateCenRequestTag) GoString() string {
	return s.String()
}

func (s *CreateCenRequestTag) SetKey(v string) *CreateCenRequestTag {
	s.Key = &v
	return s
}

func (s *CreateCenRequestTag) SetValue(v string) *CreateCenRequestTag {
	s.Value = &v
	return s
}

type CreateCenResponseBody struct {
	CenId     *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCenResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCenResponseBody) SetCenId(v string) *CreateCenResponseBody {
	s.CenId = &v
	return s
}

func (s *CreateCenResponseBody) SetRequestId(v string) *CreateCenResponseBody {
	s.RequestId = &v
	return s
}

type CreateCenResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCenResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCenResponse) GoString() string {
	return s.String()
}

func (s *CreateCenResponse) SetHeaders(v map[string]*string) *CreateCenResponse {
	s.Headers = v
	return s
}

func (s *CreateCenResponse) SetStatusCode(v int32) *CreateCenResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCenResponse) SetBody(v *CreateCenResponseBody) *CreateCenResponse {
	s.Body = v
	return s
}

type CreateCenBandwidthPackageRequest struct {
	// Specifies whether to automatically complete the payment of the bandwidth plan. Valid values:
	//
	// *   **true**: yes
	// *   **false** (default): no
	//
	// If you set the parameter to false, go to Billing Management to complete the payment after you call this operation. The instance is created only after you complete the payment.
	AutoPay *bool `json:"AutoPay,omitempty" xml:"AutoPay,omitempty"`
	// Specifies whether to enable the auto-renewal feature. Valid values:
	//
	// *   **true**: enables auto-renewal.
	// *   **false** (default): disables auto-renewal.
	//
	// > Only subscription bandwidth plans support auto-renewal.
	AutoRenew *bool `json:"AutoRenew,omitempty" xml:"AutoRenew,omitempty"`
	// The auto-renewal duration. Unit: months. Valid values: **0** to **2147483647**. Default value: **1**.
	AutoRenewDuration *int32 `json:"AutoRenewDuration,omitempty" xml:"AutoRenewDuration,omitempty"`
	// The maximum bandwidth value of the bandwidth plan. Unit: Mbit/s. Valid values: **2** to **10000**.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The billing method of the bandwidth plan. Set the value to **PREPAY**, which indicates that the billing method is pay-as-you-go.
	BandwidthPackageChargeType *string `json:"BandwidthPackageChargeType,omitempty" xml:"BandwidthPackageChargeType,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the bandwidth plan.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The area where the network instance is deployed. Valid values:
	//
	// *   **China**: Chinese mainland
	// *   **North-America**: North America
	// *   **Asia-Pacific**: Asia Pacific
	// *   **Europe**: Europe
	// *   **Australia**: Australia
	GeographicRegionAId *string `json:"GeographicRegionAId,omitempty" xml:"GeographicRegionAId,omitempty"`
	// The area where the other network instance is deployed. Valid values: Valid values:
	//
	// *   **China**: Chinese mainland
	// *   **North-America**: North America
	// *   **Asia-Pacific**: Asia Pacific
	// *   **Europe**: Europe
	// *   **Australia**: Australia
	GeographicRegionBId *string `json:"GeographicRegionBId,omitempty" xml:"GeographicRegionBId,omitempty"`
	// The name of the bandwidth plan.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter and cannot start with `http://` or `https://`.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The subscription duration of the bandwidth plan. Default value: 1.
	//
	// *   If **PricingCycle** is set to **Month**, set **Period** to a value from **1** to **3** or **6**.
	// *   If **PricingCycle** is set to **Year**, set **Period** to a value from **1** to **3**.
	//
	// > This parameter is required when **BandwidthPackageChargeType** is set to **PREPAY**.
	Period *int32 `json:"Period,omitempty" xml:"Period,omitempty"`
	// The billing cycle of the bandwidth plan. Valid values:
	//
	// *   **Month** (default): billed on a monthly basis.
	// *   **Year**: billed on an annual basis.
	PricingCycle         *string `json:"PricingCycle,omitempty" xml:"PricingCycle,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The information about the tags.
	//
	// You can specify at most 20 tags in each call.
	Tag []*CreateCenBandwidthPackageRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s CreateCenBandwidthPackageRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCenBandwidthPackageRequest) GoString() string {
	return s.String()
}

func (s *CreateCenBandwidthPackageRequest) SetAutoPay(v bool) *CreateCenBandwidthPackageRequest {
	s.AutoPay = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetAutoRenew(v bool) *CreateCenBandwidthPackageRequest {
	s.AutoRenew = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetAutoRenewDuration(v int32) *CreateCenBandwidthPackageRequest {
	s.AutoRenewDuration = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetBandwidth(v int32) *CreateCenBandwidthPackageRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetBandwidthPackageChargeType(v string) *CreateCenBandwidthPackageRequest {
	s.BandwidthPackageChargeType = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetClientToken(v string) *CreateCenBandwidthPackageRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetDescription(v string) *CreateCenBandwidthPackageRequest {
	s.Description = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetGeographicRegionAId(v string) *CreateCenBandwidthPackageRequest {
	s.GeographicRegionAId = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetGeographicRegionBId(v string) *CreateCenBandwidthPackageRequest {
	s.GeographicRegionBId = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetName(v string) *CreateCenBandwidthPackageRequest {
	s.Name = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetOwnerAccount(v string) *CreateCenBandwidthPackageRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetOwnerId(v int64) *CreateCenBandwidthPackageRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetPeriod(v int32) *CreateCenBandwidthPackageRequest {
	s.Period = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetPricingCycle(v string) *CreateCenBandwidthPackageRequest {
	s.PricingCycle = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetResourceOwnerAccount(v string) *CreateCenBandwidthPackageRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetResourceOwnerId(v int64) *CreateCenBandwidthPackageRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateCenBandwidthPackageRequest) SetTag(v []*CreateCenBandwidthPackageRequestTag) *CreateCenBandwidthPackageRequest {
	s.Tag = v
	return s
}

type CreateCenBandwidthPackageRequestTag struct {
	// The tag key.
	//
	// The tag keys cannot be an empty string. The tag key can be up to 64 characters in length, and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateCenBandwidthPackageRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateCenBandwidthPackageRequestTag) GoString() string {
	return s.String()
}

func (s *CreateCenBandwidthPackageRequestTag) SetKey(v string) *CreateCenBandwidthPackageRequestTag {
	s.Key = &v
	return s
}

func (s *CreateCenBandwidthPackageRequestTag) SetValue(v string) *CreateCenBandwidthPackageRequestTag {
	s.Value = &v
	return s
}

type CreateCenBandwidthPackageResponseBody struct {
	// The ID of the bandwidth plan.
	CenBandwidthPackageId *string `json:"CenBandwidthPackageId,omitempty" xml:"CenBandwidthPackageId,omitempty"`
	// The ID of the order for the bandwidth plan.
	CenBandwidthPackageOrderId *string `json:"CenBandwidthPackageOrderId,omitempty" xml:"CenBandwidthPackageOrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCenBandwidthPackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCenBandwidthPackageResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCenBandwidthPackageResponseBody) SetCenBandwidthPackageId(v string) *CreateCenBandwidthPackageResponseBody {
	s.CenBandwidthPackageId = &v
	return s
}

func (s *CreateCenBandwidthPackageResponseBody) SetCenBandwidthPackageOrderId(v string) *CreateCenBandwidthPackageResponseBody {
	s.CenBandwidthPackageOrderId = &v
	return s
}

func (s *CreateCenBandwidthPackageResponseBody) SetRequestId(v string) *CreateCenBandwidthPackageResponseBody {
	s.RequestId = &v
	return s
}

type CreateCenBandwidthPackageResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCenBandwidthPackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCenBandwidthPackageResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCenBandwidthPackageResponse) GoString() string {
	return s.String()
}

func (s *CreateCenBandwidthPackageResponse) SetHeaders(v map[string]*string) *CreateCenBandwidthPackageResponse {
	s.Headers = v
	return s
}

func (s *CreateCenBandwidthPackageResponse) SetStatusCode(v int32) *CreateCenBandwidthPackageResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCenBandwidthPackageResponse) SetBody(v *CreateCenBandwidthPackageResponseBody) *CreateCenBandwidthPackageResponse {
	s.Body = v
	return s
}

type CreateCenChildInstanceRouteEntryToAttachmentRequest struct {
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The destination CIDR block of the route.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// Specifies whether to perform a dry run to check information such as the permissions and the instance status. Valid values:
	//
	// *   **false**: performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	//
	// >  This parameter is not in use.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the route table configured on the network instance.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s CreateCenChildInstanceRouteEntryToAttachmentRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCenChildInstanceRouteEntryToAttachmentRequest) GoString() string {
	return s.String()
}

func (s *CreateCenChildInstanceRouteEntryToAttachmentRequest) SetCenId(v string) *CreateCenChildInstanceRouteEntryToAttachmentRequest {
	s.CenId = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToAttachmentRequest) SetClientToken(v string) *CreateCenChildInstanceRouteEntryToAttachmentRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToAttachmentRequest) SetDestinationCidrBlock(v string) *CreateCenChildInstanceRouteEntryToAttachmentRequest {
	s.DestinationCidrBlock = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToAttachmentRequest) SetDryRun(v bool) *CreateCenChildInstanceRouteEntryToAttachmentRequest {
	s.DryRun = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToAttachmentRequest) SetOwnerAccount(v string) *CreateCenChildInstanceRouteEntryToAttachmentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToAttachmentRequest) SetOwnerId(v int64) *CreateCenChildInstanceRouteEntryToAttachmentRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToAttachmentRequest) SetResourceOwnerAccount(v string) *CreateCenChildInstanceRouteEntryToAttachmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToAttachmentRequest) SetResourceOwnerId(v int64) *CreateCenChildInstanceRouteEntryToAttachmentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToAttachmentRequest) SetRouteTableId(v string) *CreateCenChildInstanceRouteEntryToAttachmentRequest {
	s.RouteTableId = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToAttachmentRequest) SetTransitRouterAttachmentId(v string) *CreateCenChildInstanceRouteEntryToAttachmentRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

type CreateCenChildInstanceRouteEntryToAttachmentResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCenChildInstanceRouteEntryToAttachmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCenChildInstanceRouteEntryToAttachmentResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCenChildInstanceRouteEntryToAttachmentResponseBody) SetRequestId(v string) *CreateCenChildInstanceRouteEntryToAttachmentResponseBody {
	s.RequestId = &v
	return s
}

type CreateCenChildInstanceRouteEntryToAttachmentResponse struct {
	Headers    map[string]*string                                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCenChildInstanceRouteEntryToAttachmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCenChildInstanceRouteEntryToAttachmentResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCenChildInstanceRouteEntryToAttachmentResponse) GoString() string {
	return s.String()
}

func (s *CreateCenChildInstanceRouteEntryToAttachmentResponse) SetHeaders(v map[string]*string) *CreateCenChildInstanceRouteEntryToAttachmentResponse {
	s.Headers = v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToAttachmentResponse) SetStatusCode(v int32) *CreateCenChildInstanceRouteEntryToAttachmentResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToAttachmentResponse) SetBody(v *CreateCenChildInstanceRouteEntryToAttachmentResponseBody) *CreateCenChildInstanceRouteEntryToAttachmentResponse {
	s.Body = v
	return s
}

type CreateCenChildInstanceRouteEntryToCenRequest struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the Alibaba Cloud account to which the network instance belongs.
	//
	// > If the network instance belongs to another Alibaba Cloud account, this parameter is required.
	ChildInstanceAliUid *int64 `json:"ChildInstanceAliUid,omitempty" xml:"ChildInstanceAliUid,omitempty"`
	// The ID of the network instance.
	ChildInstanceId *string `json:"ChildInstanceId,omitempty" xml:"ChildInstanceId,omitempty"`
	// The ID of the region where the network instance is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	ChildInstanceRegionId *string `json:"ChildInstanceRegionId,omitempty" xml:"ChildInstanceRegionId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: a virtual private cloud (VPC)
	// *   **VBR**: a virtual border router (VBR)
	ChildInstanceType *string `json:"ChildInstanceType,omitempty" xml:"ChildInstanceType,omitempty"`
	// The destination CIDR block of the route.
	//
	// Specify the value of this parameter in CIDR notation. Example: 192.168.10.0/24.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the route table configured on the network instance.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
}

func (s CreateCenChildInstanceRouteEntryToCenRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCenChildInstanceRouteEntryToCenRequest) GoString() string {
	return s.String()
}

func (s *CreateCenChildInstanceRouteEntryToCenRequest) SetCenId(v string) *CreateCenChildInstanceRouteEntryToCenRequest {
	s.CenId = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToCenRequest) SetChildInstanceAliUid(v int64) *CreateCenChildInstanceRouteEntryToCenRequest {
	s.ChildInstanceAliUid = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToCenRequest) SetChildInstanceId(v string) *CreateCenChildInstanceRouteEntryToCenRequest {
	s.ChildInstanceId = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToCenRequest) SetChildInstanceRegionId(v string) *CreateCenChildInstanceRouteEntryToCenRequest {
	s.ChildInstanceRegionId = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToCenRequest) SetChildInstanceType(v string) *CreateCenChildInstanceRouteEntryToCenRequest {
	s.ChildInstanceType = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToCenRequest) SetDestinationCidrBlock(v string) *CreateCenChildInstanceRouteEntryToCenRequest {
	s.DestinationCidrBlock = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToCenRequest) SetOwnerAccount(v string) *CreateCenChildInstanceRouteEntryToCenRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToCenRequest) SetOwnerId(v int64) *CreateCenChildInstanceRouteEntryToCenRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToCenRequest) SetResourceOwnerAccount(v string) *CreateCenChildInstanceRouteEntryToCenRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToCenRequest) SetResourceOwnerId(v int64) *CreateCenChildInstanceRouteEntryToCenRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToCenRequest) SetRouteTableId(v string) *CreateCenChildInstanceRouteEntryToCenRequest {
	s.RouteTableId = &v
	return s
}

type CreateCenChildInstanceRouteEntryToCenResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCenChildInstanceRouteEntryToCenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCenChildInstanceRouteEntryToCenResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCenChildInstanceRouteEntryToCenResponseBody) SetRequestId(v string) *CreateCenChildInstanceRouteEntryToCenResponseBody {
	s.RequestId = &v
	return s
}

type CreateCenChildInstanceRouteEntryToCenResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCenChildInstanceRouteEntryToCenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCenChildInstanceRouteEntryToCenResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCenChildInstanceRouteEntryToCenResponse) GoString() string {
	return s.String()
}

func (s *CreateCenChildInstanceRouteEntryToCenResponse) SetHeaders(v map[string]*string) *CreateCenChildInstanceRouteEntryToCenResponse {
	s.Headers = v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToCenResponse) SetStatusCode(v int32) *CreateCenChildInstanceRouteEntryToCenResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCenChildInstanceRouteEntryToCenResponse) SetBody(v *CreateCenChildInstanceRouteEntryToCenResponseBody) *CreateCenChildInstanceRouteEntryToCenResponse {
	s.Body = v
	return s
}

type CreateCenInterRegionTrafficQosPolicyRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether only to precheck the API request. Valid values:
	//
	// *   **true**: prechecks the request but does not create the QoS policy. The system checks the required parameters, the request format, and the service limits. If the request fails the check, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	// *   **false**: sends the API request. If the request passes the precheck, the QoS policy is created. This is the default value.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The description of the QoS policy.
	//
	// The description must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The description must start with a letter.
	TrafficQosPolicyDescription *string `json:"TrafficQosPolicyDescription,omitempty" xml:"TrafficQosPolicyDescription,omitempty"`
	// The name of the QoS policy.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	TrafficQosPolicyName *string `json:"TrafficQosPolicyName,omitempty" xml:"TrafficQosPolicyName,omitempty"`
	// The information about the QoS queue.
	//
	// You can call this operation to create at most three QoS queues. To create more queues, you must call the CreateCenInterRegionTrafficQosQueue operation.
	TrafficQosQueues []*CreateCenInterRegionTrafficQosPolicyRequestTrafficQosQueues `json:"TrafficQosQueues,omitempty" xml:"TrafficQosQueues,omitempty" type:"Repeated"`
	// The ID of the inter-region connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s CreateCenInterRegionTrafficQosPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCenInterRegionTrafficQosPolicyRequest) GoString() string {
	return s.String()
}

func (s *CreateCenInterRegionTrafficQosPolicyRequest) SetClientToken(v string) *CreateCenInterRegionTrafficQosPolicyRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyRequest) SetDryRun(v bool) *CreateCenInterRegionTrafficQosPolicyRequest {
	s.DryRun = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyRequest) SetOwnerAccount(v string) *CreateCenInterRegionTrafficQosPolicyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyRequest) SetOwnerId(v int64) *CreateCenInterRegionTrafficQosPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyRequest) SetResourceOwnerAccount(v string) *CreateCenInterRegionTrafficQosPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyRequest) SetResourceOwnerId(v int64) *CreateCenInterRegionTrafficQosPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyRequest) SetTrafficQosPolicyDescription(v string) *CreateCenInterRegionTrafficQosPolicyRequest {
	s.TrafficQosPolicyDescription = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyRequest) SetTrafficQosPolicyName(v string) *CreateCenInterRegionTrafficQosPolicyRequest {
	s.TrafficQosPolicyName = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyRequest) SetTrafficQosQueues(v []*CreateCenInterRegionTrafficQosPolicyRequestTrafficQosQueues) *CreateCenInterRegionTrafficQosPolicyRequest {
	s.TrafficQosQueues = v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyRequest) SetTransitRouterAttachmentId(v string) *CreateCenInterRegionTrafficQosPolicyRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyRequest) SetTransitRouterId(v string) *CreateCenInterRegionTrafficQosPolicyRequest {
	s.TransitRouterId = &v
	return s
}

type CreateCenInterRegionTrafficQosPolicyRequestTrafficQosQueues struct {
	// The DSCP value that matches the current queue.
	//
	// Each QoS policy supports up to three queues. You can specify at most 60 DSCP values for each queue. Separate DSCP values with commas (,).
	Dscps []*int32 `json:"Dscps,omitempty" xml:"Dscps,omitempty" type:"Repeated"`
	// The description of the current queue.
	//
	// Each QoS policy supports up to three queues. You can add a description to each queue.
	//
	// The description must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The description must start with a letter.
	QosQueueDescription *string `json:"QosQueueDescription,omitempty" xml:"QosQueueDescription,omitempty"`
	// The name of the current queue.
	//
	// Each QoS policy supports up to three queues. You can specify a name for each queue.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	QosQueueName *string `json:"QosQueueName,omitempty" xml:"QosQueueName,omitempty"`
	// The percentage of bandwidth resources that can be allocated to the current queue.
	//
	// Each QoS policy supports up to three queues. You can specify a percentage of bandwidth resources for each queue.
	//
	// If you enter **1**, it indicates that the current queue can consume at most \*\*1%\*\* of the bandwidth resources.
	//
	// >  The sum of the percentage values of all the queues in a QoS policy cannot exceed 100%.
	RemainBandwidthPercent *string `json:"RemainBandwidthPercent,omitempty" xml:"RemainBandwidthPercent,omitempty"`
}

func (s CreateCenInterRegionTrafficQosPolicyRequestTrafficQosQueues) String() string {
	return tea.Prettify(s)
}

func (s CreateCenInterRegionTrafficQosPolicyRequestTrafficQosQueues) GoString() string {
	return s.String()
}

func (s *CreateCenInterRegionTrafficQosPolicyRequestTrafficQosQueues) SetDscps(v []*int32) *CreateCenInterRegionTrafficQosPolicyRequestTrafficQosQueues {
	s.Dscps = v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyRequestTrafficQosQueues) SetQosQueueDescription(v string) *CreateCenInterRegionTrafficQosPolicyRequestTrafficQosQueues {
	s.QosQueueDescription = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyRequestTrafficQosQueues) SetQosQueueName(v string) *CreateCenInterRegionTrafficQosPolicyRequestTrafficQosQueues {
	s.QosQueueName = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyRequestTrafficQosQueues) SetRemainBandwidthPercent(v string) *CreateCenInterRegionTrafficQosPolicyRequestTrafficQosQueues {
	s.RemainBandwidthPercent = &v
	return s
}

type CreateCenInterRegionTrafficQosPolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the QoS policy.
	TrafficQosPolicyId *string `json:"TrafficQosPolicyId,omitempty" xml:"TrafficQosPolicyId,omitempty"`
}

func (s CreateCenInterRegionTrafficQosPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCenInterRegionTrafficQosPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCenInterRegionTrafficQosPolicyResponseBody) SetRequestId(v string) *CreateCenInterRegionTrafficQosPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyResponseBody) SetTrafficQosPolicyId(v string) *CreateCenInterRegionTrafficQosPolicyResponseBody {
	s.TrafficQosPolicyId = &v
	return s
}

type CreateCenInterRegionTrafficQosPolicyResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCenInterRegionTrafficQosPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCenInterRegionTrafficQosPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCenInterRegionTrafficQosPolicyResponse) GoString() string {
	return s.String()
}

func (s *CreateCenInterRegionTrafficQosPolicyResponse) SetHeaders(v map[string]*string) *CreateCenInterRegionTrafficQosPolicyResponse {
	s.Headers = v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyResponse) SetStatusCode(v int32) *CreateCenInterRegionTrafficQosPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosPolicyResponse) SetBody(v *CreateCenInterRegionTrafficQosPolicyResponseBody) *CreateCenInterRegionTrafficQosPolicyResponse {
	s.Body = v
	return s
}

type CreateCenInterRegionTrafficQosQueueRequest struct {
	ClientToken            *string  `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun                 *bool    `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	Dscps                  []*int32 `json:"Dscps,omitempty" xml:"Dscps,omitempty" type:"Repeated"`
	OwnerAccount           *string  `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64   `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	QosQueueDescription    *string  `json:"QosQueueDescription,omitempty" xml:"QosQueueDescription,omitempty"`
	QosQueueName           *string  `json:"QosQueueName,omitempty" xml:"QosQueueName,omitempty"`
	RemainBandwidthPercent *string  `json:"RemainBandwidthPercent,omitempty" xml:"RemainBandwidthPercent,omitempty"`
	ResourceOwnerAccount   *string  `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId        *int64   `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TrafficQosPolicyId     *string  `json:"TrafficQosPolicyId,omitempty" xml:"TrafficQosPolicyId,omitempty"`
}

func (s CreateCenInterRegionTrafficQosQueueRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCenInterRegionTrafficQosQueueRequest) GoString() string {
	return s.String()
}

func (s *CreateCenInterRegionTrafficQosQueueRequest) SetClientToken(v string) *CreateCenInterRegionTrafficQosQueueRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosQueueRequest) SetDryRun(v bool) *CreateCenInterRegionTrafficQosQueueRequest {
	s.DryRun = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosQueueRequest) SetDscps(v []*int32) *CreateCenInterRegionTrafficQosQueueRequest {
	s.Dscps = v
	return s
}

func (s *CreateCenInterRegionTrafficQosQueueRequest) SetOwnerAccount(v string) *CreateCenInterRegionTrafficQosQueueRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosQueueRequest) SetOwnerId(v int64) *CreateCenInterRegionTrafficQosQueueRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosQueueRequest) SetQosQueueDescription(v string) *CreateCenInterRegionTrafficQosQueueRequest {
	s.QosQueueDescription = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosQueueRequest) SetQosQueueName(v string) *CreateCenInterRegionTrafficQosQueueRequest {
	s.QosQueueName = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosQueueRequest) SetRemainBandwidthPercent(v string) *CreateCenInterRegionTrafficQosQueueRequest {
	s.RemainBandwidthPercent = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosQueueRequest) SetResourceOwnerAccount(v string) *CreateCenInterRegionTrafficQosQueueRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosQueueRequest) SetResourceOwnerId(v int64) *CreateCenInterRegionTrafficQosQueueRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosQueueRequest) SetTrafficQosPolicyId(v string) *CreateCenInterRegionTrafficQosQueueRequest {
	s.TrafficQosPolicyId = &v
	return s
}

type CreateCenInterRegionTrafficQosQueueResponseBody struct {
	QosQueueId *string `json:"QosQueueId,omitempty" xml:"QosQueueId,omitempty"`
	RequestId  *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateCenInterRegionTrafficQosQueueResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCenInterRegionTrafficQosQueueResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCenInterRegionTrafficQosQueueResponseBody) SetQosQueueId(v string) *CreateCenInterRegionTrafficQosQueueResponseBody {
	s.QosQueueId = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosQueueResponseBody) SetRequestId(v string) *CreateCenInterRegionTrafficQosQueueResponseBody {
	s.RequestId = &v
	return s
}

type CreateCenInterRegionTrafficQosQueueResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCenInterRegionTrafficQosQueueResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCenInterRegionTrafficQosQueueResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCenInterRegionTrafficQosQueueResponse) GoString() string {
	return s.String()
}

func (s *CreateCenInterRegionTrafficQosQueueResponse) SetHeaders(v map[string]*string) *CreateCenInterRegionTrafficQosQueueResponse {
	s.Headers = v
	return s
}

func (s *CreateCenInterRegionTrafficQosQueueResponse) SetStatusCode(v int32) *CreateCenInterRegionTrafficQosQueueResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCenInterRegionTrafficQosQueueResponse) SetBody(v *CreateCenInterRegionTrafficQosQueueResponseBody) *CreateCenInterRegionTrafficQosQueueResponse {
	s.Body = v
	return s
}

type CreateCenRouteMapRequest struct {
	// The ID of the CEN instance.
	AsPathMatchMode *string `json:"AsPathMatchMode,omitempty" xml:"AsPathMatchMode,omitempty"`
	// The type of source network instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the source region.
	CenRegionId *string `json:"CenRegionId,omitempty" xml:"CenRegionId,omitempty"`
	// The ID of the source network instance.
	CidrMatchMode *string `json:"CidrMatchMode,omitempty" xml:"CidrMatchMode,omitempty"`
	// The prefix list.
	CommunityMatchMode *string `json:"CommunityMatchMode,omitempty" xml:"CommunityMatchMode,omitempty"`
	// The AS path.
	CommunityOperateMode *string `json:"CommunityOperateMode,omitempty" xml:"CommunityOperateMode,omitempty"`
	// The priority of the routing policy. Valid values: **1** to **100**. A smaller value indicates a higher priority.
	//
	// >  You cannot specify the same priority for routing policies that apply in the same region and direction. The system matches routes against the match conditions of routing policies in descending order of priority. A smaller value indicates a higher priority. You must set the priorities to proper values.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The action that is performed on the community. Valid values:
	//
	// *   **Additive**: adds the community to the route.
	// *   **Replace**: replaces the original community of the route.
	//
	// This parameter specifies the action to be performed when a route meets the match condition.
	DestinationChildInstanceTypes []*string `json:"DestinationChildInstanceTypes,omitempty" xml:"DestinationChildInstanceTypes,omitempty" type:"Repeated"`
	// The ID of the destination route table.
	DestinationCidrBlocks []*string `json:"DestinationCidrBlocks,omitempty" xml:"DestinationCidrBlocks,omitempty" type:"Repeated"`
	// The new priority of the route.
	//
	// Valid values: **1** to **100**. The default priority is **50**. A smaller value indicates a higher priority.
	//
	// This parameter specifies the action to be performed when a route meets the match condition.
	DestinationInstanceIds []*string `json:"DestinationInstanceIds,omitempty" xml:"DestinationInstanceIds,omitempty" type:"Repeated"`
	// The types of destination network instance to which the routes belong. The following types of network instances are supported:
	//
	// *   **VPC**: VPC
	//
	// *   **VBR**: VBR
	//
	// *   **CCN**: CCN instance
	//
	// *   **VPN**: IPsec connection
	//
	//     **
	//
	//     **Note** This parameter does not take effect if the IPsec-VPN connection or SSL client is associated with a transit router through a VPN gateway and a VPC. This parameter takes effect only if the IPsec connection is directly connected to the transit router.
	//
	// You can specify one or more network instance types.
	//
	// >  The destination network instance types are valid only if the routing policy is applied to scenarios where routes are advertised from the gateway in the current region to network instances in the current region.
	DestinationInstanceIdsReverseMatch *bool `json:"DestinationInstanceIdsReverseMatch,omitempty" xml:"DestinationInstanceIdsReverseMatch,omitempty"`
	// The prefix list against which routes are matched.
	//
	// You must specify the IP addresses in CIDR notation. You can enter at most 32 CIDR blocks.
	DestinationRouteTableIds []*string `json:"DestinationRouteTableIds,omitempty" xml:"DestinationRouteTableIds,omitempty" type:"Repeated"`
	// The types of source network instance to which the routes belong. The following types of network instances are supported:
	//
	// *   **VPC**: VPC
	// *   **VBR**: VBR
	// *   **CCN**: CCN instance
	// *   **VPN**: VPN gateway or IPsec connection
	//     *   If the IPsec-VPN connection or SSL client is associated with a VPN gateway, the VPC associated with the VPN gateway must be connected to a transit router, and the VPN gateway must use BGP dynamic routing. Otherwise, this parameter cannot take effect.
	//     *   This parameter takes effect if the IPsec connection is directly connected to a transit router.
	//
	// You can specify one or more network instance types.
	MapResult *string `json:"MapResult,omitempty" xml:"MapResult,omitempty"`
	// Specifies whether to exclude the destination network instance IDs. Valid values:
	//
	// *   **false** (default value): A route is a match if its destination network instance ID is in the list specified by **DestinationInstanceIds.N**.
	// *   **true**: A route meets the match condition if its destination network instance ID is not in the list specified by **DestinationInstanceIds.N**.
	MatchAddressType *string `json:"MatchAddressType,omitempty" xml:"MatchAddressType,omitempty"`
	// The IDs of the source network instances to which the routes belong. The following network instance types are supported:
	//
	// *   VPC
	// *   VBR
	// *   CCN instance
	// *   SAG instance
	// *   The ID of the IPsec connection.
	//
	// You can enter at most 32 IDs.
	MatchAsns []*int64 `json:"MatchAsns,omitempty" xml:"MatchAsns,omitempty" type:"Repeated"`
	// The community.
	MatchCommunitySet []*string `json:"MatchCommunitySet,omitempty" xml:"MatchCommunitySet,omitempty" type:"Repeated"`
	// The action to be performed on a route that meets all match conditions. Valid values:
	//
	// *   **Permit**: the route is permitted.
	// *   **Deny**: the route is denied.
	NextPriority *int32 `json:"NextPriority,omitempty" xml:"NextPriority,omitempty"`
	// The type of route to be matched against the match condition. The following route types are supported:
	//
	// *   **System**: system routes that are automatically generated by the system.
	// *   **Custom**: custom routes that are manually added.
	// *   **BGP**: routes that are advertised over BGP.
	//
	// You can specify multiple route types.
	OperateCommunitySet []*string `json:"OperateCommunitySet,omitempty" xml:"OperateCommunitySet,omitempty" type:"Repeated"`
	OwnerAccount        *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId             *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The community against which routes are matched.
	//
	// Specify the community in the format of n:m. Valid values of n and m: **1** to **65535**. Each community must comply with the RFC 1997 standard. The RFC 8092 standard that defines Border Gateway Protocol (BGP) large communities is not supported.
	//
	// You can specify at most 32 communities.
	//
	// >  If the configurations of the communities are incorrect, routes may fail to be advertised to your data center.
	Preference *int32 `json:"Preference,omitempty" xml:"Preference,omitempty"`
	// The ID of the source route table.
	PrependAsPath []*int64 `json:"PrependAsPath,omitempty" xml:"PrependAsPath,omitempty" type:"Repeated"`
	// The IDs of the source route tables from which routes are evaluated. You can enter at most 32 route table IDs.
	Priority             *int32  `json:"Priority,omitempty" xml:"Priority,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the route table of the transit router.
	//
	// If you do not specify a route table ID, the routing policy is automatically associated with the default route table of the transit router.
	RouteTypes []*string `json:"RouteTypes,omitempty" xml:"RouteTypes,omitempty" type:"Repeated"`
	// The IDs of the destination network instances to which the routes belong. The following network instance types are supported:
	//
	// *   VPC
	// *   VBR
	// *   CCN instance
	// *   SAG instance
	// *   The ID of the IPsec connection.
	//
	// You can enter at most 32 IDs.
	//
	// >  The destination network instance IDs are valid only if the routing policy is applied to scenarios where routes are advertised from the gateway in the current region to network instances in the current region.
	SourceChildInstanceTypes []*string `json:"SourceChildInstanceTypes,omitempty" xml:"SourceChildInstanceTypes,omitempty" type:"Repeated"`
	// The ID of the routing policy.
	SourceInstanceIds []*string `json:"SourceInstanceIds,omitempty" xml:"SourceInstanceIds,omitempty" type:"Repeated"`
	// The community set on which actions are performed.
	//
	// Specify the community in the format of n:m. Valid values of n and m: **1** to **65535**. Each community must comply with RFC 1997. The RFC 8092 standard that defines BGP large communities is not supported.
	//
	// You can specify at most 32 communities.
	//
	// >  If the configurations of the communities are incorrect, routes may fail to be advertised to your data center.
	SourceInstanceIdsReverseMatch *bool `json:"SourceInstanceIdsReverseMatch,omitempty" xml:"SourceInstanceIdsReverseMatch,omitempty"`
	// The priority of the routing policy that you want to associate with the current one.
	//
	// *   This parameter takes effect only when the **MapResult** parameter is set to **Permit**. This way, the permitted route is matched against the next routing policy.
	// *   The region and direction of the routing policy to be associated must be the same as those of the current routing policy.
	// *   The priority of the next routing policy must be lower than the priority of the current routing policy.
	SourceRegionIds []*string `json:"SourceRegionIds,omitempty" xml:"SourceRegionIds,omitempty" type:"Repeated"`
	// The ID of the region where the routing policy is applied.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	SourceRouteTableIds []*string `json:"SourceRouteTableIds,omitempty" xml:"SourceRouteTableIds,omitempty" type:"Repeated"`
	// The type of destination network instance.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
	// The operation that you want to perform. Set the value to **CreateCenRouteMap**.
	TransmitDirection *string `json:"TransmitDirection,omitempty" xml:"TransmitDirection,omitempty"`
}

func (s CreateCenRouteMapRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateCenRouteMapRequest) GoString() string {
	return s.String()
}

func (s *CreateCenRouteMapRequest) SetAsPathMatchMode(v string) *CreateCenRouteMapRequest {
	s.AsPathMatchMode = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetCenId(v string) *CreateCenRouteMapRequest {
	s.CenId = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetCenRegionId(v string) *CreateCenRouteMapRequest {
	s.CenRegionId = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetCidrMatchMode(v string) *CreateCenRouteMapRequest {
	s.CidrMatchMode = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetCommunityMatchMode(v string) *CreateCenRouteMapRequest {
	s.CommunityMatchMode = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetCommunityOperateMode(v string) *CreateCenRouteMapRequest {
	s.CommunityOperateMode = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetDescription(v string) *CreateCenRouteMapRequest {
	s.Description = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetDestinationChildInstanceTypes(v []*string) *CreateCenRouteMapRequest {
	s.DestinationChildInstanceTypes = v
	return s
}

func (s *CreateCenRouteMapRequest) SetDestinationCidrBlocks(v []*string) *CreateCenRouteMapRequest {
	s.DestinationCidrBlocks = v
	return s
}

func (s *CreateCenRouteMapRequest) SetDestinationInstanceIds(v []*string) *CreateCenRouteMapRequest {
	s.DestinationInstanceIds = v
	return s
}

func (s *CreateCenRouteMapRequest) SetDestinationInstanceIdsReverseMatch(v bool) *CreateCenRouteMapRequest {
	s.DestinationInstanceIdsReverseMatch = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetDestinationRouteTableIds(v []*string) *CreateCenRouteMapRequest {
	s.DestinationRouteTableIds = v
	return s
}

func (s *CreateCenRouteMapRequest) SetMapResult(v string) *CreateCenRouteMapRequest {
	s.MapResult = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetMatchAddressType(v string) *CreateCenRouteMapRequest {
	s.MatchAddressType = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetMatchAsns(v []*int64) *CreateCenRouteMapRequest {
	s.MatchAsns = v
	return s
}

func (s *CreateCenRouteMapRequest) SetMatchCommunitySet(v []*string) *CreateCenRouteMapRequest {
	s.MatchCommunitySet = v
	return s
}

func (s *CreateCenRouteMapRequest) SetNextPriority(v int32) *CreateCenRouteMapRequest {
	s.NextPriority = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetOperateCommunitySet(v []*string) *CreateCenRouteMapRequest {
	s.OperateCommunitySet = v
	return s
}

func (s *CreateCenRouteMapRequest) SetOwnerAccount(v string) *CreateCenRouteMapRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetOwnerId(v int64) *CreateCenRouteMapRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetPreference(v int32) *CreateCenRouteMapRequest {
	s.Preference = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetPrependAsPath(v []*int64) *CreateCenRouteMapRequest {
	s.PrependAsPath = v
	return s
}

func (s *CreateCenRouteMapRequest) SetPriority(v int32) *CreateCenRouteMapRequest {
	s.Priority = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetResourceOwnerAccount(v string) *CreateCenRouteMapRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetResourceOwnerId(v int64) *CreateCenRouteMapRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetRouteTypes(v []*string) *CreateCenRouteMapRequest {
	s.RouteTypes = v
	return s
}

func (s *CreateCenRouteMapRequest) SetSourceChildInstanceTypes(v []*string) *CreateCenRouteMapRequest {
	s.SourceChildInstanceTypes = v
	return s
}

func (s *CreateCenRouteMapRequest) SetSourceInstanceIds(v []*string) *CreateCenRouteMapRequest {
	s.SourceInstanceIds = v
	return s
}

func (s *CreateCenRouteMapRequest) SetSourceInstanceIdsReverseMatch(v bool) *CreateCenRouteMapRequest {
	s.SourceInstanceIdsReverseMatch = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetSourceRegionIds(v []*string) *CreateCenRouteMapRequest {
	s.SourceRegionIds = v
	return s
}

func (s *CreateCenRouteMapRequest) SetSourceRouteTableIds(v []*string) *CreateCenRouteMapRequest {
	s.SourceRouteTableIds = v
	return s
}

func (s *CreateCenRouteMapRequest) SetTransitRouterRouteTableId(v string) *CreateCenRouteMapRequest {
	s.TransitRouterRouteTableId = &v
	return s
}

func (s *CreateCenRouteMapRequest) SetTransmitDirection(v string) *CreateCenRouteMapRequest {
	s.TransmitDirection = &v
	return s
}

type CreateCenRouteMapResponseBody struct {
	RequestId  *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	RouteMapId *string `json:"RouteMapId,omitempty" xml:"RouteMapId,omitempty"`
}

func (s CreateCenRouteMapResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateCenRouteMapResponseBody) GoString() string {
	return s.String()
}

func (s *CreateCenRouteMapResponseBody) SetRequestId(v string) *CreateCenRouteMapResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateCenRouteMapResponseBody) SetRouteMapId(v string) *CreateCenRouteMapResponseBody {
	s.RouteMapId = &v
	return s
}

type CreateCenRouteMapResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateCenRouteMapResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateCenRouteMapResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateCenRouteMapResponse) GoString() string {
	return s.String()
}

func (s *CreateCenRouteMapResponse) SetHeaders(v map[string]*string) *CreateCenRouteMapResponse {
	s.Headers = v
	return s
}

func (s *CreateCenRouteMapResponse) SetStatusCode(v int32) *CreateCenRouteMapResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateCenRouteMapResponse) SetBody(v *CreateCenRouteMapResponseBody) *CreateCenRouteMapResponse {
	s.Body = v
	return s
}

type CreateFlowlogRequest struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, ClientToken is set to the value of RequestId. The value of RequestId for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the flow log.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the flow log.
	//
	// The name must be 2 to 128 characters in length, and can contain digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	FlowLogName *string `json:"FlowLogName,omitempty" xml:"FlowLogName,omitempty"`
	// The time window for collecting log data. Unit: seconds. Valid values: **60** and **600**. Default value: **600**.
	Interval *int64 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The Logstore where the flow log is stored.
	//
	// *   If a Logstore is already created in the selected region, enter the name of the Logstore.
	//
	// *   If no Logstores are created in the selected region, enter a name and the system automatically creates a Logstore. The name of the Logstore. The name must meet the following requirements:
	//
	//     *   The name must be unique in a project.
	//     *   The name can contain only lowercase letters, digits, hyphens (-), and underscores (\_).
	//     *   The name must start and end with a lowercase letter or a digit.
	//     *   The name must be 3 to 63 characters in length.
	LogStoreName *string `json:"LogStoreName,omitempty" xml:"LogStoreName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The Log Service project where the flow log is stored.
	//
	// *   If a project is already created in the selected region, enter the name of the project.
	//
	// *   If no projects are created in the selected region, enter a name and the system automatically creates a project.
	//
	//     The project name must be unique in a region. You cannot change the name after you create the project. The naming conventions are:
	//
	//     *   The name must be globally unique.
	//     *   The name can contain only lowercase letters, digits, and hyphens (-).
	//     *   The name must start and end with a lowercase letter or a digit.
	//     *   The name must be 3 to 63 characters in length.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The ID of the region where the flow log is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The information about the tags.
	//
	// You can specify at most 20 tags in each call.
	Tag []*CreateFlowlogRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the inter-region connection or the VBR connection.
	//
	// > This parameter is required.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s CreateFlowlogRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateFlowlogRequest) GoString() string {
	return s.String()
}

func (s *CreateFlowlogRequest) SetCenId(v string) *CreateFlowlogRequest {
	s.CenId = &v
	return s
}

func (s *CreateFlowlogRequest) SetClientToken(v string) *CreateFlowlogRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateFlowlogRequest) SetDescription(v string) *CreateFlowlogRequest {
	s.Description = &v
	return s
}

func (s *CreateFlowlogRequest) SetFlowLogName(v string) *CreateFlowlogRequest {
	s.FlowLogName = &v
	return s
}

func (s *CreateFlowlogRequest) SetInterval(v int64) *CreateFlowlogRequest {
	s.Interval = &v
	return s
}

func (s *CreateFlowlogRequest) SetLogStoreName(v string) *CreateFlowlogRequest {
	s.LogStoreName = &v
	return s
}

func (s *CreateFlowlogRequest) SetOwnerAccount(v string) *CreateFlowlogRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateFlowlogRequest) SetOwnerId(v int64) *CreateFlowlogRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateFlowlogRequest) SetProjectName(v string) *CreateFlowlogRequest {
	s.ProjectName = &v
	return s
}

func (s *CreateFlowlogRequest) SetRegionId(v string) *CreateFlowlogRequest {
	s.RegionId = &v
	return s
}

func (s *CreateFlowlogRequest) SetResourceOwnerAccount(v string) *CreateFlowlogRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateFlowlogRequest) SetResourceOwnerId(v int64) *CreateFlowlogRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateFlowlogRequest) SetTag(v []*CreateFlowlogRequestTag) *CreateFlowlogRequest {
	s.Tag = v
	return s
}

func (s *CreateFlowlogRequest) SetTransitRouterAttachmentId(v string) *CreateFlowlogRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

type CreateFlowlogRequestTag struct {
	// The tag key.
	//
	// The tag key cannot be an empty string. The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateFlowlogRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateFlowlogRequestTag) GoString() string {
	return s.String()
}

func (s *CreateFlowlogRequestTag) SetKey(v string) *CreateFlowlogRequestTag {
	s.Key = &v
	return s
}

func (s *CreateFlowlogRequestTag) SetValue(v string) *CreateFlowlogRequestTag {
	s.Value = &v
	return s
}

type CreateFlowlogResponseBody struct {
	// The ID of the flow log.
	FlowLogId *string `json:"FlowLogId,omitempty" xml:"FlowLogId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call is successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateFlowlogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateFlowlogResponseBody) GoString() string {
	return s.String()
}

func (s *CreateFlowlogResponseBody) SetFlowLogId(v string) *CreateFlowlogResponseBody {
	s.FlowLogId = &v
	return s
}

func (s *CreateFlowlogResponseBody) SetRequestId(v string) *CreateFlowlogResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateFlowlogResponseBody) SetSuccess(v string) *CreateFlowlogResponseBody {
	s.Success = &v
	return s
}

type CreateFlowlogResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateFlowlogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateFlowlogResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateFlowlogResponse) GoString() string {
	return s.String()
}

func (s *CreateFlowlogResponse) SetHeaders(v map[string]*string) *CreateFlowlogResponse {
	s.Headers = v
	return s
}

func (s *CreateFlowlogResponse) SetStatusCode(v int32) *CreateFlowlogResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateFlowlogResponse) SetBody(v *CreateFlowlogResponseBody) *CreateFlowlogResponse {
	s.Body = v
	return s
}

type CreateTrafficMarkingPolicyRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request format, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The differentiated services code point (DSCP) value to be added to packets that match the traffic classification rule. Valid values: **0** to **63**.
	//
	// The DSCP value of each traffic marking policy on a transit router must be unique.
	MarkingDscp  *int32  `json:"MarkingDscp,omitempty" xml:"MarkingDscp,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The priority value of the traffic marking policy. Valid values: **1** to **100**.
	//
	// The priority value of each traffic marking policy on a transit router must be unique. A smaller value specifies a higher priority.
	Priority             *int32  `json:"Priority,omitempty" xml:"Priority,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The description of the traffic marking policy.
	//
	// The description must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The description must start with a letter.
	TrafficMarkingPolicyDescription *string `json:"TrafficMarkingPolicyDescription,omitempty" xml:"TrafficMarkingPolicyDescription,omitempty"`
	// The name of the traffic marking policy.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	TrafficMarkingPolicyName *string `json:"TrafficMarkingPolicyName,omitempty" xml:"TrafficMarkingPolicyName,omitempty"`
	// The traffic classification rules in the traffic marking policy.
	//
	// Packets that match the traffic classification rules are assigned the DSCP value of the traffic marking policy.
	//
	// You can specify at most 50 traffic classification rules.
	TrafficMatchRules []*CreateTrafficMarkingPolicyRequestTrafficMatchRules `json:"TrafficMatchRules,omitempty" xml:"TrafficMatchRules,omitempty" type:"Repeated"`
	// The ID of the transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s CreateTrafficMarkingPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMarkingPolicyRequest) GoString() string {
	return s.String()
}

func (s *CreateTrafficMarkingPolicyRequest) SetClientToken(v string) *CreateTrafficMarkingPolicyRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTrafficMarkingPolicyRequest) SetDryRun(v bool) *CreateTrafficMarkingPolicyRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTrafficMarkingPolicyRequest) SetMarkingDscp(v int32) *CreateTrafficMarkingPolicyRequest {
	s.MarkingDscp = &v
	return s
}

func (s *CreateTrafficMarkingPolicyRequest) SetOwnerAccount(v string) *CreateTrafficMarkingPolicyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTrafficMarkingPolicyRequest) SetOwnerId(v int64) *CreateTrafficMarkingPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTrafficMarkingPolicyRequest) SetPriority(v int32) *CreateTrafficMarkingPolicyRequest {
	s.Priority = &v
	return s
}

func (s *CreateTrafficMarkingPolicyRequest) SetResourceOwnerAccount(v string) *CreateTrafficMarkingPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTrafficMarkingPolicyRequest) SetResourceOwnerId(v int64) *CreateTrafficMarkingPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTrafficMarkingPolicyRequest) SetTrafficMarkingPolicyDescription(v string) *CreateTrafficMarkingPolicyRequest {
	s.TrafficMarkingPolicyDescription = &v
	return s
}

func (s *CreateTrafficMarkingPolicyRequest) SetTrafficMarkingPolicyName(v string) *CreateTrafficMarkingPolicyRequest {
	s.TrafficMarkingPolicyName = &v
	return s
}

func (s *CreateTrafficMarkingPolicyRequest) SetTrafficMatchRules(v []*CreateTrafficMarkingPolicyRequestTrafficMatchRules) *CreateTrafficMarkingPolicyRequest {
	s.TrafficMatchRules = v
	return s
}

func (s *CreateTrafficMarkingPolicyRequest) SetTransitRouterId(v string) *CreateTrafficMarkingPolicyRequest {
	s.TransitRouterId = &v
	return s
}

type CreateTrafficMarkingPolicyRequestTrafficMatchRules struct {
	// The destination CIDR block that is used to match packets.
	//
	// The traffic classification rule matches the packets whose destination IP addresses fall within the specified destination CIDR block. If you do not set this parameter, packets with all destination IP addresses are matched.
	//
	// You can create up to 50 traffic classification rules in each call. You can specify a destination CIDR block for each traffic classification rule.
	DstCidr *string `json:"DstCidr,omitempty" xml:"DstCidr,omitempty"`
	// The destination port range that is used to match packets. Valid values: **-1** and **1** to **65535**.
	//
	// The traffic classification rule matches the packets whose destination ports fall within the destination port range. If you do not set this parameter, packets with all destination ports are matched.
	//
	// You can specify at most two ports. Take note of the following rules:
	//
	// *   If you enter only one port number such as 1, the system matches the packets whose destination port is port 1.
	// *   If you enter two port numbers such as 1 and 200, the system matches the packets whose destination ports fall between 1 and 200.
	// *   If you enter two port numbers and one of them is -1, the other port number must also be -1. In this case, packets with all destination ports are matched.
	//
	// You can create up to 50 traffic classification rules in each call. You can specify a destination port range for each traffic classification rule.
	DstPortRange []*int32 `json:"DstPortRange,omitempty" xml:"DstPortRange,omitempty" type:"Repeated"`
	// The DSCP value that is used to match packets. Valid values: **0** to **63**.
	//
	// The traffic classification rule matches the packets that contain the specified DSCP value. If you do not set this parameter, packets are considered a match regardless of the DSCP value.
	//
	// >  The DSCP value that you specify for this parameter is the DSCP value that packets carry before they are transmitted over the inter-region connection.
	//
	// You can create up to 50 traffic classification rules in each call. You can specify a DSCP value for each traffic classification rule.
	MatchDscp *int32 `json:"MatchDscp,omitempty" xml:"MatchDscp,omitempty"`
	// The protocol that is used to match packets.
	//
	// Valid values: **HTTP**, **HTTPS**, **TCP**, **UDP**, **SSH**, and **Telnet**. For more information, log on to the [Cloud Enterprise Network (CEN) console](https://cen.console.aliyun.com/cen/list).
	//
	// You can create up to 50 traffic classification rules in each call. You can specify a protocol for each traffic classification rule.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The source CIDR block that is used to match packets.
	//
	// The traffic classification rule matches the packets whose source IP addresses fall within the specified source CIDR block. If you do not set this parameter, packets with all source IP addresses are matched.
	//
	// You can create up to 50 traffic classification rules in each call. You can specify a source CIDR block for each traffic classification rule.
	SrcCidr *string `json:"SrcCidr,omitempty" xml:"SrcCidr,omitempty"`
	// The source port range that is used to match packets. Valid values: **-1** and **1** to **65535**.
	//
	// The traffic classification rule matches the packets whose source ports fall within the source port range. If you do not set this parameter, packets with all source ports are matched.
	//
	// You can specify at most two ports. Take note of the following rules:
	//
	// *   If you enter only one port number such as 1, the system matches the packets whose source port is 1.
	// *   If you enter two port numbers such as 1 and 200, the system matches the packets whose source ports fall between 1 and 200.
	// *   If you enter two port numbers and one of them is -1, the other port number must also be -1. In this case, packets with all source ports are matched.
	//
	// You can create up to 50 traffic classification rules in each call. You can specify a source port range for each traffic classification rule.
	SrcPortRange []*int32 `json:"SrcPortRange,omitempty" xml:"SrcPortRange,omitempty" type:"Repeated"`
	// The description of the traffic classification rule.
	//
	// You can create up to 50 traffic classification rules in each call. You can specify a description for each traffic classification rule.
	//
	// The description must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The description must start with a letter.
	TrafficMatchRuleDescription *string `json:"TrafficMatchRuleDescription,omitempty" xml:"TrafficMatchRuleDescription,omitempty"`
	// The name of the traffic classification rule.
	//
	// You can create up to 50 traffic classification rules in each call. You can specify a name for each traffic classification rule.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	TrafficMatchRuleName *string `json:"TrafficMatchRuleName,omitempty" xml:"TrafficMatchRuleName,omitempty"`
}

func (s CreateTrafficMarkingPolicyRequestTrafficMatchRules) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMarkingPolicyRequestTrafficMatchRules) GoString() string {
	return s.String()
}

func (s *CreateTrafficMarkingPolicyRequestTrafficMatchRules) SetDstCidr(v string) *CreateTrafficMarkingPolicyRequestTrafficMatchRules {
	s.DstCidr = &v
	return s
}

func (s *CreateTrafficMarkingPolicyRequestTrafficMatchRules) SetDstPortRange(v []*int32) *CreateTrafficMarkingPolicyRequestTrafficMatchRules {
	s.DstPortRange = v
	return s
}

func (s *CreateTrafficMarkingPolicyRequestTrafficMatchRules) SetMatchDscp(v int32) *CreateTrafficMarkingPolicyRequestTrafficMatchRules {
	s.MatchDscp = &v
	return s
}

func (s *CreateTrafficMarkingPolicyRequestTrafficMatchRules) SetProtocol(v string) *CreateTrafficMarkingPolicyRequestTrafficMatchRules {
	s.Protocol = &v
	return s
}

func (s *CreateTrafficMarkingPolicyRequestTrafficMatchRules) SetSrcCidr(v string) *CreateTrafficMarkingPolicyRequestTrafficMatchRules {
	s.SrcCidr = &v
	return s
}

func (s *CreateTrafficMarkingPolicyRequestTrafficMatchRules) SetSrcPortRange(v []*int32) *CreateTrafficMarkingPolicyRequestTrafficMatchRules {
	s.SrcPortRange = v
	return s
}

func (s *CreateTrafficMarkingPolicyRequestTrafficMatchRules) SetTrafficMatchRuleDescription(v string) *CreateTrafficMarkingPolicyRequestTrafficMatchRules {
	s.TrafficMatchRuleDescription = &v
	return s
}

func (s *CreateTrafficMarkingPolicyRequestTrafficMatchRules) SetTrafficMatchRuleName(v string) *CreateTrafficMarkingPolicyRequestTrafficMatchRules {
	s.TrafficMatchRuleName = &v
	return s
}

type CreateTrafficMarkingPolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the traffic marking policy.
	TrafficMarkingPolicyId *string `json:"TrafficMarkingPolicyId,omitempty" xml:"TrafficMarkingPolicyId,omitempty"`
}

func (s CreateTrafficMarkingPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMarkingPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTrafficMarkingPolicyResponseBody) SetRequestId(v string) *CreateTrafficMarkingPolicyResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTrafficMarkingPolicyResponseBody) SetTrafficMarkingPolicyId(v string) *CreateTrafficMarkingPolicyResponseBody {
	s.TrafficMarkingPolicyId = &v
	return s
}

type CreateTrafficMarkingPolicyResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTrafficMarkingPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTrafficMarkingPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTrafficMarkingPolicyResponse) GoString() string {
	return s.String()
}

func (s *CreateTrafficMarkingPolicyResponse) SetHeaders(v map[string]*string) *CreateTrafficMarkingPolicyResponse {
	s.Headers = v
	return s
}

func (s *CreateTrafficMarkingPolicyResponse) SetStatusCode(v int32) *CreateTrafficMarkingPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTrafficMarkingPolicyResponse) SetBody(v *CreateTrafficMarkingPolicyResponseBody) *CreateTrafficMarkingPolicyResponse {
	s.Body = v
	return s
}

type CreateTransitRouteTableAggregationRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, ClientToken is set to the value of RequestId. The value of RequestId for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **false** (default): performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block of the aggregate route.
	//
	// >  The following CIDR blocks are not supported:
	// >*   CIDR blocks that start with 0 or 100.64.
	// >*   Multicast CIDR blocks, including 224.0.0.1 to 239.255.255.254.
	TransitRouteTableAggregationCidr *string `json:"TransitRouteTableAggregationCidr,omitempty" xml:"TransitRouteTableAggregationCidr,omitempty"`
	// The description of the aggregate route.
	//
	// The description must be 0 to 256 characters in length, and can contain letters, digits, and the following special characters: , . ; / @ \_ -.
	TransitRouteTableAggregationDescription *string `json:"TransitRouteTableAggregationDescription,omitempty" xml:"TransitRouteTableAggregationDescription,omitempty"`
	// The name of the aggregate route.
	//
	// The name must be 1 to 128 characters in length, and can contain letters, digits, and the following special characters: , . ; / @ \_ -. You can also leave the name empty.
	TransitRouteTableAggregationName *string `json:"TransitRouteTableAggregationName,omitempty" xml:"TransitRouteTableAggregationName,omitempty"`
	// The scope of networks that you want to advertise the aggregate route.
	//
	// Set the value to **VPC**, which specified that the aggregate route is advertised to VPCs that are in associated forwarding relationship with a route table of the Enterprise Edition transit router and have route synchronization enabled.
	TransitRouteTableAggregationScope *string `json:"TransitRouteTableAggregationScope,omitempty" xml:"TransitRouteTableAggregationScope,omitempty"`
	// The ID of the route table of the Enterprise Edition transit router.
	TransitRouteTableId *string `json:"TransitRouteTableId,omitempty" xml:"TransitRouteTableId,omitempty"`
}

func (s CreateTransitRouteTableAggregationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouteTableAggregationRequest) GoString() string {
	return s.String()
}

func (s *CreateTransitRouteTableAggregationRequest) SetClientToken(v string) *CreateTransitRouteTableAggregationRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTransitRouteTableAggregationRequest) SetDryRun(v bool) *CreateTransitRouteTableAggregationRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTransitRouteTableAggregationRequest) SetOwnerAccount(v string) *CreateTransitRouteTableAggregationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTransitRouteTableAggregationRequest) SetOwnerId(v int64) *CreateTransitRouteTableAggregationRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTransitRouteTableAggregationRequest) SetResourceOwnerAccount(v string) *CreateTransitRouteTableAggregationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTransitRouteTableAggregationRequest) SetResourceOwnerId(v int64) *CreateTransitRouteTableAggregationRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTransitRouteTableAggregationRequest) SetTransitRouteTableAggregationCidr(v string) *CreateTransitRouteTableAggregationRequest {
	s.TransitRouteTableAggregationCidr = &v
	return s
}

func (s *CreateTransitRouteTableAggregationRequest) SetTransitRouteTableAggregationDescription(v string) *CreateTransitRouteTableAggregationRequest {
	s.TransitRouteTableAggregationDescription = &v
	return s
}

func (s *CreateTransitRouteTableAggregationRequest) SetTransitRouteTableAggregationName(v string) *CreateTransitRouteTableAggregationRequest {
	s.TransitRouteTableAggregationName = &v
	return s
}

func (s *CreateTransitRouteTableAggregationRequest) SetTransitRouteTableAggregationScope(v string) *CreateTransitRouteTableAggregationRequest {
	s.TransitRouteTableAggregationScope = &v
	return s
}

func (s *CreateTransitRouteTableAggregationRequest) SetTransitRouteTableId(v string) *CreateTransitRouteTableAggregationRequest {
	s.TransitRouteTableId = &v
	return s
}

type CreateTransitRouteTableAggregationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateTransitRouteTableAggregationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouteTableAggregationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTransitRouteTableAggregationResponseBody) SetRequestId(v string) *CreateTransitRouteTableAggregationResponseBody {
	s.RequestId = &v
	return s
}

type CreateTransitRouteTableAggregationResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTransitRouteTableAggregationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTransitRouteTableAggregationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouteTableAggregationResponse) GoString() string {
	return s.String()
}

func (s *CreateTransitRouteTableAggregationResponse) SetHeaders(v map[string]*string) *CreateTransitRouteTableAggregationResponse {
	s.Headers = v
	return s
}

func (s *CreateTransitRouteTableAggregationResponse) SetStatusCode(v int32) *CreateTransitRouteTableAggregationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTransitRouteTableAggregationResponse) SetBody(v *CreateTransitRouteTableAggregationResponseBody) *CreateTransitRouteTableAggregationResponse {
	s.Body = v
	return s
}

type CreateTransitRouterRequest struct {
	CenId                    *string                                            `json:"CenId,omitempty" xml:"CenId,omitempty"`
	ClientToken              *string                                            `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun                   *bool                                              `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount             *string                                            `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                  *int64                                             `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId                 *string                                            `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount     *string                                            `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId          *int64                                             `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SupportMulticast         *bool                                              `json:"SupportMulticast,omitempty" xml:"SupportMulticast,omitempty"`
	Tag                      []*CreateTransitRouterRequestTag                   `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	TransitRouterCidrList    []*CreateTransitRouterRequestTransitRouterCidrList `json:"TransitRouterCidrList,omitempty" xml:"TransitRouterCidrList,omitempty" type:"Repeated"`
	TransitRouterDescription *string                                            `json:"TransitRouterDescription,omitempty" xml:"TransitRouterDescription,omitempty"`
	TransitRouterName        *string                                            `json:"TransitRouterName,omitempty" xml:"TransitRouterName,omitempty"`
}

func (s CreateTransitRouterRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterRequest) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterRequest) SetCenId(v string) *CreateTransitRouterRequest {
	s.CenId = &v
	return s
}

func (s *CreateTransitRouterRequest) SetClientToken(v string) *CreateTransitRouterRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTransitRouterRequest) SetDryRun(v bool) *CreateTransitRouterRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTransitRouterRequest) SetOwnerAccount(v string) *CreateTransitRouterRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTransitRouterRequest) SetOwnerId(v int64) *CreateTransitRouterRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTransitRouterRequest) SetRegionId(v string) *CreateTransitRouterRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTransitRouterRequest) SetResourceOwnerAccount(v string) *CreateTransitRouterRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTransitRouterRequest) SetResourceOwnerId(v int64) *CreateTransitRouterRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTransitRouterRequest) SetSupportMulticast(v bool) *CreateTransitRouterRequest {
	s.SupportMulticast = &v
	return s
}

func (s *CreateTransitRouterRequest) SetTag(v []*CreateTransitRouterRequestTag) *CreateTransitRouterRequest {
	s.Tag = v
	return s
}

func (s *CreateTransitRouterRequest) SetTransitRouterCidrList(v []*CreateTransitRouterRequestTransitRouterCidrList) *CreateTransitRouterRequest {
	s.TransitRouterCidrList = v
	return s
}

func (s *CreateTransitRouterRequest) SetTransitRouterDescription(v string) *CreateTransitRouterRequest {
	s.TransitRouterDescription = &v
	return s
}

func (s *CreateTransitRouterRequest) SetTransitRouterName(v string) *CreateTransitRouterRequest {
	s.TransitRouterName = &v
	return s
}

type CreateTransitRouterRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateTransitRouterRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterRequestTag) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterRequestTag) SetKey(v string) *CreateTransitRouterRequestTag {
	s.Key = &v
	return s
}

func (s *CreateTransitRouterRequestTag) SetValue(v string) *CreateTransitRouterRequestTag {
	s.Value = &v
	return s
}

type CreateTransitRouterRequestTransitRouterCidrList struct {
	Cidr             *string `json:"Cidr,omitempty" xml:"Cidr,omitempty"`
	Description      *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Name             *string `json:"Name,omitempty" xml:"Name,omitempty"`
	PublishCidrRoute *bool   `json:"PublishCidrRoute,omitempty" xml:"PublishCidrRoute,omitempty"`
}

func (s CreateTransitRouterRequestTransitRouterCidrList) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterRequestTransitRouterCidrList) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterRequestTransitRouterCidrList) SetCidr(v string) *CreateTransitRouterRequestTransitRouterCidrList {
	s.Cidr = &v
	return s
}

func (s *CreateTransitRouterRequestTransitRouterCidrList) SetDescription(v string) *CreateTransitRouterRequestTransitRouterCidrList {
	s.Description = &v
	return s
}

func (s *CreateTransitRouterRequestTransitRouterCidrList) SetName(v string) *CreateTransitRouterRequestTransitRouterCidrList {
	s.Name = &v
	return s
}

func (s *CreateTransitRouterRequestTransitRouterCidrList) SetPublishCidrRoute(v bool) *CreateTransitRouterRequestTransitRouterCidrList {
	s.PublishCidrRoute = &v
	return s
}

type CreateTransitRouterShrinkRequest struct {
	CenId                       *string                                `json:"CenId,omitempty" xml:"CenId,omitempty"`
	ClientToken                 *string                                `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun                      *bool                                  `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount                *string                                `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                     *int64                                 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId                    *string                                `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount        *string                                `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId             *int64                                 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	SupportMulticast            *bool                                  `json:"SupportMulticast,omitempty" xml:"SupportMulticast,omitempty"`
	Tag                         []*CreateTransitRouterShrinkRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	TransitRouterCidrListShrink *string                                `json:"TransitRouterCidrList,omitempty" xml:"TransitRouterCidrList,omitempty"`
	TransitRouterDescription    *string                                `json:"TransitRouterDescription,omitempty" xml:"TransitRouterDescription,omitempty"`
	TransitRouterName           *string                                `json:"TransitRouterName,omitempty" xml:"TransitRouterName,omitempty"`
}

func (s CreateTransitRouterShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterShrinkRequest) SetCenId(v string) *CreateTransitRouterShrinkRequest {
	s.CenId = &v
	return s
}

func (s *CreateTransitRouterShrinkRequest) SetClientToken(v string) *CreateTransitRouterShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTransitRouterShrinkRequest) SetDryRun(v bool) *CreateTransitRouterShrinkRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTransitRouterShrinkRequest) SetOwnerAccount(v string) *CreateTransitRouterShrinkRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTransitRouterShrinkRequest) SetOwnerId(v int64) *CreateTransitRouterShrinkRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTransitRouterShrinkRequest) SetRegionId(v string) *CreateTransitRouterShrinkRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTransitRouterShrinkRequest) SetResourceOwnerAccount(v string) *CreateTransitRouterShrinkRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTransitRouterShrinkRequest) SetResourceOwnerId(v int64) *CreateTransitRouterShrinkRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTransitRouterShrinkRequest) SetSupportMulticast(v bool) *CreateTransitRouterShrinkRequest {
	s.SupportMulticast = &v
	return s
}

func (s *CreateTransitRouterShrinkRequest) SetTag(v []*CreateTransitRouterShrinkRequestTag) *CreateTransitRouterShrinkRequest {
	s.Tag = v
	return s
}

func (s *CreateTransitRouterShrinkRequest) SetTransitRouterCidrListShrink(v string) *CreateTransitRouterShrinkRequest {
	s.TransitRouterCidrListShrink = &v
	return s
}

func (s *CreateTransitRouterShrinkRequest) SetTransitRouterDescription(v string) *CreateTransitRouterShrinkRequest {
	s.TransitRouterDescription = &v
	return s
}

func (s *CreateTransitRouterShrinkRequest) SetTransitRouterName(v string) *CreateTransitRouterShrinkRequest {
	s.TransitRouterName = &v
	return s
}

type CreateTransitRouterShrinkRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateTransitRouterShrinkRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterShrinkRequestTag) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterShrinkRequestTag) SetKey(v string) *CreateTransitRouterShrinkRequestTag {
	s.Key = &v
	return s
}

func (s *CreateTransitRouterShrinkRequestTag) SetValue(v string) *CreateTransitRouterShrinkRequestTag {
	s.Value = &v
	return s
}

type CreateTransitRouterResponseBody struct {
	RequestId       *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s CreateTransitRouterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterResponseBody) SetRequestId(v string) *CreateTransitRouterResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTransitRouterResponseBody) SetTransitRouterId(v string) *CreateTransitRouterResponseBody {
	s.TransitRouterId = &v
	return s
}

type CreateTransitRouterResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTransitRouterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTransitRouterResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterResponse) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterResponse) SetHeaders(v map[string]*string) *CreateTransitRouterResponse {
	s.Headers = v
	return s
}

func (s *CreateTransitRouterResponse) SetStatusCode(v int32) *CreateTransitRouterResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTransitRouterResponse) SetBody(v *CreateTransitRouterResponseBody) *CreateTransitRouterResponse {
	s.Body = v
	return s
}

type CreateTransitRouterCidrRequest struct {
	// The operation that you want to perform. Set the value to **CreateTransitRouterCidr**.
	Cidr *string `json:"Cidr,omitempty" xml:"Cidr,omitempty"`
	// Specifies whether to allow the system to automatically add a route that points to the CIDR block to the route table of the transit router.
	//
	// *   **true** (default): yes
	//
	//     A value of true specifies that after you create a private VPN connection and enable route learning for the connection, the system automatically adds a blackhole route to the route table of the transit router to which the VPN connection is attached. The destination CIDR block of the blackhole route is the CIDR block of the transit router. The CIDR block of the transit router refers to the CIDR block from which gateway IP addresses are allocated to IPsec-VPN connections. The blackhole route is advertised only to the route table of the virtual border router (VBR) that is connected to the transit router.
	//
	// *   **false**: no
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The name of the CIDR block.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The CIDR block that you want to create for the transit router.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The description of the CIDR block.
	//
	// The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with `http://` or `https://`.
	PublishCidrRoute *bool `json:"PublishCidrRoute,omitempty" xml:"PublishCidrRoute,omitempty"`
	// The ID of the region where the transit router is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s CreateTransitRouterCidrRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterCidrRequest) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterCidrRequest) SetCidr(v string) *CreateTransitRouterCidrRequest {
	s.Cidr = &v
	return s
}

func (s *CreateTransitRouterCidrRequest) SetClientToken(v string) *CreateTransitRouterCidrRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTransitRouterCidrRequest) SetDescription(v string) *CreateTransitRouterCidrRequest {
	s.Description = &v
	return s
}

func (s *CreateTransitRouterCidrRequest) SetDryRun(v bool) *CreateTransitRouterCidrRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTransitRouterCidrRequest) SetName(v string) *CreateTransitRouterCidrRequest {
	s.Name = &v
	return s
}

func (s *CreateTransitRouterCidrRequest) SetOwnerAccount(v string) *CreateTransitRouterCidrRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTransitRouterCidrRequest) SetOwnerId(v int64) *CreateTransitRouterCidrRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTransitRouterCidrRequest) SetPublishCidrRoute(v bool) *CreateTransitRouterCidrRequest {
	s.PublishCidrRoute = &v
	return s
}

func (s *CreateTransitRouterCidrRequest) SetRegionId(v string) *CreateTransitRouterCidrRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTransitRouterCidrRequest) SetResourceOwnerAccount(v string) *CreateTransitRouterCidrRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTransitRouterCidrRequest) SetResourceOwnerId(v int64) *CreateTransitRouterCidrRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTransitRouterCidrRequest) SetTransitRouterId(v string) *CreateTransitRouterCidrRequest {
	s.TransitRouterId = &v
	return s
}

type CreateTransitRouterCidrResponseBody struct {
	RequestId           *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TransitRouterCidrId *string `json:"TransitRouterCidrId,omitempty" xml:"TransitRouterCidrId,omitempty"`
}

func (s CreateTransitRouterCidrResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterCidrResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterCidrResponseBody) SetRequestId(v string) *CreateTransitRouterCidrResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTransitRouterCidrResponseBody) SetTransitRouterCidrId(v string) *CreateTransitRouterCidrResponseBody {
	s.TransitRouterCidrId = &v
	return s
}

type CreateTransitRouterCidrResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTransitRouterCidrResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTransitRouterCidrResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterCidrResponse) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterCidrResponse) SetHeaders(v map[string]*string) *CreateTransitRouterCidrResponse {
	s.Headers = v
	return s
}

func (s *CreateTransitRouterCidrResponse) SetStatusCode(v int32) *CreateTransitRouterCidrResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTransitRouterCidrResponse) SetBody(v *CreateTransitRouterCidrResponseBody) *CreateTransitRouterCidrResponse {
	s.Body = v
	return s
}

type CreateTransitRouterMulticastDomainRequest struct {
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request format, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the transit router is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The information about the tags.
	//
	// You can specify at most 20 tags in each call.
	Tag []*CreateTransitRouterMulticastDomainRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The description of the multicast domain.
	//
	// The description must be 0 to 256 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (\_), and hyphens (-).
	TransitRouterMulticastDomainDescription *string `json:"TransitRouterMulticastDomainDescription,omitempty" xml:"TransitRouterMulticastDomainDescription,omitempty"`
	// The name of the multicast domain.
	//
	// The name must be 0 to 128 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (\_), and hyphens (-).
	TransitRouterMulticastDomainName *string `json:"TransitRouterMulticastDomainName,omitempty" xml:"TransitRouterMulticastDomainName,omitempty"`
}

func (s CreateTransitRouterMulticastDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterMulticastDomainRequest) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterMulticastDomainRequest) SetCenId(v string) *CreateTransitRouterMulticastDomainRequest {
	s.CenId = &v
	return s
}

func (s *CreateTransitRouterMulticastDomainRequest) SetClientToken(v string) *CreateTransitRouterMulticastDomainRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTransitRouterMulticastDomainRequest) SetDryRun(v bool) *CreateTransitRouterMulticastDomainRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTransitRouterMulticastDomainRequest) SetOwnerAccount(v string) *CreateTransitRouterMulticastDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTransitRouterMulticastDomainRequest) SetOwnerId(v int64) *CreateTransitRouterMulticastDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTransitRouterMulticastDomainRequest) SetRegionId(v string) *CreateTransitRouterMulticastDomainRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTransitRouterMulticastDomainRequest) SetResourceOwnerAccount(v string) *CreateTransitRouterMulticastDomainRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTransitRouterMulticastDomainRequest) SetResourceOwnerId(v int64) *CreateTransitRouterMulticastDomainRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTransitRouterMulticastDomainRequest) SetTag(v []*CreateTransitRouterMulticastDomainRequestTag) *CreateTransitRouterMulticastDomainRequest {
	s.Tag = v
	return s
}

func (s *CreateTransitRouterMulticastDomainRequest) SetTransitRouterId(v string) *CreateTransitRouterMulticastDomainRequest {
	s.TransitRouterId = &v
	return s
}

func (s *CreateTransitRouterMulticastDomainRequest) SetTransitRouterMulticastDomainDescription(v string) *CreateTransitRouterMulticastDomainRequest {
	s.TransitRouterMulticastDomainDescription = &v
	return s
}

func (s *CreateTransitRouterMulticastDomainRequest) SetTransitRouterMulticastDomainName(v string) *CreateTransitRouterMulticastDomainRequest {
	s.TransitRouterMulticastDomainName = &v
	return s
}

type CreateTransitRouterMulticastDomainRequestTag struct {
	// The tag key.
	//
	// The tag key cannot be an empty string. The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateTransitRouterMulticastDomainRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterMulticastDomainRequestTag) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterMulticastDomainRequestTag) SetKey(v string) *CreateTransitRouterMulticastDomainRequestTag {
	s.Key = &v
	return s
}

func (s *CreateTransitRouterMulticastDomainRequestTag) SetValue(v string) *CreateTransitRouterMulticastDomainRequestTag {
	s.Value = &v
	return s
}

type CreateTransitRouterMulticastDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the multicast domain.
	TransitRouterMulticastDomainId *string `json:"TransitRouterMulticastDomainId,omitempty" xml:"TransitRouterMulticastDomainId,omitempty"`
}

func (s CreateTransitRouterMulticastDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterMulticastDomainResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterMulticastDomainResponseBody) SetRequestId(v string) *CreateTransitRouterMulticastDomainResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTransitRouterMulticastDomainResponseBody) SetTransitRouterMulticastDomainId(v string) *CreateTransitRouterMulticastDomainResponseBody {
	s.TransitRouterMulticastDomainId = &v
	return s
}

type CreateTransitRouterMulticastDomainResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTransitRouterMulticastDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTransitRouterMulticastDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterMulticastDomainResponse) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterMulticastDomainResponse) SetHeaders(v map[string]*string) *CreateTransitRouterMulticastDomainResponse {
	s.Headers = v
	return s
}

func (s *CreateTransitRouterMulticastDomainResponse) SetStatusCode(v int32) *CreateTransitRouterMulticastDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTransitRouterMulticastDomainResponse) SetBody(v *CreateTransitRouterMulticastDomainResponseBody) *CreateTransitRouterMulticastDomainResponse {
	s.Body = v
	return s
}

type CreateTransitRouterPeerAttachmentRequest struct {
	// Specifies whether to enable the local Enterprise Edition transit router to automatically advertise the routes of the inter-region connection to the peer transit router. Valid values:
	//
	// *   **false** (default): no
	// *   **true**: yes
	AutoPublishRouteEnabled *bool `json:"AutoPublishRouteEnabled,omitempty" xml:"AutoPublishRouteEnabled,omitempty"`
	// The maximum bandwidth value of the inter-region connection. Unit: Mbit/s.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The method that is used to allocate bandwidth to the inter-region connection. Valid values:
	//
	// **BandwidthPackage**: allocates bandwidth from a bandwidth plan.
	BandwidthType *string `json:"BandwidthType,omitempty" xml:"BandwidthType,omitempty"`
	// The ID of the bandwidth plan that is used to allocate bandwidth to the inter-region connection.
	//
	// If this parameter is not set, the system allocates bandwidth that is used for testing purposes to the inter-region connection. The default bandwidth for testing purpose is 1 Kbit/s. You can use the bandwidth to test the connectivity of IPv4 networks.
	CenBandwidthPackageId *string `json:"CenBandwidthPackageId,omitempty" xml:"CenBandwidthPackageId,omitempty"`
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Default values:
	//
	// *   **false** (default): performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the system returns the ID of the request.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the peer transit router.
	PeerTransitRouterId *string `json:"PeerTransitRouterId,omitempty" xml:"PeerTransitRouterId,omitempty"`
	// The ID of the region where the peer transit router is deployed.
	PeerTransitRouterRegionId *string `json:"PeerTransitRouterRegionId,omitempty" xml:"PeerTransitRouterRegionId,omitempty"`
	// The ID of the region where the local Enterprise Edition transit router is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The information about the tags.
	//
	// You can specify at most 20 tags in each call.
	Tag []*CreateTransitRouterPeerAttachmentRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The description of the inter-region connection.
	//
	// The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with `http://` or `https://`.
	TransitRouterAttachmentDescription *string `json:"TransitRouterAttachmentDescription,omitempty" xml:"TransitRouterAttachmentDescription,omitempty"`
	// The name of the inter-region connection.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	TransitRouterAttachmentName *string `json:"TransitRouterAttachmentName,omitempty" xml:"TransitRouterAttachmentName,omitempty"`
	// The ID of the local Enterprise Edition transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s CreateTransitRouterPeerAttachmentRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterPeerAttachmentRequest) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetAutoPublishRouteEnabled(v bool) *CreateTransitRouterPeerAttachmentRequest {
	s.AutoPublishRouteEnabled = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetBandwidth(v int32) *CreateTransitRouterPeerAttachmentRequest {
	s.Bandwidth = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetBandwidthType(v string) *CreateTransitRouterPeerAttachmentRequest {
	s.BandwidthType = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetCenBandwidthPackageId(v string) *CreateTransitRouterPeerAttachmentRequest {
	s.CenBandwidthPackageId = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetCenId(v string) *CreateTransitRouterPeerAttachmentRequest {
	s.CenId = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetClientToken(v string) *CreateTransitRouterPeerAttachmentRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetDryRun(v bool) *CreateTransitRouterPeerAttachmentRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetOwnerAccount(v string) *CreateTransitRouterPeerAttachmentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetOwnerId(v int64) *CreateTransitRouterPeerAttachmentRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetPeerTransitRouterId(v string) *CreateTransitRouterPeerAttachmentRequest {
	s.PeerTransitRouterId = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetPeerTransitRouterRegionId(v string) *CreateTransitRouterPeerAttachmentRequest {
	s.PeerTransitRouterRegionId = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetRegionId(v string) *CreateTransitRouterPeerAttachmentRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetResourceOwnerAccount(v string) *CreateTransitRouterPeerAttachmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetResourceOwnerId(v int64) *CreateTransitRouterPeerAttachmentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetTag(v []*CreateTransitRouterPeerAttachmentRequestTag) *CreateTransitRouterPeerAttachmentRequest {
	s.Tag = v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetTransitRouterAttachmentDescription(v string) *CreateTransitRouterPeerAttachmentRequest {
	s.TransitRouterAttachmentDescription = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetTransitRouterAttachmentName(v string) *CreateTransitRouterPeerAttachmentRequest {
	s.TransitRouterAttachmentName = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequest) SetTransitRouterId(v string) *CreateTransitRouterPeerAttachmentRequest {
	s.TransitRouterId = &v
	return s
}

type CreateTransitRouterPeerAttachmentRequestTag struct {
	// The tag key.
	//
	// The tag key cannot be an empty string. The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateTransitRouterPeerAttachmentRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterPeerAttachmentRequestTag) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterPeerAttachmentRequestTag) SetKey(v string) *CreateTransitRouterPeerAttachmentRequestTag {
	s.Key = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentRequestTag) SetValue(v string) *CreateTransitRouterPeerAttachmentRequestTag {
	s.Value = &v
	return s
}

type CreateTransitRouterPeerAttachmentResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the inter-region connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s CreateTransitRouterPeerAttachmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterPeerAttachmentResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterPeerAttachmentResponseBody) SetRequestId(v string) *CreateTransitRouterPeerAttachmentResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentResponseBody) SetTransitRouterAttachmentId(v string) *CreateTransitRouterPeerAttachmentResponseBody {
	s.TransitRouterAttachmentId = &v
	return s
}

type CreateTransitRouterPeerAttachmentResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTransitRouterPeerAttachmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTransitRouterPeerAttachmentResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterPeerAttachmentResponse) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterPeerAttachmentResponse) SetHeaders(v map[string]*string) *CreateTransitRouterPeerAttachmentResponse {
	s.Headers = v
	return s
}

func (s *CreateTransitRouterPeerAttachmentResponse) SetStatusCode(v int32) *CreateTransitRouterPeerAttachmentResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTransitRouterPeerAttachmentResponse) SetBody(v *CreateTransitRouterPeerAttachmentResponseBody) *CreateTransitRouterPeerAttachmentResponse {
	s.Body = v
	return s
}

type CreateTransitRouterPrefixListAssociationRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the next hop.
	//
	// > If **NextHopType** is set to **BlackHole**, you must set this parameter to **BlackHole**.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The type of the next hop. Valid values:
	//
	// *   **BlackHole**: specifies that all the CIDR blocks in the prefix list are blackhole routes. Packets destined for the CIDR blocks are dropped.
	// *   **VPC**: specifies that the next hop of the CIDR blocks in the prefix list is a virtual private cloud (VPC) connection.
	// *   **VBR**: specifies that the next hop of the CIDR blocks in the prefix list is a virtual border router (VBR) connection.
	// *   **TR**: specifies that the next hop of the CIDR blocks in the prefix list is an inter-region connection.
	NextHopType  *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the Alibaba Cloud account to which the prefix list belongs.
	OwnerUid *int64 `json:"OwnerUid,omitempty" xml:"OwnerUid,omitempty"`
	// The ID of the prefix list.
	PrefixListId *string `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	// The ID of the region where the transit router is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The ID of the route table of the transit router.
	TransitRouterTableId *string `json:"TransitRouterTableId,omitempty" xml:"TransitRouterTableId,omitempty"`
}

func (s CreateTransitRouterPrefixListAssociationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterPrefixListAssociationRequest) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterPrefixListAssociationRequest) SetClientToken(v string) *CreateTransitRouterPrefixListAssociationRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTransitRouterPrefixListAssociationRequest) SetDryRun(v bool) *CreateTransitRouterPrefixListAssociationRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTransitRouterPrefixListAssociationRequest) SetNextHop(v string) *CreateTransitRouterPrefixListAssociationRequest {
	s.NextHop = &v
	return s
}

func (s *CreateTransitRouterPrefixListAssociationRequest) SetNextHopType(v string) *CreateTransitRouterPrefixListAssociationRequest {
	s.NextHopType = &v
	return s
}

func (s *CreateTransitRouterPrefixListAssociationRequest) SetOwnerAccount(v string) *CreateTransitRouterPrefixListAssociationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTransitRouterPrefixListAssociationRequest) SetOwnerId(v int64) *CreateTransitRouterPrefixListAssociationRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTransitRouterPrefixListAssociationRequest) SetOwnerUid(v int64) *CreateTransitRouterPrefixListAssociationRequest {
	s.OwnerUid = &v
	return s
}

func (s *CreateTransitRouterPrefixListAssociationRequest) SetPrefixListId(v string) *CreateTransitRouterPrefixListAssociationRequest {
	s.PrefixListId = &v
	return s
}

func (s *CreateTransitRouterPrefixListAssociationRequest) SetRegionId(v string) *CreateTransitRouterPrefixListAssociationRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTransitRouterPrefixListAssociationRequest) SetResourceOwnerAccount(v string) *CreateTransitRouterPrefixListAssociationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTransitRouterPrefixListAssociationRequest) SetResourceOwnerId(v int64) *CreateTransitRouterPrefixListAssociationRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTransitRouterPrefixListAssociationRequest) SetTransitRouterId(v string) *CreateTransitRouterPrefixListAssociationRequest {
	s.TransitRouterId = &v
	return s
}

func (s *CreateTransitRouterPrefixListAssociationRequest) SetTransitRouterTableId(v string) *CreateTransitRouterPrefixListAssociationRequest {
	s.TransitRouterTableId = &v
	return s
}

type CreateTransitRouterPrefixListAssociationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateTransitRouterPrefixListAssociationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterPrefixListAssociationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterPrefixListAssociationResponseBody) SetRequestId(v string) *CreateTransitRouterPrefixListAssociationResponseBody {
	s.RequestId = &v
	return s
}

type CreateTransitRouterPrefixListAssociationResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTransitRouterPrefixListAssociationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTransitRouterPrefixListAssociationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterPrefixListAssociationResponse) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterPrefixListAssociationResponse) SetHeaders(v map[string]*string) *CreateTransitRouterPrefixListAssociationResponse {
	s.Headers = v
	return s
}

func (s *CreateTransitRouterPrefixListAssociationResponse) SetStatusCode(v int32) *CreateTransitRouterPrefixListAssociationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTransitRouterPrefixListAssociationResponse) SetBody(v *CreateTransitRouterPrefixListAssociationResponseBody) *CreateTransitRouterPrefixListAssociationResponse {
	s.Body = v
	return s
}

type CreateTransitRouterRouteEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a precheck to check information such as the permissions and instance status. Valid values:
	//
	// *   **false** (default): sends the request. If the request passes the precheck, the route entry is added.
	// *   **true**: sends a precheck request but does not add the route. If you use this value, the system checks the required parameters and the request syntax. If the request fails to pass the precheck, an error message is returned. If the request passes the check, the `DryRunOperation` error code is returned.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The description of the route.
	//
	// The description must be 0 to 256 characters in length, and can contain letters, digits, and the following special characters: , . ; / @ \_ -.
	TransitRouterRouteEntryDescription *string `json:"TransitRouterRouteEntryDescription,omitempty" xml:"TransitRouterRouteEntryDescription,omitempty"`
	// The destination CIDR block of the route.
	TransitRouterRouteEntryDestinationCidrBlock *string `json:"TransitRouterRouteEntryDestinationCidrBlock,omitempty" xml:"TransitRouterRouteEntryDestinationCidrBlock,omitempty"`
	// The name of the route.
	//
	// The name must be 0 to 128 characters in length, and can contain letters, digits, and the following special characters: , . ; / @ \_ -.
	TransitRouterRouteEntryName *string `json:"TransitRouterRouteEntryName,omitempty" xml:"TransitRouterRouteEntryName,omitempty"`
	// The ID of the network instance connection that you want to specify as the next hop.
	TransitRouterRouteEntryNextHopId *string `json:"TransitRouterRouteEntryNextHopId,omitempty" xml:"TransitRouterRouteEntryNextHopId,omitempty"`
	// The type of the next hop. Valid values:
	//
	// *   **BlackHole**: routes network traffic to a black hole. All packets that match this route are dropped. If you select this option, you do not need to specify the next hop information.
	// *   **Attachment**: routes network traffic to a network instance connection. If you select this option, you must specify the ID of the network instance connection. All packets that match this route are routed to the specified network instance connection.
	TransitRouterRouteEntryNextHopType *string `json:"TransitRouterRouteEntryNextHopType,omitempty" xml:"TransitRouterRouteEntryNextHopType,omitempty"`
	// The ID of the route table of the Enterprise Edition transit router.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
}

func (s CreateTransitRouterRouteEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterRouteEntryRequest) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterRouteEntryRequest) SetClientToken(v string) *CreateTransitRouterRouteEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTransitRouterRouteEntryRequest) SetDryRun(v bool) *CreateTransitRouterRouteEntryRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTransitRouterRouteEntryRequest) SetOwnerAccount(v string) *CreateTransitRouterRouteEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTransitRouterRouteEntryRequest) SetOwnerId(v int64) *CreateTransitRouterRouteEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTransitRouterRouteEntryRequest) SetResourceOwnerAccount(v string) *CreateTransitRouterRouteEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTransitRouterRouteEntryRequest) SetResourceOwnerId(v int64) *CreateTransitRouterRouteEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTransitRouterRouteEntryRequest) SetTransitRouterRouteEntryDescription(v string) *CreateTransitRouterRouteEntryRequest {
	s.TransitRouterRouteEntryDescription = &v
	return s
}

func (s *CreateTransitRouterRouteEntryRequest) SetTransitRouterRouteEntryDestinationCidrBlock(v string) *CreateTransitRouterRouteEntryRequest {
	s.TransitRouterRouteEntryDestinationCidrBlock = &v
	return s
}

func (s *CreateTransitRouterRouteEntryRequest) SetTransitRouterRouteEntryName(v string) *CreateTransitRouterRouteEntryRequest {
	s.TransitRouterRouteEntryName = &v
	return s
}

func (s *CreateTransitRouterRouteEntryRequest) SetTransitRouterRouteEntryNextHopId(v string) *CreateTransitRouterRouteEntryRequest {
	s.TransitRouterRouteEntryNextHopId = &v
	return s
}

func (s *CreateTransitRouterRouteEntryRequest) SetTransitRouterRouteEntryNextHopType(v string) *CreateTransitRouterRouteEntryRequest {
	s.TransitRouterRouteEntryNextHopType = &v
	return s
}

func (s *CreateTransitRouterRouteEntryRequest) SetTransitRouterRouteTableId(v string) *CreateTransitRouterRouteEntryRequest {
	s.TransitRouterRouteTableId = &v
	return s
}

type CreateTransitRouterRouteEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the route.
	TransitRouterRouteEntryId *string `json:"TransitRouterRouteEntryId,omitempty" xml:"TransitRouterRouteEntryId,omitempty"`
}

func (s CreateTransitRouterRouteEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterRouteEntryResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterRouteEntryResponseBody) SetRequestId(v string) *CreateTransitRouterRouteEntryResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTransitRouterRouteEntryResponseBody) SetTransitRouterRouteEntryId(v string) *CreateTransitRouterRouteEntryResponseBody {
	s.TransitRouterRouteEntryId = &v
	return s
}

type CreateTransitRouterRouteEntryResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTransitRouterRouteEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTransitRouterRouteEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterRouteEntryResponse) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterRouteEntryResponse) SetHeaders(v map[string]*string) *CreateTransitRouterRouteEntryResponse {
	s.Headers = v
	return s
}

func (s *CreateTransitRouterRouteEntryResponse) SetStatusCode(v int32) *CreateTransitRouterRouteEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTransitRouterRouteEntryResponse) SetBody(v *CreateTransitRouterRouteEntryResponseBody) *CreateTransitRouterRouteEntryResponse {
	s.Body = v
	return s
}

type CreateTransitRouterRouteTableRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** may be different for each API request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to precheck the request. Check items include permissions and the status of the specified cloud resources. Valid values:
	//
	// *   **false** (default): sends the request. If the request passes the precheck, the custom route table is created.
	// *   **true**: prechecks the request but does not create the custom route table. If you use this value, the system checks the required parameters and the request syntax. If the request fails to pass the precheck, an error message is returned. If the request passes the check, the system returns the ID of the request.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The features of the route table.
	RouteTableOptions *CreateTransitRouterRouteTableRequestRouteTableOptions `json:"RouteTableOptions,omitempty" xml:"RouteTableOptions,omitempty" type:"Struct"`
	// The tags.
	//
	// You can specify at most 20 tags in each call.
	Tag []*CreateTransitRouterRouteTableRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the Enterprise Edition transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The description of the custom route table.
	//
	// The description must be 2 to 256 characters in length, and can contain letters, digits, and the following special characters: , . ; / @ \_ -. You can also leave the description empty.
	TransitRouterRouteTableDescription *string `json:"TransitRouterRouteTableDescription,omitempty" xml:"TransitRouterRouteTableDescription,omitempty"`
	// The name of the custom route table.
	//
	// The name must be 1 to 128 characters in length, and can contain letters, digits, and the following special characters: , . ; / @ \_ -. You can also leave the name empty.
	TransitRouterRouteTableName *string `json:"TransitRouterRouteTableName,omitempty" xml:"TransitRouterRouteTableName,omitempty"`
}

func (s CreateTransitRouterRouteTableRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterRouteTableRequest) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterRouteTableRequest) SetClientToken(v string) *CreateTransitRouterRouteTableRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTransitRouterRouteTableRequest) SetDryRun(v bool) *CreateTransitRouterRouteTableRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTransitRouterRouteTableRequest) SetOwnerAccount(v string) *CreateTransitRouterRouteTableRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTransitRouterRouteTableRequest) SetOwnerId(v int64) *CreateTransitRouterRouteTableRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTransitRouterRouteTableRequest) SetResourceOwnerAccount(v string) *CreateTransitRouterRouteTableRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTransitRouterRouteTableRequest) SetResourceOwnerId(v int64) *CreateTransitRouterRouteTableRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTransitRouterRouteTableRequest) SetRouteTableOptions(v *CreateTransitRouterRouteTableRequestRouteTableOptions) *CreateTransitRouterRouteTableRequest {
	s.RouteTableOptions = v
	return s
}

func (s *CreateTransitRouterRouteTableRequest) SetTag(v []*CreateTransitRouterRouteTableRequestTag) *CreateTransitRouterRouteTableRequest {
	s.Tag = v
	return s
}

func (s *CreateTransitRouterRouteTableRequest) SetTransitRouterId(v string) *CreateTransitRouterRouteTableRequest {
	s.TransitRouterId = &v
	return s
}

func (s *CreateTransitRouterRouteTableRequest) SetTransitRouterRouteTableDescription(v string) *CreateTransitRouterRouteTableRequest {
	s.TransitRouterRouteTableDescription = &v
	return s
}

func (s *CreateTransitRouterRouteTableRequest) SetTransitRouterRouteTableName(v string) *CreateTransitRouterRouteTableRequest {
	s.TransitRouterRouteTableName = &v
	return s
}

type CreateTransitRouterRouteTableRequestRouteTableOptions struct {
	// Specifies whether to enable multi-region equal-cost multi-path (ECMP) routing. Valid values:
	//
	// *   **disable**(default) If multi-region ECMP routing is disabled, routes that are learned from different regions but have the same prefix and attributes select the transit router with the smallest region ID as the next hop. Region IDs are sorted in alphabetic order. The network latency and bandwidth consumption also vary based on the region. Proceed with caution.
	// *   **enable** If multi-region ECMP routing is enabled, routes that are learned from different regions but have the same prefix and attributes form an ECMP route. The network latency and bandwidth consumption also vary based on the region. Proceed with caution.
	MultiRegionECMP *string `json:"MultiRegionECMP,omitempty" xml:"MultiRegionECMP,omitempty"`
}

func (s CreateTransitRouterRouteTableRequestRouteTableOptions) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterRouteTableRequestRouteTableOptions) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterRouteTableRequestRouteTableOptions) SetMultiRegionECMP(v string) *CreateTransitRouterRouteTableRequestRouteTableOptions {
	s.MultiRegionECMP = &v
	return s
}

type CreateTransitRouterRouteTableRequestTag struct {
	// The tag key.
	//
	// The tag key cannot be an empty string. The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateTransitRouterRouteTableRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterRouteTableRequestTag) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterRouteTableRequestTag) SetKey(v string) *CreateTransitRouterRouteTableRequestTag {
	s.Key = &v
	return s
}

func (s *CreateTransitRouterRouteTableRequestTag) SetValue(v string) *CreateTransitRouterRouteTableRequestTag {
	s.Value = &v
	return s
}

type CreateTransitRouterRouteTableResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the custom route table.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
}

func (s CreateTransitRouterRouteTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterRouteTableResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterRouteTableResponseBody) SetRequestId(v string) *CreateTransitRouterRouteTableResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTransitRouterRouteTableResponseBody) SetTransitRouterRouteTableId(v string) *CreateTransitRouterRouteTableResponseBody {
	s.TransitRouterRouteTableId = &v
	return s
}

type CreateTransitRouterRouteTableResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTransitRouterRouteTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTransitRouterRouteTableResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterRouteTableResponse) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterRouteTableResponse) SetHeaders(v map[string]*string) *CreateTransitRouterRouteTableResponse {
	s.Headers = v
	return s
}

func (s *CreateTransitRouterRouteTableResponse) SetStatusCode(v int32) *CreateTransitRouterRouteTableResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTransitRouterRouteTableResponse) SetBody(v *CreateTransitRouterRouteTableResponseBody) *CreateTransitRouterRouteTableResponse {
	s.Body = v
	return s
}

type CreateTransitRouterVbrAttachmentRequest struct {
	// Specifies whether to enable the Enterprise Edition transit router to automatically advertise routes to the VBR. Valid values:
	//
	// *   **false** (default): no
	// *   **true**: yes
	AutoPublishRouteEnabled *bool `json:"AutoPublishRouteEnabled,omitempty" xml:"AutoPublishRouteEnabled,omitempty"`
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Default values:
	//
	// *   **false** (default): performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the system returns the ID of the request.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the VBR.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The information about the tags.
	//
	// You can specify at most 20 tags in each call.
	Tag []*CreateTransitRouterVbrAttachmentRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The description of the VBR connection.
	//
	// The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with `http://` or `https://`.
	TransitRouterAttachmentDescription *string `json:"TransitRouterAttachmentDescription,omitempty" xml:"TransitRouterAttachmentDescription,omitempty"`
	// The name of the VBR connection.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	TransitRouterAttachmentName *string `json:"TransitRouterAttachmentName,omitempty" xml:"TransitRouterAttachmentName,omitempty"`
	// The ID of the Enterprise Edition transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The ID of the VBR.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
	// The ID of the Alibaba Cloud account to which the VBR belongs. The default value is the ID of the current Alibaba Cloud account.
	//
	// > If the network instance and CEN instance belong to different Alibaba Cloud accounts, this parameter is required.
	VbrOwnerId *int64 `json:"VbrOwnerId,omitempty" xml:"VbrOwnerId,omitempty"`
}

func (s CreateTransitRouterVbrAttachmentRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterVbrAttachmentRequest) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterVbrAttachmentRequest) SetAutoPublishRouteEnabled(v bool) *CreateTransitRouterVbrAttachmentRequest {
	s.AutoPublishRouteEnabled = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentRequest) SetCenId(v string) *CreateTransitRouterVbrAttachmentRequest {
	s.CenId = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentRequest) SetClientToken(v string) *CreateTransitRouterVbrAttachmentRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentRequest) SetDryRun(v bool) *CreateTransitRouterVbrAttachmentRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentRequest) SetOwnerAccount(v string) *CreateTransitRouterVbrAttachmentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentRequest) SetOwnerId(v int64) *CreateTransitRouterVbrAttachmentRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentRequest) SetRegionId(v string) *CreateTransitRouterVbrAttachmentRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentRequest) SetResourceOwnerAccount(v string) *CreateTransitRouterVbrAttachmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentRequest) SetResourceOwnerId(v int64) *CreateTransitRouterVbrAttachmentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentRequest) SetTag(v []*CreateTransitRouterVbrAttachmentRequestTag) *CreateTransitRouterVbrAttachmentRequest {
	s.Tag = v
	return s
}

func (s *CreateTransitRouterVbrAttachmentRequest) SetTransitRouterAttachmentDescription(v string) *CreateTransitRouterVbrAttachmentRequest {
	s.TransitRouterAttachmentDescription = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentRequest) SetTransitRouterAttachmentName(v string) *CreateTransitRouterVbrAttachmentRequest {
	s.TransitRouterAttachmentName = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentRequest) SetTransitRouterId(v string) *CreateTransitRouterVbrAttachmentRequest {
	s.TransitRouterId = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentRequest) SetVbrId(v string) *CreateTransitRouterVbrAttachmentRequest {
	s.VbrId = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentRequest) SetVbrOwnerId(v int64) *CreateTransitRouterVbrAttachmentRequest {
	s.VbrOwnerId = &v
	return s
}

type CreateTransitRouterVbrAttachmentRequestTag struct {
	// The tag key.
	//
	// The tag key cannot be an empty string. The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateTransitRouterVbrAttachmentRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterVbrAttachmentRequestTag) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterVbrAttachmentRequestTag) SetKey(v string) *CreateTransitRouterVbrAttachmentRequestTag {
	s.Key = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentRequestTag) SetValue(v string) *CreateTransitRouterVbrAttachmentRequestTag {
	s.Value = &v
	return s
}

type CreateTransitRouterVbrAttachmentResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the VBR connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s CreateTransitRouterVbrAttachmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterVbrAttachmentResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterVbrAttachmentResponseBody) SetRequestId(v string) *CreateTransitRouterVbrAttachmentResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentResponseBody) SetTransitRouterAttachmentId(v string) *CreateTransitRouterVbrAttachmentResponseBody {
	s.TransitRouterAttachmentId = &v
	return s
}

type CreateTransitRouterVbrAttachmentResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTransitRouterVbrAttachmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTransitRouterVbrAttachmentResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterVbrAttachmentResponse) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterVbrAttachmentResponse) SetHeaders(v map[string]*string) *CreateTransitRouterVbrAttachmentResponse {
	s.Headers = v
	return s
}

func (s *CreateTransitRouterVbrAttachmentResponse) SetStatusCode(v int32) *CreateTransitRouterVbrAttachmentResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTransitRouterVbrAttachmentResponse) SetBody(v *CreateTransitRouterVbrAttachmentResponseBody) *CreateTransitRouterVbrAttachmentResponse {
	s.Body = v
	return s
}

type CreateTransitRouterVpcAttachmentRequest struct {
	// Specifies whether to enable the Enterprise Edition transit router to automatically advertise routes to VPCs. Valid values:
	//
	// *   **false:** (default)
	// *   **true**
	AutoPublishRouteEnabled *bool `json:"AutoPublishRouteEnabled,omitempty" xml:"AutoPublishRouteEnabled,omitempty"`
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The billing method. The default value is **POSTPAY**, which specifies the pay-as-you-go billing method.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, ClientToken is set to the value of RequestId. The value of RequestId for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **false** (default): performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the VPC is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The information about the tags.
	//
	// You can specify at most 20 tags in each call.
	Tag []*CreateTransitRouterVpcAttachmentRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The description of the VPC connection.
	//
	// The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with `http://` or `https://`.
	TransitRouterAttachmentDescription *string `json:"TransitRouterAttachmentDescription,omitempty" xml:"TransitRouterAttachmentDescription,omitempty"`
	// The name of the VPC connection.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	TransitRouterAttachmentName *string `json:"TransitRouterAttachmentName,omitempty" xml:"TransitRouterAttachmentName,omitempty"`
	// The ID of the Enterprise Edition transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the Alibaba Cloud account to which the VPC belongs. The default value is the ID of the current Alibaba Cloud account.
	//
	// > If the network instance and CEN instance belong to different Alibaba Cloud accounts, this parameter is required.
	VpcOwnerId *int64 `json:"VpcOwnerId,omitempty" xml:"VpcOwnerId,omitempty"`
	// A zone that supports Enterprise Edition transit routers.
	//
	// You can specify at most 10 zones.
	ZoneMappings []*CreateTransitRouterVpcAttachmentRequestZoneMappings `json:"ZoneMappings,omitempty" xml:"ZoneMappings,omitempty" type:"Repeated"`
}

func (s CreateTransitRouterVpcAttachmentRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterVpcAttachmentRequest) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetAutoPublishRouteEnabled(v bool) *CreateTransitRouterVpcAttachmentRequest {
	s.AutoPublishRouteEnabled = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetCenId(v string) *CreateTransitRouterVpcAttachmentRequest {
	s.CenId = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetChargeType(v string) *CreateTransitRouterVpcAttachmentRequest {
	s.ChargeType = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetClientToken(v string) *CreateTransitRouterVpcAttachmentRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetDryRun(v bool) *CreateTransitRouterVpcAttachmentRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetOwnerAccount(v string) *CreateTransitRouterVpcAttachmentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetOwnerId(v int64) *CreateTransitRouterVpcAttachmentRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetRegionId(v string) *CreateTransitRouterVpcAttachmentRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetResourceOwnerAccount(v string) *CreateTransitRouterVpcAttachmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetResourceOwnerId(v int64) *CreateTransitRouterVpcAttachmentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetTag(v []*CreateTransitRouterVpcAttachmentRequestTag) *CreateTransitRouterVpcAttachmentRequest {
	s.Tag = v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetTransitRouterAttachmentDescription(v string) *CreateTransitRouterVpcAttachmentRequest {
	s.TransitRouterAttachmentDescription = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetTransitRouterAttachmentName(v string) *CreateTransitRouterVpcAttachmentRequest {
	s.TransitRouterAttachmentName = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetTransitRouterId(v string) *CreateTransitRouterVpcAttachmentRequest {
	s.TransitRouterId = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetVpcId(v string) *CreateTransitRouterVpcAttachmentRequest {
	s.VpcId = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetVpcOwnerId(v int64) *CreateTransitRouterVpcAttachmentRequest {
	s.VpcOwnerId = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequest) SetZoneMappings(v []*CreateTransitRouterVpcAttachmentRequestZoneMappings) *CreateTransitRouterVpcAttachmentRequest {
	s.ZoneMappings = v
	return s
}

type CreateTransitRouterVpcAttachmentRequestTag struct {
	// The tag key.
	//
	// The tag key cannot be an empty string. The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateTransitRouterVpcAttachmentRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterVpcAttachmentRequestTag) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterVpcAttachmentRequestTag) SetKey(v string) *CreateTransitRouterVpcAttachmentRequestTag {
	s.Key = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequestTag) SetValue(v string) *CreateTransitRouterVpcAttachmentRequestTag {
	s.Value = &v
	return s
}

type CreateTransitRouterVpcAttachmentRequestZoneMappings struct {
	// A vSwitch that is deployed in the zone that supports Enterprise Edition transit routers.
	//
	// You can specify vSwitches for at most 10 zones in each call.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the zone that supports Enterprise Edition transit routers.
	//
	// You can call the [DescribeZones](~~36064~~) operation to query the most recent zone list.
	//
	// You can specify at most 10 zones in each call.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s CreateTransitRouterVpcAttachmentRequestZoneMappings) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterVpcAttachmentRequestZoneMappings) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterVpcAttachmentRequestZoneMappings) SetVSwitchId(v string) *CreateTransitRouterVpcAttachmentRequestZoneMappings {
	s.VSwitchId = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentRequestZoneMappings) SetZoneId(v string) *CreateTransitRouterVpcAttachmentRequestZoneMappings {
	s.ZoneId = &v
	return s
}

type CreateTransitRouterVpcAttachmentResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the VPC connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s CreateTransitRouterVpcAttachmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterVpcAttachmentResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterVpcAttachmentResponseBody) SetRequestId(v string) *CreateTransitRouterVpcAttachmentResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentResponseBody) SetTransitRouterAttachmentId(v string) *CreateTransitRouterVpcAttachmentResponseBody {
	s.TransitRouterAttachmentId = &v
	return s
}

type CreateTransitRouterVpcAttachmentResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTransitRouterVpcAttachmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTransitRouterVpcAttachmentResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterVpcAttachmentResponse) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterVpcAttachmentResponse) SetHeaders(v map[string]*string) *CreateTransitRouterVpcAttachmentResponse {
	s.Headers = v
	return s
}

func (s *CreateTransitRouterVpcAttachmentResponse) SetStatusCode(v int32) *CreateTransitRouterVpcAttachmentResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTransitRouterVpcAttachmentResponse) SetBody(v *CreateTransitRouterVpcAttachmentResponseBody) *CreateTransitRouterVpcAttachmentResponse {
	s.Body = v
	return s
}

type CreateTransitRouterVpnAttachmentRequest struct {
	// Specifies whether to allow the transit router to automatically advertise routes to the IPsec-VPN attachment. Valid values:
	//
	// *   **true** (default): yes
	// *   **false**: no
	AutoPublishRouteEnabled *bool `json:"AutoPublishRouteEnabled,omitempty" xml:"AutoPublishRouteEnabled,omitempty"`
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The billing method.
	//
	// Set the value to **POSTPAY**, which is the default value and specifies the pay-as-you-go billing method.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the transit router is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The tags.
	//
	// You can specify at most 20 tags in each call.
	Tag []*CreateTransitRouterVpnAttachmentRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The description of the VPN attachment.
	//
	// The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with `http://` or `https://`.
	TransitRouterAttachmentDescription *string `json:"TransitRouterAttachmentDescription,omitempty" xml:"TransitRouterAttachmentDescription,omitempty"`
	// The name of the VPN attachment.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	TransitRouterAttachmentName *string `json:"TransitRouterAttachmentName,omitempty" xml:"TransitRouterAttachmentName,omitempty"`
	// The ID of the transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The ID of the IPsec-VPN attachment.
	VpnId *string `json:"VpnId,omitempty" xml:"VpnId,omitempty"`
	// The ID of the Alibaba Cloud account to which the IPsec-VPN connection belongs.
	//
	// *   If you do not set this parameter, the ID of the current Alibaba Cloud account is used.
	// *   You must set VpnOwnerId if you want to connect the transit router to an IPsec-VPN connection that belongs to another Alibaba Cloud account.
	VpnOwnerId *int64 `json:"VpnOwnerId,omitempty" xml:"VpnOwnerId,omitempty"`
	// The ID of the zone in the current region.
	//
	// Resources are deployed in the specified zone.
	Zone []*CreateTransitRouterVpnAttachmentRequestZone `json:"Zone,omitempty" xml:"Zone,omitempty" type:"Repeated"`
}

func (s CreateTransitRouterVpnAttachmentRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterVpnAttachmentRequest) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetAutoPublishRouteEnabled(v bool) *CreateTransitRouterVpnAttachmentRequest {
	s.AutoPublishRouteEnabled = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetCenId(v string) *CreateTransitRouterVpnAttachmentRequest {
	s.CenId = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetChargeType(v string) *CreateTransitRouterVpnAttachmentRequest {
	s.ChargeType = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetClientToken(v string) *CreateTransitRouterVpnAttachmentRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetDryRun(v bool) *CreateTransitRouterVpnAttachmentRequest {
	s.DryRun = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetOwnerAccount(v string) *CreateTransitRouterVpnAttachmentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetOwnerId(v int64) *CreateTransitRouterVpnAttachmentRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetRegionId(v string) *CreateTransitRouterVpnAttachmentRequest {
	s.RegionId = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetResourceOwnerAccount(v string) *CreateTransitRouterVpnAttachmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetResourceOwnerId(v int64) *CreateTransitRouterVpnAttachmentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetTag(v []*CreateTransitRouterVpnAttachmentRequestTag) *CreateTransitRouterVpnAttachmentRequest {
	s.Tag = v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetTransitRouterAttachmentDescription(v string) *CreateTransitRouterVpnAttachmentRequest {
	s.TransitRouterAttachmentDescription = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetTransitRouterAttachmentName(v string) *CreateTransitRouterVpnAttachmentRequest {
	s.TransitRouterAttachmentName = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetTransitRouterId(v string) *CreateTransitRouterVpnAttachmentRequest {
	s.TransitRouterId = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetVpnId(v string) *CreateTransitRouterVpnAttachmentRequest {
	s.VpnId = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetVpnOwnerId(v int64) *CreateTransitRouterVpnAttachmentRequest {
	s.VpnOwnerId = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequest) SetZone(v []*CreateTransitRouterVpnAttachmentRequestZone) *CreateTransitRouterVpnAttachmentRequest {
	s.Zone = v
	return s
}

type CreateTransitRouterVpnAttachmentRequestTag struct {
	// The tag key.
	//
	// The tag keys cannot be an empty string. The tag key can be up to 64 characters in length, and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateTransitRouterVpnAttachmentRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterVpnAttachmentRequestTag) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterVpnAttachmentRequestTag) SetKey(v string) *CreateTransitRouterVpnAttachmentRequestTag {
	s.Key = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentRequestTag) SetValue(v string) *CreateTransitRouterVpnAttachmentRequestTag {
	s.Value = &v
	return s
}

type CreateTransitRouterVpnAttachmentRequestZone struct {
	// The zone ID of the read-only instance.
	//
	// You can call the [ListTransitRouterAvailableResource](~~261356~~) operation to query the most recent zone list.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s CreateTransitRouterVpnAttachmentRequestZone) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterVpnAttachmentRequestZone) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterVpnAttachmentRequestZone) SetZoneId(v string) *CreateTransitRouterVpnAttachmentRequestZone {
	s.ZoneId = &v
	return s
}

type CreateTransitRouterVpnAttachmentResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the VPN attachment.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s CreateTransitRouterVpnAttachmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterVpnAttachmentResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterVpnAttachmentResponseBody) SetRequestId(v string) *CreateTransitRouterVpnAttachmentResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentResponseBody) SetTransitRouterAttachmentId(v string) *CreateTransitRouterVpnAttachmentResponseBody {
	s.TransitRouterAttachmentId = &v
	return s
}

type CreateTransitRouterVpnAttachmentResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTransitRouterVpnAttachmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTransitRouterVpnAttachmentResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTransitRouterVpnAttachmentResponse) GoString() string {
	return s.String()
}

func (s *CreateTransitRouterVpnAttachmentResponse) SetHeaders(v map[string]*string) *CreateTransitRouterVpnAttachmentResponse {
	s.Headers = v
	return s
}

func (s *CreateTransitRouterVpnAttachmentResponse) SetStatusCode(v int32) *CreateTransitRouterVpnAttachmentResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTransitRouterVpnAttachmentResponse) SetBody(v *CreateTransitRouterVpnAttachmentResponseBody) *CreateTransitRouterVpnAttachmentResponse {
	s.Body = v
	return s
}

type DeactiveFlowLogRequest struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, ClientToken is set to the value of RequestId. The value of RequestId for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of the flow log.
	FlowLogId    *string `json:"FlowLogId,omitempty" xml:"FlowLogId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the flow log is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeactiveFlowLogRequest) String() string {
	return tea.Prettify(s)
}

func (s DeactiveFlowLogRequest) GoString() string {
	return s.String()
}

func (s *DeactiveFlowLogRequest) SetCenId(v string) *DeactiveFlowLogRequest {
	s.CenId = &v
	return s
}

func (s *DeactiveFlowLogRequest) SetClientToken(v string) *DeactiveFlowLogRequest {
	s.ClientToken = &v
	return s
}

func (s *DeactiveFlowLogRequest) SetFlowLogId(v string) *DeactiveFlowLogRequest {
	s.FlowLogId = &v
	return s
}

func (s *DeactiveFlowLogRequest) SetOwnerAccount(v string) *DeactiveFlowLogRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeactiveFlowLogRequest) SetOwnerId(v int64) *DeactiveFlowLogRequest {
	s.OwnerId = &v
	return s
}

func (s *DeactiveFlowLogRequest) SetRegionId(v string) *DeactiveFlowLogRequest {
	s.RegionId = &v
	return s
}

func (s *DeactiveFlowLogRequest) SetResourceOwnerAccount(v string) *DeactiveFlowLogRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeactiveFlowLogRequest) SetResourceOwnerId(v int64) *DeactiveFlowLogRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeactiveFlowLogResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call is successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeactiveFlowLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeactiveFlowLogResponseBody) GoString() string {
	return s.String()
}

func (s *DeactiveFlowLogResponseBody) SetRequestId(v string) *DeactiveFlowLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeactiveFlowLogResponseBody) SetSuccess(v string) *DeactiveFlowLogResponseBody {
	s.Success = &v
	return s
}

type DeactiveFlowLogResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeactiveFlowLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeactiveFlowLogResponse) String() string {
	return tea.Prettify(s)
}

func (s DeactiveFlowLogResponse) GoString() string {
	return s.String()
}

func (s *DeactiveFlowLogResponse) SetHeaders(v map[string]*string) *DeactiveFlowLogResponse {
	s.Headers = v
	return s
}

func (s *DeactiveFlowLogResponse) SetStatusCode(v int32) *DeactiveFlowLogResponse {
	s.StatusCode = &v
	return s
}

func (s *DeactiveFlowLogResponse) SetBody(v *DeactiveFlowLogResponseBody) *DeactiveFlowLogResponse {
	s.Body = v
	return s
}

type DeleteCenRequest struct {
	// The ID of the CEN instance.
	CenId                *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteCenRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenRequest) GoString() string {
	return s.String()
}

func (s *DeleteCenRequest) SetCenId(v string) *DeleteCenRequest {
	s.CenId = &v
	return s
}

func (s *DeleteCenRequest) SetOwnerAccount(v string) *DeleteCenRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteCenRequest) SetOwnerId(v int64) *DeleteCenRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteCenRequest) SetResourceOwnerAccount(v string) *DeleteCenRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteCenRequest) SetResourceOwnerId(v int64) *DeleteCenRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteCenResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCenResponseBody) SetRequestId(v string) *DeleteCenResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCenResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCenResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenResponse) GoString() string {
	return s.String()
}

func (s *DeleteCenResponse) SetHeaders(v map[string]*string) *DeleteCenResponse {
	s.Headers = v
	return s
}

func (s *DeleteCenResponse) SetStatusCode(v int32) *DeleteCenResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCenResponse) SetBody(v *DeleteCenResponseBody) *DeleteCenResponse {
	s.Body = v
	return s
}

type DeleteCenBandwidthPackageRequest struct {
	CenBandwidthPackageId *string `json:"CenBandwidthPackageId,omitempty" xml:"CenBandwidthPackageId,omitempty"`
	OwnerAccount          *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId               *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount  *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId       *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteCenBandwidthPackageRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenBandwidthPackageRequest) GoString() string {
	return s.String()
}

func (s *DeleteCenBandwidthPackageRequest) SetCenBandwidthPackageId(v string) *DeleteCenBandwidthPackageRequest {
	s.CenBandwidthPackageId = &v
	return s
}

func (s *DeleteCenBandwidthPackageRequest) SetOwnerAccount(v string) *DeleteCenBandwidthPackageRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteCenBandwidthPackageRequest) SetOwnerId(v int64) *DeleteCenBandwidthPackageRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteCenBandwidthPackageRequest) SetResourceOwnerAccount(v string) *DeleteCenBandwidthPackageRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteCenBandwidthPackageRequest) SetResourceOwnerId(v int64) *DeleteCenBandwidthPackageRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteCenBandwidthPackageResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCenBandwidthPackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenBandwidthPackageResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCenBandwidthPackageResponseBody) SetRequestId(v string) *DeleteCenBandwidthPackageResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCenBandwidthPackageResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCenBandwidthPackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCenBandwidthPackageResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenBandwidthPackageResponse) GoString() string {
	return s.String()
}

func (s *DeleteCenBandwidthPackageResponse) SetHeaders(v map[string]*string) *DeleteCenBandwidthPackageResponse {
	s.Headers = v
	return s
}

func (s *DeleteCenBandwidthPackageResponse) SetStatusCode(v int32) *DeleteCenBandwidthPackageResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCenBandwidthPackageResponse) SetBody(v *DeleteCenBandwidthPackageResponseBody) *DeleteCenBandwidthPackageResponse {
	s.Body = v
	return s
}

type DeleteCenChildInstanceRouteEntryToAttachmentRequest struct {
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The destination CIDR block of the route.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// Specifies whether to perform a dry run to check information such as the permissions and the instance status. Valid values:
	//
	// *   **false**: performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the system returns the ID of the request.
	//
	// >  This parameter is not in use.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the route table configured on the network instance.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s DeleteCenChildInstanceRouteEntryToAttachmentRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenChildInstanceRouteEntryToAttachmentRequest) GoString() string {
	return s.String()
}

func (s *DeleteCenChildInstanceRouteEntryToAttachmentRequest) SetCenId(v string) *DeleteCenChildInstanceRouteEntryToAttachmentRequest {
	s.CenId = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToAttachmentRequest) SetClientToken(v string) *DeleteCenChildInstanceRouteEntryToAttachmentRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToAttachmentRequest) SetDestinationCidrBlock(v string) *DeleteCenChildInstanceRouteEntryToAttachmentRequest {
	s.DestinationCidrBlock = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToAttachmentRequest) SetDryRun(v bool) *DeleteCenChildInstanceRouteEntryToAttachmentRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToAttachmentRequest) SetOwnerAccount(v string) *DeleteCenChildInstanceRouteEntryToAttachmentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToAttachmentRequest) SetOwnerId(v int64) *DeleteCenChildInstanceRouteEntryToAttachmentRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToAttachmentRequest) SetResourceOwnerAccount(v string) *DeleteCenChildInstanceRouteEntryToAttachmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToAttachmentRequest) SetResourceOwnerId(v int64) *DeleteCenChildInstanceRouteEntryToAttachmentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToAttachmentRequest) SetRouteTableId(v string) *DeleteCenChildInstanceRouteEntryToAttachmentRequest {
	s.RouteTableId = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToAttachmentRequest) SetTransitRouterAttachmentId(v string) *DeleteCenChildInstanceRouteEntryToAttachmentRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

type DeleteCenChildInstanceRouteEntryToAttachmentResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCenChildInstanceRouteEntryToAttachmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenChildInstanceRouteEntryToAttachmentResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCenChildInstanceRouteEntryToAttachmentResponseBody) SetRequestId(v string) *DeleteCenChildInstanceRouteEntryToAttachmentResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCenChildInstanceRouteEntryToAttachmentResponse struct {
	Headers    map[string]*string                                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCenChildInstanceRouteEntryToAttachmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCenChildInstanceRouteEntryToAttachmentResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenChildInstanceRouteEntryToAttachmentResponse) GoString() string {
	return s.String()
}

func (s *DeleteCenChildInstanceRouteEntryToAttachmentResponse) SetHeaders(v map[string]*string) *DeleteCenChildInstanceRouteEntryToAttachmentResponse {
	s.Headers = v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToAttachmentResponse) SetStatusCode(v int32) *DeleteCenChildInstanceRouteEntryToAttachmentResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToAttachmentResponse) SetBody(v *DeleteCenChildInstanceRouteEntryToAttachmentResponseBody) *DeleteCenChildInstanceRouteEntryToAttachmentResponse {
	s.Body = v
	return s
}

type DeleteCenChildInstanceRouteEntryToCenRequest struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the Alibaba Cloud account to which the network instance belongs.
	//
	// > If the network instance and the CEN instance belong to different Alibaba Cloud accounts, this parameter is required.
	ChildInstanceAliUid *int64 `json:"ChildInstanceAliUid,omitempty" xml:"ChildInstanceAliUid,omitempty"`
	// The ID of the network instance.
	ChildInstanceId *string `json:"ChildInstanceId,omitempty" xml:"ChildInstanceId,omitempty"`
	// The ID of the region where the network instance is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to obtain the region ID.
	ChildInstanceRegionId *string `json:"ChildInstanceRegionId,omitempty" xml:"ChildInstanceRegionId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: a virtual private cloud (VPC)
	// *   **VBR**: a virtual border router (VBR)
	ChildInstanceType *string `json:"ChildInstanceType,omitempty" xml:"ChildInstanceType,omitempty"`
	// The destination CIDR block of the route.
	//
	// Specify the value of this parameter in CIDR notation. Example: 192.168.10.0/24.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the route table configured on the network instance.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
}

func (s DeleteCenChildInstanceRouteEntryToCenRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenChildInstanceRouteEntryToCenRequest) GoString() string {
	return s.String()
}

func (s *DeleteCenChildInstanceRouteEntryToCenRequest) SetCenId(v string) *DeleteCenChildInstanceRouteEntryToCenRequest {
	s.CenId = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToCenRequest) SetChildInstanceAliUid(v int64) *DeleteCenChildInstanceRouteEntryToCenRequest {
	s.ChildInstanceAliUid = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToCenRequest) SetChildInstanceId(v string) *DeleteCenChildInstanceRouteEntryToCenRequest {
	s.ChildInstanceId = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToCenRequest) SetChildInstanceRegionId(v string) *DeleteCenChildInstanceRouteEntryToCenRequest {
	s.ChildInstanceRegionId = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToCenRequest) SetChildInstanceType(v string) *DeleteCenChildInstanceRouteEntryToCenRequest {
	s.ChildInstanceType = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToCenRequest) SetDestinationCidrBlock(v string) *DeleteCenChildInstanceRouteEntryToCenRequest {
	s.DestinationCidrBlock = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToCenRequest) SetOwnerAccount(v string) *DeleteCenChildInstanceRouteEntryToCenRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToCenRequest) SetOwnerId(v int64) *DeleteCenChildInstanceRouteEntryToCenRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToCenRequest) SetResourceOwnerAccount(v string) *DeleteCenChildInstanceRouteEntryToCenRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToCenRequest) SetResourceOwnerId(v int64) *DeleteCenChildInstanceRouteEntryToCenRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToCenRequest) SetRouteTableId(v string) *DeleteCenChildInstanceRouteEntryToCenRequest {
	s.RouteTableId = &v
	return s
}

type DeleteCenChildInstanceRouteEntryToCenResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCenChildInstanceRouteEntryToCenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenChildInstanceRouteEntryToCenResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCenChildInstanceRouteEntryToCenResponseBody) SetRequestId(v string) *DeleteCenChildInstanceRouteEntryToCenResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCenChildInstanceRouteEntryToCenResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCenChildInstanceRouteEntryToCenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCenChildInstanceRouteEntryToCenResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenChildInstanceRouteEntryToCenResponse) GoString() string {
	return s.String()
}

func (s *DeleteCenChildInstanceRouteEntryToCenResponse) SetHeaders(v map[string]*string) *DeleteCenChildInstanceRouteEntryToCenResponse {
	s.Headers = v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToCenResponse) SetStatusCode(v int32) *DeleteCenChildInstanceRouteEntryToCenResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCenChildInstanceRouteEntryToCenResponse) SetBody(v *DeleteCenChildInstanceRouteEntryToCenResponseBody) *DeleteCenChildInstanceRouteEntryToCenResponse {
	s.Body = v
	return s
}

type DeleteCenInterRegionTrafficQosPolicyRequest struct {
	ClientToken          *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TrafficQosPolicyId   *string `json:"TrafficQosPolicyId,omitempty" xml:"TrafficQosPolicyId,omitempty"`
}

func (s DeleteCenInterRegionTrafficQosPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenInterRegionTrafficQosPolicyRequest) GoString() string {
	return s.String()
}

func (s *DeleteCenInterRegionTrafficQosPolicyRequest) SetClientToken(v string) *DeleteCenInterRegionTrafficQosPolicyRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteCenInterRegionTrafficQosPolicyRequest) SetDryRun(v bool) *DeleteCenInterRegionTrafficQosPolicyRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteCenInterRegionTrafficQosPolicyRequest) SetOwnerAccount(v string) *DeleteCenInterRegionTrafficQosPolicyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteCenInterRegionTrafficQosPolicyRequest) SetOwnerId(v int64) *DeleteCenInterRegionTrafficQosPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteCenInterRegionTrafficQosPolicyRequest) SetResourceOwnerAccount(v string) *DeleteCenInterRegionTrafficQosPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteCenInterRegionTrafficQosPolicyRequest) SetResourceOwnerId(v int64) *DeleteCenInterRegionTrafficQosPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteCenInterRegionTrafficQosPolicyRequest) SetTrafficQosPolicyId(v string) *DeleteCenInterRegionTrafficQosPolicyRequest {
	s.TrafficQosPolicyId = &v
	return s
}

type DeleteCenInterRegionTrafficQosPolicyResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCenInterRegionTrafficQosPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenInterRegionTrafficQosPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCenInterRegionTrafficQosPolicyResponseBody) SetRequestId(v string) *DeleteCenInterRegionTrafficQosPolicyResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCenInterRegionTrafficQosPolicyResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCenInterRegionTrafficQosPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCenInterRegionTrafficQosPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenInterRegionTrafficQosPolicyResponse) GoString() string {
	return s.String()
}

func (s *DeleteCenInterRegionTrafficQosPolicyResponse) SetHeaders(v map[string]*string) *DeleteCenInterRegionTrafficQosPolicyResponse {
	s.Headers = v
	return s
}

func (s *DeleteCenInterRegionTrafficQosPolicyResponse) SetStatusCode(v int32) *DeleteCenInterRegionTrafficQosPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCenInterRegionTrafficQosPolicyResponse) SetBody(v *DeleteCenInterRegionTrafficQosPolicyResponseBody) *DeleteCenInterRegionTrafficQosPolicyResponse {
	s.Body = v
	return s
}

type DeleteCenInterRegionTrafficQosQueueRequest struct {
	ClientToken          *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	QosQueueId           *string `json:"QosQueueId,omitempty" xml:"QosQueueId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteCenInterRegionTrafficQosQueueRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenInterRegionTrafficQosQueueRequest) GoString() string {
	return s.String()
}

func (s *DeleteCenInterRegionTrafficQosQueueRequest) SetClientToken(v string) *DeleteCenInterRegionTrafficQosQueueRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteCenInterRegionTrafficQosQueueRequest) SetDryRun(v bool) *DeleteCenInterRegionTrafficQosQueueRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteCenInterRegionTrafficQosQueueRequest) SetOwnerAccount(v string) *DeleteCenInterRegionTrafficQosQueueRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteCenInterRegionTrafficQosQueueRequest) SetOwnerId(v int64) *DeleteCenInterRegionTrafficQosQueueRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteCenInterRegionTrafficQosQueueRequest) SetQosQueueId(v string) *DeleteCenInterRegionTrafficQosQueueRequest {
	s.QosQueueId = &v
	return s
}

func (s *DeleteCenInterRegionTrafficQosQueueRequest) SetResourceOwnerAccount(v string) *DeleteCenInterRegionTrafficQosQueueRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteCenInterRegionTrafficQosQueueRequest) SetResourceOwnerId(v int64) *DeleteCenInterRegionTrafficQosQueueRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteCenInterRegionTrafficQosQueueResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCenInterRegionTrafficQosQueueResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenInterRegionTrafficQosQueueResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCenInterRegionTrafficQosQueueResponseBody) SetRequestId(v string) *DeleteCenInterRegionTrafficQosQueueResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCenInterRegionTrafficQosQueueResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCenInterRegionTrafficQosQueueResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCenInterRegionTrafficQosQueueResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenInterRegionTrafficQosQueueResponse) GoString() string {
	return s.String()
}

func (s *DeleteCenInterRegionTrafficQosQueueResponse) SetHeaders(v map[string]*string) *DeleteCenInterRegionTrafficQosQueueResponse {
	s.Headers = v
	return s
}

func (s *DeleteCenInterRegionTrafficQosQueueResponse) SetStatusCode(v int32) *DeleteCenInterRegionTrafficQosQueueResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCenInterRegionTrafficQosQueueResponse) SetBody(v *DeleteCenInterRegionTrafficQosQueueResponseBody) *DeleteCenInterRegionTrafficQosQueueResponse {
	s.Body = v
	return s
}

type DeleteCenRouteMapRequest struct {
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the region in which the routing policy is applied.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	CenRegionId          *string `json:"CenRegionId,omitempty" xml:"CenRegionId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the routing policy.
	RouteMapId *string `json:"RouteMapId,omitempty" xml:"RouteMapId,omitempty"`
}

func (s DeleteCenRouteMapRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenRouteMapRequest) GoString() string {
	return s.String()
}

func (s *DeleteCenRouteMapRequest) SetCenId(v string) *DeleteCenRouteMapRequest {
	s.CenId = &v
	return s
}

func (s *DeleteCenRouteMapRequest) SetCenRegionId(v string) *DeleteCenRouteMapRequest {
	s.CenRegionId = &v
	return s
}

func (s *DeleteCenRouteMapRequest) SetOwnerAccount(v string) *DeleteCenRouteMapRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteCenRouteMapRequest) SetOwnerId(v int64) *DeleteCenRouteMapRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteCenRouteMapRequest) SetResourceOwnerAccount(v string) *DeleteCenRouteMapRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteCenRouteMapRequest) SetResourceOwnerId(v int64) *DeleteCenRouteMapRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteCenRouteMapRequest) SetRouteMapId(v string) *DeleteCenRouteMapRequest {
	s.RouteMapId = &v
	return s
}

type DeleteCenRouteMapResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteCenRouteMapResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenRouteMapResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteCenRouteMapResponseBody) SetRequestId(v string) *DeleteCenRouteMapResponseBody {
	s.RequestId = &v
	return s
}

type DeleteCenRouteMapResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteCenRouteMapResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteCenRouteMapResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteCenRouteMapResponse) GoString() string {
	return s.String()
}

func (s *DeleteCenRouteMapResponse) SetHeaders(v map[string]*string) *DeleteCenRouteMapResponse {
	s.Headers = v
	return s
}

func (s *DeleteCenRouteMapResponse) SetStatusCode(v int32) *DeleteCenRouteMapResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteCenRouteMapResponse) SetBody(v *DeleteCenRouteMapResponseBody) *DeleteCenRouteMapResponse {
	s.Body = v
	return s
}

type DeleteFlowlogRequest struct {
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// Indicates whether the call is successful.
	//
	// *   **true**: yes
	// *   **false**: no
	ClientToken  *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	FlowLogId    *string `json:"FlowLogId,omitempty" xml:"FlowLogId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the request.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteFlowlogRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteFlowlogRequest) GoString() string {
	return s.String()
}

func (s *DeleteFlowlogRequest) SetCenId(v string) *DeleteFlowlogRequest {
	s.CenId = &v
	return s
}

func (s *DeleteFlowlogRequest) SetClientToken(v string) *DeleteFlowlogRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteFlowlogRequest) SetFlowLogId(v string) *DeleteFlowlogRequest {
	s.FlowLogId = &v
	return s
}

func (s *DeleteFlowlogRequest) SetOwnerAccount(v string) *DeleteFlowlogRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteFlowlogRequest) SetOwnerId(v int64) *DeleteFlowlogRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteFlowlogRequest) SetRegionId(v string) *DeleteFlowlogRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteFlowlogRequest) SetResourceOwnerAccount(v string) *DeleteFlowlogRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteFlowlogRequest) SetResourceOwnerId(v int64) *DeleteFlowlogRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteFlowlogResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteFlowlogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteFlowlogResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteFlowlogResponseBody) SetRequestId(v string) *DeleteFlowlogResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteFlowlogResponseBody) SetSuccess(v string) *DeleteFlowlogResponseBody {
	s.Success = &v
	return s
}

type DeleteFlowlogResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteFlowlogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteFlowlogResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteFlowlogResponse) GoString() string {
	return s.String()
}

func (s *DeleteFlowlogResponse) SetHeaders(v map[string]*string) *DeleteFlowlogResponse {
	s.Headers = v
	return s
}

func (s *DeleteFlowlogResponse) SetStatusCode(v int32) *DeleteFlowlogResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteFlowlogResponse) SetBody(v *DeleteFlowlogResponseBody) *DeleteFlowlogResponse {
	s.Body = v
	return s
}

type DeleteRouteServiceInCenRequest struct {
	// The ID of the region in which the network instance of the cloud service that you want to access is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	AccessRegionId *string `json:"AccessRegionId,omitempty" xml:"AccessRegionId,omitempty"`
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The IP addresses or CIDR blocks of the cloud service.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The ID of the region in which the cloud service is deployed.
	HostRegionId *string `json:"HostRegionId,omitempty" xml:"HostRegionId,omitempty"`
	// The ID of the virtual private cloud (VPC) that is associated with the cloud service.
	HostVpcId            *string `json:"HostVpcId,omitempty" xml:"HostVpcId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DeleteRouteServiceInCenRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouteServiceInCenRequest) GoString() string {
	return s.String()
}

func (s *DeleteRouteServiceInCenRequest) SetAccessRegionId(v string) *DeleteRouteServiceInCenRequest {
	s.AccessRegionId = &v
	return s
}

func (s *DeleteRouteServiceInCenRequest) SetCenId(v string) *DeleteRouteServiceInCenRequest {
	s.CenId = &v
	return s
}

func (s *DeleteRouteServiceInCenRequest) SetHost(v string) *DeleteRouteServiceInCenRequest {
	s.Host = &v
	return s
}

func (s *DeleteRouteServiceInCenRequest) SetHostRegionId(v string) *DeleteRouteServiceInCenRequest {
	s.HostRegionId = &v
	return s
}

func (s *DeleteRouteServiceInCenRequest) SetHostVpcId(v string) *DeleteRouteServiceInCenRequest {
	s.HostVpcId = &v
	return s
}

func (s *DeleteRouteServiceInCenRequest) SetOwnerAccount(v string) *DeleteRouteServiceInCenRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteRouteServiceInCenRequest) SetOwnerId(v int64) *DeleteRouteServiceInCenRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteRouteServiceInCenRequest) SetResourceOwnerAccount(v string) *DeleteRouteServiceInCenRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteRouteServiceInCenRequest) SetResourceOwnerId(v int64) *DeleteRouteServiceInCenRequest {
	s.ResourceOwnerId = &v
	return s
}

type DeleteRouteServiceInCenResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteRouteServiceInCenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouteServiceInCenResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRouteServiceInCenResponseBody) SetRequestId(v string) *DeleteRouteServiceInCenResponseBody {
	s.RequestId = &v
	return s
}

type DeleteRouteServiceInCenResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteRouteServiceInCenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteRouteServiceInCenResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRouteServiceInCenResponse) GoString() string {
	return s.String()
}

func (s *DeleteRouteServiceInCenResponse) SetHeaders(v map[string]*string) *DeleteRouteServiceInCenResponse {
	s.Headers = v
	return s
}

func (s *DeleteRouteServiceInCenResponse) SetStatusCode(v int32) *DeleteRouteServiceInCenResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRouteServiceInCenResponse) SetBody(v *DeleteRouteServiceInCenResponseBody) *DeleteRouteServiceInCenResponse {
	s.Body = v
	return s
}

type DeleteTrafficMarkingPolicyRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The client token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the DryRunOperation error code is returned.
	// *   **false** (default): performs a dry run and sends the request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the traffic marking policy.
	TrafficMarkingPolicyId *string `json:"TrafficMarkingPolicyId,omitempty" xml:"TrafficMarkingPolicyId,omitempty"`
}

func (s DeleteTrafficMarkingPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTrafficMarkingPolicyRequest) GoString() string {
	return s.String()
}

func (s *DeleteTrafficMarkingPolicyRequest) SetClientToken(v string) *DeleteTrafficMarkingPolicyRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteTrafficMarkingPolicyRequest) SetDryRun(v bool) *DeleteTrafficMarkingPolicyRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteTrafficMarkingPolicyRequest) SetOwnerAccount(v string) *DeleteTrafficMarkingPolicyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTrafficMarkingPolicyRequest) SetOwnerId(v int64) *DeleteTrafficMarkingPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTrafficMarkingPolicyRequest) SetResourceOwnerAccount(v string) *DeleteTrafficMarkingPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTrafficMarkingPolicyRequest) SetResourceOwnerId(v int64) *DeleteTrafficMarkingPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTrafficMarkingPolicyRequest) SetTrafficMarkingPolicyId(v string) *DeleteTrafficMarkingPolicyRequest {
	s.TrafficMarkingPolicyId = &v
	return s
}

type DeleteTrafficMarkingPolicyResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTrafficMarkingPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTrafficMarkingPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTrafficMarkingPolicyResponseBody) SetRequestId(v string) *DeleteTrafficMarkingPolicyResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTrafficMarkingPolicyResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTrafficMarkingPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTrafficMarkingPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTrafficMarkingPolicyResponse) GoString() string {
	return s.String()
}

func (s *DeleteTrafficMarkingPolicyResponse) SetHeaders(v map[string]*string) *DeleteTrafficMarkingPolicyResponse {
	s.Headers = v
	return s
}

func (s *DeleteTrafficMarkingPolicyResponse) SetStatusCode(v int32) *DeleteTrafficMarkingPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTrafficMarkingPolicyResponse) SetBody(v *DeleteTrafficMarkingPolicyResponseBody) *DeleteTrafficMarkingPolicyResponse {
	s.Body = v
	return s
}

type DeleteTransitRouteTableAggregationRequest struct {
	ClientToken                      *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun                           *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount                     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount             *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId                  *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TransitRouteTableAggregationCidr *string `json:"TransitRouteTableAggregationCidr,omitempty" xml:"TransitRouteTableAggregationCidr,omitempty"`
	TransitRouteTableId              *string `json:"TransitRouteTableId,omitempty" xml:"TransitRouteTableId,omitempty"`
}

func (s DeleteTransitRouteTableAggregationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouteTableAggregationRequest) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouteTableAggregationRequest) SetClientToken(v string) *DeleteTransitRouteTableAggregationRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteTransitRouteTableAggregationRequest) SetDryRun(v bool) *DeleteTransitRouteTableAggregationRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteTransitRouteTableAggregationRequest) SetOwnerAccount(v string) *DeleteTransitRouteTableAggregationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTransitRouteTableAggregationRequest) SetOwnerId(v int64) *DeleteTransitRouteTableAggregationRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTransitRouteTableAggregationRequest) SetResourceOwnerAccount(v string) *DeleteTransitRouteTableAggregationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTransitRouteTableAggregationRequest) SetResourceOwnerId(v int64) *DeleteTransitRouteTableAggregationRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTransitRouteTableAggregationRequest) SetTransitRouteTableAggregationCidr(v string) *DeleteTransitRouteTableAggregationRequest {
	s.TransitRouteTableAggregationCidr = &v
	return s
}

func (s *DeleteTransitRouteTableAggregationRequest) SetTransitRouteTableId(v string) *DeleteTransitRouteTableAggregationRequest {
	s.TransitRouteTableId = &v
	return s
}

type DeleteTransitRouteTableAggregationResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTransitRouteTableAggregationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouteTableAggregationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouteTableAggregationResponseBody) SetRequestId(v string) *DeleteTransitRouteTableAggregationResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTransitRouteTableAggregationResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTransitRouteTableAggregationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTransitRouteTableAggregationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouteTableAggregationResponse) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouteTableAggregationResponse) SetHeaders(v map[string]*string) *DeleteTransitRouteTableAggregationResponse {
	s.Headers = v
	return s
}

func (s *DeleteTransitRouteTableAggregationResponse) SetStatusCode(v int32) *DeleteTransitRouteTableAggregationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTransitRouteTableAggregationResponse) SetBody(v *DeleteTransitRouteTableAggregationResponseBody) *DeleteTransitRouteTableAggregationResponse {
	s.Body = v
	return s
}

type DeleteTransitRouterRequest struct {
	ClientToken          *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TransitRouterId      *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s DeleteTransitRouterRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterRequest) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterRequest) SetClientToken(v string) *DeleteTransitRouterRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteTransitRouterRequest) SetDryRun(v bool) *DeleteTransitRouterRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteTransitRouterRequest) SetOwnerAccount(v string) *DeleteTransitRouterRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterRequest) SetOwnerId(v int64) *DeleteTransitRouterRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTransitRouterRequest) SetResourceOwnerAccount(v string) *DeleteTransitRouterRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterRequest) SetResourceOwnerId(v int64) *DeleteTransitRouterRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTransitRouterRequest) SetTransitRouterId(v string) *DeleteTransitRouterRequest {
	s.TransitRouterId = &v
	return s
}

type DeleteTransitRouterResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTransitRouterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterResponseBody) SetRequestId(v string) *DeleteTransitRouterResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTransitRouterResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTransitRouterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTransitRouterResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterResponse) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterResponse) SetHeaders(v map[string]*string) *DeleteTransitRouterResponse {
	s.Headers = v
	return s
}

func (s *DeleteTransitRouterResponse) SetStatusCode(v int32) *DeleteTransitRouterResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTransitRouterResponse) SetBody(v *DeleteTransitRouterResponseBody) *DeleteTransitRouterResponse {
	s.Body = v
	return s
}

type DeleteTransitRouterCidrRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, ClientToken is set to the value of RequestId. The value of RequestId for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the transit router is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the CIDR block.
	//
	// You can call the [ListTransitRouterCidr](~~462772~~) operation to query the ID of a CIDR block.
	TransitRouterCidrId *string `json:"TransitRouterCidrId,omitempty" xml:"TransitRouterCidrId,omitempty"`
	// The ID of the transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s DeleteTransitRouterCidrRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterCidrRequest) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterCidrRequest) SetClientToken(v string) *DeleteTransitRouterCidrRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteTransitRouterCidrRequest) SetDryRun(v bool) *DeleteTransitRouterCidrRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteTransitRouterCidrRequest) SetOwnerAccount(v string) *DeleteTransitRouterCidrRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterCidrRequest) SetOwnerId(v int64) *DeleteTransitRouterCidrRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTransitRouterCidrRequest) SetRegionId(v string) *DeleteTransitRouterCidrRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteTransitRouterCidrRequest) SetResourceOwnerAccount(v string) *DeleteTransitRouterCidrRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterCidrRequest) SetResourceOwnerId(v int64) *DeleteTransitRouterCidrRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTransitRouterCidrRequest) SetTransitRouterCidrId(v string) *DeleteTransitRouterCidrRequest {
	s.TransitRouterCidrId = &v
	return s
}

func (s *DeleteTransitRouterCidrRequest) SetTransitRouterId(v string) *DeleteTransitRouterCidrRequest {
	s.TransitRouterId = &v
	return s
}

type DeleteTransitRouterCidrResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTransitRouterCidrResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterCidrResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterCidrResponseBody) SetRequestId(v string) *DeleteTransitRouterCidrResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTransitRouterCidrResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTransitRouterCidrResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTransitRouterCidrResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterCidrResponse) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterCidrResponse) SetHeaders(v map[string]*string) *DeleteTransitRouterCidrResponse {
	s.Headers = v
	return s
}

func (s *DeleteTransitRouterCidrResponse) SetStatusCode(v int32) *DeleteTransitRouterCidrResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTransitRouterCidrResponse) SetBody(v *DeleteTransitRouterCidrResponseBody) *DeleteTransitRouterCidrResponse {
	s.Body = v
	return s
}

type DeleteTransitRouterMulticastDomainRequest struct {
	ClientToken                    *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun                         *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount                   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount           *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId                *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TransitRouterMulticastDomainId *string `json:"TransitRouterMulticastDomainId,omitempty" xml:"TransitRouterMulticastDomainId,omitempty"`
}

func (s DeleteTransitRouterMulticastDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterMulticastDomainRequest) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterMulticastDomainRequest) SetClientToken(v string) *DeleteTransitRouterMulticastDomainRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteTransitRouterMulticastDomainRequest) SetDryRun(v bool) *DeleteTransitRouterMulticastDomainRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteTransitRouterMulticastDomainRequest) SetOwnerAccount(v string) *DeleteTransitRouterMulticastDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterMulticastDomainRequest) SetOwnerId(v int64) *DeleteTransitRouterMulticastDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTransitRouterMulticastDomainRequest) SetResourceOwnerAccount(v string) *DeleteTransitRouterMulticastDomainRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterMulticastDomainRequest) SetResourceOwnerId(v int64) *DeleteTransitRouterMulticastDomainRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTransitRouterMulticastDomainRequest) SetTransitRouterMulticastDomainId(v string) *DeleteTransitRouterMulticastDomainRequest {
	s.TransitRouterMulticastDomainId = &v
	return s
}

type DeleteTransitRouterMulticastDomainResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTransitRouterMulticastDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterMulticastDomainResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterMulticastDomainResponseBody) SetRequestId(v string) *DeleteTransitRouterMulticastDomainResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTransitRouterMulticastDomainResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTransitRouterMulticastDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTransitRouterMulticastDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterMulticastDomainResponse) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterMulticastDomainResponse) SetHeaders(v map[string]*string) *DeleteTransitRouterMulticastDomainResponse {
	s.Headers = v
	return s
}

func (s *DeleteTransitRouterMulticastDomainResponse) SetStatusCode(v int32) *DeleteTransitRouterMulticastDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTransitRouterMulticastDomainResponse) SetBody(v *DeleteTransitRouterMulticastDomainResponseBody) *DeleteTransitRouterMulticastDomainResponse {
	s.Body = v
	return s
}

type DeleteTransitRouterPeerAttachmentRequest struct {
	// The client token that you want to use to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **false** (default): performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and request syntax. If the request fails to pass the check, an error message is returned. If the request passes the dry run, the system returns the ID of the request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether to forcefully delete the inter-region connection. Valid values:
	//
	// *   **false** (default): Check for relevant resources, including associated forwarding and route learning, before deleting the inter-region connection. If such a resource exists, the VPC connection is not deleted and an error message is returned.
	// *   **true**: Delete the inter-region connection and all relevant resources.
	Force                *bool   `json:"Force,omitempty" xml:"Force,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the inter-region connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s DeleteTransitRouterPeerAttachmentRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterPeerAttachmentRequest) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterPeerAttachmentRequest) SetClientToken(v string) *DeleteTransitRouterPeerAttachmentRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteTransitRouterPeerAttachmentRequest) SetDryRun(v bool) *DeleteTransitRouterPeerAttachmentRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteTransitRouterPeerAttachmentRequest) SetForce(v bool) *DeleteTransitRouterPeerAttachmentRequest {
	s.Force = &v
	return s
}

func (s *DeleteTransitRouterPeerAttachmentRequest) SetOwnerAccount(v string) *DeleteTransitRouterPeerAttachmentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterPeerAttachmentRequest) SetOwnerId(v int64) *DeleteTransitRouterPeerAttachmentRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTransitRouterPeerAttachmentRequest) SetResourceOwnerAccount(v string) *DeleteTransitRouterPeerAttachmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterPeerAttachmentRequest) SetResourceOwnerId(v int64) *DeleteTransitRouterPeerAttachmentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTransitRouterPeerAttachmentRequest) SetTransitRouterAttachmentId(v string) *DeleteTransitRouterPeerAttachmentRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

type DeleteTransitRouterPeerAttachmentResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTransitRouterPeerAttachmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterPeerAttachmentResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterPeerAttachmentResponseBody) SetRequestId(v string) *DeleteTransitRouterPeerAttachmentResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTransitRouterPeerAttachmentResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTransitRouterPeerAttachmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTransitRouterPeerAttachmentResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterPeerAttachmentResponse) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterPeerAttachmentResponse) SetHeaders(v map[string]*string) *DeleteTransitRouterPeerAttachmentResponse {
	s.Headers = v
	return s
}

func (s *DeleteTransitRouterPeerAttachmentResponse) SetStatusCode(v int32) *DeleteTransitRouterPeerAttachmentResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTransitRouterPeerAttachmentResponse) SetBody(v *DeleteTransitRouterPeerAttachmentResponseBody) *DeleteTransitRouterPeerAttachmentResponse {
	s.Body = v
	return s
}

type DeleteTransitRouterPrefixListAssociationRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the task.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the next hop.
	//
	// > If **NextHopType** is set to **BlackHole**, you must set this parameter to **BlackHole**.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The type of the next hop. Valid values:
	//
	// *   **BlackHole**: All the CIDR blocks in the prefix list are blackhole routes. Packets destined for the CIDR blocks are dropped.
	// *   **VPC**: The next hop of the CIDR blocks in the prefix list is a VPC connection.
	// *   **VBR**: The next hop of the CIDR blocks in the prefix list is a VBR connection.
	// *   **TR**: The next hop of the CIDR blocks in the prefix list is an inter-region connection.
	NextHopType  *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the prefix list.
	PrefixListId *string `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	// The ID of the region where the transit router is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The ID of the route table of the transit router.
	TransitRouterTableId *string `json:"TransitRouterTableId,omitempty" xml:"TransitRouterTableId,omitempty"`
}

func (s DeleteTransitRouterPrefixListAssociationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterPrefixListAssociationRequest) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterPrefixListAssociationRequest) SetClientToken(v string) *DeleteTransitRouterPrefixListAssociationRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteTransitRouterPrefixListAssociationRequest) SetDryRun(v bool) *DeleteTransitRouterPrefixListAssociationRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteTransitRouterPrefixListAssociationRequest) SetNextHop(v string) *DeleteTransitRouterPrefixListAssociationRequest {
	s.NextHop = &v
	return s
}

func (s *DeleteTransitRouterPrefixListAssociationRequest) SetNextHopType(v string) *DeleteTransitRouterPrefixListAssociationRequest {
	s.NextHopType = &v
	return s
}

func (s *DeleteTransitRouterPrefixListAssociationRequest) SetOwnerAccount(v string) *DeleteTransitRouterPrefixListAssociationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterPrefixListAssociationRequest) SetOwnerId(v int64) *DeleteTransitRouterPrefixListAssociationRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTransitRouterPrefixListAssociationRequest) SetPrefixListId(v string) *DeleteTransitRouterPrefixListAssociationRequest {
	s.PrefixListId = &v
	return s
}

func (s *DeleteTransitRouterPrefixListAssociationRequest) SetRegionId(v string) *DeleteTransitRouterPrefixListAssociationRequest {
	s.RegionId = &v
	return s
}

func (s *DeleteTransitRouterPrefixListAssociationRequest) SetResourceOwnerAccount(v string) *DeleteTransitRouterPrefixListAssociationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterPrefixListAssociationRequest) SetResourceOwnerId(v int64) *DeleteTransitRouterPrefixListAssociationRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTransitRouterPrefixListAssociationRequest) SetTransitRouterId(v string) *DeleteTransitRouterPrefixListAssociationRequest {
	s.TransitRouterId = &v
	return s
}

func (s *DeleteTransitRouterPrefixListAssociationRequest) SetTransitRouterTableId(v string) *DeleteTransitRouterPrefixListAssociationRequest {
	s.TransitRouterTableId = &v
	return s
}

type DeleteTransitRouterPrefixListAssociationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTransitRouterPrefixListAssociationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterPrefixListAssociationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterPrefixListAssociationResponseBody) SetRequestId(v string) *DeleteTransitRouterPrefixListAssociationResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTransitRouterPrefixListAssociationResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTransitRouterPrefixListAssociationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTransitRouterPrefixListAssociationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterPrefixListAssociationResponse) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterPrefixListAssociationResponse) SetHeaders(v map[string]*string) *DeleteTransitRouterPrefixListAssociationResponse {
	s.Headers = v
	return s
}

func (s *DeleteTransitRouterPrefixListAssociationResponse) SetStatusCode(v int32) *DeleteTransitRouterPrefixListAssociationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTransitRouterPrefixListAssociationResponse) SetBody(v *DeleteTransitRouterPrefixListAssociationResponseBody) *DeleteTransitRouterPrefixListAssociationResponse {
	s.Body = v
	return s
}

type DeleteTransitRouterRouteEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The client token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the value of **RequestId** as the value of **ClientToken**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to check the request but not perform the operation. The system checks the permissions and the status of the specified instances. Valid values:
	//
	// *   **false** (default): sends the request. If the request passes the precheck, the route is deleted.
	// *   **true**: sends a precheck request. The route is not deleted after the request passes the precheck. If you use this value, the system checks the required parameters and the request syntax. If the check fails, the corresponding error message is returned. If the request passes the check, the system returns the ID of the request.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block.
	TransitRouterRouteEntryDestinationCidrBlock *string `json:"TransitRouterRouteEntryDestinationCidrBlock,omitempty" xml:"TransitRouterRouteEntryDestinationCidrBlock,omitempty"`
	// The ID of the route entry.
	TransitRouterRouteEntryId *string `json:"TransitRouterRouteEntryId,omitempty" xml:"TransitRouterRouteEntryId,omitempty"`
	// The ID of the network instance connection that you want to specify as the next hop.
	TransitRouterRouteEntryNextHopId *string `json:"TransitRouterRouteEntryNextHopId,omitempty" xml:"TransitRouterRouteEntryNextHopId,omitempty"`
	// The type of the next hop. Valid values:
	//
	// *   **BlackHole**: a blackhole route. You do not need to specify a next hop.
	// *   **Attachment**: a network instance connection. You must specify a network instance connection as the next hop.
	TransitRouterRouteEntryNextHopType *string `json:"TransitRouterRouteEntryNextHopType,omitempty" xml:"TransitRouterRouteEntryNextHopType,omitempty"`
	// The ID of the route table of the Enterprise Edition transit router.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
}

func (s DeleteTransitRouterRouteEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterRouteEntryRequest) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterRouteEntryRequest) SetClientToken(v string) *DeleteTransitRouterRouteEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteTransitRouterRouteEntryRequest) SetDryRun(v bool) *DeleteTransitRouterRouteEntryRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteTransitRouterRouteEntryRequest) SetOwnerAccount(v string) *DeleteTransitRouterRouteEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterRouteEntryRequest) SetOwnerId(v int64) *DeleteTransitRouterRouteEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTransitRouterRouteEntryRequest) SetResourceOwnerAccount(v string) *DeleteTransitRouterRouteEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterRouteEntryRequest) SetResourceOwnerId(v int64) *DeleteTransitRouterRouteEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTransitRouterRouteEntryRequest) SetTransitRouterRouteEntryDestinationCidrBlock(v string) *DeleteTransitRouterRouteEntryRequest {
	s.TransitRouterRouteEntryDestinationCidrBlock = &v
	return s
}

func (s *DeleteTransitRouterRouteEntryRequest) SetTransitRouterRouteEntryId(v string) *DeleteTransitRouterRouteEntryRequest {
	s.TransitRouterRouteEntryId = &v
	return s
}

func (s *DeleteTransitRouterRouteEntryRequest) SetTransitRouterRouteEntryNextHopId(v string) *DeleteTransitRouterRouteEntryRequest {
	s.TransitRouterRouteEntryNextHopId = &v
	return s
}

func (s *DeleteTransitRouterRouteEntryRequest) SetTransitRouterRouteEntryNextHopType(v string) *DeleteTransitRouterRouteEntryRequest {
	s.TransitRouterRouteEntryNextHopType = &v
	return s
}

func (s *DeleteTransitRouterRouteEntryRequest) SetTransitRouterRouteTableId(v string) *DeleteTransitRouterRouteEntryRequest {
	s.TransitRouterRouteTableId = &v
	return s
}

type DeleteTransitRouterRouteEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTransitRouterRouteEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterRouteEntryResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterRouteEntryResponseBody) SetRequestId(v string) *DeleteTransitRouterRouteEntryResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTransitRouterRouteEntryResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTransitRouterRouteEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTransitRouterRouteEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterRouteEntryResponse) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterRouteEntryResponse) SetHeaders(v map[string]*string) *DeleteTransitRouterRouteEntryResponse {
	s.Headers = v
	return s
}

func (s *DeleteTransitRouterRouteEntryResponse) SetStatusCode(v int32) *DeleteTransitRouterRouteEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTransitRouterRouteEntryResponse) SetBody(v *DeleteTransitRouterRouteEntryResponseBody) *DeleteTransitRouterRouteEntryResponse {
	s.Body = v
	return s
}

type DeleteTransitRouterRouteTableRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **false** (default): performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and the request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the custom route table.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
}

func (s DeleteTransitRouterRouteTableRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterRouteTableRequest) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterRouteTableRequest) SetClientToken(v string) *DeleteTransitRouterRouteTableRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteTransitRouterRouteTableRequest) SetDryRun(v bool) *DeleteTransitRouterRouteTableRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteTransitRouterRouteTableRequest) SetOwnerAccount(v string) *DeleteTransitRouterRouteTableRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterRouteTableRequest) SetOwnerId(v int64) *DeleteTransitRouterRouteTableRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTransitRouterRouteTableRequest) SetResourceOwnerAccount(v string) *DeleteTransitRouterRouteTableRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterRouteTableRequest) SetResourceOwnerId(v int64) *DeleteTransitRouterRouteTableRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTransitRouterRouteTableRequest) SetTransitRouterRouteTableId(v string) *DeleteTransitRouterRouteTableRequest {
	s.TransitRouterRouteTableId = &v
	return s
}

type DeleteTransitRouterRouteTableResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTransitRouterRouteTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterRouteTableResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterRouteTableResponseBody) SetRequestId(v string) *DeleteTransitRouterRouteTableResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTransitRouterRouteTableResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTransitRouterRouteTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTransitRouterRouteTableResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterRouteTableResponse) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterRouteTableResponse) SetHeaders(v map[string]*string) *DeleteTransitRouterRouteTableResponse {
	s.Headers = v
	return s
}

func (s *DeleteTransitRouterRouteTableResponse) SetStatusCode(v int32) *DeleteTransitRouterRouteTableResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTransitRouterRouteTableResponse) SetBody(v *DeleteTransitRouterRouteTableResponseBody) *DeleteTransitRouterRouteTableResponse {
	s.Body = v
	return s
}

type DeleteTransitRouterVbrAttachmentRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Default values:
	//
	// *   **false** (default): performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and the request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the system returns the ID of the request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether to forcibly delete the VBR connection. Valid values:
	//
	// *   **false** (default): checks for resources related to the VBR connection, such as associated forwarding and route learning policies. If such resources exist, the VBR connection is not deleted and an error message is returned.
	// *   **true**: deletes the VBR connection and related resources.
	Force                *bool   `json:"Force,omitempty" xml:"Force,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VBR connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s DeleteTransitRouterVbrAttachmentRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterVbrAttachmentRequest) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterVbrAttachmentRequest) SetClientToken(v string) *DeleteTransitRouterVbrAttachmentRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteTransitRouterVbrAttachmentRequest) SetDryRun(v bool) *DeleteTransitRouterVbrAttachmentRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteTransitRouterVbrAttachmentRequest) SetForce(v bool) *DeleteTransitRouterVbrAttachmentRequest {
	s.Force = &v
	return s
}

func (s *DeleteTransitRouterVbrAttachmentRequest) SetOwnerAccount(v string) *DeleteTransitRouterVbrAttachmentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterVbrAttachmentRequest) SetOwnerId(v int64) *DeleteTransitRouterVbrAttachmentRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTransitRouterVbrAttachmentRequest) SetResourceOwnerAccount(v string) *DeleteTransitRouterVbrAttachmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterVbrAttachmentRequest) SetResourceOwnerId(v int64) *DeleteTransitRouterVbrAttachmentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTransitRouterVbrAttachmentRequest) SetTransitRouterAttachmentId(v string) *DeleteTransitRouterVbrAttachmentRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

type DeleteTransitRouterVbrAttachmentResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTransitRouterVbrAttachmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterVbrAttachmentResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterVbrAttachmentResponseBody) SetRequestId(v string) *DeleteTransitRouterVbrAttachmentResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTransitRouterVbrAttachmentResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTransitRouterVbrAttachmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTransitRouterVbrAttachmentResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterVbrAttachmentResponse) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterVbrAttachmentResponse) SetHeaders(v map[string]*string) *DeleteTransitRouterVbrAttachmentResponse {
	s.Headers = v
	return s
}

func (s *DeleteTransitRouterVbrAttachmentResponse) SetStatusCode(v int32) *DeleteTransitRouterVbrAttachmentResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTransitRouterVbrAttachmentResponse) SetBody(v *DeleteTransitRouterVbrAttachmentResponseBody) *DeleteTransitRouterVbrAttachmentResponse {
	s.Body = v
	return s
}

type DeleteTransitRouterVpcAttachmentRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// > If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Default values:
	//
	// *   **false** (default): performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the system returns the ID of the request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether to forcefully delete the VPC connection. Valid values:
	//
	// *   **false** (default): checks resources such as associated forwarding correlations and route learning policies that are related to the VPC connection before it is deleted. If such a resource exists, the VPC connection is not deleted and an error message is returned.
	// *   **true**: deletes the VPC connection and all resources that are related to the VPC connection.
	Force                *bool   `json:"Force,omitempty" xml:"Force,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPC connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s DeleteTransitRouterVpcAttachmentRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterVpcAttachmentRequest) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterVpcAttachmentRequest) SetClientToken(v string) *DeleteTransitRouterVpcAttachmentRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteTransitRouterVpcAttachmentRequest) SetDryRun(v bool) *DeleteTransitRouterVpcAttachmentRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteTransitRouterVpcAttachmentRequest) SetForce(v bool) *DeleteTransitRouterVpcAttachmentRequest {
	s.Force = &v
	return s
}

func (s *DeleteTransitRouterVpcAttachmentRequest) SetOwnerAccount(v string) *DeleteTransitRouterVpcAttachmentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterVpcAttachmentRequest) SetOwnerId(v int64) *DeleteTransitRouterVpcAttachmentRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTransitRouterVpcAttachmentRequest) SetResourceOwnerAccount(v string) *DeleteTransitRouterVpcAttachmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterVpcAttachmentRequest) SetResourceOwnerId(v int64) *DeleteTransitRouterVpcAttachmentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTransitRouterVpcAttachmentRequest) SetTransitRouterAttachmentId(v string) *DeleteTransitRouterVpcAttachmentRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

type DeleteTransitRouterVpcAttachmentResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTransitRouterVpcAttachmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterVpcAttachmentResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterVpcAttachmentResponseBody) SetRequestId(v string) *DeleteTransitRouterVpcAttachmentResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTransitRouterVpcAttachmentResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTransitRouterVpcAttachmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTransitRouterVpcAttachmentResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterVpcAttachmentResponse) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterVpcAttachmentResponse) SetHeaders(v map[string]*string) *DeleteTransitRouterVpcAttachmentResponse {
	s.Headers = v
	return s
}

func (s *DeleteTransitRouterVpcAttachmentResponse) SetStatusCode(v int32) *DeleteTransitRouterVpcAttachmentResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTransitRouterVpcAttachmentResponse) SetBody(v *DeleteTransitRouterVpcAttachmentResponseBody) *DeleteTransitRouterVpcAttachmentResponse {
	s.Body = v
	return s
}

type DeleteTransitRouterVpnAttachmentRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether to forcefully delete the VPN attachment. Valid values:
	//
	// *   **false** (default): checks the related resources, such as associated forwarding correlations and route learning policies, before the VPN attachment is deleted. If such a resource exists, the VPN attachment is not deleted and an error message is returned.
	// *   **true**: deletes the VPN attachment and the related resources.
	Force                *bool   `json:"Force,omitempty" xml:"Force,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPN attachment.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s DeleteTransitRouterVpnAttachmentRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterVpnAttachmentRequest) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterVpnAttachmentRequest) SetClientToken(v string) *DeleteTransitRouterVpnAttachmentRequest {
	s.ClientToken = &v
	return s
}

func (s *DeleteTransitRouterVpnAttachmentRequest) SetDryRun(v bool) *DeleteTransitRouterVpnAttachmentRequest {
	s.DryRun = &v
	return s
}

func (s *DeleteTransitRouterVpnAttachmentRequest) SetForce(v bool) *DeleteTransitRouterVpnAttachmentRequest {
	s.Force = &v
	return s
}

func (s *DeleteTransitRouterVpnAttachmentRequest) SetOwnerAccount(v string) *DeleteTransitRouterVpnAttachmentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterVpnAttachmentRequest) SetOwnerId(v int64) *DeleteTransitRouterVpnAttachmentRequest {
	s.OwnerId = &v
	return s
}

func (s *DeleteTransitRouterVpnAttachmentRequest) SetResourceOwnerAccount(v string) *DeleteTransitRouterVpnAttachmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeleteTransitRouterVpnAttachmentRequest) SetResourceOwnerId(v int64) *DeleteTransitRouterVpnAttachmentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeleteTransitRouterVpnAttachmentRequest) SetTransitRouterAttachmentId(v string) *DeleteTransitRouterVpnAttachmentRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

type DeleteTransitRouterVpnAttachmentResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTransitRouterVpnAttachmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterVpnAttachmentResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterVpnAttachmentResponseBody) SetRequestId(v string) *DeleteTransitRouterVpnAttachmentResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTransitRouterVpnAttachmentResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTransitRouterVpnAttachmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTransitRouterVpnAttachmentResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTransitRouterVpnAttachmentResponse) GoString() string {
	return s.String()
}

func (s *DeleteTransitRouterVpnAttachmentResponse) SetHeaders(v map[string]*string) *DeleteTransitRouterVpnAttachmentResponse {
	s.Headers = v
	return s
}

func (s *DeleteTransitRouterVpnAttachmentResponse) SetStatusCode(v int32) *DeleteTransitRouterVpnAttachmentResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTransitRouterVpnAttachmentResponse) SetBody(v *DeleteTransitRouterVpnAttachmentResponseBody) *DeleteTransitRouterVpnAttachmentResponse {
	s.Body = v
	return s
}

type DeregisterTransitRouterMulticastGroupMembersRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): preforms a dry run and sends the request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The IP address of the multicast group to which the multicast members belong.
	GroupIpAddress *string `json:"GroupIpAddress,omitempty" xml:"GroupIpAddress,omitempty"`
	// The IDs of elastic network interfaces (ENIs).
	NetworkInterfaceIds []*string `json:"NetworkInterfaceIds,omitempty" xml:"NetworkInterfaceIds,omitempty" type:"Repeated"`
	OwnerAccount        *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId             *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the multicast domain that is in a different region.
	PeerTransitRouterMulticastDomains []*string `json:"PeerTransitRouterMulticastDomains,omitempty" xml:"PeerTransitRouterMulticastDomains,omitempty" type:"Repeated"`
	ResourceOwnerAccount              *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId                   *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the multicast domain to which the multicast members belong.
	TransitRouterMulticastDomainId *string `json:"TransitRouterMulticastDomainId,omitempty" xml:"TransitRouterMulticastDomainId,omitempty"`
}

func (s DeregisterTransitRouterMulticastGroupMembersRequest) String() string {
	return tea.Prettify(s)
}

func (s DeregisterTransitRouterMulticastGroupMembersRequest) GoString() string {
	return s.String()
}

func (s *DeregisterTransitRouterMulticastGroupMembersRequest) SetClientToken(v string) *DeregisterTransitRouterMulticastGroupMembersRequest {
	s.ClientToken = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupMembersRequest) SetDryRun(v bool) *DeregisterTransitRouterMulticastGroupMembersRequest {
	s.DryRun = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupMembersRequest) SetGroupIpAddress(v string) *DeregisterTransitRouterMulticastGroupMembersRequest {
	s.GroupIpAddress = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupMembersRequest) SetNetworkInterfaceIds(v []*string) *DeregisterTransitRouterMulticastGroupMembersRequest {
	s.NetworkInterfaceIds = v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupMembersRequest) SetOwnerAccount(v string) *DeregisterTransitRouterMulticastGroupMembersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupMembersRequest) SetOwnerId(v int64) *DeregisterTransitRouterMulticastGroupMembersRequest {
	s.OwnerId = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupMembersRequest) SetPeerTransitRouterMulticastDomains(v []*string) *DeregisterTransitRouterMulticastGroupMembersRequest {
	s.PeerTransitRouterMulticastDomains = v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupMembersRequest) SetResourceOwnerAccount(v string) *DeregisterTransitRouterMulticastGroupMembersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupMembersRequest) SetResourceOwnerId(v int64) *DeregisterTransitRouterMulticastGroupMembersRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupMembersRequest) SetTransitRouterMulticastDomainId(v string) *DeregisterTransitRouterMulticastGroupMembersRequest {
	s.TransitRouterMulticastDomainId = &v
	return s
}

type DeregisterTransitRouterMulticastGroupMembersResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeregisterTransitRouterMulticastGroupMembersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeregisterTransitRouterMulticastGroupMembersResponseBody) GoString() string {
	return s.String()
}

func (s *DeregisterTransitRouterMulticastGroupMembersResponseBody) SetRequestId(v string) *DeregisterTransitRouterMulticastGroupMembersResponseBody {
	s.RequestId = &v
	return s
}

type DeregisterTransitRouterMulticastGroupMembersResponse struct {
	Headers    map[string]*string                                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeregisterTransitRouterMulticastGroupMembersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeregisterTransitRouterMulticastGroupMembersResponse) String() string {
	return tea.Prettify(s)
}

func (s DeregisterTransitRouterMulticastGroupMembersResponse) GoString() string {
	return s.String()
}

func (s *DeregisterTransitRouterMulticastGroupMembersResponse) SetHeaders(v map[string]*string) *DeregisterTransitRouterMulticastGroupMembersResponse {
	s.Headers = v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupMembersResponse) SetStatusCode(v int32) *DeregisterTransitRouterMulticastGroupMembersResponse {
	s.StatusCode = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupMembersResponse) SetBody(v *DeregisterTransitRouterMulticastGroupMembersResponseBody) *DeregisterTransitRouterMulticastGroupMembersResponse {
	s.Body = v
	return s
}

type DeregisterTransitRouterMulticastGroupSourcesRequest struct {
	// The ID of the request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun      *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// Specifies whether only to check the request. Valid values:
	//
	// *   **true**: only prechecks the API request. The multicast source is not deleted. The system checks the required parameters, the request format, and the service limits. If the request fails to pass the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. After the request passes the precheck, the multicast source is deleted.
	GroupIpAddress *string `json:"GroupIpAddress,omitempty" xml:"GroupIpAddress,omitempty"`
	// Deletes a multicast source.
	NetworkInterfaceIds  []*string `json:"NetworkInterfaceIds,omitempty" xml:"NetworkInterfaceIds,omitempty" type:"Repeated"`
	OwnerAccount         *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The operation that you want to perform. Set the value to **DeregisterTransitRouterMulticastGroupSources**.
	TransitRouterMulticastDomainId *string `json:"TransitRouterMulticastDomainId,omitempty" xml:"TransitRouterMulticastDomainId,omitempty"`
}

func (s DeregisterTransitRouterMulticastGroupSourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s DeregisterTransitRouterMulticastGroupSourcesRequest) GoString() string {
	return s.String()
}

func (s *DeregisterTransitRouterMulticastGroupSourcesRequest) SetClientToken(v string) *DeregisterTransitRouterMulticastGroupSourcesRequest {
	s.ClientToken = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupSourcesRequest) SetDryRun(v bool) *DeregisterTransitRouterMulticastGroupSourcesRequest {
	s.DryRun = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupSourcesRequest) SetGroupIpAddress(v string) *DeregisterTransitRouterMulticastGroupSourcesRequest {
	s.GroupIpAddress = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupSourcesRequest) SetNetworkInterfaceIds(v []*string) *DeregisterTransitRouterMulticastGroupSourcesRequest {
	s.NetworkInterfaceIds = v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupSourcesRequest) SetOwnerAccount(v string) *DeregisterTransitRouterMulticastGroupSourcesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupSourcesRequest) SetOwnerId(v int64) *DeregisterTransitRouterMulticastGroupSourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupSourcesRequest) SetResourceOwnerAccount(v string) *DeregisterTransitRouterMulticastGroupSourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupSourcesRequest) SetResourceOwnerId(v int64) *DeregisterTransitRouterMulticastGroupSourcesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupSourcesRequest) SetTransitRouterMulticastDomainId(v string) *DeregisterTransitRouterMulticastGroupSourcesRequest {
	s.TransitRouterMulticastDomainId = &v
	return s
}

type DeregisterTransitRouterMulticastGroupSourcesResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeregisterTransitRouterMulticastGroupSourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeregisterTransitRouterMulticastGroupSourcesResponseBody) GoString() string {
	return s.String()
}

func (s *DeregisterTransitRouterMulticastGroupSourcesResponseBody) SetRequestId(v string) *DeregisterTransitRouterMulticastGroupSourcesResponseBody {
	s.RequestId = &v
	return s
}

type DeregisterTransitRouterMulticastGroupSourcesResponse struct {
	Headers    map[string]*string                                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeregisterTransitRouterMulticastGroupSourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeregisterTransitRouterMulticastGroupSourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s DeregisterTransitRouterMulticastGroupSourcesResponse) GoString() string {
	return s.String()
}

func (s *DeregisterTransitRouterMulticastGroupSourcesResponse) SetHeaders(v map[string]*string) *DeregisterTransitRouterMulticastGroupSourcesResponse {
	s.Headers = v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupSourcesResponse) SetStatusCode(v int32) *DeregisterTransitRouterMulticastGroupSourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *DeregisterTransitRouterMulticastGroupSourcesResponse) SetBody(v *DeregisterTransitRouterMulticastGroupSourcesResponseBody) *DeregisterTransitRouterMulticastGroupSourcesResponse {
	s.Body = v
	return s
}

type DescribeCenAttachedChildInstanceAttributeRequest struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the network instance that is attached to the CEN instance.
	ChildInstanceId *string `json:"ChildInstanceId,omitempty" xml:"ChildInstanceId,omitempty"`
	// The region ID of the network instance.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	ChildInstanceRegionId *string `json:"ChildInstanceRegionId,omitempty" xml:"ChildInstanceRegionId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: virtual private cloud (VPC)
	// *   **VBR**: virtual border router (VBR)
	// *   **CCN**: Cloud Connect Network (CCN) instance
	ChildInstanceType    *string `json:"ChildInstanceType,omitempty" xml:"ChildInstanceType,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeCenAttachedChildInstanceAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenAttachedChildInstanceAttributeRequest) GoString() string {
	return s.String()
}

func (s *DescribeCenAttachedChildInstanceAttributeRequest) SetCenId(v string) *DescribeCenAttachedChildInstanceAttributeRequest {
	s.CenId = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeRequest) SetChildInstanceId(v string) *DescribeCenAttachedChildInstanceAttributeRequest {
	s.ChildInstanceId = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeRequest) SetChildInstanceRegionId(v string) *DescribeCenAttachedChildInstanceAttributeRequest {
	s.ChildInstanceRegionId = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeRequest) SetChildInstanceType(v string) *DescribeCenAttachedChildInstanceAttributeRequest {
	s.ChildInstanceType = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeRequest) SetOwnerAccount(v string) *DescribeCenAttachedChildInstanceAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeRequest) SetOwnerId(v int64) *DescribeCenAttachedChildInstanceAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeRequest) SetResourceOwnerAccount(v string) *DescribeCenAttachedChildInstanceAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeRequest) SetResourceOwnerId(v int64) *DescribeCenAttachedChildInstanceAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeCenAttachedChildInstanceAttributeResponseBody struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The time when the network instance was attached to the CEN instance.
	//
	// The time follows the ISO 8601 standard in the yyyy-MM-ddThh:mmZ format. The time is displayed in UTC.
	ChildInstanceAttachTime *string `json:"ChildInstanceAttachTime,omitempty" xml:"ChildInstanceAttachTime,omitempty"`
	// The details about the network instance.
	ChildInstanceAttributes *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributes `json:"ChildInstanceAttributes,omitempty" xml:"ChildInstanceAttributes,omitempty" type:"Struct"`
	// The ID of the network instance.
	ChildInstanceId *string `json:"ChildInstanceId,omitempty" xml:"ChildInstanceId,omitempty"`
	// The name of the network instance.
	ChildInstanceName *string `json:"ChildInstanceName,omitempty" xml:"ChildInstanceName,omitempty"`
	// The ID of the Alibaba Cloud account to which the network instance belongs.
	ChildInstanceOwnerId *int64 `json:"ChildInstanceOwnerId,omitempty" xml:"ChildInstanceOwnerId,omitempty"`
	// The region ID of the network instance.
	ChildInstanceRegionId *string `json:"ChildInstanceRegionId,omitempty" xml:"ChildInstanceRegionId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: VPC
	// *   **VBR**: VBR
	// *   **CCN**: CCN instance
	ChildInstanceType *string `json:"ChildInstanceType,omitempty" xml:"ChildInstanceType,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the network instance is attached to the CEN instance.
	//
	// *   **Attaching**: The network instance is being attached to the CEN instance.
	// *   **Attached**: The network instance is attached to the CEN instance.
	// *   **Detaching**: The network instance is being detached from the CEN instance.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeCenAttachedChildInstanceAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenAttachedChildInstanceAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBody) SetCenId(v string) *DescribeCenAttachedChildInstanceAttributeResponseBody {
	s.CenId = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBody) SetChildInstanceAttachTime(v string) *DescribeCenAttachedChildInstanceAttributeResponseBody {
	s.ChildInstanceAttachTime = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBody) SetChildInstanceAttributes(v *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributes) *DescribeCenAttachedChildInstanceAttributeResponseBody {
	s.ChildInstanceAttributes = v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBody) SetChildInstanceId(v string) *DescribeCenAttachedChildInstanceAttributeResponseBody {
	s.ChildInstanceId = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBody) SetChildInstanceName(v string) *DescribeCenAttachedChildInstanceAttributeResponseBody {
	s.ChildInstanceName = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBody) SetChildInstanceOwnerId(v int64) *DescribeCenAttachedChildInstanceAttributeResponseBody {
	s.ChildInstanceOwnerId = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBody) SetChildInstanceRegionId(v string) *DescribeCenAttachedChildInstanceAttributeResponseBody {
	s.ChildInstanceRegionId = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBody) SetChildInstanceType(v string) *DescribeCenAttachedChildInstanceAttributeResponseBody {
	s.ChildInstanceType = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBody) SetRequestId(v string) *DescribeCenAttachedChildInstanceAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBody) SetStatus(v string) *DescribeCenAttachedChildInstanceAttributeResponseBody {
	s.Status = &v
	return s
}

type DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributes struct {
	// The IPv4 CIDR block of the VPC.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// The IPv6 CIDR block of the VPC.
	Ipv6CidrBlock *string `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	// The IPv6 CIDR blocks of the VPC.
	Ipv6CidrBlocks *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocks `json:"Ipv6CidrBlocks,omitempty" xml:"Ipv6CidrBlocks,omitempty" type:"Struct"`
	// The information about the VPC secondary CIDR block.
	SecondaryCidrBlocks *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesSecondaryCidrBlocks `json:"SecondaryCidrBlocks,omitempty" xml:"SecondaryCidrBlocks,omitempty" type:"Struct"`
}

func (s DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributes) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributes) GoString() string {
	return s.String()
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributes) SetCidrBlock(v string) *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributes {
	s.CidrBlock = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributes) SetIpv6CidrBlock(v string) *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributes {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributes) SetIpv6CidrBlocks(v *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocks) *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributes {
	s.Ipv6CidrBlocks = v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributes) SetSecondaryCidrBlocks(v *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesSecondaryCidrBlocks) *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributes {
	s.SecondaryCidrBlocks = v
	return s
}

type DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocks struct {
	Ipv6CidrBlock []*DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocksIpv6CidrBlock `json:"ipv6CidrBlock,omitempty" xml:"ipv6CidrBlock,omitempty" type:"Repeated"`
}

func (s DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocks) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocks) GoString() string {
	return s.String()
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocks) SetIpv6CidrBlock(v []*DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocksIpv6CidrBlock) *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocks {
	s.Ipv6CidrBlock = v
	return s
}

type DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocksIpv6CidrBlock struct {
	// The IPv6 CIDR block of the VPC.
	Ipv6CidrBlock *string `json:"Ipv6CidrBlock,omitempty" xml:"Ipv6CidrBlock,omitempty"`
	// The type of the IPv6 CIDR block of the VPC. Valid values:
	//
	// *   BGP (default): Alibaba Cloud Border Gateway Protocol (BGP) IPv6
	// *   ChinaMobile: China Mobile (single line)
	// *   ChinaUnicom: China Unicom (single line)
	// *   ChinaTelecom: China Telecom (single line)
	//
	// >  If you are on the whitelist of single-line bandwidth, you can set this parameter to ChinaTelecom, ChinaUnicom, or ChinaMobile.
	Ipv6Isp *string `json:"Ipv6Isp,omitempty" xml:"Ipv6Isp,omitempty"`
}

func (s DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocksIpv6CidrBlock) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocksIpv6CidrBlock) GoString() string {
	return s.String()
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocksIpv6CidrBlock) SetIpv6CidrBlock(v string) *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocksIpv6CidrBlock {
	s.Ipv6CidrBlock = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocksIpv6CidrBlock) SetIpv6Isp(v string) *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesIpv6CidrBlocksIpv6CidrBlock {
	s.Ipv6Isp = &v
	return s
}

type DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesSecondaryCidrBlocks struct {
	SecondaryCidrBlock []*string `json:"secondaryCidrBlock,omitempty" xml:"secondaryCidrBlock,omitempty" type:"Repeated"`
}

func (s DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesSecondaryCidrBlocks) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesSecondaryCidrBlocks) GoString() string {
	return s.String()
}

func (s *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesSecondaryCidrBlocks) SetSecondaryCidrBlock(v []*string) *DescribeCenAttachedChildInstanceAttributeResponseBodyChildInstanceAttributesSecondaryCidrBlocks {
	s.SecondaryCidrBlock = v
	return s
}

type DescribeCenAttachedChildInstanceAttributeResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCenAttachedChildInstanceAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCenAttachedChildInstanceAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenAttachedChildInstanceAttributeResponse) GoString() string {
	return s.String()
}

func (s *DescribeCenAttachedChildInstanceAttributeResponse) SetHeaders(v map[string]*string) *DescribeCenAttachedChildInstanceAttributeResponse {
	s.Headers = v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeResponse) SetStatusCode(v int32) *DescribeCenAttachedChildInstanceAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCenAttachedChildInstanceAttributeResponse) SetBody(v *DescribeCenAttachedChildInstanceAttributeResponseBody) *DescribeCenAttachedChildInstanceAttributeResponse {
	s.Body = v
	return s
}

type DescribeCenAttachedChildInstancesRequest struct {
	CenId                 *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	ChildInstanceRegionId *string `json:"ChildInstanceRegionId,omitempty" xml:"ChildInstanceRegionId,omitempty"`
	ChildInstanceType     *string `json:"ChildInstanceType,omitempty" xml:"ChildInstanceType,omitempty"`
	OwnerAccount          *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId               *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PageNumber            *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize              *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount  *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId       *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeCenAttachedChildInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenAttachedChildInstancesRequest) GoString() string {
	return s.String()
}

func (s *DescribeCenAttachedChildInstancesRequest) SetCenId(v string) *DescribeCenAttachedChildInstancesRequest {
	s.CenId = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesRequest) SetChildInstanceRegionId(v string) *DescribeCenAttachedChildInstancesRequest {
	s.ChildInstanceRegionId = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesRequest) SetChildInstanceType(v string) *DescribeCenAttachedChildInstancesRequest {
	s.ChildInstanceType = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesRequest) SetOwnerAccount(v string) *DescribeCenAttachedChildInstancesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesRequest) SetOwnerId(v int64) *DescribeCenAttachedChildInstancesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesRequest) SetPageNumber(v int32) *DescribeCenAttachedChildInstancesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesRequest) SetPageSize(v int32) *DescribeCenAttachedChildInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesRequest) SetResourceOwnerAccount(v string) *DescribeCenAttachedChildInstancesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesRequest) SetResourceOwnerId(v int64) *DescribeCenAttachedChildInstancesRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeCenAttachedChildInstancesResponseBody struct {
	ChildInstances *DescribeCenAttachedChildInstancesResponseBodyChildInstances `json:"ChildInstances,omitempty" xml:"ChildInstances,omitempty" type:"Struct"`
	PageNumber     *int32                                                       `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize       *int32                                                       `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId      *string                                                      `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount     *int32                                                       `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCenAttachedChildInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenAttachedChildInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCenAttachedChildInstancesResponseBody) SetChildInstances(v *DescribeCenAttachedChildInstancesResponseBodyChildInstances) *DescribeCenAttachedChildInstancesResponseBody {
	s.ChildInstances = v
	return s
}

func (s *DescribeCenAttachedChildInstancesResponseBody) SetPageNumber(v int32) *DescribeCenAttachedChildInstancesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesResponseBody) SetPageSize(v int32) *DescribeCenAttachedChildInstancesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesResponseBody) SetRequestId(v string) *DescribeCenAttachedChildInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesResponseBody) SetTotalCount(v int32) *DescribeCenAttachedChildInstancesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCenAttachedChildInstancesResponseBodyChildInstances struct {
	ChildInstance []*DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance `json:"ChildInstance,omitempty" xml:"ChildInstance,omitempty" type:"Repeated"`
}

func (s DescribeCenAttachedChildInstancesResponseBodyChildInstances) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenAttachedChildInstancesResponseBodyChildInstances) GoString() string {
	return s.String()
}

func (s *DescribeCenAttachedChildInstancesResponseBodyChildInstances) SetChildInstance(v []*DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance) *DescribeCenAttachedChildInstancesResponseBodyChildInstances {
	s.ChildInstance = v
	return s
}

type DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance struct {
	CenId                   *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	ChildInstanceAttachTime *string `json:"ChildInstanceAttachTime,omitempty" xml:"ChildInstanceAttachTime,omitempty"`
	ChildInstanceId         *string `json:"ChildInstanceId,omitempty" xml:"ChildInstanceId,omitempty"`
	ChildInstanceOwnerId    *int64  `json:"ChildInstanceOwnerId,omitempty" xml:"ChildInstanceOwnerId,omitempty"`
	ChildInstanceRegionId   *string `json:"ChildInstanceRegionId,omitempty" xml:"ChildInstanceRegionId,omitempty"`
	ChildInstanceType       *string `json:"ChildInstanceType,omitempty" xml:"ChildInstanceType,omitempty"`
	Status                  *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance) GoString() string {
	return s.String()
}

func (s *DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance) SetCenId(v string) *DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance {
	s.CenId = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance) SetChildInstanceAttachTime(v string) *DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance {
	s.ChildInstanceAttachTime = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance) SetChildInstanceId(v string) *DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance {
	s.ChildInstanceId = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance) SetChildInstanceOwnerId(v int64) *DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance {
	s.ChildInstanceOwnerId = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance) SetChildInstanceRegionId(v string) *DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance {
	s.ChildInstanceRegionId = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance) SetChildInstanceType(v string) *DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance {
	s.ChildInstanceType = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance) SetStatus(v string) *DescribeCenAttachedChildInstancesResponseBodyChildInstancesChildInstance {
	s.Status = &v
	return s
}

type DescribeCenAttachedChildInstancesResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCenAttachedChildInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCenAttachedChildInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenAttachedChildInstancesResponse) GoString() string {
	return s.String()
}

func (s *DescribeCenAttachedChildInstancesResponse) SetHeaders(v map[string]*string) *DescribeCenAttachedChildInstancesResponse {
	s.Headers = v
	return s
}

func (s *DescribeCenAttachedChildInstancesResponse) SetStatusCode(v int32) *DescribeCenAttachedChildInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCenAttachedChildInstancesResponse) SetBody(v *DescribeCenAttachedChildInstancesResponseBody) *DescribeCenAttachedChildInstancesResponse {
	s.Body = v
	return s
}

type DescribeCenBandwidthPackagesRequest struct {
	// The filter configurations.
	Filter []*DescribeCenBandwidthPackagesRequestFilter `json:"Filter,omitempty" xml:"Filter,omitempty" type:"Repeated"`
	// Specifies whether to include renewal data. Valid values:
	//
	// *   **true**
	// *   **false**
	IncludeReservationData *bool `json:"IncludeReservationData,omitempty" xml:"IncludeReservationData,omitempty"`
	// The logical operator between the filter conditions. Valid values:
	//
	// *   **false** (default): **AND** Bandwidth plans that meet all filter conditions are returned.
	// *   **true**: **OR** Bandwidth plans that meet one of the filter conditions are returned.
	IsOrKey      *bool   `json:"IsOrKey,omitempty" xml:"IsOrKey,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The information about the tags.
	//
	// You can specify at most 20 tags in each call.
	Tag []*DescribeCenBandwidthPackagesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeCenBandwidthPackagesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenBandwidthPackagesRequest) GoString() string {
	return s.String()
}

func (s *DescribeCenBandwidthPackagesRequest) SetFilter(v []*DescribeCenBandwidthPackagesRequestFilter) *DescribeCenBandwidthPackagesRequest {
	s.Filter = v
	return s
}

func (s *DescribeCenBandwidthPackagesRequest) SetIncludeReservationData(v bool) *DescribeCenBandwidthPackagesRequest {
	s.IncludeReservationData = &v
	return s
}

func (s *DescribeCenBandwidthPackagesRequest) SetIsOrKey(v bool) *DescribeCenBandwidthPackagesRequest {
	s.IsOrKey = &v
	return s
}

func (s *DescribeCenBandwidthPackagesRequest) SetOwnerAccount(v string) *DescribeCenBandwidthPackagesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCenBandwidthPackagesRequest) SetOwnerId(v int64) *DescribeCenBandwidthPackagesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCenBandwidthPackagesRequest) SetPageNumber(v int32) *DescribeCenBandwidthPackagesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenBandwidthPackagesRequest) SetPageSize(v int32) *DescribeCenBandwidthPackagesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCenBandwidthPackagesRequest) SetResourceGroupId(v string) *DescribeCenBandwidthPackagesRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeCenBandwidthPackagesRequest) SetResourceOwnerAccount(v string) *DescribeCenBandwidthPackagesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCenBandwidthPackagesRequest) SetResourceOwnerId(v int64) *DescribeCenBandwidthPackagesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeCenBandwidthPackagesRequest) SetTag(v []*DescribeCenBandwidthPackagesRequestTag) *DescribeCenBandwidthPackagesRequest {
	s.Tag = v
	return s
}

type DescribeCenBandwidthPackagesRequestFilter struct {
	// The filter conditions. You can use filter conditions to filter the bandwidth plans that you want to query. The following filter conditions are supported:
	//
	// *   **CenId**: CEN instance ID
	//
	// *   **Status**: bandwidth plan status. Valid values:
	//
	//     *   **Idle**: not associated with a CEN instance.
	//     *   **InUse**: associated with a CEN instance.
	//
	// *   **CenBandwidthPackageId**: bandwidth plan ID
	//
	// *   **Name**: bandwidth plan name You can specify one or more filter conditions. The maximum value of **N** is **5**.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// Specify a filter value based on the **Key** parameter. You can specify multiple filter values for each **Key**. The logical operator between filter values is **OR**. If one filter value is matched, the filter condition is matched.
	Value []*string `json:"Value,omitempty" xml:"Value,omitempty" type:"Repeated"`
}

func (s DescribeCenBandwidthPackagesRequestFilter) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenBandwidthPackagesRequestFilter) GoString() string {
	return s.String()
}

func (s *DescribeCenBandwidthPackagesRequestFilter) SetKey(v string) *DescribeCenBandwidthPackagesRequestFilter {
	s.Key = &v
	return s
}

func (s *DescribeCenBandwidthPackagesRequestFilter) SetValue(v []*string) *DescribeCenBandwidthPackagesRequestFilter {
	s.Value = v
	return s
}

type DescribeCenBandwidthPackagesRequestTag struct {
	// The tag keys.
	//
	// The tag keys cannot be an empty string. The tag keys can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag values.
	//
	// The tag values can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// The tag value of each tag key must be unique. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeCenBandwidthPackagesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenBandwidthPackagesRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeCenBandwidthPackagesRequestTag) SetKey(v string) *DescribeCenBandwidthPackagesRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeCenBandwidthPackagesRequestTag) SetValue(v string) *DescribeCenBandwidthPackagesRequestTag {
	s.Value = &v
	return s
}

type DescribeCenBandwidthPackagesResponseBody struct {
	// The details about the bandwidth plan.
	CenBandwidthPackages *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackages `json:"CenBandwidthPackages,omitempty" xml:"CenBandwidthPackages,omitempty" type:"Struct"`
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCenBandwidthPackagesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenBandwidthPackagesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCenBandwidthPackagesResponseBody) SetCenBandwidthPackages(v *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackages) *DescribeCenBandwidthPackagesResponseBody {
	s.CenBandwidthPackages = v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBody) SetPageNumber(v int32) *DescribeCenBandwidthPackagesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBody) SetPageSize(v int32) *DescribeCenBandwidthPackagesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBody) SetRequestId(v string) *DescribeCenBandwidthPackagesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBody) SetTotalCount(v int32) *DescribeCenBandwidthPackagesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackages struct {
	CenBandwidthPackage []*DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage `json:"CenBandwidthPackage,omitempty" xml:"CenBandwidthPackage,omitempty" type:"Repeated"`
}

func (s DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackages) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackages) GoString() string {
	return s.String()
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackages) SetCenBandwidthPackage(v []*DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackages {
	s.CenBandwidthPackage = v
	return s
}

type DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage struct {
	// The maximum bandwidth of the bandwidth plan.
	Bandwidth *int64 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The billing method of the bandwidth plan.
	BandwidthPackageChargeType *string `json:"BandwidthPackageChargeType,omitempty" xml:"BandwidthPackageChargeType,omitempty"`
	// The status of the bandwidth plan. Valid values:
	//
	// *   **Normal**: running as expected.
	// *   **FinancialLocked**: locked due to overdue payments.
	// *   **SecurityLocked**: locked due to security reasons
	BusinessStatus *string `json:"BusinessStatus,omitempty" xml:"BusinessStatus,omitempty"`
	// The ID of the bandwidth plan.
	CenBandwidthPackageId *string `json:"CenBandwidthPackageId,omitempty" xml:"CenBandwidthPackageId,omitempty"`
	// A list of CEN instances that are associated with the bandwidth plan.
	CenIds *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageCenIds `json:"CenIds,omitempty" xml:"CenIds,omitempty" type:"Struct"`
	// The time when the bandwidth plan was created. The time is displayed in the ISO8601 standard in the YYYY-MM-DDThh:mmZ format.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the bandwidth plan.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The time when the bandwidth plan expires.
	ExpiredTime *string `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	// The ID of the area that you want to query. Valid values:
	//
	// *   **china**: Chinese mainland.
	// *   **asia-pacific**: Asia Pacific
	// *   **europe**: Europe
	// *   **australia**: Australia
	// *   **north-america**: North America
	GeographicRegionAId *string `json:"GeographicRegionAId,omitempty" xml:"GeographicRegionAId,omitempty"`
	// The ID of the other area connected by the bandwidth plan. Valid values:
	//
	// *   **china**: Chinese mainland.
	// *   **asia-pacific**: Asia Pacific
	// *   **europe**: Europe
	// *   **australia**: Australia
	// *   **north-america**: North America
	GeographicRegionBId *string `json:"GeographicRegionBId,omitempty" xml:"GeographicRegionBId,omitempty"`
	// The ID of the connected area.
	GeographicSpanId *string `json:"GeographicSpanId,omitempty" xml:"GeographicSpanId,omitempty"`
	// Indicates whether renewal data is included.
	//
	// *   **true**
	// *   **false**
	//
	// >  This parameter returns **true** only when the **IncludeReservationData** parameter is set to **true** and a pending order exists.
	HasReservationData *string `json:"HasReservationData,omitempty" xml:"HasReservationData,omitempty"`
	// Indicates whether the bandwidth plan supports cross-border communication.
	//
	// *   **false**
	// *   **true**
	IsCrossBorder *bool `json:"IsCrossBorder,omitempty" xml:"IsCrossBorder,omitempty"`
	// The name of the bandwidth plan.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The details about the connected regions.
	OrginInterRegionBandwidthLimits *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimits `json:"OrginInterRegionBandwidthLimits,omitempty" xml:"OrginInterRegionBandwidthLimits,omitempty" type:"Struct"`
	// The expiration time of the temporary upgrade.
	ReservationActiveTime *string `json:"ReservationActiveTime,omitempty" xml:"ReservationActiveTime,omitempty"`
	// The bandwidth value to which the bandwidth plan is restored when the temporary upgrade ends.
	ReservationBandwidth *string `json:"ReservationBandwidth,omitempty" xml:"ReservationBandwidth,omitempty"`
	// The new billing method.
	ReservationInternetChargeType *string `json:"ReservationInternetChargeType,omitempty" xml:"ReservationInternetChargeType,omitempty"`
	// The renewal method.
	//
	// *   **TEMP_UPGRADE**: temporary upgrade
	// *   **UPGRADE**: upgrade
	ReservationOrderType *string `json:"ReservationOrderType,omitempty" xml:"ReservationOrderType,omitempty"`
	// The ID of the resource group to which the ACL belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Indicates whether the bandwidth plan is associated with a CEN instance.
	//
	// *   **Idle**
	// *   **InUse**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tags of the bandwidth plan.
	Tags *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
}

func (s DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) GoString() string {
	return s.String()
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetBandwidth(v int64) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.Bandwidth = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetBandwidthPackageChargeType(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.BandwidthPackageChargeType = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetBusinessStatus(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.BusinessStatus = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetCenBandwidthPackageId(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.CenBandwidthPackageId = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetCenIds(v *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageCenIds) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.CenIds = v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetCreationTime(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.CreationTime = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetDescription(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.Description = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetExpiredTime(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.ExpiredTime = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetGeographicRegionAId(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.GeographicRegionAId = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetGeographicRegionBId(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.GeographicRegionBId = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetGeographicSpanId(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.GeographicSpanId = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetHasReservationData(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.HasReservationData = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetIsCrossBorder(v bool) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.IsCrossBorder = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetName(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.Name = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetOrginInterRegionBandwidthLimits(v *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimits) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.OrginInterRegionBandwidthLimits = v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetReservationActiveTime(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.ReservationActiveTime = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetReservationBandwidth(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.ReservationBandwidth = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetReservationInternetChargeType(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.ReservationInternetChargeType = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetReservationOrderType(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.ReservationOrderType = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetResourceGroupId(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetStatus(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.Status = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage) SetTags(v *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTags) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackage {
	s.Tags = v
	return s
}

type DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageCenIds struct {
	CenId []*string `json:"CenId,omitempty" xml:"CenId,omitempty" type:"Repeated"`
}

func (s DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageCenIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageCenIds) GoString() string {
	return s.String()
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageCenIds) SetCenId(v []*string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageCenIds {
	s.CenId = v
	return s
}

type DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimits struct {
	OrginInterRegionBandwidthLimit []*DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimitsOrginInterRegionBandwidthLimit `json:"OrginInterRegionBandwidthLimit,omitempty" xml:"OrginInterRegionBandwidthLimit,omitempty" type:"Repeated"`
}

func (s DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimits) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimits) GoString() string {
	return s.String()
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimits) SetOrginInterRegionBandwidthLimit(v []*DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimitsOrginInterRegionBandwidthLimit) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimits {
	s.OrginInterRegionBandwidthLimit = v
	return s
}

type DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimitsOrginInterRegionBandwidthLimit struct {
	// The maximum bandwidth value for the inter-region connection.
	BandwidthLimit *string `json:"BandwidthLimit,omitempty" xml:"BandwidthLimit,omitempty"`
	// The connected regions.
	GeographicSpanId *string `json:"GeographicSpanId,omitempty" xml:"GeographicSpanId,omitempty"`
	// The ID of the local region.
	LocalRegionId *string `json:"LocalRegionId,omitempty" xml:"LocalRegionId,omitempty"`
	// The ID of the peer region.
	OppositeRegionId *string `json:"OppositeRegionId,omitempty" xml:"OppositeRegionId,omitempty"`
}

func (s DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimitsOrginInterRegionBandwidthLimit) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimitsOrginInterRegionBandwidthLimit) GoString() string {
	return s.String()
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimitsOrginInterRegionBandwidthLimit) SetBandwidthLimit(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimitsOrginInterRegionBandwidthLimit {
	s.BandwidthLimit = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimitsOrginInterRegionBandwidthLimit) SetGeographicSpanId(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimitsOrginInterRegionBandwidthLimit {
	s.GeographicSpanId = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimitsOrginInterRegionBandwidthLimit) SetLocalRegionId(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimitsOrginInterRegionBandwidthLimit {
	s.LocalRegionId = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimitsOrginInterRegionBandwidthLimit) SetOppositeRegionId(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageOrginInterRegionBandwidthLimitsOrginInterRegionBandwidthLimit {
	s.OppositeRegionId = &v
	return s
}

type DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTags struct {
	Tag []*DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTags) GoString() string {
	return s.String()
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTags) SetTag(v []*DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTagsTag) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTags {
	s.Tag = v
	return s
}

type DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTagsTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTagsTag) SetKey(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTagsTag) SetValue(v string) *DescribeCenBandwidthPackagesResponseBodyCenBandwidthPackagesCenBandwidthPackageTagsTag {
	s.Value = &v
	return s
}

type DescribeCenBandwidthPackagesResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCenBandwidthPackagesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCenBandwidthPackagesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenBandwidthPackagesResponse) GoString() string {
	return s.String()
}

func (s *DescribeCenBandwidthPackagesResponse) SetHeaders(v map[string]*string) *DescribeCenBandwidthPackagesResponse {
	s.Headers = v
	return s
}

func (s *DescribeCenBandwidthPackagesResponse) SetStatusCode(v int32) *DescribeCenBandwidthPackagesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCenBandwidthPackagesResponse) SetBody(v *DescribeCenBandwidthPackagesResponseBody) *DescribeCenBandwidthPackagesResponse {
	s.Body = v
	return s
}

type DescribeCenChildInstanceRouteEntriesRequest struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the network instance.
	ChildInstanceId *string `json:"ChildInstanceId,omitempty" xml:"ChildInstanceId,omitempty"`
	// The ID of the region where the network instance is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	ChildInstanceRegionId *string `json:"ChildInstanceRegionId,omitempty" xml:"ChildInstanceRegionId,omitempty"`
	// The ID of the route table of the network instance. If you do not specify a route table ID, the system queries the routes in the system route tables of the VPCs by default.
	ChildInstanceRouteTableId *string `json:"ChildInstanceRouteTableId,omitempty" xml:"ChildInstanceRouteTableId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: virtual private cloud (VPC)
	// *   **VBR**: virtual border router (VBR)
	// *   **CCN**: Cloud Connect Network (CCN) instance
	ChildInstanceType *string `json:"ChildInstanceType,omitempty" xml:"ChildInstanceType,omitempty"`
	OwnerAccount      *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId           *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Valid values: **1** to **50**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The status of the route. Valid values:
	//
	// *   **Active**: available
	// *   **Candidate**: standby
	// *   **Rejected**: rejected
	// *   **Prohibited**: prohibited
	// *   **All** (default): all routes
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeCenChildInstanceRouteEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenChildInstanceRouteEntriesRequest) GoString() string {
	return s.String()
}

func (s *DescribeCenChildInstanceRouteEntriesRequest) SetCenId(v string) *DescribeCenChildInstanceRouteEntriesRequest {
	s.CenId = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesRequest) SetChildInstanceId(v string) *DescribeCenChildInstanceRouteEntriesRequest {
	s.ChildInstanceId = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesRequest) SetChildInstanceRegionId(v string) *DescribeCenChildInstanceRouteEntriesRequest {
	s.ChildInstanceRegionId = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesRequest) SetChildInstanceRouteTableId(v string) *DescribeCenChildInstanceRouteEntriesRequest {
	s.ChildInstanceRouteTableId = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesRequest) SetChildInstanceType(v string) *DescribeCenChildInstanceRouteEntriesRequest {
	s.ChildInstanceType = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesRequest) SetOwnerAccount(v string) *DescribeCenChildInstanceRouteEntriesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesRequest) SetOwnerId(v int64) *DescribeCenChildInstanceRouteEntriesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesRequest) SetPageNumber(v int32) *DescribeCenChildInstanceRouteEntriesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesRequest) SetPageSize(v int32) *DescribeCenChildInstanceRouteEntriesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesRequest) SetResourceOwnerAccount(v string) *DescribeCenChildInstanceRouteEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesRequest) SetResourceOwnerId(v int64) *DescribeCenChildInstanceRouteEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesRequest) SetStatus(v string) *DescribeCenChildInstanceRouteEntriesRequest {
	s.Status = &v
	return s
}

type DescribeCenChildInstanceRouteEntriesResponseBody struct {
	// The information about the route.
	CenRouteEntries *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntries `json:"CenRouteEntries,omitempty" xml:"CenRouteEntries,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCenChildInstanceRouteEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenChildInstanceRouteEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBody) SetCenRouteEntries(v *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntries) *DescribeCenChildInstanceRouteEntriesResponseBody {
	s.CenRouteEntries = v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBody) SetPageNumber(v int32) *DescribeCenChildInstanceRouteEntriesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBody) SetPageSize(v int32) *DescribeCenChildInstanceRouteEntriesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBody) SetRequestId(v string) *DescribeCenChildInstanceRouteEntriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBody) SetTotalCount(v int32) *DescribeCenChildInstanceRouteEntriesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntries struct {
	CenRouteEntry []*DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry `json:"CenRouteEntry,omitempty" xml:"CenRouteEntry,omitempty" type:"Repeated"`
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntries) GoString() string {
	return s.String()
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntries) SetCenRouteEntry(v []*DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntries {
	s.CenRouteEntry = v
	return s
}

type DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry struct {
	// The AS paths of the routes.
	AsPaths *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryAsPaths `json:"AsPaths,omitempty" xml:"AsPaths,omitempty" type:"Struct"`
	// The routing policy that the routes match.
	CenRouteMapRecords *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecords `json:"CenRouteMapRecords,omitempty" xml:"CenRouteMapRecords,omitempty" type:"Struct"`
	// The community attributes of the route entries.
	Communities *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCommunities `json:"Communities,omitempty" xml:"Communities,omitempty" type:"Struct"`
	// A list of overlapping routes.
	Conflicts *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflicts `json:"Conflicts,omitempty" xml:"Conflicts,omitempty" type:"Struct"`
	// The destination CIDR block of the route.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The ID of the instance specified as the next hop in the route.
	NextHopInstanceId *string `json:"NextHopInstanceId,omitempty" xml:"NextHopInstanceId,omitempty"`
	// The region ID of the instance specified as the next hop in the route.
	NextHopRegionId *string `json:"NextHopRegionId,omitempty" xml:"NextHopRegionId,omitempty"`
	// The type of the instance specified as the next hop in the route. Valid values:
	//
	// *   **Instance**: an ECS instance
	// *   **HaVip**: an HAVIP
	// *   **RouterInterface**: a router interface
	// *   **NetworkInterface**: an ENI
	// *   **VpnGateway**: a VPN gateway
	// *   **IPv6Gateway**: an IPv6 gateway
	// *   **Ipv4Gateway**: an IPv4 gateway
	// *   **NatGateway**: a NAT gateway
	// *   **Attachment**: a network instance connection
	// *   **service**: a cloud service
	// *   **VBR**: a VBR
	// *   **CCN**: a CCN instance
	// *   **VPC**: a VPC
	// *   **local**: a system route (no next hop is specified)
	// *   **TR**: a transit router
	// *   **BlackHole**: a blackhole route (no next hop is specified)
	// *   **EcRouterInterface**: a router interface for Express Connect
	// *   **HealthCheck**: a health check
	// *   **AS**: an access gateway for CCN
	// *   **classic**: a classic network-type instance
	// *   **GatewayEndpoint**: a gateway endpoint
	// *   **CPE**: a data center connected to a VBR
	NextHopType *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	// Indicates whether the route is allowed to be advertised to or withdrawn from the CEN instance. Valid values:
	//
	// *   **true**
	// *   **false**
	OperationalMode *bool `json:"OperationalMode,omitempty" xml:"OperationalMode,omitempty"`
	// Indicates whether the route is advertised to the CEN instance. Valid values:
	//
	// *   **Published**
	// *   **NonPublished**
	PublishStatus *string `json:"PublishStatus,omitempty" xml:"PublishStatus,omitempty"`
	// The route table ID.
	RouteTableId *string `json:"RouteTableId,omitempty" xml:"RouteTableId,omitempty"`
	// The route status. Valid values:
	//
	// *   **Active**: available routes
	// *   **Candidate**: standby routes
	// *   **Rejected**: rejected routes
	// *   **Prohibited**: prohibited routes
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The route type. Valid values:
	//
	// *   **CEN**: route that is advertised through CEN
	// *   **System**: system route
	// *   **Custom**: custom route
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) GoString() string {
	return s.String()
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetAsPaths(v *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryAsPaths) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.AsPaths = v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetCenRouteMapRecords(v *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecords) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.CenRouteMapRecords = v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetCommunities(v *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCommunities) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.Communities = v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetConflicts(v *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflicts) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.Conflicts = v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetDestinationCidrBlock(v string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.DestinationCidrBlock = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetNextHopInstanceId(v string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.NextHopInstanceId = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetNextHopRegionId(v string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.NextHopRegionId = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetNextHopType(v string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.NextHopType = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetOperationalMode(v bool) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.OperationalMode = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetPublishStatus(v string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.PublishStatus = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetRouteTableId(v string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.RouteTableId = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetStatus(v string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.Status = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetType(v string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.Type = &v
	return s
}

type DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryAsPaths struct {
	AsPath []*string `json:"AsPath,omitempty" xml:"AsPath,omitempty" type:"Repeated"`
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryAsPaths) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryAsPaths) GoString() string {
	return s.String()
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryAsPaths) SetAsPath(v []*string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryAsPaths {
	s.AsPath = v
	return s
}

type DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecords struct {
	CenRouteMapRecord []*DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord `json:"CenRouteMapRecord,omitempty" xml:"CenRouteMapRecord,omitempty" type:"Repeated"`
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecords) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecords) GoString() string {
	return s.String()
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecords) SetCenRouteMapRecord(v []*DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecords {
	s.CenRouteMapRecord = v
	return s
}

type DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord struct {
	// The region ID of the routing policy.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The routing policy ID.
	RouteMapId *string `json:"RouteMapId,omitempty" xml:"RouteMapId,omitempty"`
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord) GoString() string {
	return s.String()
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord) SetRegionId(v string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord {
	s.RegionId = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord) SetRouteMapId(v string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord {
	s.RouteMapId = &v
	return s
}

type DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCommunities struct {
	Community []*string `json:"Community,omitempty" xml:"Community,omitempty" type:"Repeated"`
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCommunities) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCommunities) GoString() string {
	return s.String()
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCommunities) SetCommunity(v []*string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCommunities {
	s.Community = v
	return s
}

type DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflicts struct {
	Conflict []*DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflictsConflict `json:"Conflict,omitempty" xml:"Conflict,omitempty" type:"Repeated"`
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflicts) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflicts) GoString() string {
	return s.String()
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflicts) SetConflict(v []*DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflictsConflict) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflicts {
	s.Conflict = v
	return s
}

type DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflictsConflict struct {
	// The destination CIDR block of the overlapping route.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The ID of the peer network instance on which the overlapping routes are found.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the peer network instance on which the overlapping routes are found. Valid values:
	//
	// *   **VPC**
	// *   **VBR**
	// *   **CCN**
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The region ID of the peer network instance on which the overlapping routes are found.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The cause of the route error. Valid values:
	//
	// *   **conflict**: The routes have the same destination CIDR block.
	// *   **overflow**: The number of routes in the route table configured on another network instance has reached the upper limit.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflictsConflict) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflictsConflict) GoString() string {
	return s.String()
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflictsConflict) SetDestinationCidrBlock(v string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflictsConflict {
	s.DestinationCidrBlock = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflictsConflict) SetInstanceId(v string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflictsConflict {
	s.InstanceId = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflictsConflict) SetInstanceType(v string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflictsConflict {
	s.InstanceType = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflictsConflict) SetRegionId(v string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflictsConflict {
	s.RegionId = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflictsConflict) SetStatus(v string) *DescribeCenChildInstanceRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryConflictsConflict {
	s.Status = &v
	return s
}

type DescribeCenChildInstanceRouteEntriesResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCenChildInstanceRouteEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCenChildInstanceRouteEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenChildInstanceRouteEntriesResponse) GoString() string {
	return s.String()
}

func (s *DescribeCenChildInstanceRouteEntriesResponse) SetHeaders(v map[string]*string) *DescribeCenChildInstanceRouteEntriesResponse {
	s.Headers = v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponse) SetStatusCode(v int32) *DescribeCenChildInstanceRouteEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCenChildInstanceRouteEntriesResponse) SetBody(v *DescribeCenChildInstanceRouteEntriesResponseBody) *DescribeCenChildInstanceRouteEntriesResponse {
	s.Body = v
	return s
}

type DescribeCenGeographicSpanRemainingBandwidthRequest struct {
	// The ID of the Cloud Enterprise Network (CEN) instance to which the bandwidth plan is associated.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of one of the connected areas of the bandwidth plan. Valid values:
	//
	// *   **China**: Chinese mainland
	// *   **North-America**: North America
	// *   **Asia-Pacific**: Asia Pacific
	// *   **Europe**: Europe
	// *   **Australia**: Australia
	GeographicRegionAId *string `json:"GeographicRegionAId,omitempty" xml:"GeographicRegionAId,omitempty"`
	// The ID of the other area connected by the bandwidth plan. Valid values:
	//
	// *   **China**: Chinese mainland
	// *   **North-America**: North America
	// *   **Asia-Pacific**: Asia Pacific
	// *   **Europe**: Europe
	// *   **Australia**: Australia
	GeographicRegionBId *string `json:"GeographicRegionBId,omitempty" xml:"GeographicRegionBId,omitempty"`
	OwnerAccount        *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId             *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Valid values: **1** to **50**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeCenGeographicSpanRemainingBandwidthRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenGeographicSpanRemainingBandwidthRequest) GoString() string {
	return s.String()
}

func (s *DescribeCenGeographicSpanRemainingBandwidthRequest) SetCenId(v string) *DescribeCenGeographicSpanRemainingBandwidthRequest {
	s.CenId = &v
	return s
}

func (s *DescribeCenGeographicSpanRemainingBandwidthRequest) SetGeographicRegionAId(v string) *DescribeCenGeographicSpanRemainingBandwidthRequest {
	s.GeographicRegionAId = &v
	return s
}

func (s *DescribeCenGeographicSpanRemainingBandwidthRequest) SetGeographicRegionBId(v string) *DescribeCenGeographicSpanRemainingBandwidthRequest {
	s.GeographicRegionBId = &v
	return s
}

func (s *DescribeCenGeographicSpanRemainingBandwidthRequest) SetOwnerAccount(v string) *DescribeCenGeographicSpanRemainingBandwidthRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCenGeographicSpanRemainingBandwidthRequest) SetOwnerId(v int64) *DescribeCenGeographicSpanRemainingBandwidthRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCenGeographicSpanRemainingBandwidthRequest) SetPageNumber(v int32) *DescribeCenGeographicSpanRemainingBandwidthRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenGeographicSpanRemainingBandwidthRequest) SetPageSize(v int32) *DescribeCenGeographicSpanRemainingBandwidthRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCenGeographicSpanRemainingBandwidthRequest) SetResourceOwnerAccount(v string) *DescribeCenGeographicSpanRemainingBandwidthRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCenGeographicSpanRemainingBandwidthRequest) SetResourceOwnerId(v int64) *DescribeCenGeographicSpanRemainingBandwidthRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeCenGeographicSpanRemainingBandwidthResponseBody struct {
	// The remaining bandwidth of the bandwidth plan. Unit: Mbit/s.
	RemainingBandwidth *int64 `json:"RemainingBandwidth,omitempty" xml:"RemainingBandwidth,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeCenGeographicSpanRemainingBandwidthResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenGeographicSpanRemainingBandwidthResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCenGeographicSpanRemainingBandwidthResponseBody) SetRemainingBandwidth(v int64) *DescribeCenGeographicSpanRemainingBandwidthResponseBody {
	s.RemainingBandwidth = &v
	return s
}

func (s *DescribeCenGeographicSpanRemainingBandwidthResponseBody) SetRequestId(v string) *DescribeCenGeographicSpanRemainingBandwidthResponseBody {
	s.RequestId = &v
	return s
}

type DescribeCenGeographicSpanRemainingBandwidthResponse struct {
	Headers    map[string]*string                                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCenGeographicSpanRemainingBandwidthResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCenGeographicSpanRemainingBandwidthResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenGeographicSpanRemainingBandwidthResponse) GoString() string {
	return s.String()
}

func (s *DescribeCenGeographicSpanRemainingBandwidthResponse) SetHeaders(v map[string]*string) *DescribeCenGeographicSpanRemainingBandwidthResponse {
	s.Headers = v
	return s
}

func (s *DescribeCenGeographicSpanRemainingBandwidthResponse) SetStatusCode(v int32) *DescribeCenGeographicSpanRemainingBandwidthResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCenGeographicSpanRemainingBandwidthResponse) SetBody(v *DescribeCenGeographicSpanRemainingBandwidthResponseBody) *DescribeCenGeographicSpanRemainingBandwidthResponse {
	s.Body = v
	return s
}

type DescribeCenGeographicSpansRequest struct {
	// The ID of the areas that are connected by the CEN instance.
	//
	// > If you do not set this parameter, the system queries the information about all areas supported by CEN.
	GeographicSpanId *string `json:"GeographicSpanId,omitempty" xml:"GeographicSpanId,omitempty"`
	OwnerAccount     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Valid values: **1** to **50**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeCenGeographicSpansRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenGeographicSpansRequest) GoString() string {
	return s.String()
}

func (s *DescribeCenGeographicSpansRequest) SetGeographicSpanId(v string) *DescribeCenGeographicSpansRequest {
	s.GeographicSpanId = &v
	return s
}

func (s *DescribeCenGeographicSpansRequest) SetOwnerAccount(v string) *DescribeCenGeographicSpansRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCenGeographicSpansRequest) SetOwnerId(v int64) *DescribeCenGeographicSpansRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCenGeographicSpansRequest) SetPageNumber(v int32) *DescribeCenGeographicSpansRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenGeographicSpansRequest) SetPageSize(v int32) *DescribeCenGeographicSpansRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCenGeographicSpansRequest) SetResourceOwnerAccount(v string) *DescribeCenGeographicSpansRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCenGeographicSpansRequest) SetResourceOwnerId(v int64) *DescribeCenGeographicSpansRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeCenGeographicSpansResponseBody struct {
	// A list of areas.
	GeographicSpanModels *DescribeCenGeographicSpansResponseBodyGeographicSpanModels `json:"GeographicSpanModels,omitempty" xml:"GeographicSpanModels,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCenGeographicSpansResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenGeographicSpansResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCenGeographicSpansResponseBody) SetGeographicSpanModels(v *DescribeCenGeographicSpansResponseBodyGeographicSpanModels) *DescribeCenGeographicSpansResponseBody {
	s.GeographicSpanModels = v
	return s
}

func (s *DescribeCenGeographicSpansResponseBody) SetPageNumber(v int32) *DescribeCenGeographicSpansResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenGeographicSpansResponseBody) SetPageSize(v int32) *DescribeCenGeographicSpansResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCenGeographicSpansResponseBody) SetRequestId(v string) *DescribeCenGeographicSpansResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCenGeographicSpansResponseBody) SetTotalCount(v int32) *DescribeCenGeographicSpansResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCenGeographicSpansResponseBodyGeographicSpanModels struct {
	GeographicSpanModel []*DescribeCenGeographicSpansResponseBodyGeographicSpanModelsGeographicSpanModel `json:"GeographicSpanModel,omitempty" xml:"GeographicSpanModel,omitempty" type:"Repeated"`
}

func (s DescribeCenGeographicSpansResponseBodyGeographicSpanModels) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenGeographicSpansResponseBodyGeographicSpanModels) GoString() string {
	return s.String()
}

func (s *DescribeCenGeographicSpansResponseBodyGeographicSpanModels) SetGeographicSpanModel(v []*DescribeCenGeographicSpansResponseBodyGeographicSpanModelsGeographicSpanModel) *DescribeCenGeographicSpansResponseBodyGeographicSpanModels {
	s.GeographicSpanModel = v
	return s
}

type DescribeCenGeographicSpansResponseBodyGeographicSpanModelsGeographicSpanModel struct {
	// The ID of the pair of connected areas.
	GeographicSpanId *string `json:"GeographicSpanId,omitempty" xml:"GeographicSpanId,omitempty"`
	// The ID of the local area.
	LocalGeoRegionId *string `json:"LocalGeoRegionId,omitempty" xml:"LocalGeoRegionId,omitempty"`
	// The ID of the peer area.
	OppositeGeoRegionId *string `json:"OppositeGeoRegionId,omitempty" xml:"OppositeGeoRegionId,omitempty"`
}

func (s DescribeCenGeographicSpansResponseBodyGeographicSpanModelsGeographicSpanModel) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenGeographicSpansResponseBodyGeographicSpanModelsGeographicSpanModel) GoString() string {
	return s.String()
}

func (s *DescribeCenGeographicSpansResponseBodyGeographicSpanModelsGeographicSpanModel) SetGeographicSpanId(v string) *DescribeCenGeographicSpansResponseBodyGeographicSpanModelsGeographicSpanModel {
	s.GeographicSpanId = &v
	return s
}

func (s *DescribeCenGeographicSpansResponseBodyGeographicSpanModelsGeographicSpanModel) SetLocalGeoRegionId(v string) *DescribeCenGeographicSpansResponseBodyGeographicSpanModelsGeographicSpanModel {
	s.LocalGeoRegionId = &v
	return s
}

func (s *DescribeCenGeographicSpansResponseBodyGeographicSpanModelsGeographicSpanModel) SetOppositeGeoRegionId(v string) *DescribeCenGeographicSpansResponseBodyGeographicSpanModelsGeographicSpanModel {
	s.OppositeGeoRegionId = &v
	return s
}

type DescribeCenGeographicSpansResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCenGeographicSpansResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCenGeographicSpansResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenGeographicSpansResponse) GoString() string {
	return s.String()
}

func (s *DescribeCenGeographicSpansResponse) SetHeaders(v map[string]*string) *DescribeCenGeographicSpansResponse {
	s.Headers = v
	return s
}

func (s *DescribeCenGeographicSpansResponse) SetStatusCode(v int32) *DescribeCenGeographicSpansResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCenGeographicSpansResponse) SetBody(v *DescribeCenGeographicSpansResponseBody) *DescribeCenGeographicSpansResponse {
	s.Body = v
	return s
}

type DescribeCenInterRegionBandwidthLimitsRequest struct {
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId        *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Valid values: **1** to **50**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The region ID of the transit router.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	TrRegionId *string `json:"TrRegionId,omitempty" xml:"TrRegionId,omitempty"`
}

func (s DescribeCenInterRegionBandwidthLimitsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenInterRegionBandwidthLimitsRequest) GoString() string {
	return s.String()
}

func (s *DescribeCenInterRegionBandwidthLimitsRequest) SetCenId(v string) *DescribeCenInterRegionBandwidthLimitsRequest {
	s.CenId = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsRequest) SetOwnerAccount(v string) *DescribeCenInterRegionBandwidthLimitsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsRequest) SetOwnerId(v int64) *DescribeCenInterRegionBandwidthLimitsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsRequest) SetPageNumber(v int32) *DescribeCenInterRegionBandwidthLimitsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsRequest) SetPageSize(v int32) *DescribeCenInterRegionBandwidthLimitsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsRequest) SetResourceOwnerAccount(v string) *DescribeCenInterRegionBandwidthLimitsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsRequest) SetResourceOwnerId(v int64) *DescribeCenInterRegionBandwidthLimitsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsRequest) SetTrRegionId(v string) *DescribeCenInterRegionBandwidthLimitsRequest {
	s.TrRegionId = &v
	return s
}

type DescribeCenInterRegionBandwidthLimitsResponseBody struct {
	// A list of inter-region connections.
	CenInterRegionBandwidthLimits *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimits `json:"CenInterRegionBandwidthLimits,omitempty" xml:"CenInterRegionBandwidthLimits,omitempty" type:"Struct"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCenInterRegionBandwidthLimitsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenInterRegionBandwidthLimitsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCenInterRegionBandwidthLimitsResponseBody) SetCenInterRegionBandwidthLimits(v *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimits) *DescribeCenInterRegionBandwidthLimitsResponseBody {
	s.CenInterRegionBandwidthLimits = v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsResponseBody) SetPageNumber(v int32) *DescribeCenInterRegionBandwidthLimitsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsResponseBody) SetPageSize(v int32) *DescribeCenInterRegionBandwidthLimitsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsResponseBody) SetRequestId(v string) *DescribeCenInterRegionBandwidthLimitsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsResponseBody) SetTotalCount(v int32) *DescribeCenInterRegionBandwidthLimitsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimits struct {
	CenInterRegionBandwidthLimit []*DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit `json:"CenInterRegionBandwidthLimit,omitempty" xml:"CenInterRegionBandwidthLimit,omitempty" type:"Repeated"`
}

func (s DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimits) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimits) GoString() string {
	return s.String()
}

func (s *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimits) SetCenInterRegionBandwidthLimit(v []*DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit) *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimits {
	s.CenInterRegionBandwidthLimit = v
	return s
}

type DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit struct {
	// The maximum bandwidth of the inter-region connection. Unit: Mbit/s.
	BandwidthLimit *int64 `json:"BandwidthLimit,omitempty" xml:"BandwidthLimit,omitempty"`
	// The ID of the bandwidth plan.
	BandwidthPackageId *string `json:"BandwidthPackageId,omitempty" xml:"BandwidthPackageId,omitempty"`
	// The CEN instance ID.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The IDs of the local and peer regions.
	GeographicSpanId *string `json:"GeographicSpanId,omitempty" xml:"GeographicSpanId,omitempty"`
	// The ID of the local region.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	LocalRegionId *string `json:"LocalRegionId,omitempty" xml:"LocalRegionId,omitempty"`
	// The ID of the peer region.
	OppositeRegionId *string `json:"OppositeRegionId,omitempty" xml:"OppositeRegionId,omitempty"`
	// The bandwidth status of the inter-region connection. Valid values:
	//
	// *   **Active**
	// *   **Modifying**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit) GoString() string {
	return s.String()
}

func (s *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit) SetBandwidthLimit(v int64) *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit {
	s.BandwidthLimit = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit) SetBandwidthPackageId(v string) *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit {
	s.BandwidthPackageId = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit) SetCenId(v string) *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit {
	s.CenId = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit) SetGeographicSpanId(v string) *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit {
	s.GeographicSpanId = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit) SetLocalRegionId(v string) *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit {
	s.LocalRegionId = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit) SetOppositeRegionId(v string) *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit {
	s.OppositeRegionId = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit) SetStatus(v string) *DescribeCenInterRegionBandwidthLimitsResponseBodyCenInterRegionBandwidthLimitsCenInterRegionBandwidthLimit {
	s.Status = &v
	return s
}

type DescribeCenInterRegionBandwidthLimitsResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCenInterRegionBandwidthLimitsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCenInterRegionBandwidthLimitsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenInterRegionBandwidthLimitsResponse) GoString() string {
	return s.String()
}

func (s *DescribeCenInterRegionBandwidthLimitsResponse) SetHeaders(v map[string]*string) *DescribeCenInterRegionBandwidthLimitsResponse {
	s.Headers = v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsResponse) SetStatusCode(v int32) *DescribeCenInterRegionBandwidthLimitsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCenInterRegionBandwidthLimitsResponse) SetBody(v *DescribeCenInterRegionBandwidthLimitsResponseBody) *DescribeCenInterRegionBandwidthLimitsResponse {
	s.Body = v
	return s
}

type DescribeCenPrivateZoneRoutesRequest struct {
	// The ID of the region where PrivateZone is accessed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	AccessRegionId *string `json:"AccessRegionId,omitempty" xml:"AccessRegionId,omitempty"`
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the region where PrivateZone is deployed.
	HostRegionId *string `json:"HostRegionId,omitempty" xml:"HostRegionId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Valid values: **1** to **50**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeCenPrivateZoneRoutesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenPrivateZoneRoutesRequest) GoString() string {
	return s.String()
}

func (s *DescribeCenPrivateZoneRoutesRequest) SetAccessRegionId(v string) *DescribeCenPrivateZoneRoutesRequest {
	s.AccessRegionId = &v
	return s
}

func (s *DescribeCenPrivateZoneRoutesRequest) SetCenId(v string) *DescribeCenPrivateZoneRoutesRequest {
	s.CenId = &v
	return s
}

func (s *DescribeCenPrivateZoneRoutesRequest) SetHostRegionId(v string) *DescribeCenPrivateZoneRoutesRequest {
	s.HostRegionId = &v
	return s
}

func (s *DescribeCenPrivateZoneRoutesRequest) SetPageNumber(v int32) *DescribeCenPrivateZoneRoutesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenPrivateZoneRoutesRequest) SetPageSize(v int32) *DescribeCenPrivateZoneRoutesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCenPrivateZoneRoutesRequest) SetResourceOwnerAccount(v string) *DescribeCenPrivateZoneRoutesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCenPrivateZoneRoutesRequest) SetResourceOwnerId(v int64) *DescribeCenPrivateZoneRoutesRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeCenPrivateZoneRoutesResponseBody struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The IP address of the DNS server used by PrivateZone.
	PrivateZoneDnsServers *string `json:"PrivateZoneDnsServers,omitempty" xml:"PrivateZoneDnsServers,omitempty"`
	// The detailed configuration of PrivateZone.
	PrivateZoneInfos *DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfos `json:"PrivateZoneInfos,omitempty" xml:"PrivateZoneInfos,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCenPrivateZoneRoutesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenPrivateZoneRoutesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCenPrivateZoneRoutesResponseBody) SetCenId(v string) *DescribeCenPrivateZoneRoutesResponseBody {
	s.CenId = &v
	return s
}

func (s *DescribeCenPrivateZoneRoutesResponseBody) SetPageNumber(v int32) *DescribeCenPrivateZoneRoutesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenPrivateZoneRoutesResponseBody) SetPageSize(v int32) *DescribeCenPrivateZoneRoutesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCenPrivateZoneRoutesResponseBody) SetPrivateZoneDnsServers(v string) *DescribeCenPrivateZoneRoutesResponseBody {
	s.PrivateZoneDnsServers = &v
	return s
}

func (s *DescribeCenPrivateZoneRoutesResponseBody) SetPrivateZoneInfos(v *DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfos) *DescribeCenPrivateZoneRoutesResponseBody {
	s.PrivateZoneInfos = v
	return s
}

func (s *DescribeCenPrivateZoneRoutesResponseBody) SetRequestId(v string) *DescribeCenPrivateZoneRoutesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCenPrivateZoneRoutesResponseBody) SetTotalCount(v int32) *DescribeCenPrivateZoneRoutesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfos struct {
	PrivateZoneInfo []*DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfosPrivateZoneInfo `json:"PrivateZoneInfo,omitempty" xml:"PrivateZoneInfo,omitempty" type:"Repeated"`
}

func (s DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfos) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfos) GoString() string {
	return s.String()
}

func (s *DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfos) SetPrivateZoneInfo(v []*DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfosPrivateZoneInfo) *DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfos {
	s.PrivateZoneInfo = v
	return s
}

type DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfosPrivateZoneInfo struct {
	// The ID of the region where PrivateZone is accessed.
	AccessRegionId *string `json:"AccessRegionId,omitempty" xml:"AccessRegionId,omitempty"`
	// The ID of the region where PrivateZone is deployed.
	HostRegionId *string `json:"HostRegionId,omitempty" xml:"HostRegionId,omitempty"`
	// The ID of the VPC that is associated with PrivateZone.
	HostVpcId *string `json:"HostVpcId,omitempty" xml:"HostVpcId,omitempty"`
	// The status of PrivateZone. Valid values:
	//
	// *   **Creating**: being created
	// *   **Active**: available
	// *   **Deleting**: being deleted
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfosPrivateZoneInfo) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfosPrivateZoneInfo) GoString() string {
	return s.String()
}

func (s *DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfosPrivateZoneInfo) SetAccessRegionId(v string) *DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfosPrivateZoneInfo {
	s.AccessRegionId = &v
	return s
}

func (s *DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfosPrivateZoneInfo) SetHostRegionId(v string) *DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfosPrivateZoneInfo {
	s.HostRegionId = &v
	return s
}

func (s *DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfosPrivateZoneInfo) SetHostVpcId(v string) *DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfosPrivateZoneInfo {
	s.HostVpcId = &v
	return s
}

func (s *DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfosPrivateZoneInfo) SetStatus(v string) *DescribeCenPrivateZoneRoutesResponseBodyPrivateZoneInfosPrivateZoneInfo {
	s.Status = &v
	return s
}

type DescribeCenPrivateZoneRoutesResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCenPrivateZoneRoutesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCenPrivateZoneRoutesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenPrivateZoneRoutesResponse) GoString() string {
	return s.String()
}

func (s *DescribeCenPrivateZoneRoutesResponse) SetHeaders(v map[string]*string) *DescribeCenPrivateZoneRoutesResponse {
	s.Headers = v
	return s
}

func (s *DescribeCenPrivateZoneRoutesResponse) SetStatusCode(v int32) *DescribeCenPrivateZoneRoutesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCenPrivateZoneRoutesResponse) SetBody(v *DescribeCenPrivateZoneRoutesResponseBody) *DescribeCenPrivateZoneRoutesResponse {
	s.Body = v
	return s
}

type DescribeCenRegionDomainRouteEntriesRequest struct {
	// The status of the routes that you want to query. Valid values:
	//
	// *   **Active** (default value): active routes
	// *   **Candidate**: standby routes
	// *   **Rejected**: rejected routes
	// *   **Prohibited**: prohibited routes
	// *   **All**: all routes
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the CEN instance.
	CenRegionId  *string `json:"CenRegionId,omitempty" xml:"CenRegionId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the route map is applied.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// Whether the route can be advertised to other regions. Valid values:
	//
	// - **Active**: The route can be advertised to other regions.
	// - **Prohibited**: The route cannot be advertised to other regions.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the region that you want to query.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeCenRegionDomainRouteEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRegionDomainRouteEntriesRequest) GoString() string {
	return s.String()
}

func (s *DescribeCenRegionDomainRouteEntriesRequest) SetCenId(v string) *DescribeCenRegionDomainRouteEntriesRequest {
	s.CenId = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesRequest) SetCenRegionId(v string) *DescribeCenRegionDomainRouteEntriesRequest {
	s.CenRegionId = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesRequest) SetOwnerAccount(v string) *DescribeCenRegionDomainRouteEntriesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesRequest) SetOwnerId(v int64) *DescribeCenRegionDomainRouteEntriesRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesRequest) SetPageNumber(v int32) *DescribeCenRegionDomainRouteEntriesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesRequest) SetPageSize(v int32) *DescribeCenRegionDomainRouteEntriesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesRequest) SetResourceOwnerAccount(v string) *DescribeCenRegionDomainRouteEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesRequest) SetResourceOwnerId(v int64) *DescribeCenRegionDomainRouteEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesRequest) SetStatus(v string) *DescribeCenRegionDomainRouteEntriesRequest {
	s.Status = &v
	return s
}

type DescribeCenRegionDomainRouteEntriesResponseBody struct {
	// The status of the route. Valid values:
	//
	// - **Active**: The route is active.
	// - **Candidate**: The route is a standby route.
	// - **Rejected**: The route is rejected.
	// - **Prohibited**: The route is prohibited.
	CenRouteEntries *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntries `json:"CenRouteEntries,omitempty" xml:"CenRouteEntries,omitempty" type:"Struct"`
	// The route maps that the routes match in the outbound direction.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the route map.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of the page to return. Default value: **1**.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the instance specified as the next hop in the route.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCenRegionDomainRouteEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRegionDomainRouteEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBody) SetCenRouteEntries(v *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntries) *DescribeCenRegionDomainRouteEntriesResponseBody {
	s.CenRouteEntries = v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBody) SetPageNumber(v int32) *DescribeCenRegionDomainRouteEntriesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBody) SetPageSize(v int32) *DescribeCenRegionDomainRouteEntriesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBody) SetRequestId(v string) *DescribeCenRegionDomainRouteEntriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBody) SetTotalCount(v int32) *DescribeCenRegionDomainRouteEntriesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntries struct {
	CenRouteEntry []*DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry `json:"CenRouteEntry,omitempty" xml:"CenRouteEntry,omitempty" type:"Repeated"`
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntries) GoString() string {
	return s.String()
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntries) SetCenRouteEntry(v []*DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntries {
	s.CenRouteEntry = v
	return s
}

type DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry struct {
	AsPaths *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryAsPaths `json:"AsPaths,omitempty" xml:"AsPaths,omitempty" type:"Struct"`
	// Queries the routes of a Cloud Enterprise Network (CEN) instance in a specified region.
	CenOutRouteMapRecords *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecords `json:"CenOutRouteMapRecords,omitempty" xml:"CenOutRouteMapRecords,omitempty" type:"Struct"`
	// The number of entries returned per page.
	CenRouteMapRecords *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecords `json:"CenRouteMapRecords,omitempty" xml:"CenRouteMapRecords,omitempty" type:"Struct"`
	Communities        *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCommunities        `json:"Communities,omitempty" xml:"Communities,omitempty" type:"Struct"`
	// The number of entries to return on each page. Default value: **10**. Valid values: **1** to **50**.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The priority of the route.
	//
	// > A smaller value indicates a higher priority.
	NextHopInstanceId *string `json:"NextHopInstanceId,omitempty" xml:"NextHopInstanceId,omitempty"`
	// The type of the network instance specified as the next hop in the route.
	//
	// - **VPC**
	// - **VBR**
	// - **CCN**
	// - **local_service**: system route. No next hop is specified.
	NextHopRegionId *string `json:"NextHopRegionId,omitempty" xml:"NextHopRegionId,omitempty"`
	// The type of the route. Valid values:
	//
	// - **CEN**: route that is advertised through CEN
	// - **Custom**: custom route
	// - **System**: system route
	NextHopType *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	// The page number of the returned page.
	Preference *int32 `json:"Preference,omitempty" xml:"Preference,omitempty"`
	// The AS paths of the routes.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the route map.
	ToOtherRegionStatus *string `json:"ToOtherRegionStatus,omitempty" xml:"ToOtherRegionStatus,omitempty"`
	// The destination CIDR block of the route.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) GoString() string {
	return s.String()
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetAsPaths(v *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryAsPaths) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.AsPaths = v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetCenOutRouteMapRecords(v *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecords) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.CenOutRouteMapRecords = v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetCenRouteMapRecords(v *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecords) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.CenRouteMapRecords = v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetCommunities(v *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCommunities) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.Communities = v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetDestinationCidrBlock(v string) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.DestinationCidrBlock = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetNextHopInstanceId(v string) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.NextHopInstanceId = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetNextHopRegionId(v string) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.NextHopRegionId = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetNextHopType(v string) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.NextHopType = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetPreference(v int32) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.Preference = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetStatus(v string) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.Status = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetToOtherRegionStatus(v string) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.ToOtherRegionStatus = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry) SetType(v string) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntry {
	s.Type = &v
	return s
}

type DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryAsPaths struct {
	AsPath []*string `json:"AsPath,omitempty" xml:"AsPath,omitempty" type:"Repeated"`
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryAsPaths) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryAsPaths) GoString() string {
	return s.String()
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryAsPaths) SetAsPath(v []*string) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryAsPaths {
	s.AsPath = v
	return s
}

type DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecords struct {
	CenOutRouteMapRecord []*DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecordsCenOutRouteMapRecord `json:"CenOutRouteMapRecord,omitempty" xml:"CenOutRouteMapRecord,omitempty" type:"Repeated"`
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecords) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecords) GoString() string {
	return s.String()
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecords) SetCenOutRouteMapRecord(v []*DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecordsCenOutRouteMapRecord) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecords {
	s.CenOutRouteMapRecord = v
	return s
}

type DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecordsCenOutRouteMapRecord struct {
	// 312501
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// DescribeCenRegionDomainRouteEntries
	RouteMapId *string `json:"RouteMapId,omitempty" xml:"RouteMapId,omitempty"`
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecordsCenOutRouteMapRecord) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecordsCenOutRouteMapRecord) GoString() string {
	return s.String()
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecordsCenOutRouteMapRecord) SetRegionId(v string) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecordsCenOutRouteMapRecord {
	s.RegionId = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecordsCenOutRouteMapRecord) SetRouteMapId(v string) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenOutRouteMapRecordsCenOutRouteMapRecord {
	s.RouteMapId = &v
	return s
}

type DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecords struct {
	CenRouteMapRecord []*DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord `json:"CenRouteMapRecord,omitempty" xml:"CenRouteMapRecord,omitempty" type:"Repeated"`
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecords) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecords) GoString() string {
	return s.String()
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecords) SetCenRouteMapRecord(v []*DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecords {
	s.CenRouteMapRecord = v
	return s
}

type DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord struct {
	// The ID of the request.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The ID of the region where the network instance specified as the next hop in the route belongs.
	RouteMapId *string `json:"RouteMapId,omitempty" xml:"RouteMapId,omitempty"`
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord) GoString() string {
	return s.String()
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord) SetRegionId(v string) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord {
	s.RegionId = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord) SetRouteMapId(v string) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCenRouteMapRecordsCenRouteMapRecord {
	s.RouteMapId = &v
	return s
}

type DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCommunities struct {
	Community []*string `json:"Community,omitempty" xml:"Community,omitempty" type:"Repeated"`
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCommunities) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCommunities) GoString() string {
	return s.String()
}

func (s *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCommunities) SetCommunity(v []*string) *DescribeCenRegionDomainRouteEntriesResponseBodyCenRouteEntriesCenRouteEntryCommunities {
	s.Community = v
	return s
}

type DescribeCenRegionDomainRouteEntriesResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCenRegionDomainRouteEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCenRegionDomainRouteEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRegionDomainRouteEntriesResponse) GoString() string {
	return s.String()
}

func (s *DescribeCenRegionDomainRouteEntriesResponse) SetHeaders(v map[string]*string) *DescribeCenRegionDomainRouteEntriesResponse {
	s.Headers = v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponse) SetStatusCode(v int32) *DescribeCenRegionDomainRouteEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCenRegionDomainRouteEntriesResponse) SetBody(v *DescribeCenRegionDomainRouteEntriesResponseBody) *DescribeCenRegionDomainRouteEntriesResponse {
	s.Body = v
	return s
}

type DescribeCenRouteMapsRequest struct {
	// The number of the page to return. Default value: **1**.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The match method that is used to match routes based on the AS path.
	//
	// *   **Include**: fuzzy match. A route is a match if the AS path of the route overlaps with the AS path specified in the match condition.
	// *   **Complete**: exact match. A route is a match only if the AS path of the route is the same as the AS path specified in the match condition.
	CenRegionId  *string `json:"CenRegionId,omitempty" xml:"CenRegionId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The route table ID of the transit router with which the routing policy is associated.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The IDs of the destination network instances to which the routes belong.
	//
	// >  The destination network instance IDs are valid only when the routing policy is applied to scenarios where routes are advertised from the gateway in the current region to network instances in the current region.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Indicates whether the destination network instance IDs are excluded.
	//
	// *   **false** (default): A route is a match if its destination network instance ID is in the list specified by **DestinationInstanceIds.N**.
	// *   **true**: A route is a match if its destination network instance ID is not in the list specified by **DestinationInstanceIds.N**.
	RouteMapId *string `json:"RouteMapId,omitempty" xml:"RouteMapId,omitempty"`
	// The priority of the routing policy that you want to associate with the current one.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
	// The match method that is used to match routes based on the community.
	//
	// *   **Include**: fuzzy match. A route is a match if the community of the route overlaps with the community specified in the match condition.
	// *   **Complete**: exact match. A route is a match only if the community of the route is the same as the community specified in the match condition.
	TransmitDirection *string `json:"TransmitDirection,omitempty" xml:"TransmitDirection,omitempty"`
}

func (s DescribeCenRouteMapsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsRequest) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsRequest) SetCenId(v string) *DescribeCenRouteMapsRequest {
	s.CenId = &v
	return s
}

func (s *DescribeCenRouteMapsRequest) SetCenRegionId(v string) *DescribeCenRouteMapsRequest {
	s.CenRegionId = &v
	return s
}

func (s *DescribeCenRouteMapsRequest) SetOwnerAccount(v string) *DescribeCenRouteMapsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCenRouteMapsRequest) SetOwnerId(v int64) *DescribeCenRouteMapsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCenRouteMapsRequest) SetPageNumber(v int32) *DescribeCenRouteMapsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenRouteMapsRequest) SetPageSize(v int32) *DescribeCenRouteMapsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCenRouteMapsRequest) SetResourceOwnerAccount(v string) *DescribeCenRouteMapsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCenRouteMapsRequest) SetResourceOwnerId(v int64) *DescribeCenRouteMapsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeCenRouteMapsRequest) SetRouteMapId(v string) *DescribeCenRouteMapsRequest {
	s.RouteMapId = &v
	return s
}

func (s *DescribeCenRouteMapsRequest) SetTransitRouterRouteTableId(v string) *DescribeCenRouteMapsRequest {
	s.TransitRouterRouteTableId = &v
	return s
}

func (s *DescribeCenRouteMapsRequest) SetTransmitDirection(v string) *DescribeCenRouteMapsRequest {
	s.TransmitDirection = &v
	return s
}

type DescribeCenRouteMapsResponseBody struct {
	// The community set on which actions are performed.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The IDs of the destination route tables to which the routes belong. You can enter at most 32 route table IDs.
	//
	// >  The destination route table IDs are valid only when the routing policy is applied to scenarios where routes are advertised from the gateway in the current region to route tables in the current region.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of entries to return on each page. Default value: **10**.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the CEN instance.
	RouteMaps *DescribeCenRouteMapsResponseBodyRouteMaps `json:"RouteMaps,omitempty" xml:"RouteMaps,omitempty" type:"Struct"`
	// Indicates whether the source network instance IDs are excluded.
	//
	// *   **false** (default): A route is a match if its source network instance ID is in the list specified by **SourceInstanceIds.N**.
	// *   **true**: A route is match if its source network instance ID is not in the list specified by **SourceInstanceIds.N**.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCenRouteMapsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBody) SetPageNumber(v int32) *DescribeCenRouteMapsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBody) SetPageSize(v int32) *DescribeCenRouteMapsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBody) SetRequestId(v string) *DescribeCenRouteMapsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBody) SetRouteMaps(v *DescribeCenRouteMapsResponseBodyRouteMaps) *DescribeCenRouteMapsResponseBody {
	s.RouteMaps = v
	return s
}

func (s *DescribeCenRouteMapsResponseBody) SetTotalCount(v int32) *DescribeCenRouteMapsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCenRouteMapsResponseBodyRouteMaps struct {
	RouteMap []*DescribeCenRouteMapsResponseBodyRouteMapsRouteMap `json:"RouteMap,omitempty" xml:"RouteMap,omitempty" type:"Repeated"`
}

func (s DescribeCenRouteMapsResponseBodyRouteMaps) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBodyRouteMaps) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBodyRouteMaps) SetRouteMap(v []*DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) *DescribeCenRouteMapsResponseBodyRouteMaps {
	s.RouteMap = v
	return s
}

type DescribeCenRouteMapsResponseBodyRouteMapsRouteMap struct {
	// The IDs of the source route tables to which the routes belong.
	AsPathMatchMode *string `json:"AsPathMatchMode,omitempty" xml:"AsPathMatchMode,omitempty"`
	// The number of entries returned.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The number of entries returned per page.
	CenRegionId *string `json:"CenRegionId,omitempty" xml:"CenRegionId,omitempty"`
	// The action performed on a route that meets the match conditions.
	//
	// *   **Permit**: the route is permitted.
	// *   **Deny**: the route is denied.
	CidrMatchMode *string `json:"CidrMatchMode,omitempty" xml:"CidrMatchMode,omitempty"`
	// The direction in which the routing policy is applied. Valid values:
	//
	// *   **RegionIn**: Routes are advertised to the gateways in the regions that are connected by the CEN instance.
	//
	//     For example, routes are advertised from network instances deployed in the current region or other regions to the gateway deployed in the current region.
	//
	// *   **RegionOut**: Routes are advertised from the gateways in the regions that are connected by the CEN instance.
	//
	//     For example, routes are advertised from the gateway deployed in the current region to network instances deployed in the current region, or to gateways deployed in other regions.
	CommunityMatchMode *string `json:"CommunityMatchMode,omitempty" xml:"CommunityMatchMode,omitempty"`
	// The information about the routing policy.
	CommunityOperateMode *string `json:"CommunityOperateMode,omitempty" xml:"CommunityOperateMode,omitempty"`
	// The AS paths based on which the routes are compared.
	Description                   *string                                                                         `json:"Description,omitempty" xml:"Description,omitempty"`
	DestinationChildInstanceTypes *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationChildInstanceTypes `json:"DestinationChildInstanceTypes,omitempty" xml:"DestinationChildInstanceTypes,omitempty" type:"Struct"`
	// The number of the returned page.
	DestinationCidrBlocks  *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationCidrBlocks  `json:"DestinationCidrBlocks,omitempty" xml:"DestinationCidrBlocks,omitempty" type:"Struct"`
	DestinationInstanceIds *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationInstanceIds `json:"DestinationInstanceIds,omitempty" xml:"DestinationInstanceIds,omitempty" type:"Struct"`
	// The description of the routing policy.
	DestinationInstanceIdsReverseMatch *bool `json:"DestinationInstanceIdsReverseMatch,omitempty" xml:"DestinationInstanceIdsReverseMatch,omitempty"`
	// The types of source network instance to which the routes belong.
	//
	// *   **VPC**: virtual private cloud (VPC)
	// *   **VBR**: virtual border router (VBR)
	// *   **CCN**: Cloud Connect Network (CCN) instance
	// *   **VPN**: IPsec-VPN connection
	DestinationRouteTableIds *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationRouteTableIds `json:"DestinationRouteTableIds,omitempty" xml:"DestinationRouteTableIds,omitempty" type:"Struct"`
	// The ID of the region where the routing policy is applied.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	MapResult *string `json:"MapResult,omitempty" xml:"MapResult,omitempty"`
	// The IDs of the source network instances to which the routes belong.
	MatchAddressType  *string                                                             `json:"MatchAddressType,omitempty" xml:"MatchAddressType,omitempty"`
	MatchAsns         *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapMatchAsns         `json:"MatchAsns,omitempty" xml:"MatchAsns,omitempty" type:"Struct"`
	MatchCommunitySet *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapMatchCommunitySet `json:"MatchCommunitySet,omitempty" xml:"MatchCommunitySet,omitempty" type:"Struct"`
	// The match method that is used to match routes based on the prefix. Valid values:
	//
	// *   **Include**: fuzzy match. A route is a match if the route prefix is included in the match conditions.
	//
	//     For example, if you set the match condition to 10.10.0.0/16 and fuzzy match is enabled, the route whose prefix is 10.10.1.0/24 is a match.
	//
	// *   **Complete**: exact match. A route is a match only if the route prefix is the same as the prefix specified in the match condition.
	//
	//     For example, if you set the match condition to 10.10.0.0/16 and exact match is enabled, a route is a match only if the prefix is 10.10.0.0/16.
	NextPriority        *int32                                                                `json:"NextPriority,omitempty" xml:"NextPriority,omitempty"`
	OperateCommunitySet *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapOperateCommunitySet `json:"OperateCommunitySet,omitempty" xml:"OperateCommunitySet,omitempty" type:"Struct"`
	// The prefixes of the routes.
	Preference    *int32                                                          `json:"Preference,omitempty" xml:"Preference,omitempty"`
	PrependAsPath *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapPrependAsPath `json:"PrependAsPath,omitempty" xml:"PrependAsPath,omitempty" type:"Struct"`
	// The ID of the region where the routing policy is applied.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of IP address to be matched against the match condition. Valid values:
	//
	// *   **IPv4**: IPv4 addresses
	// *   **IPv6**: IPv6 addresses
	// *   If no value is returned, both IPv4 and IPv6 addresses are matched against the match condition.
	RouteMapId *string                                                      `json:"RouteMapId,omitempty" xml:"RouteMapId,omitempty"`
	RouteTypes *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapRouteTypes `json:"RouteTypes,omitempty" xml:"RouteTypes,omitempty" type:"Struct"`
	// The community set based on which the routes are compared.
	SourceChildInstanceTypes *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceChildInstanceTypes `json:"SourceChildInstanceTypes,omitempty" xml:"SourceChildInstanceTypes,omitempty" type:"Struct"`
	// The direction in which the routing policy is applied.
	SourceInstanceIds *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceInstanceIds `json:"SourceInstanceIds,omitempty" xml:"SourceInstanceIds,omitempty" type:"Struct"`
	// The ID of the routing policy.
	SourceInstanceIdsReverseMatch *bool `json:"SourceInstanceIdsReverseMatch,omitempty" xml:"SourceInstanceIdsReverseMatch,omitempty"`
	// The status of the routing policy. Valid values:
	//
	// *   **Creating**: The routing policy is being created.
	// *   **Active**: The routing policy is available.
	// *   **Deleting**: The routing policy is being deleted.
	SourceRegionIds *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceRegionIds `json:"SourceRegionIds,omitempty" xml:"SourceRegionIds,omitempty" type:"Struct"`
	// Queries the routing policies of a Cloud Enterprise Network (CEN) instance.
	SourceRouteTableIds *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceRouteTableIds `json:"SourceRouteTableIds,omitempty" xml:"SourceRouteTableIds,omitempty" type:"Struct"`
	// The new priority of the route.
	//
	// A smaller value indicates a higher priority.
	//
	// This parameter indicates the action to be performed when a route meets the match condition.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The action that is performed on the community of the route.
	//
	// *   **Additive**: adds the community to the route.
	// *   **Replace**: replaces the original community of the route.
	//
	// This parameter indicates the action to be performed when a route meets the match condition.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
	// The ID of the routing policy.
	TransmitDirection *string `json:"TransmitDirection,omitempty" xml:"TransmitDirection,omitempty"`
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetAsPathMatchMode(v string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.AsPathMatchMode = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetCenId(v string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.CenId = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetCenRegionId(v string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.CenRegionId = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetCidrMatchMode(v string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.CidrMatchMode = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetCommunityMatchMode(v string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.CommunityMatchMode = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetCommunityOperateMode(v string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.CommunityOperateMode = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetDescription(v string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.Description = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetDestinationChildInstanceTypes(v *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationChildInstanceTypes) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.DestinationChildInstanceTypes = v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetDestinationCidrBlocks(v *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationCidrBlocks) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.DestinationCidrBlocks = v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetDestinationInstanceIds(v *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationInstanceIds) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.DestinationInstanceIds = v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetDestinationInstanceIdsReverseMatch(v bool) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.DestinationInstanceIdsReverseMatch = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetDestinationRouteTableIds(v *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationRouteTableIds) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.DestinationRouteTableIds = v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetMapResult(v string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.MapResult = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetMatchAddressType(v string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.MatchAddressType = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetMatchAsns(v *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapMatchAsns) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.MatchAsns = v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetMatchCommunitySet(v *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapMatchCommunitySet) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.MatchCommunitySet = v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetNextPriority(v int32) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.NextPriority = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetOperateCommunitySet(v *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapOperateCommunitySet) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.OperateCommunitySet = v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetPreference(v int32) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.Preference = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetPrependAsPath(v *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapPrependAsPath) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.PrependAsPath = v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetPriority(v int32) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.Priority = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetRouteMapId(v string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.RouteMapId = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetRouteTypes(v *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapRouteTypes) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.RouteTypes = v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetSourceChildInstanceTypes(v *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceChildInstanceTypes) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.SourceChildInstanceTypes = v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetSourceInstanceIds(v *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceInstanceIds) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.SourceInstanceIds = v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetSourceInstanceIdsReverseMatch(v bool) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.SourceInstanceIdsReverseMatch = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetSourceRegionIds(v *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceRegionIds) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.SourceRegionIds = v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetSourceRouteTableIds(v *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceRouteTableIds) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.SourceRouteTableIds = v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetStatus(v string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.Status = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetTransitRouterRouteTableId(v string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.TransitRouterRouteTableId = &v
	return s
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap) SetTransmitDirection(v string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMap {
	s.TransmitDirection = &v
	return s
}

type DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationChildInstanceTypes struct {
	DestinationChildInstanceType []*string `json:"DestinationChildInstanceType,omitempty" xml:"DestinationChildInstanceType,omitempty" type:"Repeated"`
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationChildInstanceTypes) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationChildInstanceTypes) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationChildInstanceTypes) SetDestinationChildInstanceType(v []*string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationChildInstanceTypes {
	s.DestinationChildInstanceType = v
	return s
}

type DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationCidrBlocks struct {
	DestinationCidrBlock []*string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty" type:"Repeated"`
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationCidrBlocks) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationCidrBlocks) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationCidrBlocks) SetDestinationCidrBlock(v []*string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationCidrBlocks {
	s.DestinationCidrBlock = v
	return s
}

type DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationInstanceIds struct {
	DestinationInstanceId []*string `json:"DestinationInstanceId,omitempty" xml:"DestinationInstanceId,omitempty" type:"Repeated"`
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationInstanceIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationInstanceIds) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationInstanceIds) SetDestinationInstanceId(v []*string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationInstanceIds {
	s.DestinationInstanceId = v
	return s
}

type DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationRouteTableIds struct {
	DestinationRouteTableId []*string `json:"DestinationRouteTableId,omitempty" xml:"DestinationRouteTableId,omitempty" type:"Repeated"`
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationRouteTableIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationRouteTableIds) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationRouteTableIds) SetDestinationRouteTableId(v []*string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapDestinationRouteTableIds {
	s.DestinationRouteTableId = v
	return s
}

type DescribeCenRouteMapsResponseBodyRouteMapsRouteMapMatchAsns struct {
	MatchAsn []*string `json:"MatchAsn,omitempty" xml:"MatchAsn,omitempty" type:"Repeated"`
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapMatchAsns) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapMatchAsns) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapMatchAsns) SetMatchAsn(v []*string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapMatchAsns {
	s.MatchAsn = v
	return s
}

type DescribeCenRouteMapsResponseBodyRouteMapsRouteMapMatchCommunitySet struct {
	MatchCommunity []*string `json:"MatchCommunity,omitempty" xml:"MatchCommunity,omitempty" type:"Repeated"`
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapMatchCommunitySet) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapMatchCommunitySet) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapMatchCommunitySet) SetMatchCommunity(v []*string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapMatchCommunitySet {
	s.MatchCommunity = v
	return s
}

type DescribeCenRouteMapsResponseBodyRouteMapsRouteMapOperateCommunitySet struct {
	OperateCommunity []*string `json:"OperateCommunity,omitempty" xml:"OperateCommunity,omitempty" type:"Repeated"`
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapOperateCommunitySet) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapOperateCommunitySet) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapOperateCommunitySet) SetOperateCommunity(v []*string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapOperateCommunitySet {
	s.OperateCommunity = v
	return s
}

type DescribeCenRouteMapsResponseBodyRouteMapsRouteMapPrependAsPath struct {
	AsPath []*string `json:"AsPath,omitempty" xml:"AsPath,omitempty" type:"Repeated"`
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapPrependAsPath) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapPrependAsPath) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapPrependAsPath) SetAsPath(v []*string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapPrependAsPath {
	s.AsPath = v
	return s
}

type DescribeCenRouteMapsResponseBodyRouteMapsRouteMapRouteTypes struct {
	RouteType []*string `json:"RouteType,omitempty" xml:"RouteType,omitempty" type:"Repeated"`
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapRouteTypes) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapRouteTypes) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapRouteTypes) SetRouteType(v []*string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapRouteTypes {
	s.RouteType = v
	return s
}

type DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceChildInstanceTypes struct {
	SourceChildInstanceType []*string `json:"SourceChildInstanceType,omitempty" xml:"SourceChildInstanceType,omitempty" type:"Repeated"`
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceChildInstanceTypes) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceChildInstanceTypes) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceChildInstanceTypes) SetSourceChildInstanceType(v []*string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceChildInstanceTypes {
	s.SourceChildInstanceType = v
	return s
}

type DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceInstanceIds struct {
	SourceInstanceId []*string `json:"SourceInstanceId,omitempty" xml:"SourceInstanceId,omitempty" type:"Repeated"`
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceInstanceIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceInstanceIds) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceInstanceIds) SetSourceInstanceId(v []*string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceInstanceIds {
	s.SourceInstanceId = v
	return s
}

type DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceRegionIds struct {
	SourceRegionId []*string `json:"SourceRegionId,omitempty" xml:"SourceRegionId,omitempty" type:"Repeated"`
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceRegionIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceRegionIds) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceRegionIds) SetSourceRegionId(v []*string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceRegionIds {
	s.SourceRegionId = v
	return s
}

type DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceRouteTableIds struct {
	SourceRouteTableId []*string `json:"SourceRouteTableId,omitempty" xml:"SourceRouteTableId,omitempty" type:"Repeated"`
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceRouteTableIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceRouteTableIds) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceRouteTableIds) SetSourceRouteTableId(v []*string) *DescribeCenRouteMapsResponseBodyRouteMapsRouteMapSourceRouteTableIds {
	s.SourceRouteTableId = v
	return s
}

type DescribeCenRouteMapsResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCenRouteMapsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCenRouteMapsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenRouteMapsResponse) GoString() string {
	return s.String()
}

func (s *DescribeCenRouteMapsResponse) SetHeaders(v map[string]*string) *DescribeCenRouteMapsResponse {
	s.Headers = v
	return s
}

func (s *DescribeCenRouteMapsResponse) SetStatusCode(v int32) *DescribeCenRouteMapsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCenRouteMapsResponse) SetBody(v *DescribeCenRouteMapsResponseBody) *DescribeCenRouteMapsResponse {
	s.Body = v
	return s
}

type DescribeCenVbrHealthCheckRequest struct {
	// The ID of the CEN instance.
	CenId        *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **50**. Default value: **10**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VBR.
	VbrInstanceId *string `json:"VbrInstanceId,omitempty" xml:"VbrInstanceId,omitempty"`
	// The ID of the Alibaba Cloud account that owns the VBR.
	VbrInstanceOwnerId *int64 `json:"VbrInstanceOwnerId,omitempty" xml:"VbrInstanceOwnerId,omitempty"`
	// The ID of the region where the VBR is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	VbrInstanceRegionId *string `json:"VbrInstanceRegionId,omitempty" xml:"VbrInstanceRegionId,omitempty"`
}

func (s DescribeCenVbrHealthCheckRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenVbrHealthCheckRequest) GoString() string {
	return s.String()
}

func (s *DescribeCenVbrHealthCheckRequest) SetCenId(v string) *DescribeCenVbrHealthCheckRequest {
	s.CenId = &v
	return s
}

func (s *DescribeCenVbrHealthCheckRequest) SetOwnerAccount(v string) *DescribeCenVbrHealthCheckRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCenVbrHealthCheckRequest) SetOwnerId(v int64) *DescribeCenVbrHealthCheckRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCenVbrHealthCheckRequest) SetPageNumber(v int32) *DescribeCenVbrHealthCheckRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenVbrHealthCheckRequest) SetPageSize(v int32) *DescribeCenVbrHealthCheckRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCenVbrHealthCheckRequest) SetResourceOwnerAccount(v string) *DescribeCenVbrHealthCheckRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCenVbrHealthCheckRequest) SetResourceOwnerId(v int64) *DescribeCenVbrHealthCheckRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeCenVbrHealthCheckRequest) SetVbrInstanceId(v string) *DescribeCenVbrHealthCheckRequest {
	s.VbrInstanceId = &v
	return s
}

func (s *DescribeCenVbrHealthCheckRequest) SetVbrInstanceOwnerId(v int64) *DescribeCenVbrHealthCheckRequest {
	s.VbrInstanceOwnerId = &v
	return s
}

func (s *DescribeCenVbrHealthCheckRequest) SetVbrInstanceRegionId(v string) *DescribeCenVbrHealthCheckRequest {
	s.VbrInstanceRegionId = &v
	return s
}

type DescribeCenVbrHealthCheckResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The health check configuration of the VBR.
	VbrHealthChecks *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecks `json:"VbrHealthChecks,omitempty" xml:"VbrHealthChecks,omitempty" type:"Struct"`
}

func (s DescribeCenVbrHealthCheckResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenVbrHealthCheckResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCenVbrHealthCheckResponseBody) SetPageNumber(v int32) *DescribeCenVbrHealthCheckResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCenVbrHealthCheckResponseBody) SetPageSize(v int32) *DescribeCenVbrHealthCheckResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCenVbrHealthCheckResponseBody) SetRequestId(v string) *DescribeCenVbrHealthCheckResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCenVbrHealthCheckResponseBody) SetTotalCount(v int32) *DescribeCenVbrHealthCheckResponseBody {
	s.TotalCount = &v
	return s
}

func (s *DescribeCenVbrHealthCheckResponseBody) SetVbrHealthChecks(v *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecks) *DescribeCenVbrHealthCheckResponseBody {
	s.VbrHealthChecks = v
	return s
}

type DescribeCenVbrHealthCheckResponseBodyVbrHealthChecks struct {
	VbrHealthCheck []*DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck `json:"VbrHealthCheck,omitempty" xml:"VbrHealthCheck,omitempty" type:"Repeated"`
}

func (s DescribeCenVbrHealthCheckResponseBodyVbrHealthChecks) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenVbrHealthCheckResponseBodyVbrHealthChecks) GoString() string {
	return s.String()
}

func (s *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecks) SetVbrHealthCheck(v []*DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck) *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecks {
	s.VbrHealthCheck = v
	return s
}

type DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The time interval at which probe packets are sent during the health check. Unit: seconds.
	HealthCheckInterval *int32 `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	// Indicates whether probing is enabled. Valid values:
	//
	// *   **true**: yes
	//
	//     If probing is enabled, the system does not switch to another route when the detected route is not reachable.
	//
	// *   **false**: no
	//
	//     If probing is disabled and a redundant route is specified, the system switches to the redundant route when the detected route is not reachable.
	HealthCheckOnly *bool `json:"HealthCheckOnly,omitempty" xml:"HealthCheckOnly,omitempty"`
	// The source IP address of the health check.
	HealthCheckSourceIp *string `json:"HealthCheckSourceIp,omitempty" xml:"HealthCheckSourceIp,omitempty"`
	// The destination IP address of the health check.
	HealthCheckTargetIp *string `json:"HealthCheckTargetIp,omitempty" xml:"HealthCheckTargetIp,omitempty"`
	// The number of probe packets that are sent during the health check.
	HealthyThreshold *int32 `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	// The ID of the VBR.
	VbrInstanceId *string `json:"VbrInstanceId,omitempty" xml:"VbrInstanceId,omitempty"`
	// The ID of the region where the VBR is deployed.
	VbrInstanceRegionId *string `json:"VbrInstanceRegionId,omitempty" xml:"VbrInstanceRegionId,omitempty"`
}

func (s DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck) GoString() string {
	return s.String()
}

func (s *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck) SetCenId(v string) *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck {
	s.CenId = &v
	return s
}

func (s *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck) SetHealthCheckInterval(v int32) *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck {
	s.HealthCheckInterval = &v
	return s
}

func (s *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck) SetHealthCheckOnly(v bool) *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck {
	s.HealthCheckOnly = &v
	return s
}

func (s *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck) SetHealthCheckSourceIp(v string) *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck {
	s.HealthCheckSourceIp = &v
	return s
}

func (s *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck) SetHealthCheckTargetIp(v string) *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck {
	s.HealthCheckTargetIp = &v
	return s
}

func (s *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck) SetHealthyThreshold(v int32) *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck {
	s.HealthyThreshold = &v
	return s
}

func (s *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck) SetVbrInstanceId(v string) *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck {
	s.VbrInstanceId = &v
	return s
}

func (s *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck) SetVbrInstanceRegionId(v string) *DescribeCenVbrHealthCheckResponseBodyVbrHealthChecksVbrHealthCheck {
	s.VbrInstanceRegionId = &v
	return s
}

type DescribeCenVbrHealthCheckResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCenVbrHealthCheckResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCenVbrHealthCheckResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCenVbrHealthCheckResponse) GoString() string {
	return s.String()
}

func (s *DescribeCenVbrHealthCheckResponse) SetHeaders(v map[string]*string) *DescribeCenVbrHealthCheckResponse {
	s.Headers = v
	return s
}

func (s *DescribeCenVbrHealthCheckResponse) SetStatusCode(v int32) *DescribeCenVbrHealthCheckResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCenVbrHealthCheckResponse) SetBody(v *DescribeCenVbrHealthCheckResponseBody) *DescribeCenVbrHealthCheckResponse {
	s.Body = v
	return s
}

type DescribeCensRequest struct {
	// The filter conditions.
	//
	// You can specify at most five filter conditions in each call.
	Filter       []*DescribeCensRequestFilter `json:"Filter,omitempty" xml:"Filter,omitempty" type:"Repeated"`
	OwnerAccount *string                      `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64                       `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group to which the CEN instance belongs.
	ResourceGroupId      *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The tags.
	//
	// You can specify at most 20 tags in each call.
	Tag []*DescribeCensRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeCensRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensRequest) GoString() string {
	return s.String()
}

func (s *DescribeCensRequest) SetFilter(v []*DescribeCensRequestFilter) *DescribeCensRequest {
	s.Filter = v
	return s
}

func (s *DescribeCensRequest) SetOwnerAccount(v string) *DescribeCensRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeCensRequest) SetOwnerId(v int64) *DescribeCensRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeCensRequest) SetPageNumber(v int32) *DescribeCensRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeCensRequest) SetPageSize(v int32) *DescribeCensRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeCensRequest) SetResourceGroupId(v string) *DescribeCensRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeCensRequest) SetResourceOwnerAccount(v string) *DescribeCensRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeCensRequest) SetResourceOwnerId(v int64) *DescribeCensRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeCensRequest) SetTag(v []*DescribeCensRequestTag) *DescribeCensRequest {
	s.Tag = v
	return s
}

type DescribeCensRequestFilter struct {
	// The key of the filter. Valid values:
	//
	// *   **CenId**: the ID of a CEN instance.
	// *   **Name**: the name of a CEN instance.
	//
	// By default, the logical operator among filter conditions is **AND**. Information about a CEN instance is returned only if the CEN instance matches all filter conditions.
	//
	// You can specify at most five filter conditions in each call.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the filter condition.
	//
	// Specify a filter value based on the **Key** parameter. You can specify multiple values for a filter **key**. The logical operator among multiple filter values is **OR**. If a CEN instance matches one or more of the values that you specify, the CEN instance matches the filter condition.
	//
	// You can specify at most five values in each filter condition.
	Value []*string `json:"Value,omitempty" xml:"Value,omitempty" type:"Repeated"`
}

func (s DescribeCensRequestFilter) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensRequestFilter) GoString() string {
	return s.String()
}

func (s *DescribeCensRequestFilter) SetKey(v string) *DescribeCensRequestFilter {
	s.Key = &v
	return s
}

func (s *DescribeCensRequestFilter) SetValue(v []*string) *DescribeCensRequestFilter {
	s.Value = v
	return s
}

type DescribeCensRequestTag struct {
	// The tag keys.
	//
	// The tag keys cannot be an empty string. The tag keys can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag values.
	//
	// The tag values can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeCensRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeCensRequestTag) SetKey(v string) *DescribeCensRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeCensRequestTag) SetValue(v string) *DescribeCensRequestTag {
	s.Value = &v
	return s
}

type DescribeCensResponseBody struct {
	// The information about the CEN instance.
	Cens *DescribeCensResponseBodyCens `json:"Cens,omitempty" xml:"Cens,omitempty" type:"Struct"`
	// The number of the page returned.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeCensResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeCensResponseBody) SetCens(v *DescribeCensResponseBodyCens) *DescribeCensResponseBody {
	s.Cens = v
	return s
}

func (s *DescribeCensResponseBody) SetPageNumber(v int32) *DescribeCensResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeCensResponseBody) SetPageSize(v int32) *DescribeCensResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeCensResponseBody) SetRequestId(v string) *DescribeCensResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeCensResponseBody) SetTotalCount(v int32) *DescribeCensResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeCensResponseBodyCens struct {
	Cen []*DescribeCensResponseBodyCensCen `json:"Cen,omitempty" xml:"Cen,omitempty" type:"Repeated"`
}

func (s DescribeCensResponseBodyCens) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensResponseBodyCens) GoString() string {
	return s.String()
}

func (s *DescribeCensResponseBodyCens) SetCen(v []*DescribeCensResponseBodyCensCen) *DescribeCensResponseBodyCens {
	s.Cen = v
	return s
}

type DescribeCensResponseBodyCensCen struct {
	// The IDs of the bandwidth plans that are associated with the CEN instance.
	CenBandwidthPackageIds *DescribeCensResponseBodyCensCenCenBandwidthPackageIds `json:"CenBandwidthPackageIds,omitempty" xml:"CenBandwidthPackageIds,omitempty" type:"Struct"`
	// The CEN instance ID.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The time when the CEN instance was created.
	//
	// The time follows the ISO8601 standard in the `YYYY-MM-DDThh:mmZ` format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The description of the CEN instance.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether IPv6 is enabled for the CEN instance.
	//
	// *   **ENABLE**
	// *   **DISABLED**
	Ipv6Level *string `json:"Ipv6Level,omitempty" xml:"Ipv6Level,omitempty"`
	// The CEN instance name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The level of CIDR block overlapping.
	//
	// **REDUCED**: Overlapped CIDR blocks are allowed. This value specifies that CIDR blocks can overlap but CIDR blocks cannot be duplicates.
	ProtectionLevel *string `json:"ProtectionLevel,omitempty" xml:"ProtectionLevel,omitempty"`
	// The ID of the resource group to which the CEN instance belongs.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the CEN instance.
	//
	// *   **Creating**
	// *   **Active**
	// *   **Deleting**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The IDs of the tags that are added to the CEN instance.
	Tags *DescribeCensResponseBodyCensCenTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
}

func (s DescribeCensResponseBodyCensCen) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensResponseBodyCensCen) GoString() string {
	return s.String()
}

func (s *DescribeCensResponseBodyCensCen) SetCenBandwidthPackageIds(v *DescribeCensResponseBodyCensCenCenBandwidthPackageIds) *DescribeCensResponseBodyCensCen {
	s.CenBandwidthPackageIds = v
	return s
}

func (s *DescribeCensResponseBodyCensCen) SetCenId(v string) *DescribeCensResponseBodyCensCen {
	s.CenId = &v
	return s
}

func (s *DescribeCensResponseBodyCensCen) SetCreationTime(v string) *DescribeCensResponseBodyCensCen {
	s.CreationTime = &v
	return s
}

func (s *DescribeCensResponseBodyCensCen) SetDescription(v string) *DescribeCensResponseBodyCensCen {
	s.Description = &v
	return s
}

func (s *DescribeCensResponseBodyCensCen) SetIpv6Level(v string) *DescribeCensResponseBodyCensCen {
	s.Ipv6Level = &v
	return s
}

func (s *DescribeCensResponseBodyCensCen) SetName(v string) *DescribeCensResponseBodyCensCen {
	s.Name = &v
	return s
}

func (s *DescribeCensResponseBodyCensCen) SetProtectionLevel(v string) *DescribeCensResponseBodyCensCen {
	s.ProtectionLevel = &v
	return s
}

func (s *DescribeCensResponseBodyCensCen) SetResourceGroupId(v string) *DescribeCensResponseBodyCensCen {
	s.ResourceGroupId = &v
	return s
}

func (s *DescribeCensResponseBodyCensCen) SetStatus(v string) *DescribeCensResponseBodyCensCen {
	s.Status = &v
	return s
}

func (s *DescribeCensResponseBodyCensCen) SetTags(v *DescribeCensResponseBodyCensCenTags) *DescribeCensResponseBodyCensCen {
	s.Tags = v
	return s
}

type DescribeCensResponseBodyCensCenCenBandwidthPackageIds struct {
	CenBandwidthPackageId []*string `json:"CenBandwidthPackageId,omitempty" xml:"CenBandwidthPackageId,omitempty" type:"Repeated"`
}

func (s DescribeCensResponseBodyCensCenCenBandwidthPackageIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensResponseBodyCensCenCenBandwidthPackageIds) GoString() string {
	return s.String()
}

func (s *DescribeCensResponseBodyCensCenCenBandwidthPackageIds) SetCenBandwidthPackageId(v []*string) *DescribeCensResponseBodyCensCenCenBandwidthPackageIds {
	s.CenBandwidthPackageId = v
	return s
}

type DescribeCensResponseBodyCensCenTags struct {
	Tag []*DescribeCensResponseBodyCensCenTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeCensResponseBodyCensCenTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensResponseBodyCensCenTags) GoString() string {
	return s.String()
}

func (s *DescribeCensResponseBodyCensCenTags) SetTag(v []*DescribeCensResponseBodyCensCenTagsTag) *DescribeCensResponseBodyCensCenTags {
	s.Tag = v
	return s
}

type DescribeCensResponseBodyCensCenTagsTag struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeCensResponseBodyCensCenTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensResponseBodyCensCenTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeCensResponseBodyCensCenTagsTag) SetKey(v string) *DescribeCensResponseBodyCensCenTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeCensResponseBodyCensCenTagsTag) SetValue(v string) *DescribeCensResponseBodyCensCenTagsTag {
	s.Value = &v
	return s
}

type DescribeCensResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeCensResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeCensResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeCensResponse) GoString() string {
	return s.String()
}

func (s *DescribeCensResponse) SetHeaders(v map[string]*string) *DescribeCensResponse {
	s.Headers = v
	return s
}

func (s *DescribeCensResponse) SetStatusCode(v int32) *DescribeCensResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeCensResponse) SetBody(v *DescribeCensResponseBody) *DescribeCensResponse {
	s.Body = v
	return s
}

type DescribeChildInstanceRegionsRequest struct {
	// The language of the response. Valid values: zh-CN (Chinese, which is the default language), en-US (English), and ja (Japanese).
	AcceptLanguage *string `json:"AcceptLanguage,omitempty" xml:"AcceptLanguage,omitempty"`
	OwnerAccount   *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId        *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: virtual private cloud (VPC)
	// *   **VBR**: virtual border router (VBR)
	// *   **CCN**: Cloud Connect Network (CCN) instance
	ProductType          *string `json:"ProductType,omitempty" xml:"ProductType,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeChildInstanceRegionsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeChildInstanceRegionsRequest) GoString() string {
	return s.String()
}

func (s *DescribeChildInstanceRegionsRequest) SetAcceptLanguage(v string) *DescribeChildInstanceRegionsRequest {
	s.AcceptLanguage = &v
	return s
}

func (s *DescribeChildInstanceRegionsRequest) SetOwnerAccount(v string) *DescribeChildInstanceRegionsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeChildInstanceRegionsRequest) SetOwnerId(v int64) *DescribeChildInstanceRegionsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeChildInstanceRegionsRequest) SetProductType(v string) *DescribeChildInstanceRegionsRequest {
	s.ProductType = &v
	return s
}

func (s *DescribeChildInstanceRegionsRequest) SetResourceOwnerAccount(v string) *DescribeChildInstanceRegionsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeChildInstanceRegionsRequest) SetResourceOwnerId(v int64) *DescribeChildInstanceRegionsRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeChildInstanceRegionsResponseBody struct {
	// A list of regions.
	Regions *DescribeChildInstanceRegionsResponseBodyRegions `json:"Regions,omitempty" xml:"Regions,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DescribeChildInstanceRegionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeChildInstanceRegionsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeChildInstanceRegionsResponseBody) SetRegions(v *DescribeChildInstanceRegionsResponseBodyRegions) *DescribeChildInstanceRegionsResponseBody {
	s.Regions = v
	return s
}

func (s *DescribeChildInstanceRegionsResponseBody) SetRequestId(v string) *DescribeChildInstanceRegionsResponseBody {
	s.RequestId = &v
	return s
}

type DescribeChildInstanceRegionsResponseBodyRegions struct {
	Region []*DescribeChildInstanceRegionsResponseBodyRegionsRegion `json:"Region,omitempty" xml:"Region,omitempty" type:"Repeated"`
}

func (s DescribeChildInstanceRegionsResponseBodyRegions) String() string {
	return tea.Prettify(s)
}

func (s DescribeChildInstanceRegionsResponseBodyRegions) GoString() string {
	return s.String()
}

func (s *DescribeChildInstanceRegionsResponseBodyRegions) SetRegion(v []*DescribeChildInstanceRegionsResponseBodyRegionsRegion) *DescribeChildInstanceRegionsResponseBodyRegions {
	s.Region = v
	return s
}

type DescribeChildInstanceRegionsResponseBodyRegionsRegion struct {
	// The name of the region.
	LocalName *string `json:"LocalName,omitempty" xml:"LocalName,omitempty"`
	// The ID of the region.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeChildInstanceRegionsResponseBodyRegionsRegion) String() string {
	return tea.Prettify(s)
}

func (s DescribeChildInstanceRegionsResponseBodyRegionsRegion) GoString() string {
	return s.String()
}

func (s *DescribeChildInstanceRegionsResponseBodyRegionsRegion) SetLocalName(v string) *DescribeChildInstanceRegionsResponseBodyRegionsRegion {
	s.LocalName = &v
	return s
}

func (s *DescribeChildInstanceRegionsResponseBodyRegionsRegion) SetRegionId(v string) *DescribeChildInstanceRegionsResponseBodyRegionsRegion {
	s.RegionId = &v
	return s
}

type DescribeChildInstanceRegionsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeChildInstanceRegionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeChildInstanceRegionsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeChildInstanceRegionsResponse) GoString() string {
	return s.String()
}

func (s *DescribeChildInstanceRegionsResponse) SetHeaders(v map[string]*string) *DescribeChildInstanceRegionsResponse {
	s.Headers = v
	return s
}

func (s *DescribeChildInstanceRegionsResponse) SetStatusCode(v int32) *DescribeChildInstanceRegionsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeChildInstanceRegionsResponse) SetBody(v *DescribeChildInstanceRegionsResponseBody) *DescribeChildInstanceRegionsResponse {
	s.Body = v
	return s
}

type DescribeFlowlogsRequest struct {
	// The name of the Logstore where the flow log is stored.
	//
	// The name must be 3 to 63 characters in length, and can contain lowercase letters, digits, underscores (\_), and hyphens (-). It must start or end with a lowercase letter or a digit.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The name of the flow log.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The name of the project where the flow log is stored.
	//
	// The name must be 3 to 63 characters in length, and can contain lowercase letters, digits, and hyphens (-). It must start or end with a lowercase letter or a digit.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the Cloud Enterprise Network (CEN) instance.
	FlowLogId *string `json:"FlowLogId,omitempty" xml:"FlowLogId,omitempty"`
	// The description of the flow log.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter but cannot start with `http://` or `https://`.
	FlowLogName *string `json:"FlowLogName,omitempty" xml:"FlowLogName,omitempty"`
	// The number of the page to return. Default value: **1**.
	LogStoreName *string `json:"LogStoreName,omitempty" xml:"LogStoreName,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The information about the tags.
	//
	// You can specify at most 20 tags in each call.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The tag key.
	//
	// The tag key cannot be an empty string. The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The status of the flow log. Valid values:
	//
	// *   **Active**: The flow log is enabled.
	// *   **Inactive**: The flow log is disabled.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The ID of the flow log.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The number of entries to return on each page. Minimum value: **1**. Default value: **20**.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag value.
	//
	// The tag value can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Tag []*DescribeFlowlogsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The number of entries returned per page.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s DescribeFlowlogsRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowlogsRequest) GoString() string {
	return s.String()
}

func (s *DescribeFlowlogsRequest) SetCenId(v string) *DescribeFlowlogsRequest {
	s.CenId = &v
	return s
}

func (s *DescribeFlowlogsRequest) SetClientToken(v string) *DescribeFlowlogsRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeFlowlogsRequest) SetDescription(v string) *DescribeFlowlogsRequest {
	s.Description = &v
	return s
}

func (s *DescribeFlowlogsRequest) SetFlowLogId(v string) *DescribeFlowlogsRequest {
	s.FlowLogId = &v
	return s
}

func (s *DescribeFlowlogsRequest) SetFlowLogName(v string) *DescribeFlowlogsRequest {
	s.FlowLogName = &v
	return s
}

func (s *DescribeFlowlogsRequest) SetLogStoreName(v string) *DescribeFlowlogsRequest {
	s.LogStoreName = &v
	return s
}

func (s *DescribeFlowlogsRequest) SetOwnerAccount(v string) *DescribeFlowlogsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeFlowlogsRequest) SetOwnerId(v int64) *DescribeFlowlogsRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeFlowlogsRequest) SetPageNumber(v int32) *DescribeFlowlogsRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeFlowlogsRequest) SetPageSize(v int32) *DescribeFlowlogsRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeFlowlogsRequest) SetProjectName(v string) *DescribeFlowlogsRequest {
	s.ProjectName = &v
	return s
}

func (s *DescribeFlowlogsRequest) SetRegionId(v string) *DescribeFlowlogsRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeFlowlogsRequest) SetResourceOwnerAccount(v string) *DescribeFlowlogsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeFlowlogsRequest) SetResourceOwnerId(v int64) *DescribeFlowlogsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeFlowlogsRequest) SetStatus(v string) *DescribeFlowlogsRequest {
	s.Status = &v
	return s
}

func (s *DescribeFlowlogsRequest) SetTag(v []*DescribeFlowlogsRequestTag) *DescribeFlowlogsRequest {
	s.Tag = v
	return s
}

func (s *DescribeFlowlogsRequest) SetTransitRouterAttachmentId(v string) *DescribeFlowlogsRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

type DescribeFlowlogsRequestTag struct {
	// The ID of the network instance connection.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The response.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeFlowlogsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowlogsRequestTag) GoString() string {
	return s.String()
}

func (s *DescribeFlowlogsRequestTag) SetKey(v string) *DescribeFlowlogsRequestTag {
	s.Key = &v
	return s
}

func (s *DescribeFlowlogsRequestTag) SetValue(v string) *DescribeFlowlogsRequestTag {
	s.Value = &v
	return s
}

type DescribeFlowlogsResponseBody struct {
	// The status of the flow log. Valid values:
	//
	// *   **Active**: The flow log is enabled.
	// *   **Inactive**: The flow log is disabled.
	FlowLogs *DescribeFlowlogsResponseBodyFlowLogs `json:"FlowLogs,omitempty" xml:"FlowLogs,omitempty" type:"Struct"`
	// The total number of entries returned.
	PageNumber *string `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the request.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// Indicates whether the call is successful. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the flow log.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
	// A list of flow logs.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeFlowlogsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowlogsResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeFlowlogsResponseBody) SetFlowLogs(v *DescribeFlowlogsResponseBodyFlowLogs) *DescribeFlowlogsResponseBody {
	s.FlowLogs = v
	return s
}

func (s *DescribeFlowlogsResponseBody) SetPageNumber(v string) *DescribeFlowlogsResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeFlowlogsResponseBody) SetPageSize(v string) *DescribeFlowlogsResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeFlowlogsResponseBody) SetRequestId(v string) *DescribeFlowlogsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeFlowlogsResponseBody) SetSuccess(v string) *DescribeFlowlogsResponseBody {
	s.Success = &v
	return s
}

func (s *DescribeFlowlogsResponseBody) SetTotalCount(v string) *DescribeFlowlogsResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeFlowlogsResponseBodyFlowLogs struct {
	FlowLog []*DescribeFlowlogsResponseBodyFlowLogsFlowLog `json:"FlowLog,omitempty" xml:"FlowLog,omitempty" type:"Repeated"`
}

func (s DescribeFlowlogsResponseBodyFlowLogs) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowlogsResponseBodyFlowLogs) GoString() string {
	return s.String()
}

func (s *DescribeFlowlogsResponseBodyFlowLogs) SetFlowLog(v []*DescribeFlowlogsResponseBodyFlowLogsFlowLog) *DescribeFlowlogsResponseBodyFlowLogs {
	s.FlowLog = v
	return s
}

type DescribeFlowlogsResponseBodyFlowLogsFlowLog struct {
	// The ID of the region where the flow log is deployed.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The description of the flow log.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The ID of the CEN instance.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The time window for collecting log data. Unit: seconds. Valid values: **60** and **600**. Default value: **600**.
	FlowLogId *string `json:"FlowLogId,omitempty" xml:"FlowLogId,omitempty"`
	// The name of the project where the flow log is stored.
	FlowLogName *string `json:"FlowLogName,omitempty" xml:"FlowLogName,omitempty"`
	// The tag value.
	Interval *int64 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	// The ID of the flow log.
	LogStoreName *string `json:"LogStoreName,omitempty" xml:"LogStoreName,omitempty"`
	// The name of the Logstore where the flow log is stored.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The ID of the network instance connection.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The name of the flow log.
	Status *string                                          `json:"Status,omitempty" xml:"Status,omitempty"`
	Tags   *DescribeFlowlogsResponseBodyFlowLogsFlowLogTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// A list of tags.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s DescribeFlowlogsResponseBodyFlowLogsFlowLog) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowlogsResponseBodyFlowLogsFlowLog) GoString() string {
	return s.String()
}

func (s *DescribeFlowlogsResponseBodyFlowLogsFlowLog) SetCenId(v string) *DescribeFlowlogsResponseBodyFlowLogsFlowLog {
	s.CenId = &v
	return s
}

func (s *DescribeFlowlogsResponseBodyFlowLogsFlowLog) SetCreationTime(v string) *DescribeFlowlogsResponseBodyFlowLogsFlowLog {
	s.CreationTime = &v
	return s
}

func (s *DescribeFlowlogsResponseBodyFlowLogsFlowLog) SetDescription(v string) *DescribeFlowlogsResponseBodyFlowLogsFlowLog {
	s.Description = &v
	return s
}

func (s *DescribeFlowlogsResponseBodyFlowLogsFlowLog) SetFlowLogId(v string) *DescribeFlowlogsResponseBodyFlowLogsFlowLog {
	s.FlowLogId = &v
	return s
}

func (s *DescribeFlowlogsResponseBodyFlowLogsFlowLog) SetFlowLogName(v string) *DescribeFlowlogsResponseBodyFlowLogsFlowLog {
	s.FlowLogName = &v
	return s
}

func (s *DescribeFlowlogsResponseBodyFlowLogsFlowLog) SetInterval(v int64) *DescribeFlowlogsResponseBodyFlowLogsFlowLog {
	s.Interval = &v
	return s
}

func (s *DescribeFlowlogsResponseBodyFlowLogsFlowLog) SetLogStoreName(v string) *DescribeFlowlogsResponseBodyFlowLogsFlowLog {
	s.LogStoreName = &v
	return s
}

func (s *DescribeFlowlogsResponseBodyFlowLogsFlowLog) SetProjectName(v string) *DescribeFlowlogsResponseBodyFlowLogsFlowLog {
	s.ProjectName = &v
	return s
}

func (s *DescribeFlowlogsResponseBodyFlowLogsFlowLog) SetRegionId(v string) *DescribeFlowlogsResponseBodyFlowLogsFlowLog {
	s.RegionId = &v
	return s
}

func (s *DescribeFlowlogsResponseBodyFlowLogsFlowLog) SetStatus(v string) *DescribeFlowlogsResponseBodyFlowLogsFlowLog {
	s.Status = &v
	return s
}

func (s *DescribeFlowlogsResponseBodyFlowLogsFlowLog) SetTags(v *DescribeFlowlogsResponseBodyFlowLogsFlowLogTags) *DescribeFlowlogsResponseBodyFlowLogsFlowLog {
	s.Tags = v
	return s
}

func (s *DescribeFlowlogsResponseBodyFlowLogsFlowLog) SetTransitRouterAttachmentId(v string) *DescribeFlowlogsResponseBodyFlowLogsFlowLog {
	s.TransitRouterAttachmentId = &v
	return s
}

type DescribeFlowlogsResponseBodyFlowLogsFlowLogTags struct {
	Tag []*DescribeFlowlogsResponseBodyFlowLogsFlowLogTagsTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s DescribeFlowlogsResponseBodyFlowLogsFlowLogTags) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowlogsResponseBodyFlowLogsFlowLogTags) GoString() string {
	return s.String()
}

func (s *DescribeFlowlogsResponseBodyFlowLogsFlowLogTags) SetTag(v []*DescribeFlowlogsResponseBodyFlowLogsFlowLogTagsTag) *DescribeFlowlogsResponseBodyFlowLogsFlowLogTags {
	s.Tag = v
	return s
}

type DescribeFlowlogsResponseBodyFlowLogsFlowLogTagsTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s DescribeFlowlogsResponseBodyFlowLogsFlowLogTagsTag) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowlogsResponseBodyFlowLogsFlowLogTagsTag) GoString() string {
	return s.String()
}

func (s *DescribeFlowlogsResponseBodyFlowLogsFlowLogTagsTag) SetKey(v string) *DescribeFlowlogsResponseBodyFlowLogsFlowLogTagsTag {
	s.Key = &v
	return s
}

func (s *DescribeFlowlogsResponseBodyFlowLogsFlowLogTagsTag) SetValue(v string) *DescribeFlowlogsResponseBodyFlowLogsFlowLogTagsTag {
	s.Value = &v
	return s
}

type DescribeFlowlogsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeFlowlogsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeFlowlogsResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeFlowlogsResponse) GoString() string {
	return s.String()
}

func (s *DescribeFlowlogsResponse) SetHeaders(v map[string]*string) *DescribeFlowlogsResponse {
	s.Headers = v
	return s
}

func (s *DescribeFlowlogsResponse) SetStatusCode(v int32) *DescribeFlowlogsResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeFlowlogsResponse) SetBody(v *DescribeFlowlogsResponseBody) *DescribeFlowlogsResponse {
	s.Body = v
	return s
}

type DescribeGeographicRegionMembershipRequest struct {
	GeographicRegionId   *string `json:"GeographicRegionId,omitempty" xml:"GeographicRegionId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PageNumber           *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeGeographicRegionMembershipRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGeographicRegionMembershipRequest) GoString() string {
	return s.String()
}

func (s *DescribeGeographicRegionMembershipRequest) SetGeographicRegionId(v string) *DescribeGeographicRegionMembershipRequest {
	s.GeographicRegionId = &v
	return s
}

func (s *DescribeGeographicRegionMembershipRequest) SetOwnerAccount(v string) *DescribeGeographicRegionMembershipRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeGeographicRegionMembershipRequest) SetOwnerId(v int64) *DescribeGeographicRegionMembershipRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeGeographicRegionMembershipRequest) SetPageNumber(v int32) *DescribeGeographicRegionMembershipRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeGeographicRegionMembershipRequest) SetPageSize(v int32) *DescribeGeographicRegionMembershipRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeGeographicRegionMembershipRequest) SetResourceOwnerAccount(v string) *DescribeGeographicRegionMembershipRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeGeographicRegionMembershipRequest) SetResourceOwnerId(v int64) *DescribeGeographicRegionMembershipRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeGeographicRegionMembershipResponseBody struct {
	PageNumber *int32                                                   `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32                                                   `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RegionIds  *DescribeGeographicRegionMembershipResponseBodyRegionIds `json:"RegionIds,omitempty" xml:"RegionIds,omitempty" type:"Struct"`
	RequestId  *string                                                  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount *int32                                                   `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeGeographicRegionMembershipResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGeographicRegionMembershipResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGeographicRegionMembershipResponseBody) SetPageNumber(v int32) *DescribeGeographicRegionMembershipResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeGeographicRegionMembershipResponseBody) SetPageSize(v int32) *DescribeGeographicRegionMembershipResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeGeographicRegionMembershipResponseBody) SetRegionIds(v *DescribeGeographicRegionMembershipResponseBodyRegionIds) *DescribeGeographicRegionMembershipResponseBody {
	s.RegionIds = v
	return s
}

func (s *DescribeGeographicRegionMembershipResponseBody) SetRequestId(v string) *DescribeGeographicRegionMembershipResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGeographicRegionMembershipResponseBody) SetTotalCount(v int32) *DescribeGeographicRegionMembershipResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeGeographicRegionMembershipResponseBodyRegionIds struct {
	RegionId []*DescribeGeographicRegionMembershipResponseBodyRegionIdsRegionId `json:"RegionId,omitempty" xml:"RegionId,omitempty" type:"Repeated"`
}

func (s DescribeGeographicRegionMembershipResponseBodyRegionIds) String() string {
	return tea.Prettify(s)
}

func (s DescribeGeographicRegionMembershipResponseBodyRegionIds) GoString() string {
	return s.String()
}

func (s *DescribeGeographicRegionMembershipResponseBodyRegionIds) SetRegionId(v []*DescribeGeographicRegionMembershipResponseBodyRegionIdsRegionId) *DescribeGeographicRegionMembershipResponseBodyRegionIds {
	s.RegionId = v
	return s
}

type DescribeGeographicRegionMembershipResponseBodyRegionIdsRegionId struct {
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
}

func (s DescribeGeographicRegionMembershipResponseBodyRegionIdsRegionId) String() string {
	return tea.Prettify(s)
}

func (s DescribeGeographicRegionMembershipResponseBodyRegionIdsRegionId) GoString() string {
	return s.String()
}

func (s *DescribeGeographicRegionMembershipResponseBodyRegionIdsRegionId) SetRegionId(v string) *DescribeGeographicRegionMembershipResponseBodyRegionIdsRegionId {
	s.RegionId = &v
	return s
}

type DescribeGeographicRegionMembershipResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGeographicRegionMembershipResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGeographicRegionMembershipResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGeographicRegionMembershipResponse) GoString() string {
	return s.String()
}

func (s *DescribeGeographicRegionMembershipResponse) SetHeaders(v map[string]*string) *DescribeGeographicRegionMembershipResponse {
	s.Headers = v
	return s
}

func (s *DescribeGeographicRegionMembershipResponse) SetStatusCode(v int32) *DescribeGeographicRegionMembershipResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGeographicRegionMembershipResponse) SetBody(v *DescribeGeographicRegionMembershipResponseBody) *DescribeGeographicRegionMembershipResponse {
	s.Body = v
	return s
}

type DescribeGrantRulesToCenRequest struct {
	// The CEN instance ID.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// ID
	ChildInstanceId *string `json:"ChildInstanceId,omitempty" xml:"ChildInstanceId,omitempty"`
	// ID
	ChildInstanceOwnerId *int64 `json:"ChildInstanceOwnerId,omitempty" xml:"ChildInstanceOwnerId,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **100**.
	//
	// *   If you do not set **MaxResults**, it indicates that you do not need to query results in batches. The value of **MaxResults** in the response indicates the total number of entries.
	// *   If a value is specified for **MaxResults**, it indicates that you need to query results in batches. The value of **MaxResults** in the response indicates the number of entries in the current batch. We recommend that you set **MaxResults** to **20**.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. Valid values:
	//
	// *   You do not need to specify this parameter for the first request.
	// *   You must specify the token that is obtained from the previous query as the value of **NextToken**.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**
	// *   **VBR**
	// *   **CCN**
	// *   **VPN**
	ProductType *string `json:"ProductType,omitempty" xml:"ProductType,omitempty"`
	// The region ID of the network instance.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeGrantRulesToCenRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGrantRulesToCenRequest) GoString() string {
	return s.String()
}

func (s *DescribeGrantRulesToCenRequest) SetCenId(v string) *DescribeGrantRulesToCenRequest {
	s.CenId = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetChildInstanceId(v string) *DescribeGrantRulesToCenRequest {
	s.ChildInstanceId = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetChildInstanceOwnerId(v int64) *DescribeGrantRulesToCenRequest {
	s.ChildInstanceOwnerId = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetMaxResults(v int64) *DescribeGrantRulesToCenRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetNextToken(v string) *DescribeGrantRulesToCenRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetOwnerAccount(v string) *DescribeGrantRulesToCenRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetOwnerId(v int64) *DescribeGrantRulesToCenRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetProductType(v string) *DescribeGrantRulesToCenRequest {
	s.ProductType = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetRegionId(v string) *DescribeGrantRulesToCenRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetResourceOwnerAccount(v string) *DescribeGrantRulesToCenRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeGrantRulesToCenRequest) SetResourceOwnerId(v int64) *DescribeGrantRulesToCenRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeGrantRulesToCenResponseBody struct {
	// The permissions that are granted to the CEN instance.
	GrantRules *DescribeGrantRulesToCenResponseBodyGrantRules `json:"GrantRules,omitempty" xml:"GrantRules,omitempty" type:"Struct"`
	// The number of entries returned per page.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results. Valid values:
	//
	// *   If **NextToken** is empty, no next page exists.
	// *   If a value of **NextToken** was returned in the previous query, specify the value to obtain the next set of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeGrantRulesToCenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGrantRulesToCenResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGrantRulesToCenResponseBody) SetGrantRules(v *DescribeGrantRulesToCenResponseBodyGrantRules) *DescribeGrantRulesToCenResponseBody {
	s.GrantRules = v
	return s
}

func (s *DescribeGrantRulesToCenResponseBody) SetMaxResults(v int64) *DescribeGrantRulesToCenResponseBody {
	s.MaxResults = &v
	return s
}

func (s *DescribeGrantRulesToCenResponseBody) SetNextToken(v string) *DescribeGrantRulesToCenResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeGrantRulesToCenResponseBody) SetRequestId(v string) *DescribeGrantRulesToCenResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGrantRulesToCenResponseBody) SetTotalCount(v int64) *DescribeGrantRulesToCenResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeGrantRulesToCenResponseBodyGrantRules struct {
	GrantRule []*DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule `json:"GrantRule,omitempty" xml:"GrantRule,omitempty" type:"Repeated"`
}

func (s DescribeGrantRulesToCenResponseBodyGrantRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeGrantRulesToCenResponseBodyGrantRules) GoString() string {
	return s.String()
}

func (s *DescribeGrantRulesToCenResponseBodyGrantRules) SetGrantRule(v []*DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule) *DescribeGrantRulesToCenResponseBodyGrantRules {
	s.GrantRule = v
	return s
}

type DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule struct {
	// The CEN instance ID.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the Alibaba Cloud account to which the CEN instance belongs.
	CenOwnerId *int64 `json:"CenOwnerId,omitempty" xml:"CenOwnerId,omitempty"`
	// The network instance ID.
	ChildInstanceId *string `json:"ChildInstanceId,omitempty" xml:"ChildInstanceId,omitempty"`
	// The ID of the Alibaba Cloud account to which the network instance belongs.
	ChildInstanceOwnerId *int64 `json:"ChildInstanceOwnerId,omitempty" xml:"ChildInstanceOwnerId,omitempty"`
	// The region ID of the network instance.
	ChildInstanceRegionId *string `json:"ChildInstanceRegionId,omitempty" xml:"ChildInstanceRegionId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**
	// *   **VBR**
	// *   **CCN**
	// *   **VPN**
	ChildInstanceType *string `json:"ChildInstanceType,omitempty" xml:"ChildInstanceType,omitempty"`
	// The entity that pays the fees of the network instance. Valid values:
	//
	// *   **PayByCenOwner**: the Alibaba Cloud account that owns the CEN instance.
	// *   **PayByResourceOwner**: the Alibaba Cloud account that owns the network instance.
	OrderType *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
}

func (s DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule) String() string {
	return tea.Prettify(s)
}

func (s DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule) GoString() string {
	return s.String()
}

func (s *DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule) SetCenId(v string) *DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule {
	s.CenId = &v
	return s
}

func (s *DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule) SetCenOwnerId(v int64) *DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule {
	s.CenOwnerId = &v
	return s
}

func (s *DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule) SetChildInstanceId(v string) *DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule {
	s.ChildInstanceId = &v
	return s
}

func (s *DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule) SetChildInstanceOwnerId(v int64) *DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule {
	s.ChildInstanceOwnerId = &v
	return s
}

func (s *DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule) SetChildInstanceRegionId(v string) *DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule {
	s.ChildInstanceRegionId = &v
	return s
}

func (s *DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule) SetChildInstanceType(v string) *DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule {
	s.ChildInstanceType = &v
	return s
}

func (s *DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule) SetOrderType(v string) *DescribeGrantRulesToCenResponseBodyGrantRulesGrantRule {
	s.OrderType = &v
	return s
}

type DescribeGrantRulesToCenResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGrantRulesToCenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGrantRulesToCenResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGrantRulesToCenResponse) GoString() string {
	return s.String()
}

func (s *DescribeGrantRulesToCenResponse) SetHeaders(v map[string]*string) *DescribeGrantRulesToCenResponse {
	s.Headers = v
	return s
}

func (s *DescribeGrantRulesToCenResponse) SetStatusCode(v int32) *DescribeGrantRulesToCenResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGrantRulesToCenResponse) SetBody(v *DescribeGrantRulesToCenResponseBody) *DescribeGrantRulesToCenResponse {
	s.Body = v
	return s
}

type DescribeGrantRulesToResourceRequest struct {
	// The operation that you want to perform. Set the value to **DescribeGrantRulesToResource**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query or no next query is to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the value to the value of **NextToken** that was returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the CEN instance.
	ProductType *string `json:"ProductType,omitempty" xml:"ProductType,omitempty"`
	// The ID of the network instance.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: virtual private cloud (VPC)
	// *   **ExpressConnect**: virtual border router (VBR)
	// *   **VPN**: IPsec-VPN connection
	ResourceId           *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeGrantRulesToResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeGrantRulesToResourceRequest) GoString() string {
	return s.String()
}

func (s *DescribeGrantRulesToResourceRequest) SetMaxResults(v int32) *DescribeGrantRulesToResourceRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeGrantRulesToResourceRequest) SetNextToken(v string) *DescribeGrantRulesToResourceRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeGrantRulesToResourceRequest) SetOwnerAccount(v string) *DescribeGrantRulesToResourceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeGrantRulesToResourceRequest) SetOwnerId(v int64) *DescribeGrantRulesToResourceRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeGrantRulesToResourceRequest) SetProductType(v string) *DescribeGrantRulesToResourceRequest {
	s.ProductType = &v
	return s
}

func (s *DescribeGrantRulesToResourceRequest) SetRegionId(v string) *DescribeGrantRulesToResourceRequest {
	s.RegionId = &v
	return s
}

func (s *DescribeGrantRulesToResourceRequest) SetResourceId(v string) *DescribeGrantRulesToResourceRequest {
	s.ResourceId = &v
	return s
}

func (s *DescribeGrantRulesToResourceRequest) SetResourceOwnerAccount(v string) *DescribeGrantRulesToResourceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeGrantRulesToResourceRequest) SetResourceOwnerId(v int64) *DescribeGrantRulesToResourceRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeGrantRulesToResourceResponseBody struct {
	// The ID of the request.
	GrantRules []*DescribeGrantRulesToResourceResponseBodyGrantRules `json:"GrantRules,omitempty" xml:"GrantRules,omitempty" type:"Repeated"`
	// The entity that pays the fees of the network instance. Valid values:
	//
	// *   **PayByCenOwner**: The fees of the connections and data forwarding on the transit router are paid by the Alibaba Cloud account to which the CEN instance belongs.
	// *   **PayByResourceOwner**: The fees of the connections and data forwarding on the transit router are paid by the Alibaba Cloud account to which the network instance belongs.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The ID of the Alibaba Cloud account to which the CEN instance belongs.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region where the network instance is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// *   If you do not set **MaxResults**, it indicates that you do not need to query results in batches. The value of **MaxResults** indicates the total number of entries.
	// *   If you specify a value for **MaxResults**, it indicates that you need to query results in batches. The value of **MaxResults** indicates the number of entries to return in each batch. Valid values: **1** to **100**. The value of **MaxResults** in the response indicates the number of entries in the current batch. We recommend that you set **MaxResults** to **20**.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeGrantRulesToResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeGrantRulesToResourceResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeGrantRulesToResourceResponseBody) SetGrantRules(v []*DescribeGrantRulesToResourceResponseBodyGrantRules) *DescribeGrantRulesToResourceResponseBody {
	s.GrantRules = v
	return s
}

func (s *DescribeGrantRulesToResourceResponseBody) SetMaxResults(v int32) *DescribeGrantRulesToResourceResponseBody {
	s.MaxResults = &v
	return s
}

func (s *DescribeGrantRulesToResourceResponseBody) SetNextToken(v string) *DescribeGrantRulesToResourceResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeGrantRulesToResourceResponseBody) SetRequestId(v string) *DescribeGrantRulesToResourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeGrantRulesToResourceResponseBody) SetTotalCount(v int32) *DescribeGrantRulesToResourceResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeGrantRulesToResourceResponseBodyGrantRules struct {
	CenId      *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	CenOwnerId *int64  `json:"CenOwnerId,omitempty" xml:"CenOwnerId,omitempty"`
	OrderType  *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
}

func (s DescribeGrantRulesToResourceResponseBodyGrantRules) String() string {
	return tea.Prettify(s)
}

func (s DescribeGrantRulesToResourceResponseBodyGrantRules) GoString() string {
	return s.String()
}

func (s *DescribeGrantRulesToResourceResponseBodyGrantRules) SetCenId(v string) *DescribeGrantRulesToResourceResponseBodyGrantRules {
	s.CenId = &v
	return s
}

func (s *DescribeGrantRulesToResourceResponseBodyGrantRules) SetCenOwnerId(v int64) *DescribeGrantRulesToResourceResponseBodyGrantRules {
	s.CenOwnerId = &v
	return s
}

func (s *DescribeGrantRulesToResourceResponseBodyGrantRules) SetOrderType(v string) *DescribeGrantRulesToResourceResponseBodyGrantRules {
	s.OrderType = &v
	return s
}

type DescribeGrantRulesToResourceResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeGrantRulesToResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeGrantRulesToResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeGrantRulesToResourceResponse) GoString() string {
	return s.String()
}

func (s *DescribeGrantRulesToResourceResponse) SetHeaders(v map[string]*string) *DescribeGrantRulesToResourceResponse {
	s.Headers = v
	return s
}

func (s *DescribeGrantRulesToResourceResponse) SetStatusCode(v int32) *DescribeGrantRulesToResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeGrantRulesToResourceResponse) SetBody(v *DescribeGrantRulesToResourceResponseBody) *DescribeGrantRulesToResourceResponse {
	s.Body = v
	return s
}

type DescribePublishedRouteEntriesRequest struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the network instance.
	ChildInstanceId *string `json:"ChildInstanceId,omitempty" xml:"ChildInstanceId,omitempty"`
	// The ID of the region where the network instance is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	ChildInstanceRegionId *string `json:"ChildInstanceRegionId,omitempty" xml:"ChildInstanceRegionId,omitempty"`
	// The ID of the route table of the network instance.
	ChildInstanceRouteTableId *string `json:"ChildInstanceRouteTableId,omitempty" xml:"ChildInstanceRouteTableId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: VPC
	// *   **VBR**: VBR
	// *   **CCN**: Cloud Connect Network (CCN) instance
	ChildInstanceType *string `json:"ChildInstanceType,omitempty" xml:"ChildInstanceType,omitempty"`
	// The destination CIDR block of the route that you want to query.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Valid values: **1** to **50**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribePublishedRouteEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribePublishedRouteEntriesRequest) GoString() string {
	return s.String()
}

func (s *DescribePublishedRouteEntriesRequest) SetCenId(v string) *DescribePublishedRouteEntriesRequest {
	s.CenId = &v
	return s
}

func (s *DescribePublishedRouteEntriesRequest) SetChildInstanceId(v string) *DescribePublishedRouteEntriesRequest {
	s.ChildInstanceId = &v
	return s
}

func (s *DescribePublishedRouteEntriesRequest) SetChildInstanceRegionId(v string) *DescribePublishedRouteEntriesRequest {
	s.ChildInstanceRegionId = &v
	return s
}

func (s *DescribePublishedRouteEntriesRequest) SetChildInstanceRouteTableId(v string) *DescribePublishedRouteEntriesRequest {
	s.ChildInstanceRouteTableId = &v
	return s
}

func (s *DescribePublishedRouteEntriesRequest) SetChildInstanceType(v string) *DescribePublishedRouteEntriesRequest {
	s.ChildInstanceType = &v
	return s
}

func (s *DescribePublishedRouteEntriesRequest) SetDestinationCidrBlock(v string) *DescribePublishedRouteEntriesRequest {
	s.DestinationCidrBlock = &v
	return s
}

func (s *DescribePublishedRouteEntriesRequest) SetPageNumber(v int32) *DescribePublishedRouteEntriesRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribePublishedRouteEntriesRequest) SetPageSize(v int32) *DescribePublishedRouteEntriesRequest {
	s.PageSize = &v
	return s
}

func (s *DescribePublishedRouteEntriesRequest) SetResourceOwnerAccount(v string) *DescribePublishedRouteEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribePublishedRouteEntriesRequest) SetResourceOwnerId(v int64) *DescribePublishedRouteEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribePublishedRouteEntriesResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// A list of routes.
	PublishedRouteEntries *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntries `json:"PublishedRouteEntries,omitempty" xml:"PublishedRouteEntries,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribePublishedRouteEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribePublishedRouteEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *DescribePublishedRouteEntriesResponseBody) SetPageNumber(v int32) *DescribePublishedRouteEntriesResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribePublishedRouteEntriesResponseBody) SetPageSize(v int32) *DescribePublishedRouteEntriesResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribePublishedRouteEntriesResponseBody) SetPublishedRouteEntries(v *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntries) *DescribePublishedRouteEntriesResponseBody {
	s.PublishedRouteEntries = v
	return s
}

func (s *DescribePublishedRouteEntriesResponseBody) SetRequestId(v string) *DescribePublishedRouteEntriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribePublishedRouteEntriesResponseBody) SetTotalCount(v int32) *DescribePublishedRouteEntriesResponseBody {
	s.TotalCount = &v
	return s
}

type DescribePublishedRouteEntriesResponseBodyPublishedRouteEntries struct {
	PublishedRouteEntry []*DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry `json:"PublishedRouteEntry,omitempty" xml:"PublishedRouteEntry,omitempty" type:"Repeated"`
}

func (s DescribePublishedRouteEntriesResponseBodyPublishedRouteEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribePublishedRouteEntriesResponseBodyPublishedRouteEntries) GoString() string {
	return s.String()
}

func (s *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntries) SetPublishedRouteEntry(v []*DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry) *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntries {
	s.PublishedRouteEntry = v
	return s
}

type DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry struct {
	// The ID of the route table configured on the network instance.
	ChildInstanceRouteTableId *string `json:"ChildInstanceRouteTableId,omitempty" xml:"ChildInstanceRouteTableId,omitempty"`
	// A list of conflicting routes.
	Conflicts *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflicts `json:"Conflicts,omitempty" xml:"Conflicts,omitempty" type:"Struct"`
	// The destination CIDR block of the route.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The ID of the instance specified as the next hop in the route.
	NextHopId *string `json:"NextHopId,omitempty" xml:"NextHopId,omitempty"`
	// The type of the instance specified as the next hop in the route.
	//
	// *   **Instance**: ECS instance
	// *   **HaVip**: high-availability virtual IP address (HAVIP).
	// *   **RouterInterface**: router interface.
	// *   **NetworkInterface**: elastic network interface (ENI).
	// *   **VpnGateway**: VPN gateway.
	// *   **IPv6Gateway**: IPv6 gateway.
	// *   **NatGateway**: NAT gateway.
	// *   **Attachment**: network instance connection
	// *   **service**: cloud service
	// *   **VBR**: VBR
	// *   **CCN**: CCN instance
	// *   **VPC**: VPC
	// *   **local**: system route. No next hop is specified.
	// *   **TR**: transit router
	// *   \*\*BlackHole\*\*: blackhole route. No next hop is specified.
	// *   \*\*EcRouterInterface\*\*: router interface for Express Connect
	// *   **HealthCheck**: health check
	// *   **AS**: access gateway for CCN
	// *   **classicLink**: classic network-type instance
	// *   **GatewayEndpoint**: gateway endpoint
	// *   **CPE**: data center connected to the VBR
	NextHopType *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	// Indicates whether the route is allowed to be advertised to or withdrawn from the CEN instance. Valid values:
	//
	// *   **true**: The route is allowed to be advertised to or withdrawn from the CEN instance.
	// *   **false**: The route is not allowed to be advertised to or withdrawn from the CEN instance.
	OperationalMode *bool `json:"OperationalMode,omitempty" xml:"OperationalMode,omitempty"`
	// Indicates whether the route is advertised to the CEN instance. Valid values:
	//
	// *   **Published**: The route is advertised to the CEN instance.
	// *   **NonPublished**: The route is not advertised to the CEN instance.
	PublishStatus *string `json:"PublishStatus,omitempty" xml:"PublishStatus,omitempty"`
	// The type of the route. Valid values:
	//
	// *   **CEN**: route that is advertised through CEN
	// *   **System**: system route
	// *   **Custom**: custom route
	RouteType *string `json:"RouteType,omitempty" xml:"RouteType,omitempty"`
}

func (s DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry) GoString() string {
	return s.String()
}

func (s *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry) SetChildInstanceRouteTableId(v string) *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry {
	s.ChildInstanceRouteTableId = &v
	return s
}

func (s *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry) SetConflicts(v *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflicts) *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry {
	s.Conflicts = v
	return s
}

func (s *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry) SetDestinationCidrBlock(v string) *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry {
	s.DestinationCidrBlock = &v
	return s
}

func (s *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry) SetNextHopId(v string) *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry {
	s.NextHopId = &v
	return s
}

func (s *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry) SetNextHopType(v string) *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry {
	s.NextHopType = &v
	return s
}

func (s *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry) SetOperationalMode(v bool) *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry {
	s.OperationalMode = &v
	return s
}

func (s *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry) SetPublishStatus(v string) *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry {
	s.PublishStatus = &v
	return s
}

func (s *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry) SetRouteType(v string) *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntry {
	s.RouteType = &v
	return s
}

type DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflicts struct {
	Conflict []*DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflictsConflict `json:"Conflict,omitempty" xml:"Conflict,omitempty" type:"Repeated"`
}

func (s DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflicts) String() string {
	return tea.Prettify(s)
}

func (s DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflicts) GoString() string {
	return s.String()
}

func (s *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflicts) SetConflict(v []*DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflictsConflict) *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflicts {
	s.Conflict = v
	return s
}

type DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflictsConflict struct {
	// The destination CIDR block of the conflicting route.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The ID of the peer network instance on which conflicting routes are found.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the peer network instance on which the conflicting routes are found. Valid values:
	//
	// *   **VPC**: VPC
	// *   **VBR**: VBR
	// *   **CCN**: CCN instance
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The ID of the region where the peer network instance on which the conflicting routes are found is deployed.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The cause of the route confliction. Valid values:
	//
	// *   **conflict**: The routes have the same destination CIDR block.
	// *   **overflow**: The number of routes in the route table configured on another network instance has reached the upper limit.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflictsConflict) String() string {
	return tea.Prettify(s)
}

func (s DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflictsConflict) GoString() string {
	return s.String()
}

func (s *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflictsConflict) SetDestinationCidrBlock(v string) *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflictsConflict {
	s.DestinationCidrBlock = &v
	return s
}

func (s *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflictsConflict) SetInstanceId(v string) *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflictsConflict {
	s.InstanceId = &v
	return s
}

func (s *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflictsConflict) SetInstanceType(v string) *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflictsConflict {
	s.InstanceType = &v
	return s
}

func (s *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflictsConflict) SetRegionId(v string) *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflictsConflict {
	s.RegionId = &v
	return s
}

func (s *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflictsConflict) SetStatus(v string) *DescribePublishedRouteEntriesResponseBodyPublishedRouteEntriesPublishedRouteEntryConflictsConflict {
	s.Status = &v
	return s
}

type DescribePublishedRouteEntriesResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribePublishedRouteEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribePublishedRouteEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribePublishedRouteEntriesResponse) GoString() string {
	return s.String()
}

func (s *DescribePublishedRouteEntriesResponse) SetHeaders(v map[string]*string) *DescribePublishedRouteEntriesResponse {
	s.Headers = v
	return s
}

func (s *DescribePublishedRouteEntriesResponse) SetStatusCode(v int32) *DescribePublishedRouteEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribePublishedRouteEntriesResponse) SetBody(v *DescribePublishedRouteEntriesResponseBody) *DescribePublishedRouteEntriesResponse {
	s.Body = v
	return s
}

type DescribeRouteConflictRequest struct {
	// The ID of the network instance that you want to query.
	ChildInstanceId *string `json:"ChildInstanceId,omitempty" xml:"ChildInstanceId,omitempty"`
	// The ID of the region where the network instance is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	ChildInstanceRegionId *string `json:"ChildInstanceRegionId,omitempty" xml:"ChildInstanceRegionId,omitempty"`
	// The ID of the route table that is configured on the network instance.
	ChildInstanceRouteTableId *string `json:"ChildInstanceRouteTableId,omitempty" xml:"ChildInstanceRouteTableId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: virtual private cloud (VPC)
	// *   **VBR**: virtual border router (VBR)
	// *   **CCN**: Cloud Connect Network (CCN) instance
	ChildInstanceType *string `json:"ChildInstanceType,omitempty" xml:"ChildInstanceType,omitempty"`
	// The destination CIDR block of the conflicting route.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: **10**. Valid values: **1** to **50**.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeRouteConflictRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteConflictRequest) GoString() string {
	return s.String()
}

func (s *DescribeRouteConflictRequest) SetChildInstanceId(v string) *DescribeRouteConflictRequest {
	s.ChildInstanceId = &v
	return s
}

func (s *DescribeRouteConflictRequest) SetChildInstanceRegionId(v string) *DescribeRouteConflictRequest {
	s.ChildInstanceRegionId = &v
	return s
}

func (s *DescribeRouteConflictRequest) SetChildInstanceRouteTableId(v string) *DescribeRouteConflictRequest {
	s.ChildInstanceRouteTableId = &v
	return s
}

func (s *DescribeRouteConflictRequest) SetChildInstanceType(v string) *DescribeRouteConflictRequest {
	s.ChildInstanceType = &v
	return s
}

func (s *DescribeRouteConflictRequest) SetDestinationCidrBlock(v string) *DescribeRouteConflictRequest {
	s.DestinationCidrBlock = &v
	return s
}

func (s *DescribeRouteConflictRequest) SetOwnerAccount(v string) *DescribeRouteConflictRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeRouteConflictRequest) SetOwnerId(v int64) *DescribeRouteConflictRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRouteConflictRequest) SetPageNumber(v int32) *DescribeRouteConflictRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeRouteConflictRequest) SetPageSize(v int32) *DescribeRouteConflictRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeRouteConflictRequest) SetResourceOwnerAccount(v string) *DescribeRouteConflictRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRouteConflictRequest) SetResourceOwnerId(v int64) *DescribeRouteConflictRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeRouteConflictResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// A list of overlapping routes.
	RouteConflicts *DescribeRouteConflictResponseBodyRouteConflicts `json:"RouteConflicts,omitempty" xml:"RouteConflicts,omitempty" type:"Struct"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeRouteConflictResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteConflictResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRouteConflictResponseBody) SetPageNumber(v int32) *DescribeRouteConflictResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeRouteConflictResponseBody) SetPageSize(v int32) *DescribeRouteConflictResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeRouteConflictResponseBody) SetRequestId(v string) *DescribeRouteConflictResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRouteConflictResponseBody) SetRouteConflicts(v *DescribeRouteConflictResponseBodyRouteConflicts) *DescribeRouteConflictResponseBody {
	s.RouteConflicts = v
	return s
}

func (s *DescribeRouteConflictResponseBody) SetTotalCount(v int32) *DescribeRouteConflictResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeRouteConflictResponseBodyRouteConflicts struct {
	RouteConflict []*DescribeRouteConflictResponseBodyRouteConflictsRouteConflict `json:"RouteConflict,omitempty" xml:"RouteConflict,omitempty" type:"Repeated"`
}

func (s DescribeRouteConflictResponseBodyRouteConflicts) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteConflictResponseBodyRouteConflicts) GoString() string {
	return s.String()
}

func (s *DescribeRouteConflictResponseBodyRouteConflicts) SetRouteConflict(v []*DescribeRouteConflictResponseBodyRouteConflictsRouteConflict) *DescribeRouteConflictResponseBodyRouteConflicts {
	s.RouteConflict = v
	return s
}

type DescribeRouteConflictResponseBodyRouteConflictsRouteConflict struct {
	// The destination CIDR block of the overlapping route.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// The ID of the peer network instance on which the overlapping routes are found.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the peer network instance on which the overlapping routes are found.
	//
	// *   **VPC**: VPC
	// *   **VBR**: VBR
	// *   **CCN**: CCN instance
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	// The region ID of the peer network instance on which the overlapping routes are found is deployed.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The cause of the route error. Valid values:
	//
	// *   **conflict**: The routes have the same destination CIDR block.
	// *   **overflow**: The number of routes in the route table configured on another network instance has reached the upper limit.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeRouteConflictResponseBodyRouteConflictsRouteConflict) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteConflictResponseBodyRouteConflictsRouteConflict) GoString() string {
	return s.String()
}

func (s *DescribeRouteConflictResponseBodyRouteConflictsRouteConflict) SetDestinationCidrBlock(v string) *DescribeRouteConflictResponseBodyRouteConflictsRouteConflict {
	s.DestinationCidrBlock = &v
	return s
}

func (s *DescribeRouteConflictResponseBodyRouteConflictsRouteConflict) SetInstanceId(v string) *DescribeRouteConflictResponseBodyRouteConflictsRouteConflict {
	s.InstanceId = &v
	return s
}

func (s *DescribeRouteConflictResponseBodyRouteConflictsRouteConflict) SetInstanceType(v string) *DescribeRouteConflictResponseBodyRouteConflictsRouteConflict {
	s.InstanceType = &v
	return s
}

func (s *DescribeRouteConflictResponseBodyRouteConflictsRouteConflict) SetRegionId(v string) *DescribeRouteConflictResponseBodyRouteConflictsRouteConflict {
	s.RegionId = &v
	return s
}

func (s *DescribeRouteConflictResponseBodyRouteConflictsRouteConflict) SetStatus(v string) *DescribeRouteConflictResponseBodyRouteConflictsRouteConflict {
	s.Status = &v
	return s
}

type DescribeRouteConflictResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRouteConflictResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRouteConflictResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteConflictResponse) GoString() string {
	return s.String()
}

func (s *DescribeRouteConflictResponse) SetHeaders(v map[string]*string) *DescribeRouteConflictResponse {
	s.Headers = v
	return s
}

func (s *DescribeRouteConflictResponse) SetStatusCode(v int32) *DescribeRouteConflictResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRouteConflictResponse) SetBody(v *DescribeRouteConflictResponseBody) *DescribeRouteConflictResponse {
	s.Body = v
	return s
}

type DescribeRouteServicesInCenRequest struct {
	// The operation that you want to perform. Set the value to **DescribeRouteServicesInCen**.
	AccessRegionId *string `json:"AccessRegionId,omitempty" xml:"AccessRegionId,omitempty"`
	// The information about the cloud services.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The description of the cloud service.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The status of the cloud service. Valid values:
	//
	// *   **Creating**: The cloud service is being created.
	// *   **Active**: The cloud service is available.
	// *   **Deleting**: The cloud service is being deleted.
	HostRegionId *string `json:"HostRegionId,omitempty" xml:"HostRegionId,omitempty"`
	// The ID of the region where the cloud service is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	HostVpcId    *string `json:"HostVpcId,omitempty" xml:"HostVpcId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the virtual private cloud (VPC) that is associated with the cloud service.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the CEN instance.
	PageSize             *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DescribeRouteServicesInCenRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteServicesInCenRequest) GoString() string {
	return s.String()
}

func (s *DescribeRouteServicesInCenRequest) SetAccessRegionId(v string) *DescribeRouteServicesInCenRequest {
	s.AccessRegionId = &v
	return s
}

func (s *DescribeRouteServicesInCenRequest) SetCenId(v string) *DescribeRouteServicesInCenRequest {
	s.CenId = &v
	return s
}

func (s *DescribeRouteServicesInCenRequest) SetHost(v string) *DescribeRouteServicesInCenRequest {
	s.Host = &v
	return s
}

func (s *DescribeRouteServicesInCenRequest) SetHostRegionId(v string) *DescribeRouteServicesInCenRequest {
	s.HostRegionId = &v
	return s
}

func (s *DescribeRouteServicesInCenRequest) SetHostVpcId(v string) *DescribeRouteServicesInCenRequest {
	s.HostVpcId = &v
	return s
}

func (s *DescribeRouteServicesInCenRequest) SetOwnerAccount(v string) *DescribeRouteServicesInCenRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeRouteServicesInCenRequest) SetOwnerId(v int64) *DescribeRouteServicesInCenRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeRouteServicesInCenRequest) SetPageNumber(v int32) *DescribeRouteServicesInCenRequest {
	s.PageNumber = &v
	return s
}

func (s *DescribeRouteServicesInCenRequest) SetPageSize(v int32) *DescribeRouteServicesInCenRequest {
	s.PageSize = &v
	return s
}

func (s *DescribeRouteServicesInCenRequest) SetResourceOwnerAccount(v string) *DescribeRouteServicesInCenRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeRouteServicesInCenRequest) SetResourceOwnerId(v int64) *DescribeRouteServicesInCenRequest {
	s.ResourceOwnerId = &v
	return s
}

type DescribeRouteServicesInCenResponseBody struct {
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the region where the cloud service is deployed.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the cloud service is accessed.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the region where the cloud service is accessed.
	RouteServiceEntries *DescribeRouteServicesInCenResponseBodyRouteServiceEntries `json:"RouteServiceEntries,omitempty" xml:"RouteServiceEntries,omitempty" type:"Struct"`
	// The ID of the VPC that is associated with the cloud service.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s DescribeRouteServicesInCenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteServicesInCenResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeRouteServicesInCenResponseBody) SetPageNumber(v int32) *DescribeRouteServicesInCenResponseBody {
	s.PageNumber = &v
	return s
}

func (s *DescribeRouteServicesInCenResponseBody) SetPageSize(v int32) *DescribeRouteServicesInCenResponseBody {
	s.PageSize = &v
	return s
}

func (s *DescribeRouteServicesInCenResponseBody) SetRequestId(v string) *DescribeRouteServicesInCenResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeRouteServicesInCenResponseBody) SetRouteServiceEntries(v *DescribeRouteServicesInCenResponseBodyRouteServiceEntries) *DescribeRouteServicesInCenResponseBody {
	s.RouteServiceEntries = v
	return s
}

func (s *DescribeRouteServicesInCenResponseBody) SetTotalCount(v int32) *DescribeRouteServicesInCenResponseBody {
	s.TotalCount = &v
	return s
}

type DescribeRouteServicesInCenResponseBodyRouteServiceEntries struct {
	RouteServiceEntry []*DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry `json:"RouteServiceEntry,omitempty" xml:"RouteServiceEntry,omitempty" type:"Repeated"`
}

func (s DescribeRouteServicesInCenResponseBodyRouteServiceEntries) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteServicesInCenResponseBodyRouteServiceEntries) GoString() string {
	return s.String()
}

func (s *DescribeRouteServicesInCenResponseBodyRouteServiceEntries) SetRouteServiceEntry(v []*DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry) *DescribeRouteServicesInCenResponseBodyRouteServiceEntries {
	s.RouteServiceEntry = v
	return s
}

type DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry struct {
	// Queries the cloud services that are configured on a Cloud Enterprise Network (CEN) instance.
	AccessRegionId *string `json:"AccessRegionId,omitempty" xml:"AccessRegionId,omitempty"`
	// The ID of the request.
	CenId *string                                                                          `json:"CenId,omitempty" xml:"CenId,omitempty"`
	Cidrs *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntryCidrs `json:"Cidrs,omitempty" xml:"Cidrs,omitempty" type:"Struct"`
	// The service address of the cloud service.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The number of the returned page.
	Host         *string `json:"Host,omitempty" xml:"Host,omitempty"`
	HostRegionId *string `json:"HostRegionId,omitempty" xml:"HostRegionId,omitempty"`
	// The number of entries returned per page.
	HostVpcId *string `json:"HostVpcId,omitempty" xml:"HostVpcId,omitempty"`
	// The service address of the cloud service.
	//
	// You can enter a domain name, an IP address, or a CIDR block.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry) GoString() string {
	return s.String()
}

func (s *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry) SetAccessRegionId(v string) *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry {
	s.AccessRegionId = &v
	return s
}

func (s *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry) SetCenId(v string) *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry {
	s.CenId = &v
	return s
}

func (s *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry) SetCidrs(v *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntryCidrs) *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry {
	s.Cidrs = v
	return s
}

func (s *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry) SetDescription(v string) *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry {
	s.Description = &v
	return s
}

func (s *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry) SetHost(v string) *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry {
	s.Host = &v
	return s
}

func (s *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry) SetHostRegionId(v string) *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry {
	s.HostRegionId = &v
	return s
}

func (s *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry) SetHostVpcId(v string) *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry {
	s.HostVpcId = &v
	return s
}

func (s *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry) SetStatus(v string) *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntry {
	s.Status = &v
	return s
}

type DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntryCidrs struct {
	Cidr []*string `json:"Cidr,omitempty" xml:"Cidr,omitempty" type:"Repeated"`
}

func (s DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntryCidrs) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntryCidrs) GoString() string {
	return s.String()
}

func (s *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntryCidrs) SetCidr(v []*string) *DescribeRouteServicesInCenResponseBodyRouteServiceEntriesRouteServiceEntryCidrs {
	s.Cidr = v
	return s
}

type DescribeRouteServicesInCenResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeRouteServicesInCenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeRouteServicesInCenResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeRouteServicesInCenResponse) GoString() string {
	return s.String()
}

func (s *DescribeRouteServicesInCenResponse) SetHeaders(v map[string]*string) *DescribeRouteServicesInCenResponse {
	s.Headers = v
	return s
}

func (s *DescribeRouteServicesInCenResponse) SetStatusCode(v int32) *DescribeRouteServicesInCenResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeRouteServicesInCenResponse) SetBody(v *DescribeRouteServicesInCenResponseBody) *DescribeRouteServicesInCenResponse {
	s.Body = v
	return s
}

type DescribeTransitRouteTableAggregationRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can only contain ASCII characters.
	//
	// >  If you do not set this parameter, ClientToken is set to the value of RequestId. The value of RequestId for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The number of entries to return on each page. Default value: **20**.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query or no subsequent query is to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the value to the value of **NextToken** that is returned from the last call.
	NextToken            *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block of the aggregate route.
	TransitRouteTableAggregationCidr *string `json:"TransitRouteTableAggregationCidr,omitempty" xml:"TransitRouteTableAggregationCidr,omitempty"`
	// The ID of the route table of the Enterprise Edition transit router.
	TransitRouteTableId *string `json:"TransitRouteTableId,omitempty" xml:"TransitRouteTableId,omitempty"`
}

func (s DescribeTransitRouteTableAggregationRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTransitRouteTableAggregationRequest) GoString() string {
	return s.String()
}

func (s *DescribeTransitRouteTableAggregationRequest) SetClientToken(v string) *DescribeTransitRouteTableAggregationRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationRequest) SetMaxResults(v int64) *DescribeTransitRouteTableAggregationRequest {
	s.MaxResults = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationRequest) SetNextToken(v string) *DescribeTransitRouteTableAggregationRequest {
	s.NextToken = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationRequest) SetOwnerAccount(v string) *DescribeTransitRouteTableAggregationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationRequest) SetOwnerId(v int64) *DescribeTransitRouteTableAggregationRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationRequest) SetResourceOwnerAccount(v string) *DescribeTransitRouteTableAggregationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationRequest) SetResourceOwnerId(v int64) *DescribeTransitRouteTableAggregationRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationRequest) SetTransitRouteTableAggregationCidr(v string) *DescribeTransitRouteTableAggregationRequest {
	s.TransitRouteTableAggregationCidr = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationRequest) SetTransitRouteTableId(v string) *DescribeTransitRouteTableAggregationRequest {
	s.TransitRouteTableId = &v
	return s
}

type DescribeTransitRouteTableAggregationResponseBody struct {
	// The number of entries returned per page.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// A list of aggregate routes.
	Data []*DescribeTransitRouteTableAggregationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The token that determines the start point of the next query. Valid values:
	//
	// *   If **NextToken** is not returned, it indicates that no additional results exist.
	// *   If **NextToken** was returned in the previous query, specify the value to obtain the next set of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeTransitRouteTableAggregationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTransitRouteTableAggregationResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTransitRouteTableAggregationResponseBody) SetCount(v int32) *DescribeTransitRouteTableAggregationResponseBody {
	s.Count = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationResponseBody) SetData(v []*DescribeTransitRouteTableAggregationResponseBodyData) *DescribeTransitRouteTableAggregationResponseBody {
	s.Data = v
	return s
}

func (s *DescribeTransitRouteTableAggregationResponseBody) SetNextToken(v string) *DescribeTransitRouteTableAggregationResponseBody {
	s.NextToken = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationResponseBody) SetRequestId(v string) *DescribeTransitRouteTableAggregationResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationResponseBody) SetTotal(v int32) *DescribeTransitRouteTableAggregationResponseBody {
	s.Total = &v
	return s
}

type DescribeTransitRouteTableAggregationResponseBodyData struct {
	// The description of the aggregate route.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the aggregate route.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the aggregate route.
	//
	// The valid value is **Static**, which indicates a static route. By default, aggregate routes advertised to a VPC are considered custom routes.
	RouteType *string `json:"RouteType,omitempty" xml:"RouteType,omitempty"`
	// The cope of networks to which the aggregate route is advertised.
	//
	// The valid value is **VPC**, which indicates that the aggregate route is advertised to all virtual private clouds (VPCs) that are in associated forwarding correlation with the Enterprise Edition transit router and have route synchronization enabled.
	Scope *string `json:"Scope,omitempty" xml:"Scope,omitempty"`
	// The status of the advertisement of the aggregate route. Valid values:
	//
	// *   **AllConfigured**: The aggregate route is advertised to all VPCs.
	// *   **Configuring**: The aggregate route is being advertised.
	// *   **ConfigFailed**: The aggregate route failed to be advertised.
	// *   **PartialConfigured**: Failed to advertise the aggregate route to some VPCs.
	// *   **Deleting**: The aggregate route is being deleted.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the route table of the Enterprise Edition transit router.
	TrRouteTableId *string `json:"TrRouteTableId,omitempty" xml:"TrRouteTableId,omitempty"`
	// The destination CIDR block of the aggregate route.
	TransitRouteTableAggregationCidr *string `json:"TransitRouteTableAggregationCidr,omitempty" xml:"TransitRouteTableAggregationCidr,omitempty"`
}

func (s DescribeTransitRouteTableAggregationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeTransitRouteTableAggregationResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeTransitRouteTableAggregationResponseBodyData) SetDescription(v string) *DescribeTransitRouteTableAggregationResponseBodyData {
	s.Description = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationResponseBodyData) SetName(v string) *DescribeTransitRouteTableAggregationResponseBodyData {
	s.Name = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationResponseBodyData) SetRouteType(v string) *DescribeTransitRouteTableAggregationResponseBodyData {
	s.RouteType = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationResponseBodyData) SetScope(v string) *DescribeTransitRouteTableAggregationResponseBodyData {
	s.Scope = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationResponseBodyData) SetStatus(v string) *DescribeTransitRouteTableAggregationResponseBodyData {
	s.Status = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationResponseBodyData) SetTrRouteTableId(v string) *DescribeTransitRouteTableAggregationResponseBodyData {
	s.TrRouteTableId = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationResponseBodyData) SetTransitRouteTableAggregationCidr(v string) *DescribeTransitRouteTableAggregationResponseBodyData {
	s.TransitRouteTableAggregationCidr = &v
	return s
}

type DescribeTransitRouteTableAggregationResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeTransitRouteTableAggregationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeTransitRouteTableAggregationResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTransitRouteTableAggregationResponse) GoString() string {
	return s.String()
}

func (s *DescribeTransitRouteTableAggregationResponse) SetHeaders(v map[string]*string) *DescribeTransitRouteTableAggregationResponse {
	s.Headers = v
	return s
}

func (s *DescribeTransitRouteTableAggregationResponse) SetStatusCode(v int32) *DescribeTransitRouteTableAggregationResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationResponse) SetBody(v *DescribeTransitRouteTableAggregationResponseBody) *DescribeTransitRouteTableAggregationResponse {
	s.Body = v
	return s
}

type DescribeTransitRouteTableAggregationDetailRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, ClientToken is set to the value of RequestId. The value of RequestId may be different for each request.
	ClientToken          *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The destination CIDR block of the aggregate route.
	TransitRouteTableAggregationCidr *string `json:"TransitRouteTableAggregationCidr,omitempty" xml:"TransitRouteTableAggregationCidr,omitempty"`
	// The ID of the route table of the Enterprise Edition transit router.
	TransitRouteTableId *string `json:"TransitRouteTableId,omitempty" xml:"TransitRouteTableId,omitempty"`
}

func (s DescribeTransitRouteTableAggregationDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s DescribeTransitRouteTableAggregationDetailRequest) GoString() string {
	return s.String()
}

func (s *DescribeTransitRouteTableAggregationDetailRequest) SetClientToken(v string) *DescribeTransitRouteTableAggregationDetailRequest {
	s.ClientToken = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationDetailRequest) SetOwnerAccount(v string) *DescribeTransitRouteTableAggregationDetailRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationDetailRequest) SetOwnerId(v int64) *DescribeTransitRouteTableAggregationDetailRequest {
	s.OwnerId = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationDetailRequest) SetResourceOwnerAccount(v string) *DescribeTransitRouteTableAggregationDetailRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationDetailRequest) SetResourceOwnerId(v int64) *DescribeTransitRouteTableAggregationDetailRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationDetailRequest) SetTransitRouteTableAggregationCidr(v string) *DescribeTransitRouteTableAggregationDetailRequest {
	s.TransitRouteTableAggregationCidr = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationDetailRequest) SetTransitRouteTableId(v string) *DescribeTransitRouteTableAggregationDetailRequest {
	s.TransitRouteTableId = &v
	return s
}

type DescribeTransitRouteTableAggregationDetailResponseBody struct {
	// The number of entries returned on each page.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The configuration of the aggregate route.
	Data []*DescribeTransitRouteTableAggregationDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s DescribeTransitRouteTableAggregationDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DescribeTransitRouteTableAggregationDetailResponseBody) GoString() string {
	return s.String()
}

func (s *DescribeTransitRouteTableAggregationDetailResponseBody) SetCount(v int32) *DescribeTransitRouteTableAggregationDetailResponseBody {
	s.Count = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationDetailResponseBody) SetData(v []*DescribeTransitRouteTableAggregationDetailResponseBodyData) *DescribeTransitRouteTableAggregationDetailResponseBody {
	s.Data = v
	return s
}

func (s *DescribeTransitRouteTableAggregationDetailResponseBody) SetRequestId(v string) *DescribeTransitRouteTableAggregationDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationDetailResponseBody) SetTotal(v int32) *DescribeTransitRouteTableAggregationDetailResponseBody {
	s.Total = &v
	return s
}

type DescribeTransitRouteTableAggregationDetailResponseBodyData struct {
	// The error message returned if the configuration of the aggregate route fails.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the virtual private cloud (VPC) for which the aggregate route is configured.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The status of the aggregate route. Valid values:
	//
	// *   **Configured**: The aggregate route is advertised to the VPC.
	// *   **Configuring**: The aggregate route is being advertised.
	// *   **ConfigFailed**: The aggregate route failed to be advertised.
	// *   **PartialConfigured**: Failed to advertise the aggregate route to some VPCs.
	// *   **Deleting**: The aggregate route is being deleted.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DescribeTransitRouteTableAggregationDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DescribeTransitRouteTableAggregationDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *DescribeTransitRouteTableAggregationDetailResponseBodyData) SetDescription(v string) *DescribeTransitRouteTableAggregationDetailResponseBodyData {
	s.Description = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationDetailResponseBodyData) SetInstanceId(v string) *DescribeTransitRouteTableAggregationDetailResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationDetailResponseBodyData) SetStatus(v string) *DescribeTransitRouteTableAggregationDetailResponseBodyData {
	s.Status = &v
	return s
}

type DescribeTransitRouteTableAggregationDetailResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DescribeTransitRouteTableAggregationDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DescribeTransitRouteTableAggregationDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s DescribeTransitRouteTableAggregationDetailResponse) GoString() string {
	return s.String()
}

func (s *DescribeTransitRouteTableAggregationDetailResponse) SetHeaders(v map[string]*string) *DescribeTransitRouteTableAggregationDetailResponse {
	s.Headers = v
	return s
}

func (s *DescribeTransitRouteTableAggregationDetailResponse) SetStatusCode(v int32) *DescribeTransitRouteTableAggregationDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *DescribeTransitRouteTableAggregationDetailResponse) SetBody(v *DescribeTransitRouteTableAggregationDetailResponseBody) *DescribeTransitRouteTableAggregationDetailResponse {
	s.Body = v
	return s
}

type DetachCenChildInstanceRequest struct {
	// InvalidParameter
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// Unauthorized
	CenOwnerId *int64 `json:"CenOwnerId,omitempty" xml:"CenOwnerId,omitempty"`
	// InvalidParameter
	ChildInstanceId *string `json:"ChildInstanceId,omitempty" xml:"ChildInstanceId,omitempty"`
	// Unauthorized
	ChildInstanceOwnerId *int64 `json:"ChildInstanceOwnerId,omitempty" xml:"ChildInstanceOwnerId,omitempty"`
	// 
	ChildInstanceRegionId *string `json:"ChildInstanceRegionId,omitempty" xml:"ChildInstanceRegionId,omitempty"`
	// Invalid parameter.
	ChildInstanceType    *string `json:"ChildInstanceType,omitempty" xml:"ChildInstanceType,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s DetachCenChildInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachCenChildInstanceRequest) GoString() string {
	return s.String()
}

func (s *DetachCenChildInstanceRequest) SetCenId(v string) *DetachCenChildInstanceRequest {
	s.CenId = &v
	return s
}

func (s *DetachCenChildInstanceRequest) SetCenOwnerId(v int64) *DetachCenChildInstanceRequest {
	s.CenOwnerId = &v
	return s
}

func (s *DetachCenChildInstanceRequest) SetChildInstanceId(v string) *DetachCenChildInstanceRequest {
	s.ChildInstanceId = &v
	return s
}

func (s *DetachCenChildInstanceRequest) SetChildInstanceOwnerId(v int64) *DetachCenChildInstanceRequest {
	s.ChildInstanceOwnerId = &v
	return s
}

func (s *DetachCenChildInstanceRequest) SetChildInstanceRegionId(v string) *DetachCenChildInstanceRequest {
	s.ChildInstanceRegionId = &v
	return s
}

func (s *DetachCenChildInstanceRequest) SetChildInstanceType(v string) *DetachCenChildInstanceRequest {
	s.ChildInstanceType = &v
	return s
}

func (s *DetachCenChildInstanceRequest) SetOwnerAccount(v string) *DetachCenChildInstanceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DetachCenChildInstanceRequest) SetOwnerId(v int64) *DetachCenChildInstanceRequest {
	s.OwnerId = &v
	return s
}

func (s *DetachCenChildInstanceRequest) SetResourceOwnerAccount(v string) *DetachCenChildInstanceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DetachCenChildInstanceRequest) SetResourceOwnerId(v int64) *DetachCenChildInstanceRequest {
	s.ResourceOwnerId = &v
	return s
}

type DetachCenChildInstanceResponseBody struct {
	// The AccessKeyId is unauthorized.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DetachCenChildInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachCenChildInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DetachCenChildInstanceResponseBody) SetRequestId(v string) *DetachCenChildInstanceResponseBody {
	s.RequestId = &v
	return s
}

type DetachCenChildInstanceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachCenChildInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachCenChildInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachCenChildInstanceResponse) GoString() string {
	return s.String()
}

func (s *DetachCenChildInstanceResponse) SetHeaders(v map[string]*string) *DetachCenChildInstanceResponse {
	s.Headers = v
	return s
}

func (s *DetachCenChildInstanceResponse) SetStatusCode(v int32) *DetachCenChildInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachCenChildInstanceResponse) SetBody(v *DetachCenChildInstanceResponseBody) *DetachCenChildInstanceResponse {
	s.Body = v
	return s
}

type DisableCenVbrHealthCheckRequest struct {
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId                *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VBR.
	VbrInstanceId *string `json:"VbrInstanceId,omitempty" xml:"VbrInstanceId,omitempty"`
	// The ID of the Alibaba Cloud account to which the VBR belongs.
	//
	// > This parameter is required if the VBR and the CEN instance belong to different Alibaba Cloud accounts.
	VbrInstanceOwnerId *int64 `json:"VbrInstanceOwnerId,omitempty" xml:"VbrInstanceOwnerId,omitempty"`
	// The ID of the region where the VBR is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	VbrInstanceRegionId *string `json:"VbrInstanceRegionId,omitempty" xml:"VbrInstanceRegionId,omitempty"`
}

func (s DisableCenVbrHealthCheckRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableCenVbrHealthCheckRequest) GoString() string {
	return s.String()
}

func (s *DisableCenVbrHealthCheckRequest) SetCenId(v string) *DisableCenVbrHealthCheckRequest {
	s.CenId = &v
	return s
}

func (s *DisableCenVbrHealthCheckRequest) SetOwnerAccount(v string) *DisableCenVbrHealthCheckRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DisableCenVbrHealthCheckRequest) SetOwnerId(v int64) *DisableCenVbrHealthCheckRequest {
	s.OwnerId = &v
	return s
}

func (s *DisableCenVbrHealthCheckRequest) SetResourceOwnerAccount(v string) *DisableCenVbrHealthCheckRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DisableCenVbrHealthCheckRequest) SetResourceOwnerId(v int64) *DisableCenVbrHealthCheckRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DisableCenVbrHealthCheckRequest) SetVbrInstanceId(v string) *DisableCenVbrHealthCheckRequest {
	s.VbrInstanceId = &v
	return s
}

func (s *DisableCenVbrHealthCheckRequest) SetVbrInstanceOwnerId(v int64) *DisableCenVbrHealthCheckRequest {
	s.VbrInstanceOwnerId = &v
	return s
}

func (s *DisableCenVbrHealthCheckRequest) SetVbrInstanceRegionId(v string) *DisableCenVbrHealthCheckRequest {
	s.VbrInstanceRegionId = &v
	return s
}

type DisableCenVbrHealthCheckResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableCenVbrHealthCheckResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableCenVbrHealthCheckResponseBody) GoString() string {
	return s.String()
}

func (s *DisableCenVbrHealthCheckResponseBody) SetRequestId(v string) *DisableCenVbrHealthCheckResponseBody {
	s.RequestId = &v
	return s
}

type DisableCenVbrHealthCheckResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableCenVbrHealthCheckResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableCenVbrHealthCheckResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableCenVbrHealthCheckResponse) GoString() string {
	return s.String()
}

func (s *DisableCenVbrHealthCheckResponse) SetHeaders(v map[string]*string) *DisableCenVbrHealthCheckResponse {
	s.Headers = v
	return s
}

func (s *DisableCenVbrHealthCheckResponse) SetStatusCode(v int32) *DisableCenVbrHealthCheckResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableCenVbrHealthCheckResponse) SetBody(v *DisableCenVbrHealthCheckResponseBody) *DisableCenVbrHealthCheckResponse {
	s.Body = v
	return s
}

type DisableTransitRouterRouteTablePropagationRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that the value is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Default values:
	//
	// *   **false** (default): performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and the request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the route table of the Enterprise Edition transit router.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
}

func (s DisableTransitRouterRouteTablePropagationRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableTransitRouterRouteTablePropagationRequest) GoString() string {
	return s.String()
}

func (s *DisableTransitRouterRouteTablePropagationRequest) SetClientToken(v string) *DisableTransitRouterRouteTablePropagationRequest {
	s.ClientToken = &v
	return s
}

func (s *DisableTransitRouterRouteTablePropagationRequest) SetDryRun(v bool) *DisableTransitRouterRouteTablePropagationRequest {
	s.DryRun = &v
	return s
}

func (s *DisableTransitRouterRouteTablePropagationRequest) SetOwnerAccount(v string) *DisableTransitRouterRouteTablePropagationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DisableTransitRouterRouteTablePropagationRequest) SetOwnerId(v int64) *DisableTransitRouterRouteTablePropagationRequest {
	s.OwnerId = &v
	return s
}

func (s *DisableTransitRouterRouteTablePropagationRequest) SetResourceOwnerAccount(v string) *DisableTransitRouterRouteTablePropagationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DisableTransitRouterRouteTablePropagationRequest) SetResourceOwnerId(v int64) *DisableTransitRouterRouteTablePropagationRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DisableTransitRouterRouteTablePropagationRequest) SetTransitRouterAttachmentId(v string) *DisableTransitRouterRouteTablePropagationRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *DisableTransitRouterRouteTablePropagationRequest) SetTransitRouterRouteTableId(v string) *DisableTransitRouterRouteTablePropagationRequest {
	s.TransitRouterRouteTableId = &v
	return s
}

type DisableTransitRouterRouteTablePropagationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisableTransitRouterRouteTablePropagationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableTransitRouterRouteTablePropagationResponseBody) GoString() string {
	return s.String()
}

func (s *DisableTransitRouterRouteTablePropagationResponseBody) SetRequestId(v string) *DisableTransitRouterRouteTablePropagationResponseBody {
	s.RequestId = &v
	return s
}

type DisableTransitRouterRouteTablePropagationResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableTransitRouterRouteTablePropagationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableTransitRouterRouteTablePropagationResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableTransitRouterRouteTablePropagationResponse) GoString() string {
	return s.String()
}

func (s *DisableTransitRouterRouteTablePropagationResponse) SetHeaders(v map[string]*string) *DisableTransitRouterRouteTablePropagationResponse {
	s.Headers = v
	return s
}

func (s *DisableTransitRouterRouteTablePropagationResponse) SetStatusCode(v int32) *DisableTransitRouterRouteTablePropagationResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableTransitRouterRouteTablePropagationResponse) SetBody(v *DisableTransitRouterRouteTablePropagationResponseBody) *DisableTransitRouterRouteTablePropagationResponse {
	s.Body = v
	return s
}

type DisassociateTransitRouterMulticastDomainRequest struct {
	ClientToken                    *string   `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun                         *bool     `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount                   *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                        *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount           *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId                *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TransitRouterAttachmentId      *string   `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	TransitRouterMulticastDomainId *string   `json:"TransitRouterMulticastDomainId,omitempty" xml:"TransitRouterMulticastDomainId,omitempty"`
	VSwitchIds                     []*string `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Repeated"`
}

func (s DisassociateTransitRouterMulticastDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s DisassociateTransitRouterMulticastDomainRequest) GoString() string {
	return s.String()
}

func (s *DisassociateTransitRouterMulticastDomainRequest) SetClientToken(v string) *DisassociateTransitRouterMulticastDomainRequest {
	s.ClientToken = &v
	return s
}

func (s *DisassociateTransitRouterMulticastDomainRequest) SetDryRun(v bool) *DisassociateTransitRouterMulticastDomainRequest {
	s.DryRun = &v
	return s
}

func (s *DisassociateTransitRouterMulticastDomainRequest) SetOwnerAccount(v string) *DisassociateTransitRouterMulticastDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DisassociateTransitRouterMulticastDomainRequest) SetOwnerId(v int64) *DisassociateTransitRouterMulticastDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *DisassociateTransitRouterMulticastDomainRequest) SetResourceOwnerAccount(v string) *DisassociateTransitRouterMulticastDomainRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DisassociateTransitRouterMulticastDomainRequest) SetResourceOwnerId(v int64) *DisassociateTransitRouterMulticastDomainRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DisassociateTransitRouterMulticastDomainRequest) SetTransitRouterAttachmentId(v string) *DisassociateTransitRouterMulticastDomainRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *DisassociateTransitRouterMulticastDomainRequest) SetTransitRouterMulticastDomainId(v string) *DisassociateTransitRouterMulticastDomainRequest {
	s.TransitRouterMulticastDomainId = &v
	return s
}

func (s *DisassociateTransitRouterMulticastDomainRequest) SetVSwitchIds(v []*string) *DisassociateTransitRouterMulticastDomainRequest {
	s.VSwitchIds = v
	return s
}

type DisassociateTransitRouterMulticastDomainResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DisassociateTransitRouterMulticastDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisassociateTransitRouterMulticastDomainResponseBody) GoString() string {
	return s.String()
}

func (s *DisassociateTransitRouterMulticastDomainResponseBody) SetRequestId(v string) *DisassociateTransitRouterMulticastDomainResponseBody {
	s.RequestId = &v
	return s
}

type DisassociateTransitRouterMulticastDomainResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisassociateTransitRouterMulticastDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisassociateTransitRouterMulticastDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s DisassociateTransitRouterMulticastDomainResponse) GoString() string {
	return s.String()
}

func (s *DisassociateTransitRouterMulticastDomainResponse) SetHeaders(v map[string]*string) *DisassociateTransitRouterMulticastDomainResponse {
	s.Headers = v
	return s
}

func (s *DisassociateTransitRouterMulticastDomainResponse) SetStatusCode(v int32) *DisassociateTransitRouterMulticastDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *DisassociateTransitRouterMulticastDomainResponse) SetBody(v *DisassociateTransitRouterMulticastDomainResponseBody) *DisassociateTransitRouterMulticastDomainResponse {
	s.Body = v
	return s
}

type DissociateTransitRouterAttachmentFromRouteTableRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run to check information such as the permissions and the instance status. Default values:
	//
	// *   **false** (default): performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the route table of the Enterprise Edition transit router.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
}

func (s DissociateTransitRouterAttachmentFromRouteTableRequest) String() string {
	return tea.Prettify(s)
}

func (s DissociateTransitRouterAttachmentFromRouteTableRequest) GoString() string {
	return s.String()
}

func (s *DissociateTransitRouterAttachmentFromRouteTableRequest) SetClientToken(v string) *DissociateTransitRouterAttachmentFromRouteTableRequest {
	s.ClientToken = &v
	return s
}

func (s *DissociateTransitRouterAttachmentFromRouteTableRequest) SetDryRun(v bool) *DissociateTransitRouterAttachmentFromRouteTableRequest {
	s.DryRun = &v
	return s
}

func (s *DissociateTransitRouterAttachmentFromRouteTableRequest) SetOwnerAccount(v string) *DissociateTransitRouterAttachmentFromRouteTableRequest {
	s.OwnerAccount = &v
	return s
}

func (s *DissociateTransitRouterAttachmentFromRouteTableRequest) SetOwnerId(v int64) *DissociateTransitRouterAttachmentFromRouteTableRequest {
	s.OwnerId = &v
	return s
}

func (s *DissociateTransitRouterAttachmentFromRouteTableRequest) SetResourceOwnerAccount(v string) *DissociateTransitRouterAttachmentFromRouteTableRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *DissociateTransitRouterAttachmentFromRouteTableRequest) SetResourceOwnerId(v int64) *DissociateTransitRouterAttachmentFromRouteTableRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *DissociateTransitRouterAttachmentFromRouteTableRequest) SetTransitRouterAttachmentId(v string) *DissociateTransitRouterAttachmentFromRouteTableRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *DissociateTransitRouterAttachmentFromRouteTableRequest) SetTransitRouterRouteTableId(v string) *DissociateTransitRouterAttachmentFromRouteTableRequest {
	s.TransitRouterRouteTableId = &v
	return s
}

type DissociateTransitRouterAttachmentFromRouteTableResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DissociateTransitRouterAttachmentFromRouteTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DissociateTransitRouterAttachmentFromRouteTableResponseBody) GoString() string {
	return s.String()
}

func (s *DissociateTransitRouterAttachmentFromRouteTableResponseBody) SetRequestId(v string) *DissociateTransitRouterAttachmentFromRouteTableResponseBody {
	s.RequestId = &v
	return s
}

type DissociateTransitRouterAttachmentFromRouteTableResponse struct {
	Headers    map[string]*string                                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DissociateTransitRouterAttachmentFromRouteTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DissociateTransitRouterAttachmentFromRouteTableResponse) String() string {
	return tea.Prettify(s)
}

func (s DissociateTransitRouterAttachmentFromRouteTableResponse) GoString() string {
	return s.String()
}

func (s *DissociateTransitRouterAttachmentFromRouteTableResponse) SetHeaders(v map[string]*string) *DissociateTransitRouterAttachmentFromRouteTableResponse {
	s.Headers = v
	return s
}

func (s *DissociateTransitRouterAttachmentFromRouteTableResponse) SetStatusCode(v int32) *DissociateTransitRouterAttachmentFromRouteTableResponse {
	s.StatusCode = &v
	return s
}

func (s *DissociateTransitRouterAttachmentFromRouteTableResponse) SetBody(v *DissociateTransitRouterAttachmentFromRouteTableResponseBody) *DissociateTransitRouterAttachmentFromRouteTableResponse {
	s.Body = v
	return s
}

type EnableCenVbrHealthCheckRequest struct {
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The time interval at which probe packets are sent during a health check. Unit: seconds. Default value: **2**. Valid values: **2 to 3**.
	HealthCheckInterval *int32 `json:"HealthCheckInterval,omitempty" xml:"HealthCheckInterval,omitempty"`
	// Specifies whether to enable probing during the health check. Valid values:
	//
	// *   **true**: yes
	//
	//         If you enable probing, the system does not switch to another route if the detected route is not reachable.
	//
	//           Make sure that a redundant route is available. Otherwise, network disconnections may occur.
	//
	// *   **false** (default): no
	//
	//         Probing is disabled by default. If a redundant route is specified, the system switches to the redundant route if the detected route is not reachable.
	HealthCheckOnly *bool `json:"HealthCheckOnly,omitempty" xml:"HealthCheckOnly,omitempty"`
	// The source IP address for the health check. You can set the source IP address in the following ways:
	//
	// *   **Automatic IP Address** (recommended): The system automatically assigns an IP address from the 100.96.0.0/16 CIDR block.
	// *   **Custom IP Address**: You must specify an idle IP address from the 10.0.0.0/8, 192.168.0.0/16, or 172.16.0.0/12 CIDR block. The specified IP address cannot be the IP address of the VBR on the Alibaba Cloud side, the IP address of the VBR on the customer side, or other IP addresses with which the VBR communicates through the CEN instance.
	HealthCheckSourceIp *string `json:"HealthCheckSourceIp,omitempty" xml:"HealthCheckSourceIp,omitempty"`
	// The destination IP address for the health check.
	//
	// Set the destination IP address to the IP address of the VBR on the customer side.
	HealthCheckTargetIp *string `json:"HealthCheckTargetIp,omitempty" xml:"HealthCheckTargetIp,omitempty"`
	// The number of probe packets that are sent during a health check. Unit: packets. Valid values: **3 to 8**. Default value: **8**.
	HealthyThreshold     *int32  `json:"HealthyThreshold,omitempty" xml:"HealthyThreshold,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VBR.
	VbrInstanceId *string `json:"VbrInstanceId,omitempty" xml:"VbrInstanceId,omitempty"`
	// The ID of the Alibaba Cloud account to which the VBR belongs.
	//
	// > This parameter is required if the VBR and the CEN instance belong to different Alibaba Cloud accounts.
	VbrInstanceOwnerId *int64 `json:"VbrInstanceOwnerId,omitempty" xml:"VbrInstanceOwnerId,omitempty"`
	// The ID of the region where the VBR is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	VbrInstanceRegionId *string `json:"VbrInstanceRegionId,omitempty" xml:"VbrInstanceRegionId,omitempty"`
}

func (s EnableCenVbrHealthCheckRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableCenVbrHealthCheckRequest) GoString() string {
	return s.String()
}

func (s *EnableCenVbrHealthCheckRequest) SetCenId(v string) *EnableCenVbrHealthCheckRequest {
	s.CenId = &v
	return s
}

func (s *EnableCenVbrHealthCheckRequest) SetHealthCheckInterval(v int32) *EnableCenVbrHealthCheckRequest {
	s.HealthCheckInterval = &v
	return s
}

func (s *EnableCenVbrHealthCheckRequest) SetHealthCheckOnly(v bool) *EnableCenVbrHealthCheckRequest {
	s.HealthCheckOnly = &v
	return s
}

func (s *EnableCenVbrHealthCheckRequest) SetHealthCheckSourceIp(v string) *EnableCenVbrHealthCheckRequest {
	s.HealthCheckSourceIp = &v
	return s
}

func (s *EnableCenVbrHealthCheckRequest) SetHealthCheckTargetIp(v string) *EnableCenVbrHealthCheckRequest {
	s.HealthCheckTargetIp = &v
	return s
}

func (s *EnableCenVbrHealthCheckRequest) SetHealthyThreshold(v int32) *EnableCenVbrHealthCheckRequest {
	s.HealthyThreshold = &v
	return s
}

func (s *EnableCenVbrHealthCheckRequest) SetOwnerAccount(v string) *EnableCenVbrHealthCheckRequest {
	s.OwnerAccount = &v
	return s
}

func (s *EnableCenVbrHealthCheckRequest) SetOwnerId(v int64) *EnableCenVbrHealthCheckRequest {
	s.OwnerId = &v
	return s
}

func (s *EnableCenVbrHealthCheckRequest) SetResourceOwnerAccount(v string) *EnableCenVbrHealthCheckRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *EnableCenVbrHealthCheckRequest) SetResourceOwnerId(v int64) *EnableCenVbrHealthCheckRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *EnableCenVbrHealthCheckRequest) SetVbrInstanceId(v string) *EnableCenVbrHealthCheckRequest {
	s.VbrInstanceId = &v
	return s
}

func (s *EnableCenVbrHealthCheckRequest) SetVbrInstanceOwnerId(v int64) *EnableCenVbrHealthCheckRequest {
	s.VbrInstanceOwnerId = &v
	return s
}

func (s *EnableCenVbrHealthCheckRequest) SetVbrInstanceRegionId(v string) *EnableCenVbrHealthCheckRequest {
	s.VbrInstanceRegionId = &v
	return s
}

type EnableCenVbrHealthCheckResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableCenVbrHealthCheckResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableCenVbrHealthCheckResponseBody) GoString() string {
	return s.String()
}

func (s *EnableCenVbrHealthCheckResponseBody) SetRequestId(v string) *EnableCenVbrHealthCheckResponseBody {
	s.RequestId = &v
	return s
}

type EnableCenVbrHealthCheckResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableCenVbrHealthCheckResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableCenVbrHealthCheckResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableCenVbrHealthCheckResponse) GoString() string {
	return s.String()
}

func (s *EnableCenVbrHealthCheckResponse) SetHeaders(v map[string]*string) *EnableCenVbrHealthCheckResponse {
	s.Headers = v
	return s
}

func (s *EnableCenVbrHealthCheckResponse) SetStatusCode(v int32) *EnableCenVbrHealthCheckResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableCenVbrHealthCheckResponse) SetBody(v *EnableCenVbrHealthCheckResponseBody) *EnableCenVbrHealthCheckResponse {
	s.Body = v
	return s
}

type EnableTransitRouterRouteTablePropagationRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run to check information such as the permissions and the instance status. Valid values:
	//
	// *   **false** (default): performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the route table of the Enterprise Edition transit router.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
}

func (s EnableTransitRouterRouteTablePropagationRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableTransitRouterRouteTablePropagationRequest) GoString() string {
	return s.String()
}

func (s *EnableTransitRouterRouteTablePropagationRequest) SetClientToken(v string) *EnableTransitRouterRouteTablePropagationRequest {
	s.ClientToken = &v
	return s
}

func (s *EnableTransitRouterRouteTablePropagationRequest) SetDryRun(v bool) *EnableTransitRouterRouteTablePropagationRequest {
	s.DryRun = &v
	return s
}

func (s *EnableTransitRouterRouteTablePropagationRequest) SetOwnerAccount(v string) *EnableTransitRouterRouteTablePropagationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *EnableTransitRouterRouteTablePropagationRequest) SetOwnerId(v int64) *EnableTransitRouterRouteTablePropagationRequest {
	s.OwnerId = &v
	return s
}

func (s *EnableTransitRouterRouteTablePropagationRequest) SetResourceOwnerAccount(v string) *EnableTransitRouterRouteTablePropagationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *EnableTransitRouterRouteTablePropagationRequest) SetResourceOwnerId(v int64) *EnableTransitRouterRouteTablePropagationRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *EnableTransitRouterRouteTablePropagationRequest) SetTransitRouterAttachmentId(v string) *EnableTransitRouterRouteTablePropagationRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *EnableTransitRouterRouteTablePropagationRequest) SetTransitRouterRouteTableId(v string) *EnableTransitRouterRouteTablePropagationRequest {
	s.TransitRouterRouteTableId = &v
	return s
}

type EnableTransitRouterRouteTablePropagationResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s EnableTransitRouterRouteTablePropagationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableTransitRouterRouteTablePropagationResponseBody) GoString() string {
	return s.String()
}

func (s *EnableTransitRouterRouteTablePropagationResponseBody) SetRequestId(v string) *EnableTransitRouterRouteTablePropagationResponseBody {
	s.RequestId = &v
	return s
}

type EnableTransitRouterRouteTablePropagationResponse struct {
	Headers    map[string]*string                                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableTransitRouterRouteTablePropagationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableTransitRouterRouteTablePropagationResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableTransitRouterRouteTablePropagationResponse) GoString() string {
	return s.String()
}

func (s *EnableTransitRouterRouteTablePropagationResponse) SetHeaders(v map[string]*string) *EnableTransitRouterRouteTablePropagationResponse {
	s.Headers = v
	return s
}

func (s *EnableTransitRouterRouteTablePropagationResponse) SetStatusCode(v int32) *EnableTransitRouterRouteTablePropagationResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableTransitRouterRouteTablePropagationResponse) SetBody(v *EnableTransitRouterRouteTablePropagationResponseBody) *EnableTransitRouterRouteTablePropagationResponse {
	s.Body = v
	return s
}

type GrantInstanceToTransitRouterRequest struct {
	// The ID of the region where the network instance is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	CenId      *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	CenOwnerId *int64  `json:"CenOwnerId,omitempty" xml:"CenOwnerId,omitempty"`
	// The ID of the request.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The operation that you want to perform. Set the value to **GrantInstanceToTransitRouter**.
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	OrderType    *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the Alibaba Cloud account to which the CEN instance belongs.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s GrantInstanceToTransitRouterRequest) String() string {
	return tea.Prettify(s)
}

func (s GrantInstanceToTransitRouterRequest) GoString() string {
	return s.String()
}

func (s *GrantInstanceToTransitRouterRequest) SetCenId(v string) *GrantInstanceToTransitRouterRequest {
	s.CenId = &v
	return s
}

func (s *GrantInstanceToTransitRouterRequest) SetCenOwnerId(v int64) *GrantInstanceToTransitRouterRequest {
	s.CenOwnerId = &v
	return s
}

func (s *GrantInstanceToTransitRouterRequest) SetInstanceId(v string) *GrantInstanceToTransitRouterRequest {
	s.InstanceId = &v
	return s
}

func (s *GrantInstanceToTransitRouterRequest) SetInstanceType(v string) *GrantInstanceToTransitRouterRequest {
	s.InstanceType = &v
	return s
}

func (s *GrantInstanceToTransitRouterRequest) SetOrderType(v string) *GrantInstanceToTransitRouterRequest {
	s.OrderType = &v
	return s
}

func (s *GrantInstanceToTransitRouterRequest) SetOwnerAccount(v string) *GrantInstanceToTransitRouterRequest {
	s.OwnerAccount = &v
	return s
}

func (s *GrantInstanceToTransitRouterRequest) SetOwnerId(v int64) *GrantInstanceToTransitRouterRequest {
	s.OwnerId = &v
	return s
}

func (s *GrantInstanceToTransitRouterRequest) SetRegionId(v string) *GrantInstanceToTransitRouterRequest {
	s.RegionId = &v
	return s
}

func (s *GrantInstanceToTransitRouterRequest) SetResourceOwnerAccount(v string) *GrantInstanceToTransitRouterRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *GrantInstanceToTransitRouterRequest) SetResourceOwnerId(v int64) *GrantInstanceToTransitRouterRequest {
	s.ResourceOwnerId = &v
	return s
}

type GrantInstanceToTransitRouterResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GrantInstanceToTransitRouterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GrantInstanceToTransitRouterResponseBody) GoString() string {
	return s.String()
}

func (s *GrantInstanceToTransitRouterResponseBody) SetRequestId(v string) *GrantInstanceToTransitRouterResponseBody {
	s.RequestId = &v
	return s
}

type GrantInstanceToTransitRouterResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GrantInstanceToTransitRouterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GrantInstanceToTransitRouterResponse) String() string {
	return tea.Prettify(s)
}

func (s GrantInstanceToTransitRouterResponse) GoString() string {
	return s.String()
}

func (s *GrantInstanceToTransitRouterResponse) SetHeaders(v map[string]*string) *GrantInstanceToTransitRouterResponse {
	s.Headers = v
	return s
}

func (s *GrantInstanceToTransitRouterResponse) SetStatusCode(v int32) *GrantInstanceToTransitRouterResponse {
	s.StatusCode = &v
	return s
}

func (s *GrantInstanceToTransitRouterResponse) SetBody(v *GrantInstanceToTransitRouterResponseBody) *GrantInstanceToTransitRouterResponse {
	s.Body = v
	return s
}

type ListCenChildInstanceRouteEntriesToAttachmentRequest struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the route table configured on the network instance.
	ChildInstanceRouteTableId *string `json:"ChildInstanceRouteTableId,omitempty" xml:"ChildInstanceRouteTableId,omitempty"`
	// The number of entries to return on each page. Default value: **20**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query and no subsequent queries are to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken            *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The filter condition for the destination CIDR block.
	RouteFilter []*ListCenChildInstanceRouteEntriesToAttachmentRequestRouteFilter `json:"RouteFilter,omitempty" xml:"RouteFilter,omitempty" type:"Repeated"`
	// Specifies whether to host the route. If you leave the parameter empty, the route is not hosted. A value of TR specifies that the route is hosted on a transit router.
	ServiceType *string `json:"ServiceType,omitempty" xml:"ServiceType,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s ListCenChildInstanceRouteEntriesToAttachmentRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCenChildInstanceRouteEntriesToAttachmentRequest) GoString() string {
	return s.String()
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentRequest) SetCenId(v string) *ListCenChildInstanceRouteEntriesToAttachmentRequest {
	s.CenId = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentRequest) SetChildInstanceRouteTableId(v string) *ListCenChildInstanceRouteEntriesToAttachmentRequest {
	s.ChildInstanceRouteTableId = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentRequest) SetMaxResults(v int32) *ListCenChildInstanceRouteEntriesToAttachmentRequest {
	s.MaxResults = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentRequest) SetNextToken(v string) *ListCenChildInstanceRouteEntriesToAttachmentRequest {
	s.NextToken = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentRequest) SetOwnerAccount(v string) *ListCenChildInstanceRouteEntriesToAttachmentRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentRequest) SetOwnerId(v int64) *ListCenChildInstanceRouteEntriesToAttachmentRequest {
	s.OwnerId = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentRequest) SetResourceOwnerAccount(v string) *ListCenChildInstanceRouteEntriesToAttachmentRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentRequest) SetResourceOwnerId(v int64) *ListCenChildInstanceRouteEntriesToAttachmentRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentRequest) SetRouteFilter(v []*ListCenChildInstanceRouteEntriesToAttachmentRequestRouteFilter) *ListCenChildInstanceRouteEntriesToAttachmentRequest {
	s.RouteFilter = v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentRequest) SetServiceType(v string) *ListCenChildInstanceRouteEntriesToAttachmentRequest {
	s.ServiceType = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentRequest) SetTransitRouterAttachmentId(v string) *ListCenChildInstanceRouteEntriesToAttachmentRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

type ListCenChildInstanceRouteEntriesToAttachmentRequestRouteFilter struct {
	// The match mode of the route.
	//
	// *   **prefix-exact-match**: exact match.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The destination CIDR blocks.
	Value []*string `json:"Value,omitempty" xml:"Value,omitempty" type:"Repeated"`
}

func (s ListCenChildInstanceRouteEntriesToAttachmentRequestRouteFilter) String() string {
	return tea.Prettify(s)
}

func (s ListCenChildInstanceRouteEntriesToAttachmentRequestRouteFilter) GoString() string {
	return s.String()
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentRequestRouteFilter) SetKey(v string) *ListCenChildInstanceRouteEntriesToAttachmentRequestRouteFilter {
	s.Key = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentRequestRouteFilter) SetValue(v []*string) *ListCenChildInstanceRouteEntriesToAttachmentRequestRouteFilter {
	s.Value = v
	return s
}

type ListCenChildInstanceRouteEntriesToAttachmentResponseBody struct {
	// The token that determines the start point of the next query. Valid values:
	//
	// *   If **NextToken** is not returned, it indicates that no additional results exist.
	// *   If **NextToken** was returned in the previous query, specify the value to obtain the next set of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The detailed information about the route.
	RouteEntry []*ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry `json:"RouteEntry,omitempty" xml:"RouteEntry,omitempty" type:"Repeated"`
}

func (s ListCenChildInstanceRouteEntriesToAttachmentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCenChildInstanceRouteEntriesToAttachmentResponseBody) GoString() string {
	return s.String()
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentResponseBody) SetNextToken(v string) *ListCenChildInstanceRouteEntriesToAttachmentResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentResponseBody) SetRequestId(v string) *ListCenChildInstanceRouteEntriesToAttachmentResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentResponseBody) SetRouteEntry(v []*ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry) *ListCenChildInstanceRouteEntriesToAttachmentResponseBody {
	s.RouteEntry = v
	return s
}

type ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the route table configured on the network instance.
	ChildInstanceRouteTableId *string `json:"ChildInstanceRouteTableId,omitempty" xml:"ChildInstanceRouteTableId,omitempty"`
	// The destination CIDR block of the route.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	// Indicates whether the route is hosted. If the parameter is empty, the route is not hosted. A value of TR indicates that the route is hosted on a transit router.
	ServiceType *string `json:"ServiceType,omitempty" xml:"ServiceType,omitempty"`
	// The status of the route. Valid values:
	//
	// *   **Available**: The route is available.
	// *   **Pending**: The route is being configured.
	// *   **Modifying**: the route is being modified.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry) String() string {
	return tea.Prettify(s)
}

func (s ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry) GoString() string {
	return s.String()
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry) SetCenId(v string) *ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry {
	s.CenId = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry) SetChildInstanceRouteTableId(v string) *ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry {
	s.ChildInstanceRouteTableId = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry) SetDestinationCidrBlock(v string) *ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry {
	s.DestinationCidrBlock = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry) SetServiceType(v string) *ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry {
	s.ServiceType = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry) SetStatus(v string) *ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry {
	s.Status = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry) SetTransitRouterAttachmentId(v string) *ListCenChildInstanceRouteEntriesToAttachmentResponseBodyRouteEntry {
	s.TransitRouterAttachmentId = &v
	return s
}

type ListCenChildInstanceRouteEntriesToAttachmentResponse struct {
	Headers    map[string]*string                                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListCenChildInstanceRouteEntriesToAttachmentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListCenChildInstanceRouteEntriesToAttachmentResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCenChildInstanceRouteEntriesToAttachmentResponse) GoString() string {
	return s.String()
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentResponse) SetHeaders(v map[string]*string) *ListCenChildInstanceRouteEntriesToAttachmentResponse {
	s.Headers = v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentResponse) SetStatusCode(v int32) *ListCenChildInstanceRouteEntriesToAttachmentResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCenChildInstanceRouteEntriesToAttachmentResponse) SetBody(v *ListCenChildInstanceRouteEntriesToAttachmentResponseBody) *ListCenChildInstanceRouteEntriesToAttachmentResponse {
	s.Body = v
	return s
}

type ListCenInterRegionTrafficQosPoliciesRequest struct {
	// The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query or no subsequent query is to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the value to the value of **NextToken** that is returned from the last call.
	NextToken            *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The description of the QoS policy.
	//
	// The description must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The description must start with a letter.
	TrafficQosPolicyDescription *string `json:"TrafficQosPolicyDescription,omitempty" xml:"TrafficQosPolicyDescription,omitempty"`
	// The ID of the QoS policy.
	TrafficQosPolicyId *string `json:"TrafficQosPolicyId,omitempty" xml:"TrafficQosPolicyId,omitempty"`
	// The name of the QoS policy.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	TrafficQosPolicyName *string `json:"TrafficQosPolicyName,omitempty" xml:"TrafficQosPolicyName,omitempty"`
	// The ID of the inter-region connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s ListCenInterRegionTrafficQosPoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCenInterRegionTrafficQosPoliciesRequest) GoString() string {
	return s.String()
}

func (s *ListCenInterRegionTrafficQosPoliciesRequest) SetMaxResults(v int32) *ListCenInterRegionTrafficQosPoliciesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesRequest) SetNextToken(v string) *ListCenInterRegionTrafficQosPoliciesRequest {
	s.NextToken = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesRequest) SetOwnerAccount(v string) *ListCenInterRegionTrafficQosPoliciesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesRequest) SetOwnerId(v int64) *ListCenInterRegionTrafficQosPoliciesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesRequest) SetResourceOwnerAccount(v string) *ListCenInterRegionTrafficQosPoliciesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesRequest) SetResourceOwnerId(v int64) *ListCenInterRegionTrafficQosPoliciesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesRequest) SetTrafficQosPolicyDescription(v string) *ListCenInterRegionTrafficQosPoliciesRequest {
	s.TrafficQosPolicyDescription = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesRequest) SetTrafficQosPolicyId(v string) *ListCenInterRegionTrafficQosPoliciesRequest {
	s.TrafficQosPolicyId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesRequest) SetTrafficQosPolicyName(v string) *ListCenInterRegionTrafficQosPoliciesRequest {
	s.TrafficQosPolicyName = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesRequest) SetTransitRouterAttachmentId(v string) *ListCenInterRegionTrafficQosPoliciesRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesRequest) SetTransitRouterId(v string) *ListCenInterRegionTrafficQosPoliciesRequest {
	s.TransitRouterId = &v
	return s
}

type ListCenInterRegionTrafficQosPoliciesResponseBody struct {
	// The number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query.
	//
	// *   If **NextToken** was not returned in the previous query, it indicates that no additional results exist.
	// *   If **NextToken** was returned in the previous query, specify the value to obtain the next set of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// A list of QoS policies.
	TrafficQosPolicies []*ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies `json:"TrafficQosPolicies,omitempty" xml:"TrafficQosPolicies,omitempty" type:"Repeated"`
}

func (s ListCenInterRegionTrafficQosPoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCenInterRegionTrafficQosPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBody) SetMaxResults(v int32) *ListCenInterRegionTrafficQosPoliciesResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBody) SetNextToken(v string) *ListCenInterRegionTrafficQosPoliciesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBody) SetRequestId(v string) *ListCenInterRegionTrafficQosPoliciesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBody) SetTotalCount(v int32) *ListCenInterRegionTrafficQosPoliciesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBody) SetTrafficQosPolicies(v []*ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies) *ListCenInterRegionTrafficQosPoliciesResponseBody {
	s.TrafficQosPolicies = v
	return s
}

type ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies struct {
	// The description of the QoS policy.
	TrafficQosPolicyDescription *string `json:"TrafficQosPolicyDescription,omitempty" xml:"TrafficQosPolicyDescription,omitempty"`
	// The ID of the QoS policy.
	TrafficQosPolicyId *string `json:"TrafficQosPolicyId,omitempty" xml:"TrafficQosPolicyId,omitempty"`
	// The name of the QoS policy.
	TrafficQosPolicyName *string `json:"TrafficQosPolicyName,omitempty" xml:"TrafficQosPolicyName,omitempty"`
	// The status of the QoS policy. Valid values:
	//
	// *   **Creating**: The QoS policy is being created.
	// *   **Active**: The QoS policy is available.
	// *   **Modifying**: The QoS policy is being modified
	// *   **Deleting**: The QoS policy is being deleted.
	// *   **Deleted**: The QoS policy is deleted.
	TrafficQosPolicyStatus *string `json:"TrafficQosPolicyStatus,omitempty" xml:"TrafficQosPolicyStatus,omitempty"`
	// A list of queues.
	TrafficQosQueues []*ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPoliciesTrafficQosQueues `json:"TrafficQosQueues,omitempty" xml:"TrafficQosQueues,omitempty" type:"Repeated"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies) String() string {
	return tea.Prettify(s)
}

func (s ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies) GoString() string {
	return s.String()
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies) SetTrafficQosPolicyDescription(v string) *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies {
	s.TrafficQosPolicyDescription = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies) SetTrafficQosPolicyId(v string) *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies {
	s.TrafficQosPolicyId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies) SetTrafficQosPolicyName(v string) *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies {
	s.TrafficQosPolicyName = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies) SetTrafficQosPolicyStatus(v string) *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies {
	s.TrafficQosPolicyStatus = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies) SetTrafficQosQueues(v []*ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPoliciesTrafficQosQueues) *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies {
	s.TrafficQosQueues = v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies) SetTransitRouterAttachmentId(v string) *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies) SetTransitRouterId(v string) *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPolicies {
	s.TransitRouterId = &v
	return s
}

type ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPoliciesTrafficQosQueues struct {
	// The differentiated services code point (DSCP) value used to match packets in the queue.
	Dscps []*int32 `json:"Dscps,omitempty" xml:"Dscps,omitempty" type:"Repeated"`
	// The description of the queue.
	QosQueueDescription *string `json:"QosQueueDescription,omitempty" xml:"QosQueueDescription,omitempty"`
	// The ID of the queue.
	QosQueueId *string `json:"QosQueueId,omitempty" xml:"QosQueueId,omitempty"`
	// The name of the queue.
	QosQueueName *string `json:"QosQueueName,omitempty" xml:"QosQueueName,omitempty"`
	// The percentage of the inter-region bandwidth that can be used by the queue.
	RemainBandwidthPercent *int32 `json:"RemainBandwidthPercent,omitempty" xml:"RemainBandwidthPercent,omitempty"`
}

func (s ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPoliciesTrafficQosQueues) String() string {
	return tea.Prettify(s)
}

func (s ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPoliciesTrafficQosQueues) GoString() string {
	return s.String()
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPoliciesTrafficQosQueues) SetDscps(v []*int32) *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPoliciesTrafficQosQueues {
	s.Dscps = v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPoliciesTrafficQosQueues) SetQosQueueDescription(v string) *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPoliciesTrafficQosQueues {
	s.QosQueueDescription = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPoliciesTrafficQosQueues) SetQosQueueId(v string) *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPoliciesTrafficQosQueues {
	s.QosQueueId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPoliciesTrafficQosQueues) SetQosQueueName(v string) *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPoliciesTrafficQosQueues {
	s.QosQueueName = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPoliciesTrafficQosQueues) SetRemainBandwidthPercent(v int32) *ListCenInterRegionTrafficQosPoliciesResponseBodyTrafficQosPoliciesTrafficQosQueues {
	s.RemainBandwidthPercent = &v
	return s
}

type ListCenInterRegionTrafficQosPoliciesResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListCenInterRegionTrafficQosPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListCenInterRegionTrafficQosPoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCenInterRegionTrafficQosPoliciesResponse) GoString() string {
	return s.String()
}

func (s *ListCenInterRegionTrafficQosPoliciesResponse) SetHeaders(v map[string]*string) *ListCenInterRegionTrafficQosPoliciesResponse {
	s.Headers = v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponse) SetStatusCode(v int32) *ListCenInterRegionTrafficQosPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCenInterRegionTrafficQosPoliciesResponse) SetBody(v *ListCenInterRegionTrafficQosPoliciesResponseBody) *ListCenInterRegionTrafficQosPoliciesResponse {
	s.Body = v
	return s
}

type ListCenInterRegionTrafficQosQueuesRequest struct {
	MaxResults                 *int32  `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken                  *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount               *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                    *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount       *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId            *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TrafficQosPolicyId         *string `json:"TrafficQosPolicyId,omitempty" xml:"TrafficQosPolicyId,omitempty"`
	TrafficQosQueueDescription *string `json:"TrafficQosQueueDescription,omitempty" xml:"TrafficQosQueueDescription,omitempty"`
	TrafficQosQueueId          *string `json:"TrafficQosQueueId,omitempty" xml:"TrafficQosQueueId,omitempty"`
	TrafficQosQueueName        *string `json:"TrafficQosQueueName,omitempty" xml:"TrafficQosQueueName,omitempty"`
	TransitRouterAttachmentId  *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	TransitRouterId            *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s ListCenInterRegionTrafficQosQueuesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCenInterRegionTrafficQosQueuesRequest) GoString() string {
	return s.String()
}

func (s *ListCenInterRegionTrafficQosQueuesRequest) SetMaxResults(v int32) *ListCenInterRegionTrafficQosQueuesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesRequest) SetNextToken(v string) *ListCenInterRegionTrafficQosQueuesRequest {
	s.NextToken = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesRequest) SetOwnerAccount(v string) *ListCenInterRegionTrafficQosQueuesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesRequest) SetOwnerId(v int64) *ListCenInterRegionTrafficQosQueuesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesRequest) SetResourceOwnerAccount(v string) *ListCenInterRegionTrafficQosQueuesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesRequest) SetResourceOwnerId(v int64) *ListCenInterRegionTrafficQosQueuesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesRequest) SetTrafficQosPolicyId(v string) *ListCenInterRegionTrafficQosQueuesRequest {
	s.TrafficQosPolicyId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesRequest) SetTrafficQosQueueDescription(v string) *ListCenInterRegionTrafficQosQueuesRequest {
	s.TrafficQosQueueDescription = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesRequest) SetTrafficQosQueueId(v string) *ListCenInterRegionTrafficQosQueuesRequest {
	s.TrafficQosQueueId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesRequest) SetTrafficQosQueueName(v string) *ListCenInterRegionTrafficQosQueuesRequest {
	s.TrafficQosQueueName = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesRequest) SetTransitRouterAttachmentId(v string) *ListCenInterRegionTrafficQosQueuesRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesRequest) SetTransitRouterId(v string) *ListCenInterRegionTrafficQosQueuesRequest {
	s.TransitRouterId = &v
	return s
}

type ListCenInterRegionTrafficQosQueuesResponseBody struct {
	NextToken        *string                                                           `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RequestId        *string                                                           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TrafficQosQueues []*ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues `json:"TrafficQosQueues,omitempty" xml:"TrafficQosQueues,omitempty" type:"Repeated"`
}

func (s ListCenInterRegionTrafficQosQueuesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCenInterRegionTrafficQosQueuesResponseBody) GoString() string {
	return s.String()
}

func (s *ListCenInterRegionTrafficQosQueuesResponseBody) SetNextToken(v string) *ListCenInterRegionTrafficQosQueuesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesResponseBody) SetRequestId(v string) *ListCenInterRegionTrafficQosQueuesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesResponseBody) SetTrafficQosQueues(v []*ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues) *ListCenInterRegionTrafficQosQueuesResponseBody {
	s.TrafficQosQueues = v
	return s
}

type ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues struct {
	Dscps                      []*int32 `json:"Dscps,omitempty" xml:"Dscps,omitempty" type:"Repeated"`
	RemainBandwidthPercent     *int32   `json:"RemainBandwidthPercent,omitempty" xml:"RemainBandwidthPercent,omitempty"`
	Status                     *string  `json:"Status,omitempty" xml:"Status,omitempty"`
	TrafficQosPolicyId         *string  `json:"TrafficQosPolicyId,omitempty" xml:"TrafficQosPolicyId,omitempty"`
	TrafficQosQueueDescription *string  `json:"TrafficQosQueueDescription,omitempty" xml:"TrafficQosQueueDescription,omitempty"`
	TrafficQosQueueId          *string  `json:"TrafficQosQueueId,omitempty" xml:"TrafficQosQueueId,omitempty"`
	TrafficQosQueueName        *string  `json:"TrafficQosQueueName,omitempty" xml:"TrafficQosQueueName,omitempty"`
	TransitRouterAttachmentId  *string  `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	TransitRouterId            *string  `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues) String() string {
	return tea.Prettify(s)
}

func (s ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues) GoString() string {
	return s.String()
}

func (s *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues) SetDscps(v []*int32) *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues {
	s.Dscps = v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues) SetRemainBandwidthPercent(v int32) *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues {
	s.RemainBandwidthPercent = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues) SetStatus(v string) *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues {
	s.Status = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues) SetTrafficQosPolicyId(v string) *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues {
	s.TrafficQosPolicyId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues) SetTrafficQosQueueDescription(v string) *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues {
	s.TrafficQosQueueDescription = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues) SetTrafficQosQueueId(v string) *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues {
	s.TrafficQosQueueId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues) SetTrafficQosQueueName(v string) *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues {
	s.TrafficQosQueueName = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues) SetTransitRouterAttachmentId(v string) *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues) SetTransitRouterId(v string) *ListCenInterRegionTrafficQosQueuesResponseBodyTrafficQosQueues {
	s.TransitRouterId = &v
	return s
}

type ListCenInterRegionTrafficQosQueuesResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListCenInterRegionTrafficQosQueuesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListCenInterRegionTrafficQosQueuesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCenInterRegionTrafficQosQueuesResponse) GoString() string {
	return s.String()
}

func (s *ListCenInterRegionTrafficQosQueuesResponse) SetHeaders(v map[string]*string) *ListCenInterRegionTrafficQosQueuesResponse {
	s.Headers = v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesResponse) SetStatusCode(v int32) *ListCenInterRegionTrafficQosQueuesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCenInterRegionTrafficQosQueuesResponse) SetBody(v *ListCenInterRegionTrafficQosQueuesResponseBody) *ListCenInterRegionTrafficQosQueuesResponse {
	s.Body = v
	return s
}

type ListGrantVSwitchEnisRequest struct {
	// The ID of the CEN instance to which the VPC is attached.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The number of entries to return on each page. Valid values: 10 to 500.
	//
	// Default value:
	//
	// *   If you do not specify a value, the default value is 20.
	// *   If this parameter is set to a value greater than 500, the default value is 500.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The ID of ENI N. Valid values of N: 1 to 100.
	NetworkInterfaceId []*string `json:"NetworkInterfaceId,omitempty" xml:"NetworkInterfaceId,omitempty" type:"Repeated"`
	// The name of the ENI.
	NetworkInterfaceName *string `json:"NetworkInterfaceName,omitempty" xml:"NetworkInterfaceName,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The primary private IPv4 address of the ENI.
	PrimaryIpAddress     *string `json:"PrimaryIpAddress,omitempty" xml:"PrimaryIpAddress,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of a vSwitch in the VPC. You can specify only one vSwitch in each call.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ListGrantVSwitchEnisRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGrantVSwitchEnisRequest) GoString() string {
	return s.String()
}

func (s *ListGrantVSwitchEnisRequest) SetCenId(v string) *ListGrantVSwitchEnisRequest {
	s.CenId = &v
	return s
}

func (s *ListGrantVSwitchEnisRequest) SetMaxResults(v int64) *ListGrantVSwitchEnisRequest {
	s.MaxResults = &v
	return s
}

func (s *ListGrantVSwitchEnisRequest) SetNetworkInterfaceId(v []*string) *ListGrantVSwitchEnisRequest {
	s.NetworkInterfaceId = v
	return s
}

func (s *ListGrantVSwitchEnisRequest) SetNetworkInterfaceName(v string) *ListGrantVSwitchEnisRequest {
	s.NetworkInterfaceName = &v
	return s
}

func (s *ListGrantVSwitchEnisRequest) SetNextToken(v string) *ListGrantVSwitchEnisRequest {
	s.NextToken = &v
	return s
}

func (s *ListGrantVSwitchEnisRequest) SetOwnerAccount(v string) *ListGrantVSwitchEnisRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListGrantVSwitchEnisRequest) SetOwnerId(v int64) *ListGrantVSwitchEnisRequest {
	s.OwnerId = &v
	return s
}

func (s *ListGrantVSwitchEnisRequest) SetPrimaryIpAddress(v string) *ListGrantVSwitchEnisRequest {
	s.PrimaryIpAddress = &v
	return s
}

func (s *ListGrantVSwitchEnisRequest) SetResourceOwnerAccount(v string) *ListGrantVSwitchEnisRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListGrantVSwitchEnisRequest) SetResourceOwnerId(v int64) *ListGrantVSwitchEnisRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListGrantVSwitchEnisRequest) SetVSwitchId(v string) *ListGrantVSwitchEnisRequest {
	s.VSwitchId = &v
	return s
}

func (s *ListGrantVSwitchEnisRequest) SetVpcId(v string) *ListGrantVSwitchEnisRequest {
	s.VpcId = &v
	return s
}

type ListGrantVSwitchEnisResponseBody struct {
	// The information about the ENI.
	GrantVSwitchEnis []*ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis `json:"GrantVSwitchEnis,omitempty" xml:"GrantVSwitchEnis,omitempty" type:"Repeated"`
	// The total number of entries returned.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	//
	// > If MaxResults and NextToken are sued to query results by page, ignore this parameter.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListGrantVSwitchEnisResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGrantVSwitchEnisResponseBody) GoString() string {
	return s.String()
}

func (s *ListGrantVSwitchEnisResponseBody) SetGrantVSwitchEnis(v []*ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis) *ListGrantVSwitchEnisResponseBody {
	s.GrantVSwitchEnis = v
	return s
}

func (s *ListGrantVSwitchEnisResponseBody) SetMaxResults(v int64) *ListGrantVSwitchEnisResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListGrantVSwitchEnisResponseBody) SetNextToken(v string) *ListGrantVSwitchEnisResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListGrantVSwitchEnisResponseBody) SetRequestId(v string) *ListGrantVSwitchEnisResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGrantVSwitchEnisResponseBody) SetTotalCount(v string) *ListGrantVSwitchEnisResponseBody {
	s.TotalCount = &v
	return s
}

type ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis struct {
	// The ENI description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ENI ID.
	NetworkInterfaceId *string `json:"NetworkInterfaceId,omitempty" xml:"NetworkInterfaceId,omitempty"`
	// The ENI name.
	NetworkInterfaceName *string `json:"NetworkInterfaceName,omitempty" xml:"NetworkInterfaceName,omitempty"`
	// The primary private IPv4 address of the ENI.
	PrimaryIpAddress *string `json:"PrimaryIpAddress,omitempty" xml:"PrimaryIpAddress,omitempty"`
	// Indicates whether the ENI is created by a transit router. Valid values:
	//
	// *   **true**
	// *   **false**
	//
	// ENIs that are created by transit routers cannot be used as multicast sources or members.
	TransitRouterFlag *bool `json:"TransitRouterFlag,omitempty" xml:"TransitRouterFlag,omitempty"`
	// The vSwitch ID.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The VPC ID.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis) String() string {
	return tea.Prettify(s)
}

func (s ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis) GoString() string {
	return s.String()
}

func (s *ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis) SetDescription(v string) *ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis {
	s.Description = &v
	return s
}

func (s *ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis) SetNetworkInterfaceId(v string) *ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis {
	s.NetworkInterfaceId = &v
	return s
}

func (s *ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis) SetNetworkInterfaceName(v string) *ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis {
	s.NetworkInterfaceName = &v
	return s
}

func (s *ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis) SetPrimaryIpAddress(v string) *ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis {
	s.PrimaryIpAddress = &v
	return s
}

func (s *ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis) SetTransitRouterFlag(v bool) *ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis {
	s.TransitRouterFlag = &v
	return s
}

func (s *ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis) SetVSwitchId(v string) *ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis {
	s.VSwitchId = &v
	return s
}

func (s *ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis) SetVpcId(v string) *ListGrantVSwitchEnisResponseBodyGrantVSwitchEnis {
	s.VpcId = &v
	return s
}

type ListGrantVSwitchEnisResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGrantVSwitchEnisResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGrantVSwitchEnisResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGrantVSwitchEnisResponse) GoString() string {
	return s.String()
}

func (s *ListGrantVSwitchEnisResponse) SetHeaders(v map[string]*string) *ListGrantVSwitchEnisResponse {
	s.Headers = v
	return s
}

func (s *ListGrantVSwitchEnisResponse) SetStatusCode(v int32) *ListGrantVSwitchEnisResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGrantVSwitchEnisResponse) SetBody(v *ListGrantVSwitchEnisResponseBody) *ListGrantVSwitchEnisResponse {
	s.Body = v
	return s
}

type ListGrantVSwitchesToCenRequest struct {
	// The ID of the CEN instance.
	CenId        *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The page number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The region ID of the VPC.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the zone.
	//
	// *   If you specify a zone ID, the system queries the information about the vSwitches in the specified zone.
	// *   If you do not specify a zone ID, the system queries the information about the vSwitches in all zones.
	//
	// You can call the [DescribeZones](~~36064~~) operation to query the most recent zone list.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ListGrantVSwitchesToCenRequest) String() string {
	return tea.Prettify(s)
}

func (s ListGrantVSwitchesToCenRequest) GoString() string {
	return s.String()
}

func (s *ListGrantVSwitchesToCenRequest) SetCenId(v string) *ListGrantVSwitchesToCenRequest {
	s.CenId = &v
	return s
}

func (s *ListGrantVSwitchesToCenRequest) SetOwnerAccount(v string) *ListGrantVSwitchesToCenRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListGrantVSwitchesToCenRequest) SetOwnerId(v int64) *ListGrantVSwitchesToCenRequest {
	s.OwnerId = &v
	return s
}

func (s *ListGrantVSwitchesToCenRequest) SetPageNumber(v int32) *ListGrantVSwitchesToCenRequest {
	s.PageNumber = &v
	return s
}

func (s *ListGrantVSwitchesToCenRequest) SetPageSize(v int32) *ListGrantVSwitchesToCenRequest {
	s.PageSize = &v
	return s
}

func (s *ListGrantVSwitchesToCenRequest) SetRegionId(v string) *ListGrantVSwitchesToCenRequest {
	s.RegionId = &v
	return s
}

func (s *ListGrantVSwitchesToCenRequest) SetResourceOwnerAccount(v string) *ListGrantVSwitchesToCenRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListGrantVSwitchesToCenRequest) SetResourceOwnerId(v int64) *ListGrantVSwitchesToCenRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListGrantVSwitchesToCenRequest) SetVpcId(v string) *ListGrantVSwitchesToCenRequest {
	s.VpcId = &v
	return s
}

func (s *ListGrantVSwitchesToCenRequest) SetZoneId(v string) *ListGrantVSwitchesToCenRequest {
	s.ZoneId = &v
	return s
}

type ListGrantVSwitchesToCenResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The list of vSwitches.
	VSwitches []*ListGrantVSwitchesToCenResponseBodyVSwitches `json:"VSwitches,omitempty" xml:"VSwitches,omitempty" type:"Repeated"`
}

func (s ListGrantVSwitchesToCenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListGrantVSwitchesToCenResponseBody) GoString() string {
	return s.String()
}

func (s *ListGrantVSwitchesToCenResponseBody) SetPageNumber(v int32) *ListGrantVSwitchesToCenResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListGrantVSwitchesToCenResponseBody) SetPageSize(v int32) *ListGrantVSwitchesToCenResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListGrantVSwitchesToCenResponseBody) SetRequestId(v string) *ListGrantVSwitchesToCenResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListGrantVSwitchesToCenResponseBody) SetTotalCount(v int32) *ListGrantVSwitchesToCenResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListGrantVSwitchesToCenResponseBody) SetVSwitches(v []*ListGrantVSwitchesToCenResponseBodyVSwitches) *ListGrantVSwitchesToCenResponseBody {
	s.VSwitches = v
	return s
}

type ListGrantVSwitchesToCenResponseBodyVSwitches struct {
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The name of the vSwitch.
	VSwitchName *string `json:"VSwitchName,omitempty" xml:"VSwitchName,omitempty"`
	// The ID of the VPC to which the vSwitch belongs.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the zone to which the vSwitch belongs.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ListGrantVSwitchesToCenResponseBodyVSwitches) String() string {
	return tea.Prettify(s)
}

func (s ListGrantVSwitchesToCenResponseBodyVSwitches) GoString() string {
	return s.String()
}

func (s *ListGrantVSwitchesToCenResponseBodyVSwitches) SetVSwitchId(v string) *ListGrantVSwitchesToCenResponseBodyVSwitches {
	s.VSwitchId = &v
	return s
}

func (s *ListGrantVSwitchesToCenResponseBodyVSwitches) SetVSwitchName(v string) *ListGrantVSwitchesToCenResponseBodyVSwitches {
	s.VSwitchName = &v
	return s
}

func (s *ListGrantVSwitchesToCenResponseBodyVSwitches) SetVpcId(v string) *ListGrantVSwitchesToCenResponseBodyVSwitches {
	s.VpcId = &v
	return s
}

func (s *ListGrantVSwitchesToCenResponseBodyVSwitches) SetZoneId(v string) *ListGrantVSwitchesToCenResponseBodyVSwitches {
	s.ZoneId = &v
	return s
}

type ListGrantVSwitchesToCenResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListGrantVSwitchesToCenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListGrantVSwitchesToCenResponse) String() string {
	return tea.Prettify(s)
}

func (s ListGrantVSwitchesToCenResponse) GoString() string {
	return s.String()
}

func (s *ListGrantVSwitchesToCenResponse) SetHeaders(v map[string]*string) *ListGrantVSwitchesToCenResponse {
	s.Headers = v
	return s
}

func (s *ListGrantVSwitchesToCenResponse) SetStatusCode(v int32) *ListGrantVSwitchesToCenResponse {
	s.StatusCode = &v
	return s
}

func (s *ListGrantVSwitchesToCenResponse) SetBody(v *ListGrantVSwitchesToCenResponseBody) *ListGrantVSwitchesToCenResponse {
	s.Body = v
	return s
}

type ListTagResourcesRequest struct {
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The number of entries to return on each page. Valid values: **1** to **50**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the region where the resource is deployed.
	//
	// You can ignore this parameter if ResourceType is set to Cen or BandwidthPackage.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The IDs of the CEN instances.
	//
	// You can specify at most 20 IDs in each call.
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource to which you want to add the tag. Valid values:
	//
	// **Cen**: CEN instance
	//
	// **BandwidthPackage**: bandwidth plan
	//
	// **TransitRouter**: transit router
	//
	// **TransitRouterVpcAttachment**: virtual private cloud (VPC) connection
	//
	// **TransitRouterVbrAttachment**: virtual border router (VBR) connection
	//
	// **TransitRouterPeerAttachment**: inter-region connection
	//
	// **TransitRouterVpnAttachment**: VPN connection
	//
	// **TransitRouterRouteTable**: route table
	//
	// **Flowlog**: flow log
	//
	// **TransitRouterMulticastDomain**: multicast domain
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The information about the tags that are added to the CEN instance.
	//
	// You can query at most 20 tags in each call.
	Tag []*ListTagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s ListTagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequest) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequest) SetNextToken(v string) *ListTagResourcesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesRequest) SetOwnerAccount(v string) *ListTagResourcesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTagResourcesRequest) SetOwnerId(v int64) *ListTagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTagResourcesRequest) SetPageSize(v int32) *ListTagResourcesRequest {
	s.PageSize = &v
	return s
}

func (s *ListTagResourcesRequest) SetRegionId(v string) *ListTagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceId(v []*string) *ListTagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *ListTagResourcesRequest) SetResourceOwnerAccount(v string) *ListTagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceOwnerId(v int64) *ListTagResourcesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTagResourcesRequest) SetResourceType(v string) *ListTagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesRequest) SetTag(v []*ListTagResourcesRequestTag) *ListTagResourcesRequest {
	s.Tag = v
	return s
}

type ListTagResourcesRequestTag struct {
	// The tag key.
	//
	// The tag key cannot exceed 64 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value cannot exceed 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag values.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *ListTagResourcesRequestTag) SetKey(v string) *ListTagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *ListTagResourcesRequestTag) SetValue(v string) *ListTagResourcesRequestTag {
	s.Value = &v
	return s
}

type ListTagResourcesResponseBody struct {
	// The token that determines the start point of the query. Valid values:
	//
	// *   If **NextToken** was not returned, it indicates that no additional results exist.
	// *   If **NextToken** was returned in the previous query, specify the value to obtain the next set of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// A list of resources and tags.
	TagResources *ListTagResourcesResponseBodyTagResources `json:"TagResources,omitempty" xml:"TagResources,omitempty" type:"Struct"`
}

func (s ListTagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBody) SetNextToken(v string) *ListTagResourcesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetRequestId(v string) *ListTagResourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTagResourcesResponseBody) SetTagResources(v *ListTagResourcesResponseBodyTagResources) *ListTagResourcesResponseBody {
	s.TagResources = v
	return s
}

type ListTagResourcesResponseBodyTagResources struct {
	TagResource []*ListTagResourcesResponseBodyTagResourcesTagResource `json:"TagResource,omitempty" xml:"TagResource,omitempty" type:"Repeated"`
}

func (s ListTagResourcesResponseBodyTagResources) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResources) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResources) SetTagResource(v []*ListTagResourcesResponseBodyTagResourcesTagResource) *ListTagResourcesResponseBodyTagResources {
	s.TagResource = v
	return s
}

type ListTagResourcesResponseBodyTagResourcesTagResource struct {
	// The ID of the CEN instance.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the resource. Valid values:
	//
	// **Cen**: CEN instance
	//
	// **BandwidthPackage**: bandwidth plan
	//
	// **TransitRouter**: transit router
	//
	// **TransitRouterVpcAttachment**: virtual private cloud (VPC) connection
	//
	// **TransitRouterVbrAttachment**: virtual border router (VBR) connection
	//
	// **TransitRouterPeerAttachment**: inter-region connection
	//
	// **TransitRouterVpnAttachment**: VPN connection
	//
	// **TransitRouterRouteTable**: route table
	//
	// **Flowlog**: flow log
	//
	// **TransitRouterMulticastDomain**: multicast domain
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The tag key.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The tag value.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponseBodyTagResourcesTagResource) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceId(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceId = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetResourceType(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.ResourceType = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagKey(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagKey = &v
	return s
}

func (s *ListTagResourcesResponseBodyTagResourcesTagResource) SetTagValue(v string) *ListTagResourcesResponseBodyTagResourcesTagResource {
	s.TagValue = &v
	return s
}

type ListTagResourcesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTagResourcesResponse) GoString() string {
	return s.String()
}

func (s *ListTagResourcesResponse) SetHeaders(v map[string]*string) *ListTagResourcesResponse {
	s.Headers = v
	return s
}

func (s *ListTagResourcesResponse) SetStatusCode(v int32) *ListTagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTagResourcesResponse) SetBody(v *ListTagResourcesResponseBody) *ListTagResourcesResponse {
	s.Body = v
	return s
}

type ListTrafficMarkingPoliciesRequest struct {
	MaxResults                      *int32  `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken                       *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount                    *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                         *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount            *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId                 *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TrafficMarkingPolicyDescription *string `json:"TrafficMarkingPolicyDescription,omitempty" xml:"TrafficMarkingPolicyDescription,omitempty"`
	TrafficMarkingPolicyId          *string `json:"TrafficMarkingPolicyId,omitempty" xml:"TrafficMarkingPolicyId,omitempty"`
	TrafficMarkingPolicyName        *string `json:"TrafficMarkingPolicyName,omitempty" xml:"TrafficMarkingPolicyName,omitempty"`
	TransitRouterId                 *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s ListTrafficMarkingPoliciesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMarkingPoliciesRequest) GoString() string {
	return s.String()
}

func (s *ListTrafficMarkingPoliciesRequest) SetMaxResults(v int32) *ListTrafficMarkingPoliciesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTrafficMarkingPoliciesRequest) SetNextToken(v string) *ListTrafficMarkingPoliciesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTrafficMarkingPoliciesRequest) SetOwnerAccount(v string) *ListTrafficMarkingPoliciesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTrafficMarkingPoliciesRequest) SetOwnerId(v int64) *ListTrafficMarkingPoliciesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTrafficMarkingPoliciesRequest) SetResourceOwnerAccount(v string) *ListTrafficMarkingPoliciesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTrafficMarkingPoliciesRequest) SetResourceOwnerId(v int64) *ListTrafficMarkingPoliciesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTrafficMarkingPoliciesRequest) SetTrafficMarkingPolicyDescription(v string) *ListTrafficMarkingPoliciesRequest {
	s.TrafficMarkingPolicyDescription = &v
	return s
}

func (s *ListTrafficMarkingPoliciesRequest) SetTrafficMarkingPolicyId(v string) *ListTrafficMarkingPoliciesRequest {
	s.TrafficMarkingPolicyId = &v
	return s
}

func (s *ListTrafficMarkingPoliciesRequest) SetTrafficMarkingPolicyName(v string) *ListTrafficMarkingPoliciesRequest {
	s.TrafficMarkingPolicyName = &v
	return s
}

func (s *ListTrafficMarkingPoliciesRequest) SetTransitRouterId(v string) *ListTrafficMarkingPoliciesRequest {
	s.TransitRouterId = &v
	return s
}

type ListTrafficMarkingPoliciesResponseBody struct {
	MaxResults             *int32                                                          `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken              *string                                                         `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RequestId              *string                                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount             *int32                                                          `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	TrafficMarkingPolicies []*ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies `json:"TrafficMarkingPolicies,omitempty" xml:"TrafficMarkingPolicies,omitempty" type:"Repeated"`
}

func (s ListTrafficMarkingPoliciesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMarkingPoliciesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTrafficMarkingPoliciesResponseBody) SetMaxResults(v int32) *ListTrafficMarkingPoliciesResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBody) SetNextToken(v string) *ListTrafficMarkingPoliciesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBody) SetRequestId(v string) *ListTrafficMarkingPoliciesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBody) SetTotalCount(v int32) *ListTrafficMarkingPoliciesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBody) SetTrafficMarkingPolicies(v []*ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies) *ListTrafficMarkingPoliciesResponseBody {
	s.TrafficMarkingPolicies = v
	return s
}

type ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies struct {
	MarkingDscp                     *int32                                                                           `json:"MarkingDscp,omitempty" xml:"MarkingDscp,omitempty"`
	Priority                        *int32                                                                           `json:"Priority,omitempty" xml:"Priority,omitempty"`
	TrafficMarkingPolicyDescription *string                                                                          `json:"TrafficMarkingPolicyDescription,omitempty" xml:"TrafficMarkingPolicyDescription,omitempty"`
	TrafficMarkingPolicyId          *string                                                                          `json:"TrafficMarkingPolicyId,omitempty" xml:"TrafficMarkingPolicyId,omitempty"`
	TrafficMarkingPolicyName        *string                                                                          `json:"TrafficMarkingPolicyName,omitempty" xml:"TrafficMarkingPolicyName,omitempty"`
	TrafficMarkingPolicyStatus      *string                                                                          `json:"TrafficMarkingPolicyStatus,omitempty" xml:"TrafficMarkingPolicyStatus,omitempty"`
	TrafficMatchRules               []*ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules `json:"TrafficMatchRules,omitempty" xml:"TrafficMatchRules,omitempty" type:"Repeated"`
	TransitRouterId                 *string                                                                          `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies) GoString() string {
	return s.String()
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies) SetMarkingDscp(v int32) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies {
	s.MarkingDscp = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies) SetPriority(v int32) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies {
	s.Priority = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies) SetTrafficMarkingPolicyDescription(v string) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies {
	s.TrafficMarkingPolicyDescription = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies) SetTrafficMarkingPolicyId(v string) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies {
	s.TrafficMarkingPolicyId = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies) SetTrafficMarkingPolicyName(v string) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies {
	s.TrafficMarkingPolicyName = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies) SetTrafficMarkingPolicyStatus(v string) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies {
	s.TrafficMarkingPolicyStatus = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies) SetTrafficMatchRules(v []*ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies {
	s.TrafficMatchRules = v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies) SetTransitRouterId(v string) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPolicies {
	s.TransitRouterId = &v
	return s
}

type ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules struct {
	DstCidr                     *string  `json:"DstCidr,omitempty" xml:"DstCidr,omitempty"`
	DstPortRange                []*int32 `json:"DstPortRange,omitempty" xml:"DstPortRange,omitempty" type:"Repeated"`
	MatchDscp                   *int32   `json:"MatchDscp,omitempty" xml:"MatchDscp,omitempty"`
	Protocol                    *string  `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	SrcCidr                     *string  `json:"SrcCidr,omitempty" xml:"SrcCidr,omitempty"`
	SrcPortRange                []*int32 `json:"SrcPortRange,omitempty" xml:"SrcPortRange,omitempty" type:"Repeated"`
	TrafficMatchRuleDescription *string  `json:"TrafficMatchRuleDescription,omitempty" xml:"TrafficMatchRuleDescription,omitempty"`
	TrafficMatchRuleId          *string  `json:"TrafficMatchRuleId,omitempty" xml:"TrafficMatchRuleId,omitempty"`
	TrafficMatchRuleName        *string  `json:"TrafficMatchRuleName,omitempty" xml:"TrafficMatchRuleName,omitempty"`
	TrafficMatchRuleStatus      *string  `json:"TrafficMatchRuleStatus,omitempty" xml:"TrafficMatchRuleStatus,omitempty"`
}

func (s ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules) GoString() string {
	return s.String()
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules) SetDstCidr(v string) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules {
	s.DstCidr = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules) SetDstPortRange(v []*int32) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules {
	s.DstPortRange = v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules) SetMatchDscp(v int32) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules {
	s.MatchDscp = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules) SetProtocol(v string) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules {
	s.Protocol = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules) SetSrcCidr(v string) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules {
	s.SrcCidr = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules) SetSrcPortRange(v []*int32) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules {
	s.SrcPortRange = v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules) SetTrafficMatchRuleDescription(v string) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules {
	s.TrafficMatchRuleDescription = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules) SetTrafficMatchRuleId(v string) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules {
	s.TrafficMatchRuleId = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules) SetTrafficMatchRuleName(v string) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules {
	s.TrafficMatchRuleName = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules) SetTrafficMatchRuleStatus(v string) *ListTrafficMarkingPoliciesResponseBodyTrafficMarkingPoliciesTrafficMatchRules {
	s.TrafficMatchRuleStatus = &v
	return s
}

type ListTrafficMarkingPoliciesResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTrafficMarkingPoliciesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTrafficMarkingPoliciesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTrafficMarkingPoliciesResponse) GoString() string {
	return s.String()
}

func (s *ListTrafficMarkingPoliciesResponse) SetHeaders(v map[string]*string) *ListTrafficMarkingPoliciesResponse {
	s.Headers = v
	return s
}

func (s *ListTrafficMarkingPoliciesResponse) SetStatusCode(v int32) *ListTrafficMarkingPoliciesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTrafficMarkingPoliciesResponse) SetBody(v *ListTrafficMarkingPoliciesResponseBody) *ListTrafficMarkingPoliciesResponse {
	s.Body = v
	return s
}

type ListTransitRouterAvailableResourceRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the Enterprise Edition transit router.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether to query only the zones in which the multicast feature is supported. Valid values:
	//
	// *   **true**
	//
	//     After you call **ListTransitRouterAvailableResource**, if no zone is returned, it indicates that the Enterprise Edition transit router does not support the multicast feature.
	//
	// *   **false** (default)
	SupportMulticast *bool `json:"SupportMulticast,omitempty" xml:"SupportMulticast,omitempty"`
}

func (s ListTransitRouterAvailableResourceRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterAvailableResourceRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterAvailableResourceRequest) SetOwnerAccount(v string) *ListTransitRouterAvailableResourceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterAvailableResourceRequest) SetOwnerId(v int64) *ListTransitRouterAvailableResourceRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterAvailableResourceRequest) SetRegionId(v string) *ListTransitRouterAvailableResourceRequest {
	s.RegionId = &v
	return s
}

func (s *ListTransitRouterAvailableResourceRequest) SetResourceOwnerAccount(v string) *ListTransitRouterAvailableResourceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterAvailableResourceRequest) SetResourceOwnerId(v int64) *ListTransitRouterAvailableResourceRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterAvailableResourceRequest) SetSupportMulticast(v bool) *ListTransitRouterAvailableResourceRequest {
	s.SupportMulticast = &v
	return s
}

type ListTransitRouterAvailableResourceResponseBody struct {
	// A list of zone IDs.
	AvailableZones []*string `json:"AvailableZones,omitempty" xml:"AvailableZones,omitempty" type:"Repeated"`
	// A list of primary zones.
	MasterZones []*string `json:"MasterZones,omitempty" xml:"MasterZones,omitempty" type:"Repeated"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// A list of secondary zone IDs.
	SlaveZones []*string `json:"SlaveZones,omitempty" xml:"SlaveZones,omitempty" type:"Repeated"`
	// Indicates whether the zone supports the multicast feature.
	SupportMulticast *bool `json:"SupportMulticast,omitempty" xml:"SupportMulticast,omitempty"`
}

func (s ListTransitRouterAvailableResourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterAvailableResourceResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterAvailableResourceResponseBody) SetAvailableZones(v []*string) *ListTransitRouterAvailableResourceResponseBody {
	s.AvailableZones = v
	return s
}

func (s *ListTransitRouterAvailableResourceResponseBody) SetMasterZones(v []*string) *ListTransitRouterAvailableResourceResponseBody {
	s.MasterZones = v
	return s
}

func (s *ListTransitRouterAvailableResourceResponseBody) SetRequestId(v string) *ListTransitRouterAvailableResourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRouterAvailableResourceResponseBody) SetSlaveZones(v []*string) *ListTransitRouterAvailableResourceResponseBody {
	s.SlaveZones = v
	return s
}

func (s *ListTransitRouterAvailableResourceResponseBody) SetSupportMulticast(v bool) *ListTransitRouterAvailableResourceResponseBody {
	s.SupportMulticast = &v
	return s
}

type ListTransitRouterAvailableResourceResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterAvailableResourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterAvailableResourceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterAvailableResourceResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterAvailableResourceResponse) SetHeaders(v map[string]*string) *ListTransitRouterAvailableResourceResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterAvailableResourceResponse) SetStatusCode(v int32) *ListTransitRouterAvailableResourceResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterAvailableResourceResponse) SetBody(v *ListTransitRouterAvailableResourceResponseBody) *ListTransitRouterAvailableResourceResponse {
	s.Body = v
	return s
}

type ListTransitRouterCidrRequest struct {
	ClientToken          *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TransitRouterCidrId  *string `json:"TransitRouterCidrId,omitempty" xml:"TransitRouterCidrId,omitempty"`
	TransitRouterId      *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s ListTransitRouterCidrRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterCidrRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterCidrRequest) SetClientToken(v string) *ListTransitRouterCidrRequest {
	s.ClientToken = &v
	return s
}

func (s *ListTransitRouterCidrRequest) SetDryRun(v bool) *ListTransitRouterCidrRequest {
	s.DryRun = &v
	return s
}

func (s *ListTransitRouterCidrRequest) SetOwnerAccount(v string) *ListTransitRouterCidrRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterCidrRequest) SetOwnerId(v int64) *ListTransitRouterCidrRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterCidrRequest) SetRegionId(v string) *ListTransitRouterCidrRequest {
	s.RegionId = &v
	return s
}

func (s *ListTransitRouterCidrRequest) SetResourceOwnerAccount(v string) *ListTransitRouterCidrRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterCidrRequest) SetResourceOwnerId(v int64) *ListTransitRouterCidrRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterCidrRequest) SetTransitRouterCidrId(v string) *ListTransitRouterCidrRequest {
	s.TransitRouterCidrId = &v
	return s
}

func (s *ListTransitRouterCidrRequest) SetTransitRouterId(v string) *ListTransitRouterCidrRequest {
	s.TransitRouterId = &v
	return s
}

type ListTransitRouterCidrResponseBody struct {
	CidrLists []*ListTransitRouterCidrResponseBodyCidrLists `json:"CidrLists,omitempty" xml:"CidrLists,omitempty" type:"Repeated"`
	RequestId *string                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListTransitRouterCidrResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterCidrResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterCidrResponseBody) SetCidrLists(v []*ListTransitRouterCidrResponseBodyCidrLists) *ListTransitRouterCidrResponseBody {
	s.CidrLists = v
	return s
}

func (s *ListTransitRouterCidrResponseBody) SetRequestId(v string) *ListTransitRouterCidrResponseBody {
	s.RequestId = &v
	return s
}

type ListTransitRouterCidrResponseBodyCidrLists struct {
	Cidr                *string `json:"Cidr,omitempty" xml:"Cidr,omitempty"`
	Description         *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Family              *string `json:"Family,omitempty" xml:"Family,omitempty"`
	Name                *string `json:"Name,omitempty" xml:"Name,omitempty"`
	PublishCidrRoute    *bool   `json:"PublishCidrRoute,omitempty" xml:"PublishCidrRoute,omitempty"`
	TransitRouterCidrId *string `json:"TransitRouterCidrId,omitempty" xml:"TransitRouterCidrId,omitempty"`
	TransitRouterId     *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s ListTransitRouterCidrResponseBodyCidrLists) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterCidrResponseBodyCidrLists) GoString() string {
	return s.String()
}

func (s *ListTransitRouterCidrResponseBodyCidrLists) SetCidr(v string) *ListTransitRouterCidrResponseBodyCidrLists {
	s.Cidr = &v
	return s
}

func (s *ListTransitRouterCidrResponseBodyCidrLists) SetDescription(v string) *ListTransitRouterCidrResponseBodyCidrLists {
	s.Description = &v
	return s
}

func (s *ListTransitRouterCidrResponseBodyCidrLists) SetFamily(v string) *ListTransitRouterCidrResponseBodyCidrLists {
	s.Family = &v
	return s
}

func (s *ListTransitRouterCidrResponseBodyCidrLists) SetName(v string) *ListTransitRouterCidrResponseBodyCidrLists {
	s.Name = &v
	return s
}

func (s *ListTransitRouterCidrResponseBodyCidrLists) SetPublishCidrRoute(v bool) *ListTransitRouterCidrResponseBodyCidrLists {
	s.PublishCidrRoute = &v
	return s
}

func (s *ListTransitRouterCidrResponseBodyCidrLists) SetTransitRouterCidrId(v string) *ListTransitRouterCidrResponseBodyCidrLists {
	s.TransitRouterCidrId = &v
	return s
}

func (s *ListTransitRouterCidrResponseBodyCidrLists) SetTransitRouterId(v string) *ListTransitRouterCidrResponseBodyCidrLists {
	s.TransitRouterId = &v
	return s
}

type ListTransitRouterCidrResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterCidrResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterCidrResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterCidrResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterCidrResponse) SetHeaders(v map[string]*string) *ListTransitRouterCidrResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterCidrResponse) SetStatusCode(v int32) *ListTransitRouterCidrResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterCidrResponse) SetBody(v *ListTransitRouterCidrResponseBody) *ListTransitRouterCidrResponse {
	s.Body = v
	return s
}

type ListTransitRouterCidrAllocationRequest struct {
	// The ID of the network instance connection.
	AttachmentId *string `json:"AttachmentId,omitempty" xml:"AttachmentId,omitempty"`
	// The name of the network instance connection.
	AttachmentName *string `json:"AttachmentName,omitempty" xml:"AttachmentName,omitempty"`
	// The CIDR block of the transit router.
	Cidr *string `json:"Cidr,omitempty" xml:"Cidr,omitempty"`
	// The CIDR blocks that have IP addresses allocated to network instances.
	CidrBlock *string `json:"CidrBlock,omitempty" xml:"CidrBlock,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, ClientToken is set to the value of RequestId. The value of RequestId for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The CIDR block that is for exclusive use.
	//
	// Set the value to **VPN**, which specifies the CIDR block that is reserved for VPN connections.
	DedicatedOwnerId *string `json:"DedicatedOwnerId,omitempty" xml:"DedicatedOwnerId,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The number of entries to return on each page.
	//
	// *   If you do not set **MaxResults**, it indicates that you do not need to query results in batches. The value of **MaxResults** indicates the total number of entries.
	//
	// *   If a value is specified for **MaxResults**, it indicates that you need to query results in batches. Valid values: **1** to **100**. We recommend that you set **MaxResults** to **20**.
	//
	//         The value of **MaxResults** in the response indicates the number of entries in the current batch.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query or no subsequent query is to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the value to the value of **NextToken** that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the transit router is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the CIDR block.
	//
	// You can call the [ListTransitRouterCidr](~~462772~~) operation to query the ID of a CIDR block.
	TransitRouterCidrId *string `json:"TransitRouterCidrId,omitempty" xml:"TransitRouterCidrId,omitempty"`
	// The ID of the transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s ListTransitRouterCidrAllocationRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterCidrAllocationRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterCidrAllocationRequest) SetAttachmentId(v string) *ListTransitRouterCidrAllocationRequest {
	s.AttachmentId = &v
	return s
}

func (s *ListTransitRouterCidrAllocationRequest) SetAttachmentName(v string) *ListTransitRouterCidrAllocationRequest {
	s.AttachmentName = &v
	return s
}

func (s *ListTransitRouterCidrAllocationRequest) SetCidr(v string) *ListTransitRouterCidrAllocationRequest {
	s.Cidr = &v
	return s
}

func (s *ListTransitRouterCidrAllocationRequest) SetCidrBlock(v string) *ListTransitRouterCidrAllocationRequest {
	s.CidrBlock = &v
	return s
}

func (s *ListTransitRouterCidrAllocationRequest) SetClientToken(v string) *ListTransitRouterCidrAllocationRequest {
	s.ClientToken = &v
	return s
}

func (s *ListTransitRouterCidrAllocationRequest) SetDedicatedOwnerId(v string) *ListTransitRouterCidrAllocationRequest {
	s.DedicatedOwnerId = &v
	return s
}

func (s *ListTransitRouterCidrAllocationRequest) SetDryRun(v bool) *ListTransitRouterCidrAllocationRequest {
	s.DryRun = &v
	return s
}

func (s *ListTransitRouterCidrAllocationRequest) SetMaxResults(v int32) *ListTransitRouterCidrAllocationRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterCidrAllocationRequest) SetNextToken(v string) *ListTransitRouterCidrAllocationRequest {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterCidrAllocationRequest) SetOwnerAccount(v string) *ListTransitRouterCidrAllocationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterCidrAllocationRequest) SetOwnerId(v int64) *ListTransitRouterCidrAllocationRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterCidrAllocationRequest) SetRegionId(v string) *ListTransitRouterCidrAllocationRequest {
	s.RegionId = &v
	return s
}

func (s *ListTransitRouterCidrAllocationRequest) SetResourceOwnerAccount(v string) *ListTransitRouterCidrAllocationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterCidrAllocationRequest) SetResourceOwnerId(v int64) *ListTransitRouterCidrAllocationRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterCidrAllocationRequest) SetTransitRouterCidrId(v string) *ListTransitRouterCidrAllocationRequest {
	s.TransitRouterCidrId = &v
	return s
}

func (s *ListTransitRouterCidrAllocationRequest) SetTransitRouterId(v string) *ListTransitRouterCidrAllocationRequest {
	s.TransitRouterId = &v
	return s
}

type ListTransitRouterCidrAllocationResponseBody struct {
	// The number of entries returned per page.
	//
	// *   If no value is specified for **MaxResults**, query results are returned in one batch. The value of **MaxResults** indicates the total number of entries.
	// *   If a value is specified for **MaxResults**, query results are returned in batches. The value of **MaxResults** in the response indicates the number of entries in the current batch.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. Valid values:
	//
	// *   If **NextToken** was not returned, it indicates that no additional results exist.
	// *   If **NextToken** was returned in the previous query, specify the value to obtain the next set of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The information about the CIDR blocks that have IP addresses allocated to network instances.
	TransitRouterCidrAllocations []*ListTransitRouterCidrAllocationResponseBodyTransitRouterCidrAllocations `json:"TransitRouterCidrAllocations,omitempty" xml:"TransitRouterCidrAllocations,omitempty" type:"Repeated"`
}

func (s ListTransitRouterCidrAllocationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterCidrAllocationResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterCidrAllocationResponseBody) SetMaxResults(v int32) *ListTransitRouterCidrAllocationResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterCidrAllocationResponseBody) SetNextToken(v string) *ListTransitRouterCidrAllocationResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterCidrAllocationResponseBody) SetRequestId(v string) *ListTransitRouterCidrAllocationResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRouterCidrAllocationResponseBody) SetTotalCount(v int32) *ListTransitRouterCidrAllocationResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTransitRouterCidrAllocationResponseBody) SetTransitRouterCidrAllocations(v []*ListTransitRouterCidrAllocationResponseBodyTransitRouterCidrAllocations) *ListTransitRouterCidrAllocationResponseBody {
	s.TransitRouterCidrAllocations = v
	return s
}

type ListTransitRouterCidrAllocationResponseBodyTransitRouterCidrAllocations struct {
	// The CIDR blocks that have IP addresses allocated to network instances.
	AllocatedCidrBlock *string `json:"AllocatedCidrBlock,omitempty" xml:"AllocatedCidrBlock,omitempty"`
	// The ID of the network instance connection.
	AttachmentId *string `json:"AttachmentId,omitempty" xml:"AttachmentId,omitempty"`
	// The name of the network instance connection.
	AttachmentName *string `json:"AttachmentName,omitempty" xml:"AttachmentName,omitempty"`
	// The CIDR block of the transit router.
	Cidr *string `json:"Cidr,omitempty" xml:"Cidr,omitempty"`
	// The ID of the CIDR block.
	TransitRouterCidrId *string `json:"TransitRouterCidrId,omitempty" xml:"TransitRouterCidrId,omitempty"`
}

func (s ListTransitRouterCidrAllocationResponseBodyTransitRouterCidrAllocations) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterCidrAllocationResponseBodyTransitRouterCidrAllocations) GoString() string {
	return s.String()
}

func (s *ListTransitRouterCidrAllocationResponseBodyTransitRouterCidrAllocations) SetAllocatedCidrBlock(v string) *ListTransitRouterCidrAllocationResponseBodyTransitRouterCidrAllocations {
	s.AllocatedCidrBlock = &v
	return s
}

func (s *ListTransitRouterCidrAllocationResponseBodyTransitRouterCidrAllocations) SetAttachmentId(v string) *ListTransitRouterCidrAllocationResponseBodyTransitRouterCidrAllocations {
	s.AttachmentId = &v
	return s
}

func (s *ListTransitRouterCidrAllocationResponseBodyTransitRouterCidrAllocations) SetAttachmentName(v string) *ListTransitRouterCidrAllocationResponseBodyTransitRouterCidrAllocations {
	s.AttachmentName = &v
	return s
}

func (s *ListTransitRouterCidrAllocationResponseBodyTransitRouterCidrAllocations) SetCidr(v string) *ListTransitRouterCidrAllocationResponseBodyTransitRouterCidrAllocations {
	s.Cidr = &v
	return s
}

func (s *ListTransitRouterCidrAllocationResponseBodyTransitRouterCidrAllocations) SetTransitRouterCidrId(v string) *ListTransitRouterCidrAllocationResponseBodyTransitRouterCidrAllocations {
	s.TransitRouterCidrId = &v
	return s
}

type ListTransitRouterCidrAllocationResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterCidrAllocationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterCidrAllocationResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterCidrAllocationResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterCidrAllocationResponse) SetHeaders(v map[string]*string) *ListTransitRouterCidrAllocationResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterCidrAllocationResponse) SetStatusCode(v int32) *ListTransitRouterCidrAllocationResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterCidrAllocationResponse) SetBody(v *ListTransitRouterCidrAllocationResponseBody) *ListTransitRouterCidrAllocationResponse {
	s.Body = v
	return s
}

type ListTransitRouterMulticastDomainAssociationsRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can only contain ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The number of entries to return on each page. Default value: **20**.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource associated with the multicast domain.
	ResourceId           *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of resource associated with the multicast domain.
	//
	// Valid value: **VPC**.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the multicast domain.
	TransitRouterMulticastDomainId *string `json:"TransitRouterMulticastDomainId,omitempty" xml:"TransitRouterMulticastDomainId,omitempty"`
	// The vSwitch IDs.
	//
	// You can specify at most 20 IDs.
	VSwitchIds []*string `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Repeated"`
}

func (s ListTransitRouterMulticastDomainAssociationsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastDomainAssociationsRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastDomainAssociationsRequest) SetClientToken(v string) *ListTransitRouterMulticastDomainAssociationsRequest {
	s.ClientToken = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsRequest) SetMaxResults(v int64) *ListTransitRouterMulticastDomainAssociationsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsRequest) SetNextToken(v string) *ListTransitRouterMulticastDomainAssociationsRequest {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsRequest) SetOwnerAccount(v string) *ListTransitRouterMulticastDomainAssociationsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsRequest) SetOwnerId(v int64) *ListTransitRouterMulticastDomainAssociationsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsRequest) SetResourceId(v string) *ListTransitRouterMulticastDomainAssociationsRequest {
	s.ResourceId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsRequest) SetResourceOwnerAccount(v string) *ListTransitRouterMulticastDomainAssociationsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsRequest) SetResourceOwnerId(v int64) *ListTransitRouterMulticastDomainAssociationsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsRequest) SetResourceType(v string) *ListTransitRouterMulticastDomainAssociationsRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsRequest) SetTransitRouterAttachmentId(v string) *ListTransitRouterMulticastDomainAssociationsRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsRequest) SetTransitRouterMulticastDomainId(v string) *ListTransitRouterMulticastDomainAssociationsRequest {
	s.TransitRouterMulticastDomainId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsRequest) SetVSwitchIds(v []*string) *ListTransitRouterMulticastDomainAssociationsRequest {
	s.VSwitchIds = v
	return s
}

type ListTransitRouterMulticastDomainAssociationsResponseBody struct {
	// The number of entries returned on each page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If **NextToken** is empty, it indicates that no subsequent query is to be sent.
	// *   If **NextToken** was returned in the previous query, specify the value to obtain the next set of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The information about the resource associated with the multicast domain.
	TransitRouterMulticastAssociations []*ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations `json:"TransitRouterMulticastAssociations,omitempty" xml:"TransitRouterMulticastAssociations,omitempty" type:"Repeated"`
}

func (s ListTransitRouterMulticastDomainAssociationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastDomainAssociationsResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastDomainAssociationsResponseBody) SetMaxResults(v int32) *ListTransitRouterMulticastDomainAssociationsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsResponseBody) SetNextToken(v string) *ListTransitRouterMulticastDomainAssociationsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsResponseBody) SetRequestId(v string) *ListTransitRouterMulticastDomainAssociationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsResponseBody) SetTotalCount(v int32) *ListTransitRouterMulticastDomainAssociationsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsResponseBody) SetTransitRouterMulticastAssociations(v []*ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations) *ListTransitRouterMulticastDomainAssociationsResponseBody {
	s.TransitRouterMulticastAssociations = v
	return s
}

type ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations struct {
	// The ID of the resource associated with the multicast domain.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The ID of the Alibaba Cloud account to which the resource associated with the multicast domain belongs.
	ResourceOwnerId *int64 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of resource associated with the multicast domain.
	//
	// Valid value: **VPC**.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The association status. Valid values:
	//
	// *   **Associated**: The resource is associated with the multicast domain.
	// *   **Associating**: The resource is being associated with the multicast domain.
	// *   **Dissociating**: The resource is being disassociated from the multicast domain.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the multicast domain.
	TransitRouterMulticastDomainId *string `json:"TransitRouterMulticastDomainId,omitempty" xml:"TransitRouterMulticastDomainId,omitempty"`
	// The ID of the vSwitch.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations) SetResourceId(v string) *ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations {
	s.ResourceId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations) SetResourceOwnerId(v int64) *ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations) SetResourceType(v string) *ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations {
	s.ResourceType = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations) SetStatus(v string) *ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations {
	s.Status = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations) SetTransitRouterAttachmentId(v string) *ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations) SetTransitRouterMulticastDomainId(v string) *ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations {
	s.TransitRouterMulticastDomainId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations) SetVSwitchId(v string) *ListTransitRouterMulticastDomainAssociationsResponseBodyTransitRouterMulticastAssociations {
	s.VSwitchId = &v
	return s
}

type ListTransitRouterMulticastDomainAssociationsResponse struct {
	Headers    map[string]*string                                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterMulticastDomainAssociationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterMulticastDomainAssociationsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastDomainAssociationsResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastDomainAssociationsResponse) SetHeaders(v map[string]*string) *ListTransitRouterMulticastDomainAssociationsResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsResponse) SetStatusCode(v int32) *ListTransitRouterMulticastDomainAssociationsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterMulticastDomainAssociationsResponse) SetBody(v *ListTransitRouterMulticastDomainAssociationsResponseBody) *ListTransitRouterMulticastDomainAssociationsResponse {
	s.Body = v
	return s
}

type ListTransitRouterMulticastDomainVSwitchesRequest struct {
	CenId                *string   `json:"CenId,omitempty" xml:"CenId,omitempty"`
	MaxResults           *int32    `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken            *string   `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount         *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	VSwitchIds           []*string `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Repeated"`
	VpcId                *string   `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ListTransitRouterMulticastDomainVSwitchesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastDomainVSwitchesRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastDomainVSwitchesRequest) SetCenId(v string) *ListTransitRouterMulticastDomainVSwitchesRequest {
	s.CenId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainVSwitchesRequest) SetMaxResults(v int32) *ListTransitRouterMulticastDomainVSwitchesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterMulticastDomainVSwitchesRequest) SetNextToken(v string) *ListTransitRouterMulticastDomainVSwitchesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterMulticastDomainVSwitchesRequest) SetOwnerAccount(v string) *ListTransitRouterMulticastDomainVSwitchesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterMulticastDomainVSwitchesRequest) SetOwnerId(v int64) *ListTransitRouterMulticastDomainVSwitchesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainVSwitchesRequest) SetResourceOwnerAccount(v string) *ListTransitRouterMulticastDomainVSwitchesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterMulticastDomainVSwitchesRequest) SetResourceOwnerId(v int64) *ListTransitRouterMulticastDomainVSwitchesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainVSwitchesRequest) SetVSwitchIds(v []*string) *ListTransitRouterMulticastDomainVSwitchesRequest {
	s.VSwitchIds = v
	return s
}

func (s *ListTransitRouterMulticastDomainVSwitchesRequest) SetVpcId(v string) *ListTransitRouterMulticastDomainVSwitchesRequest {
	s.VpcId = &v
	return s
}

type ListTransitRouterMulticastDomainVSwitchesResponseBody struct {
	MaxResults *int32    `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	NextToken  *string   `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RequestId  *string   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount *int32    `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	VSwitchIds []*string `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Repeated"`
}

func (s ListTransitRouterMulticastDomainVSwitchesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastDomainVSwitchesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastDomainVSwitchesResponseBody) SetMaxResults(v int32) *ListTransitRouterMulticastDomainVSwitchesResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterMulticastDomainVSwitchesResponseBody) SetNextToken(v string) *ListTransitRouterMulticastDomainVSwitchesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterMulticastDomainVSwitchesResponseBody) SetRequestId(v string) *ListTransitRouterMulticastDomainVSwitchesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainVSwitchesResponseBody) SetTotalCount(v int32) *ListTransitRouterMulticastDomainVSwitchesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTransitRouterMulticastDomainVSwitchesResponseBody) SetVSwitchIds(v []*string) *ListTransitRouterMulticastDomainVSwitchesResponseBody {
	s.VSwitchIds = v
	return s
}

type ListTransitRouterMulticastDomainVSwitchesResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterMulticastDomainVSwitchesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterMulticastDomainVSwitchesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastDomainVSwitchesResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastDomainVSwitchesResponse) SetHeaders(v map[string]*string) *ListTransitRouterMulticastDomainVSwitchesResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterMulticastDomainVSwitchesResponse) SetStatusCode(v int32) *ListTransitRouterMulticastDomainVSwitchesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterMulticastDomainVSwitchesResponse) SetBody(v *ListTransitRouterMulticastDomainVSwitchesResponseBody) *ListTransitRouterMulticastDomainVSwitchesResponse {
	s.Body = v
	return s
}

type ListTransitRouterMulticastDomainsRequest struct {
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The number of entries to return on each page. Default value: **20**.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. Valid values:
	//
	// *   You do not need to specify this parameter for the first request.
	// *   If a value is returned for NextToken, specify the value in the next request to retrieve a new page of results.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the transit router.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The tags.
	//
	// You can specify at most 20 tags in each call.
	Tag []*ListTransitRouterMulticastDomainsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The transit router ID.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The multicast domain ID.
	TransitRouterMulticastDomainId *string `json:"TransitRouterMulticastDomainId,omitempty" xml:"TransitRouterMulticastDomainId,omitempty"`
}

func (s ListTransitRouterMulticastDomainsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastDomainsRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastDomainsRequest) SetCenId(v string) *ListTransitRouterMulticastDomainsRequest {
	s.CenId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsRequest) SetClientToken(v string) *ListTransitRouterMulticastDomainsRequest {
	s.ClientToken = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsRequest) SetMaxResults(v int64) *ListTransitRouterMulticastDomainsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsRequest) SetNextToken(v string) *ListTransitRouterMulticastDomainsRequest {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsRequest) SetOwnerAccount(v string) *ListTransitRouterMulticastDomainsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsRequest) SetOwnerId(v int64) *ListTransitRouterMulticastDomainsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsRequest) SetRegionId(v string) *ListTransitRouterMulticastDomainsRequest {
	s.RegionId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsRequest) SetResourceOwnerAccount(v string) *ListTransitRouterMulticastDomainsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsRequest) SetResourceOwnerId(v int64) *ListTransitRouterMulticastDomainsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsRequest) SetTag(v []*ListTransitRouterMulticastDomainsRequestTag) *ListTransitRouterMulticastDomainsRequest {
	s.Tag = v
	return s
}

func (s *ListTransitRouterMulticastDomainsRequest) SetTransitRouterId(v string) *ListTransitRouterMulticastDomainsRequest {
	s.TransitRouterId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsRequest) SetTransitRouterMulticastDomainId(v string) *ListTransitRouterMulticastDomainsRequest {
	s.TransitRouterMulticastDomainId = &v
	return s
}

type ListTransitRouterMulticastDomainsRequestTag struct {
	// The tag keys.
	//
	// The tag keys cannot be an empty string. The tag keys can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag values.
	//
	// The tag values can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTransitRouterMulticastDomainsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastDomainsRequestTag) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastDomainsRequestTag) SetKey(v string) *ListTransitRouterMulticastDomainsRequestTag {
	s.Key = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsRequestTag) SetValue(v string) *ListTransitRouterMulticastDomainsRequestTag {
	s.Value = &v
	return s
}

type ListTransitRouterMulticastDomainsResponseBody struct {
	// The number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results. Valid values:
	//
	// *   If **NextToken** is empty, no next page exists.
	// *   If a value is returned for **NextToken**, the value is the token that determines the start point of the next query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The information about the multicast domain.
	TransitRouterMulticastDomains []*ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains `json:"TransitRouterMulticastDomains,omitempty" xml:"TransitRouterMulticastDomains,omitempty" type:"Repeated"`
}

func (s ListTransitRouterMulticastDomainsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastDomainsResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastDomainsResponseBody) SetMaxResults(v int32) *ListTransitRouterMulticastDomainsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsResponseBody) SetNextToken(v string) *ListTransitRouterMulticastDomainsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsResponseBody) SetRequestId(v string) *ListTransitRouterMulticastDomainsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsResponseBody) SetTotalCount(v int32) *ListTransitRouterMulticastDomainsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsResponseBody) SetTransitRouterMulticastDomains(v []*ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains) *ListTransitRouterMulticastDomainsResponseBody {
	s.TransitRouterMulticastDomains = v
	return s
}

type ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains struct {
	// The CEN instance ID.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The region ID of the transit router.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The status of the multicast domain.
	//
	// The valid value is **Active**, which indicates that the multicast domain is available.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tags.
	Tags []*ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomainsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The transit router ID.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The description of the multicast domain.
	TransitRouterMulticastDomainDescription *string `json:"TransitRouterMulticastDomainDescription,omitempty" xml:"TransitRouterMulticastDomainDescription,omitempty"`
	// The ID of the multicast domain.
	TransitRouterMulticastDomainId *string `json:"TransitRouterMulticastDomainId,omitempty" xml:"TransitRouterMulticastDomainId,omitempty"`
	// The name of the multicast domain.
	TransitRouterMulticastDomainName *string `json:"TransitRouterMulticastDomainName,omitempty" xml:"TransitRouterMulticastDomainName,omitempty"`
}

func (s ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains) SetCenId(v string) *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains {
	s.CenId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains) SetRegionId(v string) *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains {
	s.RegionId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains) SetStatus(v string) *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains {
	s.Status = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains) SetTags(v []*ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomainsTags) *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains {
	s.Tags = v
	return s
}

func (s *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains) SetTransitRouterId(v string) *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains {
	s.TransitRouterId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains) SetTransitRouterMulticastDomainDescription(v string) *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains {
	s.TransitRouterMulticastDomainDescription = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains) SetTransitRouterMulticastDomainId(v string) *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains {
	s.TransitRouterMulticastDomainId = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains) SetTransitRouterMulticastDomainName(v string) *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomains {
	s.TransitRouterMulticastDomainName = &v
	return s
}

type ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomainsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomainsTags) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomainsTags) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomainsTags) SetKey(v string) *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomainsTags {
	s.Key = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomainsTags) SetValue(v string) *ListTransitRouterMulticastDomainsResponseBodyTransitRouterMulticastDomainsTags {
	s.Value = &v
	return s
}

type ListTransitRouterMulticastDomainsResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterMulticastDomainsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterMulticastDomainsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastDomainsResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastDomainsResponse) SetHeaders(v map[string]*string) *ListTransitRouterMulticastDomainsResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterMulticastDomainsResponse) SetStatusCode(v int32) *ListTransitRouterMulticastDomainsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterMulticastDomainsResponse) SetBody(v *ListTransitRouterMulticastDomainsResponseBody) *ListTransitRouterMulticastDomainsResponse {
	s.Body = v
	return s
}

type ListTransitRouterMulticastGroupsRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among all requests. The token can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The IP address of the multicast group.
	//
	// Each multicast group is identified by its IP address.
	GroupIpAddress *string `json:"GroupIpAddress,omitempty" xml:"GroupIpAddress,omitempty"`
	// Specified whether to query the multicast members. Valid values:
	//
	// *   **false**: no
	// *   **true**: yes
	//
	// > This parameter can be set together with the IsGroupMember parameter.
	//
	// *   If you do not set IsGroupMember or IsGroupSource, both the multicast sources and members are queried.
	//
	// *   If you set only one of them or both of them, the specified values prevail.
	IsGroupMember *bool `json:"IsGroupMember,omitempty" xml:"IsGroupMember,omitempty"`
	// Specifies whether to query the multicast sources. Valid values:
	//
	// *   **false**: no
	// *   **true**: yes
	//
	// > This parameter can be set together with the IsGroupMember parameter.
	//
	// *   If you do not set IsGroupSource or IsGroupMember, both the multicast sources and members are queried.
	//
	// *   If you set only one of them or both of them, the specified values prevail.
	IsGroupSource *bool `json:"IsGroupSource,omitempty" xml:"IsGroupSource,omitempty"`
	// The number of entries to return on each page. Default value: **20**.
	MaxResults *int64 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The IDs of ENIs.
	NetworkInterfaceIds []*string `json:"NetworkInterfaceIds,omitempty" xml:"NetworkInterfaceIds,omitempty" type:"Repeated"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query and no next queries are to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the inter-region multicast domain.
	PeerTransitRouterMulticastDomains []*string `json:"PeerTransitRouterMulticastDomains,omitempty" xml:"PeerTransitRouterMulticastDomains,omitempty" type:"Repeated"`
	// The ID of the resource associated with the multicast resource.
	ResourceId           *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the multicast resource. Valid values:
	//
	// *   **VPC**: queries multicast resources by VPC.
	// *   **TR**: queries multicast resources that are also deployed in a different region.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the multicast domain.
	TransitRouterMulticastDomainId *string `json:"TransitRouterMulticastDomainId,omitempty" xml:"TransitRouterMulticastDomainId,omitempty"`
	// The vSwitch IDs.
	VSwitchIds []*string `json:"VSwitchIds,omitempty" xml:"VSwitchIds,omitempty" type:"Repeated"`
}

func (s ListTransitRouterMulticastGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastGroupsRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastGroupsRequest) SetClientToken(v string) *ListTransitRouterMulticastGroupsRequest {
	s.ClientToken = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetGroupIpAddress(v string) *ListTransitRouterMulticastGroupsRequest {
	s.GroupIpAddress = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetIsGroupMember(v bool) *ListTransitRouterMulticastGroupsRequest {
	s.IsGroupMember = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetIsGroupSource(v bool) *ListTransitRouterMulticastGroupsRequest {
	s.IsGroupSource = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetMaxResults(v int64) *ListTransitRouterMulticastGroupsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetNetworkInterfaceIds(v []*string) *ListTransitRouterMulticastGroupsRequest {
	s.NetworkInterfaceIds = v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetNextToken(v string) *ListTransitRouterMulticastGroupsRequest {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetOwnerAccount(v string) *ListTransitRouterMulticastGroupsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetOwnerId(v int64) *ListTransitRouterMulticastGroupsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetPeerTransitRouterMulticastDomains(v []*string) *ListTransitRouterMulticastGroupsRequest {
	s.PeerTransitRouterMulticastDomains = v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetResourceId(v string) *ListTransitRouterMulticastGroupsRequest {
	s.ResourceId = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetResourceOwnerAccount(v string) *ListTransitRouterMulticastGroupsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetResourceOwnerId(v int64) *ListTransitRouterMulticastGroupsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetResourceType(v string) *ListTransitRouterMulticastGroupsRequest {
	s.ResourceType = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetTransitRouterAttachmentId(v string) *ListTransitRouterMulticastGroupsRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetTransitRouterMulticastDomainId(v string) *ListTransitRouterMulticastGroupsRequest {
	s.TransitRouterMulticastDomainId = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsRequest) SetVSwitchIds(v []*string) *ListTransitRouterMulticastGroupsRequest {
	s.VSwitchIds = v
	return s
}

type ListTransitRouterMulticastGroupsResponseBody struct {
	// The number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If **NextToken** was not returned, it indicates that no additional results exist.
	// *   If **NextToken** was returned in the previous query, specify the value to obtain the next set of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// A list of multicast groups.
	TransitRouterMulticastGroups []*ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups `json:"TransitRouterMulticastGroups,omitempty" xml:"TransitRouterMulticastGroups,omitempty" type:"Repeated"`
}

func (s ListTransitRouterMulticastGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastGroupsResponseBody) SetMaxResults(v int32) *ListTransitRouterMulticastGroupsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBody) SetNextToken(v string) *ListTransitRouterMulticastGroupsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBody) SetRequestId(v string) *ListTransitRouterMulticastGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBody) SetTotalCount(v int32) *ListTransitRouterMulticastGroupsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBody) SetTransitRouterMulticastGroups(v []*ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) *ListTransitRouterMulticastGroupsResponseBody {
	s.TransitRouterMulticastGroups = v
	return s
}

type ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups struct {
	// The IP address of the multicast group to which the multicast resource belongs.
	GroupIpAddress *string `json:"GroupIpAddress,omitempty" xml:"GroupIpAddress,omitempty"`
	// Indicates whether the multicast resource is a multicast member. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	GroupMember *bool `json:"GroupMember,omitempty" xml:"GroupMember,omitempty"`
	// Indicates whether the multicast resource is a multicast source. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	GroupSource *bool `json:"GroupSource,omitempty" xml:"GroupSource,omitempty"`
	// The type of the multicast source.
	//
	// If the value is **Static**, the multicast source is manually specified.
	MemberType *string `json:"MemberType,omitempty" xml:"MemberType,omitempty"`
	// The ID of the ENI, which is a multicast resource.
	NetworkInterfaceId *string `json:"NetworkInterfaceId,omitempty" xml:"NetworkInterfaceId,omitempty"`
	// The ID of the multicast domain associated with the multicast resource that is deployed across regions.
	PeerTransitRouterMulticastDomainId *string `json:"PeerTransitRouterMulticastDomainId,omitempty" xml:"PeerTransitRouterMulticastDomainId,omitempty"`
	// The ID of the resource associated with the multicast resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The ID of the Alibaba Cloud account to which the multicast resource belongs.
	ResourceOwnerId *int64 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the multicast resource. Valid values:
	//
	// *   **VPC**: The multicast resource is in a VPC.
	// *   **TR**: The multicast resource is deployed across regions.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The type of the multicast member.
	//
	// If the value is **Static**, the multicast member is manually specified.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The status of the multicast resource. Valid values:
	//
	// *   **Registering**: being created
	// *   **Registered**: available
	// *   **Deregistering**: being deleted
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the multicast domain.
	TransitRouterMulticastDomainId *string `json:"TransitRouterMulticastDomainId,omitempty" xml:"TransitRouterMulticastDomainId,omitempty"`
	// The ID of the vSwitch to which the multicast resource belongs.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
}

func (s ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) SetGroupIpAddress(v string) *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups {
	s.GroupIpAddress = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) SetGroupMember(v bool) *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups {
	s.GroupMember = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) SetGroupSource(v bool) *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups {
	s.GroupSource = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) SetMemberType(v string) *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups {
	s.MemberType = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) SetNetworkInterfaceId(v string) *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups {
	s.NetworkInterfaceId = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) SetPeerTransitRouterMulticastDomainId(v string) *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups {
	s.PeerTransitRouterMulticastDomainId = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) SetResourceId(v string) *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups {
	s.ResourceId = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) SetResourceOwnerId(v int64) *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) SetResourceType(v string) *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups {
	s.ResourceType = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) SetSourceType(v string) *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups {
	s.SourceType = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) SetStatus(v string) *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups {
	s.Status = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) SetTransitRouterAttachmentId(v string) *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) SetTransitRouterMulticastDomainId(v string) *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups {
	s.TransitRouterMulticastDomainId = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups) SetVSwitchId(v string) *ListTransitRouterMulticastGroupsResponseBodyTransitRouterMulticastGroups {
	s.VSwitchId = &v
	return s
}

type ListTransitRouterMulticastGroupsResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterMulticastGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterMulticastGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterMulticastGroupsResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterMulticastGroupsResponse) SetHeaders(v map[string]*string) *ListTransitRouterMulticastGroupsResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponse) SetStatusCode(v int32) *ListTransitRouterMulticastGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterMulticastGroupsResponse) SetBody(v *ListTransitRouterMulticastGroupsResponseBody) *ListTransitRouterMulticastGroupsResponse {
	s.Body = v
	return s
}

type ListTransitRouterPeerAttachmentsRequest struct {
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The number of entries returned per page. Default value: **20**. Maximum value: **100**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. Valid values:
	//
	// *   You do not need to specify this parameter for the first request.
	// *   You must specify the token that is obtained from the previous query as the value of **NextToken**.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the Enterprise Edition transit router is deployed.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The information about the tag.
	//
	// You can specify at most 20 tags in each call.
	Tag []*ListTransitRouterPeerAttachmentsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the inter-region connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the Enterprise Edition transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s ListTransitRouterPeerAttachmentsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterPeerAttachmentsRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterPeerAttachmentsRequest) SetCenId(v string) *ListTransitRouterPeerAttachmentsRequest {
	s.CenId = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsRequest) SetMaxResults(v int32) *ListTransitRouterPeerAttachmentsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsRequest) SetNextToken(v string) *ListTransitRouterPeerAttachmentsRequest {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsRequest) SetOwnerAccount(v string) *ListTransitRouterPeerAttachmentsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsRequest) SetOwnerId(v int64) *ListTransitRouterPeerAttachmentsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsRequest) SetRegionId(v string) *ListTransitRouterPeerAttachmentsRequest {
	s.RegionId = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsRequest) SetResourceOwnerAccount(v string) *ListTransitRouterPeerAttachmentsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsRequest) SetResourceOwnerId(v int64) *ListTransitRouterPeerAttachmentsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsRequest) SetTag(v []*ListTransitRouterPeerAttachmentsRequestTag) *ListTransitRouterPeerAttachmentsRequest {
	s.Tag = v
	return s
}

func (s *ListTransitRouterPeerAttachmentsRequest) SetTransitRouterAttachmentId(v string) *ListTransitRouterPeerAttachmentsRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsRequest) SetTransitRouterId(v string) *ListTransitRouterPeerAttachmentsRequest {
	s.TransitRouterId = &v
	return s
}

type ListTransitRouterPeerAttachmentsRequestTag struct {
	// The tag key.
	//
	// The tag key cannot be an empty string. The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTransitRouterPeerAttachmentsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterPeerAttachmentsRequestTag) GoString() string {
	return s.String()
}

func (s *ListTransitRouterPeerAttachmentsRequestTag) SetKey(v string) *ListTransitRouterPeerAttachmentsRequestTag {
	s.Key = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsRequestTag) SetValue(v string) *ListTransitRouterPeerAttachmentsRequestTag {
	s.Value = &v
	return s
}

type ListTransitRouterPeerAttachmentsResponseBody struct {
	// The number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results. Valid values:
	//
	// *   If the **NextToken** parameter is empty, no next page exists.
	// *   If **NextToken** was returned in the previous query, specify the value to obtain the next set of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The queried inter-region connections.
	TransitRouterAttachments []*ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments `json:"TransitRouterAttachments,omitempty" xml:"TransitRouterAttachments,omitempty" type:"Repeated"`
}

func (s ListTransitRouterPeerAttachmentsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterPeerAttachmentsResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterPeerAttachmentsResponseBody) SetMaxResults(v int32) *ListTransitRouterPeerAttachmentsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBody) SetNextToken(v string) *ListTransitRouterPeerAttachmentsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBody) SetRequestId(v string) *ListTransitRouterPeerAttachmentsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBody) SetTotalCount(v int32) *ListTransitRouterPeerAttachmentsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBody) SetTransitRouterAttachments(v []*ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) *ListTransitRouterPeerAttachmentsResponseBody {
	s.TransitRouterAttachments = v
	return s
}

type ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments struct {
	// Indicates whether the local Enterprise Edition transit router automatically advertises routes of the inter-region connection to the peer transit router. Valid values:
	//
	// *   **false** (default): no
	// *   **true**: yes
	AutoPublishRouteEnabled *bool `json:"AutoPublishRouteEnabled,omitempty" xml:"AutoPublishRouteEnabled,omitempty"`
	// The maximum bandwidth value of the inter-region connection. Unit: Mbit/s.
	//
	// *   This parameter specifies the maximum bandwidth value for the inter-region connection if you set **BandwidthType** to **BandwidthPackage**.
	// *   This parameter specifies the bandwidth throttling threshold for the inter-region connection if you set **BandwidthType** to **DataTransfer**.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The bandwidth allocation method. Valid values:
	//
	// **BandwidthPackage**: allocates bandwidth from a bandwidth plan.
	//
	// **DataTransfer**: bills bandwidth based on the pay-by-data-transfer metering method.
	BandwidthType *string `json:"BandwidthType,omitempty" xml:"BandwidthType,omitempty"`
	// The ID of the bandwidth plan that is used to allocate bandwidth to the inter-region connection.
	CenBandwidthPackageId *string `json:"CenBandwidthPackageId,omitempty" xml:"CenBandwidthPackageId,omitempty"`
	// The CEN instance ID.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The time when the inter-region connection was created.
	//
	// The time follows the ISO8601 standard in the `YYYY-MM-DDThh:mmZ` format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The areas that are connected by the bandwidth plan.
	GeographicSpanId *string `json:"GeographicSpanId,omitempty" xml:"GeographicSpanId,omitempty"`
	// The ID of the peer transit router.
	PeerTransitRouterId *string `json:"PeerTransitRouterId,omitempty" xml:"PeerTransitRouterId,omitempty"`
	// The ID of the Alibaba Cloud account to which the peer transit router belongs.
	PeerTransitRouterOwnerId *int64 `json:"PeerTransitRouterOwnerId,omitempty" xml:"PeerTransitRouterOwnerId,omitempty"`
	// The region ID of the peer transit router.
	PeerTransitRouterRegionId *string `json:"PeerTransitRouterRegionId,omitempty" xml:"PeerTransitRouterRegionId,omitempty"`
	// The region ID of the Enterprise Edition transit router.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The type of the resource to which the transit router is connected. Valid values:
	//
	// *   **VPC**: VPC
	// *   **CCN**: Cloud Connect Network (CCN) instance
	// *   **VBR**: virtual border router (VBR)
	// *   **TR**: transit router
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The status of the inter-region connection. Valid values:
	//
	// *   **Attached**: The inter-region connection is created.
	// *   **Attaching**: The inter-region connection is being created on the transit router.
	// *   **Detaching**: The inter-region connection is being deleted from the transit router.
	// *   **Detached**: The inter-region connection is deleted from the transit router.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tags.
	Tags []*ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachmentsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The description of the inter-region connection.
	TransitRouterAttachmentDescription *string `json:"TransitRouterAttachmentDescription,omitempty" xml:"TransitRouterAttachmentDescription,omitempty"`
	// The ID of the inter-region connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The name of the inter-region connection.
	TransitRouterAttachmentName *string `json:"TransitRouterAttachmentName,omitempty" xml:"TransitRouterAttachmentName,omitempty"`
	// The ID of the Enterprise Edition transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) GoString() string {
	return s.String()
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetAutoPublishRouteEnabled(v bool) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.AutoPublishRouteEnabled = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetBandwidth(v int32) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.Bandwidth = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetBandwidthType(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.BandwidthType = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetCenBandwidthPackageId(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.CenBandwidthPackageId = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetCenId(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.CenId = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetCreationTime(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.CreationTime = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetGeographicSpanId(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.GeographicSpanId = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetPeerTransitRouterId(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.PeerTransitRouterId = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetPeerTransitRouterOwnerId(v int64) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.PeerTransitRouterOwnerId = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetPeerTransitRouterRegionId(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.PeerTransitRouterRegionId = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetRegionId(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.RegionId = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetResourceType(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.ResourceType = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetStatus(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.Status = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetTags(v []*ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachmentsTags) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.Tags = v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterAttachmentDescription(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterAttachmentDescription = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterAttachmentId(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterAttachmentName(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterAttachmentName = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterId(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterId = &v
	return s
}

type ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachmentsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachmentsTags) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachmentsTags) GoString() string {
	return s.String()
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachmentsTags) SetKey(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachmentsTags {
	s.Key = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachmentsTags) SetValue(v string) *ListTransitRouterPeerAttachmentsResponseBodyTransitRouterAttachmentsTags {
	s.Value = &v
	return s
}

type ListTransitRouterPeerAttachmentsResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterPeerAttachmentsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterPeerAttachmentsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterPeerAttachmentsResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterPeerAttachmentsResponse) SetHeaders(v map[string]*string) *ListTransitRouterPeerAttachmentsResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponse) SetStatusCode(v int32) *ListTransitRouterPeerAttachmentsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterPeerAttachmentsResponse) SetBody(v *ListTransitRouterPeerAttachmentsResponseBody) *ListTransitRouterPeerAttachmentsResponse {
	s.Body = v
	return s
}

type ListTransitRouterPrefixListAssociationRequest struct {
	// The ID of the next hop.
	//
	// > Set the value to **BlackHole** if you want to query the prefix list that generates blackhole routes.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The ID of the network instance associated with the next hop connection.
	NextHopInstanceId *string `json:"NextHopInstanceId,omitempty" xml:"NextHopInstanceId,omitempty"`
	// The type of the next hop. Valid values:
	//
	// *   **BlackHole**: The prefix list that generates blackhole routes.
	// *   **VPC**: The prefix list whose next hop is a virtual private cloud (VPC) connection.
	// *   **VBR**: The prefix list whose next hop is a virtual border router (VBR) connection.
	// *   **TR**: The prefix list whose next hop is an inter-region connection on the transit router.
	NextHopType  *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the Alibaba Cloud account to which the prefix list belongs.
	OwnerUid *int64 `json:"OwnerUid,omitempty" xml:"OwnerUid,omitempty"`
	// The number of the page to return. Default value: **1**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: **100**. Default value: **10**.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the prefix list.
	PrefixListId *string `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	// The ID of the region where the transit router is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The status of the prefix list. Valid values:
	//
	// *   **Active**
	// *   **Updating**
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The ID of the route table of the transit router.
	TransitRouterTableId *string `json:"TransitRouterTableId,omitempty" xml:"TransitRouterTableId,omitempty"`
}

func (s ListTransitRouterPrefixListAssociationRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterPrefixListAssociationRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterPrefixListAssociationRequest) SetNextHop(v string) *ListTransitRouterPrefixListAssociationRequest {
	s.NextHop = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationRequest) SetNextHopInstanceId(v string) *ListTransitRouterPrefixListAssociationRequest {
	s.NextHopInstanceId = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationRequest) SetNextHopType(v string) *ListTransitRouterPrefixListAssociationRequest {
	s.NextHopType = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationRequest) SetOwnerAccount(v string) *ListTransitRouterPrefixListAssociationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationRequest) SetOwnerId(v int64) *ListTransitRouterPrefixListAssociationRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationRequest) SetOwnerUid(v int64) *ListTransitRouterPrefixListAssociationRequest {
	s.OwnerUid = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationRequest) SetPageNumber(v int32) *ListTransitRouterPrefixListAssociationRequest {
	s.PageNumber = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationRequest) SetPageSize(v int32) *ListTransitRouterPrefixListAssociationRequest {
	s.PageSize = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationRequest) SetPrefixListId(v string) *ListTransitRouterPrefixListAssociationRequest {
	s.PrefixListId = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationRequest) SetRegionId(v string) *ListTransitRouterPrefixListAssociationRequest {
	s.RegionId = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationRequest) SetResourceOwnerAccount(v string) *ListTransitRouterPrefixListAssociationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationRequest) SetResourceOwnerId(v int64) *ListTransitRouterPrefixListAssociationRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationRequest) SetStatus(v string) *ListTransitRouterPrefixListAssociationRequest {
	s.Status = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationRequest) SetTransitRouterId(v string) *ListTransitRouterPrefixListAssociationRequest {
	s.TransitRouterId = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationRequest) SetTransitRouterTableId(v string) *ListTransitRouterPrefixListAssociationRequest {
	s.TransitRouterTableId = &v
	return s
}

type ListTransitRouterPrefixListAssociationResponseBody struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// A list of prefix lists.
	PrefixLists []*ListTransitRouterPrefixListAssociationResponseBodyPrefixLists `json:"PrefixLists,omitempty" xml:"PrefixLists,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListTransitRouterPrefixListAssociationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterPrefixListAssociationResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterPrefixListAssociationResponseBody) SetPageNumber(v int32) *ListTransitRouterPrefixListAssociationResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationResponseBody) SetPageSize(v int32) *ListTransitRouterPrefixListAssociationResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationResponseBody) SetPrefixLists(v []*ListTransitRouterPrefixListAssociationResponseBodyPrefixLists) *ListTransitRouterPrefixListAssociationResponseBody {
	s.PrefixLists = v
	return s
}

func (s *ListTransitRouterPrefixListAssociationResponseBody) SetRequestId(v string) *ListTransitRouterPrefixListAssociationResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationResponseBody) SetTotalCount(v int32) *ListTransitRouterPrefixListAssociationResponseBody {
	s.TotalCount = &v
	return s
}

type ListTransitRouterPrefixListAssociationResponseBodyPrefixLists struct {
	// The ID of the next hop.
	//
	// > A value of **BlackHole** indicates that all the CIDR blocks in the prefix list are blackhole routes. Packets destined for the CIDR blocks are dropped.
	NextHop *string `json:"NextHop,omitempty" xml:"NextHop,omitempty"`
	// The ID of the network instance associated with the next hop connection.
	NextHopInstanceId *string `json:"NextHopInstanceId,omitempty" xml:"NextHopInstanceId,omitempty"`
	// The type of the next hop. Valid values:
	//
	// *   **BlackHole**: All the CIDR blocks in the prefix list are blackhole routes. Packets destined for the CIDR blocks are dropped.
	// *   **VPC**: The next hop of the CIDR blocks in the prefix list is a VPC connection.
	// *   **VBR**: The next hop of the CIDR blocks in the prefix list is a VBR connection.
	// *   **TR**: The next hop of the CIDR blocks in the prefix list is an inter-region connection.
	NextHopType *string `json:"NextHopType,omitempty" xml:"NextHopType,omitempty"`
	// The ID of the Alibaba Cloud account to which the prefix list belongs.
	OwnerUid *int64 `json:"OwnerUid,omitempty" xml:"OwnerUid,omitempty"`
	// The ID of the prefix list.
	PrefixListId *string `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	// The status of the prefix list. Valid values:
	//
	// *   **Active**: The prefix list is effective.
	// *   **Updating**: The prefix list is being updated.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The ID of the route table of the transit router.
	TransitRouterTableId *string `json:"TransitRouterTableId,omitempty" xml:"TransitRouterTableId,omitempty"`
}

func (s ListTransitRouterPrefixListAssociationResponseBodyPrefixLists) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterPrefixListAssociationResponseBodyPrefixLists) GoString() string {
	return s.String()
}

func (s *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists) SetNextHop(v string) *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists {
	s.NextHop = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists) SetNextHopInstanceId(v string) *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists {
	s.NextHopInstanceId = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists) SetNextHopType(v string) *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists {
	s.NextHopType = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists) SetOwnerUid(v int64) *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists {
	s.OwnerUid = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists) SetPrefixListId(v string) *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists {
	s.PrefixListId = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists) SetStatus(v string) *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists {
	s.Status = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists) SetTransitRouterId(v string) *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists {
	s.TransitRouterId = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists) SetTransitRouterTableId(v string) *ListTransitRouterPrefixListAssociationResponseBodyPrefixLists {
	s.TransitRouterTableId = &v
	return s
}

type ListTransitRouterPrefixListAssociationResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterPrefixListAssociationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterPrefixListAssociationResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterPrefixListAssociationResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterPrefixListAssociationResponse) SetHeaders(v map[string]*string) *ListTransitRouterPrefixListAssociationResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterPrefixListAssociationResponse) SetStatusCode(v int32) *ListTransitRouterPrefixListAssociationResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterPrefixListAssociationResponse) SetBody(v *ListTransitRouterPrefixListAssociationResponseBody) *ListTransitRouterPrefixListAssociationResponse {
	s.Body = v
	return s
}

type ListTransitRouterRouteEntriesRequest struct {
	// The number of entries to return on each page. Valid values: **1** to **100**. Default value: **20**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. Valid values:
	//
	// *   You do not need to specify this parameter for the first request.
	// *   You must specify the token that is obtained from the previous query as the value of **NextToken**.
	NextToken            *string                                            `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount         *string                                            `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64                                             `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PrefixListId         *string                                            `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	ResourceOwnerAccount *string                                            `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                             `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	RouteFilter          []*ListTransitRouterRouteEntriesRequestRouteFilter `json:"RouteFilter,omitempty" xml:"RouteFilter,omitempty" type:"Repeated"`
	// Deprecated
	// The destination CIDR block of the route.
	TransitRouterRouteEntryDestinationCidrBlock *string `json:"TransitRouterRouteEntryDestinationCidrBlock,omitempty" xml:"TransitRouterRouteEntryDestinationCidrBlock,omitempty"`
	// The route entry ID.
	//
	// You can specify at most 20 route IDs in each call.
	//
	// >  You can use only this parameter to query static routes.
	TransitRouterRouteEntryIds []*string `json:"TransitRouterRouteEntryIds,omitempty" xml:"TransitRouterRouteEntryIds,omitempty" type:"Repeated"`
	// The route name.
	//
	// The name must be 0 to 128 characters in length, and can contain letters, digits, and the following special characters: , . ; / @ \_ -.
	//
	// You can specify at most 20 route names in each call.
	//
	// >  You can use only this parameter to query static routes.
	TransitRouterRouteEntryNames               []*string `json:"TransitRouterRouteEntryNames,omitempty" xml:"TransitRouterRouteEntryNames,omitempty" type:"Repeated"`
	TransitRouterRouteEntryNextHopId           *string   `json:"TransitRouterRouteEntryNextHopId,omitempty" xml:"TransitRouterRouteEntryNextHopId,omitempty"`
	TransitRouterRouteEntryNextHopResourceId   *string   `json:"TransitRouterRouteEntryNextHopResourceId,omitempty" xml:"TransitRouterRouteEntryNextHopResourceId,omitempty"`
	TransitRouterRouteEntryNextHopResourceType *string   `json:"TransitRouterRouteEntryNextHopResourceType,omitempty" xml:"TransitRouterRouteEntryNextHopResourceType,omitempty"`
	TransitRouterRouteEntryNextHopType         *string   `json:"TransitRouterRouteEntryNextHopType,omitempty" xml:"TransitRouterRouteEntryNextHopType,omitempty"`
	TransitRouterRouteEntryOriginResourceId    *string   `json:"TransitRouterRouteEntryOriginResourceId,omitempty" xml:"TransitRouterRouteEntryOriginResourceId,omitempty"`
	TransitRouterRouteEntryOriginResourceType  *string   `json:"TransitRouterRouteEntryOriginResourceType,omitempty" xml:"TransitRouterRouteEntryOriginResourceType,omitempty"`
	// The status of the route. Valid values:
	//
	// *   **Creating**: The route is being created.
	// *   **Active**: The route is available.
	// *   **Deleting**: The route is being deleted.
	TransitRouterRouteEntryStatus *string `json:"TransitRouterRouteEntryStatus,omitempty" xml:"TransitRouterRouteEntryStatus,omitempty"`
	TransitRouterRouteEntryType   *string `json:"TransitRouterRouteEntryType,omitempty" xml:"TransitRouterRouteEntryType,omitempty"`
	// The ID of the route table of the Enterprise Edition transit router.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
}

func (s ListTransitRouterRouteEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteEntriesRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteEntriesRequest) SetMaxResults(v int32) *ListTransitRouterRouteEntriesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetNextToken(v string) *ListTransitRouterRouteEntriesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetOwnerAccount(v string) *ListTransitRouterRouteEntriesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetOwnerId(v int64) *ListTransitRouterRouteEntriesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetPrefixListId(v string) *ListTransitRouterRouteEntriesRequest {
	s.PrefixListId = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetResourceOwnerAccount(v string) *ListTransitRouterRouteEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetResourceOwnerId(v int64) *ListTransitRouterRouteEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetRouteFilter(v []*ListTransitRouterRouteEntriesRequestRouteFilter) *ListTransitRouterRouteEntriesRequest {
	s.RouteFilter = v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetTransitRouterRouteEntryDestinationCidrBlock(v string) *ListTransitRouterRouteEntriesRequest {
	s.TransitRouterRouteEntryDestinationCidrBlock = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetTransitRouterRouteEntryIds(v []*string) *ListTransitRouterRouteEntriesRequest {
	s.TransitRouterRouteEntryIds = v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetTransitRouterRouteEntryNames(v []*string) *ListTransitRouterRouteEntriesRequest {
	s.TransitRouterRouteEntryNames = v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetTransitRouterRouteEntryNextHopId(v string) *ListTransitRouterRouteEntriesRequest {
	s.TransitRouterRouteEntryNextHopId = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetTransitRouterRouteEntryNextHopResourceId(v string) *ListTransitRouterRouteEntriesRequest {
	s.TransitRouterRouteEntryNextHopResourceId = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetTransitRouterRouteEntryNextHopResourceType(v string) *ListTransitRouterRouteEntriesRequest {
	s.TransitRouterRouteEntryNextHopResourceType = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetTransitRouterRouteEntryNextHopType(v string) *ListTransitRouterRouteEntriesRequest {
	s.TransitRouterRouteEntryNextHopType = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetTransitRouterRouteEntryOriginResourceId(v string) *ListTransitRouterRouteEntriesRequest {
	s.TransitRouterRouteEntryOriginResourceId = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetTransitRouterRouteEntryOriginResourceType(v string) *ListTransitRouterRouteEntriesRequest {
	s.TransitRouterRouteEntryOriginResourceType = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetTransitRouterRouteEntryStatus(v string) *ListTransitRouterRouteEntriesRequest {
	s.TransitRouterRouteEntryStatus = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetTransitRouterRouteEntryType(v string) *ListTransitRouterRouteEntriesRequest {
	s.TransitRouterRouteEntryType = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequest) SetTransitRouterRouteTableId(v string) *ListTransitRouterRouteEntriesRequest {
	s.TransitRouterRouteTableId = &v
	return s
}

type ListTransitRouterRouteEntriesRequestRouteFilter struct {
	Key   *string   `json:"Key,omitempty" xml:"Key,omitempty"`
	Value []*string `json:"Value,omitempty" xml:"Value,omitempty" type:"Repeated"`
}

func (s ListTransitRouterRouteEntriesRequestRouteFilter) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteEntriesRequestRouteFilter) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteEntriesRequestRouteFilter) SetKey(v string) *ListTransitRouterRouteEntriesRequestRouteFilter {
	s.Key = &v
	return s
}

func (s *ListTransitRouterRouteEntriesRequestRouteFilter) SetValue(v []*string) *ListTransitRouterRouteEntriesRequestRouteFilter {
	s.Value = v
	return s
}

type ListTransitRouterRouteEntriesResponseBody struct {
	// The number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results. Valid values:
	//
	// *   If the **NextToken** parameter is empty, no next page exists.
	// *   If a value of **NextToken** was returned in the previous query, specify the value to obtain the next set of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The queried routes.
	TransitRouterRouteEntries []*ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries `json:"TransitRouterRouteEntries,omitempty" xml:"TransitRouterRouteEntries,omitempty" type:"Repeated"`
}

func (s ListTransitRouterRouteEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteEntriesResponseBody) SetMaxResults(v int32) *ListTransitRouterRouteEntriesResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBody) SetNextToken(v string) *ListTransitRouterRouteEntriesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBody) SetRequestId(v string) *ListTransitRouterRouteEntriesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBody) SetTotalCount(v int32) *ListTransitRouterRouteEntriesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBody) SetTransitRouterRouteEntries(v []*ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) *ListTransitRouterRouteEntriesResponseBody {
	s.TransitRouterRouteEntries = v
	return s
}

type ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries struct {
	// The time when the route was created.
	//
	// The time follows the ISO8601 standard in the YYYY-MM-DDThh:mmZ format. The time is displayed in UTC.
	//
	// >  This parameter is returned only for static routes.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// Indicates whether the route can be managed. Valid values:
	//
	// *   **true**: The route can be managed. You can delete the route.
	// *   **false**: The route cannot be managed because it is automatically generated by the system.
	OperationalMode *bool                                                                             `json:"OperationalMode,omitempty" xml:"OperationalMode,omitempty"`
	PathAttributes  *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes `json:"PathAttributes,omitempty" xml:"PathAttributes,omitempty" type:"Struct"`
	PrefixListId    *string                                                                           `json:"PrefixListId,omitempty" xml:"PrefixListId,omitempty"`
	// The tag of the route.
	//
	// Only **PermitVbr** may be returned, which indicates that the route is advertised only to the route table of the virtual border router (VBR) that is connected to the transit router.
	//
	// >  This parameter is returned only for automatically learned routes.
	Tag *string `json:"Tag,omitempty" xml:"Tag,omitempty"`
	// The description of the route.
	//
	// >  This parameter is returned only for static routes.
	TransitRouterRouteEntryDescription *string `json:"TransitRouterRouteEntryDescription,omitempty" xml:"TransitRouterRouteEntryDescription,omitempty"`
	// The destination CIDR block of the route.
	TransitRouterRouteEntryDestinationCidrBlock *string `json:"TransitRouterRouteEntryDestinationCidrBlock,omitempty" xml:"TransitRouterRouteEntryDestinationCidrBlock,omitempty"`
	// The route ID.
	//
	// >  This parameter is returned only for static routes.
	TransitRouterRouteEntryId *string `json:"TransitRouterRouteEntryId,omitempty" xml:"TransitRouterRouteEntryId,omitempty"`
	// The route name.
	//
	// >  This parameter is returned only for static routes.
	TransitRouterRouteEntryName *string `json:"TransitRouterRouteEntryName,omitempty" xml:"TransitRouterRouteEntryName,omitempty"`
	// The ID of the next hop.
	TransitRouterRouteEntryNextHopId           *string `json:"TransitRouterRouteEntryNextHopId,omitempty" xml:"TransitRouterRouteEntryNextHopId,omitempty"`
	TransitRouterRouteEntryNextHopResourceId   *string `json:"TransitRouterRouteEntryNextHopResourceId,omitempty" xml:"TransitRouterRouteEntryNextHopResourceId,omitempty"`
	TransitRouterRouteEntryNextHopResourceType *string `json:"TransitRouterRouteEntryNextHopResourceType,omitempty" xml:"TransitRouterRouteEntryNextHopResourceType,omitempty"`
	// The type of next hop. Valid values:
	//
	// *   **BlackHole**: a blackhole route. Packets destined for the destination CIDR block of the route are dropped.
	// *   **Attachment**: a network instance connection. Packets destined for the destination CIDR block of the route are forwarded to the specified network instance connection.
	TransitRouterRouteEntryNextHopType        *string `json:"TransitRouterRouteEntryNextHopType,omitempty" xml:"TransitRouterRouteEntryNextHopType,omitempty"`
	TransitRouterRouteEntryOriginResourceId   *string `json:"TransitRouterRouteEntryOriginResourceId,omitempty" xml:"TransitRouterRouteEntryOriginResourceId,omitempty"`
	TransitRouterRouteEntryOriginResourceType *string `json:"TransitRouterRouteEntryOriginResourceType,omitempty" xml:"TransitRouterRouteEntryOriginResourceType,omitempty"`
	// The status of the route. Valid values:
	//
	// *   **Creating**: The route is being created.
	// *   **Active**: The route is available.
	// *   **Deleting**: The route is being deleted.
	TransitRouterRouteEntryStatus *string `json:"TransitRouterRouteEntryStatus,omitempty" xml:"TransitRouterRouteEntryStatus,omitempty"`
	// The type of the route. Valid values:
	//
	// *   **Static**: a static route
	// *   **Propagated**: an automatically learned route
	TransitRouterRouteEntryType *string `json:"TransitRouterRouteEntryType,omitempty" xml:"TransitRouterRouteEntryType,omitempty"`
}

func (s ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetCreateTime(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.CreateTime = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetOperationalMode(v bool) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.OperationalMode = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetPathAttributes(v *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.PathAttributes = v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetPrefixListId(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.PrefixListId = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetTag(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.Tag = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetTransitRouterRouteEntryDescription(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.TransitRouterRouteEntryDescription = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetTransitRouterRouteEntryDestinationCidrBlock(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.TransitRouterRouteEntryDestinationCidrBlock = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetTransitRouterRouteEntryId(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.TransitRouterRouteEntryId = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetTransitRouterRouteEntryName(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.TransitRouterRouteEntryName = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetTransitRouterRouteEntryNextHopId(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.TransitRouterRouteEntryNextHopId = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetTransitRouterRouteEntryNextHopResourceId(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.TransitRouterRouteEntryNextHopResourceId = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetTransitRouterRouteEntryNextHopResourceType(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.TransitRouterRouteEntryNextHopResourceType = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetTransitRouterRouteEntryNextHopType(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.TransitRouterRouteEntryNextHopType = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetTransitRouterRouteEntryOriginResourceId(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.TransitRouterRouteEntryOriginResourceId = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetTransitRouterRouteEntryOriginResourceType(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.TransitRouterRouteEntryOriginResourceType = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetTransitRouterRouteEntryStatus(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.TransitRouterRouteEntryStatus = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries) SetTransitRouterRouteEntryType(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntries {
	s.TransitRouterRouteEntryType = &v
	return s
}

type ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes struct {
	AsPaths            []*string `json:"AsPaths,omitempty" xml:"AsPaths,omitempty" type:"Repeated"`
	Communities        []*string `json:"Communities,omitempty" xml:"Communities,omitempty" type:"Repeated"`
	OriginInstanceId   *string   `json:"OriginInstanceId,omitempty" xml:"OriginInstanceId,omitempty"`
	OriginInstanceType *string   `json:"OriginInstanceType,omitempty" xml:"OriginInstanceType,omitempty"`
	OriginRouteType    *string   `json:"OriginRouteType,omitempty" xml:"OriginRouteType,omitempty"`
	Preference         *int32    `json:"Preference,omitempty" xml:"Preference,omitempty"`
}

func (s ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes) SetAsPaths(v []*string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes {
	s.AsPaths = v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes) SetCommunities(v []*string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes {
	s.Communities = v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes) SetOriginInstanceId(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes {
	s.OriginInstanceId = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes) SetOriginInstanceType(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes {
	s.OriginInstanceType = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes) SetOriginRouteType(v string) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes {
	s.OriginRouteType = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes) SetPreference(v int32) *ListTransitRouterRouteEntriesResponseBodyTransitRouterRouteEntriesPathAttributes {
	s.Preference = &v
	return s
}

type ListTransitRouterRouteEntriesResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterRouteEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterRouteEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteEntriesResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteEntriesResponse) SetHeaders(v map[string]*string) *ListTransitRouterRouteEntriesResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterRouteEntriesResponse) SetStatusCode(v int32) *ListTransitRouterRouteEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterRouteEntriesResponse) SetBody(v *ListTransitRouterRouteEntriesResponseBody) *ListTransitRouterRouteEntriesResponse {
	s.Body = v
	return s
}

type ListTransitRouterRouteTableAssociationsRequest struct {
	// The number of entries to return on each page. Default value: **50**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query or no subsequent query is to be sent, ignore this parameter.
	// *   If a next query is to be sent, set the value to the value of **NextToken** that is returned from the last call.
	NextToken            *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The status of the associated forwarding correlation. Valid values:
	//
	// *   **Active**: The associated forwarding correlation is available.
	// *   **Associating**: The associated forwarding correlation is being created.
	// *   **Dissociating**: The associated forwarding correlation is being deleted.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the next hop.
	TransitRouterAttachmentResourceId *string `json:"TransitRouterAttachmentResourceId,omitempty" xml:"TransitRouterAttachmentResourceId,omitempty"`
	// The type of next hop. Valid values:
	//
	// *   **VPC**: virtual private cloud (VPC)
	// *   **VBR**: virtual border router (VBR)
	// *   **TR**: transit router
	// *   **VPN**: VPN attachment
	TransitRouterAttachmentResourceType *string `json:"TransitRouterAttachmentResourceType,omitempty" xml:"TransitRouterAttachmentResourceType,omitempty"`
	// The ID of the route table of the Enterprise Edition transit router.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
}

func (s ListTransitRouterRouteTableAssociationsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTableAssociationsRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTableAssociationsRequest) SetMaxResults(v int32) *ListTransitRouterRouteTableAssociationsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsRequest) SetNextToken(v string) *ListTransitRouterRouteTableAssociationsRequest {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsRequest) SetOwnerAccount(v string) *ListTransitRouterRouteTableAssociationsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsRequest) SetOwnerId(v int64) *ListTransitRouterRouteTableAssociationsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsRequest) SetResourceOwnerAccount(v string) *ListTransitRouterRouteTableAssociationsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsRequest) SetResourceOwnerId(v int64) *ListTransitRouterRouteTableAssociationsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsRequest) SetStatus(v string) *ListTransitRouterRouteTableAssociationsRequest {
	s.Status = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsRequest) SetTransitRouterAttachmentId(v string) *ListTransitRouterRouteTableAssociationsRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsRequest) SetTransitRouterAttachmentResourceId(v string) *ListTransitRouterRouteTableAssociationsRequest {
	s.TransitRouterAttachmentResourceId = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsRequest) SetTransitRouterAttachmentResourceType(v string) *ListTransitRouterRouteTableAssociationsRequest {
	s.TransitRouterAttachmentResourceType = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsRequest) SetTransitRouterRouteTableId(v string) *ListTransitRouterRouteTableAssociationsRequest {
	s.TransitRouterRouteTableId = &v
	return s
}

type ListTransitRouterRouteTableAssociationsResponseBody struct {
	// The number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If **NextToken** was not returned, it indicates that no additional results exist.
	// *   If **NextToken** was returned in the previous query, specify the value to obtain the next set of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// A list of associated forwarding correlations.
	TransitRouterAssociations []*ListTransitRouterRouteTableAssociationsResponseBodyTransitRouterAssociations `json:"TransitRouterAssociations,omitempty" xml:"TransitRouterAssociations,omitempty" type:"Repeated"`
}

func (s ListTransitRouterRouteTableAssociationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTableAssociationsResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTableAssociationsResponseBody) SetMaxResults(v int32) *ListTransitRouterRouteTableAssociationsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsResponseBody) SetNextToken(v string) *ListTransitRouterRouteTableAssociationsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsResponseBody) SetRequestId(v string) *ListTransitRouterRouteTableAssociationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsResponseBody) SetTotalCount(v int32) *ListTransitRouterRouteTableAssociationsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsResponseBody) SetTransitRouterAssociations(v []*ListTransitRouterRouteTableAssociationsResponseBodyTransitRouterAssociations) *ListTransitRouterRouteTableAssociationsResponseBody {
	s.TransitRouterAssociations = v
	return s
}

type ListTransitRouterRouteTableAssociationsResponseBodyTransitRouterAssociations struct {
	// The ID of the next hop.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of next hop. Valid values:
	//
	// *   **VPC**: VPC
	// *   **VBR**: VBR
	// *   **TR**: transit router
	// *   **VPN** :VPN attachment
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The status of the associated forwarding correlation. Valid values:
	//
	// *   **Active**: The associated forwarding correlation is available.
	// *   **Associating**: The associated forwarding correlation is being created.
	// *   **Dissociating**: The associated forwarding correlation is being deleted.
	// *   **Deleted**: The associated forwarding correlation is deleted.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the route table of the Enterprise Edition transit router.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
}

func (s ListTransitRouterRouteTableAssociationsResponseBodyTransitRouterAssociations) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTableAssociationsResponseBodyTransitRouterAssociations) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTableAssociationsResponseBodyTransitRouterAssociations) SetResourceId(v string) *ListTransitRouterRouteTableAssociationsResponseBodyTransitRouterAssociations {
	s.ResourceId = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsResponseBodyTransitRouterAssociations) SetResourceType(v string) *ListTransitRouterRouteTableAssociationsResponseBodyTransitRouterAssociations {
	s.ResourceType = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsResponseBodyTransitRouterAssociations) SetStatus(v string) *ListTransitRouterRouteTableAssociationsResponseBodyTransitRouterAssociations {
	s.Status = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsResponseBodyTransitRouterAssociations) SetTransitRouterAttachmentId(v string) *ListTransitRouterRouteTableAssociationsResponseBodyTransitRouterAssociations {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsResponseBodyTransitRouterAssociations) SetTransitRouterRouteTableId(v string) *ListTransitRouterRouteTableAssociationsResponseBodyTransitRouterAssociations {
	s.TransitRouterRouteTableId = &v
	return s
}

type ListTransitRouterRouteTableAssociationsResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterRouteTableAssociationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterRouteTableAssociationsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTableAssociationsResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTableAssociationsResponse) SetHeaders(v map[string]*string) *ListTransitRouterRouteTableAssociationsResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsResponse) SetStatusCode(v int32) *ListTransitRouterRouteTableAssociationsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterRouteTableAssociationsResponse) SetBody(v *ListTransitRouterRouteTableAssociationsResponseBody) *ListTransitRouterRouteTableAssociationsResponse {
	s.Body = v
	return s
}

type ListTransitRouterRouteTablePropagationsRequest struct {
	// The number of entries to return on each page. Default value: **50**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query.
	NextToken            *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The status of the route learning correlation. Valid values:
	//
	// *   **Active**: available
	// *   **Enabling**: being enabled
	// *   **Disabling**: being disabled
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the network instance.
	TransitRouterAttachmentResourceId *string `json:"TransitRouterAttachmentResourceId,omitempty" xml:"TransitRouterAttachmentResourceId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: virtual private cloud (VPC)
	// *   **VBR**: virtual border router (VBR)
	// *   **TR**: transit router
	// *   **VPN**: VPN connection
	TransitRouterAttachmentResourceType *string `json:"TransitRouterAttachmentResourceType,omitempty" xml:"TransitRouterAttachmentResourceType,omitempty"`
	// The ID of the route table of the Enterprise Edition transit router.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
}

func (s ListTransitRouterRouteTablePropagationsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTablePropagationsRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTablePropagationsRequest) SetMaxResults(v int32) *ListTransitRouterRouteTablePropagationsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsRequest) SetNextToken(v string) *ListTransitRouterRouteTablePropagationsRequest {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsRequest) SetOwnerAccount(v string) *ListTransitRouterRouteTablePropagationsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsRequest) SetOwnerId(v int64) *ListTransitRouterRouteTablePropagationsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsRequest) SetResourceOwnerAccount(v string) *ListTransitRouterRouteTablePropagationsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsRequest) SetResourceOwnerId(v int64) *ListTransitRouterRouteTablePropagationsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsRequest) SetStatus(v string) *ListTransitRouterRouteTablePropagationsRequest {
	s.Status = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsRequest) SetTransitRouterAttachmentId(v string) *ListTransitRouterRouteTablePropagationsRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsRequest) SetTransitRouterAttachmentResourceId(v string) *ListTransitRouterRouteTablePropagationsRequest {
	s.TransitRouterAttachmentResourceId = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsRequest) SetTransitRouterAttachmentResourceType(v string) *ListTransitRouterRouteTablePropagationsRequest {
	s.TransitRouterAttachmentResourceType = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsRequest) SetTransitRouterRouteTableId(v string) *ListTransitRouterRouteTablePropagationsRequest {
	s.TransitRouterRouteTableId = &v
	return s
}

type ListTransitRouterRouteTablePropagationsResponseBody struct {
	// The number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// A list of route learning correlations.
	TransitRouterPropagations []*ListTransitRouterRouteTablePropagationsResponseBodyTransitRouterPropagations `json:"TransitRouterPropagations,omitempty" xml:"TransitRouterPropagations,omitempty" type:"Repeated"`
}

func (s ListTransitRouterRouteTablePropagationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTablePropagationsResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTablePropagationsResponseBody) SetMaxResults(v int32) *ListTransitRouterRouteTablePropagationsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsResponseBody) SetNextToken(v string) *ListTransitRouterRouteTablePropagationsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsResponseBody) SetRequestId(v string) *ListTransitRouterRouteTablePropagationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsResponseBody) SetTotalCount(v int32) *ListTransitRouterRouteTablePropagationsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsResponseBody) SetTransitRouterPropagations(v []*ListTransitRouterRouteTablePropagationsResponseBodyTransitRouterPropagations) *ListTransitRouterRouteTablePropagationsResponseBody {
	s.TransitRouterPropagations = v
	return s
}

type ListTransitRouterRouteTablePropagationsResponseBodyTransitRouterPropagations struct {
	// The ID of the network instance.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: VPC
	// *   **VBR**: VBR
	// *   **TR**: transit router
	// *   **VPN**: VPN connection
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The status of the route learning correlation. Valid values:
	//
	// *   **Enabling**: being enabled
	// *   **Disabling**: being disabled
	// *   **Active**: available
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the network instance connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the route table of the Enterprise Edition transit router.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
}

func (s ListTransitRouterRouteTablePropagationsResponseBodyTransitRouterPropagations) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTablePropagationsResponseBodyTransitRouterPropagations) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTablePropagationsResponseBodyTransitRouterPropagations) SetResourceId(v string) *ListTransitRouterRouteTablePropagationsResponseBodyTransitRouterPropagations {
	s.ResourceId = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsResponseBodyTransitRouterPropagations) SetResourceType(v string) *ListTransitRouterRouteTablePropagationsResponseBodyTransitRouterPropagations {
	s.ResourceType = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsResponseBodyTransitRouterPropagations) SetStatus(v string) *ListTransitRouterRouteTablePropagationsResponseBodyTransitRouterPropagations {
	s.Status = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsResponseBodyTransitRouterPropagations) SetTransitRouterAttachmentId(v string) *ListTransitRouterRouteTablePropagationsResponseBodyTransitRouterPropagations {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsResponseBodyTransitRouterPropagations) SetTransitRouterRouteTableId(v string) *ListTransitRouterRouteTablePropagationsResponseBodyTransitRouterPropagations {
	s.TransitRouterRouteTableId = &v
	return s
}

type ListTransitRouterRouteTablePropagationsResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterRouteTablePropagationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterRouteTablePropagationsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTablePropagationsResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTablePropagationsResponse) SetHeaders(v map[string]*string) *ListTransitRouterRouteTablePropagationsResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsResponse) SetStatusCode(v int32) *ListTransitRouterRouteTablePropagationsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterRouteTablePropagationsResponse) SetBody(v *ListTransitRouterRouteTablePropagationsResponseBody) *ListTransitRouterRouteTablePropagationsResponse {
	s.Body = v
	return s
}

type ListTransitRouterRouteTablesRequest struct {
	// The number of entries per page. Valid values: **1** to **100**. Default value: **20**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query or no subsequent query is to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the value to the value of **NextToken** that is returned from the last call.
	NextToken            *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The features of the route table.
	RouteTableOptions *ListTransitRouterRouteTablesRequestRouteTableOptions `json:"RouteTableOptions,omitempty" xml:"RouteTableOptions,omitempty" type:"Struct"`
	// The information about the tags.
	//
	// You can specify at most 20 tags in each call.
	Tag []*ListTransitRouterRouteTablesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the Enterprise Edition transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The ID of the route table.
	//
	// You can query multiple route tables in each call. Maximum value of **N**: **20**.
	TransitRouterRouteTableIds []*string `json:"TransitRouterRouteTableIds,omitempty" xml:"TransitRouterRouteTableIds,omitempty" type:"Repeated"`
	// The name of the route table.
	//
	// You can query multiple route tables in each call. Maximum value of **N**: **20**.
	//
	// > If you set both **TransitRouterRouteTableNames.N** and **TransitRouterRouteTableIds.N**, make sure that the specified name and ID belong to the same route table.
	TransitRouterRouteTableNames []*string `json:"TransitRouterRouteTableNames,omitempty" xml:"TransitRouterRouteTableNames,omitempty" type:"Repeated"`
	// The status of the route table. Valid values:
	//
	// *   **Creating**: The route table is being created.
	// *   **Deleting**: The route table is being deleted.
	// *   **Active**: The route table is available.
	TransitRouterRouteTableStatus *string `json:"TransitRouterRouteTableStatus,omitempty" xml:"TransitRouterRouteTableStatus,omitempty"`
	// The type of the route table. Valid values:
	//
	// *   **Custom**: a custom route table
	// *   **System**: the default route table
	TransitRouterRouteTableType *string `json:"TransitRouterRouteTableType,omitempty" xml:"TransitRouterRouteTableType,omitempty"`
}

func (s ListTransitRouterRouteTablesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTablesRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTablesRequest) SetMaxResults(v int32) *ListTransitRouterRouteTablesRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterRouteTablesRequest) SetNextToken(v string) *ListTransitRouterRouteTablesRequest {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterRouteTablesRequest) SetOwnerAccount(v string) *ListTransitRouterRouteTablesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterRouteTablesRequest) SetOwnerId(v int64) *ListTransitRouterRouteTablesRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterRouteTablesRequest) SetResourceOwnerAccount(v string) *ListTransitRouterRouteTablesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterRouteTablesRequest) SetResourceOwnerId(v int64) *ListTransitRouterRouteTablesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterRouteTablesRequest) SetRouteTableOptions(v *ListTransitRouterRouteTablesRequestRouteTableOptions) *ListTransitRouterRouteTablesRequest {
	s.RouteTableOptions = v
	return s
}

func (s *ListTransitRouterRouteTablesRequest) SetTag(v []*ListTransitRouterRouteTablesRequestTag) *ListTransitRouterRouteTablesRequest {
	s.Tag = v
	return s
}

func (s *ListTransitRouterRouteTablesRequest) SetTransitRouterId(v string) *ListTransitRouterRouteTablesRequest {
	s.TransitRouterId = &v
	return s
}

func (s *ListTransitRouterRouteTablesRequest) SetTransitRouterRouteTableIds(v []*string) *ListTransitRouterRouteTablesRequest {
	s.TransitRouterRouteTableIds = v
	return s
}

func (s *ListTransitRouterRouteTablesRequest) SetTransitRouterRouteTableNames(v []*string) *ListTransitRouterRouteTablesRequest {
	s.TransitRouterRouteTableNames = v
	return s
}

func (s *ListTransitRouterRouteTablesRequest) SetTransitRouterRouteTableStatus(v string) *ListTransitRouterRouteTablesRequest {
	s.TransitRouterRouteTableStatus = &v
	return s
}

func (s *ListTransitRouterRouteTablesRequest) SetTransitRouterRouteTableType(v string) *ListTransitRouterRouteTablesRequest {
	s.TransitRouterRouteTableType = &v
	return s
}

type ListTransitRouterRouteTablesRequestRouteTableOptions struct {
	// Specifies whether to enable equal-cost multi-path (ECMP) routing. Valid values:
	//
	// *   **disable**: disables ECMP routing If you disable ECMP routing, routes that are learned from different regions but have the same prefix and attributes select the transit router with the smallest region ID as the next hop. Region IDs are sorted in alphabetic order. The network latency and bandwidth consumption also vary based on the region. Proceed with caution.
	// *   **enable**: enables ECMP routing. If you enable ECMP routing, routes that are learned from different regions but have the same prefix and attributes form an ECMP route. The network latency and bandwidth consumption also vary based on the region. Proceed with caution.
	MultiRegionECMP *string `json:"MultiRegionECMP,omitempty" xml:"MultiRegionECMP,omitempty"`
}

func (s ListTransitRouterRouteTablesRequestRouteTableOptions) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTablesRequestRouteTableOptions) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTablesRequestRouteTableOptions) SetMultiRegionECMP(v string) *ListTransitRouterRouteTablesRequestRouteTableOptions {
	s.MultiRegionECMP = &v
	return s
}

type ListTransitRouterRouteTablesRequestTag struct {
	// The tag key.
	//
	// The tag key cannot be an empty string. The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTransitRouterRouteTablesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTablesRequestTag) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTablesRequestTag) SetKey(v string) *ListTransitRouterRouteTablesRequestTag {
	s.Key = &v
	return s
}

func (s *ListTransitRouterRouteTablesRequestTag) SetValue(v string) *ListTransitRouterRouteTablesRequestTag {
	s.Value = &v
	return s
}

type ListTransitRouterRouteTablesResponseBody struct {
	// The number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. Valid values:
	//
	// *   If **NextToken** was returned in the previous query, specify the value to obtain the next set of results.
	// *   If a value of **NextToken** is not returned, it indicates that no additional results exist.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// A list of route tables.
	TransitRouterRouteTables []*ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables `json:"TransitRouterRouteTables,omitempty" xml:"TransitRouterRouteTables,omitempty" type:"Repeated"`
}

func (s ListTransitRouterRouteTablesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTablesResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTablesResponseBody) SetMaxResults(v int32) *ListTransitRouterRouteTablesResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterRouteTablesResponseBody) SetNextToken(v string) *ListTransitRouterRouteTablesResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterRouteTablesResponseBody) SetRequestId(v string) *ListTransitRouterRouteTablesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRouterRouteTablesResponseBody) SetTotalCount(v int32) *ListTransitRouterRouteTablesResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTransitRouterRouteTablesResponseBody) SetTransitRouterRouteTables(v []*ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables) *ListTransitRouterRouteTablesResponseBody {
	s.TransitRouterRouteTables = v
	return s
}

type ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables struct {
	// The time when the route table was created.
	//
	// The time follows the ISO8601 standard in the YYYY-MM-DDThh:mmZ format. The time is displayed in UTC.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The region ID of the Enterprise Edition transit router.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The features of the route table.
	RouteTableOptions *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesRouteTableOptions `json:"RouteTableOptions,omitempty" xml:"RouteTableOptions,omitempty" type:"Struct"`
	// The tags.
	Tags []*ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The transit router ID.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The description of the route table.
	TransitRouterRouteTableDescription *string `json:"TransitRouterRouteTableDescription,omitempty" xml:"TransitRouterRouteTableDescription,omitempty"`
	// The ID of the route table.
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
	// The name of the route table.
	TransitRouterRouteTableName *string `json:"TransitRouterRouteTableName,omitempty" xml:"TransitRouterRouteTableName,omitempty"`
	// The status of the route table. Valid values:
	//
	// *   **Creating**
	// *   **Deleting**
	// *   **Active**
	TransitRouterRouteTableStatus *string `json:"TransitRouterRouteTableStatus,omitempty" xml:"TransitRouterRouteTableStatus,omitempty"`
	// The type of the route table. Valid values:
	//
	// *   **Custom**
	// *   **System**
	TransitRouterRouteTableType *string `json:"TransitRouterRouteTableType,omitempty" xml:"TransitRouterRouteTableType,omitempty"`
}

func (s ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables) SetCreateTime(v string) *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables {
	s.CreateTime = &v
	return s
}

func (s *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables) SetRegionId(v string) *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables {
	s.RegionId = &v
	return s
}

func (s *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables) SetRouteTableOptions(v *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesRouteTableOptions) *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables {
	s.RouteTableOptions = v
	return s
}

func (s *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables) SetTags(v []*ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesTags) *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables {
	s.Tags = v
	return s
}

func (s *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables) SetTransitRouterId(v string) *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables {
	s.TransitRouterId = &v
	return s
}

func (s *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables) SetTransitRouterRouteTableDescription(v string) *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables {
	s.TransitRouterRouteTableDescription = &v
	return s
}

func (s *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables) SetTransitRouterRouteTableId(v string) *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables {
	s.TransitRouterRouteTableId = &v
	return s
}

func (s *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables) SetTransitRouterRouteTableName(v string) *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables {
	s.TransitRouterRouteTableName = &v
	return s
}

func (s *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables) SetTransitRouterRouteTableStatus(v string) *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables {
	s.TransitRouterRouteTableStatus = &v
	return s
}

func (s *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables) SetTransitRouterRouteTableType(v string) *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTables {
	s.TransitRouterRouteTableType = &v
	return s
}

type ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesRouteTableOptions struct {
	// Indicates whether ECMP routing is enabled. Valid values:
	//
	// *   **disable** If ECMP routing is disabled, routes that are learned from different regions but have the same prefix and attributes select the transit router with the smallest region ID as the next hop. Region IDs are sorted in alphabetic order. The network latency and bandwidth consumption also vary based on the region. Proceed with caution.
	// *   **enable** If ECMP routing is enabled, routes that are learned from different regions but have the same prefix and attributes form an ECMP route. The network latency and bandwidth consumption also vary based on the region. Proceed with caution.
	MultiRegionECMP *string `json:"MultiRegionECMP,omitempty" xml:"MultiRegionECMP,omitempty"`
}

func (s ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesRouteTableOptions) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesRouteTableOptions) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesRouteTableOptions) SetMultiRegionECMP(v string) *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesRouteTableOptions {
	s.MultiRegionECMP = &v
	return s
}

type ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesTags) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesTags) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesTags) SetKey(v string) *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesTags {
	s.Key = &v
	return s
}

func (s *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesTags) SetValue(v string) *ListTransitRouterRouteTablesResponseBodyTransitRouterRouteTablesTags {
	s.Value = &v
	return s
}

type ListTransitRouterRouteTablesResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterRouteTablesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterRouteTablesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterRouteTablesResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterRouteTablesResponse) SetHeaders(v map[string]*string) *ListTransitRouterRouteTablesResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterRouteTablesResponse) SetStatusCode(v int32) *ListTransitRouterRouteTablesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterRouteTablesResponse) SetBody(v *ListTransitRouterRouteTablesResponseBody) *ListTransitRouterRouteTablesResponse {
	s.Body = v
	return s
}

type ListTransitRouterVbrAttachmentsRequest struct {
	// The IDs of the CEN instances.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The number of entries to return on each page. Default value: **20**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the Enterprise Edition transit router.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The information about the tags.
	//
	// You can specify at most 20 tags in each call.
	Tag []*ListTransitRouterVbrAttachmentsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the VBR connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the Enterprise Edition transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s ListTransitRouterVbrAttachmentsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVbrAttachmentsRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVbrAttachmentsRequest) SetCenId(v string) *ListTransitRouterVbrAttachmentsRequest {
	s.CenId = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsRequest) SetMaxResults(v int32) *ListTransitRouterVbrAttachmentsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsRequest) SetNextToken(v string) *ListTransitRouterVbrAttachmentsRequest {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsRequest) SetOwnerAccount(v string) *ListTransitRouterVbrAttachmentsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsRequest) SetOwnerId(v int64) *ListTransitRouterVbrAttachmentsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsRequest) SetRegionId(v string) *ListTransitRouterVbrAttachmentsRequest {
	s.RegionId = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsRequest) SetResourceOwnerAccount(v string) *ListTransitRouterVbrAttachmentsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsRequest) SetResourceOwnerId(v int64) *ListTransitRouterVbrAttachmentsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsRequest) SetTag(v []*ListTransitRouterVbrAttachmentsRequestTag) *ListTransitRouterVbrAttachmentsRequest {
	s.Tag = v
	return s
}

func (s *ListTransitRouterVbrAttachmentsRequest) SetTransitRouterAttachmentId(v string) *ListTransitRouterVbrAttachmentsRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsRequest) SetTransitRouterId(v string) *ListTransitRouterVbrAttachmentsRequest {
	s.TransitRouterId = &v
	return s
}

type ListTransitRouterVbrAttachmentsRequestTag struct {
	// The tag key.
	//
	// The tag key cannot be an empty string. The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTransitRouterVbrAttachmentsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVbrAttachmentsRequestTag) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVbrAttachmentsRequestTag) SetKey(v string) *ListTransitRouterVbrAttachmentsRequestTag {
	s.Key = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsRequestTag) SetValue(v string) *ListTransitRouterVbrAttachmentsRequestTag {
	s.Value = &v
	return s
}

type ListTransitRouterVbrAttachmentsResponseBody struct {
	// The number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The queried VBR connections.
	TransitRouterAttachments []*ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments `json:"TransitRouterAttachments,omitempty" xml:"TransitRouterAttachments,omitempty" type:"Repeated"`
}

func (s ListTransitRouterVbrAttachmentsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVbrAttachmentsResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVbrAttachmentsResponseBody) SetMaxResults(v int32) *ListTransitRouterVbrAttachmentsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBody) SetNextToken(v string) *ListTransitRouterVbrAttachmentsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBody) SetRequestId(v string) *ListTransitRouterVbrAttachmentsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBody) SetTotalCount(v int32) *ListTransitRouterVbrAttachmentsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBody) SetTransitRouterAttachments(v []*ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) *ListTransitRouterVbrAttachmentsResponseBody {
	s.TransitRouterAttachments = v
	return s
}

type ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments struct {
	// Indicates whether the Enterprise Edition transit router automatically advertises routes to the VBR. Valid values:
	//
	// *   **false** (default): no
	// *   **true**: yes
	AutoPublishRouteEnabled *bool `json:"AutoPublishRouteEnabled,omitempty" xml:"AutoPublishRouteEnabled,omitempty"`
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The time when the VBR connection was established.
	//
	// The time follows the ISO8601 standard in the YYYY-MM-DDThh:mmZ format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The type of resource to which the transit router is connected. Valid values:
	//
	// *   **VPC**: VPC
	// *   **CCN**: Cloud Connect Network (CCN) instance
	// *   **VBR**: VBR
	// *   **TR**: transit router
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The status of the VBR connection. Valid values:
	//
	// *   **Attached**: The VBR connection is created on the transit router.
	// *   **Attaching**: The VBR connection is being created on the transit router.
	// *   **Detaching**: The VBR connection is being deleted from the transit router.
	// *   **Detached**: The VBR connection is deleted from the transit router.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tags.
	Tags []*ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachmentsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The description of the VBR connection.
	TransitRouterAttachmentDescription *string `json:"TransitRouterAttachmentDescription,omitempty" xml:"TransitRouterAttachmentDescription,omitempty"`
	// The ID of the VBR connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The name of the VBR connection.
	TransitRouterAttachmentName *string `json:"TransitRouterAttachmentName,omitempty" xml:"TransitRouterAttachmentName,omitempty"`
	// The ID of the Enterprise Edition transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The VBR ID.
	VbrId *string `json:"VbrId,omitempty" xml:"VbrId,omitempty"`
	// The ID of the account to which the VBR belongs.
	VbrOwnerId *int64 `json:"VbrOwnerId,omitempty" xml:"VbrOwnerId,omitempty"`
	// The region ID of the VBR.
	VbrRegionId *string `json:"VbrRegionId,omitempty" xml:"VbrRegionId,omitempty"`
}

func (s ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) SetAutoPublishRouteEnabled(v bool) *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments {
	s.AutoPublishRouteEnabled = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) SetCenId(v string) *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments {
	s.CenId = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) SetCreationTime(v string) *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments {
	s.CreationTime = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) SetResourceType(v string) *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments {
	s.ResourceType = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) SetStatus(v string) *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments {
	s.Status = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) SetTags(v []*ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachmentsTags) *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments {
	s.Tags = v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterAttachmentDescription(v string) *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterAttachmentDescription = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterAttachmentId(v string) *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterAttachmentName(v string) *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterAttachmentName = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterId(v string) *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterId = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) SetVbrId(v string) *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments {
	s.VbrId = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) SetVbrOwnerId(v int64) *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments {
	s.VbrOwnerId = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments) SetVbrRegionId(v string) *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachments {
	s.VbrRegionId = &v
	return s
}

type ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachmentsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachmentsTags) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachmentsTags) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachmentsTags) SetKey(v string) *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachmentsTags {
	s.Key = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachmentsTags) SetValue(v string) *ListTransitRouterVbrAttachmentsResponseBodyTransitRouterAttachmentsTags {
	s.Value = &v
	return s
}

type ListTransitRouterVbrAttachmentsResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterVbrAttachmentsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterVbrAttachmentsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVbrAttachmentsResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVbrAttachmentsResponse) SetHeaders(v map[string]*string) *ListTransitRouterVbrAttachmentsResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponse) SetStatusCode(v int32) *ListTransitRouterVbrAttachmentsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterVbrAttachmentsResponse) SetBody(v *ListTransitRouterVbrAttachmentsResponseBody) *ListTransitRouterVbrAttachmentsResponse {
	s.Body = v
	return s
}

type ListTransitRouterVpcAttachmentsRequest struct {
	// The IDs of the CEN instances.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The number of entries to return on each page. Default value: **20**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the query. Valid values:
	//
	// *   If this is your first query and no subsequent queries are to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The entity that pays the fees of the network instance. Valid values:
	//
	// *   **PayByCenOwner**: the Alibaba Cloud account that owns the CEN instance.
	// *   **PayByResourceOwner**: the Alibaba Cloud account that owns the network instance.
	OrderType    *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the Enterprise Edition transit router.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether the network instance is attached to the CEN instance. Valid values:
	//
	// *   **Attaching**: being attached to the CEN instance.
	// *   **Attached**: attached to the CEN instance.
	// *   **Detaching**: being detached from the CEN instance.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The information about the tags.
	//
	// You can specify at most 20 tags in each call.
	Tag []*ListTransitRouterVpcAttachmentsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the VPC connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the Enterprise Edition transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s ListTransitRouterVpcAttachmentsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVpcAttachmentsRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVpcAttachmentsRequest) SetCenId(v string) *ListTransitRouterVpcAttachmentsRequest {
	s.CenId = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsRequest) SetMaxResults(v int32) *ListTransitRouterVpcAttachmentsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsRequest) SetNextToken(v string) *ListTransitRouterVpcAttachmentsRequest {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsRequest) SetOrderType(v string) *ListTransitRouterVpcAttachmentsRequest {
	s.OrderType = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsRequest) SetOwnerAccount(v string) *ListTransitRouterVpcAttachmentsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsRequest) SetOwnerId(v int64) *ListTransitRouterVpcAttachmentsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsRequest) SetRegionId(v string) *ListTransitRouterVpcAttachmentsRequest {
	s.RegionId = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsRequest) SetResourceOwnerAccount(v string) *ListTransitRouterVpcAttachmentsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsRequest) SetResourceOwnerId(v int64) *ListTransitRouterVpcAttachmentsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsRequest) SetStatus(v string) *ListTransitRouterVpcAttachmentsRequest {
	s.Status = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsRequest) SetTag(v []*ListTransitRouterVpcAttachmentsRequestTag) *ListTransitRouterVpcAttachmentsRequest {
	s.Tag = v
	return s
}

func (s *ListTransitRouterVpcAttachmentsRequest) SetTransitRouterAttachmentId(v string) *ListTransitRouterVpcAttachmentsRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsRequest) SetTransitRouterId(v string) *ListTransitRouterVpcAttachmentsRequest {
	s.TransitRouterId = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsRequest) SetVpcId(v string) *ListTransitRouterVpcAttachmentsRequest {
	s.VpcId = &v
	return s
}

type ListTransitRouterVpcAttachmentsRequestTag struct {
	// The tag key.
	//
	// The tag key cannot be an empty string. The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTransitRouterVpcAttachmentsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVpcAttachmentsRequestTag) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVpcAttachmentsRequestTag) SetKey(v string) *ListTransitRouterVpcAttachmentsRequestTag {
	s.Key = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsRequestTag) SetValue(v string) *ListTransitRouterVpcAttachmentsRequestTag {
	s.Value = &v
	return s
}

type ListTransitRouterVpcAttachmentsResponseBody struct {
	// The number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. Valid values:
	//
	// *   If **NextToken** is returned, it indicates that no additional results exist.
	// *   If **NextToken** was returned in the previous query, specify the value to obtain the next set of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the region.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The queried VPC connections.
	TransitRouterAttachments []*ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments `json:"TransitRouterAttachments,omitempty" xml:"TransitRouterAttachments,omitempty" type:"Repeated"`
}

func (s ListTransitRouterVpcAttachmentsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVpcAttachmentsResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVpcAttachmentsResponseBody) SetMaxResults(v int32) *ListTransitRouterVpcAttachmentsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBody) SetNextToken(v string) *ListTransitRouterVpcAttachmentsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBody) SetRequestId(v string) *ListTransitRouterVpcAttachmentsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBody) SetTotalCount(v int32) *ListTransitRouterVpcAttachmentsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBody) SetTransitRouterAttachments(v []*ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) *ListTransitRouterVpcAttachmentsResponseBody {
	s.TransitRouterAttachments = v
	return s
}

type ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments struct {
	// VPC
	//
	// - **false**
	// - **true**
	AutoPublishRouteEnabled *bool `json:"AutoPublishRouteEnabled,omitempty" xml:"AutoPublishRouteEnabled,omitempty"`
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The billing method of the VPC connection.
	//
	// The value is **POSTPAY**, which is the default value and specifies the pay-as-you-go billing method.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The time when the VPC connection is created.
	//
	// The time follows the ISO8601 standard in the YYYY-MM-DDThh:mmZ format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The entity that pays the fees of the network instance. Valid values:
	//
	// *   **PayByCenOwner**: the Alibaba Cloud account that owns the CEN instance.
	// *   **PayByResourceOwner**: the Alibaba Cloud account that owns the network instance.
	OrderType *string `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	// The type of resource to which the transit router is connected.
	//
	// The value is set to **VPC**.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The status of the VPC connection. Valid values:
	//
	// *   **Attached**: The VPC connection is created on the transit router.
	// *   **Attaching**: The VPC connection is being created on the transit router.
	// *   **Detaching**: The VPC connection is being deleted from the transit router.
	// *   **Detached**: The VPC connection is deleted from the transit router.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag key.
	Tags []*ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The description of the VPC connection.
	TransitRouterAttachmentDescription *string `json:"TransitRouterAttachmentDescription,omitempty" xml:"TransitRouterAttachmentDescription,omitempty"`
	// The ID of the VPC connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The name of the VPC connection.
	TransitRouterAttachmentName *string `json:"TransitRouterAttachmentName,omitempty" xml:"TransitRouterAttachmentName,omitempty"`
	// The ID of the Enterprise Edition transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The ID of the VPC.
	VpcId *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
	// The ID of the Alibaba Cloud account to which the VPC belongs.
	VpcOwnerId *int64 `json:"VpcOwnerId,omitempty" xml:"VpcOwnerId,omitempty"`
	// The ID of the region where the VPC is deployed.
	VpcRegionId *string `json:"VpcRegionId,omitempty" xml:"VpcRegionId,omitempty"`
	// The primary and secondary zones of the VPC connection and the vSwitches and elastic network interfaces (ENIs) of the VPC.
	ZoneMappings []*ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsZoneMappings `json:"ZoneMappings,omitempty" xml:"ZoneMappings,omitempty" type:"Repeated"`
}

func (s ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetAutoPublishRouteEnabled(v bool) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.AutoPublishRouteEnabled = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetCenId(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.CenId = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetChargeType(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.ChargeType = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetCreationTime(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.CreationTime = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetOrderType(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.OrderType = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetResourceType(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.ResourceType = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetStatus(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.Status = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetTags(v []*ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsTags) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.Tags = v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterAttachmentDescription(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterAttachmentDescription = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterAttachmentId(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterAttachmentName(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterAttachmentName = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterId(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterId = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetVpcId(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.VpcId = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetVpcOwnerId(v int64) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.VpcOwnerId = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetVpcRegionId(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.VpcRegionId = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments) SetZoneMappings(v []*ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsZoneMappings) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachments {
	s.ZoneMappings = v
	return s
}

type ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsTags) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsTags) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsTags) SetKey(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsTags {
	s.Key = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsTags) SetValue(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsTags {
	s.Value = &v
	return s
}

type ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsZoneMappings struct {
	// The ID of the ENI that is associated with the vSwitch of the Enterprise Edition transit router.
	NetworkInterfaceId *string `json:"NetworkInterfaceId,omitempty" xml:"NetworkInterfaceId,omitempty"`
	// The vSwitch ID of the node.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The zone ID of the instance.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsZoneMappings) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsZoneMappings) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsZoneMappings) SetNetworkInterfaceId(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsZoneMappings {
	s.NetworkInterfaceId = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsZoneMappings) SetVSwitchId(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsZoneMappings {
	s.VSwitchId = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsZoneMappings) SetZoneId(v string) *ListTransitRouterVpcAttachmentsResponseBodyTransitRouterAttachmentsZoneMappings {
	s.ZoneId = &v
	return s
}

type ListTransitRouterVpcAttachmentsResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterVpcAttachmentsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterVpcAttachmentsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVpcAttachmentsResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVpcAttachmentsResponse) SetHeaders(v map[string]*string) *ListTransitRouterVpcAttachmentsResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponse) SetStatusCode(v int32) *ListTransitRouterVpcAttachmentsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterVpcAttachmentsResponse) SetBody(v *ListTransitRouterVpcAttachmentsResponseBody) *ListTransitRouterVpcAttachmentsResponse {
	s.Body = v
	return s
}

type ListTransitRouterVpnAttachmentsRequest struct {
	// The ID of the Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The number of entries to return on each page. Default value: **20**.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. Valid values:
	//
	// *   If this is your first query and no subsequent queries are to be sent, ignore this parameter.
	// *   If a subsequent query is to be sent, set the parameter to the value of NextToken that is returned from the last call.
	NextToken    *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the transit router is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The information about the tags that are added to the CEN instance.
	//
	// You can query at most 20 tags in each call.
	Tag []*ListTransitRouterVpnAttachmentsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The ID of the VPN attachment.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The ID of the transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s ListTransitRouterVpnAttachmentsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVpnAttachmentsRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVpnAttachmentsRequest) SetCenId(v string) *ListTransitRouterVpnAttachmentsRequest {
	s.CenId = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsRequest) SetMaxResults(v int32) *ListTransitRouterVpnAttachmentsRequest {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsRequest) SetNextToken(v string) *ListTransitRouterVpnAttachmentsRequest {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsRequest) SetOwnerAccount(v string) *ListTransitRouterVpnAttachmentsRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsRequest) SetOwnerId(v int64) *ListTransitRouterVpnAttachmentsRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsRequest) SetRegionId(v string) *ListTransitRouterVpnAttachmentsRequest {
	s.RegionId = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsRequest) SetResourceOwnerAccount(v string) *ListTransitRouterVpnAttachmentsRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsRequest) SetResourceOwnerId(v int64) *ListTransitRouterVpnAttachmentsRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsRequest) SetTag(v []*ListTransitRouterVpnAttachmentsRequestTag) *ListTransitRouterVpnAttachmentsRequest {
	s.Tag = v
	return s
}

func (s *ListTransitRouterVpnAttachmentsRequest) SetTransitRouterAttachmentId(v string) *ListTransitRouterVpnAttachmentsRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsRequest) SetTransitRouterId(v string) *ListTransitRouterVpnAttachmentsRequest {
	s.TransitRouterId = &v
	return s
}

type ListTransitRouterVpnAttachmentsRequestTag struct {
	// The tag key.
	//
	// The tag key cannot be an empty string. The tag key can be up to 64 characters in length and cannot start with `acs:` or `aliyun`. It cannot contain `http://` or `https://`.
	//
	// You can specify at most 20 tag keys.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	//
	// The tag value can be 0 to 128 characters in length, and cannot start with `aliyun` or `acs:`. It cannot contain `http://` or `https://`.
	//
	// Each tag key must have a unique tag value. You can specify at most 20 tag values in each call.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTransitRouterVpnAttachmentsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVpnAttachmentsRequestTag) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVpnAttachmentsRequestTag) SetKey(v string) *ListTransitRouterVpnAttachmentsRequestTag {
	s.Key = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsRequestTag) SetValue(v string) *ListTransitRouterVpnAttachmentsRequestTag {
	s.Value = &v
	return s
}

type ListTransitRouterVpnAttachmentsResponseBody struct {
	// The number of entries returned per page.
	MaxResults *int32 `json:"MaxResults,omitempty" xml:"MaxResults,omitempty"`
	// The token that determines the start point of the next query. Valid values:
	//
	// *   If **NextToken** is not returned, it indicates that no additional results exist.
	// *   If **NextToken** was returned in the previous query, specify the value to obtain the next set of results.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The information about the VPN attachment.
	TransitRouterAttachments []*ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments `json:"TransitRouterAttachments,omitempty" xml:"TransitRouterAttachments,omitempty" type:"Repeated"`
}

func (s ListTransitRouterVpnAttachmentsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVpnAttachmentsResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVpnAttachmentsResponseBody) SetMaxResults(v int32) *ListTransitRouterVpnAttachmentsResponseBody {
	s.MaxResults = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBody) SetNextToken(v string) *ListTransitRouterVpnAttachmentsResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBody) SetRequestId(v string) *ListTransitRouterVpnAttachmentsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBody) SetTotalCount(v int32) *ListTransitRouterVpnAttachmentsResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBody) SetTransitRouterAttachments(v []*ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) *ListTransitRouterVpnAttachmentsResponseBody {
	s.TransitRouterAttachments = v
	return s
}

type ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments struct {
	// Specifies whether to allow the transit router to automatically advertise routes to the IPsec-VPN connection. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	AutoPublishRouteEnabled *bool `json:"AutoPublishRouteEnabled,omitempty" xml:"AutoPublishRouteEnabled,omitempty"`
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The billing method of the VPN attachment.
	//
	// The value is POSTPAY, which is the default value and specifies the pay-as-you-go billing method.
	ChargeType *string `json:"ChargeType,omitempty" xml:"ChargeType,omitempty"`
	// The time when the VPN attachment was created.
	//
	// The time follows the ISO8601 standard in the YYYY-MM-DDThh:mmZ format. The time is displayed in UTC.
	CreationTime *string `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	// The type of resource to which the transit router is connected.
	//
	// Valid value: **VPN**, which indicates that an IPsec-VPN connection is attached to the transit router.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The status of the VPN attachment. Valid values:
	//
	// *   **Attached**: The VPC attachment has been created on the transit router.
	// *   **Attaching**: The VPN attachment is being created on the transit router.
	// *   **Detaching**: The VPN attachment is being deleted from the transit router.
	// *   **Detached**: The VPN attachment is deleted from the transit router.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// A list of tags.
	Tags []*ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The description of the VPN attachment.
	TransitRouterAttachmentDescription *string `json:"TransitRouterAttachmentDescription,omitempty" xml:"TransitRouterAttachmentDescription,omitempty"`
	// The ID of the VPN attachment.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The name of the VPN attachment.
	TransitRouterAttachmentName *string `json:"TransitRouterAttachmentName,omitempty" xml:"TransitRouterAttachmentName,omitempty"`
	// The ID of the transit router.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The ID of the IPsec-VPN connection.
	VpnId *string `json:"VpnId,omitempty" xml:"VpnId,omitempty"`
	// The ID of the Alibaba Cloud account to which the IPsec-VPN connection belongs.
	VpnOwnerId *int64 `json:"VpnOwnerId,omitempty" xml:"VpnOwnerId,omitempty"`
	// The ID of the region to which the IPsec-VPN connection belongs.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	VpnRegionId *string `json:"VpnRegionId,omitempty" xml:"VpnRegionId,omitempty"`
	// The zones where the VPN attachment is deployed.
	Zones []*ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsZones `json:"Zones,omitempty" xml:"Zones,omitempty" type:"Repeated"`
}

func (s ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) SetAutoPublishRouteEnabled(v bool) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments {
	s.AutoPublishRouteEnabled = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) SetCenId(v string) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments {
	s.CenId = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) SetChargeType(v string) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments {
	s.ChargeType = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) SetCreationTime(v string) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments {
	s.CreationTime = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) SetResourceType(v string) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments {
	s.ResourceType = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) SetStatus(v string) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments {
	s.Status = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) SetTags(v []*ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsTags) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments {
	s.Tags = v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterAttachmentDescription(v string) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterAttachmentDescription = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterAttachmentId(v string) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterAttachmentName(v string) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterAttachmentName = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) SetTransitRouterId(v string) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments {
	s.TransitRouterId = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) SetVpnId(v string) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments {
	s.VpnId = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) SetVpnOwnerId(v int64) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments {
	s.VpnOwnerId = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) SetVpnRegionId(v string) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments {
	s.VpnRegionId = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments) SetZones(v []*ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsZones) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachments {
	s.Zones = v
	return s
}

type ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsTags struct {
	// The tag key.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The tag value.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsTags) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsTags) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsTags) SetKey(v string) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsTags {
	s.Key = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsTags) SetValue(v string) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsTags {
	s.Value = &v
	return s
}

type ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsZones struct {
	// The ID of the zone.
	//
	// You can call the [DescribeZones](~~36064~~) operation to query the most recent zone list.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsZones) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsZones) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsZones) SetZoneId(v string) *ListTransitRouterVpnAttachmentsResponseBodyTransitRouterAttachmentsZones {
	s.ZoneId = &v
	return s
}

type ListTransitRouterVpnAttachmentsResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRouterVpnAttachmentsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRouterVpnAttachmentsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRouterVpnAttachmentsResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRouterVpnAttachmentsResponse) SetHeaders(v map[string]*string) *ListTransitRouterVpnAttachmentsResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponse) SetStatusCode(v int32) *ListTransitRouterVpnAttachmentsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRouterVpnAttachmentsResponse) SetBody(v *ListTransitRouterVpnAttachmentsResponseBody) *ListTransitRouterVpnAttachmentsResponse {
	s.Body = v
	return s
}

type ListTransitRoutersRequest struct {
	CenId                *string                                   `json:"CenId,omitempty" xml:"CenId,omitempty"`
	FeatureFilter        []*ListTransitRoutersRequestFeatureFilter `json:"FeatureFilter,omitempty" xml:"FeatureFilter,omitempty" type:"Repeated"`
	OwnerAccount         *string                                   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64                                    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PageNumber           *int32                                    `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize             *int32                                    `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RegionId             *string                                   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string                                   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	Status               *string                                   `json:"Status,omitempty" xml:"Status,omitempty"`
	Tag                  []*ListTransitRoutersRequestTag           `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	TransitRouterId      *string                                   `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	TransitRouterName    *string                                   `json:"TransitRouterName,omitempty" xml:"TransitRouterName,omitempty"`
	Type                 *string                                   `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListTransitRoutersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRoutersRequest) GoString() string {
	return s.String()
}

func (s *ListTransitRoutersRequest) SetCenId(v string) *ListTransitRoutersRequest {
	s.CenId = &v
	return s
}

func (s *ListTransitRoutersRequest) SetFeatureFilter(v []*ListTransitRoutersRequestFeatureFilter) *ListTransitRoutersRequest {
	s.FeatureFilter = v
	return s
}

func (s *ListTransitRoutersRequest) SetOwnerAccount(v string) *ListTransitRoutersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ListTransitRoutersRequest) SetOwnerId(v int64) *ListTransitRoutersRequest {
	s.OwnerId = &v
	return s
}

func (s *ListTransitRoutersRequest) SetPageNumber(v int32) *ListTransitRoutersRequest {
	s.PageNumber = &v
	return s
}

func (s *ListTransitRoutersRequest) SetPageSize(v int32) *ListTransitRoutersRequest {
	s.PageSize = &v
	return s
}

func (s *ListTransitRoutersRequest) SetRegionId(v string) *ListTransitRoutersRequest {
	s.RegionId = &v
	return s
}

func (s *ListTransitRoutersRequest) SetResourceOwnerAccount(v string) *ListTransitRoutersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ListTransitRoutersRequest) SetResourceOwnerId(v int64) *ListTransitRoutersRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ListTransitRoutersRequest) SetStatus(v string) *ListTransitRoutersRequest {
	s.Status = &v
	return s
}

func (s *ListTransitRoutersRequest) SetTag(v []*ListTransitRoutersRequestTag) *ListTransitRoutersRequest {
	s.Tag = v
	return s
}

func (s *ListTransitRoutersRequest) SetTransitRouterId(v string) *ListTransitRoutersRequest {
	s.TransitRouterId = &v
	return s
}

func (s *ListTransitRoutersRequest) SetTransitRouterName(v string) *ListTransitRoutersRequest {
	s.TransitRouterName = &v
	return s
}

func (s *ListTransitRoutersRequest) SetType(v string) *ListTransitRoutersRequest {
	s.Type = &v
	return s
}

type ListTransitRoutersRequestFeatureFilter struct {
	Key   *string   `json:"Key,omitempty" xml:"Key,omitempty"`
	Value []*string `json:"Value,omitempty" xml:"Value,omitempty" type:"Repeated"`
}

func (s ListTransitRoutersRequestFeatureFilter) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRoutersRequestFeatureFilter) GoString() string {
	return s.String()
}

func (s *ListTransitRoutersRequestFeatureFilter) SetKey(v string) *ListTransitRoutersRequestFeatureFilter {
	s.Key = &v
	return s
}

func (s *ListTransitRoutersRequestFeatureFilter) SetValue(v []*string) *ListTransitRoutersRequestFeatureFilter {
	s.Value = v
	return s
}

type ListTransitRoutersRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTransitRoutersRequestTag) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRoutersRequestTag) GoString() string {
	return s.String()
}

func (s *ListTransitRoutersRequestTag) SetKey(v string) *ListTransitRoutersRequestTag {
	s.Key = &v
	return s
}

func (s *ListTransitRoutersRequestTag) SetValue(v string) *ListTransitRoutersRequestTag {
	s.Value = &v
	return s
}

type ListTransitRoutersResponseBody struct {
	PageNumber     *int32                                          `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize       *int32                                          `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId      *string                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	TotalCount     *int32                                          `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	TransitRouters []*ListTransitRoutersResponseBodyTransitRouters `json:"TransitRouters,omitempty" xml:"TransitRouters,omitempty" type:"Repeated"`
}

func (s ListTransitRoutersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRoutersResponseBody) GoString() string {
	return s.String()
}

func (s *ListTransitRoutersResponseBody) SetPageNumber(v int32) *ListTransitRoutersResponseBody {
	s.PageNumber = &v
	return s
}

func (s *ListTransitRoutersResponseBody) SetPageSize(v int32) *ListTransitRoutersResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListTransitRoutersResponseBody) SetRequestId(v string) *ListTransitRoutersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTransitRoutersResponseBody) SetTotalCount(v int32) *ListTransitRoutersResponseBody {
	s.TotalCount = &v
	return s
}

func (s *ListTransitRoutersResponseBody) SetTransitRouters(v []*ListTransitRoutersResponseBodyTransitRouters) *ListTransitRoutersResponseBody {
	s.TransitRouters = v
	return s
}

type ListTransitRoutersResponseBodyTransitRouters struct {
	AliUid                   *int64                                                               `json:"AliUid,omitempty" xml:"AliUid,omitempty"`
	CenId                    *string                                                              `json:"CenId,omitempty" xml:"CenId,omitempty"`
	CreationTime             *string                                                              `json:"CreationTime,omitempty" xml:"CreationTime,omitempty"`
	RegionId                 *string                                                              `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	Status                   *string                                                              `json:"Status,omitempty" xml:"Status,omitempty"`
	SupportMulticast         *bool                                                                `json:"SupportMulticast,omitempty" xml:"SupportMulticast,omitempty"`
	Tags                     []*ListTransitRoutersResponseBodyTransitRoutersTags                  `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	TransitRouterCidrList    []*ListTransitRoutersResponseBodyTransitRoutersTransitRouterCidrList `json:"TransitRouterCidrList,omitempty" xml:"TransitRouterCidrList,omitempty" type:"Repeated"`
	TransitRouterDescription *string                                                              `json:"TransitRouterDescription,omitempty" xml:"TransitRouterDescription,omitempty"`
	TransitRouterId          *string                                                              `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	TransitRouterName        *string                                                              `json:"TransitRouterName,omitempty" xml:"TransitRouterName,omitempty"`
	Type                     *string                                                              `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListTransitRoutersResponseBodyTransitRouters) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRoutersResponseBodyTransitRouters) GoString() string {
	return s.String()
}

func (s *ListTransitRoutersResponseBodyTransitRouters) SetAliUid(v int64) *ListTransitRoutersResponseBodyTransitRouters {
	s.AliUid = &v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRouters) SetCenId(v string) *ListTransitRoutersResponseBodyTransitRouters {
	s.CenId = &v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRouters) SetCreationTime(v string) *ListTransitRoutersResponseBodyTransitRouters {
	s.CreationTime = &v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRouters) SetRegionId(v string) *ListTransitRoutersResponseBodyTransitRouters {
	s.RegionId = &v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRouters) SetStatus(v string) *ListTransitRoutersResponseBodyTransitRouters {
	s.Status = &v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRouters) SetSupportMulticast(v bool) *ListTransitRoutersResponseBodyTransitRouters {
	s.SupportMulticast = &v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRouters) SetTags(v []*ListTransitRoutersResponseBodyTransitRoutersTags) *ListTransitRoutersResponseBodyTransitRouters {
	s.Tags = v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRouters) SetTransitRouterCidrList(v []*ListTransitRoutersResponseBodyTransitRoutersTransitRouterCidrList) *ListTransitRoutersResponseBodyTransitRouters {
	s.TransitRouterCidrList = v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRouters) SetTransitRouterDescription(v string) *ListTransitRoutersResponseBodyTransitRouters {
	s.TransitRouterDescription = &v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRouters) SetTransitRouterId(v string) *ListTransitRoutersResponseBodyTransitRouters {
	s.TransitRouterId = &v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRouters) SetTransitRouterName(v string) *ListTransitRoutersResponseBodyTransitRouters {
	s.TransitRouterName = &v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRouters) SetType(v string) *ListTransitRoutersResponseBodyTransitRouters {
	s.Type = &v
	return s
}

type ListTransitRoutersResponseBodyTransitRoutersTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListTransitRoutersResponseBodyTransitRoutersTags) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRoutersResponseBodyTransitRoutersTags) GoString() string {
	return s.String()
}

func (s *ListTransitRoutersResponseBodyTransitRoutersTags) SetKey(v string) *ListTransitRoutersResponseBodyTransitRoutersTags {
	s.Key = &v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRoutersTags) SetValue(v string) *ListTransitRoutersResponseBodyTransitRoutersTags {
	s.Value = &v
	return s
}

type ListTransitRoutersResponseBodyTransitRoutersTransitRouterCidrList struct {
	Cidr                *string `json:"Cidr,omitempty" xml:"Cidr,omitempty"`
	Description         *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Name                *string `json:"Name,omitempty" xml:"Name,omitempty"`
	PublishCidrRoute    *bool   `json:"PublishCidrRoute,omitempty" xml:"PublishCidrRoute,omitempty"`
	TransitRouterCidrId *string `json:"TransitRouterCidrId,omitempty" xml:"TransitRouterCidrId,omitempty"`
}

func (s ListTransitRoutersResponseBodyTransitRoutersTransitRouterCidrList) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRoutersResponseBodyTransitRoutersTransitRouterCidrList) GoString() string {
	return s.String()
}

func (s *ListTransitRoutersResponseBodyTransitRoutersTransitRouterCidrList) SetCidr(v string) *ListTransitRoutersResponseBodyTransitRoutersTransitRouterCidrList {
	s.Cidr = &v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRoutersTransitRouterCidrList) SetDescription(v string) *ListTransitRoutersResponseBodyTransitRoutersTransitRouterCidrList {
	s.Description = &v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRoutersTransitRouterCidrList) SetName(v string) *ListTransitRoutersResponseBodyTransitRoutersTransitRouterCidrList {
	s.Name = &v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRoutersTransitRouterCidrList) SetPublishCidrRoute(v bool) *ListTransitRoutersResponseBodyTransitRoutersTransitRouterCidrList {
	s.PublishCidrRoute = &v
	return s
}

func (s *ListTransitRoutersResponseBodyTransitRoutersTransitRouterCidrList) SetTransitRouterCidrId(v string) *ListTransitRoutersResponseBodyTransitRoutersTransitRouterCidrList {
	s.TransitRouterCidrId = &v
	return s
}

type ListTransitRoutersResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTransitRoutersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTransitRoutersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTransitRoutersResponse) GoString() string {
	return s.String()
}

func (s *ListTransitRoutersResponse) SetHeaders(v map[string]*string) *ListTransitRoutersResponse {
	s.Headers = v
	return s
}

func (s *ListTransitRoutersResponse) SetStatusCode(v int32) *ListTransitRoutersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTransitRoutersResponse) SetBody(v *ListTransitRoutersResponseBody) *ListTransitRoutersResponse {
	s.Body = v
	return s
}

type ModifyCenAttributeRequest struct {
	// Modifies the name and description of a Cloud Enterprise Network (CEN) instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// WB656982
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// ModifyCenAttribute
	Name                 *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ProtectionLevel      *string `json:"ProtectionLevel,omitempty" xml:"ProtectionLevel,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyCenAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCenAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyCenAttributeRequest) SetCenId(v string) *ModifyCenAttributeRequest {
	s.CenId = &v
	return s
}

func (s *ModifyCenAttributeRequest) SetDescription(v string) *ModifyCenAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyCenAttributeRequest) SetName(v string) *ModifyCenAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyCenAttributeRequest) SetOwnerAccount(v string) *ModifyCenAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyCenAttributeRequest) SetOwnerId(v int64) *ModifyCenAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyCenAttributeRequest) SetProtectionLevel(v string) *ModifyCenAttributeRequest {
	s.ProtectionLevel = &v
	return s
}

func (s *ModifyCenAttributeRequest) SetResourceOwnerAccount(v string) *ModifyCenAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyCenAttributeRequest) SetResourceOwnerId(v int64) *ModifyCenAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyCenAttributeResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyCenAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCenAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCenAttributeResponseBody) SetRequestId(v string) *ModifyCenAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyCenAttributeResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCenAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCenAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCenAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyCenAttributeResponse) SetHeaders(v map[string]*string) *ModifyCenAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyCenAttributeResponse) SetStatusCode(v int32) *ModifyCenAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCenAttributeResponse) SetBody(v *ModifyCenAttributeResponseBody) *ModifyCenAttributeResponse {
	s.Body = v
	return s
}

type ModifyCenBandwidthPackageAttributeRequest struct {
	// The ID of the bandwidth plan.
	CenBandwidthPackageId *string `json:"CenBandwidthPackageId,omitempty" xml:"CenBandwidthPackageId,omitempty"`
	// The new description of the bandwidth plan.
	//
	// The description must be 2 to 256 characters in length. It must start with a letter and cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The new name of the bandwidth plan.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter and cannot start with `http://` or `https://`.
	Name                 *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyCenBandwidthPackageAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCenBandwidthPackageAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyCenBandwidthPackageAttributeRequest) SetCenBandwidthPackageId(v string) *ModifyCenBandwidthPackageAttributeRequest {
	s.CenBandwidthPackageId = &v
	return s
}

func (s *ModifyCenBandwidthPackageAttributeRequest) SetDescription(v string) *ModifyCenBandwidthPackageAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyCenBandwidthPackageAttributeRequest) SetName(v string) *ModifyCenBandwidthPackageAttributeRequest {
	s.Name = &v
	return s
}

func (s *ModifyCenBandwidthPackageAttributeRequest) SetOwnerAccount(v string) *ModifyCenBandwidthPackageAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyCenBandwidthPackageAttributeRequest) SetOwnerId(v int64) *ModifyCenBandwidthPackageAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyCenBandwidthPackageAttributeRequest) SetResourceOwnerAccount(v string) *ModifyCenBandwidthPackageAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyCenBandwidthPackageAttributeRequest) SetResourceOwnerId(v int64) *ModifyCenBandwidthPackageAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyCenBandwidthPackageAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyCenBandwidthPackageAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCenBandwidthPackageAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCenBandwidthPackageAttributeResponseBody) SetRequestId(v string) *ModifyCenBandwidthPackageAttributeResponseBody {
	s.RequestId = &v
	return s
}

type ModifyCenBandwidthPackageAttributeResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCenBandwidthPackageAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCenBandwidthPackageAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCenBandwidthPackageAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyCenBandwidthPackageAttributeResponse) SetHeaders(v map[string]*string) *ModifyCenBandwidthPackageAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyCenBandwidthPackageAttributeResponse) SetStatusCode(v int32) *ModifyCenBandwidthPackageAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCenBandwidthPackageAttributeResponse) SetBody(v *ModifyCenBandwidthPackageAttributeResponseBody) *ModifyCenBandwidthPackageAttributeResponse {
	s.Body = v
	return s
}

type ModifyCenBandwidthPackageSpecRequest struct {
	// The new maximum bandwidth value of the bandwidth plan. Unit: Mbit/s.
	//
	// Valid values: **2** to **10000**.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The ID of the bandwidth plan.
	CenBandwidthPackageId *string `json:"CenBandwidthPackageId,omitempty" xml:"CenBandwidthPackageId,omitempty"`
	OwnerAccount          *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId               *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount  *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId       *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyCenBandwidthPackageSpecRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCenBandwidthPackageSpecRequest) GoString() string {
	return s.String()
}

func (s *ModifyCenBandwidthPackageSpecRequest) SetBandwidth(v int32) *ModifyCenBandwidthPackageSpecRequest {
	s.Bandwidth = &v
	return s
}

func (s *ModifyCenBandwidthPackageSpecRequest) SetCenBandwidthPackageId(v string) *ModifyCenBandwidthPackageSpecRequest {
	s.CenBandwidthPackageId = &v
	return s
}

func (s *ModifyCenBandwidthPackageSpecRequest) SetOwnerAccount(v string) *ModifyCenBandwidthPackageSpecRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyCenBandwidthPackageSpecRequest) SetOwnerId(v int64) *ModifyCenBandwidthPackageSpecRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyCenBandwidthPackageSpecRequest) SetResourceOwnerAccount(v string) *ModifyCenBandwidthPackageSpecRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyCenBandwidthPackageSpecRequest) SetResourceOwnerId(v int64) *ModifyCenBandwidthPackageSpecRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyCenBandwidthPackageSpecResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyCenBandwidthPackageSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCenBandwidthPackageSpecResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCenBandwidthPackageSpecResponseBody) SetRequestId(v string) *ModifyCenBandwidthPackageSpecResponseBody {
	s.RequestId = &v
	return s
}

type ModifyCenBandwidthPackageSpecResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCenBandwidthPackageSpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCenBandwidthPackageSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCenBandwidthPackageSpecResponse) GoString() string {
	return s.String()
}

func (s *ModifyCenBandwidthPackageSpecResponse) SetHeaders(v map[string]*string) *ModifyCenBandwidthPackageSpecResponse {
	s.Headers = v
	return s
}

func (s *ModifyCenBandwidthPackageSpecResponse) SetStatusCode(v int32) *ModifyCenBandwidthPackageSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCenBandwidthPackageSpecResponse) SetBody(v *ModifyCenBandwidthPackageSpecResponseBody) *ModifyCenBandwidthPackageSpecResponse {
	s.Body = v
	return s
}

type ModifyCenRouteMapRequest struct {
	// The AS paths against which routes are matched.
	//
	// > Only the AS-SEQUENCE parameter is supported. The AS-SET, AS-CONFED-SEQUENCE, and AS-CONFED-SET parameters are not supported. In other words, only the AS number list is supported. Sets and sub-lists are not supported.
	AsPathMatchMode *string `json:"AsPathMatchMode,omitempty" xml:"AsPathMatchMode,omitempty"`
	// The ID of the routing policy.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// 22
	CenRegionId *string `json:"CenRegionId,omitempty" xml:"CenRegionId,omitempty"`
	// vtb-adfg53c322v****
	CidrMatchMode *string `json:"CidrMatchMode,omitempty" xml:"CidrMatchMode,omitempty"`
	// The description of the routing policy.
	//
	// The description cannot start with `http://` or `https://`. It must start with a letter and can contain letters, digits, hyphens (-), periods (.), and underscores (\_).
	CommunityMatchMode *string `json:"CommunityMatchMode,omitempty" xml:"CommunityMatchMode,omitempty"`
	// The match method that is used to match routes against the AS paths. Valid values:
	//
	// *   **Include**: fuzzy match. A route meets the match condition if the AS path of the route overlaps with the AS paths specified in the match condition.
	// *   **Complete**: exact match. A route is a match only if the AS path of the route is the same as an AS path specified in the match condition.
	CommunityOperateMode *string `json:"CommunityOperateMode,omitempty" xml:"CommunityOperateMode,omitempty"`
	// cn-beijing
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// VPC
	DestinationChildInstanceTypes []*string `json:"DestinationChildInstanceTypes,omitempty" xml:"DestinationChildInstanceTypes,omitempty" type:"Repeated"`
	// The ID of the request.
	DestinationCidrBlocks []*string `json:"DestinationCidrBlocks,omitempty" xml:"DestinationCidrBlocks,omitempty" type:"Repeated"`
	// vtb-acdbvtbr342cd****
	DestinationInstanceIds []*string `json:"DestinationInstanceIds,omitempty" xml:"DestinationInstanceIds,omitempty" type:"Repeated"`
	// System
	DestinationInstanceIdsReverseMatch *bool `json:"DestinationInstanceIdsReverseMatch,omitempty" xml:"DestinationInstanceIdsReverseMatch,omitempty"`
	// The IDs of the destination network instances to which the routes belong. The following network instance types are supported:
	//
	// *   VPC
	// *   VBR
	// *   CCN instance
	// *   SAG instance
	// *   The ID of the IPsec-VPN connection.
	//
	// You can enter at most 32 IDs.
	//
	// > The destination instance IDs take effect only when Direction is set to Export from Regional Gateway and the destination instances are deployed in the current region.
	DestinationRouteTableIds []*string `json:"DestinationRouteTableIds,omitempty" xml:"DestinationRouteTableIds,omitempty" type:"Repeated"`
	// Specifies whether to exclude the destination network instance IDs. Valid values:
	//
	// *   **false** (default value): A route is a match if its destination network instance ID is in the list specified by **DestinationInstanceIds.N**.
	// *   **true**: A route meets the match condition if its destination network instance ID is not in the list specified by **DestinationInstanceIds.N**.
	MapResult *string `json:"MapResult,omitempty" xml:"MapResult,omitempty"`
	// cn-beijing
	MatchAddressType *string `json:"MatchAddressType,omitempty" xml:"MatchAddressType,omitempty"`
	// The ID of the CEN instance.
	MatchAsns []*int32 `json:"MatchAsns,omitempty" xml:"MatchAsns,omitempty" type:"Repeated"`
	// The ID of the routing policy.
	MatchCommunitySet []*string `json:"MatchCommunitySet,omitempty" xml:"MatchCommunitySet,omitempty" type:"Repeated"`
	// 10.10.10.0/24
	NextPriority *int32 `json:"NextPriority,omitempty" xml:"NextPriority,omitempty"`
	// The action to be performed on a route that meets all match conditions. Valid values:
	//
	// *   **Permit**: the route is permitted.
	// *   **Deny**: the route is denied.
	OperateCommunitySet []*string `json:"OperateCommunitySet,omitempty" xml:"OperateCommunitySet,omitempty" type:"Repeated"`
	OwnerAccount        *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId             *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The community against which routes are matched.
	//
	// Specify the community in the format of n:m. Valid values of n and m: **1** to **65535**. Each community must comply with the RFC 1997 standard. The RFC 8092 standard that defines BGP large communities is not supported.
	//
	// You can specify at most 32 communities.
	//
	// **
	//
	// **If the configurations of the communities are incorrect, routes may fail to be advertised to your data center.
	Preference *int32 `json:"Preference,omitempty" xml:"Preference,omitempty"`
	// The match method that is used to match routes against the prefix list. Valid values:
	//
	// *   **Include**: fuzzy match. A route is a match if the route prefix is included in the match conditions.
	//
	// For example, if you set the match condition to 10.10.0.0/16 and fuzzy match is enabled, the route whose prefix is 10.10.1.0/24 is a match.
	//
	// *   **Complete**: exact match. A route is a match only if the route prefix is the same as the prefix specified in the match condition.
	//
	// For example, if you set the match condition to 10.10.0.0/16 and exact match is enabled, a route is a match only if the prefix is 10.10.0.0/16.
	PrependAsPath []*int64 `json:"PrependAsPath,omitempty" xml:"PrependAsPath,omitempty" type:"Repeated"`
	// VPC
	Priority             *int32  `json:"Priority,omitempty" xml:"Priority,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// vpc-avcdsg34ds****
	RouteMapId *string `json:"RouteMapId,omitempty" xml:"RouteMapId,omitempty"`
	// Modifies a routing policy of a Cloud Enterprise Network (CEN) instance.
	RouteTypes []*string `json:"RouteTypes,omitempty" xml:"RouteTypes,omitempty" type:"Repeated"`
	// The AS paths that are prepended by using an action statement when regional gateways receive or advertise routes.
	//
	// The AS paths vary based on the direction in which the routing policy is applied:
	//
	// *   If AS paths are prepended to a routing policy that is applied in the inbound direction, you must specify source network instance IDs and the source region in the match condition. In addition, the source region must be the same as the region where the routing policy is applied.
	// *   If AS paths are prepended to a routing policy that is applied in the outbound direction, you must specify destination network instance IDs in the match condition.
	//
	// This parameter specifies the action to be performed when a route meets the match condition.
	SourceChildInstanceTypes []*string `json:"SourceChildInstanceTypes,omitempty" xml:"SourceChildInstanceTypes,omitempty" type:"Repeated"`
	// 20
	SourceInstanceIds []*string `json:"SourceInstanceIds,omitempty" xml:"SourceInstanceIds,omitempty" type:"Repeated"`
	// The IDs of the destination route tables to which the routes belong. You can enter at most 32 route table IDs.
	//
	// > The destination route table IDs take effect only when Direction is set to Export from Regional Gateway and the destination route tables belong to network instances deployed in the current region.
	SourceInstanceIdsReverseMatch *bool `json:"SourceInstanceIdsReverseMatch,omitempty" xml:"SourceInstanceIdsReverseMatch,omitempty"`
	// The IDs of the source route tables to which the routes belong. You can enter at most 32 route table IDs.
	SourceRegionIds []*string `json:"SourceRegionIds,omitempty" xml:"SourceRegionIds,omitempty" type:"Repeated"`
	// The action that is performed on the community. Valid values:
	//
	// *   **Additive**: adds the community to the route.
	// *   **Replace**: replaces the original community of the route.
	//
	// This parameter specifies the action to be performed when a route meets the match condition.
	SourceRouteTableIds []*string `json:"SourceRouteTableIds,omitempty" xml:"SourceRouteTableIds,omitempty" type:"Repeated"`
}

func (s ModifyCenRouteMapRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyCenRouteMapRequest) GoString() string {
	return s.String()
}

func (s *ModifyCenRouteMapRequest) SetAsPathMatchMode(v string) *ModifyCenRouteMapRequest {
	s.AsPathMatchMode = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetCenId(v string) *ModifyCenRouteMapRequest {
	s.CenId = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetCenRegionId(v string) *ModifyCenRouteMapRequest {
	s.CenRegionId = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetCidrMatchMode(v string) *ModifyCenRouteMapRequest {
	s.CidrMatchMode = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetCommunityMatchMode(v string) *ModifyCenRouteMapRequest {
	s.CommunityMatchMode = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetCommunityOperateMode(v string) *ModifyCenRouteMapRequest {
	s.CommunityOperateMode = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetDescription(v string) *ModifyCenRouteMapRequest {
	s.Description = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetDestinationChildInstanceTypes(v []*string) *ModifyCenRouteMapRequest {
	s.DestinationChildInstanceTypes = v
	return s
}

func (s *ModifyCenRouteMapRequest) SetDestinationCidrBlocks(v []*string) *ModifyCenRouteMapRequest {
	s.DestinationCidrBlocks = v
	return s
}

func (s *ModifyCenRouteMapRequest) SetDestinationInstanceIds(v []*string) *ModifyCenRouteMapRequest {
	s.DestinationInstanceIds = v
	return s
}

func (s *ModifyCenRouteMapRequest) SetDestinationInstanceIdsReverseMatch(v bool) *ModifyCenRouteMapRequest {
	s.DestinationInstanceIdsReverseMatch = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetDestinationRouteTableIds(v []*string) *ModifyCenRouteMapRequest {
	s.DestinationRouteTableIds = v
	return s
}

func (s *ModifyCenRouteMapRequest) SetMapResult(v string) *ModifyCenRouteMapRequest {
	s.MapResult = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetMatchAddressType(v string) *ModifyCenRouteMapRequest {
	s.MatchAddressType = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetMatchAsns(v []*int32) *ModifyCenRouteMapRequest {
	s.MatchAsns = v
	return s
}

func (s *ModifyCenRouteMapRequest) SetMatchCommunitySet(v []*string) *ModifyCenRouteMapRequest {
	s.MatchCommunitySet = v
	return s
}

func (s *ModifyCenRouteMapRequest) SetNextPriority(v int32) *ModifyCenRouteMapRequest {
	s.NextPriority = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetOperateCommunitySet(v []*string) *ModifyCenRouteMapRequest {
	s.OperateCommunitySet = v
	return s
}

func (s *ModifyCenRouteMapRequest) SetOwnerAccount(v string) *ModifyCenRouteMapRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetOwnerId(v int64) *ModifyCenRouteMapRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetPreference(v int32) *ModifyCenRouteMapRequest {
	s.Preference = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetPrependAsPath(v []*int64) *ModifyCenRouteMapRequest {
	s.PrependAsPath = v
	return s
}

func (s *ModifyCenRouteMapRequest) SetPriority(v int32) *ModifyCenRouteMapRequest {
	s.Priority = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetResourceOwnerAccount(v string) *ModifyCenRouteMapRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetResourceOwnerId(v int64) *ModifyCenRouteMapRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetRouteMapId(v string) *ModifyCenRouteMapRequest {
	s.RouteMapId = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetRouteTypes(v []*string) *ModifyCenRouteMapRequest {
	s.RouteTypes = v
	return s
}

func (s *ModifyCenRouteMapRequest) SetSourceChildInstanceTypes(v []*string) *ModifyCenRouteMapRequest {
	s.SourceChildInstanceTypes = v
	return s
}

func (s *ModifyCenRouteMapRequest) SetSourceInstanceIds(v []*string) *ModifyCenRouteMapRequest {
	s.SourceInstanceIds = v
	return s
}

func (s *ModifyCenRouteMapRequest) SetSourceInstanceIdsReverseMatch(v bool) *ModifyCenRouteMapRequest {
	s.SourceInstanceIdsReverseMatch = &v
	return s
}

func (s *ModifyCenRouteMapRequest) SetSourceRegionIds(v []*string) *ModifyCenRouteMapRequest {
	s.SourceRegionIds = v
	return s
}

func (s *ModifyCenRouteMapRequest) SetSourceRouteTableIds(v []*string) *ModifyCenRouteMapRequest {
	s.SourceRouteTableIds = v
	return s
}

type ModifyCenRouteMapResponseBody struct {
	// The action that is performed on the community. Valid values:
	//
	// *   **Additive**: adds the community to the route.
	// *   **Replace**: replaces the original community of the route.
	//
	// This parameter specifies the action to be performed when a route meets the match condition.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyCenRouteMapResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyCenRouteMapResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyCenRouteMapResponseBody) SetRequestId(v string) *ModifyCenRouteMapResponseBody {
	s.RequestId = &v
	return s
}

type ModifyCenRouteMapResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyCenRouteMapResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyCenRouteMapResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyCenRouteMapResponse) GoString() string {
	return s.String()
}

func (s *ModifyCenRouteMapResponse) SetHeaders(v map[string]*string) *ModifyCenRouteMapResponse {
	s.Headers = v
	return s
}

func (s *ModifyCenRouteMapResponse) SetStatusCode(v int32) *ModifyCenRouteMapResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyCenRouteMapResponse) SetBody(v *ModifyCenRouteMapResponseBody) *ModifyCenRouteMapResponse {
	s.Body = v
	return s
}

type ModifyFlowLogAttributeRequest struct {
	CenId                *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	ClientToken          *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Description          *string `json:"Description,omitempty" xml:"Description,omitempty"`
	FlowLogId            *string `json:"FlowLogId,omitempty" xml:"FlowLogId,omitempty"`
	FlowLogName          *string `json:"FlowLogName,omitempty" xml:"FlowLogName,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ModifyFlowLogAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyFlowLogAttributeRequest) GoString() string {
	return s.String()
}

func (s *ModifyFlowLogAttributeRequest) SetCenId(v string) *ModifyFlowLogAttributeRequest {
	s.CenId = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetClientToken(v string) *ModifyFlowLogAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetDescription(v string) *ModifyFlowLogAttributeRequest {
	s.Description = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetFlowLogId(v string) *ModifyFlowLogAttributeRequest {
	s.FlowLogId = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetFlowLogName(v string) *ModifyFlowLogAttributeRequest {
	s.FlowLogName = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetOwnerAccount(v string) *ModifyFlowLogAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetOwnerId(v int64) *ModifyFlowLogAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetRegionId(v string) *ModifyFlowLogAttributeRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetResourceOwnerAccount(v string) *ModifyFlowLogAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyFlowLogAttributeRequest) SetResourceOwnerId(v int64) *ModifyFlowLogAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type ModifyFlowLogAttributeResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyFlowLogAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyFlowLogAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyFlowLogAttributeResponseBody) SetRequestId(v string) *ModifyFlowLogAttributeResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyFlowLogAttributeResponseBody) SetSuccess(v string) *ModifyFlowLogAttributeResponseBody {
	s.Success = &v
	return s
}

type ModifyFlowLogAttributeResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyFlowLogAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyFlowLogAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyFlowLogAttributeResponse) GoString() string {
	return s.String()
}

func (s *ModifyFlowLogAttributeResponse) SetHeaders(v map[string]*string) *ModifyFlowLogAttributeResponse {
	s.Headers = v
	return s
}

func (s *ModifyFlowLogAttributeResponse) SetStatusCode(v int32) *ModifyFlowLogAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyFlowLogAttributeResponse) SetBody(v *ModifyFlowLogAttributeResponseBody) *ModifyFlowLogAttributeResponse {
	s.Body = v
	return s
}

type ModifyTransitRouterCidrRequest struct {
	// The ID of the region where the transit router is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	Cidr *string `json:"Cidr,omitempty" xml:"Cidr,omitempty"`
	// Specifies whether to allow the system to automatically add routes that point to the CIDR block to the route table of the transit router.
	//
	// *   **true**: yes
	//
	//     A value of true specifies that after you create a private VPN connection and enable route learning for the connection, the system automatically adds a blackhole route to the route table of the transit route to which the VPN connection is attached.
	//
	//     The destination CIDR block of the blackhole route is the CIDR block of the transit router. The CIDR block of the transit router refers to the CIDR block from which gateway IP addresses are allocated to IPsec-VPN connections.
	//
	//     The blackhole route is advertised only to the route table of the virtual border router (VBR) that is connected to the transit router.
	//
	// *   **false**: no
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The new CIDR block of the transit router.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the transit router CIDR block.
	//
	// You can call [ListTransitRouterCidr](~~462772~~) to query the ID of a transit route CIDR block.
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The operation that you want to perform. Set the value to **ModifyTransitRouterCidr**.
	PublishCidrRoute *bool `json:"PublishCidrRoute,omitempty" xml:"PublishCidrRoute,omitempty"`
	// The ID of the transit router.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Specifies whether only to precheck the request. Valid values:
	//
	// *   **true**: checks the request but does not modify the CIDR block. The system checks the required parameters, the request format, and the service limits. If the request fails to pass the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false**: sends the request. If the request passes the precheck, the CIDR block of the transit router is modified.
	TransitRouterCidrId *string `json:"TransitRouterCidrId,omitempty" xml:"TransitRouterCidrId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	//
	// >  If you do not set this parameter, ClientToken is set to the value of RequestId. The value of RequestId for each API request may be different.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
}

func (s ModifyTransitRouterCidrRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyTransitRouterCidrRequest) GoString() string {
	return s.String()
}

func (s *ModifyTransitRouterCidrRequest) SetCidr(v string) *ModifyTransitRouterCidrRequest {
	s.Cidr = &v
	return s
}

func (s *ModifyTransitRouterCidrRequest) SetClientToken(v string) *ModifyTransitRouterCidrRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyTransitRouterCidrRequest) SetDescription(v string) *ModifyTransitRouterCidrRequest {
	s.Description = &v
	return s
}

func (s *ModifyTransitRouterCidrRequest) SetDryRun(v bool) *ModifyTransitRouterCidrRequest {
	s.DryRun = &v
	return s
}

func (s *ModifyTransitRouterCidrRequest) SetName(v string) *ModifyTransitRouterCidrRequest {
	s.Name = &v
	return s
}

func (s *ModifyTransitRouterCidrRequest) SetOwnerAccount(v string) *ModifyTransitRouterCidrRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyTransitRouterCidrRequest) SetOwnerId(v int64) *ModifyTransitRouterCidrRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyTransitRouterCidrRequest) SetPublishCidrRoute(v bool) *ModifyTransitRouterCidrRequest {
	s.PublishCidrRoute = &v
	return s
}

func (s *ModifyTransitRouterCidrRequest) SetRegionId(v string) *ModifyTransitRouterCidrRequest {
	s.RegionId = &v
	return s
}

func (s *ModifyTransitRouterCidrRequest) SetResourceOwnerAccount(v string) *ModifyTransitRouterCidrRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyTransitRouterCidrRequest) SetResourceOwnerId(v int64) *ModifyTransitRouterCidrRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyTransitRouterCidrRequest) SetTransitRouterCidrId(v string) *ModifyTransitRouterCidrRequest {
	s.TransitRouterCidrId = &v
	return s
}

func (s *ModifyTransitRouterCidrRequest) SetTransitRouterId(v string) *ModifyTransitRouterCidrRequest {
	s.TransitRouterId = &v
	return s
}

type ModifyTransitRouterCidrResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyTransitRouterCidrResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyTransitRouterCidrResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyTransitRouterCidrResponseBody) SetRequestId(v string) *ModifyTransitRouterCidrResponseBody {
	s.RequestId = &v
	return s
}

type ModifyTransitRouterCidrResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyTransitRouterCidrResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyTransitRouterCidrResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyTransitRouterCidrResponse) GoString() string {
	return s.String()
}

func (s *ModifyTransitRouterCidrResponse) SetHeaders(v map[string]*string) *ModifyTransitRouterCidrResponse {
	s.Headers = v
	return s
}

func (s *ModifyTransitRouterCidrResponse) SetStatusCode(v int32) *ModifyTransitRouterCidrResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyTransitRouterCidrResponse) SetBody(v *ModifyTransitRouterCidrResponseBody) *ModifyTransitRouterCidrResponse {
	s.Body = v
	return s
}

type ModifyTransitRouterMulticastDomainRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether only to precheck the request. Valid values:
	//
	// *   **true**: prechecks the request but does not modify the name or description of the multicast domain. The system checks the required parameters, the request format, and the service limits. If the request fails the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. If the request passes the precheck, the name and description of the multicast domain are modified.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The new description of the multicast domain.
	//
	// The description must be 0 to 256 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (\_), and hyphens (-).
	TransitRouterMulticastDomainDescription *string `json:"TransitRouterMulticastDomainDescription,omitempty" xml:"TransitRouterMulticastDomainDescription,omitempty"`
	// The ID of the multicast domain.
	TransitRouterMulticastDomainId *string `json:"TransitRouterMulticastDomainId,omitempty" xml:"TransitRouterMulticastDomainId,omitempty"`
	// The new name of the multicast domain.
	//
	// The name must be 0 to 128 characters in length, and can contain letters, digits, commas (,), periods (.), semicolons (;), forward slashes (/), at signs (@), underscores (\_), and hyphens (-).
	TransitRouterMulticastDomainName *string `json:"TransitRouterMulticastDomainName,omitempty" xml:"TransitRouterMulticastDomainName,omitempty"`
}

func (s ModifyTransitRouterMulticastDomainRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyTransitRouterMulticastDomainRequest) GoString() string {
	return s.String()
}

func (s *ModifyTransitRouterMulticastDomainRequest) SetClientToken(v string) *ModifyTransitRouterMulticastDomainRequest {
	s.ClientToken = &v
	return s
}

func (s *ModifyTransitRouterMulticastDomainRequest) SetDryRun(v bool) *ModifyTransitRouterMulticastDomainRequest {
	s.DryRun = &v
	return s
}

func (s *ModifyTransitRouterMulticastDomainRequest) SetOwnerAccount(v string) *ModifyTransitRouterMulticastDomainRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ModifyTransitRouterMulticastDomainRequest) SetOwnerId(v int64) *ModifyTransitRouterMulticastDomainRequest {
	s.OwnerId = &v
	return s
}

func (s *ModifyTransitRouterMulticastDomainRequest) SetResourceOwnerAccount(v string) *ModifyTransitRouterMulticastDomainRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ModifyTransitRouterMulticastDomainRequest) SetResourceOwnerId(v int64) *ModifyTransitRouterMulticastDomainRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ModifyTransitRouterMulticastDomainRequest) SetTransitRouterMulticastDomainDescription(v string) *ModifyTransitRouterMulticastDomainRequest {
	s.TransitRouterMulticastDomainDescription = &v
	return s
}

func (s *ModifyTransitRouterMulticastDomainRequest) SetTransitRouterMulticastDomainId(v string) *ModifyTransitRouterMulticastDomainRequest {
	s.TransitRouterMulticastDomainId = &v
	return s
}

func (s *ModifyTransitRouterMulticastDomainRequest) SetTransitRouterMulticastDomainName(v string) *ModifyTransitRouterMulticastDomainRequest {
	s.TransitRouterMulticastDomainName = &v
	return s
}

type ModifyTransitRouterMulticastDomainResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ModifyTransitRouterMulticastDomainResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyTransitRouterMulticastDomainResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyTransitRouterMulticastDomainResponseBody) SetRequestId(v string) *ModifyTransitRouterMulticastDomainResponseBody {
	s.RequestId = &v
	return s
}

type ModifyTransitRouterMulticastDomainResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyTransitRouterMulticastDomainResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyTransitRouterMulticastDomainResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyTransitRouterMulticastDomainResponse) GoString() string {
	return s.String()
}

func (s *ModifyTransitRouterMulticastDomainResponse) SetHeaders(v map[string]*string) *ModifyTransitRouterMulticastDomainResponse {
	s.Headers = v
	return s
}

func (s *ModifyTransitRouterMulticastDomainResponse) SetStatusCode(v int32) *ModifyTransitRouterMulticastDomainResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyTransitRouterMulticastDomainResponse) SetBody(v *ModifyTransitRouterMulticastDomainResponseBody) *ModifyTransitRouterMulticastDomainResponse {
	s.Body = v
	return s
}

type MoveResourceGroupRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false:**: performs a dry run and sends the request.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The ID of the resource group to which you want to move the CEN instance or bandwidth plan.
	NewResourceGroupId *string `json:"NewResourceGroupId,omitempty" xml:"NewResourceGroupId,omitempty"`
	OwnerAccount       *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId            *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the resource.
	ResourceId           *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The type of the resource. Valid values:
	//
	// *   **CEN**: CEN instance
	// *   **bandwidthpackage**: bandwidth plan
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s MoveResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupRequest) SetClientToken(v string) *MoveResourceGroupRequest {
	s.ClientToken = &v
	return s
}

func (s *MoveResourceGroupRequest) SetDryRun(v bool) *MoveResourceGroupRequest {
	s.DryRun = &v
	return s
}

func (s *MoveResourceGroupRequest) SetNewResourceGroupId(v string) *MoveResourceGroupRequest {
	s.NewResourceGroupId = &v
	return s
}

func (s *MoveResourceGroupRequest) SetOwnerAccount(v string) *MoveResourceGroupRequest {
	s.OwnerAccount = &v
	return s
}

func (s *MoveResourceGroupRequest) SetOwnerId(v int64) *MoveResourceGroupRequest {
	s.OwnerId = &v
	return s
}

func (s *MoveResourceGroupRequest) SetResourceId(v string) *MoveResourceGroupRequest {
	s.ResourceId = &v
	return s
}

func (s *MoveResourceGroupRequest) SetResourceOwnerAccount(v string) *MoveResourceGroupRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *MoveResourceGroupRequest) SetResourceOwnerId(v int64) *MoveResourceGroupRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *MoveResourceGroupRequest) SetResourceType(v string) *MoveResourceGroupRequest {
	s.ResourceType = &v
	return s
}

type MoveResourceGroupResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s MoveResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupResponseBody) SetRequestId(v string) *MoveResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

type MoveResourceGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *MoveResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s MoveResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s MoveResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *MoveResourceGroupResponse) SetHeaders(v map[string]*string) *MoveResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *MoveResourceGroupResponse) SetStatusCode(v int32) *MoveResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *MoveResourceGroupResponse) SetBody(v *MoveResourceGroupResponseBody) *MoveResourceGroupResponse {
	s.Body = v
	return s
}

type OpenTransitRouterServiceRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The client token can contain only ASCII characters.
	ClientToken          *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s OpenTransitRouterServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s OpenTransitRouterServiceRequest) GoString() string {
	return s.String()
}

func (s *OpenTransitRouterServiceRequest) SetClientToken(v string) *OpenTransitRouterServiceRequest {
	s.ClientToken = &v
	return s
}

func (s *OpenTransitRouterServiceRequest) SetOwnerAccount(v string) *OpenTransitRouterServiceRequest {
	s.OwnerAccount = &v
	return s
}

func (s *OpenTransitRouterServiceRequest) SetOwnerId(v int64) *OpenTransitRouterServiceRequest {
	s.OwnerId = &v
	return s
}

func (s *OpenTransitRouterServiceRequest) SetResourceOwnerAccount(v string) *OpenTransitRouterServiceRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *OpenTransitRouterServiceRequest) SetResourceOwnerId(v int64) *OpenTransitRouterServiceRequest {
	s.ResourceOwnerId = &v
	return s
}

type OpenTransitRouterServiceResponseBody struct {
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s OpenTransitRouterServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OpenTransitRouterServiceResponseBody) GoString() string {
	return s.String()
}

func (s *OpenTransitRouterServiceResponseBody) SetOrderId(v string) *OpenTransitRouterServiceResponseBody {
	s.OrderId = &v
	return s
}

func (s *OpenTransitRouterServiceResponseBody) SetRequestId(v string) *OpenTransitRouterServiceResponseBody {
	s.RequestId = &v
	return s
}

type OpenTransitRouterServiceResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OpenTransitRouterServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OpenTransitRouterServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s OpenTransitRouterServiceResponse) GoString() string {
	return s.String()
}

func (s *OpenTransitRouterServiceResponse) SetHeaders(v map[string]*string) *OpenTransitRouterServiceResponse {
	s.Headers = v
	return s
}

func (s *OpenTransitRouterServiceResponse) SetStatusCode(v int32) *OpenTransitRouterServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *OpenTransitRouterServiceResponse) SetBody(v *OpenTransitRouterServiceResponseBody) *OpenTransitRouterServiceResponse {
	s.Body = v
	return s
}

type PublishRouteEntriesRequest struct {
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the network instance.
	ChildInstanceId *string `json:"ChildInstanceId,omitempty" xml:"ChildInstanceId,omitempty"`
	// The ID of the region where the network instance is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	ChildInstanceRegionId *string `json:"ChildInstanceRegionId,omitempty" xml:"ChildInstanceRegionId,omitempty"`
	// The ID of the route table configured on the network instance.
	ChildInstanceRouteTableId *string `json:"ChildInstanceRouteTableId,omitempty" xml:"ChildInstanceRouteTableId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: VPC
	// *   **VBR**: VBR
	ChildInstanceType *string `json:"ChildInstanceType,omitempty" xml:"ChildInstanceType,omitempty"`
	// The destination CIDR block of the route that you want to advertise.
	DestinationCidrBlock *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s PublishRouteEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s PublishRouteEntriesRequest) GoString() string {
	return s.String()
}

func (s *PublishRouteEntriesRequest) SetCenId(v string) *PublishRouteEntriesRequest {
	s.CenId = &v
	return s
}

func (s *PublishRouteEntriesRequest) SetChildInstanceId(v string) *PublishRouteEntriesRequest {
	s.ChildInstanceId = &v
	return s
}

func (s *PublishRouteEntriesRequest) SetChildInstanceRegionId(v string) *PublishRouteEntriesRequest {
	s.ChildInstanceRegionId = &v
	return s
}

func (s *PublishRouteEntriesRequest) SetChildInstanceRouteTableId(v string) *PublishRouteEntriesRequest {
	s.ChildInstanceRouteTableId = &v
	return s
}

func (s *PublishRouteEntriesRequest) SetChildInstanceType(v string) *PublishRouteEntriesRequest {
	s.ChildInstanceType = &v
	return s
}

func (s *PublishRouteEntriesRequest) SetDestinationCidrBlock(v string) *PublishRouteEntriesRequest {
	s.DestinationCidrBlock = &v
	return s
}

func (s *PublishRouteEntriesRequest) SetResourceOwnerAccount(v string) *PublishRouteEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *PublishRouteEntriesRequest) SetResourceOwnerId(v int64) *PublishRouteEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

type PublishRouteEntriesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s PublishRouteEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PublishRouteEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *PublishRouteEntriesResponseBody) SetRequestId(v string) *PublishRouteEntriesResponseBody {
	s.RequestId = &v
	return s
}

type PublishRouteEntriesResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PublishRouteEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PublishRouteEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s PublishRouteEntriesResponse) GoString() string {
	return s.String()
}

func (s *PublishRouteEntriesResponse) SetHeaders(v map[string]*string) *PublishRouteEntriesResponse {
	s.Headers = v
	return s
}

func (s *PublishRouteEntriesResponse) SetStatusCode(v int32) *PublishRouteEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *PublishRouteEntriesResponse) SetBody(v *PublishRouteEntriesResponseBody) *PublishRouteEntriesResponse {
	s.Body = v
	return s
}

type RefreshTransitRouteTableAggregationRequest struct {
	ClientToken                      *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	OwnerAccount                     *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                          *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount             *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId                  *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TransitRouteTableAggregationCidr *string `json:"TransitRouteTableAggregationCidr,omitempty" xml:"TransitRouteTableAggregationCidr,omitempty"`
	TransitRouteTableId              *string `json:"TransitRouteTableId,omitempty" xml:"TransitRouteTableId,omitempty"`
}

func (s RefreshTransitRouteTableAggregationRequest) String() string {
	return tea.Prettify(s)
}

func (s RefreshTransitRouteTableAggregationRequest) GoString() string {
	return s.String()
}

func (s *RefreshTransitRouteTableAggregationRequest) SetClientToken(v string) *RefreshTransitRouteTableAggregationRequest {
	s.ClientToken = &v
	return s
}

func (s *RefreshTransitRouteTableAggregationRequest) SetOwnerAccount(v string) *RefreshTransitRouteTableAggregationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RefreshTransitRouteTableAggregationRequest) SetOwnerId(v int64) *RefreshTransitRouteTableAggregationRequest {
	s.OwnerId = &v
	return s
}

func (s *RefreshTransitRouteTableAggregationRequest) SetResourceOwnerAccount(v string) *RefreshTransitRouteTableAggregationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RefreshTransitRouteTableAggregationRequest) SetResourceOwnerId(v int64) *RefreshTransitRouteTableAggregationRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RefreshTransitRouteTableAggregationRequest) SetTransitRouteTableAggregationCidr(v string) *RefreshTransitRouteTableAggregationRequest {
	s.TransitRouteTableAggregationCidr = &v
	return s
}

func (s *RefreshTransitRouteTableAggregationRequest) SetTransitRouteTableId(v string) *RefreshTransitRouteTableAggregationRequest {
	s.TransitRouteTableId = &v
	return s
}

type RefreshTransitRouteTableAggregationResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RefreshTransitRouteTableAggregationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RefreshTransitRouteTableAggregationResponseBody) GoString() string {
	return s.String()
}

func (s *RefreshTransitRouteTableAggregationResponseBody) SetRequestId(v string) *RefreshTransitRouteTableAggregationResponseBody {
	s.RequestId = &v
	return s
}

type RefreshTransitRouteTableAggregationResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RefreshTransitRouteTableAggregationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RefreshTransitRouteTableAggregationResponse) String() string {
	return tea.Prettify(s)
}

func (s RefreshTransitRouteTableAggregationResponse) GoString() string {
	return s.String()
}

func (s *RefreshTransitRouteTableAggregationResponse) SetHeaders(v map[string]*string) *RefreshTransitRouteTableAggregationResponse {
	s.Headers = v
	return s
}

func (s *RefreshTransitRouteTableAggregationResponse) SetStatusCode(v int32) *RefreshTransitRouteTableAggregationResponse {
	s.StatusCode = &v
	return s
}

func (s *RefreshTransitRouteTableAggregationResponse) SetBody(v *RefreshTransitRouteTableAggregationResponseBody) *RefreshTransitRouteTableAggregationResponse {
	s.Body = v
	return s
}

type RegisterTransitRouterMulticastGroupMembersRequest struct {
	ClientToken                       *string   `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun                            *bool     `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	GroupIpAddress                    *string   `json:"GroupIpAddress,omitempty" xml:"GroupIpAddress,omitempty"`
	NetworkInterfaceIds               []*string `json:"NetworkInterfaceIds,omitempty" xml:"NetworkInterfaceIds,omitempty" type:"Repeated"`
	OwnerAccount                      *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                           *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	PeerTransitRouterMulticastDomains []*string `json:"PeerTransitRouterMulticastDomains,omitempty" xml:"PeerTransitRouterMulticastDomains,omitempty" type:"Repeated"`
	ResourceOwnerAccount              *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId                   *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TransitRouterMulticastDomainId    *string   `json:"TransitRouterMulticastDomainId,omitempty" xml:"TransitRouterMulticastDomainId,omitempty"`
	VpcId                             *string   `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s RegisterTransitRouterMulticastGroupMembersRequest) String() string {
	return tea.Prettify(s)
}

func (s RegisterTransitRouterMulticastGroupMembersRequest) GoString() string {
	return s.String()
}

func (s *RegisterTransitRouterMulticastGroupMembersRequest) SetClientToken(v string) *RegisterTransitRouterMulticastGroupMembersRequest {
	s.ClientToken = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupMembersRequest) SetDryRun(v bool) *RegisterTransitRouterMulticastGroupMembersRequest {
	s.DryRun = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupMembersRequest) SetGroupIpAddress(v string) *RegisterTransitRouterMulticastGroupMembersRequest {
	s.GroupIpAddress = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupMembersRequest) SetNetworkInterfaceIds(v []*string) *RegisterTransitRouterMulticastGroupMembersRequest {
	s.NetworkInterfaceIds = v
	return s
}

func (s *RegisterTransitRouterMulticastGroupMembersRequest) SetOwnerAccount(v string) *RegisterTransitRouterMulticastGroupMembersRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupMembersRequest) SetOwnerId(v int64) *RegisterTransitRouterMulticastGroupMembersRequest {
	s.OwnerId = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupMembersRequest) SetPeerTransitRouterMulticastDomains(v []*string) *RegisterTransitRouterMulticastGroupMembersRequest {
	s.PeerTransitRouterMulticastDomains = v
	return s
}

func (s *RegisterTransitRouterMulticastGroupMembersRequest) SetResourceOwnerAccount(v string) *RegisterTransitRouterMulticastGroupMembersRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupMembersRequest) SetResourceOwnerId(v int64) *RegisterTransitRouterMulticastGroupMembersRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupMembersRequest) SetTransitRouterMulticastDomainId(v string) *RegisterTransitRouterMulticastGroupMembersRequest {
	s.TransitRouterMulticastDomainId = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupMembersRequest) SetVpcId(v string) *RegisterTransitRouterMulticastGroupMembersRequest {
	s.VpcId = &v
	return s
}

type RegisterTransitRouterMulticastGroupMembersResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RegisterTransitRouterMulticastGroupMembersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RegisterTransitRouterMulticastGroupMembersResponseBody) GoString() string {
	return s.String()
}

func (s *RegisterTransitRouterMulticastGroupMembersResponseBody) SetRequestId(v string) *RegisterTransitRouterMulticastGroupMembersResponseBody {
	s.RequestId = &v
	return s
}

type RegisterTransitRouterMulticastGroupMembersResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RegisterTransitRouterMulticastGroupMembersResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RegisterTransitRouterMulticastGroupMembersResponse) String() string {
	return tea.Prettify(s)
}

func (s RegisterTransitRouterMulticastGroupMembersResponse) GoString() string {
	return s.String()
}

func (s *RegisterTransitRouterMulticastGroupMembersResponse) SetHeaders(v map[string]*string) *RegisterTransitRouterMulticastGroupMembersResponse {
	s.Headers = v
	return s
}

func (s *RegisterTransitRouterMulticastGroupMembersResponse) SetStatusCode(v int32) *RegisterTransitRouterMulticastGroupMembersResponse {
	s.StatusCode = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupMembersResponse) SetBody(v *RegisterTransitRouterMulticastGroupMembersResponseBody) *RegisterTransitRouterMulticastGroupMembersResponse {
	s.Body = v
	return s
}

type RegisterTransitRouterMulticastGroupSourcesRequest struct {
	// Specifies whether only to check the request. Valid values:
	//
	// *   **true**: prechecks the request but does not create the multicast source. The system checks the required parameters, the request format, and the service limits. If the request fails to pass the precheck, an error message is returned. If the request passes the precheck, the `DryRunOperation` error code is returned.
	// *   **false** (default): sends the request. After the request passes the precheck, the multicast source is created.
	ClientToken          *string   `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun               *bool     `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	GroupIpAddress       *string   `json:"GroupIpAddress,omitempty" xml:"GroupIpAddress,omitempty"`
	NetworkInterfaceIds  []*string `json:"NetworkInterfaceIds,omitempty" xml:"NetworkInterfaceIds,omitempty" type:"Repeated"`
	OwnerAccount         *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// Creates a multicast source.
	TransitRouterMulticastDomainId *string `json:"TransitRouterMulticastDomainId,omitempty" xml:"TransitRouterMulticastDomainId,omitempty"`
	VpcId                          *string `json:"VpcId,omitempty" xml:"VpcId,omitempty"`
}

func (s RegisterTransitRouterMulticastGroupSourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s RegisterTransitRouterMulticastGroupSourcesRequest) GoString() string {
	return s.String()
}

func (s *RegisterTransitRouterMulticastGroupSourcesRequest) SetClientToken(v string) *RegisterTransitRouterMulticastGroupSourcesRequest {
	s.ClientToken = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupSourcesRequest) SetDryRun(v bool) *RegisterTransitRouterMulticastGroupSourcesRequest {
	s.DryRun = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupSourcesRequest) SetGroupIpAddress(v string) *RegisterTransitRouterMulticastGroupSourcesRequest {
	s.GroupIpAddress = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupSourcesRequest) SetNetworkInterfaceIds(v []*string) *RegisterTransitRouterMulticastGroupSourcesRequest {
	s.NetworkInterfaceIds = v
	return s
}

func (s *RegisterTransitRouterMulticastGroupSourcesRequest) SetOwnerAccount(v string) *RegisterTransitRouterMulticastGroupSourcesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupSourcesRequest) SetOwnerId(v int64) *RegisterTransitRouterMulticastGroupSourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupSourcesRequest) SetResourceOwnerAccount(v string) *RegisterTransitRouterMulticastGroupSourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupSourcesRequest) SetResourceOwnerId(v int64) *RegisterTransitRouterMulticastGroupSourcesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupSourcesRequest) SetTransitRouterMulticastDomainId(v string) *RegisterTransitRouterMulticastGroupSourcesRequest {
	s.TransitRouterMulticastDomainId = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupSourcesRequest) SetVpcId(v string) *RegisterTransitRouterMulticastGroupSourcesRequest {
	s.VpcId = &v
	return s
}

type RegisterTransitRouterMulticastGroupSourcesResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RegisterTransitRouterMulticastGroupSourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RegisterTransitRouterMulticastGroupSourcesResponseBody) GoString() string {
	return s.String()
}

func (s *RegisterTransitRouterMulticastGroupSourcesResponseBody) SetRequestId(v string) *RegisterTransitRouterMulticastGroupSourcesResponseBody {
	s.RequestId = &v
	return s
}

type RegisterTransitRouterMulticastGroupSourcesResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RegisterTransitRouterMulticastGroupSourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RegisterTransitRouterMulticastGroupSourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s RegisterTransitRouterMulticastGroupSourcesResponse) GoString() string {
	return s.String()
}

func (s *RegisterTransitRouterMulticastGroupSourcesResponse) SetHeaders(v map[string]*string) *RegisterTransitRouterMulticastGroupSourcesResponse {
	s.Headers = v
	return s
}

func (s *RegisterTransitRouterMulticastGroupSourcesResponse) SetStatusCode(v int32) *RegisterTransitRouterMulticastGroupSourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *RegisterTransitRouterMulticastGroupSourcesResponse) SetBody(v *RegisterTransitRouterMulticastGroupSourcesResponseBody) *RegisterTransitRouterMulticastGroupSourcesResponse {
	s.Body = v
	return s
}

type RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest struct {
	ClientToken            *string   `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun                 *bool     `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount           *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount   *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId        *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TrafficMarkRuleIds     []*string `json:"TrafficMarkRuleIds,omitempty" xml:"TrafficMarkRuleIds,omitempty" type:"Repeated"`
	TrafficMarkingPolicyId *string   `json:"TrafficMarkingPolicyId,omitempty" xml:"TrafficMarkingPolicyId,omitempty"`
}

func (s RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest) GoString() string {
	return s.String()
}

func (s *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest) SetClientToken(v string) *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest {
	s.ClientToken = &v
	return s
}

func (s *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest) SetDryRun(v bool) *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest {
	s.DryRun = &v
	return s
}

func (s *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest) SetOwnerAccount(v string) *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest) SetOwnerId(v int64) *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest) SetResourceOwnerAccount(v string) *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest) SetResourceOwnerId(v int64) *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest) SetTrafficMarkRuleIds(v []*string) *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest {
	s.TrafficMarkRuleIds = v
	return s
}

func (s *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest) SetTrafficMarkingPolicyId(v string) *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest {
	s.TrafficMarkingPolicyId = &v
	return s
}

type RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponseBody) SetRequestId(v string) *RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponseBody {
	s.RequestId = &v
	return s
}

type RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponse struct {
	Headers    map[string]*string                                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponse) GoString() string {
	return s.String()
}

func (s *RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponse) SetHeaders(v map[string]*string) *RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponse {
	s.Headers = v
	return s
}

func (s *RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponse) SetStatusCode(v int32) *RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponse) SetBody(v *RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponseBody) *RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponse {
	s.Body = v
	return s
}

type RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest struct {
	// The ID of the request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The operation that you want to perform. Set the value to **RemoveTraficMatchRuleFromTrafficMarkingPolicy**.
	DryRun               *bool     `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TrafficMarkRuleIds   []*string `json:"TrafficMarkRuleIds,omitempty" xml:"TrafficMarkRuleIds,omitempty" type:"Repeated"`
	// Deletes specified traffic classification rules from a traffic marking policy.
	TrafficMarkingPolicyId *string `json:"TrafficMarkingPolicyId,omitempty" xml:"TrafficMarkingPolicyId,omitempty"`
}

func (s RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest) GoString() string {
	return s.String()
}

func (s *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest) SetClientToken(v string) *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest {
	s.ClientToken = &v
	return s
}

func (s *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest) SetDryRun(v bool) *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest {
	s.DryRun = &v
	return s
}

func (s *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest) SetOwnerAccount(v string) *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest) SetOwnerId(v int64) *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest {
	s.OwnerId = &v
	return s
}

func (s *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest) SetResourceOwnerAccount(v string) *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest) SetResourceOwnerId(v int64) *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest) SetTrafficMarkRuleIds(v []*string) *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest {
	s.TrafficMarkRuleIds = v
	return s
}

func (s *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest) SetTrafficMarkingPolicyId(v string) *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest {
	s.TrafficMarkingPolicyId = &v
	return s
}

type RemoveTraficMatchRuleFromTrafficMarkingPolicyResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveTraficMatchRuleFromTrafficMarkingPolicyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveTraficMatchRuleFromTrafficMarkingPolicyResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveTraficMatchRuleFromTrafficMarkingPolicyResponseBody) SetRequestId(v string) *RemoveTraficMatchRuleFromTrafficMarkingPolicyResponseBody {
	s.RequestId = &v
	return s
}

type RemoveTraficMatchRuleFromTrafficMarkingPolicyResponse struct {
	Headers    map[string]*string                                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveTraficMatchRuleFromTrafficMarkingPolicyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveTraficMatchRuleFromTrafficMarkingPolicyResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveTraficMatchRuleFromTrafficMarkingPolicyResponse) GoString() string {
	return s.String()
}

func (s *RemoveTraficMatchRuleFromTrafficMarkingPolicyResponse) SetHeaders(v map[string]*string) *RemoveTraficMatchRuleFromTrafficMarkingPolicyResponse {
	s.Headers = v
	return s
}

func (s *RemoveTraficMatchRuleFromTrafficMarkingPolicyResponse) SetStatusCode(v int32) *RemoveTraficMatchRuleFromTrafficMarkingPolicyResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveTraficMatchRuleFromTrafficMarkingPolicyResponse) SetBody(v *RemoveTraficMatchRuleFromTrafficMarkingPolicyResponseBody) *RemoveTraficMatchRuleFromTrafficMarkingPolicyResponse {
	s.Body = v
	return s
}

type ReplaceTransitRouterRouteTableAssociationRequest struct {
	ClientToken               *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun                    *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount              *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                   *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount      *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId           *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	TransitRouterRouteTableId *string `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
}

func (s ReplaceTransitRouterRouteTableAssociationRequest) String() string {
	return tea.Prettify(s)
}

func (s ReplaceTransitRouterRouteTableAssociationRequest) GoString() string {
	return s.String()
}

func (s *ReplaceTransitRouterRouteTableAssociationRequest) SetClientToken(v string) *ReplaceTransitRouterRouteTableAssociationRequest {
	s.ClientToken = &v
	return s
}

func (s *ReplaceTransitRouterRouteTableAssociationRequest) SetDryRun(v bool) *ReplaceTransitRouterRouteTableAssociationRequest {
	s.DryRun = &v
	return s
}

func (s *ReplaceTransitRouterRouteTableAssociationRequest) SetOwnerAccount(v string) *ReplaceTransitRouterRouteTableAssociationRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ReplaceTransitRouterRouteTableAssociationRequest) SetOwnerId(v int64) *ReplaceTransitRouterRouteTableAssociationRequest {
	s.OwnerId = &v
	return s
}

func (s *ReplaceTransitRouterRouteTableAssociationRequest) SetResourceOwnerAccount(v string) *ReplaceTransitRouterRouteTableAssociationRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ReplaceTransitRouterRouteTableAssociationRequest) SetResourceOwnerId(v int64) *ReplaceTransitRouterRouteTableAssociationRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *ReplaceTransitRouterRouteTableAssociationRequest) SetTransitRouterAttachmentId(v string) *ReplaceTransitRouterRouteTableAssociationRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *ReplaceTransitRouterRouteTableAssociationRequest) SetTransitRouterRouteTableId(v string) *ReplaceTransitRouterRouteTableAssociationRequest {
	s.TransitRouterRouteTableId = &v
	return s
}

type ReplaceTransitRouterRouteTableAssociationResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ReplaceTransitRouterRouteTableAssociationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReplaceTransitRouterRouteTableAssociationResponseBody) GoString() string {
	return s.String()
}

func (s *ReplaceTransitRouterRouteTableAssociationResponseBody) SetRequestId(v string) *ReplaceTransitRouterRouteTableAssociationResponseBody {
	s.RequestId = &v
	return s
}

type ReplaceTransitRouterRouteTableAssociationResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReplaceTransitRouterRouteTableAssociationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReplaceTransitRouterRouteTableAssociationResponse) String() string {
	return tea.Prettify(s)
}

func (s ReplaceTransitRouterRouteTableAssociationResponse) GoString() string {
	return s.String()
}

func (s *ReplaceTransitRouterRouteTableAssociationResponse) SetHeaders(v map[string]*string) *ReplaceTransitRouterRouteTableAssociationResponse {
	s.Headers = v
	return s
}

func (s *ReplaceTransitRouterRouteTableAssociationResponse) SetStatusCode(v int32) *ReplaceTransitRouterRouteTableAssociationResponse {
	s.StatusCode = &v
	return s
}

func (s *ReplaceTransitRouterRouteTableAssociationResponse) SetBody(v *ReplaceTransitRouterRouteTableAssociationResponseBody) *ReplaceTransitRouterRouteTableAssociationResponse {
	s.Body = v
	return s
}

type ResolveAndRouteServiceInCenRequest struct {
	// The ID of the region in which the cloud service that you want to access is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	AccessRegionIds []*string `json:"AccessRegionIds,omitempty" xml:"AccessRegionIds,omitempty" type:"Repeated"`
	// The ID of the CEN instance.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The description of the cloud service.
	//
	// The description can be empty or 2 to 256 characters in length. It must start with a letter, and can contain digits, hyphens (-), periods (.), and underscores (\_). It cannot start with `http://` or `https://`.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The IP addresses or CIDR blocks of the cloud service.
	//
	// > In most cases, multiple IP addresses or CIDR blocks are assigned to a cloud service. We recommend that you call this operation multiple times to add all IP addresses and CIDR blocks of the cloud service.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The ID of the region in which the cloud service is deployed.
	HostRegionId *string `json:"HostRegionId,omitempty" xml:"HostRegionId,omitempty"`
	// The ID of the VPC that is associated with the cloud service.
	HostVpcId            *string `json:"HostVpcId,omitempty" xml:"HostVpcId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s ResolveAndRouteServiceInCenRequest) String() string {
	return tea.Prettify(s)
}

func (s ResolveAndRouteServiceInCenRequest) GoString() string {
	return s.String()
}

func (s *ResolveAndRouteServiceInCenRequest) SetAccessRegionIds(v []*string) *ResolveAndRouteServiceInCenRequest {
	s.AccessRegionIds = v
	return s
}

func (s *ResolveAndRouteServiceInCenRequest) SetCenId(v string) *ResolveAndRouteServiceInCenRequest {
	s.CenId = &v
	return s
}

func (s *ResolveAndRouteServiceInCenRequest) SetClientToken(v string) *ResolveAndRouteServiceInCenRequest {
	s.ClientToken = &v
	return s
}

func (s *ResolveAndRouteServiceInCenRequest) SetDescription(v string) *ResolveAndRouteServiceInCenRequest {
	s.Description = &v
	return s
}

func (s *ResolveAndRouteServiceInCenRequest) SetHost(v string) *ResolveAndRouteServiceInCenRequest {
	s.Host = &v
	return s
}

func (s *ResolveAndRouteServiceInCenRequest) SetHostRegionId(v string) *ResolveAndRouteServiceInCenRequest {
	s.HostRegionId = &v
	return s
}

func (s *ResolveAndRouteServiceInCenRequest) SetHostVpcId(v string) *ResolveAndRouteServiceInCenRequest {
	s.HostVpcId = &v
	return s
}

func (s *ResolveAndRouteServiceInCenRequest) SetOwnerAccount(v string) *ResolveAndRouteServiceInCenRequest {
	s.OwnerAccount = &v
	return s
}

func (s *ResolveAndRouteServiceInCenRequest) SetOwnerId(v int64) *ResolveAndRouteServiceInCenRequest {
	s.OwnerId = &v
	return s
}

func (s *ResolveAndRouteServiceInCenRequest) SetResourceOwnerAccount(v string) *ResolveAndRouteServiceInCenRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *ResolveAndRouteServiceInCenRequest) SetResourceOwnerId(v int64) *ResolveAndRouteServiceInCenRequest {
	s.ResourceOwnerId = &v
	return s
}

type ResolveAndRouteServiceInCenResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ResolveAndRouteServiceInCenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResolveAndRouteServiceInCenResponseBody) GoString() string {
	return s.String()
}

func (s *ResolveAndRouteServiceInCenResponseBody) SetRequestId(v string) *ResolveAndRouteServiceInCenResponseBody {
	s.RequestId = &v
	return s
}

type ResolveAndRouteServiceInCenResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ResolveAndRouteServiceInCenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ResolveAndRouteServiceInCenResponse) String() string {
	return tea.Prettify(s)
}

func (s ResolveAndRouteServiceInCenResponse) GoString() string {
	return s.String()
}

func (s *ResolveAndRouteServiceInCenResponse) SetHeaders(v map[string]*string) *ResolveAndRouteServiceInCenResponse {
	s.Headers = v
	return s
}

func (s *ResolveAndRouteServiceInCenResponse) SetStatusCode(v int32) *ResolveAndRouteServiceInCenResponse {
	s.StatusCode = &v
	return s
}

func (s *ResolveAndRouteServiceInCenResponse) SetBody(v *ResolveAndRouteServiceInCenResponseBody) *ResolveAndRouteServiceInCenResponse {
	s.Body = v
	return s
}

type RevokeInstanceFromTransitRouterRequest struct {
	// Enter the ID of the Cloud Enterprise Network (CEN) instance to which the transit router belongs.
	CenId *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	// The ID of the Alibaba Cloud account to which the CEN instance belongs.
	CenOwnerId *int64 `json:"CenOwnerId,omitempty" xml:"CenOwnerId,omitempty"`
	// The ID of the network instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The type of the network instance. Valid values:
	//
	// *   **VPC**: VPC
	// *   **ExpressConnect**: VBR
	// *   **VPN**: IPsec-VPN connection
	InstanceType *string `json:"InstanceType,omitempty" xml:"InstanceType,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the region where the network instance is deployed.
	//
	// You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s RevokeInstanceFromTransitRouterRequest) String() string {
	return tea.Prettify(s)
}

func (s RevokeInstanceFromTransitRouterRequest) GoString() string {
	return s.String()
}

func (s *RevokeInstanceFromTransitRouterRequest) SetCenId(v string) *RevokeInstanceFromTransitRouterRequest {
	s.CenId = &v
	return s
}

func (s *RevokeInstanceFromTransitRouterRequest) SetCenOwnerId(v int64) *RevokeInstanceFromTransitRouterRequest {
	s.CenOwnerId = &v
	return s
}

func (s *RevokeInstanceFromTransitRouterRequest) SetInstanceId(v string) *RevokeInstanceFromTransitRouterRequest {
	s.InstanceId = &v
	return s
}

func (s *RevokeInstanceFromTransitRouterRequest) SetInstanceType(v string) *RevokeInstanceFromTransitRouterRequest {
	s.InstanceType = &v
	return s
}

func (s *RevokeInstanceFromTransitRouterRequest) SetOwnerAccount(v string) *RevokeInstanceFromTransitRouterRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RevokeInstanceFromTransitRouterRequest) SetOwnerId(v int64) *RevokeInstanceFromTransitRouterRequest {
	s.OwnerId = &v
	return s
}

func (s *RevokeInstanceFromTransitRouterRequest) SetRegionId(v string) *RevokeInstanceFromTransitRouterRequest {
	s.RegionId = &v
	return s
}

func (s *RevokeInstanceFromTransitRouterRequest) SetResourceOwnerAccount(v string) *RevokeInstanceFromTransitRouterRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RevokeInstanceFromTransitRouterRequest) SetResourceOwnerId(v int64) *RevokeInstanceFromTransitRouterRequest {
	s.ResourceOwnerId = &v
	return s
}

type RevokeInstanceFromTransitRouterResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RevokeInstanceFromTransitRouterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RevokeInstanceFromTransitRouterResponseBody) GoString() string {
	return s.String()
}

func (s *RevokeInstanceFromTransitRouterResponseBody) SetRequestId(v string) *RevokeInstanceFromTransitRouterResponseBody {
	s.RequestId = &v
	return s
}

type RevokeInstanceFromTransitRouterResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RevokeInstanceFromTransitRouterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RevokeInstanceFromTransitRouterResponse) String() string {
	return tea.Prettify(s)
}

func (s RevokeInstanceFromTransitRouterResponse) GoString() string {
	return s.String()
}

func (s *RevokeInstanceFromTransitRouterResponse) SetHeaders(v map[string]*string) *RevokeInstanceFromTransitRouterResponse {
	s.Headers = v
	return s
}

func (s *RevokeInstanceFromTransitRouterResponse) SetStatusCode(v int32) *RevokeInstanceFromTransitRouterResponse {
	s.StatusCode = &v
	return s
}

func (s *RevokeInstanceFromTransitRouterResponse) SetBody(v *RevokeInstanceFromTransitRouterResponseBody) *RevokeInstanceFromTransitRouterResponse {
	s.Body = v
	return s
}

type RoutePrivateZoneInCenToVpcRequest struct {
	AccessRegionId       *string `json:"AccessRegionId,omitempty" xml:"AccessRegionId,omitempty"`
	CenId                *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	HostRegionId         *string `json:"HostRegionId,omitempty" xml:"HostRegionId,omitempty"`
	HostVpcId            *string `json:"HostVpcId,omitempty" xml:"HostVpcId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s RoutePrivateZoneInCenToVpcRequest) String() string {
	return tea.Prettify(s)
}

func (s RoutePrivateZoneInCenToVpcRequest) GoString() string {
	return s.String()
}

func (s *RoutePrivateZoneInCenToVpcRequest) SetAccessRegionId(v string) *RoutePrivateZoneInCenToVpcRequest {
	s.AccessRegionId = &v
	return s
}

func (s *RoutePrivateZoneInCenToVpcRequest) SetCenId(v string) *RoutePrivateZoneInCenToVpcRequest {
	s.CenId = &v
	return s
}

func (s *RoutePrivateZoneInCenToVpcRequest) SetHostRegionId(v string) *RoutePrivateZoneInCenToVpcRequest {
	s.HostRegionId = &v
	return s
}

func (s *RoutePrivateZoneInCenToVpcRequest) SetHostVpcId(v string) *RoutePrivateZoneInCenToVpcRequest {
	s.HostVpcId = &v
	return s
}

func (s *RoutePrivateZoneInCenToVpcRequest) SetOwnerAccount(v string) *RoutePrivateZoneInCenToVpcRequest {
	s.OwnerAccount = &v
	return s
}

func (s *RoutePrivateZoneInCenToVpcRequest) SetOwnerId(v int64) *RoutePrivateZoneInCenToVpcRequest {
	s.OwnerId = &v
	return s
}

func (s *RoutePrivateZoneInCenToVpcRequest) SetResourceOwnerAccount(v string) *RoutePrivateZoneInCenToVpcRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *RoutePrivateZoneInCenToVpcRequest) SetResourceOwnerId(v int64) *RoutePrivateZoneInCenToVpcRequest {
	s.ResourceOwnerId = &v
	return s
}

type RoutePrivateZoneInCenToVpcResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RoutePrivateZoneInCenToVpcResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RoutePrivateZoneInCenToVpcResponseBody) GoString() string {
	return s.String()
}

func (s *RoutePrivateZoneInCenToVpcResponseBody) SetRequestId(v string) *RoutePrivateZoneInCenToVpcResponseBody {
	s.RequestId = &v
	return s
}

type RoutePrivateZoneInCenToVpcResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RoutePrivateZoneInCenToVpcResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RoutePrivateZoneInCenToVpcResponse) String() string {
	return tea.Prettify(s)
}

func (s RoutePrivateZoneInCenToVpcResponse) GoString() string {
	return s.String()
}

func (s *RoutePrivateZoneInCenToVpcResponse) SetHeaders(v map[string]*string) *RoutePrivateZoneInCenToVpcResponse {
	s.Headers = v
	return s
}

func (s *RoutePrivateZoneInCenToVpcResponse) SetStatusCode(v int32) *RoutePrivateZoneInCenToVpcResponse {
	s.StatusCode = &v
	return s
}

func (s *RoutePrivateZoneInCenToVpcResponse) SetBody(v *RoutePrivateZoneInCenToVpcResponseBody) *RoutePrivateZoneInCenToVpcResponse {
	s.Body = v
	return s
}

type SetCenInterRegionBandwidthLimitRequest struct {
	BandwidthLimit       *int64  `json:"BandwidthLimit,omitempty" xml:"BandwidthLimit,omitempty"`
	CenId                *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	LocalRegionId        *string `json:"LocalRegionId,omitempty" xml:"LocalRegionId,omitempty"`
	OppositeRegionId     *string `json:"OppositeRegionId,omitempty" xml:"OppositeRegionId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s SetCenInterRegionBandwidthLimitRequest) String() string {
	return tea.Prettify(s)
}

func (s SetCenInterRegionBandwidthLimitRequest) GoString() string {
	return s.String()
}

func (s *SetCenInterRegionBandwidthLimitRequest) SetBandwidthLimit(v int64) *SetCenInterRegionBandwidthLimitRequest {
	s.BandwidthLimit = &v
	return s
}

func (s *SetCenInterRegionBandwidthLimitRequest) SetCenId(v string) *SetCenInterRegionBandwidthLimitRequest {
	s.CenId = &v
	return s
}

func (s *SetCenInterRegionBandwidthLimitRequest) SetLocalRegionId(v string) *SetCenInterRegionBandwidthLimitRequest {
	s.LocalRegionId = &v
	return s
}

func (s *SetCenInterRegionBandwidthLimitRequest) SetOppositeRegionId(v string) *SetCenInterRegionBandwidthLimitRequest {
	s.OppositeRegionId = &v
	return s
}

func (s *SetCenInterRegionBandwidthLimitRequest) SetOwnerAccount(v string) *SetCenInterRegionBandwidthLimitRequest {
	s.OwnerAccount = &v
	return s
}

func (s *SetCenInterRegionBandwidthLimitRequest) SetOwnerId(v int64) *SetCenInterRegionBandwidthLimitRequest {
	s.OwnerId = &v
	return s
}

func (s *SetCenInterRegionBandwidthLimitRequest) SetResourceOwnerAccount(v string) *SetCenInterRegionBandwidthLimitRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *SetCenInterRegionBandwidthLimitRequest) SetResourceOwnerId(v int64) *SetCenInterRegionBandwidthLimitRequest {
	s.ResourceOwnerId = &v
	return s
}

type SetCenInterRegionBandwidthLimitResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s SetCenInterRegionBandwidthLimitResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetCenInterRegionBandwidthLimitResponseBody) GoString() string {
	return s.String()
}

func (s *SetCenInterRegionBandwidthLimitResponseBody) SetRequestId(v string) *SetCenInterRegionBandwidthLimitResponseBody {
	s.RequestId = &v
	return s
}

type SetCenInterRegionBandwidthLimitResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetCenInterRegionBandwidthLimitResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetCenInterRegionBandwidthLimitResponse) String() string {
	return tea.Prettify(s)
}

func (s SetCenInterRegionBandwidthLimitResponse) GoString() string {
	return s.String()
}

func (s *SetCenInterRegionBandwidthLimitResponse) SetHeaders(v map[string]*string) *SetCenInterRegionBandwidthLimitResponse {
	s.Headers = v
	return s
}

func (s *SetCenInterRegionBandwidthLimitResponse) SetStatusCode(v int32) *SetCenInterRegionBandwidthLimitResponse {
	s.StatusCode = &v
	return s
}

func (s *SetCenInterRegionBandwidthLimitResponse) SetBody(v *SetCenInterRegionBandwidthLimitResponseBody) *SetCenInterRegionBandwidthLimitResponse {
	s.Body = v
	return s
}

type TagResourcesRequest struct {
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId     *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// Creates tags and adds them to a resource.
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// $.parameters[2].schema.example
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// 79517
	Tag []*TagResourcesRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s TagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequest) GoString() string {
	return s.String()
}

func (s *TagResourcesRequest) SetOwnerAccount(v string) *TagResourcesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *TagResourcesRequest) SetOwnerId(v int64) *TagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *TagResourcesRequest) SetRegionId(v string) *TagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceId(v []*string) *TagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *TagResourcesRequest) SetResourceOwnerAccount(v string) *TagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *TagResourcesRequest) SetResourceOwnerId(v int64) *TagResourcesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *TagResourcesRequest) SetResourceType(v string) *TagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *TagResourcesRequest) SetTag(v []*TagResourcesRequestTag) *TagResourcesRequest {
	s.Tag = v
	return s
}

type TagResourcesRequestTag struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s TagResourcesRequestTag) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesRequestTag) GoString() string {
	return s.String()
}

func (s *TagResourcesRequestTag) SetKey(v string) *TagResourcesRequestTag {
	s.Key = &v
	return s
}

func (s *TagResourcesRequestTag) SetValue(v string) *TagResourcesRequestTag {
	s.Value = &v
	return s
}

type TagResourcesResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *TagResourcesResponseBody) SetRequestId(v string) *TagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type TagResourcesResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s TagResourcesResponse) GoString() string {
	return s.String()
}

func (s *TagResourcesResponse) SetHeaders(v map[string]*string) *TagResourcesResponse {
	s.Headers = v
	return s
}

func (s *TagResourcesResponse) SetStatusCode(v int32) *TagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *TagResourcesResponse) SetBody(v *TagResourcesResponseBody) *TagResourcesResponse {
	s.Body = v
	return s
}

type TempUpgradeCenBandwidthPackageSpecRequest struct {
	Bandwidth             *int32  `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	CenBandwidthPackageId *string `json:"CenBandwidthPackageId,omitempty" xml:"CenBandwidthPackageId,omitempty"`
	EndTime               *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	OwnerAccount          *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId               *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount  *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId       *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s TempUpgradeCenBandwidthPackageSpecRequest) String() string {
	return tea.Prettify(s)
}

func (s TempUpgradeCenBandwidthPackageSpecRequest) GoString() string {
	return s.String()
}

func (s *TempUpgradeCenBandwidthPackageSpecRequest) SetBandwidth(v int32) *TempUpgradeCenBandwidthPackageSpecRequest {
	s.Bandwidth = &v
	return s
}

func (s *TempUpgradeCenBandwidthPackageSpecRequest) SetCenBandwidthPackageId(v string) *TempUpgradeCenBandwidthPackageSpecRequest {
	s.CenBandwidthPackageId = &v
	return s
}

func (s *TempUpgradeCenBandwidthPackageSpecRequest) SetEndTime(v string) *TempUpgradeCenBandwidthPackageSpecRequest {
	s.EndTime = &v
	return s
}

func (s *TempUpgradeCenBandwidthPackageSpecRequest) SetOwnerAccount(v string) *TempUpgradeCenBandwidthPackageSpecRequest {
	s.OwnerAccount = &v
	return s
}

func (s *TempUpgradeCenBandwidthPackageSpecRequest) SetOwnerId(v int64) *TempUpgradeCenBandwidthPackageSpecRequest {
	s.OwnerId = &v
	return s
}

func (s *TempUpgradeCenBandwidthPackageSpecRequest) SetResourceOwnerAccount(v string) *TempUpgradeCenBandwidthPackageSpecRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *TempUpgradeCenBandwidthPackageSpecRequest) SetResourceOwnerId(v int64) *TempUpgradeCenBandwidthPackageSpecRequest {
	s.ResourceOwnerId = &v
	return s
}

type TempUpgradeCenBandwidthPackageSpecResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TempUpgradeCenBandwidthPackageSpecResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TempUpgradeCenBandwidthPackageSpecResponseBody) GoString() string {
	return s.String()
}

func (s *TempUpgradeCenBandwidthPackageSpecResponseBody) SetRequestId(v string) *TempUpgradeCenBandwidthPackageSpecResponseBody {
	s.RequestId = &v
	return s
}

type TempUpgradeCenBandwidthPackageSpecResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TempUpgradeCenBandwidthPackageSpecResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TempUpgradeCenBandwidthPackageSpecResponse) String() string {
	return tea.Prettify(s)
}

func (s TempUpgradeCenBandwidthPackageSpecResponse) GoString() string {
	return s.String()
}

func (s *TempUpgradeCenBandwidthPackageSpecResponse) SetHeaders(v map[string]*string) *TempUpgradeCenBandwidthPackageSpecResponse {
	s.Headers = v
	return s
}

func (s *TempUpgradeCenBandwidthPackageSpecResponse) SetStatusCode(v int32) *TempUpgradeCenBandwidthPackageSpecResponse {
	s.StatusCode = &v
	return s
}

func (s *TempUpgradeCenBandwidthPackageSpecResponse) SetBody(v *TempUpgradeCenBandwidthPackageSpecResponseBody) *TempUpgradeCenBandwidthPackageSpecResponse {
	s.Body = v
	return s
}

type UnassociateCenBandwidthPackageRequest struct {
	// The ID of the bandwidth plan.
	CenBandwidthPackageId *string `json:"CenBandwidthPackageId,omitempty" xml:"CenBandwidthPackageId,omitempty"`
	// The ID of the CEN instance.
	CenId                *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s UnassociateCenBandwidthPackageRequest) String() string {
	return tea.Prettify(s)
}

func (s UnassociateCenBandwidthPackageRequest) GoString() string {
	return s.String()
}

func (s *UnassociateCenBandwidthPackageRequest) SetCenBandwidthPackageId(v string) *UnassociateCenBandwidthPackageRequest {
	s.CenBandwidthPackageId = &v
	return s
}

func (s *UnassociateCenBandwidthPackageRequest) SetCenId(v string) *UnassociateCenBandwidthPackageRequest {
	s.CenId = &v
	return s
}

func (s *UnassociateCenBandwidthPackageRequest) SetOwnerAccount(v string) *UnassociateCenBandwidthPackageRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UnassociateCenBandwidthPackageRequest) SetOwnerId(v int64) *UnassociateCenBandwidthPackageRequest {
	s.OwnerId = &v
	return s
}

func (s *UnassociateCenBandwidthPackageRequest) SetResourceOwnerAccount(v string) *UnassociateCenBandwidthPackageRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UnassociateCenBandwidthPackageRequest) SetResourceOwnerId(v int64) *UnassociateCenBandwidthPackageRequest {
	s.ResourceOwnerId = &v
	return s
}

type UnassociateCenBandwidthPackageResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UnassociateCenBandwidthPackageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnassociateCenBandwidthPackageResponseBody) GoString() string {
	return s.String()
}

func (s *UnassociateCenBandwidthPackageResponseBody) SetRequestId(v string) *UnassociateCenBandwidthPackageResponseBody {
	s.RequestId = &v
	return s
}

type UnassociateCenBandwidthPackageResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnassociateCenBandwidthPackageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnassociateCenBandwidthPackageResponse) String() string {
	return tea.Prettify(s)
}

func (s UnassociateCenBandwidthPackageResponse) GoString() string {
	return s.String()
}

func (s *UnassociateCenBandwidthPackageResponse) SetHeaders(v map[string]*string) *UnassociateCenBandwidthPackageResponse {
	s.Headers = v
	return s
}

func (s *UnassociateCenBandwidthPackageResponse) SetStatusCode(v int32) *UnassociateCenBandwidthPackageResponse {
	s.StatusCode = &v
	return s
}

func (s *UnassociateCenBandwidthPackageResponse) SetBody(v *UnassociateCenBandwidthPackageResponseBody) *UnassociateCenBandwidthPackageResponse {
	s.Body = v
	return s
}

type UnroutePrivateZoneInCenToVpcRequest struct {
	AccessRegionId       *string `json:"AccessRegionId,omitempty" xml:"AccessRegionId,omitempty"`
	CenId                *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s UnroutePrivateZoneInCenToVpcRequest) String() string {
	return tea.Prettify(s)
}

func (s UnroutePrivateZoneInCenToVpcRequest) GoString() string {
	return s.String()
}

func (s *UnroutePrivateZoneInCenToVpcRequest) SetAccessRegionId(v string) *UnroutePrivateZoneInCenToVpcRequest {
	s.AccessRegionId = &v
	return s
}

func (s *UnroutePrivateZoneInCenToVpcRequest) SetCenId(v string) *UnroutePrivateZoneInCenToVpcRequest {
	s.CenId = &v
	return s
}

func (s *UnroutePrivateZoneInCenToVpcRequest) SetOwnerAccount(v string) *UnroutePrivateZoneInCenToVpcRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UnroutePrivateZoneInCenToVpcRequest) SetOwnerId(v int64) *UnroutePrivateZoneInCenToVpcRequest {
	s.OwnerId = &v
	return s
}

func (s *UnroutePrivateZoneInCenToVpcRequest) SetResourceOwnerAccount(v string) *UnroutePrivateZoneInCenToVpcRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UnroutePrivateZoneInCenToVpcRequest) SetResourceOwnerId(v int64) *UnroutePrivateZoneInCenToVpcRequest {
	s.ResourceOwnerId = &v
	return s
}

type UnroutePrivateZoneInCenToVpcResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UnroutePrivateZoneInCenToVpcResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnroutePrivateZoneInCenToVpcResponseBody) GoString() string {
	return s.String()
}

func (s *UnroutePrivateZoneInCenToVpcResponseBody) SetRequestId(v string) *UnroutePrivateZoneInCenToVpcResponseBody {
	s.RequestId = &v
	return s
}

type UnroutePrivateZoneInCenToVpcResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnroutePrivateZoneInCenToVpcResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnroutePrivateZoneInCenToVpcResponse) String() string {
	return tea.Prettify(s)
}

func (s UnroutePrivateZoneInCenToVpcResponse) GoString() string {
	return s.String()
}

func (s *UnroutePrivateZoneInCenToVpcResponse) SetHeaders(v map[string]*string) *UnroutePrivateZoneInCenToVpcResponse {
	s.Headers = v
	return s
}

func (s *UnroutePrivateZoneInCenToVpcResponse) SetStatusCode(v int32) *UnroutePrivateZoneInCenToVpcResponse {
	s.StatusCode = &v
	return s
}

func (s *UnroutePrivateZoneInCenToVpcResponse) SetBody(v *UnroutePrivateZoneInCenToVpcResponseBody) *UnroutePrivateZoneInCenToVpcResponse {
	s.Body = v
	return s
}

type UntagResourcesRequest struct {
	All                  *bool     `json:"All,omitempty" xml:"All,omitempty"`
	OwnerAccount         *string   `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64    `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	RegionId             *string   `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceId           []*string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string   `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64    `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	ResourceType         *string   `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	TagKey               []*string `json:"TagKey,omitempty" xml:"TagKey,omitempty" type:"Repeated"`
}

func (s UntagResourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesRequest) GoString() string {
	return s.String()
}

func (s *UntagResourcesRequest) SetAll(v bool) *UntagResourcesRequest {
	s.All = &v
	return s
}

func (s *UntagResourcesRequest) SetOwnerAccount(v string) *UntagResourcesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UntagResourcesRequest) SetOwnerId(v int64) *UntagResourcesRequest {
	s.OwnerId = &v
	return s
}

func (s *UntagResourcesRequest) SetRegionId(v string) *UntagResourcesRequest {
	s.RegionId = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceId(v []*string) *UntagResourcesRequest {
	s.ResourceId = v
	return s
}

func (s *UntagResourcesRequest) SetResourceOwnerAccount(v string) *UntagResourcesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceOwnerId(v int64) *UntagResourcesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UntagResourcesRequest) SetResourceType(v string) *UntagResourcesRequest {
	s.ResourceType = &v
	return s
}

func (s *UntagResourcesRequest) SetTagKey(v []*string) *UntagResourcesRequest {
	s.TagKey = v
	return s
}

type UntagResourcesResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UntagResourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponseBody) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponseBody) SetRequestId(v string) *UntagResourcesResponseBody {
	s.RequestId = &v
	return s
}

type UntagResourcesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UntagResourcesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UntagResourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s UntagResourcesResponse) GoString() string {
	return s.String()
}

func (s *UntagResourcesResponse) SetHeaders(v map[string]*string) *UntagResourcesResponse {
	s.Headers = v
	return s
}

func (s *UntagResourcesResponse) SetStatusCode(v int32) *UntagResourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *UntagResourcesResponse) SetBody(v *UntagResourcesResponseBody) *UntagResourcesResponse {
	s.Body = v
	return s
}

type UpdateCenInterRegionTrafficQosPolicyAttributeRequest struct {
	// The ID of the request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The operation that you want to perform. Set the value to **UpdateCenInterRegionTrafficQosPolicyAttribute**.
	DryRun                      *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount                *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                     *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount        *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId             *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	TrafficQosPolicyDescription *string `json:"TrafficQosPolicyDescription,omitempty" xml:"TrafficQosPolicyDescription,omitempty"`
	// The new description of the QoS policy.
	//
	// The description must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The description must start with a letter.
	TrafficQosPolicyId   *string `json:"TrafficQosPolicyId,omitempty" xml:"TrafficQosPolicyId,omitempty"`
	TrafficQosPolicyName *string `json:"TrafficQosPolicyName,omitempty" xml:"TrafficQosPolicyName,omitempty"`
}

func (s UpdateCenInterRegionTrafficQosPolicyAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCenInterRegionTrafficQosPolicyAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateCenInterRegionTrafficQosPolicyAttributeRequest) SetClientToken(v string) *UpdateCenInterRegionTrafficQosPolicyAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosPolicyAttributeRequest) SetDryRun(v bool) *UpdateCenInterRegionTrafficQosPolicyAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosPolicyAttributeRequest) SetOwnerAccount(v string) *UpdateCenInterRegionTrafficQosPolicyAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosPolicyAttributeRequest) SetOwnerId(v int64) *UpdateCenInterRegionTrafficQosPolicyAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosPolicyAttributeRequest) SetResourceOwnerAccount(v string) *UpdateCenInterRegionTrafficQosPolicyAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosPolicyAttributeRequest) SetResourceOwnerId(v int64) *UpdateCenInterRegionTrafficQosPolicyAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosPolicyAttributeRequest) SetTrafficQosPolicyDescription(v string) *UpdateCenInterRegionTrafficQosPolicyAttributeRequest {
	s.TrafficQosPolicyDescription = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosPolicyAttributeRequest) SetTrafficQosPolicyId(v string) *UpdateCenInterRegionTrafficQosPolicyAttributeRequest {
	s.TrafficQosPolicyId = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosPolicyAttributeRequest) SetTrafficQosPolicyName(v string) *UpdateCenInterRegionTrafficQosPolicyAttributeRequest {
	s.TrafficQosPolicyName = &v
	return s
}

type UpdateCenInterRegionTrafficQosPolicyAttributeResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateCenInterRegionTrafficQosPolicyAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateCenInterRegionTrafficQosPolicyAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateCenInterRegionTrafficQosPolicyAttributeResponseBody) SetRequestId(v string) *UpdateCenInterRegionTrafficQosPolicyAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateCenInterRegionTrafficQosPolicyAttributeResponse struct {
	Headers    map[string]*string                                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateCenInterRegionTrafficQosPolicyAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateCenInterRegionTrafficQosPolicyAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateCenInterRegionTrafficQosPolicyAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateCenInterRegionTrafficQosPolicyAttributeResponse) SetHeaders(v map[string]*string) *UpdateCenInterRegionTrafficQosPolicyAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateCenInterRegionTrafficQosPolicyAttributeResponse) SetStatusCode(v int32) *UpdateCenInterRegionTrafficQosPolicyAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosPolicyAttributeResponse) SetBody(v *UpdateCenInterRegionTrafficQosPolicyAttributeResponseBody) *UpdateCenInterRegionTrafficQosPolicyAttributeResponse {
	s.Body = v
	return s
}

type UpdateCenInterRegionTrafficQosQueueAttributeRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run, without performing the actual request. Valid values:
	//
	// *   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	DryRun *bool `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	// The differentiated services code point (DSCP) value used to match packets in the queue.
	Dscps        []*int32 `json:"Dscps,omitempty" xml:"Dscps,omitempty" type:"Repeated"`
	OwnerAccount *string  `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64   `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The new description of the queue.
	//
	// The description must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The description must start with a letter.
	QosQueueDescription *string `json:"QosQueueDescription,omitempty" xml:"QosQueueDescription,omitempty"`
	// The queue ID.
	QosQueueId *string `json:"QosQueueId,omitempty" xml:"QosQueueId,omitempty"`
	// The new name of the queue.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	QosQueueName *string `json:"QosQueueName,omitempty" xml:"QosQueueName,omitempty"`
	// The percentage of the inter-region bandwidth that can be used by the queue.
	//
	// Enter a number. You do not need to enter a percent sign (%).
	RemainBandwidthPercent *string `json:"RemainBandwidthPercent,omitempty" xml:"RemainBandwidthPercent,omitempty"`
	ResourceOwnerAccount   *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId        *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s UpdateCenInterRegionTrafficQosQueueAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateCenInterRegionTrafficQosQueueAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateCenInterRegionTrafficQosQueueAttributeRequest) SetClientToken(v string) *UpdateCenInterRegionTrafficQosQueueAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosQueueAttributeRequest) SetDryRun(v bool) *UpdateCenInterRegionTrafficQosQueueAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosQueueAttributeRequest) SetDscps(v []*int32) *UpdateCenInterRegionTrafficQosQueueAttributeRequest {
	s.Dscps = v
	return s
}

func (s *UpdateCenInterRegionTrafficQosQueueAttributeRequest) SetOwnerAccount(v string) *UpdateCenInterRegionTrafficQosQueueAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosQueueAttributeRequest) SetOwnerId(v int64) *UpdateCenInterRegionTrafficQosQueueAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosQueueAttributeRequest) SetQosQueueDescription(v string) *UpdateCenInterRegionTrafficQosQueueAttributeRequest {
	s.QosQueueDescription = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosQueueAttributeRequest) SetQosQueueId(v string) *UpdateCenInterRegionTrafficQosQueueAttributeRequest {
	s.QosQueueId = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosQueueAttributeRequest) SetQosQueueName(v string) *UpdateCenInterRegionTrafficQosQueueAttributeRequest {
	s.QosQueueName = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosQueueAttributeRequest) SetRemainBandwidthPercent(v string) *UpdateCenInterRegionTrafficQosQueueAttributeRequest {
	s.RemainBandwidthPercent = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosQueueAttributeRequest) SetResourceOwnerAccount(v string) *UpdateCenInterRegionTrafficQosQueueAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosQueueAttributeRequest) SetResourceOwnerId(v int64) *UpdateCenInterRegionTrafficQosQueueAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

type UpdateCenInterRegionTrafficQosQueueAttributeResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateCenInterRegionTrafficQosQueueAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateCenInterRegionTrafficQosQueueAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateCenInterRegionTrafficQosQueueAttributeResponseBody) SetRequestId(v string) *UpdateCenInterRegionTrafficQosQueueAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateCenInterRegionTrafficQosQueueAttributeResponse struct {
	Headers    map[string]*string                                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateCenInterRegionTrafficQosQueueAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateCenInterRegionTrafficQosQueueAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateCenInterRegionTrafficQosQueueAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateCenInterRegionTrafficQosQueueAttributeResponse) SetHeaders(v map[string]*string) *UpdateCenInterRegionTrafficQosQueueAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateCenInterRegionTrafficQosQueueAttributeResponse) SetStatusCode(v int32) *UpdateCenInterRegionTrafficQosQueueAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateCenInterRegionTrafficQosQueueAttributeResponse) SetBody(v *UpdateCenInterRegionTrafficQosQueueAttributeResponseBody) *UpdateCenInterRegionTrafficQosQueueAttributeResponse {
	s.Body = v
	return s
}

type UpdateTrafficMarkingPolicyAttributeRequest struct {
	// The traffic classification rules to be added to the traffic marking policy.
	AddTrafficMatchRules []*UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules `json:"AddTrafficMatchRules,omitempty" xml:"AddTrafficMatchRules,omitempty" type:"Repeated"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the value, but you must make sure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The traffic classification rules to be deleted from the traffic marking policy.
	DeleteTrafficMatchRules []*UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules `json:"DeleteTrafficMatchRules,omitempty" xml:"DeleteTrafficMatchRules,omitempty" type:"Repeated"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: preforms a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The new description of the traffic marking policy.
	//
	// The description must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The description must start with a letter.
	TrafficMarkingPolicyDescription *string `json:"TrafficMarkingPolicyDescription,omitempty" xml:"TrafficMarkingPolicyDescription,omitempty"`
	// The ID of the traffic marking policy.
	TrafficMarkingPolicyId *string `json:"TrafficMarkingPolicyId,omitempty" xml:"TrafficMarkingPolicyId,omitempty"`
	// The new name of the traffic marking policy.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	TrafficMarkingPolicyName *string `json:"TrafficMarkingPolicyName,omitempty" xml:"TrafficMarkingPolicyName,omitempty"`
}

func (s UpdateTrafficMarkingPolicyAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTrafficMarkingPolicyAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateTrafficMarkingPolicyAttributeRequest) SetAddTrafficMatchRules(v []*UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules) *UpdateTrafficMarkingPolicyAttributeRequest {
	s.AddTrafficMatchRules = v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequest) SetClientToken(v string) *UpdateTrafficMarkingPolicyAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequest) SetDeleteTrafficMatchRules(v []*UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules) *UpdateTrafficMarkingPolicyAttributeRequest {
	s.DeleteTrafficMatchRules = v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequest) SetDryRun(v bool) *UpdateTrafficMarkingPolicyAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequest) SetOwnerAccount(v string) *UpdateTrafficMarkingPolicyAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequest) SetOwnerId(v int64) *UpdateTrafficMarkingPolicyAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequest) SetResourceOwnerAccount(v string) *UpdateTrafficMarkingPolicyAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequest) SetResourceOwnerId(v int64) *UpdateTrafficMarkingPolicyAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequest) SetTrafficMarkingPolicyDescription(v string) *UpdateTrafficMarkingPolicyAttributeRequest {
	s.TrafficMarkingPolicyDescription = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequest) SetTrafficMarkingPolicyId(v string) *UpdateTrafficMarkingPolicyAttributeRequest {
	s.TrafficMarkingPolicyId = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequest) SetTrafficMarkingPolicyName(v string) *UpdateTrafficMarkingPolicyAttributeRequest {
	s.TrafficMarkingPolicyName = &v
	return s
}

type UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules struct {
	// The destination CIDR block that is used to match packets.
	//
	// The traffic classification rule matches the packets whose destination IP addresses fall within the specified destination CIDR block. If you do not set this parameter, packets are considered a match regardless of the destination IP address.
	//
	// You can create up to 50 traffic classification rules at a time. You can specify a destination CIDR block for each traffic classification rule.
	DstCidr *string `json:"DstCidr,omitempty" xml:"DstCidr,omitempty"`
	// The destination port range that is used to match packets. Valid values: **-1** and **1** to **65535**.
	//
	// The traffic classification rule matches the packets whose destination ports fall within the destination port range. If you do not set this parameter, packets are considered a match regardless of the destination port.
	//
	// You can specify at most two ports. Take note of the following rules:
	//
	// *   If you enter only one port number such as 1, the system matches the packets whose destination port is port 1.
	// *   If you enter two port numbers such as 1 and 200, the system matches the packets whose destination ports fall between 1 and 200.
	// *   If you enter two port numbers and one of them is -1, the other port number must also be -1. In this case, packets are considered a match regardless of the destination port.
	//
	// You can create up to 50 traffic classification rules at a time. You can specify a destination port range for each traffic classification rule.
	DstPortRange []*int32 `json:"DstPortRange,omitempty" xml:"DstPortRange,omitempty" type:"Repeated"`
	// The differentiated services code point (DSCP) value that is used to match packets. Valid values: **0** to **63**.
	//
	// The traffic classification rule matches the packets that contain the specified DSCP value. If you do not set this parameter, packets are considered a match regardless of the DSCP value.
	//
	// >  The DSCP value that you specify for this parameter is the DSCP value that packets carry before they are transmitted over the inter-region connection.
	//
	// You can create up to 50 traffic classification rules at a time. You can specify a DSCP value for each traffic classification rule.
	MatchDscp *int32 `json:"MatchDscp,omitempty" xml:"MatchDscp,omitempty"`
	// The protocol that is used to match packets.
	//
	// Valid values: **HTTP**, **HTTPS**, **TCP**, **UDP**, **SSH**, and **Telnet**. For more information, log on to the [Cloud Enterprise Network (CEN) console](https://cen.console.aliyun.com/cen/list).
	//
	// You can create up to 50 traffic classification rules at a time. You can specify a protocol for each traffic classification rule.
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The source CIDR block that is used to match packets.
	//
	// The traffic classification rule matches the packets whose source IP addresses fall within the specified source CIDR block. If you do not set this parameter, packets are considered a match regardless of the source IP address.
	//
	// You can create up to 50 traffic classification rules at a time. You can specify a source CIDR block for each traffic classification rule.
	SrcCidr *string `json:"SrcCidr,omitempty" xml:"SrcCidr,omitempty"`
	// The source port range that is used to match packets. Valid values: **-1** and **1** to **65535**.
	//
	// The traffic classification rule matches the packets whose source ports fall within the source port range. If you do not set this parameter, packets are considered a match regardless of the source port.
	//
	// You can specify at most two ports. Take note of the following rules:
	//
	// *   If you enter only one port number such as 1, the system matches the packets whose source port is 1.
	// *   If you enter two port numbers such as 1 and 200, the system matches the packets whose source ports fall between 1 and 200.
	// *   If you enter two port numbers and one of them is -1, the other port number must also be -1. In this case, packets are considered a match regardless of the source port.
	//
	// You can create up to 50 traffic classification rules at a time. You can specify a source port range for each traffic classification rule.
	SrcPortRange []*int32 `json:"SrcPortRange,omitempty" xml:"SrcPortRange,omitempty" type:"Repeated"`
	// The description of the traffic classification rule.
	//
	// You can create up to 50 traffic classification rules at a time. You can specify a description for each traffic classification rule.
	//
	// The description must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The description must start with a letter.
	TrafficMatchRuleDescription *string `json:"TrafficMatchRuleDescription,omitempty" xml:"TrafficMatchRuleDescription,omitempty"`
	// The name of the traffic classification rule.
	//
	// You can create up to 50 traffic classification rules at a time. You can specify a name for each traffic classification rule.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	TrafficMatchRuleName *string `json:"TrafficMatchRuleName,omitempty" xml:"TrafficMatchRuleName,omitempty"`
}

func (s UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules) String() string {
	return tea.Prettify(s)
}

func (s UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules) GoString() string {
	return s.String()
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules) SetDstCidr(v string) *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules {
	s.DstCidr = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules) SetDstPortRange(v []*int32) *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules {
	s.DstPortRange = v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules) SetMatchDscp(v int32) *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules {
	s.MatchDscp = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules) SetProtocol(v string) *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules {
	s.Protocol = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules) SetSrcCidr(v string) *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules {
	s.SrcCidr = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules) SetSrcPortRange(v []*int32) *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules {
	s.SrcPortRange = v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules) SetTrafficMatchRuleDescription(v string) *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules {
	s.TrafficMatchRuleDescription = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules) SetTrafficMatchRuleName(v string) *UpdateTrafficMarkingPolicyAttributeRequestAddTrafficMatchRules {
	s.TrafficMatchRuleName = &v
	return s
}

type UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules struct {
	// The destination CIDR block that is used to match data packets.
	DstCidr *string `json:"DstCidr,omitempty" xml:"DstCidr,omitempty"`
	// The destination port range that is used to match packets. Valid values: **-1** and **1** to **65535**.
	DstPortRange []*int32 `json:"DstPortRange,omitempty" xml:"DstPortRange,omitempty" type:"Repeated"`
	// The DSCP value that is used to match packets.
	MatchDscp *int32 `json:"MatchDscp,omitempty" xml:"MatchDscp,omitempty"`
	// The protocol that is used to match packets.
	//
	// Valid values: **HTTP**, **HTTPS**, **TCP**, **UDP**, **SSH**, and **Telnet**. For more information, log on to the [Cloud Enterprise Network (CEN) console](https://cen.console.aliyun.com/cen/list).
	Protocol *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	// The source CIDR block that is used to match packets.
	SrcCidr *string `json:"SrcCidr,omitempty" xml:"SrcCidr,omitempty"`
	// The source port range that is used to match packets. Valid values: **-1** and **1** to **65535**.
	SrcPortRange []*int32 `json:"SrcPortRange,omitempty" xml:"SrcPortRange,omitempty" type:"Repeated"`
	// The description of the traffic classification rule.
	TrafficMatchRuleDescription *string `json:"TrafficMatchRuleDescription,omitempty" xml:"TrafficMatchRuleDescription,omitempty"`
	// The name of the traffic classification rule.
	TrafficMatchRuleName *string `json:"TrafficMatchRuleName,omitempty" xml:"TrafficMatchRuleName,omitempty"`
}

func (s UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules) String() string {
	return tea.Prettify(s)
}

func (s UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules) GoString() string {
	return s.String()
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules) SetDstCidr(v string) *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules {
	s.DstCidr = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules) SetDstPortRange(v []*int32) *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules {
	s.DstPortRange = v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules) SetMatchDscp(v int32) *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules {
	s.MatchDscp = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules) SetProtocol(v string) *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules {
	s.Protocol = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules) SetSrcCidr(v string) *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules {
	s.SrcCidr = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules) SetSrcPortRange(v []*int32) *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules {
	s.SrcPortRange = v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules) SetTrafficMatchRuleDescription(v string) *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules {
	s.TrafficMatchRuleDescription = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules) SetTrafficMatchRuleName(v string) *UpdateTrafficMarkingPolicyAttributeRequestDeleteTrafficMatchRules {
	s.TrafficMatchRuleName = &v
	return s
}

type UpdateTrafficMarkingPolicyAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateTrafficMarkingPolicyAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTrafficMarkingPolicyAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTrafficMarkingPolicyAttributeResponseBody) SetRequestId(v string) *UpdateTrafficMarkingPolicyAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateTrafficMarkingPolicyAttributeResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTrafficMarkingPolicyAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTrafficMarkingPolicyAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTrafficMarkingPolicyAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateTrafficMarkingPolicyAttributeResponse) SetHeaders(v map[string]*string) *UpdateTrafficMarkingPolicyAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeResponse) SetStatusCode(v int32) *UpdateTrafficMarkingPolicyAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTrafficMarkingPolicyAttributeResponse) SetBody(v *UpdateTrafficMarkingPolicyAttributeResponseBody) *UpdateTrafficMarkingPolicyAttributeResponse {
	s.Body = v
	return s
}

type UpdateTransitRouterRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request. Valid values:
	//
	// *   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	// *   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the system returns the ID of the request.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The region ID of the transit router.
	//
	// You can call the [DescribeRegions](~~36063~~) operation to query the most recent region list.
	RegionId             *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The description of the transit router.
	//
	// The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with `http://` or `https://`.
	TransitRouterDescription *string `json:"TransitRouterDescription,omitempty" xml:"TransitRouterDescription,omitempty"`
	// The transit router ID.
	TransitRouterId *string `json:"TransitRouterId,omitempty" xml:"TransitRouterId,omitempty"`
	// The transit router name.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, periods (.), underscores (\_), and hyphens (-). The name must start with a letter but cannot start with `http://` or `https://`.
	TransitRouterName *string `json:"TransitRouterName,omitempty" xml:"TransitRouterName,omitempty"`
}

func (s UpdateTransitRouterRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterRequest) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterRequest) SetClientToken(v string) *UpdateTransitRouterRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateTransitRouterRequest) SetDryRun(v bool) *UpdateTransitRouterRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateTransitRouterRequest) SetOwnerAccount(v string) *UpdateTransitRouterRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterRequest) SetOwnerId(v int64) *UpdateTransitRouterRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateTransitRouterRequest) SetRegionId(v string) *UpdateTransitRouterRequest {
	s.RegionId = &v
	return s
}

func (s *UpdateTransitRouterRequest) SetResourceOwnerAccount(v string) *UpdateTransitRouterRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterRequest) SetResourceOwnerId(v int64) *UpdateTransitRouterRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateTransitRouterRequest) SetTransitRouterDescription(v string) *UpdateTransitRouterRequest {
	s.TransitRouterDescription = &v
	return s
}

func (s *UpdateTransitRouterRequest) SetTransitRouterId(v string) *UpdateTransitRouterRequest {
	s.TransitRouterId = &v
	return s
}

func (s *UpdateTransitRouterRequest) SetTransitRouterName(v string) *UpdateTransitRouterRequest {
	s.TransitRouterName = &v
	return s
}

type UpdateTransitRouterResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateTransitRouterResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterResponseBody) SetRequestId(v string) *UpdateTransitRouterResponseBody {
	s.RequestId = &v
	return s
}

type UpdateTransitRouterResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTransitRouterResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTransitRouterResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterResponse) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterResponse) SetHeaders(v map[string]*string) *UpdateTransitRouterResponse {
	s.Headers = v
	return s
}

func (s *UpdateTransitRouterResponse) SetStatusCode(v int32) *UpdateTransitRouterResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTransitRouterResponse) SetBody(v *UpdateTransitRouterResponseBody) *UpdateTransitRouterResponse {
	s.Body = v
	return s
}

type UpdateTransitRouterPeerAttachmentAttributeRequest struct {
	// Specifies whether to enable the local Enterprise Edition transit router to automatically advertise the routes of the inter-region connection to the peer transit router. Valid values:
	//
	// *   **false** (default): no
	// *   **true**: yes
	AutoPublishRouteEnabled *bool `json:"AutoPublishRouteEnabled,omitempty" xml:"AutoPublishRouteEnabled,omitempty"`
	// The maximum bandwidth value of the inter-region connection. Unit: Mbit/s.
	//
	// *   This parameter specifies the maximum bandwidth value for the inter-region connection if you set **BandwidthType** to **BandwidthPackage**.
	// *   This parameter specifies the bandwidth throttling threshold for the inter-region connection if you set **BandwidthType** to **DataTransfer**.
	Bandwidth *int32 `json:"Bandwidth,omitempty" xml:"Bandwidth,omitempty"`
	// The bandwidth allocation method. Valid values:
	//
	// *   **BandwidthPackage**: allocates bandwidth from a bandwidth plan.
	// *   **DataTransfer**: bandwidth is billed based on the pay-by-data-transfer metering method.
	BandwidthType *string `json:"BandwidthType,omitempty" xml:"BandwidthType,omitempty"`
	// The ID of the bandwidth plan that is used to allocate bandwidth to the inter-region connection.
	//
	// > If you set **BandwidthType** to **DataTransfer**, you do not need to set this parameter.
	CenBandwidthPackageId *string `json:"CenBandwidthPackageId,omitempty" xml:"CenBandwidthPackageId,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run to check information such as the permissions and the instance status. Default values:
	//
	// *   **false** (default): performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the system returns the ID of the request.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The new description of the inter-region connection.
	//
	// The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with `http://` or `https://`.
	TransitRouterAttachmentDescription *string `json:"TransitRouterAttachmentDescription,omitempty" xml:"TransitRouterAttachmentDescription,omitempty"`
	// The ID of the inter-region connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The new name of the inter-region connection.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	TransitRouterAttachmentName *string `json:"TransitRouterAttachmentName,omitempty" xml:"TransitRouterAttachmentName,omitempty"`
}

func (s UpdateTransitRouterPeerAttachmentAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterPeerAttachmentAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterPeerAttachmentAttributeRequest) SetAutoPublishRouteEnabled(v bool) *UpdateTransitRouterPeerAttachmentAttributeRequest {
	s.AutoPublishRouteEnabled = &v
	return s
}

func (s *UpdateTransitRouterPeerAttachmentAttributeRequest) SetBandwidth(v int32) *UpdateTransitRouterPeerAttachmentAttributeRequest {
	s.Bandwidth = &v
	return s
}

func (s *UpdateTransitRouterPeerAttachmentAttributeRequest) SetBandwidthType(v string) *UpdateTransitRouterPeerAttachmentAttributeRequest {
	s.BandwidthType = &v
	return s
}

func (s *UpdateTransitRouterPeerAttachmentAttributeRequest) SetCenBandwidthPackageId(v string) *UpdateTransitRouterPeerAttachmentAttributeRequest {
	s.CenBandwidthPackageId = &v
	return s
}

func (s *UpdateTransitRouterPeerAttachmentAttributeRequest) SetClientToken(v string) *UpdateTransitRouterPeerAttachmentAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateTransitRouterPeerAttachmentAttributeRequest) SetDryRun(v bool) *UpdateTransitRouterPeerAttachmentAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateTransitRouterPeerAttachmentAttributeRequest) SetOwnerAccount(v string) *UpdateTransitRouterPeerAttachmentAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterPeerAttachmentAttributeRequest) SetOwnerId(v int64) *UpdateTransitRouterPeerAttachmentAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateTransitRouterPeerAttachmentAttributeRequest) SetResourceOwnerAccount(v string) *UpdateTransitRouterPeerAttachmentAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterPeerAttachmentAttributeRequest) SetResourceOwnerId(v int64) *UpdateTransitRouterPeerAttachmentAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateTransitRouterPeerAttachmentAttributeRequest) SetTransitRouterAttachmentDescription(v string) *UpdateTransitRouterPeerAttachmentAttributeRequest {
	s.TransitRouterAttachmentDescription = &v
	return s
}

func (s *UpdateTransitRouterPeerAttachmentAttributeRequest) SetTransitRouterAttachmentId(v string) *UpdateTransitRouterPeerAttachmentAttributeRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *UpdateTransitRouterPeerAttachmentAttributeRequest) SetTransitRouterAttachmentName(v string) *UpdateTransitRouterPeerAttachmentAttributeRequest {
	s.TransitRouterAttachmentName = &v
	return s
}

type UpdateTransitRouterPeerAttachmentAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateTransitRouterPeerAttachmentAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterPeerAttachmentAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterPeerAttachmentAttributeResponseBody) SetRequestId(v string) *UpdateTransitRouterPeerAttachmentAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateTransitRouterPeerAttachmentAttributeResponse struct {
	Headers    map[string]*string                                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTransitRouterPeerAttachmentAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTransitRouterPeerAttachmentAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterPeerAttachmentAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterPeerAttachmentAttributeResponse) SetHeaders(v map[string]*string) *UpdateTransitRouterPeerAttachmentAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateTransitRouterPeerAttachmentAttributeResponse) SetStatusCode(v int32) *UpdateTransitRouterPeerAttachmentAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTransitRouterPeerAttachmentAttributeResponse) SetBody(v *UpdateTransitRouterPeerAttachmentAttributeResponseBody) *UpdateTransitRouterPeerAttachmentAttributeResponse {
	s.Body = v
	return s
}

type UpdateTransitRouterRouteEntryRequest struct {
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The client token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Default values:
	//
	// *   **false** (default): performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The new description of the route.
	//
	// The description must be 1 to 256 characters in length, and can contain letters, digits, and the following special characters: , . ; / @ \_ -. You can also leave the description empty.
	TransitRouterRouteEntryDescription *string `json:"TransitRouterRouteEntryDescription,omitempty" xml:"TransitRouterRouteEntryDescription,omitempty"`
	// The ID of the route.
	TransitRouterRouteEntryId *string `json:"TransitRouterRouteEntryId,omitempty" xml:"TransitRouterRouteEntryId,omitempty"`
	// The new name of the route.
	//
	// The name must be 1 to 128 characters in length, and can contain letters, digits, and the following special characters: , . ; / @ \_ -. You can also leave the name empty.
	TransitRouterRouteEntryName *string `json:"TransitRouterRouteEntryName,omitempty" xml:"TransitRouterRouteEntryName,omitempty"`
}

func (s UpdateTransitRouterRouteEntryRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterRouteEntryRequest) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterRouteEntryRequest) SetClientToken(v string) *UpdateTransitRouterRouteEntryRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateTransitRouterRouteEntryRequest) SetDryRun(v bool) *UpdateTransitRouterRouteEntryRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateTransitRouterRouteEntryRequest) SetOwnerAccount(v string) *UpdateTransitRouterRouteEntryRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterRouteEntryRequest) SetOwnerId(v int64) *UpdateTransitRouterRouteEntryRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateTransitRouterRouteEntryRequest) SetResourceOwnerAccount(v string) *UpdateTransitRouterRouteEntryRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterRouteEntryRequest) SetResourceOwnerId(v int64) *UpdateTransitRouterRouteEntryRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateTransitRouterRouteEntryRequest) SetTransitRouterRouteEntryDescription(v string) *UpdateTransitRouterRouteEntryRequest {
	s.TransitRouterRouteEntryDescription = &v
	return s
}

func (s *UpdateTransitRouterRouteEntryRequest) SetTransitRouterRouteEntryId(v string) *UpdateTransitRouterRouteEntryRequest {
	s.TransitRouterRouteEntryId = &v
	return s
}

func (s *UpdateTransitRouterRouteEntryRequest) SetTransitRouterRouteEntryName(v string) *UpdateTransitRouterRouteEntryRequest {
	s.TransitRouterRouteEntryName = &v
	return s
}

type UpdateTransitRouterRouteEntryResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateTransitRouterRouteEntryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterRouteEntryResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterRouteEntryResponseBody) SetRequestId(v string) *UpdateTransitRouterRouteEntryResponseBody {
	s.RequestId = &v
	return s
}

type UpdateTransitRouterRouteEntryResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTransitRouterRouteEntryResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTransitRouterRouteEntryResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterRouteEntryResponse) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterRouteEntryResponse) SetHeaders(v map[string]*string) *UpdateTransitRouterRouteEntryResponse {
	s.Headers = v
	return s
}

func (s *UpdateTransitRouterRouteEntryResponse) SetStatusCode(v int32) *UpdateTransitRouterRouteEntryResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTransitRouterRouteEntryResponse) SetBody(v *UpdateTransitRouterRouteEntryResponseBody) *UpdateTransitRouterRouteEntryResponse {
	s.Body = v
	return s
}

type UpdateTransitRouterRouteTableRequest struct {
	ClientToken                        *string                                                `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DryRun                             *bool                                                  `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount                       *string                                                `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId                            *int64                                                 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount               *string                                                `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId                    *int64                                                 `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	RouteTableOptions                  *UpdateTransitRouterRouteTableRequestRouteTableOptions `json:"RouteTableOptions,omitempty" xml:"RouteTableOptions,omitempty" type:"Struct"`
	TransitRouterRouteTableDescription *string                                                `json:"TransitRouterRouteTableDescription,omitempty" xml:"TransitRouterRouteTableDescription,omitempty"`
	TransitRouterRouteTableId          *string                                                `json:"TransitRouterRouteTableId,omitempty" xml:"TransitRouterRouteTableId,omitempty"`
	TransitRouterRouteTableName        *string                                                `json:"TransitRouterRouteTableName,omitempty" xml:"TransitRouterRouteTableName,omitempty"`
}

func (s UpdateTransitRouterRouteTableRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterRouteTableRequest) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterRouteTableRequest) SetClientToken(v string) *UpdateTransitRouterRouteTableRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateTransitRouterRouteTableRequest) SetDryRun(v bool) *UpdateTransitRouterRouteTableRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateTransitRouterRouteTableRequest) SetOwnerAccount(v string) *UpdateTransitRouterRouteTableRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterRouteTableRequest) SetOwnerId(v int64) *UpdateTransitRouterRouteTableRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateTransitRouterRouteTableRequest) SetResourceOwnerAccount(v string) *UpdateTransitRouterRouteTableRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterRouteTableRequest) SetResourceOwnerId(v int64) *UpdateTransitRouterRouteTableRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateTransitRouterRouteTableRequest) SetRouteTableOptions(v *UpdateTransitRouterRouteTableRequestRouteTableOptions) *UpdateTransitRouterRouteTableRequest {
	s.RouteTableOptions = v
	return s
}

func (s *UpdateTransitRouterRouteTableRequest) SetTransitRouterRouteTableDescription(v string) *UpdateTransitRouterRouteTableRequest {
	s.TransitRouterRouteTableDescription = &v
	return s
}

func (s *UpdateTransitRouterRouteTableRequest) SetTransitRouterRouteTableId(v string) *UpdateTransitRouterRouteTableRequest {
	s.TransitRouterRouteTableId = &v
	return s
}

func (s *UpdateTransitRouterRouteTableRequest) SetTransitRouterRouteTableName(v string) *UpdateTransitRouterRouteTableRequest {
	s.TransitRouterRouteTableName = &v
	return s
}

type UpdateTransitRouterRouteTableRequestRouteTableOptions struct {
	MultiRegionECMP *string `json:"MultiRegionECMP,omitempty" xml:"MultiRegionECMP,omitempty"`
}

func (s UpdateTransitRouterRouteTableRequestRouteTableOptions) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterRouteTableRequestRouteTableOptions) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterRouteTableRequestRouteTableOptions) SetMultiRegionECMP(v string) *UpdateTransitRouterRouteTableRequestRouteTableOptions {
	s.MultiRegionECMP = &v
	return s
}

type UpdateTransitRouterRouteTableResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateTransitRouterRouteTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterRouteTableResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterRouteTableResponseBody) SetRequestId(v string) *UpdateTransitRouterRouteTableResponseBody {
	s.RequestId = &v
	return s
}

type UpdateTransitRouterRouteTableResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTransitRouterRouteTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTransitRouterRouteTableResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterRouteTableResponse) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterRouteTableResponse) SetHeaders(v map[string]*string) *UpdateTransitRouterRouteTableResponse {
	s.Headers = v
	return s
}

func (s *UpdateTransitRouterRouteTableResponse) SetStatusCode(v int32) *UpdateTransitRouterRouteTableResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTransitRouterRouteTableResponse) SetBody(v *UpdateTransitRouterRouteTableResponseBody) *UpdateTransitRouterRouteTableResponse {
	s.Body = v
	return s
}

type UpdateTransitRouterVbrAttachmentAttributeRequest struct {
	// Specifies whether to allow the Enterprise Edition transit router to automatically advertise routes to the VBR. Valid values:
	//
	// *   **true**
	// *   **false**
	AutoPublishRouteEnabled *bool `json:"AutoPublishRouteEnabled,omitempty" xml:"AutoPublishRouteEnabled,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// > If you do not specify this parameter, the system automatically uses the **request ID** as the **client token**. The **request ID** may be different for each request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform only a dry run, without performing the actual request. Default values:
	//
	// *   **false** (default): performs a dry run and performs the actual request. If the request passes the dry run, a 2xx HTTP status code is returned and the operation is performed.
	// *   **true**: performs only a dry run. The system checks the request for potential issues, including missing parameter values, incorrect request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The new description of the VBR connection.
	//
	// The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with `http://` or `https://`.
	TransitRouterAttachmentDescription *string `json:"TransitRouterAttachmentDescription,omitempty" xml:"TransitRouterAttachmentDescription,omitempty"`
	// The ID of the VBR connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The new name of the VBR connection.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). The name must start with a letter.
	TransitRouterAttachmentName *string `json:"TransitRouterAttachmentName,omitempty" xml:"TransitRouterAttachmentName,omitempty"`
}

func (s UpdateTransitRouterVbrAttachmentAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterVbrAttachmentAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterVbrAttachmentAttributeRequest) SetAutoPublishRouteEnabled(v bool) *UpdateTransitRouterVbrAttachmentAttributeRequest {
	s.AutoPublishRouteEnabled = &v
	return s
}

func (s *UpdateTransitRouterVbrAttachmentAttributeRequest) SetClientToken(v string) *UpdateTransitRouterVbrAttachmentAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateTransitRouterVbrAttachmentAttributeRequest) SetDryRun(v bool) *UpdateTransitRouterVbrAttachmentAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateTransitRouterVbrAttachmentAttributeRequest) SetOwnerAccount(v string) *UpdateTransitRouterVbrAttachmentAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterVbrAttachmentAttributeRequest) SetOwnerId(v int64) *UpdateTransitRouterVbrAttachmentAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateTransitRouterVbrAttachmentAttributeRequest) SetResourceOwnerAccount(v string) *UpdateTransitRouterVbrAttachmentAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterVbrAttachmentAttributeRequest) SetResourceOwnerId(v int64) *UpdateTransitRouterVbrAttachmentAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateTransitRouterVbrAttachmentAttributeRequest) SetTransitRouterAttachmentDescription(v string) *UpdateTransitRouterVbrAttachmentAttributeRequest {
	s.TransitRouterAttachmentDescription = &v
	return s
}

func (s *UpdateTransitRouterVbrAttachmentAttributeRequest) SetTransitRouterAttachmentId(v string) *UpdateTransitRouterVbrAttachmentAttributeRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *UpdateTransitRouterVbrAttachmentAttributeRequest) SetTransitRouterAttachmentName(v string) *UpdateTransitRouterVbrAttachmentAttributeRequest {
	s.TransitRouterAttachmentName = &v
	return s
}

type UpdateTransitRouterVbrAttachmentAttributeResponseBody struct {
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateTransitRouterVbrAttachmentAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterVbrAttachmentAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterVbrAttachmentAttributeResponseBody) SetRequestId(v string) *UpdateTransitRouterVbrAttachmentAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateTransitRouterVbrAttachmentAttributeResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTransitRouterVbrAttachmentAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTransitRouterVbrAttachmentAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterVbrAttachmentAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterVbrAttachmentAttributeResponse) SetHeaders(v map[string]*string) *UpdateTransitRouterVbrAttachmentAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateTransitRouterVbrAttachmentAttributeResponse) SetStatusCode(v int32) *UpdateTransitRouterVbrAttachmentAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTransitRouterVbrAttachmentAttributeResponse) SetBody(v *UpdateTransitRouterVbrAttachmentAttributeResponseBody) *UpdateTransitRouterVbrAttachmentAttributeResponse {
	s.Body = v
	return s
}

type UpdateTransitRouterVpcAttachmentAttributeRequest struct {
	// Specifies whether to allow the Enterprise Edition transit router to advertise routes to the VPC. Valid values:
	//
	// *   **false:** (default)
	// *   **true**
	AutoPublishRouteEnabled *bool `json:"AutoPublishRouteEnabled,omitempty" xml:"AutoPublishRouteEnabled,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among all requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Default values:
	//
	// *   **false** (default): performs a dry run and sends the request.
	// *   **true**: performs a dry run. The system checks the required parameters and request syntax. If the request fails the dry run, an error message is returned. If the request passes the dry run, the system returns the ID of the request.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The description of the VPC connection.
	//
	// The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with `http://` or `https://`.
	TransitRouterAttachmentDescription *string `json:"TransitRouterAttachmentDescription,omitempty" xml:"TransitRouterAttachmentDescription,omitempty"`
	// The ID of the VPC connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The name of the VPC connection.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	TransitRouterAttachmentName *string `json:"TransitRouterAttachmentName,omitempty" xml:"TransitRouterAttachmentName,omitempty"`
}

func (s UpdateTransitRouterVpcAttachmentAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterVpcAttachmentAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterVpcAttachmentAttributeRequest) SetAutoPublishRouteEnabled(v bool) *UpdateTransitRouterVpcAttachmentAttributeRequest {
	s.AutoPublishRouteEnabled = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentAttributeRequest) SetClientToken(v string) *UpdateTransitRouterVpcAttachmentAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentAttributeRequest) SetDryRun(v bool) *UpdateTransitRouterVpcAttachmentAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentAttributeRequest) SetOwnerAccount(v string) *UpdateTransitRouterVpcAttachmentAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentAttributeRequest) SetOwnerId(v int64) *UpdateTransitRouterVpcAttachmentAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentAttributeRequest) SetResourceOwnerAccount(v string) *UpdateTransitRouterVpcAttachmentAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentAttributeRequest) SetResourceOwnerId(v int64) *UpdateTransitRouterVpcAttachmentAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentAttributeRequest) SetTransitRouterAttachmentDescription(v string) *UpdateTransitRouterVpcAttachmentAttributeRequest {
	s.TransitRouterAttachmentDescription = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentAttributeRequest) SetTransitRouterAttachmentId(v string) *UpdateTransitRouterVpcAttachmentAttributeRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentAttributeRequest) SetTransitRouterAttachmentName(v string) *UpdateTransitRouterVpcAttachmentAttributeRequest {
	s.TransitRouterAttachmentName = &v
	return s
}

type UpdateTransitRouterVpcAttachmentAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateTransitRouterVpcAttachmentAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterVpcAttachmentAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterVpcAttachmentAttributeResponseBody) SetRequestId(v string) *UpdateTransitRouterVpcAttachmentAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateTransitRouterVpcAttachmentAttributeResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTransitRouterVpcAttachmentAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTransitRouterVpcAttachmentAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterVpcAttachmentAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterVpcAttachmentAttributeResponse) SetHeaders(v map[string]*string) *UpdateTransitRouterVpcAttachmentAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentAttributeResponse) SetStatusCode(v int32) *UpdateTransitRouterVpcAttachmentAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentAttributeResponse) SetBody(v *UpdateTransitRouterVpcAttachmentAttributeResponseBody) *UpdateTransitRouterVpcAttachmentAttributeResponse {
	s.Body = v
	return s
}

type UpdateTransitRouterVpcAttachmentZonesRequest struct {
	// The zones and vSwitches that you want to add to the VPC connection.
	AddZoneMappings []*UpdateTransitRouterVpcAttachmentZonesRequestAddZoneMappings `json:"AddZoneMappings,omitempty" xml:"AddZoneMappings,omitempty" type:"Repeated"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, ClientToken is set to the value of RequestId. The value of RequestId for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**: performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request.
	DryRun       *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId      *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The zones and vSwitches that you want to remove from the VPC connection.
	RemoveZoneMappings   []*UpdateTransitRouterVpcAttachmentZonesRequestRemoveZoneMappings `json:"RemoveZoneMappings,omitempty" xml:"RemoveZoneMappings,omitempty" type:"Repeated"`
	ResourceOwnerAccount *string                                                           `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64                                                            `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The ID of the VPC connection.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
}

func (s UpdateTransitRouterVpcAttachmentZonesRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterVpcAttachmentZonesRequest) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterVpcAttachmentZonesRequest) SetAddZoneMappings(v []*UpdateTransitRouterVpcAttachmentZonesRequestAddZoneMappings) *UpdateTransitRouterVpcAttachmentZonesRequest {
	s.AddZoneMappings = v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentZonesRequest) SetClientToken(v string) *UpdateTransitRouterVpcAttachmentZonesRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentZonesRequest) SetDryRun(v bool) *UpdateTransitRouterVpcAttachmentZonesRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentZonesRequest) SetOwnerAccount(v string) *UpdateTransitRouterVpcAttachmentZonesRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentZonesRequest) SetOwnerId(v int64) *UpdateTransitRouterVpcAttachmentZonesRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentZonesRequest) SetRemoveZoneMappings(v []*UpdateTransitRouterVpcAttachmentZonesRequestRemoveZoneMappings) *UpdateTransitRouterVpcAttachmentZonesRequest {
	s.RemoveZoneMappings = v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentZonesRequest) SetResourceOwnerAccount(v string) *UpdateTransitRouterVpcAttachmentZonesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentZonesRequest) SetResourceOwnerId(v int64) *UpdateTransitRouterVpcAttachmentZonesRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentZonesRequest) SetTransitRouterAttachmentId(v string) *UpdateTransitRouterVpcAttachmentZonesRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

type UpdateTransitRouterVpcAttachmentZonesRequestAddZoneMappings struct {
	// The ID of the vSwitch that you want to add to the VPC connection.
	//
	// You can specify at most 10 vSwitches in each call.
	//
	// *   If the VPC connection belongs to the current Alibaba Cloud account, you can call the [DescribeVSwitches](~~35748~~) operation to query the IDs of the vSwitches and zones of the VPC.
	// *   If the VPC connection belongs to another Alibaba Cloud account, you can call the [ListGrantVSwitchesToCen](~~427599~~) operation to query the IDs of the vSwitches and zones of the VPC.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the zone where the vSwitch that you want to add to the VPC connection is deployed.
	//
	// You can specify at most 10 vSwitches in each call.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s UpdateTransitRouterVpcAttachmentZonesRequestAddZoneMappings) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterVpcAttachmentZonesRequestAddZoneMappings) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterVpcAttachmentZonesRequestAddZoneMappings) SetVSwitchId(v string) *UpdateTransitRouterVpcAttachmentZonesRequestAddZoneMappings {
	s.VSwitchId = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentZonesRequestAddZoneMappings) SetZoneId(v string) *UpdateTransitRouterVpcAttachmentZonesRequestAddZoneMappings {
	s.ZoneId = &v
	return s
}

type UpdateTransitRouterVpcAttachmentZonesRequestRemoveZoneMappings struct {
	// The ID of the vSwitch that you want to remove from the VPC connection.
	//
	// You can remove at most 10 vSwitches from a VPC in each call.
	VSwitchId *string `json:"VSwitchId,omitempty" xml:"VSwitchId,omitempty"`
	// The ID of the zone where the vSwitch that you want to remove from the VPC connection is deployed.
	//
	// You can remove at most 10 vSwitches from a VPC in each call.
	ZoneId *string `json:"ZoneId,omitempty" xml:"ZoneId,omitempty"`
}

func (s UpdateTransitRouterVpcAttachmentZonesRequestRemoveZoneMappings) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterVpcAttachmentZonesRequestRemoveZoneMappings) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterVpcAttachmentZonesRequestRemoveZoneMappings) SetVSwitchId(v string) *UpdateTransitRouterVpcAttachmentZonesRequestRemoveZoneMappings {
	s.VSwitchId = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentZonesRequestRemoveZoneMappings) SetZoneId(v string) *UpdateTransitRouterVpcAttachmentZonesRequestRemoveZoneMappings {
	s.ZoneId = &v
	return s
}

type UpdateTransitRouterVpcAttachmentZonesResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateTransitRouterVpcAttachmentZonesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterVpcAttachmentZonesResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterVpcAttachmentZonesResponseBody) SetRequestId(v string) *UpdateTransitRouterVpcAttachmentZonesResponseBody {
	s.RequestId = &v
	return s
}

type UpdateTransitRouterVpcAttachmentZonesResponse struct {
	Headers    map[string]*string                                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTransitRouterVpcAttachmentZonesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTransitRouterVpcAttachmentZonesResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterVpcAttachmentZonesResponse) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterVpcAttachmentZonesResponse) SetHeaders(v map[string]*string) *UpdateTransitRouterVpcAttachmentZonesResponse {
	s.Headers = v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentZonesResponse) SetStatusCode(v int32) *UpdateTransitRouterVpcAttachmentZonesResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTransitRouterVpcAttachmentZonesResponse) SetBody(v *UpdateTransitRouterVpcAttachmentZonesResponseBody) *UpdateTransitRouterVpcAttachmentZonesResponse {
	s.Body = v
	return s
}

type UpdateTransitRouterVpnAttachmentAttributeRequest struct {
	// Specifies whether to allow the transit router to automatically advertise routes to the IPsec-VPN attachment. Valid values:
	//
	// *   **true**: yes
	// *   **false**: no
	AutoPublishRouteEnabled *bool `json:"AutoPublishRouteEnabled,omitempty" xml:"AutoPublishRouteEnabled,omitempty"`
	// The client token that is used to ensure the idempotence of the request.
	//
	// You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters.
	//
	// >  If you do not set this parameter, **ClientToken** is set to the value of **RequestId**. The value of **RequestId** for each API request may be different.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// Specifies whether to perform a dry run. Valid values:
	//
	// *   **true**:performs a dry run. The system checks the required parameters, request syntax, and limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the `DryRunOperation` error code is returned.
	// *   **false** (default): performs a dry run and sends the request.
	DryRun               *bool   `json:"DryRun,omitempty" xml:"DryRun,omitempty"`
	OwnerAccount         *string `json:"OwnerAccount,omitempty" xml:"OwnerAccount,omitempty"`
	OwnerId              *int64  `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	ResourceOwnerAccount *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId      *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
	// The new description of the VPN attachment.
	//
	// The description must be 2 to 256 characters in length. The description must start with a letter but cannot start with `http://` or `https://`.
	TransitRouterAttachmentDescription *string `json:"TransitRouterAttachmentDescription,omitempty" xml:"TransitRouterAttachmentDescription,omitempty"`
	// The ID of the VPN attachment.
	TransitRouterAttachmentId *string `json:"TransitRouterAttachmentId,omitempty" xml:"TransitRouterAttachmentId,omitempty"`
	// The name of the VPN attachment.
	//
	// The name must be 2 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-). It must start with a letter.
	TransitRouterAttachmentName *string `json:"TransitRouterAttachmentName,omitempty" xml:"TransitRouterAttachmentName,omitempty"`
}

func (s UpdateTransitRouterVpnAttachmentAttributeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterVpnAttachmentAttributeRequest) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterVpnAttachmentAttributeRequest) SetAutoPublishRouteEnabled(v bool) *UpdateTransitRouterVpnAttachmentAttributeRequest {
	s.AutoPublishRouteEnabled = &v
	return s
}

func (s *UpdateTransitRouterVpnAttachmentAttributeRequest) SetClientToken(v string) *UpdateTransitRouterVpnAttachmentAttributeRequest {
	s.ClientToken = &v
	return s
}

func (s *UpdateTransitRouterVpnAttachmentAttributeRequest) SetDryRun(v bool) *UpdateTransitRouterVpnAttachmentAttributeRequest {
	s.DryRun = &v
	return s
}

func (s *UpdateTransitRouterVpnAttachmentAttributeRequest) SetOwnerAccount(v string) *UpdateTransitRouterVpnAttachmentAttributeRequest {
	s.OwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterVpnAttachmentAttributeRequest) SetOwnerId(v int64) *UpdateTransitRouterVpnAttachmentAttributeRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateTransitRouterVpnAttachmentAttributeRequest) SetResourceOwnerAccount(v string) *UpdateTransitRouterVpnAttachmentAttributeRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *UpdateTransitRouterVpnAttachmentAttributeRequest) SetResourceOwnerId(v int64) *UpdateTransitRouterVpnAttachmentAttributeRequest {
	s.ResourceOwnerId = &v
	return s
}

func (s *UpdateTransitRouterVpnAttachmentAttributeRequest) SetTransitRouterAttachmentDescription(v string) *UpdateTransitRouterVpnAttachmentAttributeRequest {
	s.TransitRouterAttachmentDescription = &v
	return s
}

func (s *UpdateTransitRouterVpnAttachmentAttributeRequest) SetTransitRouterAttachmentId(v string) *UpdateTransitRouterVpnAttachmentAttributeRequest {
	s.TransitRouterAttachmentId = &v
	return s
}

func (s *UpdateTransitRouterVpnAttachmentAttributeRequest) SetTransitRouterAttachmentName(v string) *UpdateTransitRouterVpnAttachmentAttributeRequest {
	s.TransitRouterAttachmentName = &v
	return s
}

type UpdateTransitRouterVpnAttachmentAttributeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateTransitRouterVpnAttachmentAttributeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterVpnAttachmentAttributeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterVpnAttachmentAttributeResponseBody) SetRequestId(v string) *UpdateTransitRouterVpnAttachmentAttributeResponseBody {
	s.RequestId = &v
	return s
}

type UpdateTransitRouterVpnAttachmentAttributeResponse struct {
	Headers    map[string]*string                                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTransitRouterVpnAttachmentAttributeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTransitRouterVpnAttachmentAttributeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTransitRouterVpnAttachmentAttributeResponse) GoString() string {
	return s.String()
}

func (s *UpdateTransitRouterVpnAttachmentAttributeResponse) SetHeaders(v map[string]*string) *UpdateTransitRouterVpnAttachmentAttributeResponse {
	s.Headers = v
	return s
}

func (s *UpdateTransitRouterVpnAttachmentAttributeResponse) SetStatusCode(v int32) *UpdateTransitRouterVpnAttachmentAttributeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTransitRouterVpnAttachmentAttributeResponse) SetBody(v *UpdateTransitRouterVpnAttachmentAttributeResponseBody) *UpdateTransitRouterVpnAttachmentAttributeResponse {
	s.Body = v
	return s
}

type WithdrawPublishedRouteEntriesRequest struct {
	CenId                     *string `json:"CenId,omitempty" xml:"CenId,omitempty"`
	ChildInstanceId           *string `json:"ChildInstanceId,omitempty" xml:"ChildInstanceId,omitempty"`
	ChildInstanceRegionId     *string `json:"ChildInstanceRegionId,omitempty" xml:"ChildInstanceRegionId,omitempty"`
	ChildInstanceRouteTableId *string `json:"ChildInstanceRouteTableId,omitempty" xml:"ChildInstanceRouteTableId,omitempty"`
	ChildInstanceType         *string `json:"ChildInstanceType,omitempty" xml:"ChildInstanceType,omitempty"`
	DestinationCidrBlock      *string `json:"DestinationCidrBlock,omitempty" xml:"DestinationCidrBlock,omitempty"`
	ResourceOwnerAccount      *string `json:"ResourceOwnerAccount,omitempty" xml:"ResourceOwnerAccount,omitempty"`
	ResourceOwnerId           *int64  `json:"ResourceOwnerId,omitempty" xml:"ResourceOwnerId,omitempty"`
}

func (s WithdrawPublishedRouteEntriesRequest) String() string {
	return tea.Prettify(s)
}

func (s WithdrawPublishedRouteEntriesRequest) GoString() string {
	return s.String()
}

func (s *WithdrawPublishedRouteEntriesRequest) SetCenId(v string) *WithdrawPublishedRouteEntriesRequest {
	s.CenId = &v
	return s
}

func (s *WithdrawPublishedRouteEntriesRequest) SetChildInstanceId(v string) *WithdrawPublishedRouteEntriesRequest {
	s.ChildInstanceId = &v
	return s
}

func (s *WithdrawPublishedRouteEntriesRequest) SetChildInstanceRegionId(v string) *WithdrawPublishedRouteEntriesRequest {
	s.ChildInstanceRegionId = &v
	return s
}

func (s *WithdrawPublishedRouteEntriesRequest) SetChildInstanceRouteTableId(v string) *WithdrawPublishedRouteEntriesRequest {
	s.ChildInstanceRouteTableId = &v
	return s
}

func (s *WithdrawPublishedRouteEntriesRequest) SetChildInstanceType(v string) *WithdrawPublishedRouteEntriesRequest {
	s.ChildInstanceType = &v
	return s
}

func (s *WithdrawPublishedRouteEntriesRequest) SetDestinationCidrBlock(v string) *WithdrawPublishedRouteEntriesRequest {
	s.DestinationCidrBlock = &v
	return s
}

func (s *WithdrawPublishedRouteEntriesRequest) SetResourceOwnerAccount(v string) *WithdrawPublishedRouteEntriesRequest {
	s.ResourceOwnerAccount = &v
	return s
}

func (s *WithdrawPublishedRouteEntriesRequest) SetResourceOwnerId(v int64) *WithdrawPublishedRouteEntriesRequest {
	s.ResourceOwnerId = &v
	return s
}

type WithdrawPublishedRouteEntriesResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s WithdrawPublishedRouteEntriesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s WithdrawPublishedRouteEntriesResponseBody) GoString() string {
	return s.String()
}

func (s *WithdrawPublishedRouteEntriesResponseBody) SetRequestId(v string) *WithdrawPublishedRouteEntriesResponseBody {
	s.RequestId = &v
	return s
}

type WithdrawPublishedRouteEntriesResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *WithdrawPublishedRouteEntriesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s WithdrawPublishedRouteEntriesResponse) String() string {
	return tea.Prettify(s)
}

func (s WithdrawPublishedRouteEntriesResponse) GoString() string {
	return s.String()
}

func (s *WithdrawPublishedRouteEntriesResponse) SetHeaders(v map[string]*string) *WithdrawPublishedRouteEntriesResponse {
	s.Headers = v
	return s
}

func (s *WithdrawPublishedRouteEntriesResponse) SetStatusCode(v int32) *WithdrawPublishedRouteEntriesResponse {
	s.StatusCode = &v
	return s
}

func (s *WithdrawPublishedRouteEntriesResponse) SetBody(v *WithdrawPublishedRouteEntriesResponseBody) *WithdrawPublishedRouteEntriesResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("central")
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("cbn"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   After you create a flow log, it is enabled by default. You can call this operation to enable a disabled flow log.
 * *   `ActiveFlowLog` is an asynchronous operation. After you send a request, the system returns a**request ID** and runs the task in the background. You can call the `DescribeFlowlogs` operation to query the status of a flow log.
 *     *   If a flow log is in the **Modifying** state, the flow log is being enabled. In this case, you can query the flow log but cannot perform other operations.
 *     *   If a flow log is in the **Active** state, the flow log is enabled.
 *
 * @param request ActiveFlowLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ActiveFlowLogResponse
 */
func (client *Client) ActiveFlowLogWithOptions(request *ActiveFlowLogRequest, runtime *util.RuntimeOptions) (_result *ActiveFlowLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.FlowLogId)) {
		query["FlowLogId"] = request.FlowLogId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ActiveFlowLog"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ActiveFlowLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   After you create a flow log, it is enabled by default. You can call this operation to enable a disabled flow log.
 * *   `ActiveFlowLog` is an asynchronous operation. After you send a request, the system returns a**request ID** and runs the task in the background. You can call the `DescribeFlowlogs` operation to query the status of a flow log.
 *     *   If a flow log is in the **Modifying** state, the flow log is being enabled. In this case, you can query the flow log but cannot perform other operations.
 *     *   If a flow log is in the **Active** state, the flow log is enabled.
 *
 * @param request ActiveFlowLogRequest
 * @return ActiveFlowLogResponse
 */
func (client *Client) ActiveFlowLog(request *ActiveFlowLogRequest) (_result *ActiveFlowLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ActiveFlowLogResponse{}
	_body, _err := client.ActiveFlowLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **AddTrafficMatchRuleToTrafficMarkingPolicy** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTrafficMarkingPolicies** operation to query the status of a traffic classification rule.
 * *   If a traffic classification rule is in the **Creating** state, the traffic classification rule is being created. In this case, you can query the traffic classification rule but cannot perform other operations.
 * *   If a traffic classification rule is in the **Active** state, the traffic classification rule is added to the traffic marking policy.
 *
 * @param request AddTrafficMatchRuleToTrafficMarkingPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddTrafficMatchRuleToTrafficMarkingPolicyResponse
 */
func (client *Client) AddTrafficMatchRuleToTrafficMarkingPolicyWithOptions(request *AddTrafficMatchRuleToTrafficMarkingPolicyRequest, runtime *util.RuntimeOptions) (_result *AddTrafficMatchRuleToTrafficMarkingPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMarkingPolicyId)) {
		query["TrafficMarkingPolicyId"] = request.TrafficMarkingPolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMatchRules)) {
		query["TrafficMatchRules"] = request.TrafficMatchRules
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddTrafficMatchRuleToTrafficMarkingPolicy"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddTrafficMatchRuleToTrafficMarkingPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **AddTrafficMatchRuleToTrafficMarkingPolicy** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTrafficMarkingPolicies** operation to query the status of a traffic classification rule.
 * *   If a traffic classification rule is in the **Creating** state, the traffic classification rule is being created. In this case, you can query the traffic classification rule but cannot perform other operations.
 * *   If a traffic classification rule is in the **Active** state, the traffic classification rule is added to the traffic marking policy.
 *
 * @param request AddTrafficMatchRuleToTrafficMarkingPolicyRequest
 * @return AddTrafficMatchRuleToTrafficMarkingPolicyResponse
 */
func (client *Client) AddTrafficMatchRuleToTrafficMarkingPolicy(request *AddTrafficMatchRuleToTrafficMarkingPolicyRequest) (_result *AddTrafficMatchRuleToTrafficMarkingPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddTrafficMatchRuleToTrafficMarkingPolicyResponse{}
	_body, _err := client.AddTrafficMatchRuleToTrafficMarkingPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated : AddTraficMatchRuleToTrafficMarkingPolicy is deprecated, please use Cbn::2017-09-12::AddTrafficMatchRuleToTrafficMarkingPolicy instead.
 * The ID of the request.
 *
 * @param request AddTraficMatchRuleToTrafficMarkingPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddTraficMatchRuleToTrafficMarkingPolicyResponse
 */
// Deprecated
func (client *Client) AddTraficMatchRuleToTrafficMarkingPolicyWithOptions(request *AddTraficMatchRuleToTrafficMarkingPolicyRequest, runtime *util.RuntimeOptions) (_result *AddTraficMatchRuleToTrafficMarkingPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMarkingPolicyId)) {
		query["TrafficMarkingPolicyId"] = request.TrafficMarkingPolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMatchRules)) {
		query["TrafficMatchRules"] = request.TrafficMatchRules
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddTraficMatchRuleToTrafficMarkingPolicy"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddTraficMatchRuleToTrafficMarkingPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated : AddTraficMatchRuleToTrafficMarkingPolicy is deprecated, please use Cbn::2017-09-12::AddTrafficMatchRuleToTrafficMarkingPolicy instead.
 * The ID of the request.
 *
 * @param request AddTraficMatchRuleToTrafficMarkingPolicyRequest
 * @return AddTraficMatchRuleToTrafficMarkingPolicyResponse
 */
// Deprecated
func (client *Client) AddTraficMatchRuleToTrafficMarkingPolicy(request *AddTraficMatchRuleToTrafficMarkingPolicyRequest) (_result *AddTraficMatchRuleToTrafficMarkingPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddTraficMatchRuleToTrafficMarkingPolicyResponse{}
	_body, _err := client.AddTraficMatchRuleToTrafficMarkingPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can associate multiple bandwidth plans with a CEN instance. However, the pair of areas connected by each bandwidth plan must be unique.
 * For example, if a CEN instance is associated with a bandwidth plan that connects networks in the Chinese mainland, you cannot associate another bandwidth plan that also connects networks in the Chinese mainland with the CEN instance. However, you can associate a bandwidth plan that connects the Chinese mainland to North America with the CEN instance.
 *
 * @param request AssociateCenBandwidthPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateCenBandwidthPackageResponse
 */
func (client *Client) AssociateCenBandwidthPackageWithOptions(request *AssociateCenBandwidthPackageRequest, runtime *util.RuntimeOptions) (_result *AssociateCenBandwidthPackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenBandwidthPackageId)) {
		query["CenBandwidthPackageId"] = request.CenBandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateCenBandwidthPackage"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateCenBandwidthPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can associate multiple bandwidth plans with a CEN instance. However, the pair of areas connected by each bandwidth plan must be unique.
 * For example, if a CEN instance is associated with a bandwidth plan that connects networks in the Chinese mainland, you cannot associate another bandwidth plan that also connects networks in the Chinese mainland with the CEN instance. However, you can associate a bandwidth plan that connects the Chinese mainland to North America with the CEN instance.
 *
 * @param request AssociateCenBandwidthPackageRequest
 * @return AssociateCenBandwidthPackageResponse
 */
func (client *Client) AssociateCenBandwidthPackage(request *AssociateCenBandwidthPackageRequest) (_result *AssociateCenBandwidthPackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateCenBandwidthPackageResponse{}
	_body, _err := client.AssociateCenBandwidthPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you create a network instance connection on a transit router, you can configure an associated forwarding correlation to associate the network instance connection with a route table. Then, the network instance connection can forward network traffic based on the associated route table. Before you begin, we recommend that you take note of the following rules:
 * *   Only Enterprise Edition transit routers support associated forwarding correlations. For more information about the regions and zones that support Enterprise Edition transit routers, see [Transit routers](~~181681~~).
 * *   **AssociateTransitRouterAttachmentWithRouteTable** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterRouteTableAssociations** operation to query the status of an associated forwarding correlation.
 *     *   If an associated forwarding correlation is in the **Associating** state, the associated forwarding correlation is being created. You can query the associated forwarding correlation but cannot perform other operations.
 *     *   If an associated forwarding correlation is in the **Active** state, the associated forwarding correlation is created.
 *
 * @param request AssociateTransitRouterAttachmentWithRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AssociateTransitRouterAttachmentWithRouteTableResponse
 */
func (client *Client) AssociateTransitRouterAttachmentWithRouteTableWithOptions(request *AssociateTransitRouterAttachmentWithRouteTableRequest, runtime *util.RuntimeOptions) (_result *AssociateTransitRouterAttachmentWithRouteTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableId)) {
		query["TransitRouterRouteTableId"] = request.TransitRouterRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateTransitRouterAttachmentWithRouteTable"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateTransitRouterAttachmentWithRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you create a network instance connection on a transit router, you can configure an associated forwarding correlation to associate the network instance connection with a route table. Then, the network instance connection can forward network traffic based on the associated route table. Before you begin, we recommend that you take note of the following rules:
 * *   Only Enterprise Edition transit routers support associated forwarding correlations. For more information about the regions and zones that support Enterprise Edition transit routers, see [Transit routers](~~181681~~).
 * *   **AssociateTransitRouterAttachmentWithRouteTable** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterRouteTableAssociations** operation to query the status of an associated forwarding correlation.
 *     *   If an associated forwarding correlation is in the **Associating** state, the associated forwarding correlation is being created. You can query the associated forwarding correlation but cannot perform other operations.
 *     *   If an associated forwarding correlation is in the **Active** state, the associated forwarding correlation is created.
 *
 * @param request AssociateTransitRouterAttachmentWithRouteTableRequest
 * @return AssociateTransitRouterAttachmentWithRouteTableResponse
 */
func (client *Client) AssociateTransitRouterAttachmentWithRouteTable(request *AssociateTransitRouterAttachmentWithRouteTableRequest) (_result *AssociateTransitRouterAttachmentWithRouteTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateTransitRouterAttachmentWithRouteTableResponse{}
	_body, _err := client.AssociateTransitRouterAttachmentWithRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AssociateTransitRouterMulticastDomainWithOptions(request *AssociateTransitRouterMulticastDomainRequest, runtime *util.RuntimeOptions) (_result *AssociateTransitRouterMulticastDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterMulticastDomainId)) {
		query["TransitRouterMulticastDomainId"] = request.TransitRouterMulticastDomainId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchIds)) {
		query["VSwitchIds"] = request.VSwitchIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AssociateTransitRouterMulticastDomain"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AssociateTransitRouterMulticastDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AssociateTransitRouterMulticastDomain(request *AssociateTransitRouterMulticastDomainRequest) (_result *AssociateTransitRouterMulticastDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AssociateTransitRouterMulticastDomainResponse{}
	_body, _err := client.AssociateTransitRouterMulticastDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * CEN allows you to attach a network instance that belongs to another Alibaba Cloud account to your CEN instance. Before you attach the network instance, CEN must acquire permissions to access the network instance that belongs to another Alibaba Cloud account.
 * *   For more information about how to grant CEN permissions on virtual private clouds (VPCs) that belong to another Alibaba Cloud account, see [GrantInstanceToCen](~~126224~~).
 * *   For more information about how to grant CEN permissions on Cloud Connect Network (CCN) instances that belong to another Alibaba Cloud account, see [GrantInstanceToCbn](~~126141~~).
 * *   By default, you cannot grant permissions on virtual border routers (VBRs) that belong to another Alibaba Cloud account to a CEN instance. If you need to use this feature, contact your account manager.
 *
 * @param request AttachCenChildInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachCenChildInstanceResponse
 */
func (client *Client) AttachCenChildInstanceWithOptions(request *AttachCenChildInstanceRequest, runtime *util.RuntimeOptions) (_result *AttachCenChildInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceId)) {
		query["ChildInstanceId"] = request.ChildInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceOwnerId)) {
		query["ChildInstanceOwnerId"] = request.ChildInstanceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRegionId)) {
		query["ChildInstanceRegionId"] = request.ChildInstanceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceType)) {
		query["ChildInstanceType"] = request.ChildInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachCenChildInstance"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachCenChildInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * CEN allows you to attach a network instance that belongs to another Alibaba Cloud account to your CEN instance. Before you attach the network instance, CEN must acquire permissions to access the network instance that belongs to another Alibaba Cloud account.
 * *   For more information about how to grant CEN permissions on virtual private clouds (VPCs) that belong to another Alibaba Cloud account, see [GrantInstanceToCen](~~126224~~).
 * *   For more information about how to grant CEN permissions on Cloud Connect Network (CCN) instances that belong to another Alibaba Cloud account, see [GrantInstanceToCbn](~~126141~~).
 * *   By default, you cannot grant permissions on virtual border routers (VBRs) that belong to another Alibaba Cloud account to a CEN instance. If you need to use this feature, contact your account manager.
 *
 * @param request AttachCenChildInstanceRequest
 * @return AttachCenChildInstanceResponse
 */
func (client *Client) AttachCenChildInstance(request *AttachCenChildInstanceRequest) (_result *AttachCenChildInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachCenChildInstanceResponse{}
	_body, _err := client.AttachCenChildInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CheckTransitRouterServiceWithOptions(request *CheckTransitRouterServiceRequest, runtime *util.RuntimeOptions) (_result *CheckTransitRouterServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckTransitRouterService"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckTransitRouterServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CheckTransitRouterService(request *CheckTransitRouterServiceRequest) (_result *CheckTransitRouterServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckTransitRouterServiceResponse{}
	_body, _err := client.CheckTransitRouterServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The description of the CEN instance.
 * The description must be 2 to 256 characters in length. It must start with a letter and cannot start with `http://` or `https://`.
 *
 * @param request CreateCenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCenResponse
 */
func (client *Client) CreateCenWithOptions(request *CreateCenRequest, runtime *util.RuntimeOptions) (_result *CreateCenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProtectionLevel)) {
		query["ProtectionLevel"] = request.ProtectionLevel
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCen"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The description of the CEN instance.
 * The description must be 2 to 256 characters in length. It must start with a letter and cannot start with `http://` or `https://`.
 *
 * @param request CreateCenRequest
 * @return CreateCenResponse
 */
func (client *Client) CreateCen(request *CreateCenRequest) (_result *CreateCenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCenResponse{}
	_body, _err := client.CreateCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You must specify the areas to be connected when you create a bandwidth plan. An area contains one or more Alibaba Cloud regions. When you select areas for a bandwidth plan, make sure that the areas contain the regions that you want to connect. For more information about the supported areas and regions, see [Purchase a bandwidth plan](~~181560~~).
 * *   For more information about the billing rules, see [Billing](~~189836~~).
 * *   **CreateCenBandwidthPackage** is an asynchronous operation. After you send a request, the system returns a bandwidth plan instance ID and runs the task in the background. You can call the **DescribeCenBandwidthPackages** operation to query the status of a bandwidth plan. If a bandwidth plan is in the **Idle** or **InUse** state, the bandwidth plan is created.
 *
 * @param request CreateCenBandwidthPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCenBandwidthPackageResponse
 */
func (client *Client) CreateCenBandwidthPackageWithOptions(request *CreateCenBandwidthPackageRequest, runtime *util.RuntimeOptions) (_result *CreateCenBandwidthPackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPay)) {
		query["AutoPay"] = request.AutoPay
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenew)) {
		query["AutoRenew"] = request.AutoRenew
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRenewDuration)) {
		query["AutoRenewDuration"] = request.AutoRenewDuration
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.BandwidthPackageChargeType)) {
		query["BandwidthPackageChargeType"] = request.BandwidthPackageChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.GeographicRegionAId)) {
		query["GeographicRegionAId"] = request.GeographicRegionAId
	}

	if !tea.BoolValue(util.IsUnset(request.GeographicRegionBId)) {
		query["GeographicRegionBId"] = request.GeographicRegionBId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Period)) {
		query["Period"] = request.Period
	}

	if !tea.BoolValue(util.IsUnset(request.PricingCycle)) {
		query["PricingCycle"] = request.PricingCycle
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCenBandwidthPackage"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCenBandwidthPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You must specify the areas to be connected when you create a bandwidth plan. An area contains one or more Alibaba Cloud regions. When you select areas for a bandwidth plan, make sure that the areas contain the regions that you want to connect. For more information about the supported areas and regions, see [Purchase a bandwidth plan](~~181560~~).
 * *   For more information about the billing rules, see [Billing](~~189836~~).
 * *   **CreateCenBandwidthPackage** is an asynchronous operation. After you send a request, the system returns a bandwidth plan instance ID and runs the task in the background. You can call the **DescribeCenBandwidthPackages** operation to query the status of a bandwidth plan. If a bandwidth plan is in the **Idle** or **InUse** state, the bandwidth plan is created.
 *
 * @param request CreateCenBandwidthPackageRequest
 * @return CreateCenBandwidthPackageResponse
 */
func (client *Client) CreateCenBandwidthPackage(request *CreateCenBandwidthPackageRequest) (_result *CreateCenBandwidthPackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCenBandwidthPackageResponse{}
	_body, _err := client.CreateCenBandwidthPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can add routes only to virtual private clouds (VPCs) or virtual border routers (VBRs) that are connected to an Enterprise Edition transit router.
 * *   By default, the next hop of the routes is the **transit router connection**, which is the connection between the VBR and the Enterprise Edition transit router. You cannot modify the next hop.
 * *   **CreateCenChildInstanceRouteEntryToAttachment** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **DescribeRouteEntryList** operation to query the status of a route.
 *     *   If a route is in the **Pending** state, the route is being created. You can query the route but cannot perform other operations.
 *     *   If a route is in the **Available** state, the route is created.
 *
 * @param request CreateCenChildInstanceRouteEntryToAttachmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCenChildInstanceRouteEntryToAttachmentResponse
 */
func (client *Client) CreateCenChildInstanceRouteEntryToAttachmentWithOptions(request *CreateCenChildInstanceRouteEntryToAttachmentRequest, runtime *util.RuntimeOptions) (_result *CreateCenChildInstanceRouteEntryToAttachmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlock)) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCenChildInstanceRouteEntryToAttachment"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCenChildInstanceRouteEntryToAttachmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can add routes only to virtual private clouds (VPCs) or virtual border routers (VBRs) that are connected to an Enterprise Edition transit router.
 * *   By default, the next hop of the routes is the **transit router connection**, which is the connection between the VBR and the Enterprise Edition transit router. You cannot modify the next hop.
 * *   **CreateCenChildInstanceRouteEntryToAttachment** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **DescribeRouteEntryList** operation to query the status of a route.
 *     *   If a route is in the **Pending** state, the route is being created. You can query the route but cannot perform other operations.
 *     *   If a route is in the **Available** state, the route is created.
 *
 * @param request CreateCenChildInstanceRouteEntryToAttachmentRequest
 * @return CreateCenChildInstanceRouteEntryToAttachmentResponse
 */
func (client *Client) CreateCenChildInstanceRouteEntryToAttachment(request *CreateCenChildInstanceRouteEntryToAttachmentRequest) (_result *CreateCenChildInstanceRouteEntryToAttachmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCenChildInstanceRouteEntryToAttachmentResponse{}
	_body, _err := client.CreateCenChildInstanceRouteEntryToAttachmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   By default, the CreateCenChildInstanceRouteEntryToCen operation is unavailable. To call this operation,[submit a ticket](https://workorder-intl.console.aliyun.com/#/ticket/createIndex).
 * *   You cannot add a route entry to an Enterprise Edition transit router by calling the CreateCenChildInstanceRouteEntryToCen operation.
 * *   By default, the next hop of the route entry is the regional gateway of the Cloud Enterprise Network (CEN) instance. You cannot modify the next hop.
 *
 * @param request CreateCenChildInstanceRouteEntryToCenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCenChildInstanceRouteEntryToCenResponse
 */
func (client *Client) CreateCenChildInstanceRouteEntryToCenWithOptions(request *CreateCenChildInstanceRouteEntryToCenRequest, runtime *util.RuntimeOptions) (_result *CreateCenChildInstanceRouteEntryToCenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceAliUid)) {
		query["ChildInstanceAliUid"] = request.ChildInstanceAliUid
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceId)) {
		query["ChildInstanceId"] = request.ChildInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRegionId)) {
		query["ChildInstanceRegionId"] = request.ChildInstanceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceType)) {
		query["ChildInstanceType"] = request.ChildInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlock)) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCenChildInstanceRouteEntryToCen"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCenChildInstanceRouteEntryToCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   By default, the CreateCenChildInstanceRouteEntryToCen operation is unavailable. To call this operation,[submit a ticket](https://workorder-intl.console.aliyun.com/#/ticket/createIndex).
 * *   You cannot add a route entry to an Enterprise Edition transit router by calling the CreateCenChildInstanceRouteEntryToCen operation.
 * *   By default, the next hop of the route entry is the regional gateway of the Cloud Enterprise Network (CEN) instance. You cannot modify the next hop.
 *
 * @param request CreateCenChildInstanceRouteEntryToCenRequest
 * @return CreateCenChildInstanceRouteEntryToCenResponse
 */
func (client *Client) CreateCenChildInstanceRouteEntryToCen(request *CreateCenChildInstanceRouteEntryToCenRequest) (_result *CreateCenChildInstanceRouteEntryToCenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCenChildInstanceRouteEntryToCenResponse{}
	_body, _err := client.CreateCenChildInstanceRouteEntryToCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Only inter-region connections created on Enterprise Edition transit routers support QoS policies.
 *         If your inter-region connection uses test bandwidth, you cannot create QoS policies for the inter-region connection.
 * *   QoS policies apply only to outbound traffic on Enterprise Edition transit routers.
 *         If you create an inter-region connection between the China (Hangzhou) region and the China (Qingdao) region, and create QoS policies for the transit router in the China (Hangzhou) region and the transit router in the China (Qingdao) region, the QoS policies apply only to the network traffic that flows from China (Hangzhou) to China (Qingdao). QoS policies allocate bandwidth resources to different services.
 * *   **CreateCenInterRegionTrafficQosPolicy** is an asynchronous operation. After you send a request, the system returns a QoS policy ID and runs the task in the system background. You can call **ListCenInterRegionTrafficQosPolicies** to query the status of a QoS policy.
 *     *   If a QoS policy is in the **Creating** state, the QoS policy is being created. You can query the QoS policy but cannot perform other operations.
 *     *   If a QoS policy is in the **Active** state, the QoS policy is created.
 * ### Prerequisites
 * Make sure that the following requirements are met before you call the **CreateCenInterRegionTrafficQosPolicy** operation:
 * *   An inter-region connection is created. For more information, see [CreateTransitRouterPeerAttachment](~~261363~~).
 * *   A traffic marking policy is created. For more information, see [CreateTrafficMarkingPolicy](~~419025~~).
 *
 * @param request CreateCenInterRegionTrafficQosPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCenInterRegionTrafficQosPolicyResponse
 */
func (client *Client) CreateCenInterRegionTrafficQosPolicyWithOptions(request *CreateCenInterRegionTrafficQosPolicyRequest, runtime *util.RuntimeOptions) (_result *CreateCenInterRegionTrafficQosPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficQosPolicyDescription)) {
		query["TrafficQosPolicyDescription"] = request.TrafficQosPolicyDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficQosPolicyName)) {
		query["TrafficQosPolicyName"] = request.TrafficQosPolicyName
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficQosQueues)) {
		query["TrafficQosQueues"] = request.TrafficQosQueues
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCenInterRegionTrafficQosPolicy"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCenInterRegionTrafficQosPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Only inter-region connections created on Enterprise Edition transit routers support QoS policies.
 *         If your inter-region connection uses test bandwidth, you cannot create QoS policies for the inter-region connection.
 * *   QoS policies apply only to outbound traffic on Enterprise Edition transit routers.
 *         If you create an inter-region connection between the China (Hangzhou) region and the China (Qingdao) region, and create QoS policies for the transit router in the China (Hangzhou) region and the transit router in the China (Qingdao) region, the QoS policies apply only to the network traffic that flows from China (Hangzhou) to China (Qingdao). QoS policies allocate bandwidth resources to different services.
 * *   **CreateCenInterRegionTrafficQosPolicy** is an asynchronous operation. After you send a request, the system returns a QoS policy ID and runs the task in the system background. You can call **ListCenInterRegionTrafficQosPolicies** to query the status of a QoS policy.
 *     *   If a QoS policy is in the **Creating** state, the QoS policy is being created. You can query the QoS policy but cannot perform other operations.
 *     *   If a QoS policy is in the **Active** state, the QoS policy is created.
 * ### Prerequisites
 * Make sure that the following requirements are met before you call the **CreateCenInterRegionTrafficQosPolicy** operation:
 * *   An inter-region connection is created. For more information, see [CreateTransitRouterPeerAttachment](~~261363~~).
 * *   A traffic marking policy is created. For more information, see [CreateTrafficMarkingPolicy](~~419025~~).
 *
 * @param request CreateCenInterRegionTrafficQosPolicyRequest
 * @return CreateCenInterRegionTrafficQosPolicyResponse
 */
func (client *Client) CreateCenInterRegionTrafficQosPolicy(request *CreateCenInterRegionTrafficQosPolicyRequest) (_result *CreateCenInterRegionTrafficQosPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCenInterRegionTrafficQosPolicyResponse{}
	_body, _err := client.CreateCenInterRegionTrafficQosPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request CreateCenInterRegionTrafficQosQueueRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCenInterRegionTrafficQosQueueResponse
 */
func (client *Client) CreateCenInterRegionTrafficQosQueueWithOptions(request *CreateCenInterRegionTrafficQosQueueRequest, runtime *util.RuntimeOptions) (_result *CreateCenInterRegionTrafficQosQueueResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Dscps)) {
		query["Dscps"] = request.Dscps
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.QosQueueDescription)) {
		query["QosQueueDescription"] = request.QosQueueDescription
	}

	if !tea.BoolValue(util.IsUnset(request.QosQueueName)) {
		query["QosQueueName"] = request.QosQueueName
	}

	if !tea.BoolValue(util.IsUnset(request.RemainBandwidthPercent)) {
		query["RemainBandwidthPercent"] = request.RemainBandwidthPercent
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficQosPolicyId)) {
		query["TrafficQosPolicyId"] = request.TrafficQosPolicyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCenInterRegionTrafficQosQueue"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCenInterRegionTrafficQosQueueResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request CreateCenInterRegionTrafficQosQueueRequest
 * @return CreateCenInterRegionTrafficQosQueueResponse
 */
func (client *Client) CreateCenInterRegionTrafficQosQueue(request *CreateCenInterRegionTrafficQosQueueRequest) (_result *CreateCenInterRegionTrafficQosQueueResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCenInterRegionTrafficQosQueueResponse{}
	_body, _err := client.CreateCenInterRegionTrafficQosQueueWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The IDs of the source regions from which routes are evaluated. You can enter at most 32 region IDs.
 * You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
 *
 * @param request CreateCenRouteMapRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCenRouteMapResponse
 */
func (client *Client) CreateCenRouteMapWithOptions(request *CreateCenRouteMapRequest, runtime *util.RuntimeOptions) (_result *CreateCenRouteMapResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AsPathMatchMode)) {
		query["AsPathMatchMode"] = request.AsPathMatchMode
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.CenRegionId)) {
		query["CenRegionId"] = request.CenRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.CidrMatchMode)) {
		query["CidrMatchMode"] = request.CidrMatchMode
	}

	if !tea.BoolValue(util.IsUnset(request.CommunityMatchMode)) {
		query["CommunityMatchMode"] = request.CommunityMatchMode
	}

	if !tea.BoolValue(util.IsUnset(request.CommunityOperateMode)) {
		query["CommunityOperateMode"] = request.CommunityOperateMode
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationChildInstanceTypes)) {
		query["DestinationChildInstanceTypes"] = request.DestinationChildInstanceTypes
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlocks)) {
		query["DestinationCidrBlocks"] = request.DestinationCidrBlocks
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationInstanceIds)) {
		query["DestinationInstanceIds"] = request.DestinationInstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationInstanceIdsReverseMatch)) {
		query["DestinationInstanceIdsReverseMatch"] = request.DestinationInstanceIdsReverseMatch
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationRouteTableIds)) {
		query["DestinationRouteTableIds"] = request.DestinationRouteTableIds
	}

	if !tea.BoolValue(util.IsUnset(request.MapResult)) {
		query["MapResult"] = request.MapResult
	}

	if !tea.BoolValue(util.IsUnset(request.MatchAddressType)) {
		query["MatchAddressType"] = request.MatchAddressType
	}

	if !tea.BoolValue(util.IsUnset(request.MatchAsns)) {
		query["MatchAsns"] = request.MatchAsns
	}

	if !tea.BoolValue(util.IsUnset(request.MatchCommunitySet)) {
		query["MatchCommunitySet"] = request.MatchCommunitySet
	}

	if !tea.BoolValue(util.IsUnset(request.NextPriority)) {
		query["NextPriority"] = request.NextPriority
	}

	if !tea.BoolValue(util.IsUnset(request.OperateCommunitySet)) {
		query["OperateCommunitySet"] = request.OperateCommunitySet
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Preference)) {
		query["Preference"] = request.Preference
	}

	if !tea.BoolValue(util.IsUnset(request.PrependAsPath)) {
		query["PrependAsPath"] = request.PrependAsPath
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTypes)) {
		query["RouteTypes"] = request.RouteTypes
	}

	if !tea.BoolValue(util.IsUnset(request.SourceChildInstanceTypes)) {
		query["SourceChildInstanceTypes"] = request.SourceChildInstanceTypes
	}

	if !tea.BoolValue(util.IsUnset(request.SourceInstanceIds)) {
		query["SourceInstanceIds"] = request.SourceInstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.SourceInstanceIdsReverseMatch)) {
		query["SourceInstanceIdsReverseMatch"] = request.SourceInstanceIdsReverseMatch
	}

	if !tea.BoolValue(util.IsUnset(request.SourceRegionIds)) {
		query["SourceRegionIds"] = request.SourceRegionIds
	}

	if !tea.BoolValue(util.IsUnset(request.SourceRouteTableIds)) {
		query["SourceRouteTableIds"] = request.SourceRouteTableIds
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableId)) {
		query["TransitRouterRouteTableId"] = request.TransitRouterRouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.TransmitDirection)) {
		query["TransmitDirection"] = request.TransmitDirection
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateCenRouteMap"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateCenRouteMapResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The IDs of the source regions from which routes are evaluated. You can enter at most 32 region IDs.
 * You can call the [DescribeChildInstanceRegions](~~132080~~) operation to query the most recent region list.
 *
 * @param request CreateCenRouteMapRequest
 * @return CreateCenRouteMapResponse
 */
func (client *Client) CreateCenRouteMap(request *CreateCenRouteMapRequest) (_result *CreateCenRouteMapResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateCenRouteMapResponse{}
	_body, _err := client.CreateCenRouteMapWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Flow logs are used to capture the information about network traffic between transit routers and between virtual border routers (VBRs). Before you create a flow log, take note of the following items:
 * *   Flow logs are supported only by Enterprise Edition transit routers.
 * *   Only flow logs in some regions can capture the information about network traffic over VBR connections. For more information, see [Limits](~~339822~~).
 * *   Flow logs are used to capture the information about outbound traffic on transit routers. Information about inbound traffic on transit routers is not captured.
 *     For example, an Elastic Compute Service (ECS) instance in the US (Silicon Valley) region accesses an ECS instance in the US (Virginia) region through CEN. After you enable the flow log feature for the transit router in the US (Virginia) region, you can check the log entries about packets sent from the ECS instance in the US (Virginia) region to the ECS instance in the US (Silicon Valley) region. However, packets sent from the ECS instance in the US (Silicon Valley) region to the ECS instance in the US (Virginia) region are not recorded. If you want to record the packets sent from the ECS instance in the US (Silicon Valley) region to the ECS instance in the US (Virginia) region, you must also enable the flow log feature on the transit router that is in the US (Silicon Valley) region.
 * *   `CreateFlowLog` is an asynchronous operation. After you send a request, the system returns a flow log ID and runs the task in the background. You can call the `DescribeFlowLogs` operation to query the status of a flow log.
 *     *   If a flow log is in the **Creating** state, the flow log is being created. In this case, you can query the flow log but cannot perform other operations.
 *     *   If a flow log is in the **Active** state, the flow log is created.
 * # Prerequisites
 * An inter-region connection or a VBR connection is created. For more information, see [CreateTransitRouterPeerAttachment](~~261363~~) or [CreateTransitRouterVbrAttachment](~~261361~~).
 *
 * @param request CreateFlowlogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFlowlogResponse
 */
func (client *Client) CreateFlowlogWithOptions(request *CreateFlowlogRequest, runtime *util.RuntimeOptions) (_result *CreateFlowlogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.FlowLogName)) {
		query["FlowLogName"] = request.FlowLogName
	}

	if !tea.BoolValue(util.IsUnset(request.Interval)) {
		query["Interval"] = request.Interval
	}

	if !tea.BoolValue(util.IsUnset(request.LogStoreName)) {
		query["LogStoreName"] = request.LogStoreName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		query["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateFlowlog"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateFlowlogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Flow logs are used to capture the information about network traffic between transit routers and between virtual border routers (VBRs). Before you create a flow log, take note of the following items:
 * *   Flow logs are supported only by Enterprise Edition transit routers.
 * *   Only flow logs in some regions can capture the information about network traffic over VBR connections. For more information, see [Limits](~~339822~~).
 * *   Flow logs are used to capture the information about outbound traffic on transit routers. Information about inbound traffic on transit routers is not captured.
 *     For example, an Elastic Compute Service (ECS) instance in the US (Silicon Valley) region accesses an ECS instance in the US (Virginia) region through CEN. After you enable the flow log feature for the transit router in the US (Virginia) region, you can check the log entries about packets sent from the ECS instance in the US (Virginia) region to the ECS instance in the US (Silicon Valley) region. However, packets sent from the ECS instance in the US (Silicon Valley) region to the ECS instance in the US (Virginia) region are not recorded. If you want to record the packets sent from the ECS instance in the US (Silicon Valley) region to the ECS instance in the US (Virginia) region, you must also enable the flow log feature on the transit router that is in the US (Silicon Valley) region.
 * *   `CreateFlowLog` is an asynchronous operation. After you send a request, the system returns a flow log ID and runs the task in the background. You can call the `DescribeFlowLogs` operation to query the status of a flow log.
 *     *   If a flow log is in the **Creating** state, the flow log is being created. In this case, you can query the flow log but cannot perform other operations.
 *     *   If a flow log is in the **Active** state, the flow log is created.
 * # Prerequisites
 * An inter-region connection or a VBR connection is created. For more information, see [CreateTransitRouterPeerAttachment](~~261363~~) or [CreateTransitRouterVbrAttachment](~~261361~~).
 *
 * @param request CreateFlowlogRequest
 * @return CreateFlowlogResponse
 */
func (client *Client) CreateFlowlog(request *CreateFlowlogRequest) (_result *CreateFlowlogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateFlowlogResponse{}
	_body, _err := client.CreateFlowlogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Only Enterprise Edition transit routers support traffic marking policies.
 * *   **CreateTrafficMarkingPolicy** is an asynchronous operation. After you send a request, the system returns a traffic marking policy ID and runs the task in the background. You can call the **ListTrafficMarkingPolicies** operation to query the status of a traffic marking policy.
 *     *   If a traffic marking policy is in the **Creating** state, the traffic marking policy is being created. You can query the traffic marking policy but cannot perform other operations.
 *     *   If a traffic marking policy is in the **Active** state, the traffic marking policy is created.
 *
 * @param request CreateTrafficMarkingPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTrafficMarkingPolicyResponse
 */
func (client *Client) CreateTrafficMarkingPolicyWithOptions(request *CreateTrafficMarkingPolicyRequest, runtime *util.RuntimeOptions) (_result *CreateTrafficMarkingPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.MarkingDscp)) {
		query["MarkingDscp"] = request.MarkingDscp
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMarkingPolicyDescription)) {
		query["TrafficMarkingPolicyDescription"] = request.TrafficMarkingPolicyDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMarkingPolicyName)) {
		query["TrafficMarkingPolicyName"] = request.TrafficMarkingPolicyName
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMatchRules)) {
		query["TrafficMatchRules"] = request.TrafficMatchRules
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTrafficMarkingPolicy"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTrafficMarkingPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Only Enterprise Edition transit routers support traffic marking policies.
 * *   **CreateTrafficMarkingPolicy** is an asynchronous operation. After you send a request, the system returns a traffic marking policy ID and runs the task in the background. You can call the **ListTrafficMarkingPolicies** operation to query the status of a traffic marking policy.
 *     *   If a traffic marking policy is in the **Creating** state, the traffic marking policy is being created. You can query the traffic marking policy but cannot perform other operations.
 *     *   If a traffic marking policy is in the **Active** state, the traffic marking policy is created.
 *
 * @param request CreateTrafficMarkingPolicyRequest
 * @return CreateTrafficMarkingPolicyResponse
 */
func (client *Client) CreateTrafficMarkingPolicy(request *CreateTrafficMarkingPolicyRequest) (_result *CreateTrafficMarkingPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTrafficMarkingPolicyResponse{}
	_body, _err := client.CreateTrafficMarkingPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you add an aggregate route to a route table of an Enterprise Edition transit router, the Enterprise Edition transit router advertises its routes only to route tables of virtual private clouds (VPCs) that are associated with a route table of the Enterprise Edition transit router and have route synchronization enabled.
 * Perform the following operations before you create an aggregate route. Otherwise, the Enterprise Edition transit router does not advertise routes to VPC route tables:
 * *   Associated forwarding is enabled between the VPCs and the Enterprise Edition transit router. For more information, see [AssociateTransitRouterAttachmentWithRouteTable](~~261242~~).
 * *   Route synchronization is enabled for the VPCs. For more information, see [CreateTransitRouterVpcAttachment](~~261358~~).
 *
 * @param request CreateTransitRouteTableAggregationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTransitRouteTableAggregationResponse
 */
func (client *Client) CreateTransitRouteTableAggregationWithOptions(request *CreateTransitRouteTableAggregationRequest, runtime *util.RuntimeOptions) (_result *CreateTransitRouteTableAggregationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouteTableAggregationCidr)) {
		query["TransitRouteTableAggregationCidr"] = request.TransitRouteTableAggregationCidr
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouteTableAggregationDescription)) {
		query["TransitRouteTableAggregationDescription"] = request.TransitRouteTableAggregationDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouteTableAggregationName)) {
		query["TransitRouteTableAggregationName"] = request.TransitRouteTableAggregationName
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouteTableAggregationScope)) {
		query["TransitRouteTableAggregationScope"] = request.TransitRouteTableAggregationScope
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouteTableId)) {
		query["TransitRouteTableId"] = request.TransitRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTransitRouteTableAggregation"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTransitRouteTableAggregationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you add an aggregate route to a route table of an Enterprise Edition transit router, the Enterprise Edition transit router advertises its routes only to route tables of virtual private clouds (VPCs) that are associated with a route table of the Enterprise Edition transit router and have route synchronization enabled.
 * Perform the following operations before you create an aggregate route. Otherwise, the Enterprise Edition transit router does not advertise routes to VPC route tables:
 * *   Associated forwarding is enabled between the VPCs and the Enterprise Edition transit router. For more information, see [AssociateTransitRouterAttachmentWithRouteTable](~~261242~~).
 * *   Route synchronization is enabled for the VPCs. For more information, see [CreateTransitRouterVpcAttachment](~~261358~~).
 *
 * @param request CreateTransitRouteTableAggregationRequest
 * @return CreateTransitRouteTableAggregationResponse
 */
func (client *Client) CreateTransitRouteTableAggregation(request *CreateTransitRouteTableAggregationRequest) (_result *CreateTransitRouteTableAggregationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTransitRouteTableAggregationResponse{}
	_body, _err := client.CreateTransitRouteTableAggregationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param tmpReq CreateTransitRouterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTransitRouterResponse
 */
func (client *Client) CreateTransitRouterWithOptions(tmpReq *CreateTransitRouterRequest, runtime *util.RuntimeOptions) (_result *CreateTransitRouterResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateTransitRouterShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.TransitRouterCidrList)) {
		request.TransitRouterCidrListShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.TransitRouterCidrList, tea.String("TransitRouterCidrList"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SupportMulticast)) {
		query["SupportMulticast"] = request.SupportMulticast
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterCidrListShrink)) {
		query["TransitRouterCidrList"] = request.TransitRouterCidrListShrink
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterDescription)) {
		query["TransitRouterDescription"] = request.TransitRouterDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterName)) {
		query["TransitRouterName"] = request.TransitRouterName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTransitRouter"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTransitRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request CreateTransitRouterRequest
 * @return CreateTransitRouterResponse
 */
func (client *Client) CreateTransitRouter(request *CreateTransitRouterRequest) (_result *CreateTransitRouterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTransitRouterResponse{}
	_body, _err := client.CreateTransitRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The client token that is used to ensure the idempotence of the request.
 * You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
 * >  If you do not set this parameter, ClientToken is set to the value of RequestId. The value of RequestId for each API request may be different.
 *
 * @param request CreateTransitRouterCidrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTransitRouterCidrResponse
 */
func (client *Client) CreateTransitRouterCidrWithOptions(request *CreateTransitRouterCidrRequest, runtime *util.RuntimeOptions) (_result *CreateTransitRouterCidrResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Cidr)) {
		query["Cidr"] = request.Cidr
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PublishCidrRoute)) {
		query["PublishCidrRoute"] = request.PublishCidrRoute
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTransitRouterCidr"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTransitRouterCidrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The client token that is used to ensure the idempotence of the request.
 * You can use the client to generate the value, but you must make sure that it is unique among different requests. ClientToken can contain only ASCII characters.
 * >  If you do not set this parameter, ClientToken is set to the value of RequestId. The value of RequestId for each API request may be different.
 *
 * @param request CreateTransitRouterCidrRequest
 * @return CreateTransitRouterCidrResponse
 */
func (client *Client) CreateTransitRouterCidr(request *CreateTransitRouterCidrRequest) (_result *CreateTransitRouterCidrResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTransitRouterCidrResponse{}
	_body, _err := client.CreateTransitRouterCidrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, read the following rules:
 * *   Only Enterprise Edition transit routers in the Australia (Sydney) and UK (London) regions support the multicast feature. Multicast is unavailable by default. If you want to enable multicast, contact your sales manager or [submit a ticket](https://workorder-intl.console.aliyun.com/#/ticket/createIndex) to apply for multicast resources.
 * *   Make sure that an Enterprise Edition transit router is deployed in the region where you want to create the multicast domain, and the multicast feature is enabled for the Enterprise Edition transit router. For more information, see [CreateTransitRouter](~~261169~~).
 *     If an Enterprise Edition transit router was created before you apply for multicast resources, the transit router does not support multicast. You can delete the transit router and create a new one. For more information about how to delete an Enterprise Edition transit router, see [DeleteTransitRouter](~~261218~~).
 * *   When you call **CreateTransitRouterMulticastDomain**, if you set **CenId** and **RegionId**, you do not need to set **TransitRouterId**. If you set **TransitRouterId**, you do not need to set **CenId** or **RegionId**.
 *
 * @param request CreateTransitRouterMulticastDomainRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTransitRouterMulticastDomainResponse
 */
func (client *Client) CreateTransitRouterMulticastDomainWithOptions(request *CreateTransitRouterMulticastDomainRequest, runtime *util.RuntimeOptions) (_result *CreateTransitRouterMulticastDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterMulticastDomainDescription)) {
		query["TransitRouterMulticastDomainDescription"] = request.TransitRouterMulticastDomainDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterMulticastDomainName)) {
		query["TransitRouterMulticastDomainName"] = request.TransitRouterMulticastDomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTransitRouterMulticastDomain"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTransitRouterMulticastDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, read the following rules:
 * *   Only Enterprise Edition transit routers in the Australia (Sydney) and UK (London) regions support the multicast feature. Multicast is unavailable by default. If you want to enable multicast, contact your sales manager or [submit a ticket](https://workorder-intl.console.aliyun.com/#/ticket/createIndex) to apply for multicast resources.
 * *   Make sure that an Enterprise Edition transit router is deployed in the region where you want to create the multicast domain, and the multicast feature is enabled for the Enterprise Edition transit router. For more information, see [CreateTransitRouter](~~261169~~).
 *     If an Enterprise Edition transit router was created before you apply for multicast resources, the transit router does not support multicast. You can delete the transit router and create a new one. For more information about how to delete an Enterprise Edition transit router, see [DeleteTransitRouter](~~261218~~).
 * *   When you call **CreateTransitRouterMulticastDomain**, if you set **CenId** and **RegionId**, you do not need to set **TransitRouterId**. If you set **TransitRouterId**, you do not need to set **CenId** or **RegionId**.
 *
 * @param request CreateTransitRouterMulticastDomainRequest
 * @return CreateTransitRouterMulticastDomainResponse
 */
func (client *Client) CreateTransitRouterMulticastDomain(request *CreateTransitRouterMulticastDomainRequest) (_result *CreateTransitRouterMulticastDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTransitRouterMulticastDomainResponse{}
	_body, _err := client.CreateTransitRouterMulticastDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You must purchase a bandwidth plan before you can create an inter-region connection. For more information, see [CreateCenBandwidthPackage](~~468263~~).
 * **CreateTransitRouterPeerAttachment** is an asynchronous operation. After you send a request, the system returns an inter-region connection ID and runs the task in the background. You can call the **ListTransitRouterPeerAttachments** operation to query the status of an inter-region connection.
 * *   If an inter-region connection is in the **Attaching** state, the inter-region connection is being created. You can query the inter-region connection but cannot perform other regions.
 * *   If an inter-region connection is in the **Attached** state, the inter-region connection is created.
 *
 * @param request CreateTransitRouterPeerAttachmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTransitRouterPeerAttachmentResponse
 */
func (client *Client) CreateTransitRouterPeerAttachmentWithOptions(request *CreateTransitRouterPeerAttachmentRequest, runtime *util.RuntimeOptions) (_result *CreateTransitRouterPeerAttachmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPublishRouteEnabled)) {
		query["AutoPublishRouteEnabled"] = request.AutoPublishRouteEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.BandwidthType)) {
		query["BandwidthType"] = request.BandwidthType
	}

	if !tea.BoolValue(util.IsUnset(request.CenBandwidthPackageId)) {
		query["CenBandwidthPackageId"] = request.CenBandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerTransitRouterId)) {
		query["PeerTransitRouterId"] = request.PeerTransitRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerTransitRouterRegionId)) {
		query["PeerTransitRouterRegionId"] = request.PeerTransitRouterRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentDescription)) {
		query["TransitRouterAttachmentDescription"] = request.TransitRouterAttachmentDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentName)) {
		query["TransitRouterAttachmentName"] = request.TransitRouterAttachmentName
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTransitRouterPeerAttachment"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTransitRouterPeerAttachmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You must purchase a bandwidth plan before you can create an inter-region connection. For more information, see [CreateCenBandwidthPackage](~~468263~~).
 * **CreateTransitRouterPeerAttachment** is an asynchronous operation. After you send a request, the system returns an inter-region connection ID and runs the task in the background. You can call the **ListTransitRouterPeerAttachments** operation to query the status of an inter-region connection.
 * *   If an inter-region connection is in the **Attaching** state, the inter-region connection is being created. You can query the inter-region connection but cannot perform other regions.
 * *   If an inter-region connection is in the **Attached** state, the inter-region connection is created.
 *
 * @param request CreateTransitRouterPeerAttachmentRequest
 * @return CreateTransitRouterPeerAttachmentResponse
 */
func (client *Client) CreateTransitRouterPeerAttachment(request *CreateTransitRouterPeerAttachmentRequest) (_result *CreateTransitRouterPeerAttachmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTransitRouterPeerAttachmentResponse{}
	_body, _err := client.CreateTransitRouterPeerAttachmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Only the route tables of Enterprise Edition transit routers can be associated with prefix lists.
 * *   A prefix list can be associated only with one route table of an Enterprise Edition.
 * *   The CIDR blocks in the prefix list cannot overlap with those in the route table of the Enterprise Edition transit router. Otherwise, the prefix list fails to be associated with the route table.
 * *   If the route table of an Enterprise Edition transit router needs to be associated with multiple prefix lists, make sure that the CIDR blocks in the prefix lists do not overlap. Otherwise, the route table fails to be associated with the prefix lists.
 * # Prerequisites
 * *   A prefix list is created. For more information, see [CreateVpcPrefixList](~~437367~~).
 * *   The prefix list is shared with the Alibaba Cloud account that owns the Enterprise Edition transit router if the prefix list and the Enterprise Edition transit router belong to different Alibaba Cloud accounts. For more information about how to share a prefix list with another Alibaba Cloud account, see [Resource sharing overview](~~160622~~) and [API reference for resource sharing](~~193445~~).
 *
 * @param request CreateTransitRouterPrefixListAssociationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTransitRouterPrefixListAssociationResponse
 */
func (client *Client) CreateTransitRouterPrefixListAssociationWithOptions(request *CreateTransitRouterPrefixListAssociationRequest, runtime *util.RuntimeOptions) (_result *CreateTransitRouterPrefixListAssociationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.NextHop)) {
		query["NextHop"] = request.NextHop
	}

	if !tea.BoolValue(util.IsUnset(request.NextHopType)) {
		query["NextHopType"] = request.NextHopType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerUid)) {
		query["OwnerUid"] = request.OwnerUid
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListId)) {
		query["PrefixListId"] = request.PrefixListId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterTableId)) {
		query["TransitRouterTableId"] = request.TransitRouterTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTransitRouterPrefixListAssociation"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTransitRouterPrefixListAssociationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Only the route tables of Enterprise Edition transit routers can be associated with prefix lists.
 * *   A prefix list can be associated only with one route table of an Enterprise Edition.
 * *   The CIDR blocks in the prefix list cannot overlap with those in the route table of the Enterprise Edition transit router. Otherwise, the prefix list fails to be associated with the route table.
 * *   If the route table of an Enterprise Edition transit router needs to be associated with multiple prefix lists, make sure that the CIDR blocks in the prefix lists do not overlap. Otherwise, the route table fails to be associated with the prefix lists.
 * # Prerequisites
 * *   A prefix list is created. For more information, see [CreateVpcPrefixList](~~437367~~).
 * *   The prefix list is shared with the Alibaba Cloud account that owns the Enterprise Edition transit router if the prefix list and the Enterprise Edition transit router belong to different Alibaba Cloud accounts. For more information about how to share a prefix list with another Alibaba Cloud account, see [Resource sharing overview](~~160622~~) and [API reference for resource sharing](~~193445~~).
 *
 * @param request CreateTransitRouterPrefixListAssociationRequest
 * @return CreateTransitRouterPrefixListAssociationResponse
 */
func (client *Client) CreateTransitRouterPrefixListAssociation(request *CreateTransitRouterPrefixListAssociationRequest) (_result *CreateTransitRouterPrefixListAssociationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTransitRouterPrefixListAssociationResponse{}
	_body, _err := client.CreateTransitRouterPrefixListAssociationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **CreateTransitRouterRouteEntry** is an asynchronous operation. After you send a request, the route ID is returned but the operation is still being performed in the system background. You can call **ListTransitRouterRouteEntries** to query the status of a route.
 * *   If a route is in the **Creating** state, the route is being created. In this case, you can query the route but cannot perform other operations.
 * *   If a route is in the **Active** state, the route is created.
 *
 * @param request CreateTransitRouterRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTransitRouterRouteEntryResponse
 */
func (client *Client) CreateTransitRouterRouteEntryWithOptions(request *CreateTransitRouterRouteEntryRequest, runtime *util.RuntimeOptions) (_result *CreateTransitRouterRouteEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryDescription)) {
		query["TransitRouterRouteEntryDescription"] = request.TransitRouterRouteEntryDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryDestinationCidrBlock)) {
		query["TransitRouterRouteEntryDestinationCidrBlock"] = request.TransitRouterRouteEntryDestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryName)) {
		query["TransitRouterRouteEntryName"] = request.TransitRouterRouteEntryName
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryNextHopId)) {
		query["TransitRouterRouteEntryNextHopId"] = request.TransitRouterRouteEntryNextHopId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryNextHopType)) {
		query["TransitRouterRouteEntryNextHopType"] = request.TransitRouterRouteEntryNextHopType
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableId)) {
		query["TransitRouterRouteTableId"] = request.TransitRouterRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTransitRouterRouteEntry"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTransitRouterRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **CreateTransitRouterRouteEntry** is an asynchronous operation. After you send a request, the route ID is returned but the operation is still being performed in the system background. You can call **ListTransitRouterRouteEntries** to query the status of a route.
 * *   If a route is in the **Creating** state, the route is being created. In this case, you can query the route but cannot perform other operations.
 * *   If a route is in the **Active** state, the route is created.
 *
 * @param request CreateTransitRouterRouteEntryRequest
 * @return CreateTransitRouterRouteEntryResponse
 */
func (client *Client) CreateTransitRouterRouteEntry(request *CreateTransitRouterRouteEntryRequest) (_result *CreateTransitRouterRouteEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTransitRouterRouteEntryResponse{}
	_body, _err := client.CreateTransitRouterRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Only Enterprise Edition transit routers support custom route tables. For more information about the regions and zones that support Enterprise Edition transit routers, see [What is CEN?](~~181681~~)
 * *   **CreateTransitRouterRouteTable** is an asynchronous operation. After you send a request, the route table ID is returned but the operation is still being performed in the system background. You can call **ListTransitRouterRouteTables** to query the status of a route table.
 *     *   If a route table is in the **Creating** state, the route table is being created. In this case, you can query the route table but cannot perform other operations.
 *     *   If a route table is in the **Active** state, the route table is created.
 *
 * @param request CreateTransitRouterRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTransitRouterRouteTableResponse
 */
func (client *Client) CreateTransitRouterRouteTableWithOptions(request *CreateTransitRouterRouteTableRequest, runtime *util.RuntimeOptions) (_result *CreateTransitRouterRouteTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableOptions)) {
		query["RouteTableOptions"] = request.RouteTableOptions
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableDescription)) {
		query["TransitRouterRouteTableDescription"] = request.TransitRouterRouteTableDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableName)) {
		query["TransitRouterRouteTableName"] = request.TransitRouterRouteTableName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTransitRouterRouteTable"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTransitRouterRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Only Enterprise Edition transit routers support custom route tables. For more information about the regions and zones that support Enterprise Edition transit routers, see [What is CEN?](~~181681~~)
 * *   **CreateTransitRouterRouteTable** is an asynchronous operation. After you send a request, the route table ID is returned but the operation is still being performed in the system background. You can call **ListTransitRouterRouteTables** to query the status of a route table.
 *     *   If a route table is in the **Creating** state, the route table is being created. In this case, you can query the route table but cannot perform other operations.
 *     *   If a route table is in the **Active** state, the route table is created.
 *
 * @param request CreateTransitRouterRouteTableRequest
 * @return CreateTransitRouterRouteTableResponse
 */
func (client *Client) CreateTransitRouterRouteTable(request *CreateTransitRouterRouteTableRequest) (_result *CreateTransitRouterRouteTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTransitRouterRouteTableResponse{}
	_body, _err := client.CreateTransitRouterRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   For more information about the regions and zones that support Enterprise Edition transit routers, see [What is CEN?](~~181681~~)
 * *   You can use the following methods to connect a VBR to an Enterprise Edition transit router:
 *     *   If an Enterprise Edition transit router is already created in the region where you want to create a VBR connection, set the **VbrId** and **TransitRouterId** parameters.
 *     *   If no Enterprise Edition transit router is created in the region where you want to create a VBR connection, set the **VbrId**, **CenId**, and **RegionId** parameters. Then, the system automatically creates an Enterprise Edition transit router in the specified region.
 * *   **CreateTransitRouterVbrAttachment** is an asynchronous operation. After you send a request, the system returns a VBR connection ID and runs the task in the background. You can call the **ListTransitRouterVbrAttachments** operation to query the status of a VBR connection.
 *     *   If a VBR connection is in the **Attaching** state, the VBR connection is being created. You can query the VBR connection but cannot perform other operations.
 *     *   If a VBR connection is in the **Attached** state, the VBR connection is created.
 *
 * @param request CreateTransitRouterVbrAttachmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTransitRouterVbrAttachmentResponse
 */
func (client *Client) CreateTransitRouterVbrAttachmentWithOptions(request *CreateTransitRouterVbrAttachmentRequest, runtime *util.RuntimeOptions) (_result *CreateTransitRouterVbrAttachmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPublishRouteEnabled)) {
		query["AutoPublishRouteEnabled"] = request.AutoPublishRouteEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentDescription)) {
		query["TransitRouterAttachmentDescription"] = request.TransitRouterAttachmentDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentName)) {
		query["TransitRouterAttachmentName"] = request.TransitRouterAttachmentName
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrId)) {
		query["VbrId"] = request.VbrId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrOwnerId)) {
		query["VbrOwnerId"] = request.VbrOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTransitRouterVbrAttachment"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTransitRouterVbrAttachmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   For more information about the regions and zones that support Enterprise Edition transit routers, see [What is CEN?](~~181681~~)
 * *   You can use the following methods to connect a VBR to an Enterprise Edition transit router:
 *     *   If an Enterprise Edition transit router is already created in the region where you want to create a VBR connection, set the **VbrId** and **TransitRouterId** parameters.
 *     *   If no Enterprise Edition transit router is created in the region where you want to create a VBR connection, set the **VbrId**, **CenId**, and **RegionId** parameters. Then, the system automatically creates an Enterprise Edition transit router in the specified region.
 * *   **CreateTransitRouterVbrAttachment** is an asynchronous operation. After you send a request, the system returns a VBR connection ID and runs the task in the background. You can call the **ListTransitRouterVbrAttachments** operation to query the status of a VBR connection.
 *     *   If a VBR connection is in the **Attaching** state, the VBR connection is being created. You can query the VBR connection but cannot perform other operations.
 *     *   If a VBR connection is in the **Attached** state, the VBR connection is created.
 *
 * @param request CreateTransitRouterVbrAttachmentRequest
 * @return CreateTransitRouterVbrAttachmentResponse
 */
func (client *Client) CreateTransitRouterVbrAttachment(request *CreateTransitRouterVbrAttachmentRequest) (_result *CreateTransitRouterVbrAttachmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTransitRouterVbrAttachmentResponse{}
	_body, _err := client.CreateTransitRouterVbrAttachmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can use the following methods to attach a VPC to an Enterprise Edition transit router:
 *     *   If an Enterprise Edition transit router is already created in the region where you want to create a VPC connection, set **VpcId**, **ZoneMappings.N.VSwitchId**, **ZoneMappings.N.ZoneId**, and **TransitRouterId**.
 *     *   If no Enterprise Edition transit router is created in the region where you want to create a VPC connection, set **VpcId**, **ZoneMappings.N.VSwitchId**, **ZoneMappings.N.ZoneId**, **CenId**, and **RegionId**. When you create a VPC connection, the system automatically creates an Enterprise Edition transit router in the specified region.
 * *   **CreateTransitRouterVpcAttachment** is an asynchronous operation. After you send a request, the VPC connection ID is returned but the operation is still being performed in the system background. You can call the [ListTransitRouterVpcAttachments](~~261222~~) operation to query the status of a VPC connection.
 *     *   If a VPC connection is in the **Attaching** state, the VPC connection is being created. You can query the VPC connection but cannot perform other operations.
 *     *   If a VPC connection is in the **Attached** state, the VPC connection is created.
 * *   By default, route learning and associated forwarding are disabled between transit router route tables and VPC connections.
 * ## Prerequisites
 * Before you call this operation, make sure that the following requirements are met:
 * *   At least one vSwitch is deployed for the VPC in the zones supported by Enterprise Edition transit routers. Each vSwitch must have at least one idle IP address. For more information, see [Regions and zones supported by Enterprise Edition transit routers](~~181681~~).
 * *   To connect to a network instance that belongs to another Alibaba Cloud account, you must first acquire the required permissions from the account. For more information, see [Acquire permissions to connect to a network instance that belongs to another account](~~181553~~).
 * *   VPC connections incur fees. Take note of the billing rules of VPC connections before you create a VPC connection. For more information, see [Billing](~~189836~~).
 *
 * @param request CreateTransitRouterVpcAttachmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTransitRouterVpcAttachmentResponse
 */
func (client *Client) CreateTransitRouterVpcAttachmentWithOptions(request *CreateTransitRouterVpcAttachmentRequest, runtime *util.RuntimeOptions) (_result *CreateTransitRouterVpcAttachmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPublishRouteEnabled)) {
		query["AutoPublishRouteEnabled"] = request.AutoPublishRouteEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ChargeType)) {
		query["ChargeType"] = request.ChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentDescription)) {
		query["TransitRouterAttachmentDescription"] = request.TransitRouterAttachmentDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentName)) {
		query["TransitRouterAttachmentName"] = request.TransitRouterAttachmentName
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcOwnerId)) {
		query["VpcOwnerId"] = request.VpcOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneMappings)) {
		query["ZoneMappings"] = request.ZoneMappings
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTransitRouterVpcAttachment"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTransitRouterVpcAttachmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can use the following methods to attach a VPC to an Enterprise Edition transit router:
 *     *   If an Enterprise Edition transit router is already created in the region where you want to create a VPC connection, set **VpcId**, **ZoneMappings.N.VSwitchId**, **ZoneMappings.N.ZoneId**, and **TransitRouterId**.
 *     *   If no Enterprise Edition transit router is created in the region where you want to create a VPC connection, set **VpcId**, **ZoneMappings.N.VSwitchId**, **ZoneMappings.N.ZoneId**, **CenId**, and **RegionId**. When you create a VPC connection, the system automatically creates an Enterprise Edition transit router in the specified region.
 * *   **CreateTransitRouterVpcAttachment** is an asynchronous operation. After you send a request, the VPC connection ID is returned but the operation is still being performed in the system background. You can call the [ListTransitRouterVpcAttachments](~~261222~~) operation to query the status of a VPC connection.
 *     *   If a VPC connection is in the **Attaching** state, the VPC connection is being created. You can query the VPC connection but cannot perform other operations.
 *     *   If a VPC connection is in the **Attached** state, the VPC connection is created.
 * *   By default, route learning and associated forwarding are disabled between transit router route tables and VPC connections.
 * ## Prerequisites
 * Before you call this operation, make sure that the following requirements are met:
 * *   At least one vSwitch is deployed for the VPC in the zones supported by Enterprise Edition transit routers. Each vSwitch must have at least one idle IP address. For more information, see [Regions and zones supported by Enterprise Edition transit routers](~~181681~~).
 * *   To connect to a network instance that belongs to another Alibaba Cloud account, you must first acquire the required permissions from the account. For more information, see [Acquire permissions to connect to a network instance that belongs to another account](~~181553~~).
 * *   VPC connections incur fees. Take note of the billing rules of VPC connections before you create a VPC connection. For more information, see [Billing](~~189836~~).
 *
 * @param request CreateTransitRouterVpcAttachmentRequest
 * @return CreateTransitRouterVpcAttachmentResponse
 */
func (client *Client) CreateTransitRouterVpcAttachment(request *CreateTransitRouterVpcAttachmentRequest) (_result *CreateTransitRouterVpcAttachmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTransitRouterVpcAttachmentResponse{}
	_body, _err := client.CreateTransitRouterVpcAttachmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   By default, route learning and associated forwarding are disabled between transit router route tables and IPsec-VPN attachments.
 * *   When you call `CreateTransitRouterVpnAttachment`, if you set **CenId** and **RegionId**, you do not need to set **TransitRouterId**. If you set **TransitRouterId** and **RegionId**, you do not need to set **CenId**.
 * ## Prerequisites
 * *   Before you attach an IPsec-VPN connection to a transit router, make sure that at least one IPsec-VPN connection is created in the region where the transit router is deployed. Make sure the IPsec-VPN connection is not associated with a resource. For more information, see [CreateVpnAttachment](~~442455~~).
 * *   If the IPsec-VPN connection to be attached to the transit router belongs to a different Alibaba Cloud account, make sure that the transit router has obtained the required permissions from the IPsec-VPN connection. For more information, see [GrantInstanceToTransitRouter](~~417520~~).
 *
 * @param request CreateTransitRouterVpnAttachmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTransitRouterVpnAttachmentResponse
 */
func (client *Client) CreateTransitRouterVpnAttachmentWithOptions(request *CreateTransitRouterVpnAttachmentRequest, runtime *util.RuntimeOptions) (_result *CreateTransitRouterVpnAttachmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPublishRouteEnabled)) {
		query["AutoPublishRouteEnabled"] = request.AutoPublishRouteEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ChargeType)) {
		query["ChargeType"] = request.ChargeType
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentDescription)) {
		query["TransitRouterAttachmentDescription"] = request.TransitRouterAttachmentDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentName)) {
		query["TransitRouterAttachmentName"] = request.TransitRouterAttachmentName
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnId)) {
		query["VpnId"] = request.VpnId
	}

	if !tea.BoolValue(util.IsUnset(request.VpnOwnerId)) {
		query["VpnOwnerId"] = request.VpnOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Zone)) {
		query["Zone"] = request.Zone
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTransitRouterVpnAttachment"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTransitRouterVpnAttachmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   By default, route learning and associated forwarding are disabled between transit router route tables and IPsec-VPN attachments.
 * *   When you call `CreateTransitRouterVpnAttachment`, if you set **CenId** and **RegionId**, you do not need to set **TransitRouterId**. If you set **TransitRouterId** and **RegionId**, you do not need to set **CenId**.
 * ## Prerequisites
 * *   Before you attach an IPsec-VPN connection to a transit router, make sure that at least one IPsec-VPN connection is created in the region where the transit router is deployed. Make sure the IPsec-VPN connection is not associated with a resource. For more information, see [CreateVpnAttachment](~~442455~~).
 * *   If the IPsec-VPN connection to be attached to the transit router belongs to a different Alibaba Cloud account, make sure that the transit router has obtained the required permissions from the IPsec-VPN connection. For more information, see [GrantInstanceToTransitRouter](~~417520~~).
 *
 * @param request CreateTransitRouterVpnAttachmentRequest
 * @return CreateTransitRouterVpnAttachmentResponse
 */
func (client *Client) CreateTransitRouterVpnAttachment(request *CreateTransitRouterVpnAttachmentRequest) (_result *CreateTransitRouterVpnAttachmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTransitRouterVpnAttachmentResponse{}
	_body, _err := client.CreateTransitRouterVpnAttachmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * `DeactiveFlowLog` is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the `DescribeFlowlogs` operation to query the status of a flow log.
 * *   If a flow log is in the **Modifying** state, the flow log is being disabled. You can query the flow log but cannot perform other operations.
 * *   If a flow log is in the **Inactive** state, the flow log is disabled.
 *
 * @param request DeactiveFlowLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeactiveFlowLogResponse
 */
func (client *Client) DeactiveFlowLogWithOptions(request *DeactiveFlowLogRequest, runtime *util.RuntimeOptions) (_result *DeactiveFlowLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.FlowLogId)) {
		query["FlowLogId"] = request.FlowLogId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeactiveFlowLog"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeactiveFlowLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * `DeactiveFlowLog` is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the `DescribeFlowlogs` operation to query the status of a flow log.
 * *   If a flow log is in the **Modifying** state, the flow log is being disabled. You can query the flow log but cannot perform other operations.
 * *   If a flow log is in the **Inactive** state, the flow log is disabled.
 *
 * @param request DeactiveFlowLogRequest
 * @return DeactiveFlowLogResponse
 */
func (client *Client) DeactiveFlowLog(request *DeactiveFlowLogRequest) (_result *DeactiveFlowLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeactiveFlowLogResponse{}
	_body, _err := client.DeactiveFlowLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **DeleteCen** is an asynchronous operation. After you send a request, the **request ID** is returned but the operation is still being performed in the system background. You can call **DescribeCens** to query the status of a CEN instance.
 * - If a CEN instance is in the **Deleting** state, the CEN instance is being deleted. In this case, you can query the CEN instance but cannot perform other operations.
 * - If a CEN instance cannot be found, the CEN instance is deleted.
 * ## Prerequisites
 * The CEN instance that you want to delete is not associated with a bandwidth plan, and the transit router associated with the CEN instance does not have a network instance connection or a custom route table.
 * - For more information about how to detach a network instance, see the following topics:
 *   - [DeleteTransitRouterVpcAttachment](~~468238~~)
 *   - [DeleteTransitRouterVbrAttachment](~~468244~~)
 *   - [DeleteTransitRouterVpnAttachment](~~468251~~)
 *   - [DeleteTransitRouterPeerAttachment](~~468271~~)
 *   >  For more information about how to detach network instances from a Basic Edition transit router, see [DetachCenChildInstance](~~468685~~).
 * - For more information about how to delete a custom route table, see [DeleteTransitRouterRouteTable](~~468285~~).
 * - For more information about how to disassociate a bandwidth plan from a CEN instance, see [UnassociateCenBandwidthPackage](~~468506~~).
 *
 * @param request DeleteCenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCenResponse
 */
func (client *Client) DeleteCenWithOptions(request *DeleteCenRequest, runtime *util.RuntimeOptions) (_result *DeleteCenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCen"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **DeleteCen** is an asynchronous operation. After you send a request, the **request ID** is returned but the operation is still being performed in the system background. You can call **DescribeCens** to query the status of a CEN instance.
 * - If a CEN instance is in the **Deleting** state, the CEN instance is being deleted. In this case, you can query the CEN instance but cannot perform other operations.
 * - If a CEN instance cannot be found, the CEN instance is deleted.
 * ## Prerequisites
 * The CEN instance that you want to delete is not associated with a bandwidth plan, and the transit router associated with the CEN instance does not have a network instance connection or a custom route table.
 * - For more information about how to detach a network instance, see the following topics:
 *   - [DeleteTransitRouterVpcAttachment](~~468238~~)
 *   - [DeleteTransitRouterVbrAttachment](~~468244~~)
 *   - [DeleteTransitRouterVpnAttachment](~~468251~~)
 *   - [DeleteTransitRouterPeerAttachment](~~468271~~)
 *   >  For more information about how to detach network instances from a Basic Edition transit router, see [DetachCenChildInstance](~~468685~~).
 * - For more information about how to delete a custom route table, see [DeleteTransitRouterRouteTable](~~468285~~).
 * - For more information about how to disassociate a bandwidth plan from a CEN instance, see [UnassociateCenBandwidthPackage](~~468506~~).
 *
 * @param request DeleteCenRequest
 * @return DeleteCenResponse
 */
func (client *Client) DeleteCen(request *DeleteCenRequest) (_result *DeleteCenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCenResponse{}
	_body, _err := client.DeleteCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteCenBandwidthPackageWithOptions(request *DeleteCenBandwidthPackageRequest, runtime *util.RuntimeOptions) (_result *DeleteCenBandwidthPackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenBandwidthPackageId)) {
		query["CenBandwidthPackageId"] = request.CenBandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCenBandwidthPackage"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCenBandwidthPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteCenBandwidthPackage(request *DeleteCenBandwidthPackageRequest) (_result *DeleteCenBandwidthPackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCenBandwidthPackageResponse{}
	_body, _err := client.DeleteCenBandwidthPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can delete routes only from virtual private clouds (VPCs) and virtual border routers (VBRs) whose next hop is an **Enterprise Edition transit router connection**, which is the connection to the network instance.
 * *   **DeleteCenChildInstanceRouteEntryToAttachment** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **DescribeRouteEntryList** operation to query the status of a route.
 *     *   If a route is in the **Deleting** state, the route is being deleted. You can query the route but cannot perform other operations.
 *     *   If a route cannot be found, the route is deleted.
 *
 * @param request DeleteCenChildInstanceRouteEntryToAttachmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCenChildInstanceRouteEntryToAttachmentResponse
 */
func (client *Client) DeleteCenChildInstanceRouteEntryToAttachmentWithOptions(request *DeleteCenChildInstanceRouteEntryToAttachmentRequest, runtime *util.RuntimeOptions) (_result *DeleteCenChildInstanceRouteEntryToAttachmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlock)) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCenChildInstanceRouteEntryToAttachment"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCenChildInstanceRouteEntryToAttachmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can delete routes only from virtual private clouds (VPCs) and virtual border routers (VBRs) whose next hop is an **Enterprise Edition transit router connection**, which is the connection to the network instance.
 * *   **DeleteCenChildInstanceRouteEntryToAttachment** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **DescribeRouteEntryList** operation to query the status of a route.
 *     *   If a route is in the **Deleting** state, the route is being deleted. You can query the route but cannot perform other operations.
 *     *   If a route cannot be found, the route is deleted.
 *
 * @param request DeleteCenChildInstanceRouteEntryToAttachmentRequest
 * @return DeleteCenChildInstanceRouteEntryToAttachmentResponse
 */
func (client *Client) DeleteCenChildInstanceRouteEntryToAttachment(request *DeleteCenChildInstanceRouteEntryToAttachmentRequest) (_result *DeleteCenChildInstanceRouteEntryToAttachmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCenChildInstanceRouteEntryToAttachmentResponse{}
	_body, _err := client.DeleteCenChildInstanceRouteEntryToAttachmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   By default, the DeleteCenChildInstanceRouteEntryToCen operation is unavailable. To call this operation, [submit a ticket](https://workorder-intl.console.aliyun.com/#/ticket/createIndex).
 * *   You cannot delete a route entry from an Enterprise Edition transit router by calling the DeleteCenChildInstanceRouteEntryToCen operation.
 *
 * @param request DeleteCenChildInstanceRouteEntryToCenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCenChildInstanceRouteEntryToCenResponse
 */
func (client *Client) DeleteCenChildInstanceRouteEntryToCenWithOptions(request *DeleteCenChildInstanceRouteEntryToCenRequest, runtime *util.RuntimeOptions) (_result *DeleteCenChildInstanceRouteEntryToCenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceAliUid)) {
		query["ChildInstanceAliUid"] = request.ChildInstanceAliUid
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceId)) {
		query["ChildInstanceId"] = request.ChildInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRegionId)) {
		query["ChildInstanceRegionId"] = request.ChildInstanceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceType)) {
		query["ChildInstanceType"] = request.ChildInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlock)) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableId)) {
		query["RouteTableId"] = request.RouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCenChildInstanceRouteEntryToCen"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCenChildInstanceRouteEntryToCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   By default, the DeleteCenChildInstanceRouteEntryToCen operation is unavailable. To call this operation, [submit a ticket](https://workorder-intl.console.aliyun.com/#/ticket/createIndex).
 * *   You cannot delete a route entry from an Enterprise Edition transit router by calling the DeleteCenChildInstanceRouteEntryToCen operation.
 *
 * @param request DeleteCenChildInstanceRouteEntryToCenRequest
 * @return DeleteCenChildInstanceRouteEntryToCenResponse
 */
func (client *Client) DeleteCenChildInstanceRouteEntryToCen(request *DeleteCenChildInstanceRouteEntryToCenRequest) (_result *DeleteCenChildInstanceRouteEntryToCenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCenChildInstanceRouteEntryToCenResponse{}
	_body, _err := client.DeleteCenChildInstanceRouteEntryToCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteCenInterRegionTrafficQosPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCenInterRegionTrafficQosPolicyResponse
 */
func (client *Client) DeleteCenInterRegionTrafficQosPolicyWithOptions(request *DeleteCenInterRegionTrafficQosPolicyRequest, runtime *util.RuntimeOptions) (_result *DeleteCenInterRegionTrafficQosPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficQosPolicyId)) {
		query["TrafficQosPolicyId"] = request.TrafficQosPolicyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCenInterRegionTrafficQosPolicy"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCenInterRegionTrafficQosPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteCenInterRegionTrafficQosPolicyRequest
 * @return DeleteCenInterRegionTrafficQosPolicyResponse
 */
func (client *Client) DeleteCenInterRegionTrafficQosPolicy(request *DeleteCenInterRegionTrafficQosPolicyRequest) (_result *DeleteCenInterRegionTrafficQosPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCenInterRegionTrafficQosPolicyResponse{}
	_body, _err := client.DeleteCenInterRegionTrafficQosPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteCenInterRegionTrafficQosQueueRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCenInterRegionTrafficQosQueueResponse
 */
func (client *Client) DeleteCenInterRegionTrafficQosQueueWithOptions(request *DeleteCenInterRegionTrafficQosQueueRequest, runtime *util.RuntimeOptions) (_result *DeleteCenInterRegionTrafficQosQueueResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.QosQueueId)) {
		query["QosQueueId"] = request.QosQueueId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCenInterRegionTrafficQosQueue"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCenInterRegionTrafficQosQueueResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteCenInterRegionTrafficQosQueueRequest
 * @return DeleteCenInterRegionTrafficQosQueueResponse
 */
func (client *Client) DeleteCenInterRegionTrafficQosQueue(request *DeleteCenInterRegionTrafficQosQueueRequest) (_result *DeleteCenInterRegionTrafficQosQueueResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCenInterRegionTrafficQosQueueResponse{}
	_body, _err := client.DeleteCenInterRegionTrafficQosQueueWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * `DeleteCenRouteMap` is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the `DescribeCenRouteMaps` operation to query the status of a routing policy.
 * *   If a routing policy is in the **Deleting** state, the routing policy is being deleted. You can query the routing policy but cannot perform other operations.
 * *   If a routing policy cannot be found, it is deleted.``
 *
 * @param request DeleteCenRouteMapRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteCenRouteMapResponse
 */
func (client *Client) DeleteCenRouteMapWithOptions(request *DeleteCenRouteMapRequest, runtime *util.RuntimeOptions) (_result *DeleteCenRouteMapResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.CenRegionId)) {
		query["CenRegionId"] = request.CenRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteMapId)) {
		query["RouteMapId"] = request.RouteMapId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteCenRouteMap"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteCenRouteMapResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * `DeleteCenRouteMap` is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the `DescribeCenRouteMaps` operation to query the status of a routing policy.
 * *   If a routing policy is in the **Deleting** state, the routing policy is being deleted. You can query the routing policy but cannot perform other operations.
 * *   If a routing policy cannot be found, it is deleted.``
 *
 * @param request DeleteCenRouteMapRequest
 * @return DeleteCenRouteMapResponse
 */
func (client *Client) DeleteCenRouteMap(request *DeleteCenRouteMapRequest) (_result *DeleteCenRouteMapResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteCenRouteMapResponse{}
	_body, _err := client.DeleteCenRouteMapWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The response.
 *
 * @param request DeleteFlowlogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFlowlogResponse
 */
func (client *Client) DeleteFlowlogWithOptions(request *DeleteFlowlogRequest, runtime *util.RuntimeOptions) (_result *DeleteFlowlogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.FlowLogId)) {
		query["FlowLogId"] = request.FlowLogId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteFlowlog"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteFlowlogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The response.
 *
 * @param request DeleteFlowlogRequest
 * @return DeleteFlowlogResponse
 */
func (client *Client) DeleteFlowlog(request *DeleteFlowlogRequest) (_result *DeleteFlowlogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteFlowlogResponse{}
	_body, _err := client.DeleteFlowlogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **DeleteRouteServiceInCen** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **DescribeRouteServicesInCen** operation to query the status of the connection to a cloud service.
 *     - If a cloud service is in the **Deleting** state, the configuration of the cloud service is being deleted. You can query the configuration but cannot perform other operations.
 *     - If no configuration of a cloud service can be found, the configuration of the cloud service is deleted.
 *
 * @param request DeleteRouteServiceInCenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRouteServiceInCenResponse
 */
func (client *Client) DeleteRouteServiceInCenWithOptions(request *DeleteRouteServiceInCenRequest, runtime *util.RuntimeOptions) (_result *DeleteRouteServiceInCenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessRegionId)) {
		query["AccessRegionId"] = request.AccessRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.Host)) {
		query["Host"] = request.Host
	}

	if !tea.BoolValue(util.IsUnset(request.HostRegionId)) {
		query["HostRegionId"] = request.HostRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.HostVpcId)) {
		query["HostVpcId"] = request.HostVpcId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRouteServiceInCen"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRouteServiceInCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **DeleteRouteServiceInCen** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **DescribeRouteServicesInCen** operation to query the status of the connection to a cloud service.
 *     - If a cloud service is in the **Deleting** state, the configuration of the cloud service is being deleted. You can query the configuration but cannot perform other operations.
 *     - If no configuration of a cloud service can be found, the configuration of the cloud service is deleted.
 *
 * @param request DeleteRouteServiceInCenRequest
 * @return DeleteRouteServiceInCenResponse
 */
func (client *Client) DeleteRouteServiceInCen(request *DeleteRouteServiceInCenRequest) (_result *DeleteRouteServiceInCenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRouteServiceInCenResponse{}
	_body, _err := client.DeleteRouteServiceInCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The **DeleteTrafficMarkingPolicy** operation is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call **ListTrafficMarkingPolicies** to query the status of a traffic marking policy.
 *     *   If a traffic marking policy is in the **Deleting** state, the traffic marking policy is being deleted. You can query the traffic marking policy, but cannot perform other operations.
 *     *   If a traffic marking policy cannot be found, the traffic marking policy is deleted.
 * *   Before you delete a traffic marking policy, you must delete all traffic classification rules from the policy. For more information, see [RemoveTraficMatchRuleFromTrafficMarkingPolicy](~~419012~~).
 *
 * @param request DeleteTrafficMarkingPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTrafficMarkingPolicyResponse
 */
func (client *Client) DeleteTrafficMarkingPolicyWithOptions(request *DeleteTrafficMarkingPolicyRequest, runtime *util.RuntimeOptions) (_result *DeleteTrafficMarkingPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMarkingPolicyId)) {
		query["TrafficMarkingPolicyId"] = request.TrafficMarkingPolicyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTrafficMarkingPolicy"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTrafficMarkingPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The **DeleteTrafficMarkingPolicy** operation is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call **ListTrafficMarkingPolicies** to query the status of a traffic marking policy.
 *     *   If a traffic marking policy is in the **Deleting** state, the traffic marking policy is being deleted. You can query the traffic marking policy, but cannot perform other operations.
 *     *   If a traffic marking policy cannot be found, the traffic marking policy is deleted.
 * *   Before you delete a traffic marking policy, you must delete all traffic classification rules from the policy. For more information, see [RemoveTraficMatchRuleFromTrafficMarkingPolicy](~~419012~~).
 *
 * @param request DeleteTrafficMarkingPolicyRequest
 * @return DeleteTrafficMarkingPolicyResponse
 */
func (client *Client) DeleteTrafficMarkingPolicy(request *DeleteTrafficMarkingPolicyRequest) (_result *DeleteTrafficMarkingPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTrafficMarkingPolicyResponse{}
	_body, _err := client.DeleteTrafficMarkingPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteTransitRouteTableAggregationWithOptions(request *DeleteTransitRouteTableAggregationRequest, runtime *util.RuntimeOptions) (_result *DeleteTransitRouteTableAggregationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouteTableAggregationCidr)) {
		query["TransitRouteTableAggregationCidr"] = request.TransitRouteTableAggregationCidr
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouteTableId)) {
		query["TransitRouteTableId"] = request.TransitRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTransitRouteTableAggregation"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTransitRouteTableAggregationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteTransitRouteTableAggregation(request *DeleteTransitRouteTableAggregationRequest) (_result *DeleteTransitRouteTableAggregationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTransitRouteTableAggregationResponse{}
	_body, _err := client.DeleteTransitRouteTableAggregationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteTransitRouterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTransitRouterResponse
 */
func (client *Client) DeleteTransitRouterWithOptions(request *DeleteTransitRouterRequest, runtime *util.RuntimeOptions) (_result *DeleteTransitRouterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTransitRouter"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTransitRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request DeleteTransitRouterRequest
 * @return DeleteTransitRouterResponse
 */
func (client *Client) DeleteTransitRouter(request *DeleteTransitRouterRequest) (_result *DeleteTransitRouterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTransitRouterResponse{}
	_body, _err := client.DeleteTransitRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If IP addresses within the CIDR block have been allocated to network instances, the CIDR block cannot be deleted.
 *
 * @param request DeleteTransitRouterCidrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTransitRouterCidrResponse
 */
func (client *Client) DeleteTransitRouterCidrWithOptions(request *DeleteTransitRouterCidrRequest, runtime *util.RuntimeOptions) (_result *DeleteTransitRouterCidrResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterCidrId)) {
		query["TransitRouterCidrId"] = request.TransitRouterCidrId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTransitRouterCidr"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTransitRouterCidrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If IP addresses within the CIDR block have been allocated to network instances, the CIDR block cannot be deleted.
 *
 * @param request DeleteTransitRouterCidrRequest
 * @return DeleteTransitRouterCidrResponse
 */
func (client *Client) DeleteTransitRouterCidr(request *DeleteTransitRouterCidrRequest) (_result *DeleteTransitRouterCidrResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTransitRouterCidrResponse{}
	_body, _err := client.DeleteTransitRouterCidrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteTransitRouterMulticastDomainWithOptions(request *DeleteTransitRouterMulticastDomainRequest, runtime *util.RuntimeOptions) (_result *DeleteTransitRouterMulticastDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterMulticastDomainId)) {
		query["TransitRouterMulticastDomainId"] = request.TransitRouterMulticastDomainId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTransitRouterMulticastDomain"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTransitRouterMulticastDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteTransitRouterMulticastDomain(request *DeleteTransitRouterMulticastDomainRequest) (_result *DeleteTransitRouterMulticastDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTransitRouterMulticastDomainResponse{}
	_body, _err := client.DeleteTransitRouterMulticastDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **DeleteTransitRouterPeerAttachment** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call **ListTransitRouterPeerAttachments** to query the status of an inter-region connection.
 * *   If an inter-region connection is in the **Detaching** state, the inter-region connection is being deleted. You can query the inter-region connection but cannot perform other operations.
 * *   If an inter-region connection cannot be found, the inter-region connection is deleted.
 * ## Prerequisites
 * Before you begin, make sure that the Enterprise Edition transit router that you use to create inter-region connections meets the following prerequisites:
 * *   No associated forwarding correlation is established between the inter-region connection and the route tables of the Enterprise Edition transit router. For more information about how to delete an associated forwarding correlation, see [DissociateTransitRouterAttachmentFromRouteTable](~~260944~~).
 * *   No route learning correlation is established between the inter-region connection and the route tables of the Enterprise Edition transit router. For more information about how to delete a route learning correlation, see [DisableTransitRouterRouteTablePropagation](~~260945~~).
 * *   The route tables of the Enterprise Edition transit router do not contain a custom route entry whose next hop is the network instance connection. For more information about how to delete custom routes from route tables of Enterprise Edition transit routers, see [DeleteTransitRouterRouteEntry](~~261240~~).
 * *   The route table does not contain a route whose next hop is the inter-region connection and that is generated from a prefix list. You can delete routes from a route table by disassociating the route table from the prefix list. For more information, see [DeleteTransitRouterPrefixListAssociation](~~445486~~).
 * *   No quality of service (QoS) policy is configured for the inter-region connection. For more information about how to delete QoS policies, see [DeleteCenInterRegionTrafficQosPolicy](~~427547~~).
 *
 * @param request DeleteTransitRouterPeerAttachmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTransitRouterPeerAttachmentResponse
 */
func (client *Client) DeleteTransitRouterPeerAttachmentWithOptions(request *DeleteTransitRouterPeerAttachmentRequest, runtime *util.RuntimeOptions) (_result *DeleteTransitRouterPeerAttachmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTransitRouterPeerAttachment"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTransitRouterPeerAttachmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **DeleteTransitRouterPeerAttachment** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call **ListTransitRouterPeerAttachments** to query the status of an inter-region connection.
 * *   If an inter-region connection is in the **Detaching** state, the inter-region connection is being deleted. You can query the inter-region connection but cannot perform other operations.
 * *   If an inter-region connection cannot be found, the inter-region connection is deleted.
 * ## Prerequisites
 * Before you begin, make sure that the Enterprise Edition transit router that you use to create inter-region connections meets the following prerequisites:
 * *   No associated forwarding correlation is established between the inter-region connection and the route tables of the Enterprise Edition transit router. For more information about how to delete an associated forwarding correlation, see [DissociateTransitRouterAttachmentFromRouteTable](~~260944~~).
 * *   No route learning correlation is established between the inter-region connection and the route tables of the Enterprise Edition transit router. For more information about how to delete a route learning correlation, see [DisableTransitRouterRouteTablePropagation](~~260945~~).
 * *   The route tables of the Enterprise Edition transit router do not contain a custom route entry whose next hop is the network instance connection. For more information about how to delete custom routes from route tables of Enterprise Edition transit routers, see [DeleteTransitRouterRouteEntry](~~261240~~).
 * *   The route table does not contain a route whose next hop is the inter-region connection and that is generated from a prefix list. You can delete routes from a route table by disassociating the route table from the prefix list. For more information, see [DeleteTransitRouterPrefixListAssociation](~~445486~~).
 * *   No quality of service (QoS) policy is configured for the inter-region connection. For more information about how to delete QoS policies, see [DeleteCenInterRegionTrafficQosPolicy](~~427547~~).
 *
 * @param request DeleteTransitRouterPeerAttachmentRequest
 * @return DeleteTransitRouterPeerAttachmentResponse
 */
func (client *Client) DeleteTransitRouterPeerAttachment(request *DeleteTransitRouterPeerAttachmentRequest) (_result *DeleteTransitRouterPeerAttachmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTransitRouterPeerAttachmentResponse{}
	_body, _err := client.DeleteTransitRouterPeerAttachmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * # Usage notes
 * After you disassociate a route table of an Enterprise Edition transit router from a prefix list, the routes that point to the CIDR blocks in the prefix list are automatically withdrawn from the route table. Before you disassociate the route table of an Enterprise Edition transit router from a prefix list, you must migrate workloads that use the routes in case services are interrupted.
 *
 * @param request DeleteTransitRouterPrefixListAssociationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTransitRouterPrefixListAssociationResponse
 */
func (client *Client) DeleteTransitRouterPrefixListAssociationWithOptions(request *DeleteTransitRouterPrefixListAssociationRequest, runtime *util.RuntimeOptions) (_result *DeleteTransitRouterPrefixListAssociationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.NextHop)) {
		query["NextHop"] = request.NextHop
	}

	if !tea.BoolValue(util.IsUnset(request.NextHopType)) {
		query["NextHopType"] = request.NextHopType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListId)) {
		query["PrefixListId"] = request.PrefixListId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterTableId)) {
		query["TransitRouterTableId"] = request.TransitRouterTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTransitRouterPrefixListAssociation"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTransitRouterPrefixListAssociationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * # Usage notes
 * After you disassociate a route table of an Enterprise Edition transit router from a prefix list, the routes that point to the CIDR blocks in the prefix list are automatically withdrawn from the route table. Before you disassociate the route table of an Enterprise Edition transit router from a prefix list, you must migrate workloads that use the routes in case services are interrupted.
 *
 * @param request DeleteTransitRouterPrefixListAssociationRequest
 * @return DeleteTransitRouterPrefixListAssociationResponse
 */
func (client *Client) DeleteTransitRouterPrefixListAssociation(request *DeleteTransitRouterPrefixListAssociationRequest) (_result *DeleteTransitRouterPrefixListAssociationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTransitRouterPrefixListAssociationResponse{}
	_body, _err := client.DeleteTransitRouterPrefixListAssociationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation, take note of the following items:
 * *   If **TransitRouterRouteEntryId** is set, you must not set **TransitRouterRouteTableId** or **TransitRouterRouteEntryDestinationCidrBlock**. Otherwise, parameter conflicts will occur.
 * *   If **TransitRouterRouteEntryId** is not set, you must specify the set parameters based on the type of the next hop:
 *     *   To delete a blackhole route, you must set **TransitRouterRouteTableId**, **TransitRouterRouteEntryDestinationCidrBlock**, and **TransitRouterRouteEntryNextHopType**.
 *     *   If the route that you want to delete is not a blackhole route, you must set **TransitRouterRouteTableId**, **TransitRouterRouteEntryDestinationCidrBlock**, **TransitRouterRouteEntryNextHopType**, and **TransitRouterRouteEntryNextHopId**.
 * *   **DeleteTransitRouterRouteEntry** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the system background. You can call the **ListTransitRouterRouteEntries** operation to query the status of a route entry.
 *     *   If a route entry is in the **Deleting** state, the route entry is being deleted. You can query the route entry but cannot perform other operations.
 *     *   If a route entry cannot be found, it is deleted.
 * ## Limits
 * You can call this operation to delete only static routes. Automatically learned routes are not supported. You can call the [ListTransitRouterRouteEntries](~~260941~~) operation to query route types.
 *
 * @param request DeleteTransitRouterRouteEntryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTransitRouterRouteEntryResponse
 */
func (client *Client) DeleteTransitRouterRouteEntryWithOptions(request *DeleteTransitRouterRouteEntryRequest, runtime *util.RuntimeOptions) (_result *DeleteTransitRouterRouteEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryDestinationCidrBlock)) {
		query["TransitRouterRouteEntryDestinationCidrBlock"] = request.TransitRouterRouteEntryDestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryId)) {
		query["TransitRouterRouteEntryId"] = request.TransitRouterRouteEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryNextHopId)) {
		query["TransitRouterRouteEntryNextHopId"] = request.TransitRouterRouteEntryNextHopId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryNextHopType)) {
		query["TransitRouterRouteEntryNextHopType"] = request.TransitRouterRouteEntryNextHopType
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableId)) {
		query["TransitRouterRouteTableId"] = request.TransitRouterRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTransitRouterRouteEntry"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTransitRouterRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation, take note of the following items:
 * *   If **TransitRouterRouteEntryId** is set, you must not set **TransitRouterRouteTableId** or **TransitRouterRouteEntryDestinationCidrBlock**. Otherwise, parameter conflicts will occur.
 * *   If **TransitRouterRouteEntryId** is not set, you must specify the set parameters based on the type of the next hop:
 *     *   To delete a blackhole route, you must set **TransitRouterRouteTableId**, **TransitRouterRouteEntryDestinationCidrBlock**, and **TransitRouterRouteEntryNextHopType**.
 *     *   If the route that you want to delete is not a blackhole route, you must set **TransitRouterRouteTableId**, **TransitRouterRouteEntryDestinationCidrBlock**, **TransitRouterRouteEntryNextHopType**, and **TransitRouterRouteEntryNextHopId**.
 * *   **DeleteTransitRouterRouteEntry** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the system background. You can call the **ListTransitRouterRouteEntries** operation to query the status of a route entry.
 *     *   If a route entry is in the **Deleting** state, the route entry is being deleted. You can query the route entry but cannot perform other operations.
 *     *   If a route entry cannot be found, it is deleted.
 * ## Limits
 * You can call this operation to delete only static routes. Automatically learned routes are not supported. You can call the [ListTransitRouterRouteEntries](~~260941~~) operation to query route types.
 *
 * @param request DeleteTransitRouterRouteEntryRequest
 * @return DeleteTransitRouterRouteEntryResponse
 */
func (client *Client) DeleteTransitRouterRouteEntry(request *DeleteTransitRouterRouteEntryRequest) (_result *DeleteTransitRouterRouteEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTransitRouterRouteEntryResponse{}
	_body, _err := client.DeleteTransitRouterRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You cannot delete the default route table of an Enterprise Edition transit router.
 * *   **DeleteTransitRouterRouteTable** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterRouteTables** operation to query the status of a custom route table.
 *     *   If a custom route table is in the Deleting state, the custom route table is being deleted. In this case, you can query the custom route table but cannot perform other operations.
 *     *   If a custom route table cannot be found, the custom route table is deleted.
 *
 * @param request DeleteTransitRouterRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTransitRouterRouteTableResponse
 */
func (client *Client) DeleteTransitRouterRouteTableWithOptions(request *DeleteTransitRouterRouteTableRequest, runtime *util.RuntimeOptions) (_result *DeleteTransitRouterRouteTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableId)) {
		query["TransitRouterRouteTableId"] = request.TransitRouterRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTransitRouterRouteTable"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTransitRouterRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You cannot delete the default route table of an Enterprise Edition transit router.
 * *   **DeleteTransitRouterRouteTable** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterRouteTables** operation to query the status of a custom route table.
 *     *   If a custom route table is in the Deleting state, the custom route table is being deleted. In this case, you can query the custom route table but cannot perform other operations.
 *     *   If a custom route table cannot be found, the custom route table is deleted.
 *
 * @param request DeleteTransitRouterRouteTableRequest
 * @return DeleteTransitRouterRouteTableResponse
 */
func (client *Client) DeleteTransitRouterRouteTable(request *DeleteTransitRouterRouteTableRequest) (_result *DeleteTransitRouterRouteTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTransitRouterRouteTableResponse{}
	_body, _err := client.DeleteTransitRouterRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **DeleteTransitRouterVbrAttachment** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterVbrAttachments** operation to query the status of a VBR connection.
 * *   If a VBR connection is in the **Detaching** state, the VBR connection is being deleted. You can query the VBR connection but cannot perform other operations.
 * *   If a VBR connection cannot be found, the VBR connection is deleted.
 * ## Prerequisites
 * Before you delete a VBR connection for an Enterprise Edition transit router, make sure that the following requirements are met:
 * *   No associated forwarding correlation is established between the VBR connection and the route tables of the Enterprise Edition transit router. For more information about how to delete an associated forwarding correlation, see [DissociateTransitRouterAttachmentFromRouteTable](~~260944~~).
 * *   No route learning correlation is established between the VBR connection and the route tables of the Enterprise Edition transit router. For more information about how to delete a route learning correlation, see [DisableTransitRouterRouteTablePropagation](~~260945~~).
 * *   The route tables of the Enterprise Edition transit router do not contain a custom route entry whose next hop is the network instance connection. For more information about how to delete custom route entries, see [DeleteTransitRouterRouteEntry](~~261240~~).
 * *   The route tables of the Enterprise Edition transit router do not contain a route whose next hop is the VBR connection and that is generated from a prefix list. You can delete such routes by disassociating the route table from the prefix list. For more information, see [DeleteTransitRouterPrefixListAssociation](~~445486~~).
 *
 * @param request DeleteTransitRouterVbrAttachmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTransitRouterVbrAttachmentResponse
 */
func (client *Client) DeleteTransitRouterVbrAttachmentWithOptions(request *DeleteTransitRouterVbrAttachmentRequest, runtime *util.RuntimeOptions) (_result *DeleteTransitRouterVbrAttachmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTransitRouterVbrAttachment"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTransitRouterVbrAttachmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **DeleteTransitRouterVbrAttachment** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterVbrAttachments** operation to query the status of a VBR connection.
 * *   If a VBR connection is in the **Detaching** state, the VBR connection is being deleted. You can query the VBR connection but cannot perform other operations.
 * *   If a VBR connection cannot be found, the VBR connection is deleted.
 * ## Prerequisites
 * Before you delete a VBR connection for an Enterprise Edition transit router, make sure that the following requirements are met:
 * *   No associated forwarding correlation is established between the VBR connection and the route tables of the Enterprise Edition transit router. For more information about how to delete an associated forwarding correlation, see [DissociateTransitRouterAttachmentFromRouteTable](~~260944~~).
 * *   No route learning correlation is established between the VBR connection and the route tables of the Enterprise Edition transit router. For more information about how to delete a route learning correlation, see [DisableTransitRouterRouteTablePropagation](~~260945~~).
 * *   The route tables of the Enterprise Edition transit router do not contain a custom route entry whose next hop is the network instance connection. For more information about how to delete custom route entries, see [DeleteTransitRouterRouteEntry](~~261240~~).
 * *   The route tables of the Enterprise Edition transit router do not contain a route whose next hop is the VBR connection and that is generated from a prefix list. You can delete such routes by disassociating the route table from the prefix list. For more information, see [DeleteTransitRouterPrefixListAssociation](~~445486~~).
 *
 * @param request DeleteTransitRouterVbrAttachmentRequest
 * @return DeleteTransitRouterVbrAttachmentResponse
 */
func (client *Client) DeleteTransitRouterVbrAttachment(request *DeleteTransitRouterVbrAttachmentRequest) (_result *DeleteTransitRouterVbrAttachmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTransitRouterVbrAttachmentResponse{}
	_body, _err := client.DeleteTransitRouterVbrAttachmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **DeleteTransitRouterVpcAttachment** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterVpcAttachments** operation to query the status of a VPC connection.
 * *   If a VPC connection is in the **Detaching** state, the VPC connection is being deleted. You can query the VPC connection but cannot perform other operations.
 * *   If a VPC connection cannot be found, it is deleted.
 * ## Prerequisites
 * Before you delete a VPC connection, make sure that the following requirements are met:
 * *   No associated forwarding correlation is established between the VPC connection and the route tables of the Enterprise Edition transit router. For more information about how to delete an associated forwarding correlation, see [DissociateTransitRouterAttachmentFromRouteTable](~~260944~~).
 * *   No route learning correlation is established between the VPC connection and the route tables of the Enterprise Edition transit router. For more information about how to delete a route learning correlation, see [DisableTransitRouterRouteTablePropagation](~~260945~~).
 * *   The route table of the VPC does not contain routes that point to the VPC connection. For more information about how to delete routes from a VPC route table, see [DeleteRouteEntry](~~36013~~).
 * *   The route tables of the Enterprise Edition transit router do not contain a custom route entry whose next hop is the network instance connection. For more information about how to delete custom routes from the route tables of an Enterprise Edition transit router, see [DeleteTransitRouterRouteEntry](~~261240~~).
 * *   The route tables of the Enterprise Edition transit router do not contain a route that is generated from a prefix list and the next hop is the VPC connection. You can delete such routes by disassociating the route table from the prefix list. For more information, see [DeleteTransitRouterPrefixListAssociation](~~445486~~).
 *
 * @param request DeleteTransitRouterVpcAttachmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTransitRouterVpcAttachmentResponse
 */
func (client *Client) DeleteTransitRouterVpcAttachmentWithOptions(request *DeleteTransitRouterVpcAttachmentRequest, runtime *util.RuntimeOptions) (_result *DeleteTransitRouterVpcAttachmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTransitRouterVpcAttachment"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTransitRouterVpcAttachmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **DeleteTransitRouterVpcAttachment** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterVpcAttachments** operation to query the status of a VPC connection.
 * *   If a VPC connection is in the **Detaching** state, the VPC connection is being deleted. You can query the VPC connection but cannot perform other operations.
 * *   If a VPC connection cannot be found, it is deleted.
 * ## Prerequisites
 * Before you delete a VPC connection, make sure that the following requirements are met:
 * *   No associated forwarding correlation is established between the VPC connection and the route tables of the Enterprise Edition transit router. For more information about how to delete an associated forwarding correlation, see [DissociateTransitRouterAttachmentFromRouteTable](~~260944~~).
 * *   No route learning correlation is established between the VPC connection and the route tables of the Enterprise Edition transit router. For more information about how to delete a route learning correlation, see [DisableTransitRouterRouteTablePropagation](~~260945~~).
 * *   The route table of the VPC does not contain routes that point to the VPC connection. For more information about how to delete routes from a VPC route table, see [DeleteRouteEntry](~~36013~~).
 * *   The route tables of the Enterprise Edition transit router do not contain a custom route entry whose next hop is the network instance connection. For more information about how to delete custom routes from the route tables of an Enterprise Edition transit router, see [DeleteTransitRouterRouteEntry](~~261240~~).
 * *   The route tables of the Enterprise Edition transit router do not contain a route that is generated from a prefix list and the next hop is the VPC connection. You can delete such routes by disassociating the route table from the prefix list. For more information, see [DeleteTransitRouterPrefixListAssociation](~~445486~~).
 *
 * @param request DeleteTransitRouterVpcAttachmentRequest
 * @return DeleteTransitRouterVpcAttachmentResponse
 */
func (client *Client) DeleteTransitRouterVpcAttachment(request *DeleteTransitRouterVpcAttachmentRequest) (_result *DeleteTransitRouterVpcAttachmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTransitRouterVpcAttachmentResponse{}
	_body, _err := client.DeleteTransitRouterVpcAttachmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you delete a VPN attachment, make sure that the following requirements are met:
 * *   No associated forwarding correlation is established between the VPN attachment and the route tables of the Enterprise Edition transit router. For more information about how to delete an associated forwarding correlation, see [DissociateTransitRouterAttachmentFromRouteTable](~~260944~~).
 * *   No route learning correlation is established between the VPn attachment and the route tables of the Enterprise Edition transit router. For more information about how to delete a route learning correlation, see [DisableTransitRouterRouteTablePropagation](~~260945~~).
 * *   No route in the route table of the Enterprise Edition transit router points to the VPN attachment. For more information, see [DeleteTransitRouterRouteEntry](~~261240~~).
 *
 * @param request DeleteTransitRouterVpnAttachmentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTransitRouterVpnAttachmentResponse
 */
func (client *Client) DeleteTransitRouterVpnAttachmentWithOptions(request *DeleteTransitRouterVpnAttachmentRequest, runtime *util.RuntimeOptions) (_result *DeleteTransitRouterVpnAttachmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Force)) {
		query["Force"] = request.Force
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTransitRouterVpnAttachment"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTransitRouterVpnAttachmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you delete a VPN attachment, make sure that the following requirements are met:
 * *   No associated forwarding correlation is established between the VPN attachment and the route tables of the Enterprise Edition transit router. For more information about how to delete an associated forwarding correlation, see [DissociateTransitRouterAttachmentFromRouteTable](~~260944~~).
 * *   No route learning correlation is established between the VPn attachment and the route tables of the Enterprise Edition transit router. For more information about how to delete a route learning correlation, see [DisableTransitRouterRouteTablePropagation](~~260945~~).
 * *   No route in the route table of the Enterprise Edition transit router points to the VPN attachment. For more information, see [DeleteTransitRouterRouteEntry](~~261240~~).
 *
 * @param request DeleteTransitRouterVpnAttachmentRequest
 * @return DeleteTransitRouterVpnAttachmentResponse
 */
func (client *Client) DeleteTransitRouterVpnAttachment(request *DeleteTransitRouterVpnAttachmentRequest) (_result *DeleteTransitRouterVpnAttachmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTransitRouterVpnAttachmentResponse{}
	_body, _err := client.DeleteTransitRouterVpnAttachmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * `RegisterTransitRouterMulticastGroupMembers` is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the `ListTransitRouterMulticastGroups` operation to query the status of a multicast member.
 * *   If a multicast member is in the **Deregistering** state, the multicast member is being removed. In this case, you can query the multicast member but cannot perform other operations.
 * *   If a multicast member cannot be found, the multicast member is removed from the multicast group.``
 *
 * @param request DeregisterTransitRouterMulticastGroupMembersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeregisterTransitRouterMulticastGroupMembersResponse
 */
func (client *Client) DeregisterTransitRouterMulticastGroupMembersWithOptions(request *DeregisterTransitRouterMulticastGroupMembersRequest, runtime *util.RuntimeOptions) (_result *DeregisterTransitRouterMulticastGroupMembersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.GroupIpAddress)) {
		query["GroupIpAddress"] = request.GroupIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkInterfaceIds)) {
		query["NetworkInterfaceIds"] = request.NetworkInterfaceIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerTransitRouterMulticastDomains)) {
		query["PeerTransitRouterMulticastDomains"] = request.PeerTransitRouterMulticastDomains
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterMulticastDomainId)) {
		query["TransitRouterMulticastDomainId"] = request.TransitRouterMulticastDomainId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeregisterTransitRouterMulticastGroupMembers"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeregisterTransitRouterMulticastGroupMembersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * `RegisterTransitRouterMulticastGroupMembers` is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the `ListTransitRouterMulticastGroups` operation to query the status of a multicast member.
 * *   If a multicast member is in the **Deregistering** state, the multicast member is being removed. In this case, you can query the multicast member but cannot perform other operations.
 * *   If a multicast member cannot be found, the multicast member is removed from the multicast group.``
 *
 * @param request DeregisterTransitRouterMulticastGroupMembersRequest
 * @return DeregisterTransitRouterMulticastGroupMembersResponse
 */
func (client *Client) DeregisterTransitRouterMulticastGroupMembers(request *DeregisterTransitRouterMulticastGroupMembersRequest) (_result *DeregisterTransitRouterMulticastGroupMembersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeregisterTransitRouterMulticastGroupMembersResponse{}
	_body, _err := client.DeregisterTransitRouterMulticastGroupMembersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the multicast source.
 * You can create only one multicast source in a multicast group.
 * >  This parameter is required.
 *
 * @param request DeregisterTransitRouterMulticastGroupSourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeregisterTransitRouterMulticastGroupSourcesResponse
 */
func (client *Client) DeregisterTransitRouterMulticastGroupSourcesWithOptions(request *DeregisterTransitRouterMulticastGroupSourcesRequest, runtime *util.RuntimeOptions) (_result *DeregisterTransitRouterMulticastGroupSourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.GroupIpAddress)) {
		query["GroupIpAddress"] = request.GroupIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkInterfaceIds)) {
		query["NetworkInterfaceIds"] = request.NetworkInterfaceIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterMulticastDomainId)) {
		query["TransitRouterMulticastDomainId"] = request.TransitRouterMulticastDomainId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeregisterTransitRouterMulticastGroupSources"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeregisterTransitRouterMulticastGroupSourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the multicast source.
 * You can create only one multicast source in a multicast group.
 * >  This parameter is required.
 *
 * @param request DeregisterTransitRouterMulticastGroupSourcesRequest
 * @return DeregisterTransitRouterMulticastGroupSourcesResponse
 */
func (client *Client) DeregisterTransitRouterMulticastGroupSources(request *DeregisterTransitRouterMulticastGroupSourcesRequest) (_result *DeregisterTransitRouterMulticastGroupSourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeregisterTransitRouterMulticastGroupSourcesResponse{}
	_body, _err := client.DeregisterTransitRouterMulticastGroupSourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCenAttachedChildInstanceAttributeWithOptions(request *DescribeCenAttachedChildInstanceAttributeRequest, runtime *util.RuntimeOptions) (_result *DescribeCenAttachedChildInstanceAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceId)) {
		query["ChildInstanceId"] = request.ChildInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRegionId)) {
		query["ChildInstanceRegionId"] = request.ChildInstanceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceType)) {
		query["ChildInstanceType"] = request.ChildInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCenAttachedChildInstanceAttribute"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCenAttachedChildInstanceAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCenAttachedChildInstanceAttribute(request *DescribeCenAttachedChildInstanceAttributeRequest) (_result *DescribeCenAttachedChildInstanceAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCenAttachedChildInstanceAttributeResponse{}
	_body, _err := client.DescribeCenAttachedChildInstanceAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The time when the network instance was attached to the CEN instance.
 * The time follows the ISO8601 standard in the YYYY-MM-DDThh:mmZ format. The time is displayed in UTC.
 *
 * @param request DescribeCenAttachedChildInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeCenAttachedChildInstancesResponse
 */
func (client *Client) DescribeCenAttachedChildInstancesWithOptions(request *DescribeCenAttachedChildInstancesRequest, runtime *util.RuntimeOptions) (_result *DescribeCenAttachedChildInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRegionId)) {
		query["ChildInstanceRegionId"] = request.ChildInstanceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceType)) {
		query["ChildInstanceType"] = request.ChildInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCenAttachedChildInstances"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCenAttachedChildInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The time when the network instance was attached to the CEN instance.
 * The time follows the ISO8601 standard in the YYYY-MM-DDThh:mmZ format. The time is displayed in UTC.
 *
 * @param request DescribeCenAttachedChildInstancesRequest
 * @return DescribeCenAttachedChildInstancesResponse
 */
func (client *Client) DescribeCenAttachedChildInstances(request *DescribeCenAttachedChildInstancesRequest) (_result *DescribeCenAttachedChildInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCenAttachedChildInstancesResponse{}
	_body, _err := client.DescribeCenAttachedChildInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCenBandwidthPackagesWithOptions(request *DescribeCenBandwidthPackagesRequest, runtime *util.RuntimeOptions) (_result *DescribeCenBandwidthPackagesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Filter)) {
		query["Filter"] = request.Filter
	}

	if !tea.BoolValue(util.IsUnset(request.IncludeReservationData)) {
		query["IncludeReservationData"] = request.IncludeReservationData
	}

	if !tea.BoolValue(util.IsUnset(request.IsOrKey)) {
		query["IsOrKey"] = request.IsOrKey
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCenBandwidthPackages"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCenBandwidthPackagesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCenBandwidthPackages(request *DescribeCenBandwidthPackagesRequest) (_result *DescribeCenBandwidthPackagesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCenBandwidthPackagesResponse{}
	_body, _err := client.DescribeCenBandwidthPackagesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCenChildInstanceRouteEntriesWithOptions(request *DescribeCenChildInstanceRouteEntriesRequest, runtime *util.RuntimeOptions) (_result *DescribeCenChildInstanceRouteEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceId)) {
		query["ChildInstanceId"] = request.ChildInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRegionId)) {
		query["ChildInstanceRegionId"] = request.ChildInstanceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRouteTableId)) {
		query["ChildInstanceRouteTableId"] = request.ChildInstanceRouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceType)) {
		query["ChildInstanceType"] = request.ChildInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCenChildInstanceRouteEntries"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCenChildInstanceRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCenChildInstanceRouteEntries(request *DescribeCenChildInstanceRouteEntriesRequest) (_result *DescribeCenChildInstanceRouteEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCenChildInstanceRouteEntriesResponse{}
	_body, _err := client.DescribeCenChildInstanceRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCenGeographicSpanRemainingBandwidthWithOptions(request *DescribeCenGeographicSpanRemainingBandwidthRequest, runtime *util.RuntimeOptions) (_result *DescribeCenGeographicSpanRemainingBandwidthResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.GeographicRegionAId)) {
		query["GeographicRegionAId"] = request.GeographicRegionAId
	}

	if !tea.BoolValue(util.IsUnset(request.GeographicRegionBId)) {
		query["GeographicRegionBId"] = request.GeographicRegionBId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCenGeographicSpanRemainingBandwidth"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCenGeographicSpanRemainingBandwidthResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCenGeographicSpanRemainingBandwidth(request *DescribeCenGeographicSpanRemainingBandwidthRequest) (_result *DescribeCenGeographicSpanRemainingBandwidthResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCenGeographicSpanRemainingBandwidthResponse{}
	_body, _err := client.DescribeCenGeographicSpanRemainingBandwidthWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCenGeographicSpansWithOptions(request *DescribeCenGeographicSpansRequest, runtime *util.RuntimeOptions) (_result *DescribeCenGeographicSpansResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GeographicSpanId)) {
		query["GeographicSpanId"] = request.GeographicSpanId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCenGeographicSpans"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCenGeographicSpansResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCenGeographicSpans(request *DescribeCenGeographicSpansRequest) (_result *DescribeCenGeographicSpansResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCenGeographicSpansResponse{}
	_body, _err := client.DescribeCenGeographicSpansWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCenInterRegionBandwidthLimitsWithOptions(request *DescribeCenInterRegionBandwidthLimitsRequest, runtime *util.RuntimeOptions) (_result *DescribeCenInterRegionBandwidthLimitsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrRegionId)) {
		query["TrRegionId"] = request.TrRegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCenInterRegionBandwidthLimits"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCenInterRegionBandwidthLimitsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCenInterRegionBandwidthLimits(request *DescribeCenInterRegionBandwidthLimitsRequest) (_result *DescribeCenInterRegionBandwidthLimitsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCenInterRegionBandwidthLimitsResponse{}
	_body, _err := client.DescribeCenInterRegionBandwidthLimitsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCenPrivateZoneRoutesWithOptions(request *DescribeCenPrivateZoneRoutesRequest, runtime *util.RuntimeOptions) (_result *DescribeCenPrivateZoneRoutesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessRegionId)) {
		query["AccessRegionId"] = request.AccessRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.HostRegionId)) {
		query["HostRegionId"] = request.HostRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCenPrivateZoneRoutes"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCenPrivateZoneRoutesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCenPrivateZoneRoutes(request *DescribeCenPrivateZoneRoutesRequest) (_result *DescribeCenPrivateZoneRoutesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCenPrivateZoneRoutesResponse{}
	_body, _err := client.DescribeCenPrivateZoneRoutesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCenRegionDomainRouteEntriesWithOptions(request *DescribeCenRegionDomainRouteEntriesRequest, runtime *util.RuntimeOptions) (_result *DescribeCenRegionDomainRouteEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.CenRegionId)) {
		query["CenRegionId"] = request.CenRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCenRegionDomainRouteEntries"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCenRegionDomainRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCenRegionDomainRouteEntries(request *DescribeCenRegionDomainRouteEntriesRequest) (_result *DescribeCenRegionDomainRouteEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCenRegionDomainRouteEntriesResponse{}
	_body, _err := client.DescribeCenRegionDomainRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCenRouteMapsWithOptions(request *DescribeCenRouteMapsRequest, runtime *util.RuntimeOptions) (_result *DescribeCenRouteMapsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.CenRegionId)) {
		query["CenRegionId"] = request.CenRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteMapId)) {
		query["RouteMapId"] = request.RouteMapId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableId)) {
		query["TransitRouterRouteTableId"] = request.TransitRouterRouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.TransmitDirection)) {
		query["TransmitDirection"] = request.TransmitDirection
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCenRouteMaps"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCenRouteMapsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCenRouteMaps(request *DescribeCenRouteMapsRequest) (_result *DescribeCenRouteMapsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCenRouteMapsResponse{}
	_body, _err := client.DescribeCenRouteMapsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCenVbrHealthCheckWithOptions(request *DescribeCenVbrHealthCheckRequest, runtime *util.RuntimeOptions) (_result *DescribeCenVbrHealthCheckResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrInstanceId)) {
		query["VbrInstanceId"] = request.VbrInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrInstanceOwnerId)) {
		query["VbrInstanceOwnerId"] = request.VbrInstanceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrInstanceRegionId)) {
		query["VbrInstanceRegionId"] = request.VbrInstanceRegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCenVbrHealthCheck"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCenVbrHealthCheckResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCenVbrHealthCheck(request *DescribeCenVbrHealthCheckRequest) (_result *DescribeCenVbrHealthCheckResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCenVbrHealthCheckResponse{}
	_body, _err := client.DescribeCenVbrHealthCheckWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeCensWithOptions(request *DescribeCensRequest, runtime *util.RuntimeOptions) (_result *DescribeCensResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Filter)) {
		query["Filter"] = request.Filter
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeCens"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeCensResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeCens(request *DescribeCensRequest) (_result *DescribeCensResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeCensResponse{}
	_body, _err := client.DescribeCensWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The regions that support CEN vary based on the network instance type. To query the regions where you can attach a specified type of network instance to CEN, set the `ProductType` parameter. If you do not set the `ProductType` parameter, the system queries all regions in which you can attach network instances to CEN, regardless of the network instance type.
 *
 * @param request DescribeChildInstanceRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeChildInstanceRegionsResponse
 */
func (client *Client) DescribeChildInstanceRegionsWithOptions(request *DescribeChildInstanceRegionsRequest, runtime *util.RuntimeOptions) (_result *DescribeChildInstanceRegionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AcceptLanguage)) {
		query["AcceptLanguage"] = request.AcceptLanguage
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductType)) {
		query["ProductType"] = request.ProductType
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeChildInstanceRegions"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeChildInstanceRegionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The regions that support CEN vary based on the network instance type. To query the regions where you can attach a specified type of network instance to CEN, set the `ProductType` parameter. If you do not set the `ProductType` parameter, the system queries all regions in which you can attach network instances to CEN, regardless of the network instance type.
 *
 * @param request DescribeChildInstanceRegionsRequest
 * @return DescribeChildInstanceRegionsResponse
 */
func (client *Client) DescribeChildInstanceRegions(request *DescribeChildInstanceRegionsRequest) (_result *DescribeChildInstanceRegionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeChildInstanceRegionsResponse{}
	_body, _err := client.DescribeChildInstanceRegionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeFlowlogsWithOptions(request *DescribeFlowlogsRequest, runtime *util.RuntimeOptions) (_result *DescribeFlowlogsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.FlowLogId)) {
		query["FlowLogId"] = request.FlowLogId
	}

	if !tea.BoolValue(util.IsUnset(request.FlowLogName)) {
		query["FlowLogName"] = request.FlowLogName
	}

	if !tea.BoolValue(util.IsUnset(request.LogStoreName)) {
		query["LogStoreName"] = request.LogStoreName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		query["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeFlowlogs"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeFlowlogsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeFlowlogs(request *DescribeFlowlogsRequest) (_result *DescribeFlowlogsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeFlowlogsResponse{}
	_body, _err := client.DescribeFlowlogsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGeographicRegionMembershipWithOptions(request *DescribeGeographicRegionMembershipRequest, runtime *util.RuntimeOptions) (_result *DescribeGeographicRegionMembershipResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GeographicRegionId)) {
		query["GeographicRegionId"] = request.GeographicRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGeographicRegionMembership"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGeographicRegionMembershipResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGeographicRegionMembership(request *DescribeGeographicRegionMembershipRequest) (_result *DescribeGeographicRegionMembershipResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGeographicRegionMembershipResponse{}
	_body, _err := client.DescribeGeographicRegionMembershipWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGrantRulesToCenWithOptions(request *DescribeGrantRulesToCenRequest, runtime *util.RuntimeOptions) (_result *DescribeGrantRulesToCenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceId)) {
		query["ChildInstanceId"] = request.ChildInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceOwnerId)) {
		query["ChildInstanceOwnerId"] = request.ChildInstanceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductType)) {
		query["ProductType"] = request.ProductType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGrantRulesToCen"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGrantRulesToCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGrantRulesToCen(request *DescribeGrantRulesToCenRequest) (_result *DescribeGrantRulesToCenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGrantRulesToCenResponse{}
	_body, _err := client.DescribeGrantRulesToCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeGrantRulesToResourceWithOptions(request *DescribeGrantRulesToResourceRequest, runtime *util.RuntimeOptions) (_result *DescribeGrantRulesToResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductType)) {
		query["ProductType"] = request.ProductType
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeGrantRulesToResource"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeGrantRulesToResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeGrantRulesToResource(request *DescribeGrantRulesToResourceRequest) (_result *DescribeGrantRulesToResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeGrantRulesToResourceResponse{}
	_body, _err := client.DescribeGrantRulesToResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribePublishedRouteEntriesWithOptions(request *DescribePublishedRouteEntriesRequest, runtime *util.RuntimeOptions) (_result *DescribePublishedRouteEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceId)) {
		query["ChildInstanceId"] = request.ChildInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRegionId)) {
		query["ChildInstanceRegionId"] = request.ChildInstanceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRouteTableId)) {
		query["ChildInstanceRouteTableId"] = request.ChildInstanceRouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceType)) {
		query["ChildInstanceType"] = request.ChildInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlock)) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribePublishedRouteEntries"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribePublishedRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribePublishedRouteEntries(request *DescribePublishedRouteEntriesRequest) (_result *DescribePublishedRouteEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribePublishedRouteEntriesResponse{}
	_body, _err := client.DescribePublishedRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRouteConflictWithOptions(request *DescribeRouteConflictRequest, runtime *util.RuntimeOptions) (_result *DescribeRouteConflictResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChildInstanceId)) {
		query["ChildInstanceId"] = request.ChildInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRegionId)) {
		query["ChildInstanceRegionId"] = request.ChildInstanceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRouteTableId)) {
		query["ChildInstanceRouteTableId"] = request.ChildInstanceRouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceType)) {
		query["ChildInstanceType"] = request.ChildInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlock)) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRouteConflict"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRouteConflictResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRouteConflict(request *DescribeRouteConflictRequest) (_result *DescribeRouteConflictResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRouteConflictResponse{}
	_body, _err := client.DescribeRouteConflictWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeRouteServicesInCenWithOptions(request *DescribeRouteServicesInCenRequest, runtime *util.RuntimeOptions) (_result *DescribeRouteServicesInCenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessRegionId)) {
		query["AccessRegionId"] = request.AccessRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.Host)) {
		query["Host"] = request.Host
	}

	if !tea.BoolValue(util.IsUnset(request.HostRegionId)) {
		query["HostRegionId"] = request.HostRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.HostVpcId)) {
		query["HostVpcId"] = request.HostVpcId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeRouteServicesInCen"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeRouteServicesInCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeRouteServicesInCen(request *DescribeRouteServicesInCenRequest) (_result *DescribeRouteServicesInCenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeRouteServicesInCenResponse{}
	_body, _err := client.DescribeRouteServicesInCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can set the **TransitRouteTableId** and **TransitRouteTableAggregationCidr** parameters to specify the aggregate routes that you want to query. If you set only the **TransitRouteTableId** parameter, all aggregate routes in the specified route table are queried.
 *
 * @param request DescribeTransitRouteTableAggregationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTransitRouteTableAggregationResponse
 */
func (client *Client) DescribeTransitRouteTableAggregationWithOptions(request *DescribeTransitRouteTableAggregationRequest, runtime *util.RuntimeOptions) (_result *DescribeTransitRouteTableAggregationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouteTableAggregationCidr)) {
		query["TransitRouteTableAggregationCidr"] = request.TransitRouteTableAggregationCidr
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouteTableId)) {
		query["TransitRouteTableId"] = request.TransitRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTransitRouteTableAggregation"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTransitRouteTableAggregationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can set the **TransitRouteTableId** and **TransitRouteTableAggregationCidr** parameters to specify the aggregate routes that you want to query. If you set only the **TransitRouteTableId** parameter, all aggregate routes in the specified route table are queried.
 *
 * @param request DescribeTransitRouteTableAggregationRequest
 * @return DescribeTransitRouteTableAggregationResponse
 */
func (client *Client) DescribeTransitRouteTableAggregation(request *DescribeTransitRouteTableAggregationRequest) (_result *DescribeTransitRouteTableAggregationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTransitRouteTableAggregationResponse{}
	_body, _err := client.DescribeTransitRouteTableAggregationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DescribeTransitRouteTableAggregationDetailWithOptions(request *DescribeTransitRouteTableAggregationDetailRequest, runtime *util.RuntimeOptions) (_result *DescribeTransitRouteTableAggregationDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouteTableAggregationCidr)) {
		query["TransitRouteTableAggregationCidr"] = request.TransitRouteTableAggregationCidr
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouteTableId)) {
		query["TransitRouteTableId"] = request.TransitRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DescribeTransitRouteTableAggregationDetail"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DescribeTransitRouteTableAggregationDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DescribeTransitRouteTableAggregationDetail(request *DescribeTransitRouteTableAggregationDetailRequest) (_result *DescribeTransitRouteTableAggregationDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DescribeTransitRouteTableAggregationDetailResponse{}
	_body, _err := client.DescribeTransitRouteTableAggregationDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DetachCenChildInstanceWithOptions(request *DetachCenChildInstanceRequest, runtime *util.RuntimeOptions) (_result *DetachCenChildInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.CenOwnerId)) {
		query["CenOwnerId"] = request.CenOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceId)) {
		query["ChildInstanceId"] = request.ChildInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceOwnerId)) {
		query["ChildInstanceOwnerId"] = request.ChildInstanceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRegionId)) {
		query["ChildInstanceRegionId"] = request.ChildInstanceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceType)) {
		query["ChildInstanceType"] = request.ChildInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachCenChildInstance"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachCenChildInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DetachCenChildInstance(request *DetachCenChildInstanceRequest) (_result *DetachCenChildInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachCenChildInstanceResponse{}
	_body, _err := client.DetachCenChildInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **DisableCenVbrHealthCheck** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **DescribeCenVbrHealthCheck** operation to query the status of health check configurations. If the health check configurations cannot be found, the health check configurations are deleted.
 *
 * @param request DisableCenVbrHealthCheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableCenVbrHealthCheckResponse
 */
func (client *Client) DisableCenVbrHealthCheckWithOptions(request *DisableCenVbrHealthCheckRequest, runtime *util.RuntimeOptions) (_result *DisableCenVbrHealthCheckResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrInstanceId)) {
		query["VbrInstanceId"] = request.VbrInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrInstanceOwnerId)) {
		query["VbrInstanceOwnerId"] = request.VbrInstanceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrInstanceRegionId)) {
		query["VbrInstanceRegionId"] = request.VbrInstanceRegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableCenVbrHealthCheck"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableCenVbrHealthCheckResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **DisableCenVbrHealthCheck** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **DescribeCenVbrHealthCheck** operation to query the status of health check configurations. If the health check configurations cannot be found, the health check configurations are deleted.
 *
 * @param request DisableCenVbrHealthCheckRequest
 * @return DisableCenVbrHealthCheckResponse
 */
func (client *Client) DisableCenVbrHealthCheck(request *DisableCenVbrHealthCheckRequest) (_result *DisableCenVbrHealthCheckResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableCenVbrHealthCheckResponse{}
	_body, _err := client.DisableCenVbrHealthCheckWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **DisableTransitRouterRouteTablePropagation** is an synchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterRouteTablePropagations** operation to query the status of a route learning correlation.
 * *   If a route learning correlation is in the **Disabling** state, the route learning correlation is being deleted. You can query the route learning correlation but cannot perform other operations.
 * *   If a route learning correlation cannot be found, the route learning correlation is deleted.
 *
 * @param request DisableTransitRouterRouteTablePropagationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableTransitRouterRouteTablePropagationResponse
 */
func (client *Client) DisableTransitRouterRouteTablePropagationWithOptions(request *DisableTransitRouterRouteTablePropagationRequest, runtime *util.RuntimeOptions) (_result *DisableTransitRouterRouteTablePropagationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableId)) {
		query["TransitRouterRouteTableId"] = request.TransitRouterRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableTransitRouterRouteTablePropagation"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableTransitRouterRouteTablePropagationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **DisableTransitRouterRouteTablePropagation** is an synchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterRouteTablePropagations** operation to query the status of a route learning correlation.
 * *   If a route learning correlation is in the **Disabling** state, the route learning correlation is being deleted. You can query the route learning correlation but cannot perform other operations.
 * *   If a route learning correlation cannot be found, the route learning correlation is deleted.
 *
 * @param request DisableTransitRouterRouteTablePropagationRequest
 * @return DisableTransitRouterRouteTablePropagationResponse
 */
func (client *Client) DisableTransitRouterRouteTablePropagation(request *DisableTransitRouterRouteTablePropagationRequest) (_result *DisableTransitRouterRouteTablePropagationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableTransitRouterRouteTablePropagationResponse{}
	_body, _err := client.DisableTransitRouterRouteTablePropagationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisassociateTransitRouterMulticastDomainWithOptions(request *DisassociateTransitRouterMulticastDomainRequest, runtime *util.RuntimeOptions) (_result *DisassociateTransitRouterMulticastDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterMulticastDomainId)) {
		query["TransitRouterMulticastDomainId"] = request.TransitRouterMulticastDomainId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchIds)) {
		query["VSwitchIds"] = request.VSwitchIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisassociateTransitRouterMulticastDomain"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisassociateTransitRouterMulticastDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisassociateTransitRouterMulticastDomain(request *DisassociateTransitRouterMulticastDomainRequest) (_result *DisassociateTransitRouterMulticastDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisassociateTransitRouterMulticastDomainResponse{}
	_body, _err := client.DisassociateTransitRouterMulticastDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **DissociateTransitRouterAttachmentFromRouteTable** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterRouteTableAssociations** operation to query an associated forwarding correlation between a network instance connection and a route table.
 * *   If an associated forwarding correlation is in the **Dissociating** state, the associated forwarding correlation is being deleted. You can query the associated forwarding correlation but cannot perform other operations.
 * *   If an associated forwarding correlation cannot be found, the associated forwarding correlation is deleted.
 *
 * @param request DissociateTransitRouterAttachmentFromRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DissociateTransitRouterAttachmentFromRouteTableResponse
 */
func (client *Client) DissociateTransitRouterAttachmentFromRouteTableWithOptions(request *DissociateTransitRouterAttachmentFromRouteTableRequest, runtime *util.RuntimeOptions) (_result *DissociateTransitRouterAttachmentFromRouteTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableId)) {
		query["TransitRouterRouteTableId"] = request.TransitRouterRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DissociateTransitRouterAttachmentFromRouteTable"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DissociateTransitRouterAttachmentFromRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **DissociateTransitRouterAttachmentFromRouteTable** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterRouteTableAssociations** operation to query an associated forwarding correlation between a network instance connection and a route table.
 * *   If an associated forwarding correlation is in the **Dissociating** state, the associated forwarding correlation is being deleted. You can query the associated forwarding correlation but cannot perform other operations.
 * *   If an associated forwarding correlation cannot be found, the associated forwarding correlation is deleted.
 *
 * @param request DissociateTransitRouterAttachmentFromRouteTableRequest
 * @return DissociateTransitRouterAttachmentFromRouteTableResponse
 */
func (client *Client) DissociateTransitRouterAttachmentFromRouteTable(request *DissociateTransitRouterAttachmentFromRouteTableRequest) (_result *DissociateTransitRouterAttachmentFromRouteTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DissociateTransitRouterAttachmentFromRouteTableResponse{}
	_body, _err := client.DissociateTransitRouterAttachmentFromRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can enable the health check feature for a VBR to monitor the Express Connect circuit between your data center and Alibaba Cloud. This helps you detect connection issues in a timely manner.
 * Before you use the health check feature, take note of the following information:
 * *   If your VBR uses static routing, you must add a static route for the data center that is connected to the VBR after you configure the health check feature. Set the destination CIDR block to the source IP address of health checks, set the mask length to 32, and set the next hop to the IP address of the VBR on the Alibaba Cloud side.
 * *   If your VBR uses dynamic Border Gateway Protocol (BGP) routing, you do not need to add routes for the data center.
 * *   **EnableCenVbrHealthCheck** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **DescribeCenVbrHealthCheck** operation to query the status of health check configurations. If health check configurations are returned, health check is configured or modified.
 *
 * @param request EnableCenVbrHealthCheckRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableCenVbrHealthCheckResponse
 */
func (client *Client) EnableCenVbrHealthCheckWithOptions(request *EnableCenVbrHealthCheckRequest, runtime *util.RuntimeOptions) (_result *EnableCenVbrHealthCheckResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckInterval)) {
		query["HealthCheckInterval"] = request.HealthCheckInterval
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckOnly)) {
		query["HealthCheckOnly"] = request.HealthCheckOnly
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckSourceIp)) {
		query["HealthCheckSourceIp"] = request.HealthCheckSourceIp
	}

	if !tea.BoolValue(util.IsUnset(request.HealthCheckTargetIp)) {
		query["HealthCheckTargetIp"] = request.HealthCheckTargetIp
	}

	if !tea.BoolValue(util.IsUnset(request.HealthyThreshold)) {
		query["HealthyThreshold"] = request.HealthyThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrInstanceId)) {
		query["VbrInstanceId"] = request.VbrInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrInstanceOwnerId)) {
		query["VbrInstanceOwnerId"] = request.VbrInstanceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VbrInstanceRegionId)) {
		query["VbrInstanceRegionId"] = request.VbrInstanceRegionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableCenVbrHealthCheck"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableCenVbrHealthCheckResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can enable the health check feature for a VBR to monitor the Express Connect circuit between your data center and Alibaba Cloud. This helps you detect connection issues in a timely manner.
 * Before you use the health check feature, take note of the following information:
 * *   If your VBR uses static routing, you must add a static route for the data center that is connected to the VBR after you configure the health check feature. Set the destination CIDR block to the source IP address of health checks, set the mask length to 32, and set the next hop to the IP address of the VBR on the Alibaba Cloud side.
 * *   If your VBR uses dynamic Border Gateway Protocol (BGP) routing, you do not need to add routes for the data center.
 * *   **EnableCenVbrHealthCheck** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **DescribeCenVbrHealthCheck** operation to query the status of health check configurations. If health check configurations are returned, health check is configured or modified.
 *
 * @param request EnableCenVbrHealthCheckRequest
 * @return EnableCenVbrHealthCheckResponse
 */
func (client *Client) EnableCenVbrHealthCheck(request *EnableCenVbrHealthCheckRequest) (_result *EnableCenVbrHealthCheckResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableCenVbrHealthCheckResponse{}
	_body, _err := client.EnableCenVbrHealthCheckWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you establish a network instance connection on a transit router, you can create a route learning correlation for the network instance connection. Then, the routes of the connected network instance are automatically advertised to the route table of the transit router. Before you begin, we recommend that you take note of the following rules:
 * *   You can create route learning correlations only on Enterprise Edition transit routers. For more information about the regions and zones that support Enterprise Edition transit routers, see [What is CEN?](~~181681~~)
 * *   **EnableTransitRouterRouteTablePropagation** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterRouteTablePropagations** operation to query the route learning status between a network instance connection and a route table.
 *     *   **Enabling** indicates that a route learning correlation is being created between the network instance connection and route table. You can query the route learning correlation but cannot perform other operations.
 *     *   **Active** indicates that the route learning correlation is created between the network instance connection and route table.
 *
 * @param request EnableTransitRouterRouteTablePropagationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableTransitRouterRouteTablePropagationResponse
 */
func (client *Client) EnableTransitRouterRouteTablePropagationWithOptions(request *EnableTransitRouterRouteTablePropagationRequest, runtime *util.RuntimeOptions) (_result *EnableTransitRouterRouteTablePropagationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableId)) {
		query["TransitRouterRouteTableId"] = request.TransitRouterRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableTransitRouterRouteTablePropagation"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableTransitRouterRouteTablePropagationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you establish a network instance connection on a transit router, you can create a route learning correlation for the network instance connection. Then, the routes of the connected network instance are automatically advertised to the route table of the transit router. Before you begin, we recommend that you take note of the following rules:
 * *   You can create route learning correlations only on Enterprise Edition transit routers. For more information about the regions and zones that support Enterprise Edition transit routers, see [What is CEN?](~~181681~~)
 * *   **EnableTransitRouterRouteTablePropagation** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterRouteTablePropagations** operation to query the route learning status between a network instance connection and a route table.
 *     *   **Enabling** indicates that a route learning correlation is being created between the network instance connection and route table. You can query the route learning correlation but cannot perform other operations.
 *     *   **Active** indicates that the route learning correlation is created between the network instance connection and route table.
 *
 * @param request EnableTransitRouterRouteTablePropagationRequest
 * @return EnableTransitRouterRouteTablePropagationResponse
 */
func (client *Client) EnableTransitRouterRouteTablePropagation(request *EnableTransitRouterRouteTablePropagationRequest) (_result *EnableTransitRouterRouteTablePropagationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableTransitRouterRouteTablePropagationResponse{}
	_body, _err := client.EnableTransitRouterRouteTablePropagationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The type of the network instance. Valid values:
 * *   **VPC**: VPC
 * *   **ExpressConnect**: VBR
 * *   **VPN**: IPsec-VPN connection
 *
 * @param request GrantInstanceToTransitRouterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantInstanceToTransitRouterResponse
 */
func (client *Client) GrantInstanceToTransitRouterWithOptions(request *GrantInstanceToTransitRouterRequest, runtime *util.RuntimeOptions) (_result *GrantInstanceToTransitRouterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.CenOwnerId)) {
		query["CenOwnerId"] = request.CenOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OrderType)) {
		query["OrderType"] = request.OrderType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GrantInstanceToTransitRouter"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GrantInstanceToTransitRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The type of the network instance. Valid values:
 * *   **VPC**: VPC
 * *   **ExpressConnect**: VBR
 * *   **VPN**: IPsec-VPN connection
 *
 * @param request GrantInstanceToTransitRouterRequest
 * @return GrantInstanceToTransitRouterResponse
 */
func (client *Client) GrantInstanceToTransitRouter(request *GrantInstanceToTransitRouterRequest) (_result *GrantInstanceToTransitRouterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GrantInstanceToTransitRouterResponse{}
	_body, _err := client.GrantInstanceToTransitRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListCenChildInstanceRouteEntriesToAttachmentWithOptions(request *ListCenChildInstanceRouteEntriesToAttachmentRequest, runtime *util.RuntimeOptions) (_result *ListCenChildInstanceRouteEntriesToAttachmentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRouteTableId)) {
		query["ChildInstanceRouteTableId"] = request.ChildInstanceRouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteFilter)) {
		query["RouteFilter"] = request.RouteFilter
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceType)) {
		query["ServiceType"] = request.ServiceType
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCenChildInstanceRouteEntriesToAttachment"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCenChildInstanceRouteEntriesToAttachmentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListCenChildInstanceRouteEntriesToAttachment(request *ListCenChildInstanceRouteEntriesToAttachmentRequest) (_result *ListCenChildInstanceRouteEntriesToAttachmentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCenChildInstanceRouteEntriesToAttachmentResponse{}
	_body, _err := client.ListCenChildInstanceRouteEntriesToAttachmentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call the **ListCenInterRegionTrafficQosPolicies** operation, take note of the following information:
 * *   If you do not set the **TrafficQosPolicyId** parameter, the system returns information about QoS policies based on the values of the **TransitRouterId**, **TransitRouterAttachmentId**, **TrafficQosPolicyName**, and **TrafficQosPolicyDescription** parameters, but does not return information about the queues in the QoS policies. The **TrafficQosQueues** parameter is not included in the response.
 * *   If you specify a QoS policy ID in the **TrafficMarkingPolicyId** parameter, the system returns the information about the QoS policy and the queues. The **TrafficQosQueues** parameter is included in the response.
 *     If the **TrafficQosQueues** parameter contains an empty array, it indicates that the QoS policy contains only the default queue.
 *
 * @param request ListCenInterRegionTrafficQosPoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCenInterRegionTrafficQosPoliciesResponse
 */
func (client *Client) ListCenInterRegionTrafficQosPoliciesWithOptions(request *ListCenInterRegionTrafficQosPoliciesRequest, runtime *util.RuntimeOptions) (_result *ListCenInterRegionTrafficQosPoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficQosPolicyDescription)) {
		query["TrafficQosPolicyDescription"] = request.TrafficQosPolicyDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficQosPolicyId)) {
		query["TrafficQosPolicyId"] = request.TrafficQosPolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficQosPolicyName)) {
		query["TrafficQosPolicyName"] = request.TrafficQosPolicyName
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCenInterRegionTrafficQosPolicies"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCenInterRegionTrafficQosPoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call the **ListCenInterRegionTrafficQosPolicies** operation, take note of the following information:
 * *   If you do not set the **TrafficQosPolicyId** parameter, the system returns information about QoS policies based on the values of the **TransitRouterId**, **TransitRouterAttachmentId**, **TrafficQosPolicyName**, and **TrafficQosPolicyDescription** parameters, but does not return information about the queues in the QoS policies. The **TrafficQosQueues** parameter is not included in the response.
 * *   If you specify a QoS policy ID in the **TrafficMarkingPolicyId** parameter, the system returns the information about the QoS policy and the queues. The **TrafficQosQueues** parameter is included in the response.
 *     If the **TrafficQosQueues** parameter contains an empty array, it indicates that the QoS policy contains only the default queue.
 *
 * @param request ListCenInterRegionTrafficQosPoliciesRequest
 * @return ListCenInterRegionTrafficQosPoliciesResponse
 */
func (client *Client) ListCenInterRegionTrafficQosPolicies(request *ListCenInterRegionTrafficQosPoliciesRequest) (_result *ListCenInterRegionTrafficQosPoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCenInterRegionTrafficQosPoliciesResponse{}
	_body, _err := client.ListCenInterRegionTrafficQosPoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListCenInterRegionTrafficQosQueuesWithOptions(request *ListCenInterRegionTrafficQosQueuesRequest, runtime *util.RuntimeOptions) (_result *ListCenInterRegionTrafficQosQueuesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficQosPolicyId)) {
		query["TrafficQosPolicyId"] = request.TrafficQosPolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficQosQueueDescription)) {
		query["TrafficQosQueueDescription"] = request.TrafficQosQueueDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficQosQueueId)) {
		query["TrafficQosQueueId"] = request.TrafficQosQueueId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficQosQueueName)) {
		query["TrafficQosQueueName"] = request.TrafficQosQueueName
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCenInterRegionTrafficQosQueues"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCenInterRegionTrafficQosQueuesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListCenInterRegionTrafficQosQueues(request *ListCenInterRegionTrafficQosQueuesRequest) (_result *ListCenInterRegionTrafficQosQueuesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCenInterRegionTrafficQosQueuesResponse{}
	_body, _err := client.ListCenInterRegionTrafficQosQueuesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call `ListGrantVSwitchEnis`, make sure that the VPC is attached to a Cloud Enterprise Network (CEN) instance. For more information, see [CreateTransitRouterVpcAttachment](~~468237~~).
 *
 * @param request ListGrantVSwitchEnisRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGrantVSwitchEnisResponse
 */
func (client *Client) ListGrantVSwitchEnisWithOptions(request *ListGrantVSwitchEnisRequest, runtime *util.RuntimeOptions) (_result *ListGrantVSwitchEnisResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkInterfaceId)) {
		query["NetworkInterfaceId"] = request.NetworkInterfaceId
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkInterfaceName)) {
		query["NetworkInterfaceName"] = request.NetworkInterfaceName
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrimaryIpAddress)) {
		query["PrimaryIpAddress"] = request.PrimaryIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchId)) {
		query["VSwitchId"] = request.VSwitchId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGrantVSwitchEnis"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGrantVSwitchEnisResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call `ListGrantVSwitchEnis`, make sure that the VPC is attached to a Cloud Enterprise Network (CEN) instance. For more information, see [CreateTransitRouterVpcAttachment](~~468237~~).
 *
 * @param request ListGrantVSwitchEnisRequest
 * @return ListGrantVSwitchEnisResponse
 */
func (client *Client) ListGrantVSwitchEnis(request *ListGrantVSwitchEnisRequest) (_result *ListGrantVSwitchEnisResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGrantVSwitchEnisResponse{}
	_body, _err := client.ListGrantVSwitchEnisWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call the `ListGrantVSwitchesToCen` operation, make sure that the following requirements are met:
 * *   The permissions on the VPC are granted to the CEN instance. For more information, see [GrantInstanceToCen](~~126224~~).
 * *   The VPC is attached to the CEN instance.
 *     *   For more information about how to connect an Enterprise Edition transit router to a VPC, see [CreateTransitRouterVpcAttachment](~~261358~~).
 *     *   For more information about how to connect a Basic Edition transit router to a VPC, see [AttachCenChildInstance](~~65902~~).
 *
 * @param request ListGrantVSwitchesToCenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGrantVSwitchesToCenResponse
 */
func (client *Client) ListGrantVSwitchesToCenWithOptions(request *ListGrantVSwitchesToCenRequest, runtime *util.RuntimeOptions) (_result *ListGrantVSwitchesToCenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	if !tea.BoolValue(util.IsUnset(request.ZoneId)) {
		query["ZoneId"] = request.ZoneId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListGrantVSwitchesToCen"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListGrantVSwitchesToCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call the `ListGrantVSwitchesToCen` operation, make sure that the following requirements are met:
 * *   The permissions on the VPC are granted to the CEN instance. For more information, see [GrantInstanceToCen](~~126224~~).
 * *   The VPC is attached to the CEN instance.
 *     *   For more information about how to connect an Enterprise Edition transit router to a VPC, see [CreateTransitRouterVpcAttachment](~~261358~~).
 *     *   For more information about how to connect a Basic Edition transit router to a VPC, see [AttachCenChildInstance](~~65902~~).
 *
 * @param request ListGrantVSwitchesToCenRequest
 * @return ListGrantVSwitchesToCenResponse
 */
func (client *Client) ListGrantVSwitchesToCen(request *ListGrantVSwitchesToCenRequest) (_result *ListGrantVSwitchesToCenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListGrantVSwitchesToCenResponse{}
	_body, _err := client.ListGrantVSwitchesToCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * To call this operation, you must set at least one of **ResourceId.N** and **Tag.N.Key**.
 * *   If you set only **ResourceId.N**, the tags that are added to the specified CEN instances are returned.
 * *   If you set only **Tag.N.Key**, the CEN instances that have the specified tags are returned.
 * *   If you set both **ResourceId.N** and **Tag.N.Key**, the specified tags that are added to the specified CEN instances are returned.
 *     *   Make sure that the CEN instance specified by **ResourceId.N** has the tag specified by **Tag.N.Key**. Otherwise, the response returns null.
 *     *   If multiple tag keys are specified, the logical operator among these tag keys is **AND**.
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
func (client *Client) ListTagResourcesWithOptions(request *ListTagResourcesRequest, runtime *util.RuntimeOptions) (_result *ListTagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTagResources"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * To call this operation, you must set at least one of **ResourceId.N** and **Tag.N.Key**.
 * *   If you set only **ResourceId.N**, the tags that are added to the specified CEN instances are returned.
 * *   If you set only **Tag.N.Key**, the CEN instances that have the specified tags are returned.
 * *   If you set both **ResourceId.N** and **Tag.N.Key**, the specified tags that are added to the specified CEN instances are returned.
 *     *   Make sure that the CEN instance specified by **ResourceId.N** has the tag specified by **Tag.N.Key**. Otherwise, the response returns null.
 *     *   If multiple tag keys are specified, the logical operator among these tag keys is **AND**.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
func (client *Client) ListTagResources(request *ListTagResourcesRequest) (_result *ListTagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTagResourcesResponse{}
	_body, _err := client.ListTagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTrafficMarkingPoliciesWithOptions(request *ListTrafficMarkingPoliciesRequest, runtime *util.RuntimeOptions) (_result *ListTrafficMarkingPoliciesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMarkingPolicyDescription)) {
		query["TrafficMarkingPolicyDescription"] = request.TrafficMarkingPolicyDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMarkingPolicyId)) {
		query["TrafficMarkingPolicyId"] = request.TrafficMarkingPolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMarkingPolicyName)) {
		query["TrafficMarkingPolicyName"] = request.TrafficMarkingPolicyName
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTrafficMarkingPolicies"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTrafficMarkingPoliciesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTrafficMarkingPolicies(request *ListTrafficMarkingPoliciesRequest) (_result *ListTrafficMarkingPoliciesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTrafficMarkingPoliciesResponse{}
	_body, _err := client.ListTrafficMarkingPoliciesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call the **ListTransitRouterAvailableResource** operation to query the zones that support Enterprise Edition transit routers in a specified region.
 *     *   If you do not set **SupportMulticast** to **true**, general-purpose zones that support Enterprise Edition transit routers are queried.
 *     *   If you set **SupportMulticast** to **true**, zones in which Enterprise Edition transit routers support multicast are queried.
 * *   On May 31, 2022, VPC-connected Enterprise Edition transit routers were optimized. Optimized Enterprise Edition transit routers do not require you to specify the primary and secondary zones when you connect VPCs to the Enterprise Edition transit routers. You can specify one or more zones.
 *     *   If your Enterprise Edition transit router has not been optimized, you must specify the primary and secondary zones when you connect a VPC to your Enterprise Edition transit router. After you call **ListTransitRouterAvailableResource**, you can call **MasterZones** and **SlaveZones** to query the primary and secondary zones.
 *     *   If your Enterprise Edition transit router has been optimized, you can specify a zone as needed when you connect a VPC to your Enterprise Edition transit router. After you call **ListTransitRouterAvailableResource**, you can call **AvailableZones** to query the zones.
 * For more information about the optimization, see [Announcement: Optimization on VPC-connected Enterprise Edition transit routers](~~434191~~).
 *
 * @param request ListTransitRouterAvailableResourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTransitRouterAvailableResourceResponse
 */
func (client *Client) ListTransitRouterAvailableResourceWithOptions(request *ListTransitRouterAvailableResourceRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterAvailableResourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.SupportMulticast)) {
		query["SupportMulticast"] = request.SupportMulticast
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterAvailableResource"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterAvailableResourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call the **ListTransitRouterAvailableResource** operation to query the zones that support Enterprise Edition transit routers in a specified region.
 *     *   If you do not set **SupportMulticast** to **true**, general-purpose zones that support Enterprise Edition transit routers are queried.
 *     *   If you set **SupportMulticast** to **true**, zones in which Enterprise Edition transit routers support multicast are queried.
 * *   On May 31, 2022, VPC-connected Enterprise Edition transit routers were optimized. Optimized Enterprise Edition transit routers do not require you to specify the primary and secondary zones when you connect VPCs to the Enterprise Edition transit routers. You can specify one or more zones.
 *     *   If your Enterprise Edition transit router has not been optimized, you must specify the primary and secondary zones when you connect a VPC to your Enterprise Edition transit router. After you call **ListTransitRouterAvailableResource**, you can call **MasterZones** and **SlaveZones** to query the primary and secondary zones.
 *     *   If your Enterprise Edition transit router has been optimized, you can specify a zone as needed when you connect a VPC to your Enterprise Edition transit router. After you call **ListTransitRouterAvailableResource**, you can call **AvailableZones** to query the zones.
 * For more information about the optimization, see [Announcement: Optimization on VPC-connected Enterprise Edition transit routers](~~434191~~).
 *
 * @param request ListTransitRouterAvailableResourceRequest
 * @return ListTransitRouterAvailableResourceResponse
 */
func (client *Client) ListTransitRouterAvailableResource(request *ListTransitRouterAvailableResourceRequest) (_result *ListTransitRouterAvailableResourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterAvailableResourceResponse{}
	_body, _err := client.ListTransitRouterAvailableResourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTransitRouterCidrWithOptions(request *ListTransitRouterCidrRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterCidrResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterCidrId)) {
		query["TransitRouterCidrId"] = request.TransitRouterCidrId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterCidr"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterCidrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTransitRouterCidr(request *ListTransitRouterCidrRequest) (_result *ListTransitRouterCidrResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterCidrResponse{}
	_body, _err := client.ListTransitRouterCidrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTransitRouterCidrAllocationWithOptions(request *ListTransitRouterCidrAllocationRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterCidrAllocationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AttachmentId)) {
		query["AttachmentId"] = request.AttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.AttachmentName)) {
		query["AttachmentName"] = request.AttachmentName
	}

	if !tea.BoolValue(util.IsUnset(request.Cidr)) {
		query["Cidr"] = request.Cidr
	}

	if !tea.BoolValue(util.IsUnset(request.CidrBlock)) {
		query["CidrBlock"] = request.CidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DedicatedOwnerId)) {
		query["DedicatedOwnerId"] = request.DedicatedOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterCidrId)) {
		query["TransitRouterCidrId"] = request.TransitRouterCidrId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterCidrAllocation"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterCidrAllocationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTransitRouterCidrAllocation(request *ListTransitRouterCidrAllocationRequest) (_result *ListTransitRouterCidrAllocationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterCidrAllocationResponse{}
	_body, _err := client.ListTransitRouterCidrAllocationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * Multicast domains can be associated only with vSwitches that are in VPCs. You can call the **ListTransitRouterMulticastDomainAssociations** operation to query whether vSwitches in VPCs are associated with a specified multicast domain.
 *
 * @param request ListTransitRouterMulticastDomainAssociationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTransitRouterMulticastDomainAssociationsResponse
 */
func (client *Client) ListTransitRouterMulticastDomainAssociationsWithOptions(request *ListTransitRouterMulticastDomainAssociationsRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterMulticastDomainAssociationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterMulticastDomainId)) {
		query["TransitRouterMulticastDomainId"] = request.TransitRouterMulticastDomainId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchIds)) {
		query["VSwitchIds"] = request.VSwitchIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterMulticastDomainAssociations"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterMulticastDomainAssociationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * Multicast domains can be associated only with vSwitches that are in VPCs. You can call the **ListTransitRouterMulticastDomainAssociations** operation to query whether vSwitches in VPCs are associated with a specified multicast domain.
 *
 * @param request ListTransitRouterMulticastDomainAssociationsRequest
 * @return ListTransitRouterMulticastDomainAssociationsResponse
 */
func (client *Client) ListTransitRouterMulticastDomainAssociations(request *ListTransitRouterMulticastDomainAssociationsRequest) (_result *ListTransitRouterMulticastDomainAssociationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterMulticastDomainAssociationsResponse{}
	_body, _err := client.ListTransitRouterMulticastDomainAssociationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTransitRouterMulticastDomainVSwitchesWithOptions(request *ListTransitRouterMulticastDomainVSwitchesRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterMulticastDomainVSwitchesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchIds)) {
		query["VSwitchIds"] = request.VSwitchIds
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterMulticastDomainVSwitches"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterMulticastDomainVSwitchesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTransitRouterMulticastDomainVSwitches(request *ListTransitRouterMulticastDomainVSwitchesRequest) (_result *ListTransitRouterMulticastDomainVSwitchesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterMulticastDomainVSwitchesResponse{}
	_body, _err := client.ListTransitRouterMulticastDomainVSwitchesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTransitRouterMulticastDomainsWithOptions(request *ListTransitRouterMulticastDomainsRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterMulticastDomainsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterMulticastDomainId)) {
		query["TransitRouterMulticastDomainId"] = request.TransitRouterMulticastDomainId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterMulticastDomains"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterMulticastDomainsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTransitRouterMulticastDomains(request *ListTransitRouterMulticastDomainsRequest) (_result *ListTransitRouterMulticastDomainsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterMulticastDomainsResponse{}
	_body, _err := client.ListTransitRouterMulticastDomainsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the `ListTransitRouterMulticastGroups` operation to query the multicast sources and members in a multicast domain. Multicast sources and members are also known as multicast resources.
 * *   If you set **GroupIpAddress**, the system queries multicast resources in the multicast domain by multicast group.
 * *   If you set **VSwitchIds**, the system queries multicast resources in the multicast domain by vSwitch.
 * *   If you set **PeerTransitRouterMulticastDomains**, the system queries multicast resources that are also deployed in a different region.
 * *   If you set **ResourceType**, the system queries the multicast resources of the specified type in the multicast domain.
 * *   If you set **ResourceId**, the system queries multicast resources by resource.
 * *   If you set only **TransitRouterMulticastDomainId**, the system queries all the multicast resources in the multicast domain.
 *
 * @param request ListTransitRouterMulticastGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTransitRouterMulticastGroupsResponse
 */
func (client *Client) ListTransitRouterMulticastGroupsWithOptions(request *ListTransitRouterMulticastGroupsRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterMulticastGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.GroupIpAddress)) {
		query["GroupIpAddress"] = request.GroupIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.IsGroupMember)) {
		query["IsGroupMember"] = request.IsGroupMember
	}

	if !tea.BoolValue(util.IsUnset(request.IsGroupSource)) {
		query["IsGroupSource"] = request.IsGroupSource
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkInterfaceIds)) {
		query["NetworkInterfaceIds"] = request.NetworkInterfaceIds
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerTransitRouterMulticastDomains)) {
		query["PeerTransitRouterMulticastDomains"] = request.PeerTransitRouterMulticastDomains
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterMulticastDomainId)) {
		query["TransitRouterMulticastDomainId"] = request.TransitRouterMulticastDomainId
	}

	if !tea.BoolValue(util.IsUnset(request.VSwitchIds)) {
		query["VSwitchIds"] = request.VSwitchIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterMulticastGroups"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterMulticastGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the `ListTransitRouterMulticastGroups` operation to query the multicast sources and members in a multicast domain. Multicast sources and members are also known as multicast resources.
 * *   If you set **GroupIpAddress**, the system queries multicast resources in the multicast domain by multicast group.
 * *   If you set **VSwitchIds**, the system queries multicast resources in the multicast domain by vSwitch.
 * *   If you set **PeerTransitRouterMulticastDomains**, the system queries multicast resources that are also deployed in a different region.
 * *   If you set **ResourceType**, the system queries the multicast resources of the specified type in the multicast domain.
 * *   If you set **ResourceId**, the system queries multicast resources by resource.
 * *   If you set only **TransitRouterMulticastDomainId**, the system queries all the multicast resources in the multicast domain.
 *
 * @param request ListTransitRouterMulticastGroupsRequest
 * @return ListTransitRouterMulticastGroupsResponse
 */
func (client *Client) ListTransitRouterMulticastGroups(request *ListTransitRouterMulticastGroupsRequest) (_result *ListTransitRouterMulticastGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterMulticastGroupsResponse{}
	_body, _err := client.ListTransitRouterMulticastGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can use the following methods to query inter-region connections on an Enterprise Edition transit router:
 * *   Query all inter-region connections on an Enterprise Edition transit router by specifying the ID of the Enterprise Edition transit router.
 * *   Query all inter-region connections on an Enterprise Edition transit router by specifying the ID of the Cloud Enterprise Network (CEN) instance and the ID of the region where the transit router is deployed.
 *
 * @param request ListTransitRouterPeerAttachmentsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTransitRouterPeerAttachmentsResponse
 */
func (client *Client) ListTransitRouterPeerAttachmentsWithOptions(request *ListTransitRouterPeerAttachmentsRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterPeerAttachmentsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterPeerAttachments"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterPeerAttachmentsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can use the following methods to query inter-region connections on an Enterprise Edition transit router:
 * *   Query all inter-region connections on an Enterprise Edition transit router by specifying the ID of the Enterprise Edition transit router.
 * *   Query all inter-region connections on an Enterprise Edition transit router by specifying the ID of the Cloud Enterprise Network (CEN) instance and the ID of the region where the transit router is deployed.
 *
 * @param request ListTransitRouterPeerAttachmentsRequest
 * @return ListTransitRouterPeerAttachmentsResponse
 */
func (client *Client) ListTransitRouterPeerAttachments(request *ListTransitRouterPeerAttachmentsRequest) (_result *ListTransitRouterPeerAttachmentsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterPeerAttachmentsResponse{}
	_body, _err := client.ListTransitRouterPeerAttachmentsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTransitRouterPrefixListAssociationWithOptions(request *ListTransitRouterPrefixListAssociationRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterPrefixListAssociationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NextHop)) {
		query["NextHop"] = request.NextHop
	}

	if !tea.BoolValue(util.IsUnset(request.NextHopInstanceId)) {
		query["NextHopInstanceId"] = request.NextHopInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NextHopType)) {
		query["NextHopType"] = request.NextHopType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerUid)) {
		query["OwnerUid"] = request.OwnerUid
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListId)) {
		query["PrefixListId"] = request.PrefixListId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterTableId)) {
		query["TransitRouterTableId"] = request.TransitRouterTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterPrefixListAssociation"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterPrefixListAssociationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTransitRouterPrefixListAssociation(request *ListTransitRouterPrefixListAssociationRequest) (_result *ListTransitRouterPrefixListAssociationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterPrefixListAssociationResponse{}
	_body, _err := client.ListTransitRouterPrefixListAssociationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTransitRouterRouteEntriesWithOptions(request *ListTransitRouterRouteEntriesRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterRouteEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PrefixListId)) {
		query["PrefixListId"] = request.PrefixListId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteFilter)) {
		query["RouteFilter"] = request.RouteFilter
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryDestinationCidrBlock)) {
		query["TransitRouterRouteEntryDestinationCidrBlock"] = request.TransitRouterRouteEntryDestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryIds)) {
		query["TransitRouterRouteEntryIds"] = request.TransitRouterRouteEntryIds
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryNames)) {
		query["TransitRouterRouteEntryNames"] = request.TransitRouterRouteEntryNames
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryNextHopId)) {
		query["TransitRouterRouteEntryNextHopId"] = request.TransitRouterRouteEntryNextHopId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryNextHopResourceId)) {
		query["TransitRouterRouteEntryNextHopResourceId"] = request.TransitRouterRouteEntryNextHopResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryNextHopResourceType)) {
		query["TransitRouterRouteEntryNextHopResourceType"] = request.TransitRouterRouteEntryNextHopResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryNextHopType)) {
		query["TransitRouterRouteEntryNextHopType"] = request.TransitRouterRouteEntryNextHopType
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryOriginResourceId)) {
		query["TransitRouterRouteEntryOriginResourceId"] = request.TransitRouterRouteEntryOriginResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryOriginResourceType)) {
		query["TransitRouterRouteEntryOriginResourceType"] = request.TransitRouterRouteEntryOriginResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryStatus)) {
		query["TransitRouterRouteEntryStatus"] = request.TransitRouterRouteEntryStatus
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryType)) {
		query["TransitRouterRouteEntryType"] = request.TransitRouterRouteEntryType
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableId)) {
		query["TransitRouterRouteTableId"] = request.TransitRouterRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterRouteEntries"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTransitRouterRouteEntries(request *ListTransitRouterRouteEntriesRequest) (_result *ListTransitRouterRouteEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterRouteEntriesResponse{}
	_body, _err := client.ListTransitRouterRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call **ListTransitRouterRouteTableAssociations**, you must set at least one of **TransitRouterRouteTableId** and **TransitRouterAttachmentId**.
 * *   If you set only **TransitRouterRouteTableId**, the network instance connections that are in associated forwarding correlation with a route table of an Enterprise Edition transit router are queried.
 * *   If you set only **TransitRouterAttachmentId**, the route table of an Enterprise Edition transit router that is in associated forwarding correlation with a network instance connection is queried.
 * *   If you set both **TransitRouterRouteTableId** and **TransitRouterAttachmentId**, the associated forwarding correlations between a specified network instance connection and a specified route table of an Enterprise Edition transit router are queried.
 *     *   If an associated forwarding correlation is created between the network instance connection and the route table of the Enterprise Edition transit router, the information about the associated forwarding correlation is returned.
 *     *   If no associated forwarding correlation is created between the network instance connection and the route table of the Enterprise Edition transit router, **TransitRouterAssociations** in the response is empty.
 *
 * @param request ListTransitRouterRouteTableAssociationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTransitRouterRouteTableAssociationsResponse
 */
func (client *Client) ListTransitRouterRouteTableAssociationsWithOptions(request *ListTransitRouterRouteTableAssociationsRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterRouteTableAssociationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentResourceId)) {
		query["TransitRouterAttachmentResourceId"] = request.TransitRouterAttachmentResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentResourceType)) {
		query["TransitRouterAttachmentResourceType"] = request.TransitRouterAttachmentResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableId)) {
		query["TransitRouterRouteTableId"] = request.TransitRouterRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterRouteTableAssociations"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterRouteTableAssociationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call **ListTransitRouterRouteTableAssociations**, you must set at least one of **TransitRouterRouteTableId** and **TransitRouterAttachmentId**.
 * *   If you set only **TransitRouterRouteTableId**, the network instance connections that are in associated forwarding correlation with a route table of an Enterprise Edition transit router are queried.
 * *   If you set only **TransitRouterAttachmentId**, the route table of an Enterprise Edition transit router that is in associated forwarding correlation with a network instance connection is queried.
 * *   If you set both **TransitRouterRouteTableId** and **TransitRouterAttachmentId**, the associated forwarding correlations between a specified network instance connection and a specified route table of an Enterprise Edition transit router are queried.
 *     *   If an associated forwarding correlation is created between the network instance connection and the route table of the Enterprise Edition transit router, the information about the associated forwarding correlation is returned.
 *     *   If no associated forwarding correlation is created between the network instance connection and the route table of the Enterprise Edition transit router, **TransitRouterAssociations** in the response is empty.
 *
 * @param request ListTransitRouterRouteTableAssociationsRequest
 * @return ListTransitRouterRouteTableAssociationsResponse
 */
func (client *Client) ListTransitRouterRouteTableAssociations(request *ListTransitRouterRouteTableAssociationsRequest) (_result *ListTransitRouterRouteTableAssociationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterRouteTableAssociationsResponse{}
	_body, _err := client.ListTransitRouterRouteTableAssociationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTransitRouterRouteTablePropagationsWithOptions(request *ListTransitRouterRouteTablePropagationsRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterRouteTablePropagationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentResourceId)) {
		query["TransitRouterAttachmentResourceId"] = request.TransitRouterAttachmentResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentResourceType)) {
		query["TransitRouterAttachmentResourceType"] = request.TransitRouterAttachmentResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableId)) {
		query["TransitRouterRouteTableId"] = request.TransitRouterRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterRouteTablePropagations"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterRouteTablePropagationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTransitRouterRouteTablePropagations(request *ListTransitRouterRouteTablePropagationsRequest) (_result *ListTransitRouterRouteTablePropagationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterRouteTablePropagationsResponse{}
	_body, _err := client.ListTransitRouterRouteTablePropagationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTransitRouterRouteTablesWithOptions(request *ListTransitRouterRouteTablesRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterRouteTablesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableOptions)) {
		query["RouteTableOptions"] = request.RouteTableOptions
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableIds)) {
		query["TransitRouterRouteTableIds"] = request.TransitRouterRouteTableIds
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableNames)) {
		query["TransitRouterRouteTableNames"] = request.TransitRouterRouteTableNames
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableStatus)) {
		query["TransitRouterRouteTableStatus"] = request.TransitRouterRouteTableStatus
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableType)) {
		query["TransitRouterRouteTableType"] = request.TransitRouterRouteTableType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterRouteTables"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterRouteTablesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTransitRouterRouteTables(request *ListTransitRouterRouteTablesRequest) (_result *ListTransitRouterRouteTablesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterRouteTablesResponse{}
	_body, _err := client.ListTransitRouterRouteTablesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can use the following methods to query VBR connections on an Enterprise Edition transit router:
 * *   Specify the ID of the Enterprise Edition transit router.
 * *   Specify the ID of the relevant Cloud Enterprise Network (CEN) instance and the region ID of the Enterprise Edition transit router.
 *
 * @param request ListTransitRouterVbrAttachmentsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTransitRouterVbrAttachmentsResponse
 */
func (client *Client) ListTransitRouterVbrAttachmentsWithOptions(request *ListTransitRouterVbrAttachmentsRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterVbrAttachmentsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterVbrAttachments"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterVbrAttachmentsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can use the following methods to query VBR connections on an Enterprise Edition transit router:
 * *   Specify the ID of the Enterprise Edition transit router.
 * *   Specify the ID of the relevant Cloud Enterprise Network (CEN) instance and the region ID of the Enterprise Edition transit router.
 *
 * @param request ListTransitRouterVbrAttachmentsRequest
 * @return ListTransitRouterVbrAttachmentsResponse
 */
func (client *Client) ListTransitRouterVbrAttachments(request *ListTransitRouterVbrAttachmentsRequest) (_result *ListTransitRouterVbrAttachmentsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterVbrAttachmentsResponse{}
	_body, _err := client.ListTransitRouterVbrAttachmentsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can use the following methods to query VPC connections on an Enterprise Edition transit router:
 * *   Specify the ID of the Enterprise Edition transit router.
 * *   Specify the ID of the relevant Cloud Enterprise Network (CEN) instance and the region ID of the Enterprise Edition transit router.
 * *   Specify the ID of the region where the Enterprise Edition transit router is deployed.
 *
 * @param request ListTransitRouterVpcAttachmentsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTransitRouterVpcAttachmentsResponse
 */
func (client *Client) ListTransitRouterVpcAttachmentsWithOptions(request *ListTransitRouterVpcAttachmentsRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterVpcAttachmentsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OrderType)) {
		query["OrderType"] = request.OrderType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterVpcAttachments"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterVpcAttachmentsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can use the following methods to query VPC connections on an Enterprise Edition transit router:
 * *   Specify the ID of the Enterprise Edition transit router.
 * *   Specify the ID of the relevant Cloud Enterprise Network (CEN) instance and the region ID of the Enterprise Edition transit router.
 * *   Specify the ID of the region where the Enterprise Edition transit router is deployed.
 *
 * @param request ListTransitRouterVpcAttachmentsRequest
 * @return ListTransitRouterVpcAttachmentsResponse
 */
func (client *Client) ListTransitRouterVpcAttachments(request *ListTransitRouterVpcAttachmentsRequest) (_result *ListTransitRouterVpcAttachmentsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterVpcAttachmentsResponse{}
	_body, _err := client.ListTransitRouterVpcAttachmentsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call the **ListTransitRouterVpnAttachments** operation, take note of the following items:
 * *   If you set only **CenId** and **RegionId**, the VPN attachments in the current region are queried.
 * *   If you set **CenId**, **RegionId**, and **TransitRouterAttachmentId**, only the specified VPN attachment is queried.
 * *   If you set **CenId** and **RegionId**, you do not need to set **TransitRouterId**. If you set **TransitRouterId**, you do not need to set **CenId** or **RegionId**.
 *
 * @param request ListTransitRouterVpnAttachmentsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTransitRouterVpnAttachmentsResponse
 */
func (client *Client) ListTransitRouterVpnAttachmentsWithOptions(request *ListTransitRouterVpnAttachmentsRequest, runtime *util.RuntimeOptions) (_result *ListTransitRouterVpnAttachmentsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.MaxResults)) {
		query["MaxResults"] = request.MaxResults
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouterVpnAttachments"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRouterVpnAttachmentsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call the **ListTransitRouterVpnAttachments** operation, take note of the following items:
 * *   If you set only **CenId** and **RegionId**, the VPN attachments in the current region are queried.
 * *   If you set **CenId**, **RegionId**, and **TransitRouterAttachmentId**, only the specified VPN attachment is queried.
 * *   If you set **CenId** and **RegionId**, you do not need to set **TransitRouterId**. If you set **TransitRouterId**, you do not need to set **CenId** or **RegionId**.
 *
 * @param request ListTransitRouterVpnAttachmentsRequest
 * @return ListTransitRouterVpnAttachmentsResponse
 */
func (client *Client) ListTransitRouterVpnAttachments(request *ListTransitRouterVpnAttachmentsRequest) (_result *ListTransitRouterVpnAttachmentsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRouterVpnAttachmentsResponse{}
	_body, _err := client.ListTransitRouterVpnAttachmentsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The tag value.
 *
 * @param request ListTransitRoutersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTransitRoutersResponse
 */
func (client *Client) ListTransitRoutersWithOptions(request *ListTransitRoutersRequest, runtime *util.RuntimeOptions) (_result *ListTransitRoutersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.FeatureFilter)) {
		query["FeatureFilter"] = request.FeatureFilter
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterName)) {
		query["TransitRouterName"] = request.TransitRouterName
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTransitRouters"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTransitRoutersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The tag value.
 *
 * @param request ListTransitRoutersRequest
 * @return ListTransitRoutersResponse
 */
func (client *Client) ListTransitRouters(request *ListTransitRoutersRequest) (_result *ListTransitRoutersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTransitRoutersResponse{}
	_body, _err := client.ListTransitRoutersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **ModifyCenAttribute**.
 *
 * @param request ModifyCenAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCenAttributeResponse
 */
func (client *Client) ModifyCenAttributeWithOptions(request *ModifyCenAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyCenAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProtectionLevel)) {
		query["ProtectionLevel"] = request.ProtectionLevel
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCenAttribute"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCenAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **ModifyCenAttribute**.
 *
 * @param request ModifyCenAttributeRequest
 * @return ModifyCenAttributeResponse
 */
func (client *Client) ModifyCenAttribute(request *ModifyCenAttributeRequest) (_result *ModifyCenAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCenAttributeResponse{}
	_body, _err := client.ModifyCenAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyCenBandwidthPackageAttributeWithOptions(request *ModifyCenBandwidthPackageAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyCenBandwidthPackageAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenBandwidthPackageId)) {
		query["CenBandwidthPackageId"] = request.CenBandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCenBandwidthPackageAttribute"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCenBandwidthPackageAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyCenBandwidthPackageAttribute(request *ModifyCenBandwidthPackageAttributeRequest) (_result *ModifyCenBandwidthPackageAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCenBandwidthPackageAttributeResponse{}
	_body, _err := client.ModifyCenBandwidthPackageAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyCenBandwidthPackageSpecWithOptions(request *ModifyCenBandwidthPackageSpecRequest, runtime *util.RuntimeOptions) (_result *ModifyCenBandwidthPackageSpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.CenBandwidthPackageId)) {
		query["CenBandwidthPackageId"] = request.CenBandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCenBandwidthPackageSpec"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCenBandwidthPackageSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyCenBandwidthPackageSpec(request *ModifyCenBandwidthPackageSpecRequest) (_result *ModifyCenBandwidthPackageSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCenBandwidthPackageSpecResponse{}
	_body, _err := client.ModifyCenBandwidthPackageSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The response.
 *
 * @param request ModifyCenRouteMapRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyCenRouteMapResponse
 */
func (client *Client) ModifyCenRouteMapWithOptions(request *ModifyCenRouteMapRequest, runtime *util.RuntimeOptions) (_result *ModifyCenRouteMapResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AsPathMatchMode)) {
		query["AsPathMatchMode"] = request.AsPathMatchMode
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.CenRegionId)) {
		query["CenRegionId"] = request.CenRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.CidrMatchMode)) {
		query["CidrMatchMode"] = request.CidrMatchMode
	}

	if !tea.BoolValue(util.IsUnset(request.CommunityMatchMode)) {
		query["CommunityMatchMode"] = request.CommunityMatchMode
	}

	if !tea.BoolValue(util.IsUnset(request.CommunityOperateMode)) {
		query["CommunityOperateMode"] = request.CommunityOperateMode
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationChildInstanceTypes)) {
		query["DestinationChildInstanceTypes"] = request.DestinationChildInstanceTypes
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlocks)) {
		query["DestinationCidrBlocks"] = request.DestinationCidrBlocks
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationInstanceIds)) {
		query["DestinationInstanceIds"] = request.DestinationInstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationInstanceIdsReverseMatch)) {
		query["DestinationInstanceIdsReverseMatch"] = request.DestinationInstanceIdsReverseMatch
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationRouteTableIds)) {
		query["DestinationRouteTableIds"] = request.DestinationRouteTableIds
	}

	if !tea.BoolValue(util.IsUnset(request.MapResult)) {
		query["MapResult"] = request.MapResult
	}

	if !tea.BoolValue(util.IsUnset(request.MatchAddressType)) {
		query["MatchAddressType"] = request.MatchAddressType
	}

	if !tea.BoolValue(util.IsUnset(request.MatchAsns)) {
		query["MatchAsns"] = request.MatchAsns
	}

	if !tea.BoolValue(util.IsUnset(request.MatchCommunitySet)) {
		query["MatchCommunitySet"] = request.MatchCommunitySet
	}

	if !tea.BoolValue(util.IsUnset(request.NextPriority)) {
		query["NextPriority"] = request.NextPriority
	}

	if !tea.BoolValue(util.IsUnset(request.OperateCommunitySet)) {
		query["OperateCommunitySet"] = request.OperateCommunitySet
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.Preference)) {
		query["Preference"] = request.Preference
	}

	if !tea.BoolValue(util.IsUnset(request.PrependAsPath)) {
		query["PrependAsPath"] = request.PrependAsPath
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		query["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteMapId)) {
		query["RouteMapId"] = request.RouteMapId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTypes)) {
		query["RouteTypes"] = request.RouteTypes
	}

	if !tea.BoolValue(util.IsUnset(request.SourceChildInstanceTypes)) {
		query["SourceChildInstanceTypes"] = request.SourceChildInstanceTypes
	}

	if !tea.BoolValue(util.IsUnset(request.SourceInstanceIds)) {
		query["SourceInstanceIds"] = request.SourceInstanceIds
	}

	if !tea.BoolValue(util.IsUnset(request.SourceInstanceIdsReverseMatch)) {
		query["SourceInstanceIdsReverseMatch"] = request.SourceInstanceIdsReverseMatch
	}

	if !tea.BoolValue(util.IsUnset(request.SourceRegionIds)) {
		query["SourceRegionIds"] = request.SourceRegionIds
	}

	if !tea.BoolValue(util.IsUnset(request.SourceRouteTableIds)) {
		query["SourceRouteTableIds"] = request.SourceRouteTableIds
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyCenRouteMap"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyCenRouteMapResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The response.
 *
 * @param request ModifyCenRouteMapRequest
 * @return ModifyCenRouteMapResponse
 */
func (client *Client) ModifyCenRouteMap(request *ModifyCenRouteMapRequest) (_result *ModifyCenRouteMapResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyCenRouteMapResponse{}
	_body, _err := client.ModifyCenRouteMapWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyFlowLogAttributeWithOptions(request *ModifyFlowLogAttributeRequest, runtime *util.RuntimeOptions) (_result *ModifyFlowLogAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.FlowLogId)) {
		query["FlowLogId"] = request.FlowLogId
	}

	if !tea.BoolValue(util.IsUnset(request.FlowLogName)) {
		query["FlowLogName"] = request.FlowLogName
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyFlowLogAttribute"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyFlowLogAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyFlowLogAttribute(request *ModifyFlowLogAttributeRequest) (_result *ModifyFlowLogAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyFlowLogAttributeResponse{}
	_body, _err := client.ModifyFlowLogAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The new description of the transit router CIDR block.
 * The description must be 1 to 256 characters in length.
 *
 * @param request ModifyTransitRouterCidrRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyTransitRouterCidrResponse
 */
func (client *Client) ModifyTransitRouterCidrWithOptions(request *ModifyTransitRouterCidrRequest, runtime *util.RuntimeOptions) (_result *ModifyTransitRouterCidrResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Cidr)) {
		query["Cidr"] = request.Cidr
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PublishCidrRoute)) {
		query["PublishCidrRoute"] = request.PublishCidrRoute
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterCidrId)) {
		query["TransitRouterCidrId"] = request.TransitRouterCidrId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyTransitRouterCidr"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyTransitRouterCidrResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The new description of the transit router CIDR block.
 * The description must be 1 to 256 characters in length.
 *
 * @param request ModifyTransitRouterCidrRequest
 * @return ModifyTransitRouterCidrResponse
 */
func (client *Client) ModifyTransitRouterCidr(request *ModifyTransitRouterCidrRequest) (_result *ModifyTransitRouterCidrResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyTransitRouterCidrResponse{}
	_body, _err := client.ModifyTransitRouterCidrWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyTransitRouterMulticastDomainWithOptions(request *ModifyTransitRouterMulticastDomainRequest, runtime *util.RuntimeOptions) (_result *ModifyTransitRouterMulticastDomainResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterMulticastDomainDescription)) {
		query["TransitRouterMulticastDomainDescription"] = request.TransitRouterMulticastDomainDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterMulticastDomainId)) {
		query["TransitRouterMulticastDomainId"] = request.TransitRouterMulticastDomainId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterMulticastDomainName)) {
		query["TransitRouterMulticastDomainName"] = request.TransitRouterMulticastDomainName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyTransitRouterMulticastDomain"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyTransitRouterMulticastDomainResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyTransitRouterMulticastDomain(request *ModifyTransitRouterMulticastDomainRequest) (_result *ModifyTransitRouterMulticastDomainResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyTransitRouterMulticastDomainResponse{}
	_body, _err := client.ModifyTransitRouterMulticastDomainWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * By default, CEN instances and bandwidth plans are in the default resource group. You can call the `MoveResourceGroup` operation to move CEN instances or bandwidth plans to another resource group.
 *
 * @param request MoveResourceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MoveResourceGroupResponse
 */
func (client *Client) MoveResourceGroupWithOptions(request *MoveResourceGroupRequest, runtime *util.RuntimeOptions) (_result *MoveResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.NewResourceGroupId)) {
		query["NewResourceGroupId"] = request.NewResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("MoveResourceGroup"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MoveResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * By default, CEN instances and bandwidth plans are in the default resource group. You can call the `MoveResourceGroup` operation to move CEN instances or bandwidth plans to another resource group.
 *
 * @param request MoveResourceGroupRequest
 * @return MoveResourceGroupResponse
 */
func (client *Client) MoveResourceGroup(request *MoveResourceGroupRequest) (_result *MoveResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MoveResourceGroupResponse{}
	_body, _err := client.MoveResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the `OpenTransitRouterService` operation to activate the transit router feature free of charge. After the `OpenTransitRouterService` operation succeeds, an order is automatically generated. You can use the returned order ID to query the order information in [Alibaba Cloud User Center](https://usercenter2-intl.aliyun.com/billing/#/account/overview).
 *
 * @param request OpenTransitRouterServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenTransitRouterServiceResponse
 */
func (client *Client) OpenTransitRouterServiceWithOptions(request *OpenTransitRouterServiceRequest, runtime *util.RuntimeOptions) (_result *OpenTransitRouterServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OpenTransitRouterService"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OpenTransitRouterServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the `OpenTransitRouterService` operation to activate the transit router feature free of charge. After the `OpenTransitRouterService` operation succeeds, an order is automatically generated. You can use the returned order ID to query the order information in [Alibaba Cloud User Center](https://usercenter2-intl.aliyun.com/billing/#/account/overview).
 *
 * @param request OpenTransitRouterServiceRequest
 * @return OpenTransitRouterServiceResponse
 */
func (client *Client) OpenTransitRouterService(request *OpenTransitRouterServiceRequest) (_result *OpenTransitRouterServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OpenTransitRouterServiceResponse{}
	_body, _err := client.OpenTransitRouterServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The following table describes whether routes of different types are advertised to CEN by default. You can call the PublishRouteEntries operation to advertise routes to CEN.
 * |Route|Network instance|Advertised to CEN by default|
 * |---|---|---|
 * |Routes that route network traffic to Elastic Compute Service (ECS) instances|VPC|No|
 * |Routes that route network traffic to VPN gateways|VPC|No|
 * |Routes that route network traffic to high-availability virtual IP addresses (HAVIPs)|VPC|No|
 * |Routes that route network traffic to router interfaces|VPC|No|
 * |Routes that route network traffic to elastic network interfaces (ENIs)|VPC|No|
 * |Routes that route network traffic to IPv6 gateways|VPC|No|
 * |Routes that route network traffic to NAT gateways|VPC|No|
 * |System routes of VPCs|VPC|Yes|
 * |Routes that route network traffic to data centers|VBR|Yes|
 * |Border Gateway Protocol (BGP) routes|VBR|Yes|
 *
 * @param request PublishRouteEntriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishRouteEntriesResponse
 */
func (client *Client) PublishRouteEntriesWithOptions(request *PublishRouteEntriesRequest, runtime *util.RuntimeOptions) (_result *PublishRouteEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceId)) {
		query["ChildInstanceId"] = request.ChildInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRegionId)) {
		query["ChildInstanceRegionId"] = request.ChildInstanceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRouteTableId)) {
		query["ChildInstanceRouteTableId"] = request.ChildInstanceRouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceType)) {
		query["ChildInstanceType"] = request.ChildInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlock)) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PublishRouteEntries"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PublishRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The following table describes whether routes of different types are advertised to CEN by default. You can call the PublishRouteEntries operation to advertise routes to CEN.
 * |Route|Network instance|Advertised to CEN by default|
 * |---|---|---|
 * |Routes that route network traffic to Elastic Compute Service (ECS) instances|VPC|No|
 * |Routes that route network traffic to VPN gateways|VPC|No|
 * |Routes that route network traffic to high-availability virtual IP addresses (HAVIPs)|VPC|No|
 * |Routes that route network traffic to router interfaces|VPC|No|
 * |Routes that route network traffic to elastic network interfaces (ENIs)|VPC|No|
 * |Routes that route network traffic to IPv6 gateways|VPC|No|
 * |Routes that route network traffic to NAT gateways|VPC|No|
 * |System routes of VPCs|VPC|Yes|
 * |Routes that route network traffic to data centers|VBR|Yes|
 * |Border Gateway Protocol (BGP) routes|VBR|Yes|
 *
 * @param request PublishRouteEntriesRequest
 * @return PublishRouteEntriesResponse
 */
func (client *Client) PublishRouteEntries(request *PublishRouteEntriesRequest) (_result *PublishRouteEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PublishRouteEntriesResponse{}
	_body, _err := client.PublishRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RefreshTransitRouteTableAggregationWithOptions(request *RefreshTransitRouteTableAggregationRequest, runtime *util.RuntimeOptions) (_result *RefreshTransitRouteTableAggregationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouteTableAggregationCidr)) {
		query["TransitRouteTableAggregationCidr"] = request.TransitRouteTableAggregationCidr
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouteTableId)) {
		query["TransitRouteTableId"] = request.TransitRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RefreshTransitRouteTableAggregation"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RefreshTransitRouteTableAggregationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RefreshTransitRouteTableAggregation(request *RefreshTransitRouteTableAggregationRequest) (_result *RefreshTransitRouteTableAggregationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RefreshTransitRouteTableAggregationResponse{}
	_body, _err := client.RefreshTransitRouteTableAggregationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request RegisterTransitRouterMulticastGroupMembersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RegisterTransitRouterMulticastGroupMembersResponse
 */
func (client *Client) RegisterTransitRouterMulticastGroupMembersWithOptions(request *RegisterTransitRouterMulticastGroupMembersRequest, runtime *util.RuntimeOptions) (_result *RegisterTransitRouterMulticastGroupMembersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.GroupIpAddress)) {
		query["GroupIpAddress"] = request.GroupIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkInterfaceIds)) {
		query["NetworkInterfaceIds"] = request.NetworkInterfaceIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PeerTransitRouterMulticastDomains)) {
		query["PeerTransitRouterMulticastDomains"] = request.PeerTransitRouterMulticastDomains
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterMulticastDomainId)) {
		query["TransitRouterMulticastDomainId"] = request.TransitRouterMulticastDomainId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RegisterTransitRouterMulticastGroupMembers"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RegisterTransitRouterMulticastGroupMembersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request RegisterTransitRouterMulticastGroupMembersRequest
 * @return RegisterTransitRouterMulticastGroupMembersResponse
 */
func (client *Client) RegisterTransitRouterMulticastGroupMembers(request *RegisterTransitRouterMulticastGroupMembersRequest) (_result *RegisterTransitRouterMulticastGroupMembersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RegisterTransitRouterMulticastGroupMembersResponse{}
	_body, _err := client.RegisterTransitRouterMulticastGroupMembersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request RegisterTransitRouterMulticastGroupSourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RegisterTransitRouterMulticastGroupSourcesResponse
 */
func (client *Client) RegisterTransitRouterMulticastGroupSourcesWithOptions(request *RegisterTransitRouterMulticastGroupSourcesRequest, runtime *util.RuntimeOptions) (_result *RegisterTransitRouterMulticastGroupSourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.GroupIpAddress)) {
		query["GroupIpAddress"] = request.GroupIpAddress
	}

	if !tea.BoolValue(util.IsUnset(request.NetworkInterfaceIds)) {
		query["NetworkInterfaceIds"] = request.NetworkInterfaceIds
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterMulticastDomainId)) {
		query["TransitRouterMulticastDomainId"] = request.TransitRouterMulticastDomainId
	}

	if !tea.BoolValue(util.IsUnset(request.VpcId)) {
		query["VpcId"] = request.VpcId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RegisterTransitRouterMulticastGroupSources"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RegisterTransitRouterMulticastGroupSourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request RegisterTransitRouterMulticastGroupSourcesRequest
 * @return RegisterTransitRouterMulticastGroupSourcesResponse
 */
func (client *Client) RegisterTransitRouterMulticastGroupSources(request *RegisterTransitRouterMulticastGroupSourcesRequest) (_result *RegisterTransitRouterMulticastGroupSourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RegisterTransitRouterMulticastGroupSourcesResponse{}
	_body, _err := client.RegisterTransitRouterMulticastGroupSourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponse
 */
func (client *Client) RemoveTrafficMatchRuleFromTrafficMarkingPolicyWithOptions(request *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest, runtime *util.RuntimeOptions) (_result *RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMarkRuleIds)) {
		query["TrafficMarkRuleIds"] = request.TrafficMarkRuleIds
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMarkingPolicyId)) {
		query["TrafficMarkingPolicyId"] = request.TrafficMarkingPolicyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveTrafficMatchRuleFromTrafficMarkingPolicy"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest
 * @return RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponse
 */
func (client *Client) RemoveTrafficMatchRuleFromTrafficMarkingPolicy(request *RemoveTrafficMatchRuleFromTrafficMarkingPolicyRequest) (_result *RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveTrafficMatchRuleFromTrafficMarkingPolicyResponse{}
	_body, _err := client.RemoveTrafficMatchRuleFromTrafficMarkingPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated : RemoveTraficMatchRuleFromTrafficMarkingPolicy is deprecated, please use Cbn::2017-09-12::RemoveTrafficMatchRuleFromTrafficMarkingPolicy instead.
 * The ID of the traffic marking policy.
 *
 * @param request RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveTraficMatchRuleFromTrafficMarkingPolicyResponse
 */
// Deprecated
func (client *Client) RemoveTraficMatchRuleFromTrafficMarkingPolicyWithOptions(request *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest, runtime *util.RuntimeOptions) (_result *RemoveTraficMatchRuleFromTrafficMarkingPolicyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMarkRuleIds)) {
		query["TrafficMarkRuleIds"] = request.TrafficMarkRuleIds
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMarkingPolicyId)) {
		query["TrafficMarkingPolicyId"] = request.TrafficMarkingPolicyId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveTraficMatchRuleFromTrafficMarkingPolicy"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveTraficMatchRuleFromTrafficMarkingPolicyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated : RemoveTraficMatchRuleFromTrafficMarkingPolicy is deprecated, please use Cbn::2017-09-12::RemoveTrafficMatchRuleFromTrafficMarkingPolicy instead.
 * The ID of the traffic marking policy.
 *
 * @param request RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest
 * @return RemoveTraficMatchRuleFromTrafficMarkingPolicyResponse
 */
// Deprecated
func (client *Client) RemoveTraficMatchRuleFromTrafficMarkingPolicy(request *RemoveTraficMatchRuleFromTrafficMarkingPolicyRequest) (_result *RemoveTraficMatchRuleFromTrafficMarkingPolicyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveTraficMatchRuleFromTrafficMarkingPolicyResponse{}
	_body, _err := client.RemoveTraficMatchRuleFromTrafficMarkingPolicyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ReplaceTransitRouterRouteTableAssociationWithOptions(request *ReplaceTransitRouterRouteTableAssociationRequest, runtime *util.RuntimeOptions) (_result *ReplaceTransitRouterRouteTableAssociationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableId)) {
		query["TransitRouterRouteTableId"] = request.TransitRouterRouteTableId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReplaceTransitRouterRouteTableAssociation"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReplaceTransitRouterRouteTableAssociationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ReplaceTransitRouterRouteTableAssociation(request *ReplaceTransitRouterRouteTableAssociationRequest) (_result *ReplaceTransitRouterRouteTableAssociationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReplaceTransitRouterRouteTableAssociationResponse{}
	_body, _err := client.ReplaceTransitRouterRouteTableAssociationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Cloud services refer to the Alibaba Cloud services that use the 100.64.0.0/10 CIDR block to provide services. These cloud services include Object Storage Service (OSS), Log Service, and Data Transmission Service (DTS). If your on-premises network needs to access a cloud service, you must attach the virtual border router (VBR) or Cloud Connect Network (CCN) instance that is connected to your on-premises network to a Cloud Enterprise Network (CEN) instance. In addition, you must attach a virtual private cloud (VPC) that is deployed in the same region as the cloud service to the CEN instance. This way, your on-premises network can connect to the VPC that is deployed in the same region as the cloud service and access the cloud service through the VPC.
 * *   An on-premises network associated with a VBR can use CEN to access only a cloud service that is deployed in the same region.
 *     For example, if cloud services are deployed in the China (Beijing) region, only on-premises networks connected to VBRs in the China (Beijing) region can access the cloud services.
 * *   **ResolveAndRouteServiceInCen** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **DescribeRouteServicesInCen** operation to query the status of a cloud service.
 *     *   If a cloud service is in the **Creating** state, the connection to the cloud service is being created. In this case, you can query the cloud service but cannot perform other operations.
 *     *   If a cloud service is in the **Active** state, the connection to the cloud service is created.
 *     *   If a cloud service is in the **Failed** state, the connection to the cloud service failed.
 * # Prerequisites
 * Before you call this operation, make sure that the following conditions are met:
 * *   The VBR or CCN instance to which your on-premises network is connected is attached to a CEN instance.
 * *   A VPC that is deployed in the same region as the cloud service is also attached to the CEN instance. For more information, see [AttachCenChildInstance](~~65902~~).
 *
 * @param request ResolveAndRouteServiceInCenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResolveAndRouteServiceInCenResponse
 */
func (client *Client) ResolveAndRouteServiceInCenWithOptions(request *ResolveAndRouteServiceInCenRequest, runtime *util.RuntimeOptions) (_result *ResolveAndRouteServiceInCenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessRegionIds)) {
		query["AccessRegionIds"] = request.AccessRegionIds
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Host)) {
		query["Host"] = request.Host
	}

	if !tea.BoolValue(util.IsUnset(request.HostRegionId)) {
		query["HostRegionId"] = request.HostRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.HostVpcId)) {
		query["HostVpcId"] = request.HostVpcId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResolveAndRouteServiceInCen"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ResolveAndRouteServiceInCenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Cloud services refer to the Alibaba Cloud services that use the 100.64.0.0/10 CIDR block to provide services. These cloud services include Object Storage Service (OSS), Log Service, and Data Transmission Service (DTS). If your on-premises network needs to access a cloud service, you must attach the virtual border router (VBR) or Cloud Connect Network (CCN) instance that is connected to your on-premises network to a Cloud Enterprise Network (CEN) instance. In addition, you must attach a virtual private cloud (VPC) that is deployed in the same region as the cloud service to the CEN instance. This way, your on-premises network can connect to the VPC that is deployed in the same region as the cloud service and access the cloud service through the VPC.
 * *   An on-premises network associated with a VBR can use CEN to access only a cloud service that is deployed in the same region.
 *     For example, if cloud services are deployed in the China (Beijing) region, only on-premises networks connected to VBRs in the China (Beijing) region can access the cloud services.
 * *   **ResolveAndRouteServiceInCen** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **DescribeRouteServicesInCen** operation to query the status of a cloud service.
 *     *   If a cloud service is in the **Creating** state, the connection to the cloud service is being created. In this case, you can query the cloud service but cannot perform other operations.
 *     *   If a cloud service is in the **Active** state, the connection to the cloud service is created.
 *     *   If a cloud service is in the **Failed** state, the connection to the cloud service failed.
 * # Prerequisites
 * Before you call this operation, make sure that the following conditions are met:
 * *   The VBR or CCN instance to which your on-premises network is connected is attached to a CEN instance.
 * *   A VPC that is deployed in the same region as the cloud service is also attached to the CEN instance. For more information, see [AttachCenChildInstance](~~65902~~).
 *
 * @param request ResolveAndRouteServiceInCenRequest
 * @return ResolveAndRouteServiceInCenResponse
 */
func (client *Client) ResolveAndRouteServiceInCen(request *ResolveAndRouteServiceInCenRequest) (_result *ResolveAndRouteServiceInCenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ResolveAndRouteServiceInCenResponse{}
	_body, _err := client.ResolveAndRouteServiceInCenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * `RevokeInstanceFromTransitRouter` disallows transit routers only from connecting to virtual private clouds (VPCs), virtual border routers (VBRs), and IPsec-VPN connections.
 * If you want to disallow transit routers from connecting to Cloud Connect Network (CCN) instances, call the [RevokeInstanceFromCbn](https://www.alibabacloud.com/help/en/smart-access-gateway/latest/revokeinstancefromcbn) operation.
 * ## Prerequisites
 * Before you call `RevokeInstanceFromTransitRouter`, you must detach the network instances from the transit router.
 * - For more information about how to detach VPCs from an Enterprise Edition transit router, see [DeleteTransitRouterVpcAttachment](https://www.alibabacloud.com/help/en/cloud-enterprise-network/latest/deletetransitroutervpcattachment).
 * - For more information about how to detach VBRs from an Enterprise Edition transit router, see [DeleteTransitRouterVbrAttachment](https://www.alibabacloud.com/help/en/cloud-enterprise-network/latest/deletetransitroutervbrattachment).
 * - For more information about how to detach network instances from a Basic Edition transit router, see [DetachCenChildInstance](~~468685~~).
 *
 * @param request RevokeInstanceFromTransitRouterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokeInstanceFromTransitRouterResponse
 */
func (client *Client) RevokeInstanceFromTransitRouterWithOptions(request *RevokeInstanceFromTransitRouterRequest, runtime *util.RuntimeOptions) (_result *RevokeInstanceFromTransitRouterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.CenOwnerId)) {
		query["CenOwnerId"] = request.CenOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceType)) {
		query["InstanceType"] = request.InstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RevokeInstanceFromTransitRouter"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RevokeInstanceFromTransitRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * `RevokeInstanceFromTransitRouter` disallows transit routers only from connecting to virtual private clouds (VPCs), virtual border routers (VBRs), and IPsec-VPN connections.
 * If you want to disallow transit routers from connecting to Cloud Connect Network (CCN) instances, call the [RevokeInstanceFromCbn](https://www.alibabacloud.com/help/en/smart-access-gateway/latest/revokeinstancefromcbn) operation.
 * ## Prerequisites
 * Before you call `RevokeInstanceFromTransitRouter`, you must detach the network instances from the transit router.
 * - For more information about how to detach VPCs from an Enterprise Edition transit router, see [DeleteTransitRouterVpcAttachment](https://www.alibabacloud.com/help/en/cloud-enterprise-network/latest/deletetransitroutervpcattachment).
 * - For more information about how to detach VBRs from an Enterprise Edition transit router, see [DeleteTransitRouterVbrAttachment](https://www.alibabacloud.com/help/en/cloud-enterprise-network/latest/deletetransitroutervbrattachment).
 * - For more information about how to detach network instances from a Basic Edition transit router, see [DetachCenChildInstance](~~468685~~).
 *
 * @param request RevokeInstanceFromTransitRouterRequest
 * @return RevokeInstanceFromTransitRouterResponse
 */
func (client *Client) RevokeInstanceFromTransitRouter(request *RevokeInstanceFromTransitRouterRequest) (_result *RevokeInstanceFromTransitRouterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RevokeInstanceFromTransitRouterResponse{}
	_body, _err := client.RevokeInstanceFromTransitRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request RoutePrivateZoneInCenToVpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RoutePrivateZoneInCenToVpcResponse
 */
func (client *Client) RoutePrivateZoneInCenToVpcWithOptions(request *RoutePrivateZoneInCenToVpcRequest, runtime *util.RuntimeOptions) (_result *RoutePrivateZoneInCenToVpcResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessRegionId)) {
		query["AccessRegionId"] = request.AccessRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.HostRegionId)) {
		query["HostRegionId"] = request.HostRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.HostVpcId)) {
		query["HostVpcId"] = request.HostVpcId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RoutePrivateZoneInCenToVpc"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RoutePrivateZoneInCenToVpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the request.
 *
 * @param request RoutePrivateZoneInCenToVpcRequest
 * @return RoutePrivateZoneInCenToVpcResponse
 */
func (client *Client) RoutePrivateZoneInCenToVpc(request *RoutePrivateZoneInCenToVpcRequest) (_result *RoutePrivateZoneInCenToVpcResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RoutePrivateZoneInCenToVpcResponse{}
	_body, _err := client.RoutePrivateZoneInCenToVpcWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetCenInterRegionBandwidthLimitWithOptions(request *SetCenInterRegionBandwidthLimitRequest, runtime *util.RuntimeOptions) (_result *SetCenInterRegionBandwidthLimitResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BandwidthLimit)) {
		query["BandwidthLimit"] = request.BandwidthLimit
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.LocalRegionId)) {
		query["LocalRegionId"] = request.LocalRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.OppositeRegionId)) {
		query["OppositeRegionId"] = request.OppositeRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetCenInterRegionBandwidthLimit"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetCenInterRegionBandwidthLimitResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetCenInterRegionBandwidthLimit(request *SetCenInterRegionBandwidthLimitRequest) (_result *SetCenInterRegionBandwidthLimitResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetCenInterRegionBandwidthLimitResponse{}
	_body, _err := client.SetCenInterRegionBandwidthLimitWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the resource.
 * You can enter multiple resource IDs. Valid values of **N**: **1** to **20**.
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
func (client *Client) TagResourcesWithOptions(request *TagResourcesRequest, runtime *util.RuntimeOptions) (_result *TagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TagResources"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the resource.
 * You can enter multiple resource IDs. Valid values of **N**: **1** to **20**.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
func (client *Client) TagResources(request *TagResourcesRequest) (_result *TagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TagResourcesResponse{}
	_body, _err := client.TagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TempUpgradeCenBandwidthPackageSpecWithOptions(request *TempUpgradeCenBandwidthPackageSpecRequest, runtime *util.RuntimeOptions) (_result *TempUpgradeCenBandwidthPackageSpecResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.CenBandwidthPackageId)) {
		query["CenBandwidthPackageId"] = request.CenBandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TempUpgradeCenBandwidthPackageSpec"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TempUpgradeCenBandwidthPackageSpecResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TempUpgradeCenBandwidthPackageSpec(request *TempUpgradeCenBandwidthPackageSpecRequest) (_result *TempUpgradeCenBandwidthPackageSpecResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TempUpgradeCenBandwidthPackageSpecResponse{}
	_body, _err := client.TempUpgradeCenBandwidthPackageSpecWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * No inter-region connections are configured in the bandwidth plan. For more information about how to delete inter-region connections, see [SetCenInterRegionBandwidthLimit](~~65942~~).
 *
 * @param request UnassociateCenBandwidthPackageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnassociateCenBandwidthPackageResponse
 */
func (client *Client) UnassociateCenBandwidthPackageWithOptions(request *UnassociateCenBandwidthPackageRequest, runtime *util.RuntimeOptions) (_result *UnassociateCenBandwidthPackageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenBandwidthPackageId)) {
		query["CenBandwidthPackageId"] = request.CenBandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnassociateCenBandwidthPackage"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnassociateCenBandwidthPackageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * No inter-region connections are configured in the bandwidth plan. For more information about how to delete inter-region connections, see [SetCenInterRegionBandwidthLimit](~~65942~~).
 *
 * @param request UnassociateCenBandwidthPackageRequest
 * @return UnassociateCenBandwidthPackageResponse
 */
func (client *Client) UnassociateCenBandwidthPackage(request *UnassociateCenBandwidthPackageRequest) (_result *UnassociateCenBandwidthPackageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnassociateCenBandwidthPackageResponse{}
	_body, _err := client.UnassociateCenBandwidthPackageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UnroutePrivateZoneInCenToVpcWithOptions(request *UnroutePrivateZoneInCenToVpcRequest, runtime *util.RuntimeOptions) (_result *UnroutePrivateZoneInCenToVpcResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccessRegionId)) {
		query["AccessRegionId"] = request.AccessRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnroutePrivateZoneInCenToVpc"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnroutePrivateZoneInCenToVpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UnroutePrivateZoneInCenToVpc(request *UnroutePrivateZoneInCenToVpcRequest) (_result *UnroutePrivateZoneInCenToVpcResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnroutePrivateZoneInCenToVpcResponse{}
	_body, _err := client.UnroutePrivateZoneInCenToVpcWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UntagResourcesWithOptions(request *UntagResourcesRequest, runtime *util.RuntimeOptions) (_result *UntagResourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.All)) {
		query["All"] = request.All
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TagKey)) {
		query["TagKey"] = request.TagKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UntagResources"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UntagResourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UntagResources(request *UntagResourcesRequest) (_result *UntagResourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UntagResourcesResponse{}
	_body, _err := client.UntagResourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateCenInterRegionTrafficQosPolicyAttributeWithOptions(request *UpdateCenInterRegionTrafficQosPolicyAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateCenInterRegionTrafficQosPolicyAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficQosPolicyDescription)) {
		query["TrafficQosPolicyDescription"] = request.TrafficQosPolicyDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficQosPolicyId)) {
		query["TrafficQosPolicyId"] = request.TrafficQosPolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficQosPolicyName)) {
		query["TrafficQosPolicyName"] = request.TrafficQosPolicyName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCenInterRegionTrafficQosPolicyAttribute"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateCenInterRegionTrafficQosPolicyAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateCenInterRegionTrafficQosPolicyAttribute(request *UpdateCenInterRegionTrafficQosPolicyAttributeRequest) (_result *UpdateCenInterRegionTrafficQosPolicyAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateCenInterRegionTrafficQosPolicyAttributeResponse{}
	_body, _err := client.UpdateCenInterRegionTrafficQosPolicyAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateCenInterRegionTrafficQosQueueAttributeWithOptions(request *UpdateCenInterRegionTrafficQosQueueAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateCenInterRegionTrafficQosQueueAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.Dscps)) {
		query["Dscps"] = request.Dscps
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.QosQueueDescription)) {
		query["QosQueueDescription"] = request.QosQueueDescription
	}

	if !tea.BoolValue(util.IsUnset(request.QosQueueId)) {
		query["QosQueueId"] = request.QosQueueId
	}

	if !tea.BoolValue(util.IsUnset(request.QosQueueName)) {
		query["QosQueueName"] = request.QosQueueName
	}

	if !tea.BoolValue(util.IsUnset(request.RemainBandwidthPercent)) {
		query["RemainBandwidthPercent"] = request.RemainBandwidthPercent
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateCenInterRegionTrafficQosQueueAttribute"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateCenInterRegionTrafficQosQueueAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateCenInterRegionTrafficQosQueueAttribute(request *UpdateCenInterRegionTrafficQosQueueAttributeRequest) (_result *UpdateCenInterRegionTrafficQosQueueAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateCenInterRegionTrafficQosQueueAttributeResponse{}
	_body, _err := client.UpdateCenInterRegionTrafficQosQueueAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTrafficMarkingPolicyAttributeWithOptions(request *UpdateTrafficMarkingPolicyAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateTrafficMarkingPolicyAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddTrafficMatchRules)) {
		query["AddTrafficMatchRules"] = request.AddTrafficMatchRules
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DeleteTrafficMatchRules)) {
		query["DeleteTrafficMatchRules"] = request.DeleteTrafficMatchRules
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMarkingPolicyDescription)) {
		query["TrafficMarkingPolicyDescription"] = request.TrafficMarkingPolicyDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMarkingPolicyId)) {
		query["TrafficMarkingPolicyId"] = request.TrafficMarkingPolicyId
	}

	if !tea.BoolValue(util.IsUnset(request.TrafficMarkingPolicyName)) {
		query["TrafficMarkingPolicyName"] = request.TrafficMarkingPolicyName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTrafficMarkingPolicyAttribute"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTrafficMarkingPolicyAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTrafficMarkingPolicyAttribute(request *UpdateTrafficMarkingPolicyAttributeRequest) (_result *UpdateTrafficMarkingPolicyAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTrafficMarkingPolicyAttributeResponse{}
	_body, _err := client.UpdateTrafficMarkingPolicyAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **UpdateTransitRouter** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouters** operation to query the status of a transit router.
 * *   If a transit router is in the **Modifying** state, the configuration of the transit router is being modified. You can query the transit router but cannot perform other operations.
 * *   If a transit router is in the **Active** state, the configuration of the transit router is modified.
 *
 * @param request UpdateTransitRouterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTransitRouterResponse
 */
func (client *Client) UpdateTransitRouterWithOptions(request *UpdateTransitRouterRequest, runtime *util.RuntimeOptions) (_result *UpdateTransitRouterResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterDescription)) {
		query["TransitRouterDescription"] = request.TransitRouterDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterId)) {
		query["TransitRouterId"] = request.TransitRouterId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterName)) {
		query["TransitRouterName"] = request.TransitRouterName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTransitRouter"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTransitRouterResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **UpdateTransitRouter** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouters** operation to query the status of a transit router.
 * *   If a transit router is in the **Modifying** state, the configuration of the transit router is being modified. You can query the transit router but cannot perform other operations.
 * *   If a transit router is in the **Active** state, the configuration of the transit router is modified.
 *
 * @param request UpdateTransitRouterRequest
 * @return UpdateTransitRouterResponse
 */
func (client *Client) UpdateTransitRouter(request *UpdateTransitRouterRequest) (_result *UpdateTransitRouterResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTransitRouterResponse{}
	_body, _err := client.UpdateTransitRouterWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **UpdateTransitRouterPeerAttachmentAttribute** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterPeerAttachments** operation to query the status of an inter-region connection.
 * *   If an inter-region connection is in the **Modifying** state, the inter-region connection is being modified. You can query the inter-region connection but cannot perform other operations.
 * *   If an inter-region connection is in the **Attached** state, the inter-region connection is modified.
 *
 * @param request UpdateTransitRouterPeerAttachmentAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTransitRouterPeerAttachmentAttributeResponse
 */
func (client *Client) UpdateTransitRouterPeerAttachmentAttributeWithOptions(request *UpdateTransitRouterPeerAttachmentAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateTransitRouterPeerAttachmentAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPublishRouteEnabled)) {
		query["AutoPublishRouteEnabled"] = request.AutoPublishRouteEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.Bandwidth)) {
		query["Bandwidth"] = request.Bandwidth
	}

	if !tea.BoolValue(util.IsUnset(request.BandwidthType)) {
		query["BandwidthType"] = request.BandwidthType
	}

	if !tea.BoolValue(util.IsUnset(request.CenBandwidthPackageId)) {
		query["CenBandwidthPackageId"] = request.CenBandwidthPackageId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentDescription)) {
		query["TransitRouterAttachmentDescription"] = request.TransitRouterAttachmentDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentName)) {
		query["TransitRouterAttachmentName"] = request.TransitRouterAttachmentName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTransitRouterPeerAttachmentAttribute"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTransitRouterPeerAttachmentAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **UpdateTransitRouterPeerAttachmentAttribute** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterPeerAttachments** operation to query the status of an inter-region connection.
 * *   If an inter-region connection is in the **Modifying** state, the inter-region connection is being modified. You can query the inter-region connection but cannot perform other operations.
 * *   If an inter-region connection is in the **Attached** state, the inter-region connection is modified.
 *
 * @param request UpdateTransitRouterPeerAttachmentAttributeRequest
 * @return UpdateTransitRouterPeerAttachmentAttributeResponse
 */
func (client *Client) UpdateTransitRouterPeerAttachmentAttribute(request *UpdateTransitRouterPeerAttachmentAttributeRequest) (_result *UpdateTransitRouterPeerAttachmentAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTransitRouterPeerAttachmentAttributeResponse{}
	_body, _err := client.UpdateTransitRouterPeerAttachmentAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTransitRouterRouteEntryWithOptions(request *UpdateTransitRouterRouteEntryRequest, runtime *util.RuntimeOptions) (_result *UpdateTransitRouterRouteEntryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryDescription)) {
		query["TransitRouterRouteEntryDescription"] = request.TransitRouterRouteEntryDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryId)) {
		query["TransitRouterRouteEntryId"] = request.TransitRouterRouteEntryId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteEntryName)) {
		query["TransitRouterRouteEntryName"] = request.TransitRouterRouteEntryName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTransitRouterRouteEntry"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTransitRouterRouteEntryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTransitRouterRouteEntry(request *UpdateTransitRouterRouteEntryRequest) (_result *UpdateTransitRouterRouteEntryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTransitRouterRouteEntryResponse{}
	_body, _err := client.UpdateTransitRouterRouteEntryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTransitRouterRouteTableWithOptions(request *UpdateTransitRouterRouteTableRequest, runtime *util.RuntimeOptions) (_result *UpdateTransitRouterRouteTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteTableOptions)) {
		query["RouteTableOptions"] = request.RouteTableOptions
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableDescription)) {
		query["TransitRouterRouteTableDescription"] = request.TransitRouterRouteTableDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableId)) {
		query["TransitRouterRouteTableId"] = request.TransitRouterRouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterRouteTableName)) {
		query["TransitRouterRouteTableName"] = request.TransitRouterRouteTableName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTransitRouterRouteTable"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTransitRouterRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTransitRouterRouteTable(request *UpdateTransitRouterRouteTableRequest) (_result *UpdateTransitRouterRouteTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTransitRouterRouteTableResponse{}
	_body, _err := client.UpdateTransitRouterRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **UpdateTransitRouterVbrAttachmentAttribute** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterVbrAttachments** operation to query the status of a VBR connection.
 * *   If a VBR connection is in the **Modifying** state, the VBR connection is being modified. You can query the VBR connection but cannot perform other operations.
 * *   If the VBR connection is in the **Attached** state, the VBR connection is modified.
 *
 * @param request UpdateTransitRouterVbrAttachmentAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTransitRouterVbrAttachmentAttributeResponse
 */
func (client *Client) UpdateTransitRouterVbrAttachmentAttributeWithOptions(request *UpdateTransitRouterVbrAttachmentAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateTransitRouterVbrAttachmentAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPublishRouteEnabled)) {
		query["AutoPublishRouteEnabled"] = request.AutoPublishRouteEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentDescription)) {
		query["TransitRouterAttachmentDescription"] = request.TransitRouterAttachmentDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentName)) {
		query["TransitRouterAttachmentName"] = request.TransitRouterAttachmentName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTransitRouterVbrAttachmentAttribute"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTransitRouterVbrAttachmentAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **UpdateTransitRouterVbrAttachmentAttribute** is an asynchronous operation. After a request is sent, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterVbrAttachments** operation to query the status of a VBR connection.
 * *   If a VBR connection is in the **Modifying** state, the VBR connection is being modified. You can query the VBR connection but cannot perform other operations.
 * *   If the VBR connection is in the **Attached** state, the VBR connection is modified.
 *
 * @param request UpdateTransitRouterVbrAttachmentAttributeRequest
 * @return UpdateTransitRouterVbrAttachmentAttributeResponse
 */
func (client *Client) UpdateTransitRouterVbrAttachmentAttribute(request *UpdateTransitRouterVbrAttachmentAttributeRequest) (_result *UpdateTransitRouterVbrAttachmentAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTransitRouterVbrAttachmentAttributeResponse{}
	_body, _err := client.UpdateTransitRouterVbrAttachmentAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * **UpdateTransitRouterVpcAttachmentAttribute** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterVpcAttachments** operation to query the status of a VPC connection.
 * *   If a VPC connection is in the **Modifying** state, the VPC connection is being modified. You can query the VPC connection but cannot perform other operations.
 * *   If a VPC connection is in the **Attached** state, the VPC connection is modified.
 *
 * @param request UpdateTransitRouterVpcAttachmentAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTransitRouterVpcAttachmentAttributeResponse
 */
func (client *Client) UpdateTransitRouterVpcAttachmentAttributeWithOptions(request *UpdateTransitRouterVpcAttachmentAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateTransitRouterVpcAttachmentAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPublishRouteEnabled)) {
		query["AutoPublishRouteEnabled"] = request.AutoPublishRouteEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentDescription)) {
		query["TransitRouterAttachmentDescription"] = request.TransitRouterAttachmentDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentName)) {
		query["TransitRouterAttachmentName"] = request.TransitRouterAttachmentName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTransitRouterVpcAttachmentAttribute"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTransitRouterVpcAttachmentAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * **UpdateTransitRouterVpcAttachmentAttribute** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterVpcAttachments** operation to query the status of a VPC connection.
 * *   If a VPC connection is in the **Modifying** state, the VPC connection is being modified. You can query the VPC connection but cannot perform other operations.
 * *   If a VPC connection is in the **Attached** state, the VPC connection is modified.
 *
 * @param request UpdateTransitRouterVpcAttachmentAttributeRequest
 * @return UpdateTransitRouterVpcAttachmentAttributeResponse
 */
func (client *Client) UpdateTransitRouterVpcAttachmentAttribute(request *UpdateTransitRouterVpcAttachmentAttributeRequest) (_result *UpdateTransitRouterVpcAttachmentAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTransitRouterVpcAttachmentAttributeResponse{}
	_body, _err := client.UpdateTransitRouterVpcAttachmentAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   When you add a zone and a vSwitch for a VPC connection, make sure that the vSwitch has at least one idle IP address. When you modify the zones and vSwitches of a VPC connection, the Enterprise Edition transit router creates an elastic network interface (ENI) in the vSwitch. The ENI occupies one IP address in the vSwitch. The ENI forwards traffic between the VPC and the Enterprise Edition transit router.
 * *   **UpdateTransitRouterVpcAttachmentZones** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterVpcAttachments** operation to query the status of a VPC connection.
 *     *   If a VPC connection is in the **Modifying** state, the VPC connection is being modified. You can query the VPC connection but cannot perform other operations.
 *     *   If a VPC connection is in the **Attached** state, the VPC connection is modified.
 *
 * @param request UpdateTransitRouterVpcAttachmentZonesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTransitRouterVpcAttachmentZonesResponse
 */
func (client *Client) UpdateTransitRouterVpcAttachmentZonesWithOptions(request *UpdateTransitRouterVpcAttachmentZonesRequest, runtime *util.RuntimeOptions) (_result *UpdateTransitRouterVpcAttachmentZonesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddZoneMappings)) {
		query["AddZoneMappings"] = request.AddZoneMappings
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.RemoveZoneMappings)) {
		query["RemoveZoneMappings"] = request.RemoveZoneMappings
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTransitRouterVpcAttachmentZones"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTransitRouterVpcAttachmentZonesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   When you add a zone and a vSwitch for a VPC connection, make sure that the vSwitch has at least one idle IP address. When you modify the zones and vSwitches of a VPC connection, the Enterprise Edition transit router creates an elastic network interface (ENI) in the vSwitch. The ENI occupies one IP address in the vSwitch. The ENI forwards traffic between the VPC and the Enterprise Edition transit router.
 * *   **UpdateTransitRouterVpcAttachmentZones** is an asynchronous operation. After you send a request, the system returns a **request ID** and runs the task in the background. You can call the **ListTransitRouterVpcAttachments** operation to query the status of a VPC connection.
 *     *   If a VPC connection is in the **Modifying** state, the VPC connection is being modified. You can query the VPC connection but cannot perform other operations.
 *     *   If a VPC connection is in the **Attached** state, the VPC connection is modified.
 *
 * @param request UpdateTransitRouterVpcAttachmentZonesRequest
 * @return UpdateTransitRouterVpcAttachmentZonesResponse
 */
func (client *Client) UpdateTransitRouterVpcAttachmentZones(request *UpdateTransitRouterVpcAttachmentZonesRequest) (_result *UpdateTransitRouterVpcAttachmentZonesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTransitRouterVpcAttachmentZonesResponse{}
	_body, _err := client.UpdateTransitRouterVpcAttachmentZonesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTransitRouterVpnAttachmentAttributeWithOptions(request *UpdateTransitRouterVpnAttachmentAttributeRequest, runtime *util.RuntimeOptions) (_result *UpdateTransitRouterVpnAttachmentAttributeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AutoPublishRouteEnabled)) {
		query["AutoPublishRouteEnabled"] = request.AutoPublishRouteEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DryRun)) {
		query["DryRun"] = request.DryRun
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerAccount)) {
		query["OwnerAccount"] = request.OwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentDescription)) {
		query["TransitRouterAttachmentDescription"] = request.TransitRouterAttachmentDescription
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentId)) {
		query["TransitRouterAttachmentId"] = request.TransitRouterAttachmentId
	}

	if !tea.BoolValue(util.IsUnset(request.TransitRouterAttachmentName)) {
		query["TransitRouterAttachmentName"] = request.TransitRouterAttachmentName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTransitRouterVpnAttachmentAttribute"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTransitRouterVpnAttachmentAttributeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTransitRouterVpnAttachmentAttribute(request *UpdateTransitRouterVpnAttachmentAttributeRequest) (_result *UpdateTransitRouterVpnAttachmentAttributeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTransitRouterVpnAttachmentAttributeResponse{}
	_body, _err := client.UpdateTransitRouterVpnAttachmentAttributeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) WithdrawPublishedRouteEntriesWithOptions(request *WithdrawPublishedRouteEntriesRequest, runtime *util.RuntimeOptions) (_result *WithdrawPublishedRouteEntriesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CenId)) {
		query["CenId"] = request.CenId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceId)) {
		query["ChildInstanceId"] = request.ChildInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRegionId)) {
		query["ChildInstanceRegionId"] = request.ChildInstanceRegionId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceRouteTableId)) {
		query["ChildInstanceRouteTableId"] = request.ChildInstanceRouteTableId
	}

	if !tea.BoolValue(util.IsUnset(request.ChildInstanceType)) {
		query["ChildInstanceType"] = request.ChildInstanceType
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationCidrBlock)) {
		query["DestinationCidrBlock"] = request.DestinationCidrBlock
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerAccount)) {
		query["ResourceOwnerAccount"] = request.ResourceOwnerAccount
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceOwnerId)) {
		query["ResourceOwnerId"] = request.ResourceOwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("WithdrawPublishedRouteEntries"),
		Version:     tea.String("2017-09-12"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &WithdrawPublishedRouteEntriesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) WithdrawPublishedRouteEntries(request *WithdrawPublishedRouteEntriesRequest) (_result *WithdrawPublishedRouteEntriesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &WithdrawPublishedRouteEntriesResponse{}
	_body, _err := client.WithdrawPublishedRouteEntriesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
