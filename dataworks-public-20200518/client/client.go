// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	openplatform "github.com/alibabacloud-go/openplatform-20191219/v2/client"
	fileform "github.com/alibabacloud-go/tea-fileform/service"
	oss "github.com/alibabacloud-go/tea-oss-sdk/client"
	ossutil "github.com/alibabacloud-go/tea-oss-utils/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
	"io"
)

type Collection struct {
	CollectionType *string `json:"CollectionType,omitempty" xml:"CollectionType,omitempty"`
	Comment        *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	CreateTime     *int64  `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	Level          *int32  `json:"Level,omitempty" xml:"Level,omitempty"`
	Name           *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerId        *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	OwnerName      *string `json:"OwnerName,omitempty" xml:"OwnerName,omitempty"`
	QualifiedName  *string `json:"QualifiedName,omitempty" xml:"QualifiedName,omitempty"`
	UpdateTime     *int64  `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s Collection) String() string {
	return tea.Prettify(s)
}

func (s Collection) GoString() string {
	return s.String()
}

func (s *Collection) SetCollectionType(v string) *Collection {
	s.CollectionType = &v
	return s
}

func (s *Collection) SetComment(v string) *Collection {
	s.Comment = &v
	return s
}

func (s *Collection) SetCreateTime(v int64) *Collection {
	s.CreateTime = &v
	return s
}

func (s *Collection) SetLevel(v int32) *Collection {
	s.Level = &v
	return s
}

func (s *Collection) SetName(v string) *Collection {
	s.Name = &v
	return s
}

func (s *Collection) SetOwnerId(v string) *Collection {
	s.OwnerId = &v
	return s
}

func (s *Collection) SetOwnerName(v string) *Collection {
	s.OwnerName = &v
	return s
}

func (s *Collection) SetQualifiedName(v string) *Collection {
	s.QualifiedName = &v
	return s
}

func (s *Collection) SetUpdateTime(v int64) *Collection {
	s.UpdateTime = &v
	return s
}

type Entity struct {
	EntityContent map[string]interface{} `json:"EntityContent,omitempty" xml:"EntityContent,omitempty"`
	QualifiedName *string                `json:"QualifiedName,omitempty" xml:"QualifiedName,omitempty"`
	TenantId      *int64                 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s Entity) String() string {
	return tea.Prettify(s)
}

func (s Entity) GoString() string {
	return s.String()
}

func (s *Entity) SetEntityContent(v map[string]interface{}) *Entity {
	s.EntityContent = v
	return s
}

func (s *Entity) SetQualifiedName(v string) *Entity {
	s.QualifiedName = &v
	return s
}

func (s *Entity) SetTenantId(v int64) *Entity {
	s.TenantId = &v
	return s
}

type LineageEntityVO struct {
	DetailUrl     *string `json:"DetailUrl,omitempty" xml:"DetailUrl,omitempty"`
	Name          *string `json:"Name,omitempty" xml:"Name,omitempty"`
	ParentName    *string `json:"ParentName,omitempty" xml:"ParentName,omitempty"`
	QualifiedName *string `json:"QualifiedName,omitempty" xml:"QualifiedName,omitempty"`
}

func (s LineageEntityVO) String() string {
	return tea.Prettify(s)
}

func (s LineageEntityVO) GoString() string {
	return s.String()
}

func (s *LineageEntityVO) SetDetailUrl(v string) *LineageEntityVO {
	s.DetailUrl = &v
	return s
}

func (s *LineageEntityVO) SetName(v string) *LineageEntityVO {
	s.Name = &v
	return s
}

func (s *LineageEntityVO) SetParentName(v string) *LineageEntityVO {
	s.ParentName = &v
	return s
}

func (s *LineageEntityVO) SetQualifiedName(v string) *LineageEntityVO {
	s.QualifiedName = &v
	return s
}

type LineageRelationRegisterVO struct {
	CreateTimestamp *int64           `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	DestEntity      *LineageEntityVO `json:"DestEntity,omitempty" xml:"DestEntity,omitempty"`
	Relationship    *RelationshipVO  `json:"Relationship,omitempty" xml:"Relationship,omitempty"`
	SrcEntity       *LineageEntityVO `json:"SrcEntity,omitempty" xml:"SrcEntity,omitempty"`
}

func (s LineageRelationRegisterVO) String() string {
	return tea.Prettify(s)
}

func (s LineageRelationRegisterVO) GoString() string {
	return s.String()
}

func (s *LineageRelationRegisterVO) SetCreateTimestamp(v int64) *LineageRelationRegisterVO {
	s.CreateTimestamp = &v
	return s
}

func (s *LineageRelationRegisterVO) SetDestEntity(v *LineageEntityVO) *LineageRelationRegisterVO {
	s.DestEntity = v
	return s
}

func (s *LineageRelationRegisterVO) SetRelationship(v *RelationshipVO) *LineageRelationRegisterVO {
	s.Relationship = v
	return s
}

func (s *LineageRelationRegisterVO) SetSrcEntity(v *LineageEntityVO) *LineageRelationRegisterVO {
	s.SrcEntity = v
	return s
}

type RelationshipVO struct {
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s RelationshipVO) String() string {
	return tea.Prettify(s)
}

func (s RelationshipVO) GoString() string {
	return s.String()
}

func (s *RelationshipVO) SetType(v string) *RelationshipVO {
	s.Type = &v
	return s
}

type UserEntityTag struct {
	TagKey   *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s UserEntityTag) String() string {
	return tea.Prettify(s)
}

func (s UserEntityTag) GoString() string {
	return s.String()
}

func (s *UserEntityTag) SetTagKey(v string) *UserEntityTag {
	s.TagKey = &v
	return s
}

func (s *UserEntityTag) SetTagValue(v string) *UserEntityTag {
	s.TagValue = &v
	return s
}

type AbolishDataServiceApiRequest struct {
	// The ID of the DataService Studio API.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s AbolishDataServiceApiRequest) String() string {
	return tea.Prettify(s)
}

func (s AbolishDataServiceApiRequest) GoString() string {
	return s.String()
}

func (s *AbolishDataServiceApiRequest) SetApiId(v int64) *AbolishDataServiceApiRequest {
	s.ApiId = &v
	return s
}

func (s *AbolishDataServiceApiRequest) SetProjectId(v int64) *AbolishDataServiceApiRequest {
	s.ProjectId = &v
	return s
}

func (s *AbolishDataServiceApiRequest) SetTenantId(v int64) *AbolishDataServiceApiRequest {
	s.TenantId = &v
	return s
}

type AbolishDataServiceApiResponseBody struct {
	// Indicates whether the DataService Studio API is unpublished.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AbolishDataServiceApiResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AbolishDataServiceApiResponseBody) GoString() string {
	return s.String()
}

func (s *AbolishDataServiceApiResponseBody) SetData(v bool) *AbolishDataServiceApiResponseBody {
	s.Data = &v
	return s
}

func (s *AbolishDataServiceApiResponseBody) SetErrorCode(v string) *AbolishDataServiceApiResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AbolishDataServiceApiResponseBody) SetErrorMessage(v string) *AbolishDataServiceApiResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AbolishDataServiceApiResponseBody) SetHttpStatusCode(v int32) *AbolishDataServiceApiResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AbolishDataServiceApiResponseBody) SetRequestId(v string) *AbolishDataServiceApiResponseBody {
	s.RequestId = &v
	return s
}

func (s *AbolishDataServiceApiResponseBody) SetSuccess(v bool) *AbolishDataServiceApiResponseBody {
	s.Success = &v
	return s
}

type AbolishDataServiceApiResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AbolishDataServiceApiResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AbolishDataServiceApiResponse) String() string {
	return tea.Prettify(s)
}

func (s AbolishDataServiceApiResponse) GoString() string {
	return s.String()
}

func (s *AbolishDataServiceApiResponse) SetHeaders(v map[string]*string) *AbolishDataServiceApiResponse {
	s.Headers = v
	return s
}

func (s *AbolishDataServiceApiResponse) SetStatusCode(v int32) *AbolishDataServiceApiResponse {
	s.StatusCode = &v
	return s
}

func (s *AbolishDataServiceApiResponse) SetBody(v *AbolishDataServiceApiResponseBody) *AbolishDataServiceApiResponse {
	s.Body = v
	return s
}

type AddMetaCollectionEntityRequest struct {
	// The unique identifier of the entity.
	//
	// Example: maxcompute-table.projectA.tableA.
	CollectionQualifiedName *string `json:"CollectionQualifiedName,omitempty" xml:"CollectionQualifiedName,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	EntityQualifiedName *string `json:"EntityQualifiedName,omitempty" xml:"EntityQualifiedName,omitempty"`
	Remark              *string `json:"Remark,omitempty" xml:"Remark,omitempty"`
}

func (s AddMetaCollectionEntityRequest) String() string {
	return tea.Prettify(s)
}

func (s AddMetaCollectionEntityRequest) GoString() string {
	return s.String()
}

func (s *AddMetaCollectionEntityRequest) SetCollectionQualifiedName(v string) *AddMetaCollectionEntityRequest {
	s.CollectionQualifiedName = &v
	return s
}

func (s *AddMetaCollectionEntityRequest) SetEntityQualifiedName(v string) *AddMetaCollectionEntityRequest {
	s.EntityQualifiedName = &v
	return s
}

func (s *AddMetaCollectionEntityRequest) SetRemark(v string) *AddMetaCollectionEntityRequest {
	s.Remark = &v
	return s
}

type AddMetaCollectionEntityResponseBody struct {
	// Indicates whether the request was successful. Valid values:
	//
	// true: The request was successful.
	//
	// false: The request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error code returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The error message returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The result of the operation. Valid values:
	//
	// *   true: succeeded
	// *   false: failed
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The HTTP status code returned.
	Status  *bool `json:"Status,omitempty" xml:"Status,omitempty"`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddMetaCollectionEntityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddMetaCollectionEntityResponseBody) GoString() string {
	return s.String()
}

func (s *AddMetaCollectionEntityResponseBody) SetErrorCode(v string) *AddMetaCollectionEntityResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AddMetaCollectionEntityResponseBody) SetErrorMessage(v string) *AddMetaCollectionEntityResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AddMetaCollectionEntityResponseBody) SetHttpStatusCode(v int32) *AddMetaCollectionEntityResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddMetaCollectionEntityResponseBody) SetRequestId(v string) *AddMetaCollectionEntityResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddMetaCollectionEntityResponseBody) SetStatus(v bool) *AddMetaCollectionEntityResponseBody {
	s.Status = &v
	return s
}

func (s *AddMetaCollectionEntityResponseBody) SetSuccess(v bool) *AddMetaCollectionEntityResponseBody {
	s.Success = &v
	return s
}

type AddMetaCollectionEntityResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddMetaCollectionEntityResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddMetaCollectionEntityResponse) String() string {
	return tea.Prettify(s)
}

func (s AddMetaCollectionEntityResponse) GoString() string {
	return s.String()
}

func (s *AddMetaCollectionEntityResponse) SetHeaders(v map[string]*string) *AddMetaCollectionEntityResponse {
	s.Headers = v
	return s
}

func (s *AddMetaCollectionEntityResponse) SetStatusCode(v int32) *AddMetaCollectionEntityResponse {
	s.StatusCode = &v
	return s
}

func (s *AddMetaCollectionEntityResponse) SetBody(v *AddMetaCollectionEntityResponseBody) *AddMetaCollectionEntityResponse {
	s.Body = v
	return s
}

type AddProjectMemberToRoleRequest struct {
	// The ID of the request. You can use the ID to search for logs and troubleshoot issues based on the logs.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The ID of your Alibaba Cloud account. To view the ID, log on to [the DataWorks console](https://workbench.data.aliyun.com/console) and move the pointer over the profile picture in the upper-right corner.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The client token. It is a field with the idempotence property. We recommend that you use a universally unique identifier (UUID). This parameter is used to uniquely identify the API operation call.
	RoleCode *string `json:"RoleCode,omitempty" xml:"RoleCode,omitempty"`
	// The region of the workspace. For example, the ID of the China (Shanghai) region is cn-shanghai, and that of the China (Zhangjiakou) region is cn-zhangjiakou. The system automatically determines the value of this parameter based on the endpoint used to call the operation.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s AddProjectMemberToRoleRequest) String() string {
	return tea.Prettify(s)
}

func (s AddProjectMemberToRoleRequest) GoString() string {
	return s.String()
}

func (s *AddProjectMemberToRoleRequest) SetClientToken(v string) *AddProjectMemberToRoleRequest {
	s.ClientToken = &v
	return s
}

func (s *AddProjectMemberToRoleRequest) SetProjectId(v int64) *AddProjectMemberToRoleRequest {
	s.ProjectId = &v
	return s
}

func (s *AddProjectMemberToRoleRequest) SetRoleCode(v string) *AddProjectMemberToRoleRequest {
	s.RoleCode = &v
	return s
}

func (s *AddProjectMemberToRoleRequest) SetUserId(v string) *AddProjectMemberToRoleRequest {
	s.UserId = &v
	return s
}

type AddProjectMemberToRoleResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s AddProjectMemberToRoleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddProjectMemberToRoleResponseBody) GoString() string {
	return s.String()
}

func (s *AddProjectMemberToRoleResponseBody) SetRequestId(v string) *AddProjectMemberToRoleResponseBody {
	s.RequestId = &v
	return s
}

type AddProjectMemberToRoleResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddProjectMemberToRoleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddProjectMemberToRoleResponse) String() string {
	return tea.Prettify(s)
}

func (s AddProjectMemberToRoleResponse) GoString() string {
	return s.String()
}

func (s *AddProjectMemberToRoleResponse) SetHeaders(v map[string]*string) *AddProjectMemberToRoleResponse {
	s.Headers = v
	return s
}

func (s *AddProjectMemberToRoleResponse) SetStatusCode(v int32) *AddProjectMemberToRoleResponse {
	s.StatusCode = &v
	return s
}

func (s *AddProjectMemberToRoleResponse) SetBody(v *AddProjectMemberToRoleResponseBody) *AddProjectMemberToRoleResponse {
	s.Body = v
	return s
}

type AddRecognizeRuleRequest struct {
	AccountName          *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	ColExclude           *string `json:"ColExclude,omitempty" xml:"ColExclude,omitempty"`
	ColScan              *string `json:"ColScan,omitempty" xml:"ColScan,omitempty"`
	CommentScan          *string `json:"CommentScan,omitempty" xml:"CommentScan,omitempty"`
	ContentScan          *string `json:"ContentScan,omitempty" xml:"ContentScan,omitempty"`
	HitThreshold         *int32  `json:"HitThreshold,omitempty" xml:"HitThreshold,omitempty"`
	Level                *string `json:"Level,omitempty" xml:"Level,omitempty"`
	LevelName            *string `json:"LevelName,omitempty" xml:"LevelName,omitempty"`
	NodeId               *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	NodeParent           *string `json:"NodeParent,omitempty" xml:"NodeParent,omitempty"`
	OperationType        *int32  `json:"OperationType,omitempty" xml:"OperationType,omitempty"`
	RecognizeRules       *string `json:"RecognizeRules,omitempty" xml:"RecognizeRules,omitempty"`
	RecognizeRulesType   *string `json:"RecognizeRulesType,omitempty" xml:"RecognizeRulesType,omitempty"`
	SensitiveDescription *string `json:"SensitiveDescription,omitempty" xml:"SensitiveDescription,omitempty"`
	SensitiveName        *string `json:"SensitiveName,omitempty" xml:"SensitiveName,omitempty"`
	Status               *int32  `json:"Status,omitempty" xml:"Status,omitempty"`
	TemplateId           *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	TenantId             *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s AddRecognizeRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s AddRecognizeRuleRequest) GoString() string {
	return s.String()
}

func (s *AddRecognizeRuleRequest) SetAccountName(v string) *AddRecognizeRuleRequest {
	s.AccountName = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetColExclude(v string) *AddRecognizeRuleRequest {
	s.ColExclude = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetColScan(v string) *AddRecognizeRuleRequest {
	s.ColScan = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetCommentScan(v string) *AddRecognizeRuleRequest {
	s.CommentScan = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetContentScan(v string) *AddRecognizeRuleRequest {
	s.ContentScan = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetHitThreshold(v int32) *AddRecognizeRuleRequest {
	s.HitThreshold = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetLevel(v string) *AddRecognizeRuleRequest {
	s.Level = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetLevelName(v string) *AddRecognizeRuleRequest {
	s.LevelName = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetNodeId(v string) *AddRecognizeRuleRequest {
	s.NodeId = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetNodeParent(v string) *AddRecognizeRuleRequest {
	s.NodeParent = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetOperationType(v int32) *AddRecognizeRuleRequest {
	s.OperationType = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetRecognizeRules(v string) *AddRecognizeRuleRequest {
	s.RecognizeRules = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetRecognizeRulesType(v string) *AddRecognizeRuleRequest {
	s.RecognizeRulesType = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetSensitiveDescription(v string) *AddRecognizeRuleRequest {
	s.SensitiveDescription = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetSensitiveName(v string) *AddRecognizeRuleRequest {
	s.SensitiveName = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetStatus(v int32) *AddRecognizeRuleRequest {
	s.Status = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetTemplateId(v string) *AddRecognizeRuleRequest {
	s.TemplateId = &v
	return s
}

func (s *AddRecognizeRuleRequest) SetTenantId(v string) *AddRecognizeRuleRequest {
	s.TenantId = &v
	return s
}

type AddRecognizeRuleResponseBody struct {
	Data           interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string     `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32      `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddRecognizeRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddRecognizeRuleResponseBody) GoString() string {
	return s.String()
}

func (s *AddRecognizeRuleResponseBody) SetData(v interface{}) *AddRecognizeRuleResponseBody {
	s.Data = v
	return s
}

func (s *AddRecognizeRuleResponseBody) SetErrorCode(v string) *AddRecognizeRuleResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AddRecognizeRuleResponseBody) SetErrorMessage(v string) *AddRecognizeRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AddRecognizeRuleResponseBody) SetHttpStatusCode(v int32) *AddRecognizeRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddRecognizeRuleResponseBody) SetRequestId(v string) *AddRecognizeRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddRecognizeRuleResponseBody) SetSuccess(v bool) *AddRecognizeRuleResponseBody {
	s.Success = &v
	return s
}

type AddRecognizeRuleResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddRecognizeRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddRecognizeRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s AddRecognizeRuleResponse) GoString() string {
	return s.String()
}

func (s *AddRecognizeRuleResponse) SetHeaders(v map[string]*string) *AddRecognizeRuleResponse {
	s.Headers = v
	return s
}

func (s *AddRecognizeRuleResponse) SetStatusCode(v int32) *AddRecognizeRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *AddRecognizeRuleResponse) SetBody(v *AddRecognizeRuleResponseBody) *AddRecognizeRuleResponse {
	s.Body = v
	return s
}

type AddToMetaCategoryRequest struct {
	// The ID of the category.
	CategoryId *int64 `json:"CategoryId,omitempty" xml:"CategoryId,omitempty"`
	// The GUID of the metatable.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
}

func (s AddToMetaCategoryRequest) String() string {
	return tea.Prettify(s)
}

func (s AddToMetaCategoryRequest) GoString() string {
	return s.String()
}

func (s *AddToMetaCategoryRequest) SetCategoryId(v int64) *AddToMetaCategoryRequest {
	s.CategoryId = &v
	return s
}

func (s *AddToMetaCategoryRequest) SetTableGuid(v string) *AddToMetaCategoryRequest {
	s.TableGuid = &v
	return s
}

type AddToMetaCategoryResponseBody struct {
	// Indicates whether the metatable was added to the specified category.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddToMetaCategoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddToMetaCategoryResponseBody) GoString() string {
	return s.String()
}

func (s *AddToMetaCategoryResponseBody) SetData(v bool) *AddToMetaCategoryResponseBody {
	s.Data = &v
	return s
}

func (s *AddToMetaCategoryResponseBody) SetErrorCode(v string) *AddToMetaCategoryResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *AddToMetaCategoryResponseBody) SetErrorMessage(v string) *AddToMetaCategoryResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AddToMetaCategoryResponseBody) SetHttpStatusCode(v int32) *AddToMetaCategoryResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *AddToMetaCategoryResponseBody) SetRequestId(v string) *AddToMetaCategoryResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddToMetaCategoryResponseBody) SetSuccess(v bool) *AddToMetaCategoryResponseBody {
	s.Success = &v
	return s
}

type AddToMetaCategoryResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *AddToMetaCategoryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s AddToMetaCategoryResponse) String() string {
	return tea.Prettify(s)
}

func (s AddToMetaCategoryResponse) GoString() string {
	return s.String()
}

func (s *AddToMetaCategoryResponse) SetHeaders(v map[string]*string) *AddToMetaCategoryResponse {
	s.Headers = v
	return s
}

func (s *AddToMetaCategoryResponse) SetStatusCode(v int32) *AddToMetaCategoryResponse {
	s.StatusCode = &v
	return s
}

func (s *AddToMetaCategoryResponse) SetBody(v *AddToMetaCategoryResponseBody) *AddToMetaCategoryResponse {
	s.Body = v
	return s
}

type ApprovePermissionApplyOrderRequest struct {
	// The approval action. Valid values:
	//
	// *   1: Approve the permission request order.
	// *   2: Reject the permission request order.
	ApproveAction *int32 `json:"ApproveAction,omitempty" xml:"ApproveAction,omitempty"`
	// The comment on the approval.
	ApproveComment *string `json:"ApproveComment,omitempty" xml:"ApproveComment,omitempty"`
	// The ID of the permission request order. You can call the ListPermissionApplyOrders operation to obtain the order ID.
	FlowId *string `json:"FlowId,omitempty" xml:"FlowId,omitempty"`
}

func (s ApprovePermissionApplyOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s ApprovePermissionApplyOrderRequest) GoString() string {
	return s.String()
}

func (s *ApprovePermissionApplyOrderRequest) SetApproveAction(v int32) *ApprovePermissionApplyOrderRequest {
	s.ApproveAction = &v
	return s
}

func (s *ApprovePermissionApplyOrderRequest) SetApproveComment(v string) *ApprovePermissionApplyOrderRequest {
	s.ApproveComment = &v
	return s
}

func (s *ApprovePermissionApplyOrderRequest) SetFlowId(v string) *ApprovePermissionApplyOrderRequest {
	s.FlowId = &v
	return s
}

type ApprovePermissionApplyOrderResponseBody struct {
	// Indicates that the approval is successful.
	ApproveSuccess *bool `json:"ApproveSuccess,omitempty" xml:"ApproveSuccess,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ApprovePermissionApplyOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ApprovePermissionApplyOrderResponseBody) GoString() string {
	return s.String()
}

func (s *ApprovePermissionApplyOrderResponseBody) SetApproveSuccess(v bool) *ApprovePermissionApplyOrderResponseBody {
	s.ApproveSuccess = &v
	return s
}

func (s *ApprovePermissionApplyOrderResponseBody) SetRequestId(v string) *ApprovePermissionApplyOrderResponseBody {
	s.RequestId = &v
	return s
}

type ApprovePermissionApplyOrderResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ApprovePermissionApplyOrderResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ApprovePermissionApplyOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s ApprovePermissionApplyOrderResponse) GoString() string {
	return s.String()
}

func (s *ApprovePermissionApplyOrderResponse) SetHeaders(v map[string]*string) *ApprovePermissionApplyOrderResponse {
	s.Headers = v
	return s
}

func (s *ApprovePermissionApplyOrderResponse) SetStatusCode(v int32) *ApprovePermissionApplyOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *ApprovePermissionApplyOrderResponse) SetBody(v *ApprovePermissionApplyOrderResponseBody) *ApprovePermissionApplyOrderResponse {
	s.Body = v
	return s
}

type CallbackExtensionRequest struct {
	CheckMessage  *string `json:"CheckMessage,omitempty" xml:"CheckMessage,omitempty"`
	CheckResult   *string `json:"CheckResult,omitempty" xml:"CheckResult,omitempty"`
	ExtensionCode *string `json:"ExtensionCode,omitempty" xml:"ExtensionCode,omitempty"`
	MessageId     *string `json:"MessageId,omitempty" xml:"MessageId,omitempty"`
}

func (s CallbackExtensionRequest) String() string {
	return tea.Prettify(s)
}

func (s CallbackExtensionRequest) GoString() string {
	return s.String()
}

func (s *CallbackExtensionRequest) SetCheckMessage(v string) *CallbackExtensionRequest {
	s.CheckMessage = &v
	return s
}

func (s *CallbackExtensionRequest) SetCheckResult(v string) *CallbackExtensionRequest {
	s.CheckResult = &v
	return s
}

func (s *CallbackExtensionRequest) SetExtensionCode(v string) *CallbackExtensionRequest {
	s.ExtensionCode = &v
	return s
}

func (s *CallbackExtensionRequest) SetMessageId(v string) *CallbackExtensionRequest {
	s.MessageId = &v
	return s
}

type CallbackExtensionResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CallbackExtensionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CallbackExtensionResponseBody) GoString() string {
	return s.String()
}

func (s *CallbackExtensionResponseBody) SetRequestId(v string) *CallbackExtensionResponseBody {
	s.RequestId = &v
	return s
}

func (s *CallbackExtensionResponseBody) SetSuccess(v string) *CallbackExtensionResponseBody {
	s.Success = &v
	return s
}

type CallbackExtensionResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CallbackExtensionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CallbackExtensionResponse) String() string {
	return tea.Prettify(s)
}

func (s CallbackExtensionResponse) GoString() string {
	return s.String()
}

func (s *CallbackExtensionResponse) SetHeaders(v map[string]*string) *CallbackExtensionResponse {
	s.Headers = v
	return s
}

func (s *CallbackExtensionResponse) SetStatusCode(v int32) *CallbackExtensionResponse {
	s.StatusCode = &v
	return s
}

func (s *CallbackExtensionResponse) SetBody(v *CallbackExtensionResponseBody) *CallbackExtensionResponse {
	s.Body = v
	return s
}

type ChangeResourceManagerResourceGroupRequest struct {
	// The ID of the new resource group.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// Indicates whether the resource group was successfully modified.
	ResourceManagerResourceGroupId *string `json:"ResourceManagerResourceGroupId,omitempty" xml:"ResourceManagerResourceGroupId,omitempty"`
	// The ID of the resource type. Valid values:
	//
	// *   If you set the ResourceType parameter to project, set this parameter to the value of ProjectIdentifier. You can call the [ListProjects](~~178393~~) operation to obtain the value of ProjectIdentifier.
	// *   If you set the ResourceType parameter to tenantresourcegroup, set this parameter to the value of ResourceGroupType. You can call the [ListResourceGroups](~~173913~~) operation to obtain the value of ResourceGroupType. Only the values 7, 8, and 9 are valid.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
}

func (s ChangeResourceManagerResourceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceManagerResourceGroupRequest) GoString() string {
	return s.String()
}

func (s *ChangeResourceManagerResourceGroupRequest) SetResourceId(v string) *ChangeResourceManagerResourceGroupRequest {
	s.ResourceId = &v
	return s
}

func (s *ChangeResourceManagerResourceGroupRequest) SetResourceManagerResourceGroupId(v string) *ChangeResourceManagerResourceGroupRequest {
	s.ResourceManagerResourceGroupId = &v
	return s
}

func (s *ChangeResourceManagerResourceGroupRequest) SetResourceType(v string) *ChangeResourceManagerResourceGroupRequest {
	s.ResourceType = &v
	return s
}

type ChangeResourceManagerResourceGroupResponseBody struct {
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The HTTP status code returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ChangeResourceManagerResourceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceManagerResourceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *ChangeResourceManagerResourceGroupResponseBody) SetData(v bool) *ChangeResourceManagerResourceGroupResponseBody {
	s.Data = &v
	return s
}

func (s *ChangeResourceManagerResourceGroupResponseBody) SetHttpStatusCode(v int32) *ChangeResourceManagerResourceGroupResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ChangeResourceManagerResourceGroupResponseBody) SetRequestId(v string) *ChangeResourceManagerResourceGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *ChangeResourceManagerResourceGroupResponseBody) SetSuccess(v bool) *ChangeResourceManagerResourceGroupResponseBody {
	s.Success = &v
	return s
}

type ChangeResourceManagerResourceGroupResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ChangeResourceManagerResourceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ChangeResourceManagerResourceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s ChangeResourceManagerResourceGroupResponse) GoString() string {
	return s.String()
}

func (s *ChangeResourceManagerResourceGroupResponse) SetHeaders(v map[string]*string) *ChangeResourceManagerResourceGroupResponse {
	s.Headers = v
	return s
}

func (s *ChangeResourceManagerResourceGroupResponse) SetStatusCode(v int32) *ChangeResourceManagerResourceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *ChangeResourceManagerResourceGroupResponse) SetBody(v *ChangeResourceManagerResourceGroupResponseBody) *ChangeResourceManagerResourceGroupResponse {
	s.Body = v
	return s
}

type CheckFileDeploymentRequest struct {
	// This parameter is deprecated.
	CheckDetailUrl *string `json:"CheckDetailUrl,omitempty" xml:"CheckDetailUrl,omitempty"`
	// The ID of the instance to which the file checker belongs. You can obtain the ID from the CheckerInstanceId parameter in the check event logs returned by DataWorks.
	CheckerInstanceId *string `json:"CheckerInstanceId,omitempty" xml:"CheckerInstanceId,omitempty"`
	// The check status of the file that you want to deploy. Valid values:
	//
	// *   OK: The file passes the check.
	// *   WARN: The file passes the check, but an alert is reported.
	// *   FAIL: The file fails the check.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s CheckFileDeploymentRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckFileDeploymentRequest) GoString() string {
	return s.String()
}

func (s *CheckFileDeploymentRequest) SetCheckDetailUrl(v string) *CheckFileDeploymentRequest {
	s.CheckDetailUrl = &v
	return s
}

func (s *CheckFileDeploymentRequest) SetCheckerInstanceId(v string) *CheckFileDeploymentRequest {
	s.CheckerInstanceId = &v
	return s
}

func (s *CheckFileDeploymentRequest) SetStatus(v string) *CheckFileDeploymentRequest {
	s.Status = &v
	return s
}

type CheckFileDeploymentResponseBody struct {
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CheckFileDeploymentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckFileDeploymentResponseBody) GoString() string {
	return s.String()
}

func (s *CheckFileDeploymentResponseBody) SetRequestId(v string) *CheckFileDeploymentResponseBody {
	s.RequestId = &v
	return s
}

type CheckFileDeploymentResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CheckFileDeploymentResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CheckFileDeploymentResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckFileDeploymentResponse) GoString() string {
	return s.String()
}

func (s *CheckFileDeploymentResponse) SetHeaders(v map[string]*string) *CheckFileDeploymentResponse {
	s.Headers = v
	return s
}

func (s *CheckFileDeploymentResponse) SetStatusCode(v int32) *CheckFileDeploymentResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckFileDeploymentResponse) SetBody(v *CheckFileDeploymentResponseBody) *CheckFileDeploymentResponse {
	s.Body = v
	return s
}

type CheckMetaPartitionRequest struct {
	// The name of the table.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// Indicates whether the partition exists.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The type of the data source. Valid values: odps and emr.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// The name of the database.
	Partition *string `json:"Partition,omitempty" xml:"Partition,omitempty"`
	// The ID of the E-MapReduce (EMR) cluster.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The HTTP status code.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s CheckMetaPartitionRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckMetaPartitionRequest) GoString() string {
	return s.String()
}

func (s *CheckMetaPartitionRequest) SetClusterId(v string) *CheckMetaPartitionRequest {
	s.ClusterId = &v
	return s
}

func (s *CheckMetaPartitionRequest) SetDataSourceType(v string) *CheckMetaPartitionRequest {
	s.DataSourceType = &v
	return s
}

func (s *CheckMetaPartitionRequest) SetDatabaseName(v string) *CheckMetaPartitionRequest {
	s.DatabaseName = &v
	return s
}

func (s *CheckMetaPartitionRequest) SetPartition(v string) *CheckMetaPartitionRequest {
	s.Partition = &v
	return s
}

func (s *CheckMetaPartitionRequest) SetTableGuid(v string) *CheckMetaPartitionRequest {
	s.TableGuid = &v
	return s
}

func (s *CheckMetaPartitionRequest) SetTableName(v string) *CheckMetaPartitionRequest {
	s.TableName = &v
	return s
}

type CheckMetaPartitionResponseBody struct {
	// The error message.
	Data      *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request is successful.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error code.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CheckMetaPartitionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckMetaPartitionResponseBody) GoString() string {
	return s.String()
}

func (s *CheckMetaPartitionResponseBody) SetData(v bool) *CheckMetaPartitionResponseBody {
	s.Data = &v
	return s
}

func (s *CheckMetaPartitionResponseBody) SetErrorCode(v string) *CheckMetaPartitionResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CheckMetaPartitionResponseBody) SetErrorMessage(v string) *CheckMetaPartitionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CheckMetaPartitionResponseBody) SetHttpStatusCode(v int32) *CheckMetaPartitionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CheckMetaPartitionResponseBody) SetRequestId(v string) *CheckMetaPartitionResponseBody {
	s.RequestId = &v
	return s
}

func (s *CheckMetaPartitionResponseBody) SetSuccess(v bool) *CheckMetaPartitionResponseBody {
	s.Success = &v
	return s
}

type CheckMetaPartitionResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CheckMetaPartitionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CheckMetaPartitionResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckMetaPartitionResponse) GoString() string {
	return s.String()
}

func (s *CheckMetaPartitionResponse) SetHeaders(v map[string]*string) *CheckMetaPartitionResponse {
	s.Headers = v
	return s
}

func (s *CheckMetaPartitionResponse) SetStatusCode(v int32) *CheckMetaPartitionResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckMetaPartitionResponse) SetBody(v *CheckMetaPartitionResponseBody) *CheckMetaPartitionResponse {
	s.Body = v
	return s
}

type CheckMetaTableRequest struct {
	// The name of the EMR table.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the request.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The type of the data source. Valid values: odps and emr.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// The name of the EMR database.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// Indicates whether the table exists.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s CheckMetaTableRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckMetaTableRequest) GoString() string {
	return s.String()
}

func (s *CheckMetaTableRequest) SetClusterId(v string) *CheckMetaTableRequest {
	s.ClusterId = &v
	return s
}

func (s *CheckMetaTableRequest) SetDataSourceType(v string) *CheckMetaTableRequest {
	s.DataSourceType = &v
	return s
}

func (s *CheckMetaTableRequest) SetDatabaseName(v string) *CheckMetaTableRequest {
	s.DatabaseName = &v
	return s
}

func (s *CheckMetaTableRequest) SetTableGuid(v string) *CheckMetaTableRequest {
	s.TableGuid = &v
	return s
}

func (s *CheckMetaTableRequest) SetTableName(v string) *CheckMetaTableRequest {
	s.TableName = &v
	return s
}

type CheckMetaTableResponseBody struct {
	Data      *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CheckMetaTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckMetaTableResponseBody) GoString() string {
	return s.String()
}

func (s *CheckMetaTableResponseBody) SetData(v bool) *CheckMetaTableResponseBody {
	s.Data = &v
	return s
}

func (s *CheckMetaTableResponseBody) SetRequestId(v string) *CheckMetaTableResponseBody {
	s.RequestId = &v
	return s
}

type CheckMetaTableResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CheckMetaTableResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CheckMetaTableResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckMetaTableResponse) GoString() string {
	return s.String()
}

func (s *CheckMetaTableResponse) SetHeaders(v map[string]*string) *CheckMetaTableResponse {
	s.Headers = v
	return s
}

func (s *CheckMetaTableResponse) SetStatusCode(v int32) *CheckMetaTableResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckMetaTableResponse) SetBody(v *CheckMetaTableResponseBody) *CheckMetaTableResponse {
	s.Body = v
	return s
}

type CreateBaselineRequest struct {
	AlertMarginThreshold *int32                                   `json:"AlertMarginThreshold,omitempty" xml:"AlertMarginThreshold,omitempty"`
	BaselineName         *string                                  `json:"BaselineName,omitempty" xml:"BaselineName,omitempty"`
	BaselineType         *string                                  `json:"BaselineType,omitempty" xml:"BaselineType,omitempty"`
	NodeIds              *string                                  `json:"NodeIds,omitempty" xml:"NodeIds,omitempty"`
	OvertimeSettings     []*CreateBaselineRequestOvertimeSettings `json:"OvertimeSettings,omitempty" xml:"OvertimeSettings,omitempty" type:"Repeated"`
	Owner                *string                                  `json:"Owner,omitempty" xml:"Owner,omitempty"`
	Priority             *int32                                   `json:"Priority,omitempty" xml:"Priority,omitempty"`
	ProjectId            *int64                                   `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s CreateBaselineRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateBaselineRequest) GoString() string {
	return s.String()
}

func (s *CreateBaselineRequest) SetAlertMarginThreshold(v int32) *CreateBaselineRequest {
	s.AlertMarginThreshold = &v
	return s
}

func (s *CreateBaselineRequest) SetBaselineName(v string) *CreateBaselineRequest {
	s.BaselineName = &v
	return s
}

func (s *CreateBaselineRequest) SetBaselineType(v string) *CreateBaselineRequest {
	s.BaselineType = &v
	return s
}

func (s *CreateBaselineRequest) SetNodeIds(v string) *CreateBaselineRequest {
	s.NodeIds = &v
	return s
}

func (s *CreateBaselineRequest) SetOvertimeSettings(v []*CreateBaselineRequestOvertimeSettings) *CreateBaselineRequest {
	s.OvertimeSettings = v
	return s
}

func (s *CreateBaselineRequest) SetOwner(v string) *CreateBaselineRequest {
	s.Owner = &v
	return s
}

func (s *CreateBaselineRequest) SetPriority(v int32) *CreateBaselineRequest {
	s.Priority = &v
	return s
}

func (s *CreateBaselineRequest) SetProjectId(v int64) *CreateBaselineRequest {
	s.ProjectId = &v
	return s
}

type CreateBaselineRequestOvertimeSettings struct {
	Cycle *int32  `json:"Cycle,omitempty" xml:"Cycle,omitempty"`
	Time  *string `json:"Time,omitempty" xml:"Time,omitempty"`
}

func (s CreateBaselineRequestOvertimeSettings) String() string {
	return tea.Prettify(s)
}

func (s CreateBaselineRequestOvertimeSettings) GoString() string {
	return s.String()
}

func (s *CreateBaselineRequestOvertimeSettings) SetCycle(v int32) *CreateBaselineRequestOvertimeSettings {
	s.Cycle = &v
	return s
}

func (s *CreateBaselineRequestOvertimeSettings) SetTime(v string) *CreateBaselineRequestOvertimeSettings {
	s.Time = &v
	return s
}

type CreateBaselineResponseBody struct {
	Data           *int64  `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateBaselineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateBaselineResponseBody) GoString() string {
	return s.String()
}

func (s *CreateBaselineResponseBody) SetData(v int64) *CreateBaselineResponseBody {
	s.Data = &v
	return s
}

func (s *CreateBaselineResponseBody) SetErrorCode(v string) *CreateBaselineResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateBaselineResponseBody) SetErrorMessage(v string) *CreateBaselineResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateBaselineResponseBody) SetHttpStatusCode(v int32) *CreateBaselineResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateBaselineResponseBody) SetRequestId(v string) *CreateBaselineResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateBaselineResponseBody) SetSuccess(v bool) *CreateBaselineResponseBody {
	s.Success = &v
	return s
}

type CreateBaselineResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateBaselineResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateBaselineResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateBaselineResponse) GoString() string {
	return s.String()
}

func (s *CreateBaselineResponse) SetHeaders(v map[string]*string) *CreateBaselineResponse {
	s.Headers = v
	return s
}

func (s *CreateBaselineResponse) SetStatusCode(v int32) *CreateBaselineResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateBaselineResponse) SetBody(v *CreateBaselineResponseBody) *CreateBaselineResponse {
	s.Body = v
	return s
}

type CreateBusinessRequest struct {
	BusinessName      *string `json:"BusinessName,omitempty" xml:"BusinessName,omitempty"`
	Description       *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Owner             *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	ProjectId         *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
	UseType           *string `json:"UseType,omitempty" xml:"UseType,omitempty"`
}

func (s CreateBusinessRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateBusinessRequest) GoString() string {
	return s.String()
}

func (s *CreateBusinessRequest) SetBusinessName(v string) *CreateBusinessRequest {
	s.BusinessName = &v
	return s
}

func (s *CreateBusinessRequest) SetDescription(v string) *CreateBusinessRequest {
	s.Description = &v
	return s
}

func (s *CreateBusinessRequest) SetOwner(v string) *CreateBusinessRequest {
	s.Owner = &v
	return s
}

func (s *CreateBusinessRequest) SetProjectId(v int64) *CreateBusinessRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateBusinessRequest) SetProjectIdentifier(v string) *CreateBusinessRequest {
	s.ProjectIdentifier = &v
	return s
}

func (s *CreateBusinessRequest) SetUseType(v string) *CreateBusinessRequest {
	s.UseType = &v
	return s
}

type CreateBusinessResponseBody struct {
	BusinessId     *int64  `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	ErrorCode      *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateBusinessResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateBusinessResponseBody) GoString() string {
	return s.String()
}

func (s *CreateBusinessResponseBody) SetBusinessId(v int64) *CreateBusinessResponseBody {
	s.BusinessId = &v
	return s
}

func (s *CreateBusinessResponseBody) SetErrorCode(v string) *CreateBusinessResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateBusinessResponseBody) SetErrorMessage(v string) *CreateBusinessResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateBusinessResponseBody) SetHttpStatusCode(v int32) *CreateBusinessResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateBusinessResponseBody) SetRequestId(v string) *CreateBusinessResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateBusinessResponseBody) SetSuccess(v bool) *CreateBusinessResponseBody {
	s.Success = &v
	return s
}

type CreateBusinessResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateBusinessResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateBusinessResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateBusinessResponse) GoString() string {
	return s.String()
}

func (s *CreateBusinessResponse) SetHeaders(v map[string]*string) *CreateBusinessResponse {
	s.Headers = v
	return s
}

func (s *CreateBusinessResponse) SetStatusCode(v int32) *CreateBusinessResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateBusinessResponse) SetBody(v *CreateBusinessResponseBody) *CreateBusinessResponse {
	s.Body = v
	return s
}

type CreateConnectionRequest struct {
	// The type of the connection string.
	ConnectionType *string `json:"ConnectionType,omitempty" xml:"ConnectionType,omitempty"`
	// Details of the data source.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The description of the connection string.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Environment of the data source.
	EnvType *int32 `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The name of the data source.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the workspace to be associated with the data source.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The sub-type of a connection string.
	SubType *string `json:"SubType,omitempty" xml:"SubType,omitempty"`
}

func (s CreateConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateConnectionRequest) GoString() string {
	return s.String()
}

func (s *CreateConnectionRequest) SetConnectionType(v string) *CreateConnectionRequest {
	s.ConnectionType = &v
	return s
}

func (s *CreateConnectionRequest) SetContent(v string) *CreateConnectionRequest {
	s.Content = &v
	return s
}

func (s *CreateConnectionRequest) SetDescription(v string) *CreateConnectionRequest {
	s.Description = &v
	return s
}

func (s *CreateConnectionRequest) SetEnvType(v int32) *CreateConnectionRequest {
	s.EnvType = &v
	return s
}

func (s *CreateConnectionRequest) SetName(v string) *CreateConnectionRequest {
	s.Name = &v
	return s
}

func (s *CreateConnectionRequest) SetProjectId(v int64) *CreateConnectionRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateConnectionRequest) SetSubType(v string) *CreateConnectionRequest {
	s.SubType = &v
	return s
}

type CreateConnectionResponseBody struct {
	// The ID of the data source.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code.
	HttpStatusCode *string `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. A value of true indicates that the request is successful. A value of false indicates that the request has failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *CreateConnectionResponseBody) SetData(v int64) *CreateConnectionResponseBody {
	s.Data = &v
	return s
}

func (s *CreateConnectionResponseBody) SetHttpStatusCode(v string) *CreateConnectionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateConnectionResponseBody) SetRequestId(v string) *CreateConnectionResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateConnectionResponseBody) SetSuccess(v bool) *CreateConnectionResponseBody {
	s.Success = &v
	return s
}

type CreateConnectionResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateConnectionResponse) GoString() string {
	return s.String()
}

func (s *CreateConnectionResponse) SetHeaders(v map[string]*string) *CreateConnectionResponse {
	s.Headers = v
	return s
}

func (s *CreateConnectionResponse) SetStatusCode(v int32) *CreateConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateConnectionResponse) SetBody(v *CreateConnectionResponseBody) *CreateConnectionResponse {
	s.Body = v
	return s
}

type CreateDIAlarmRuleRequest struct {
	DIJobId              *int64                                        `json:"DIJobId,omitempty" xml:"DIJobId,omitempty"`
	Description          *string                                       `json:"Description,omitempty" xml:"Description,omitempty"`
	Enabled              *bool                                         `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	MetricType           *string                                       `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	NotificationSettings *CreateDIAlarmRuleRequestNotificationSettings `json:"NotificationSettings,omitempty" xml:"NotificationSettings,omitempty" type:"Struct"`
	TriggerConditions    []*CreateDIAlarmRuleRequestTriggerConditions  `json:"TriggerConditions,omitempty" xml:"TriggerConditions,omitempty" type:"Repeated"`
}

func (s CreateDIAlarmRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDIAlarmRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateDIAlarmRuleRequest) SetDIJobId(v int64) *CreateDIAlarmRuleRequest {
	s.DIJobId = &v
	return s
}

func (s *CreateDIAlarmRuleRequest) SetDescription(v string) *CreateDIAlarmRuleRequest {
	s.Description = &v
	return s
}

func (s *CreateDIAlarmRuleRequest) SetEnabled(v bool) *CreateDIAlarmRuleRequest {
	s.Enabled = &v
	return s
}

func (s *CreateDIAlarmRuleRequest) SetMetricType(v string) *CreateDIAlarmRuleRequest {
	s.MetricType = &v
	return s
}

func (s *CreateDIAlarmRuleRequest) SetNotificationSettings(v *CreateDIAlarmRuleRequestNotificationSettings) *CreateDIAlarmRuleRequest {
	s.NotificationSettings = v
	return s
}

func (s *CreateDIAlarmRuleRequest) SetTriggerConditions(v []*CreateDIAlarmRuleRequestTriggerConditions) *CreateDIAlarmRuleRequest {
	s.TriggerConditions = v
	return s
}

type CreateDIAlarmRuleRequestNotificationSettings struct {
	InhibitionInterval    *int32                                                               `json:"InhibitionInterval,omitempty" xml:"InhibitionInterval,omitempty"`
	NotificationChannels  []*CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels  `json:"NotificationChannels,omitempty" xml:"NotificationChannels,omitempty" type:"Repeated"`
	NotificationReceivers []*CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers `json:"NotificationReceivers,omitempty" xml:"NotificationReceivers,omitempty" type:"Repeated"`
}

func (s CreateDIAlarmRuleRequestNotificationSettings) String() string {
	return tea.Prettify(s)
}

func (s CreateDIAlarmRuleRequestNotificationSettings) GoString() string {
	return s.String()
}

func (s *CreateDIAlarmRuleRequestNotificationSettings) SetInhibitionInterval(v int32) *CreateDIAlarmRuleRequestNotificationSettings {
	s.InhibitionInterval = &v
	return s
}

func (s *CreateDIAlarmRuleRequestNotificationSettings) SetNotificationChannels(v []*CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels) *CreateDIAlarmRuleRequestNotificationSettings {
	s.NotificationChannels = v
	return s
}

func (s *CreateDIAlarmRuleRequestNotificationSettings) SetNotificationReceivers(v []*CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers) *CreateDIAlarmRuleRequestNotificationSettings {
	s.NotificationReceivers = v
	return s
}

type CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels struct {
	Channels []*string `json:"Channels,omitempty" xml:"Channels,omitempty" type:"Repeated"`
	Severity *string   `json:"Severity,omitempty" xml:"Severity,omitempty"`
}

func (s CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels) String() string {
	return tea.Prettify(s)
}

func (s CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels) GoString() string {
	return s.String()
}

func (s *CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels) SetChannels(v []*string) *CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels {
	s.Channels = v
	return s
}

func (s *CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels) SetSeverity(v string) *CreateDIAlarmRuleRequestNotificationSettingsNotificationChannels {
	s.Severity = &v
	return s
}

type CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers struct {
	ReceiverType   *string   `json:"ReceiverType,omitempty" xml:"ReceiverType,omitempty"`
	ReceiverValues []*string `json:"ReceiverValues,omitempty" xml:"ReceiverValues,omitempty" type:"Repeated"`
}

func (s CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers) String() string {
	return tea.Prettify(s)
}

func (s CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers) GoString() string {
	return s.String()
}

func (s *CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers) SetReceiverType(v string) *CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers {
	s.ReceiverType = &v
	return s
}

func (s *CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers) SetReceiverValues(v []*string) *CreateDIAlarmRuleRequestNotificationSettingsNotificationReceivers {
	s.ReceiverValues = v
	return s
}

type CreateDIAlarmRuleRequestTriggerConditions struct {
	Duration  *int64  `json:"Duration,omitempty" xml:"Duration,omitempty"`
	Severity  *string `json:"Severity,omitempty" xml:"Severity,omitempty"`
	Threshold *int64  `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s CreateDIAlarmRuleRequestTriggerConditions) String() string {
	return tea.Prettify(s)
}

func (s CreateDIAlarmRuleRequestTriggerConditions) GoString() string {
	return s.String()
}

func (s *CreateDIAlarmRuleRequestTriggerConditions) SetDuration(v int64) *CreateDIAlarmRuleRequestTriggerConditions {
	s.Duration = &v
	return s
}

func (s *CreateDIAlarmRuleRequestTriggerConditions) SetSeverity(v string) *CreateDIAlarmRuleRequestTriggerConditions {
	s.Severity = &v
	return s
}

func (s *CreateDIAlarmRuleRequestTriggerConditions) SetThreshold(v int64) *CreateDIAlarmRuleRequestTriggerConditions {
	s.Threshold = &v
	return s
}

type CreateDIAlarmRuleShrinkRequest struct {
	DIJobId                    *int64  `json:"DIJobId,omitempty" xml:"DIJobId,omitempty"`
	Description                *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Enabled                    *bool   `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	MetricType                 *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	NotificationSettingsShrink *string `json:"NotificationSettings,omitempty" xml:"NotificationSettings,omitempty"`
	TriggerConditionsShrink    *string `json:"TriggerConditions,omitempty" xml:"TriggerConditions,omitempty"`
}

func (s CreateDIAlarmRuleShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDIAlarmRuleShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateDIAlarmRuleShrinkRequest) SetDIJobId(v int64) *CreateDIAlarmRuleShrinkRequest {
	s.DIJobId = &v
	return s
}

func (s *CreateDIAlarmRuleShrinkRequest) SetDescription(v string) *CreateDIAlarmRuleShrinkRequest {
	s.Description = &v
	return s
}

func (s *CreateDIAlarmRuleShrinkRequest) SetEnabled(v bool) *CreateDIAlarmRuleShrinkRequest {
	s.Enabled = &v
	return s
}

func (s *CreateDIAlarmRuleShrinkRequest) SetMetricType(v string) *CreateDIAlarmRuleShrinkRequest {
	s.MetricType = &v
	return s
}

func (s *CreateDIAlarmRuleShrinkRequest) SetNotificationSettingsShrink(v string) *CreateDIAlarmRuleShrinkRequest {
	s.NotificationSettingsShrink = &v
	return s
}

func (s *CreateDIAlarmRuleShrinkRequest) SetTriggerConditionsShrink(v string) *CreateDIAlarmRuleShrinkRequest {
	s.TriggerConditionsShrink = &v
	return s
}

type CreateDIAlarmRuleResponseBody struct {
	DIAlarmRuleId *int64  `json:"DIAlarmRuleId,omitempty" xml:"DIAlarmRuleId,omitempty"`
	RequestId     *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDIAlarmRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDIAlarmRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDIAlarmRuleResponseBody) SetDIAlarmRuleId(v int64) *CreateDIAlarmRuleResponseBody {
	s.DIAlarmRuleId = &v
	return s
}

func (s *CreateDIAlarmRuleResponseBody) SetRequestId(v string) *CreateDIAlarmRuleResponseBody {
	s.RequestId = &v
	return s
}

type CreateDIAlarmRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDIAlarmRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDIAlarmRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDIAlarmRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateDIAlarmRuleResponse) SetHeaders(v map[string]*string) *CreateDIAlarmRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateDIAlarmRuleResponse) SetStatusCode(v int32) *CreateDIAlarmRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDIAlarmRuleResponse) SetBody(v *CreateDIAlarmRuleResponseBody) *CreateDIAlarmRuleResponse {
	s.Body = v
	return s
}

type CreateDIJobRequest struct {
	Description                   *string                                            `json:"Description,omitempty" xml:"Description,omitempty"`
	DestinationDataSourceSettings []*CreateDIJobRequestDestinationDataSourceSettings `json:"DestinationDataSourceSettings,omitempty" xml:"DestinationDataSourceSettings,omitempty" type:"Repeated"`
	DestinationDataSourceType     *string                                            `json:"DestinationDataSourceType,omitempty" xml:"DestinationDataSourceType,omitempty"`
	JobName                       *string                                            `json:"JobName,omitempty" xml:"JobName,omitempty"`
	JobSettings                   *CreateDIJobRequestJobSettings                     `json:"JobSettings,omitempty" xml:"JobSettings,omitempty" type:"Struct"`
	MigrationType                 *string                                            `json:"MigrationType,omitempty" xml:"MigrationType,omitempty"`
	ProjectId                     *int64                                             `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResourceSettings              *CreateDIJobRequestResourceSettings                `json:"ResourceSettings,omitempty" xml:"ResourceSettings,omitempty" type:"Struct"`
	SourceDataSourceSettings      []*CreateDIJobRequestSourceDataSourceSettings      `json:"SourceDataSourceSettings,omitempty" xml:"SourceDataSourceSettings,omitempty" type:"Repeated"`
	SourceDataSourceType          *string                                            `json:"SourceDataSourceType,omitempty" xml:"SourceDataSourceType,omitempty"`
	SystemDebug                   *string                                            `json:"SystemDebug,omitempty" xml:"SystemDebug,omitempty"`
	TableMappings                 []*CreateDIJobRequestTableMappings                 `json:"TableMappings,omitempty" xml:"TableMappings,omitempty" type:"Repeated"`
	TransformationRules           []*CreateDIJobRequestTransformationRules           `json:"TransformationRules,omitempty" xml:"TransformationRules,omitempty" type:"Repeated"`
}

func (s CreateDIJobRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequest) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequest) SetDescription(v string) *CreateDIJobRequest {
	s.Description = &v
	return s
}

func (s *CreateDIJobRequest) SetDestinationDataSourceSettings(v []*CreateDIJobRequestDestinationDataSourceSettings) *CreateDIJobRequest {
	s.DestinationDataSourceSettings = v
	return s
}

func (s *CreateDIJobRequest) SetDestinationDataSourceType(v string) *CreateDIJobRequest {
	s.DestinationDataSourceType = &v
	return s
}

func (s *CreateDIJobRequest) SetJobName(v string) *CreateDIJobRequest {
	s.JobName = &v
	return s
}

func (s *CreateDIJobRequest) SetJobSettings(v *CreateDIJobRequestJobSettings) *CreateDIJobRequest {
	s.JobSettings = v
	return s
}

func (s *CreateDIJobRequest) SetMigrationType(v string) *CreateDIJobRequest {
	s.MigrationType = &v
	return s
}

func (s *CreateDIJobRequest) SetProjectId(v int64) *CreateDIJobRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateDIJobRequest) SetResourceSettings(v *CreateDIJobRequestResourceSettings) *CreateDIJobRequest {
	s.ResourceSettings = v
	return s
}

func (s *CreateDIJobRequest) SetSourceDataSourceSettings(v []*CreateDIJobRequestSourceDataSourceSettings) *CreateDIJobRequest {
	s.SourceDataSourceSettings = v
	return s
}

func (s *CreateDIJobRequest) SetSourceDataSourceType(v string) *CreateDIJobRequest {
	s.SourceDataSourceType = &v
	return s
}

func (s *CreateDIJobRequest) SetSystemDebug(v string) *CreateDIJobRequest {
	s.SystemDebug = &v
	return s
}

func (s *CreateDIJobRequest) SetTableMappings(v []*CreateDIJobRequestTableMappings) *CreateDIJobRequest {
	s.TableMappings = v
	return s
}

func (s *CreateDIJobRequest) SetTransformationRules(v []*CreateDIJobRequestTransformationRules) *CreateDIJobRequest {
	s.TransformationRules = v
	return s
}

type CreateDIJobRequestDestinationDataSourceSettings struct {
	DataSourceName       *string            `json:"DataSourceName,omitempty" xml:"DataSourceName,omitempty"`
	DataSourceProperties map[string]*string `json:"DataSourceProperties,omitempty" xml:"DataSourceProperties,omitempty"`
}

func (s CreateDIJobRequestDestinationDataSourceSettings) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequestDestinationDataSourceSettings) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequestDestinationDataSourceSettings) SetDataSourceName(v string) *CreateDIJobRequestDestinationDataSourceSettings {
	s.DataSourceName = &v
	return s
}

func (s *CreateDIJobRequestDestinationDataSourceSettings) SetDataSourceProperties(v map[string]*string) *CreateDIJobRequestDestinationDataSourceSettings {
	s.DataSourceProperties = v
	return s
}

type CreateDIJobRequestJobSettings struct {
	ChannelSettings        *string                                                `json:"ChannelSettings,omitempty" xml:"ChannelSettings,omitempty"`
	ColumnDataTypeSettings []*CreateDIJobRequestJobSettingsColumnDataTypeSettings `json:"ColumnDataTypeSettings,omitempty" xml:"ColumnDataTypeSettings,omitempty" type:"Repeated"`
	CycleScheduleSettings  *CreateDIJobRequestJobSettingsCycleScheduleSettings    `json:"CycleScheduleSettings,omitempty" xml:"CycleScheduleSettings,omitempty" type:"Struct"`
	DdlHandlingSettings    []*CreateDIJobRequestJobSettingsDdlHandlingSettings    `json:"DdlHandlingSettings,omitempty" xml:"DdlHandlingSettings,omitempty" type:"Repeated"`
	ImportRuleSettings     *CreateDIJobRequestJobSettingsImportRuleSettings       `json:"ImportRuleSettings,omitempty" xml:"ImportRuleSettings,omitempty" type:"Struct"`
	RuntimeSettings        []*CreateDIJobRequestJobSettingsRuntimeSettings        `json:"RuntimeSettings,omitempty" xml:"RuntimeSettings,omitempty" type:"Repeated"`
}

func (s CreateDIJobRequestJobSettings) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequestJobSettings) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequestJobSettings) SetChannelSettings(v string) *CreateDIJobRequestJobSettings {
	s.ChannelSettings = &v
	return s
}

func (s *CreateDIJobRequestJobSettings) SetColumnDataTypeSettings(v []*CreateDIJobRequestJobSettingsColumnDataTypeSettings) *CreateDIJobRequestJobSettings {
	s.ColumnDataTypeSettings = v
	return s
}

func (s *CreateDIJobRequestJobSettings) SetCycleScheduleSettings(v *CreateDIJobRequestJobSettingsCycleScheduleSettings) *CreateDIJobRequestJobSettings {
	s.CycleScheduleSettings = v
	return s
}

func (s *CreateDIJobRequestJobSettings) SetDdlHandlingSettings(v []*CreateDIJobRequestJobSettingsDdlHandlingSettings) *CreateDIJobRequestJobSettings {
	s.DdlHandlingSettings = v
	return s
}

func (s *CreateDIJobRequestJobSettings) SetImportRuleSettings(v *CreateDIJobRequestJobSettingsImportRuleSettings) *CreateDIJobRequestJobSettings {
	s.ImportRuleSettings = v
	return s
}

func (s *CreateDIJobRequestJobSettings) SetRuntimeSettings(v []*CreateDIJobRequestJobSettingsRuntimeSettings) *CreateDIJobRequestJobSettings {
	s.RuntimeSettings = v
	return s
}

type CreateDIJobRequestJobSettingsColumnDataTypeSettings struct {
	DestinationDataType *string `json:"DestinationDataType,omitempty" xml:"DestinationDataType,omitempty"`
	SourceDataType      *string `json:"SourceDataType,omitempty" xml:"SourceDataType,omitempty"`
}

func (s CreateDIJobRequestJobSettingsColumnDataTypeSettings) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequestJobSettingsColumnDataTypeSettings) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequestJobSettingsColumnDataTypeSettings) SetDestinationDataType(v string) *CreateDIJobRequestJobSettingsColumnDataTypeSettings {
	s.DestinationDataType = &v
	return s
}

func (s *CreateDIJobRequestJobSettingsColumnDataTypeSettings) SetSourceDataType(v string) *CreateDIJobRequestJobSettingsColumnDataTypeSettings {
	s.SourceDataType = &v
	return s
}

type CreateDIJobRequestJobSettingsCycleScheduleSettings struct {
	CycleMigrationType *string `json:"CycleMigrationType,omitempty" xml:"CycleMigrationType,omitempty"`
	ScheduleParameters *string `json:"ScheduleParameters,omitempty" xml:"ScheduleParameters,omitempty"`
}

func (s CreateDIJobRequestJobSettingsCycleScheduleSettings) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequestJobSettingsCycleScheduleSettings) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequestJobSettingsCycleScheduleSettings) SetCycleMigrationType(v string) *CreateDIJobRequestJobSettingsCycleScheduleSettings {
	s.CycleMigrationType = &v
	return s
}

func (s *CreateDIJobRequestJobSettingsCycleScheduleSettings) SetScheduleParameters(v string) *CreateDIJobRequestJobSettingsCycleScheduleSettings {
	s.ScheduleParameters = &v
	return s
}

type CreateDIJobRequestJobSettingsDdlHandlingSettings struct {
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	Type   *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateDIJobRequestJobSettingsDdlHandlingSettings) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequestJobSettingsDdlHandlingSettings) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequestJobSettingsDdlHandlingSettings) SetAction(v string) *CreateDIJobRequestJobSettingsDdlHandlingSettings {
	s.Action = &v
	return s
}

func (s *CreateDIJobRequestJobSettingsDdlHandlingSettings) SetType(v string) *CreateDIJobRequestJobSettingsDdlHandlingSettings {
	s.Type = &v
	return s
}

type CreateDIJobRequestJobSettingsImportRuleSettings struct {
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
}

func (s CreateDIJobRequestJobSettingsImportRuleSettings) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequestJobSettingsImportRuleSettings) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequestJobSettingsImportRuleSettings) SetFileId(v string) *CreateDIJobRequestJobSettingsImportRuleSettings {
	s.FileId = &v
	return s
}

func (s *CreateDIJobRequestJobSettingsImportRuleSettings) SetSource(v string) *CreateDIJobRequestJobSettingsImportRuleSettings {
	s.Source = &v
	return s
}

type CreateDIJobRequestJobSettingsRuntimeSettings struct {
	Name  *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateDIJobRequestJobSettingsRuntimeSettings) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequestJobSettingsRuntimeSettings) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequestJobSettingsRuntimeSettings) SetName(v string) *CreateDIJobRequestJobSettingsRuntimeSettings {
	s.Name = &v
	return s
}

func (s *CreateDIJobRequestJobSettingsRuntimeSettings) SetValue(v string) *CreateDIJobRequestJobSettingsRuntimeSettings {
	s.Value = &v
	return s
}

type CreateDIJobRequestResourceSettings struct {
	OfflineResourceSettings  *CreateDIJobRequestResourceSettingsOfflineResourceSettings  `json:"OfflineResourceSettings,omitempty" xml:"OfflineResourceSettings,omitempty" type:"Struct"`
	RealtimeResourceSettings *CreateDIJobRequestResourceSettingsRealtimeResourceSettings `json:"RealtimeResourceSettings,omitempty" xml:"RealtimeResourceSettings,omitempty" type:"Struct"`
}

func (s CreateDIJobRequestResourceSettings) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequestResourceSettings) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequestResourceSettings) SetOfflineResourceSettings(v *CreateDIJobRequestResourceSettingsOfflineResourceSettings) *CreateDIJobRequestResourceSettings {
	s.OfflineResourceSettings = v
	return s
}

func (s *CreateDIJobRequestResourceSettings) SetRealtimeResourceSettings(v *CreateDIJobRequestResourceSettingsRealtimeResourceSettings) *CreateDIJobRequestResourceSettings {
	s.RealtimeResourceSettings = v
	return s
}

type CreateDIJobRequestResourceSettingsOfflineResourceSettings struct {
	ResourceGroupIdentifier *string `json:"ResourceGroupIdentifier,omitempty" xml:"ResourceGroupIdentifier,omitempty"`
}

func (s CreateDIJobRequestResourceSettingsOfflineResourceSettings) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequestResourceSettingsOfflineResourceSettings) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequestResourceSettingsOfflineResourceSettings) SetResourceGroupIdentifier(v string) *CreateDIJobRequestResourceSettingsOfflineResourceSettings {
	s.ResourceGroupIdentifier = &v
	return s
}

type CreateDIJobRequestResourceSettingsRealtimeResourceSettings struct {
	ResourceGroupIdentifier *string `json:"ResourceGroupIdentifier,omitempty" xml:"ResourceGroupIdentifier,omitempty"`
}

func (s CreateDIJobRequestResourceSettingsRealtimeResourceSettings) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequestResourceSettingsRealtimeResourceSettings) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequestResourceSettingsRealtimeResourceSettings) SetResourceGroupIdentifier(v string) *CreateDIJobRequestResourceSettingsRealtimeResourceSettings {
	s.ResourceGroupIdentifier = &v
	return s
}

type CreateDIJobRequestSourceDataSourceSettings struct {
	DataSourceName       *string            `json:"DataSourceName,omitempty" xml:"DataSourceName,omitempty"`
	DataSourceProperties map[string]*string `json:"DataSourceProperties,omitempty" xml:"DataSourceProperties,omitempty"`
}

func (s CreateDIJobRequestSourceDataSourceSettings) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequestSourceDataSourceSettings) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequestSourceDataSourceSettings) SetDataSourceName(v string) *CreateDIJobRequestSourceDataSourceSettings {
	s.DataSourceName = &v
	return s
}

func (s *CreateDIJobRequestSourceDataSourceSettings) SetDataSourceProperties(v map[string]*string) *CreateDIJobRequestSourceDataSourceSettings {
	s.DataSourceProperties = v
	return s
}

type CreateDIJobRequestTableMappings struct {
	SourceObjectSelectionRules []*CreateDIJobRequestTableMappingsSourceObjectSelectionRules `json:"SourceObjectSelectionRules,omitempty" xml:"SourceObjectSelectionRules,omitempty" type:"Repeated"`
	TransformationRules        []*CreateDIJobRequestTableMappingsTransformationRules        `json:"TransformationRules,omitempty" xml:"TransformationRules,omitempty" type:"Repeated"`
}

func (s CreateDIJobRequestTableMappings) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequestTableMappings) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequestTableMappings) SetSourceObjectSelectionRules(v []*CreateDIJobRequestTableMappingsSourceObjectSelectionRules) *CreateDIJobRequestTableMappings {
	s.SourceObjectSelectionRules = v
	return s
}

func (s *CreateDIJobRequestTableMappings) SetTransformationRules(v []*CreateDIJobRequestTableMappingsTransformationRules) *CreateDIJobRequestTableMappings {
	s.TransformationRules = v
	return s
}

type CreateDIJobRequestTableMappingsSourceObjectSelectionRules struct {
	Expression *string `json:"Expression,omitempty" xml:"Expression,omitempty"`
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
}

func (s CreateDIJobRequestTableMappingsSourceObjectSelectionRules) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequestTableMappingsSourceObjectSelectionRules) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequestTableMappingsSourceObjectSelectionRules) SetExpression(v string) *CreateDIJobRequestTableMappingsSourceObjectSelectionRules {
	s.Expression = &v
	return s
}

func (s *CreateDIJobRequestTableMappingsSourceObjectSelectionRules) SetObjectType(v string) *CreateDIJobRequestTableMappingsSourceObjectSelectionRules {
	s.ObjectType = &v
	return s
}

type CreateDIJobRequestTableMappingsTransformationRules struct {
	RuleActionType *string `json:"RuleActionType,omitempty" xml:"RuleActionType,omitempty"`
	RuleName       *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	RuleTargetType *string `json:"RuleTargetType,omitempty" xml:"RuleTargetType,omitempty"`
}

func (s CreateDIJobRequestTableMappingsTransformationRules) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequestTableMappingsTransformationRules) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequestTableMappingsTransformationRules) SetRuleActionType(v string) *CreateDIJobRequestTableMappingsTransformationRules {
	s.RuleActionType = &v
	return s
}

func (s *CreateDIJobRequestTableMappingsTransformationRules) SetRuleName(v string) *CreateDIJobRequestTableMappingsTransformationRules {
	s.RuleName = &v
	return s
}

func (s *CreateDIJobRequestTableMappingsTransformationRules) SetRuleTargetType(v string) *CreateDIJobRequestTableMappingsTransformationRules {
	s.RuleTargetType = &v
	return s
}

type CreateDIJobRequestTransformationRules struct {
	RuleActionType *string `json:"RuleActionType,omitempty" xml:"RuleActionType,omitempty"`
	RuleExpression *string `json:"RuleExpression,omitempty" xml:"RuleExpression,omitempty"`
	RuleName       *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	RuleTargetType *string `json:"RuleTargetType,omitempty" xml:"RuleTargetType,omitempty"`
}

func (s CreateDIJobRequestTransformationRules) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobRequestTransformationRules) GoString() string {
	return s.String()
}

func (s *CreateDIJobRequestTransformationRules) SetRuleActionType(v string) *CreateDIJobRequestTransformationRules {
	s.RuleActionType = &v
	return s
}

func (s *CreateDIJobRequestTransformationRules) SetRuleExpression(v string) *CreateDIJobRequestTransformationRules {
	s.RuleExpression = &v
	return s
}

func (s *CreateDIJobRequestTransformationRules) SetRuleName(v string) *CreateDIJobRequestTransformationRules {
	s.RuleName = &v
	return s
}

func (s *CreateDIJobRequestTransformationRules) SetRuleTargetType(v string) *CreateDIJobRequestTransformationRules {
	s.RuleTargetType = &v
	return s
}

type CreateDIJobShrinkRequest struct {
	Description                         *string `json:"Description,omitempty" xml:"Description,omitempty"`
	DestinationDataSourceSettingsShrink *string `json:"DestinationDataSourceSettings,omitempty" xml:"DestinationDataSourceSettings,omitempty"`
	DestinationDataSourceType           *string `json:"DestinationDataSourceType,omitempty" xml:"DestinationDataSourceType,omitempty"`
	JobName                             *string `json:"JobName,omitempty" xml:"JobName,omitempty"`
	JobSettingsShrink                   *string `json:"JobSettings,omitempty" xml:"JobSettings,omitempty"`
	MigrationType                       *string `json:"MigrationType,omitempty" xml:"MigrationType,omitempty"`
	ProjectId                           *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResourceSettingsShrink              *string `json:"ResourceSettings,omitempty" xml:"ResourceSettings,omitempty"`
	SourceDataSourceSettingsShrink      *string `json:"SourceDataSourceSettings,omitempty" xml:"SourceDataSourceSettings,omitempty"`
	SourceDataSourceType                *string `json:"SourceDataSourceType,omitempty" xml:"SourceDataSourceType,omitempty"`
	SystemDebug                         *string `json:"SystemDebug,omitempty" xml:"SystemDebug,omitempty"`
	TableMappingsShrink                 *string `json:"TableMappings,omitempty" xml:"TableMappings,omitempty"`
	TransformationRulesShrink           *string `json:"TransformationRules,omitempty" xml:"TransformationRules,omitempty"`
}

func (s CreateDIJobShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateDIJobShrinkRequest) SetDescription(v string) *CreateDIJobShrinkRequest {
	s.Description = &v
	return s
}

func (s *CreateDIJobShrinkRequest) SetDestinationDataSourceSettingsShrink(v string) *CreateDIJobShrinkRequest {
	s.DestinationDataSourceSettingsShrink = &v
	return s
}

func (s *CreateDIJobShrinkRequest) SetDestinationDataSourceType(v string) *CreateDIJobShrinkRequest {
	s.DestinationDataSourceType = &v
	return s
}

func (s *CreateDIJobShrinkRequest) SetJobName(v string) *CreateDIJobShrinkRequest {
	s.JobName = &v
	return s
}

func (s *CreateDIJobShrinkRequest) SetJobSettingsShrink(v string) *CreateDIJobShrinkRequest {
	s.JobSettingsShrink = &v
	return s
}

func (s *CreateDIJobShrinkRequest) SetMigrationType(v string) *CreateDIJobShrinkRequest {
	s.MigrationType = &v
	return s
}

func (s *CreateDIJobShrinkRequest) SetProjectId(v int64) *CreateDIJobShrinkRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateDIJobShrinkRequest) SetResourceSettingsShrink(v string) *CreateDIJobShrinkRequest {
	s.ResourceSettingsShrink = &v
	return s
}

func (s *CreateDIJobShrinkRequest) SetSourceDataSourceSettingsShrink(v string) *CreateDIJobShrinkRequest {
	s.SourceDataSourceSettingsShrink = &v
	return s
}

func (s *CreateDIJobShrinkRequest) SetSourceDataSourceType(v string) *CreateDIJobShrinkRequest {
	s.SourceDataSourceType = &v
	return s
}

func (s *CreateDIJobShrinkRequest) SetSystemDebug(v string) *CreateDIJobShrinkRequest {
	s.SystemDebug = &v
	return s
}

func (s *CreateDIJobShrinkRequest) SetTableMappingsShrink(v string) *CreateDIJobShrinkRequest {
	s.TableMappingsShrink = &v
	return s
}

func (s *CreateDIJobShrinkRequest) SetTransformationRulesShrink(v string) *CreateDIJobShrinkRequest {
	s.TransformationRulesShrink = &v
	return s
}

type CreateDIJobResponseBody struct {
	DIJobId *int64 `json:"DIJobId,omitempty" xml:"DIJobId,omitempty"`
	// Id of the request
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDIJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDIJobResponseBody) SetDIJobId(v int64) *CreateDIJobResponseBody {
	s.DIJobId = &v
	return s
}

func (s *CreateDIJobResponseBody) SetRequestId(v string) *CreateDIJobResponseBody {
	s.RequestId = &v
	return s
}

type CreateDIJobResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDIJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDIJobResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDIJobResponse) GoString() string {
	return s.String()
}

func (s *CreateDIJobResponse) SetHeaders(v map[string]*string) *CreateDIJobResponse {
	s.Headers = v
	return s
}

func (s *CreateDIJobResponse) SetStatusCode(v int32) *CreateDIJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDIJobResponse) SetBody(v *CreateDIJobResponseBody) *CreateDIJobResponse {
	s.Body = v
	return s
}

type CreateDISyncTaskRequest struct {
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	ProjectId   *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	TaskContent *string `json:"TaskContent,omitempty" xml:"TaskContent,omitempty"`
	TaskName    *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
	TaskParam   *string `json:"TaskParam,omitempty" xml:"TaskParam,omitempty"`
	TaskType    *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s CreateDISyncTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDISyncTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateDISyncTaskRequest) SetClientToken(v string) *CreateDISyncTaskRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateDISyncTaskRequest) SetProjectId(v int64) *CreateDISyncTaskRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateDISyncTaskRequest) SetTaskContent(v string) *CreateDISyncTaskRequest {
	s.TaskContent = &v
	return s
}

func (s *CreateDISyncTaskRequest) SetTaskName(v string) *CreateDISyncTaskRequest {
	s.TaskName = &v
	return s
}

func (s *CreateDISyncTaskRequest) SetTaskParam(v string) *CreateDISyncTaskRequest {
	s.TaskParam = &v
	return s
}

func (s *CreateDISyncTaskRequest) SetTaskType(v string) *CreateDISyncTaskRequest {
	s.TaskType = &v
	return s
}

type CreateDISyncTaskResponseBody struct {
	Data      *CreateDISyncTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool                             `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDISyncTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDISyncTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDISyncTaskResponseBody) SetData(v *CreateDISyncTaskResponseBodyData) *CreateDISyncTaskResponseBody {
	s.Data = v
	return s
}

func (s *CreateDISyncTaskResponseBody) SetRequestId(v string) *CreateDISyncTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDISyncTaskResponseBody) SetSuccess(v bool) *CreateDISyncTaskResponseBody {
	s.Success = &v
	return s
}

type CreateDISyncTaskResponseBodyData struct {
	FileId  *int64  `json:"FileId,omitempty" xml:"FileId,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	Status  *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s CreateDISyncTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateDISyncTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateDISyncTaskResponseBodyData) SetFileId(v int64) *CreateDISyncTaskResponseBodyData {
	s.FileId = &v
	return s
}

func (s *CreateDISyncTaskResponseBodyData) SetMessage(v string) *CreateDISyncTaskResponseBodyData {
	s.Message = &v
	return s
}

func (s *CreateDISyncTaskResponseBodyData) SetStatus(v string) *CreateDISyncTaskResponseBodyData {
	s.Status = &v
	return s
}

type CreateDISyncTaskResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDISyncTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDISyncTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDISyncTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateDISyncTaskResponse) SetHeaders(v map[string]*string) *CreateDISyncTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateDISyncTaskResponse) SetStatusCode(v int32) *CreateDISyncTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDISyncTaskResponse) SetBody(v *CreateDISyncTaskResponseBody) *CreateDISyncTaskResponse {
	s.Body = v
	return s
}

type CreateDagComplementRequest struct {
	BizBeginTime   *string `json:"BizBeginTime,omitempty" xml:"BizBeginTime,omitempty"`
	BizEndTime     *string `json:"BizEndTime,omitempty" xml:"BizEndTime,omitempty"`
	EndBizDate     *string `json:"EndBizDate,omitempty" xml:"EndBizDate,omitempty"`
	ExcludeNodeIds *string `json:"ExcludeNodeIds,omitempty" xml:"ExcludeNodeIds,omitempty"`
	IncludeNodeIds *string `json:"IncludeNodeIds,omitempty" xml:"IncludeNodeIds,omitempty"`
	Name           *string `json:"Name,omitempty" xml:"Name,omitempty"`
	NodeParams     *string `json:"NodeParams,omitempty" xml:"NodeParams,omitempty"`
	Parallelism    *bool   `json:"Parallelism,omitempty" xml:"Parallelism,omitempty"`
	ProjectEnv     *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
	RootNodeId     *int64  `json:"RootNodeId,omitempty" xml:"RootNodeId,omitempty"`
	StartBizDate   *string `json:"StartBizDate,omitempty" xml:"StartBizDate,omitempty"`
}

func (s CreateDagComplementRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDagComplementRequest) GoString() string {
	return s.String()
}

func (s *CreateDagComplementRequest) SetBizBeginTime(v string) *CreateDagComplementRequest {
	s.BizBeginTime = &v
	return s
}

func (s *CreateDagComplementRequest) SetBizEndTime(v string) *CreateDagComplementRequest {
	s.BizEndTime = &v
	return s
}

func (s *CreateDagComplementRequest) SetEndBizDate(v string) *CreateDagComplementRequest {
	s.EndBizDate = &v
	return s
}

func (s *CreateDagComplementRequest) SetExcludeNodeIds(v string) *CreateDagComplementRequest {
	s.ExcludeNodeIds = &v
	return s
}

func (s *CreateDagComplementRequest) SetIncludeNodeIds(v string) *CreateDagComplementRequest {
	s.IncludeNodeIds = &v
	return s
}

func (s *CreateDagComplementRequest) SetName(v string) *CreateDagComplementRequest {
	s.Name = &v
	return s
}

func (s *CreateDagComplementRequest) SetNodeParams(v string) *CreateDagComplementRequest {
	s.NodeParams = &v
	return s
}

func (s *CreateDagComplementRequest) SetParallelism(v bool) *CreateDagComplementRequest {
	s.Parallelism = &v
	return s
}

func (s *CreateDagComplementRequest) SetProjectEnv(v string) *CreateDagComplementRequest {
	s.ProjectEnv = &v
	return s
}

func (s *CreateDagComplementRequest) SetRootNodeId(v int64) *CreateDagComplementRequest {
	s.RootNodeId = &v
	return s
}

func (s *CreateDagComplementRequest) SetStartBizDate(v string) *CreateDagComplementRequest {
	s.StartBizDate = &v
	return s
}

type CreateDagComplementResponseBody struct {
	Data           []*int64 `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	ErrorCode      *string  `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string  `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32   `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool    `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDagComplementResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDagComplementResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDagComplementResponseBody) SetData(v []*int64) *CreateDagComplementResponseBody {
	s.Data = v
	return s
}

func (s *CreateDagComplementResponseBody) SetErrorCode(v string) *CreateDagComplementResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateDagComplementResponseBody) SetErrorMessage(v string) *CreateDagComplementResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDagComplementResponseBody) SetHttpStatusCode(v int32) *CreateDagComplementResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateDagComplementResponseBody) SetRequestId(v string) *CreateDagComplementResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDagComplementResponseBody) SetSuccess(v bool) *CreateDagComplementResponseBody {
	s.Success = &v
	return s
}

type CreateDagComplementResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDagComplementResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDagComplementResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDagComplementResponse) GoString() string {
	return s.String()
}

func (s *CreateDagComplementResponse) SetHeaders(v map[string]*string) *CreateDagComplementResponse {
	s.Headers = v
	return s
}

func (s *CreateDagComplementResponse) SetStatusCode(v int32) *CreateDagComplementResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDagComplementResponse) SetBody(v *CreateDagComplementResponseBody) *CreateDagComplementResponse {
	s.Body = v
	return s
}

type CreateDagTestRequest struct {
	Bizdate    *string `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	Name       *string `json:"Name,omitempty" xml:"Name,omitempty"`
	NodeId     *int64  `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	NodeParams *string `json:"NodeParams,omitempty" xml:"NodeParams,omitempty"`
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s CreateDagTestRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDagTestRequest) GoString() string {
	return s.String()
}

func (s *CreateDagTestRequest) SetBizdate(v string) *CreateDagTestRequest {
	s.Bizdate = &v
	return s
}

func (s *CreateDagTestRequest) SetName(v string) *CreateDagTestRequest {
	s.Name = &v
	return s
}

func (s *CreateDagTestRequest) SetNodeId(v int64) *CreateDagTestRequest {
	s.NodeId = &v
	return s
}

func (s *CreateDagTestRequest) SetNodeParams(v string) *CreateDagTestRequest {
	s.NodeParams = &v
	return s
}

func (s *CreateDagTestRequest) SetProjectEnv(v string) *CreateDagTestRequest {
	s.ProjectEnv = &v
	return s
}

type CreateDagTestResponseBody struct {
	Data           *int64  `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDagTestResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDagTestResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDagTestResponseBody) SetData(v int64) *CreateDagTestResponseBody {
	s.Data = &v
	return s
}

func (s *CreateDagTestResponseBody) SetErrorCode(v string) *CreateDagTestResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateDagTestResponseBody) SetErrorMessage(v string) *CreateDagTestResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDagTestResponseBody) SetHttpStatusCode(v int32) *CreateDagTestResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateDagTestResponseBody) SetRequestId(v string) *CreateDagTestResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDagTestResponseBody) SetSuccess(v bool) *CreateDagTestResponseBody {
	s.Success = &v
	return s
}

type CreateDagTestResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDagTestResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDagTestResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDagTestResponse) GoString() string {
	return s.String()
}

func (s *CreateDagTestResponse) SetHeaders(v map[string]*string) *CreateDagTestResponse {
	s.Headers = v
	return s
}

func (s *CreateDagTestResponse) SetStatusCode(v int32) *CreateDagTestResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDagTestResponse) SetBody(v *CreateDagTestResponseBody) *CreateDagTestResponse {
	s.Body = v
	return s
}

type CreateDataServiceApiRequest struct {
	// The HTTP status code.
	ApiDescription *string `json:"ApiDescription,omitempty" xml:"ApiDescription,omitempty"`
	// The format in which the response of the API request is returned. Valid values: 0 and 1. The value 0 indicates the JSON format. The value 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
	ApiMode *int32 `json:"ApiMode,omitempty" xml:"ApiMode,omitempty"`
	// The type of the API. Valid values: 0, 1, and 2. The value 0 indicates that the API is generated in wizard mode. The value 1 indicates that the API is generated in script mode. The value 2 indicates that the API is generated by registration.
	ApiName *string `json:"ApiName,omitempty" xml:"ApiName,omitempty"`
	// The ID of the folder used to store the API. The ID of the root folder in a business process is 0. The ID of the folder created by a user must be greater than 0.
	ApiPath *string `json:"ApiPath,omitempty" xml:"ApiPath,omitempty"`
	// The ID of the API.
	FolderId *int64 `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The request method of the API. Valid values: 0, 1, 2, and 3. The value 0 indicates the GET method. The value 1 indicates the POST method. The value 2 indicates the PUT method. The value 3 indicates the DELETE method. APIs generated in wizard or script mode support the GET and POST methods. APIs generated by registration support the GET, POST, PUT, and DELETE methods.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the business process.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The details of the API generated in script mode. For more information, see the ScriptDetails parameter returned by the [GetDataServiceApi](~~174013~~) operation.
	Protocols *string `json:"Protocols,omitempty" xml:"Protocols,omitempty"`
	// The description of the API.
	RegistrationDetails *string `json:"RegistrationDetails,omitempty" xml:"RegistrationDetails,omitempty"`
	RequestContentType  *int32  `json:"RequestContentType,omitempty" xml:"RequestContentType,omitempty"`
	// The timeout period of the API request. Unit: milliseconds. Valid values: (0,30000].
	RequestMethod   *int32 `json:"RequestMethod,omitempty" xml:"RequestMethod,omitempty"`
	ResourceGroupId *int64 `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The scope in which the API is visible. Valid values:
	//
	// *   0: The API is visible to all members in the workspace.
	// *   1: The API is visible only to its owner, and permissions on the API cannot be granted to other members.
	ResponseContentType *int32 `json:"ResponseContentType,omitempty" xml:"ResponseContentType,omitempty"`
	// The path of the API. The path cannot exceed 200 characters in length. The path can contain letters, digits, underscores (\_), and hyphens (-) and must start with a forward slash (/).
	ScriptDetails *string `json:"ScriptDetails,omitempty" xml:"ScriptDetails,omitempty"`
	SqlMode       *int64  `json:"SqlMode,omitempty" xml:"SqlMode,omitempty"`
	// The name of the API. The name must be 4 to 50 characters in length. The name can contain letters, digits, and underscores (\_) and must start with a letter.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	// The protocol used by the API. Valid values: 0 and 1. The value 0 indicates HTTP. The value 1 indicates HTTPS. You can specify multiple protocols. Separate them with commas (,).
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The details of the API generated in wizard mode. For more information, see the WizardDetails parameter returned by the [GetDataServiceApi](~~174013~~) operation.
	VisibleRange *int32 `json:"VisibleRange,omitempty" xml:"VisibleRange,omitempty"`
	// The details of the API generated by registration. For more information, see the RegistrationDetails parameter returned by the [GetDataServiceApi](~~174013~~) operation.
	WizardDetails *string `json:"WizardDetails,omitempty" xml:"WizardDetails,omitempty"`
}

func (s CreateDataServiceApiRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataServiceApiRequest) GoString() string {
	return s.String()
}

func (s *CreateDataServiceApiRequest) SetApiDescription(v string) *CreateDataServiceApiRequest {
	s.ApiDescription = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetApiMode(v int32) *CreateDataServiceApiRequest {
	s.ApiMode = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetApiName(v string) *CreateDataServiceApiRequest {
	s.ApiName = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetApiPath(v string) *CreateDataServiceApiRequest {
	s.ApiPath = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetFolderId(v int64) *CreateDataServiceApiRequest {
	s.FolderId = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetGroupId(v string) *CreateDataServiceApiRequest {
	s.GroupId = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetProjectId(v int64) *CreateDataServiceApiRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetProtocols(v string) *CreateDataServiceApiRequest {
	s.Protocols = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetRegistrationDetails(v string) *CreateDataServiceApiRequest {
	s.RegistrationDetails = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetRequestContentType(v int32) *CreateDataServiceApiRequest {
	s.RequestContentType = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetRequestMethod(v int32) *CreateDataServiceApiRequest {
	s.RequestMethod = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetResourceGroupId(v int64) *CreateDataServiceApiRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetResponseContentType(v int32) *CreateDataServiceApiRequest {
	s.ResponseContentType = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetScriptDetails(v string) *CreateDataServiceApiRequest {
	s.ScriptDetails = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetSqlMode(v int64) *CreateDataServiceApiRequest {
	s.SqlMode = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetTenantId(v int64) *CreateDataServiceApiRequest {
	s.TenantId = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetTimeout(v int32) *CreateDataServiceApiRequest {
	s.Timeout = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetVisibleRange(v int32) *CreateDataServiceApiRequest {
	s.VisibleRange = &v
	return s
}

func (s *CreateDataServiceApiRequest) SetWizardDetails(v string) *CreateDataServiceApiRequest {
	s.WizardDetails = &v
	return s
}

type CreateDataServiceApiResponseBody struct {
	// The ID of the request.
	Data      *int64  `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error code.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The error message.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// Indicates whether the request is successful.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDataServiceApiResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDataServiceApiResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataServiceApiResponseBody) SetData(v int64) *CreateDataServiceApiResponseBody {
	s.Data = &v
	return s
}

func (s *CreateDataServiceApiResponseBody) SetErrorCode(v string) *CreateDataServiceApiResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateDataServiceApiResponseBody) SetErrorMessage(v string) *CreateDataServiceApiResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDataServiceApiResponseBody) SetHttpStatusCode(v int32) *CreateDataServiceApiResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateDataServiceApiResponseBody) SetRequestId(v string) *CreateDataServiceApiResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDataServiceApiResponseBody) SetSuccess(v bool) *CreateDataServiceApiResponseBody {
	s.Success = &v
	return s
}

type CreateDataServiceApiResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDataServiceApiResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDataServiceApiResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDataServiceApiResponse) GoString() string {
	return s.String()
}

func (s *CreateDataServiceApiResponse) SetHeaders(v map[string]*string) *CreateDataServiceApiResponse {
	s.Headers = v
	return s
}

func (s *CreateDataServiceApiResponse) SetStatusCode(v int32) *CreateDataServiceApiResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataServiceApiResponse) SetBody(v *CreateDataServiceApiResponseBody) *CreateDataServiceApiResponse {
	s.Body = v
	return s
}

type CreateDataServiceApiAuthorityRequest struct {
	// The ID of the API.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The ID of the workspace to which the access permissions on the API are granted.
	AuthorizedProjectId *int64 `json:"AuthorizedProjectId,omitempty" xml:"AuthorizedProjectId,omitempty"`
	// The end time of the validity period of the access permissions. The time must be a UNIX timestamp. Unit: seconds. Example: 1600531564, which indicates 2020-09-20 00:06:04 (UTC+8).
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s CreateDataServiceApiAuthorityRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataServiceApiAuthorityRequest) GoString() string {
	return s.String()
}

func (s *CreateDataServiceApiAuthorityRequest) SetApiId(v int64) *CreateDataServiceApiAuthorityRequest {
	s.ApiId = &v
	return s
}

func (s *CreateDataServiceApiAuthorityRequest) SetAuthorizedProjectId(v int64) *CreateDataServiceApiAuthorityRequest {
	s.AuthorizedProjectId = &v
	return s
}

func (s *CreateDataServiceApiAuthorityRequest) SetEndTime(v int64) *CreateDataServiceApiAuthorityRequest {
	s.EndTime = &v
	return s
}

func (s *CreateDataServiceApiAuthorityRequest) SetProjectId(v int64) *CreateDataServiceApiAuthorityRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateDataServiceApiAuthorityRequest) SetTenantId(v int64) *CreateDataServiceApiAuthorityRequest {
	s.TenantId = &v
	return s
}

type CreateDataServiceApiAuthorityResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the authorization was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDataServiceApiAuthorityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDataServiceApiAuthorityResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataServiceApiAuthorityResponseBody) SetRequestId(v string) *CreateDataServiceApiAuthorityResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDataServiceApiAuthorityResponseBody) SetSuccess(v bool) *CreateDataServiceApiAuthorityResponseBody {
	s.Success = &v
	return s
}

type CreateDataServiceApiAuthorityResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDataServiceApiAuthorityResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDataServiceApiAuthorityResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDataServiceApiAuthorityResponse) GoString() string {
	return s.String()
}

func (s *CreateDataServiceApiAuthorityResponse) SetHeaders(v map[string]*string) *CreateDataServiceApiAuthorityResponse {
	s.Headers = v
	return s
}

func (s *CreateDataServiceApiAuthorityResponse) SetStatusCode(v int32) *CreateDataServiceApiAuthorityResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataServiceApiAuthorityResponse) SetBody(v *CreateDataServiceApiAuthorityResponseBody) *CreateDataServiceApiAuthorityResponse {
	s.Body = v
	return s
}

type CreateDataServiceFolderRequest struct {
	// The name of the folder.
	FolderName *string `json:"FolderName,omitempty" xml:"FolderName,omitempty"`
	// The ID of the desired workflow to which the folder belongs.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the desired parent folder of the folder. The ID of the root folder in a workflow is 0. The ID of the folder created by users in a workflow is greater than 0.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s CreateDataServiceFolderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataServiceFolderRequest) GoString() string {
	return s.String()
}

func (s *CreateDataServiceFolderRequest) SetFolderName(v string) *CreateDataServiceFolderRequest {
	s.FolderName = &v
	return s
}

func (s *CreateDataServiceFolderRequest) SetGroupId(v string) *CreateDataServiceFolderRequest {
	s.GroupId = &v
	return s
}

func (s *CreateDataServiceFolderRequest) SetParentId(v int64) *CreateDataServiceFolderRequest {
	s.ParentId = &v
	return s
}

func (s *CreateDataServiceFolderRequest) SetProjectId(v int64) *CreateDataServiceFolderRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateDataServiceFolderRequest) SetTenantId(v int64) *CreateDataServiceFolderRequest {
	s.TenantId = &v
	return s
}

type CreateDataServiceFolderResponseBody struct {
	// The ID of the created folder.
	FolderId *int64 `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDataServiceFolderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDataServiceFolderResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataServiceFolderResponseBody) SetFolderId(v int64) *CreateDataServiceFolderResponseBody {
	s.FolderId = &v
	return s
}

func (s *CreateDataServiceFolderResponseBody) SetRequestId(v string) *CreateDataServiceFolderResponseBody {
	s.RequestId = &v
	return s
}

type CreateDataServiceFolderResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDataServiceFolderResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDataServiceFolderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDataServiceFolderResponse) GoString() string {
	return s.String()
}

func (s *CreateDataServiceFolderResponse) SetHeaders(v map[string]*string) *CreateDataServiceFolderResponse {
	s.Headers = v
	return s
}

func (s *CreateDataServiceFolderResponse) SetStatusCode(v int32) *CreateDataServiceFolderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataServiceFolderResponse) SetBody(v *CreateDataServiceFolderResponseBody) *CreateDataServiceFolderResponse {
	s.Body = v
	return s
}

type CreateDataServiceGroupRequest struct {
	// The ID of the API group that is associated with the business process in the API Gateway console. You can log on to the API Gateway console and go to the Group Details page to view the ID.
	ApiGatewayGroupId *string `json:"ApiGatewayGroupId,omitempty" xml:"ApiGatewayGroupId,omitempty"`
	// The description of the business process.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the business process.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s CreateDataServiceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataServiceGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateDataServiceGroupRequest) SetApiGatewayGroupId(v string) *CreateDataServiceGroupRequest {
	s.ApiGatewayGroupId = &v
	return s
}

func (s *CreateDataServiceGroupRequest) SetDescription(v string) *CreateDataServiceGroupRequest {
	s.Description = &v
	return s
}

func (s *CreateDataServiceGroupRequest) SetGroupName(v string) *CreateDataServiceGroupRequest {
	s.GroupName = &v
	return s
}

func (s *CreateDataServiceGroupRequest) SetProjectId(v int64) *CreateDataServiceGroupRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateDataServiceGroupRequest) SetTenantId(v int64) *CreateDataServiceGroupRequest {
	s.TenantId = &v
	return s
}

type CreateDataServiceGroupResponseBody struct {
	// The ID of the business process.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateDataServiceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDataServiceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataServiceGroupResponseBody) SetGroupId(v string) *CreateDataServiceGroupResponseBody {
	s.GroupId = &v
	return s
}

func (s *CreateDataServiceGroupResponseBody) SetRequestId(v string) *CreateDataServiceGroupResponseBody {
	s.RequestId = &v
	return s
}

type CreateDataServiceGroupResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDataServiceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDataServiceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDataServiceGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateDataServiceGroupResponse) SetHeaders(v map[string]*string) *CreateDataServiceGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateDataServiceGroupResponse) SetStatusCode(v int32) *CreateDataServiceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataServiceGroupResponse) SetBody(v *CreateDataServiceGroupResponseBody) *CreateDataServiceGroupResponse {
	s.Body = v
	return s
}

type CreateDataSourceRequest struct {
	// The ID of the data source.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The environment in which the data source is used. Valid values: 0 and 1. 0 indicates the development environment. 1 indicates the production environment.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The subtype of the data source. Example:
	//
	// *   This parameter takes effect only if the DataSourceType parameter is set to rds.
	// *   If the DataSourceType parameter is set to rds, this parameter can be set to mysql, sqlserver, or postgresql.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The HTTP status code returned.
	EnvType *int32 `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The type of the data source. Valid values:
	//
	// *   odps
	// *   mysql
	// *   rds
	// *   oss
	// *   sqlserver
	// *   polardb
	// *   oracle
	// *   mongodb
	// *   emr
	// *   postgresql
	// *   analyticdb_for_mysql
	// *   hybriddb_for_postgresql
	// *   holo
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The description of the data source.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The details of the data source. Examples of details of some common data sources:
	//
	// *   odps
	//
	// ```
	//
	// {
	//   "accessId": "xssssss",
	//   "accessKey": "xsaxsaxsa",
	//   "authType": 2,
	//   "endpoint": "http://service.odps.aliyun.com/api",
	//   "project": "xsaxsax",
	//   "tag": "public"
	// }
	// ```
	//
	// *   mysql
	//
	// ```
	//
	// {
	//   "database": "xsaxsa",
	//   "instanceName": "rm-xsaxsa",
	//   "password": "xsaxsa",
	//   "rdsOwnerId": "xasxsa",
	//   "regionId": "cn-shanghai",
	//   "tag": "rds",
	//   "username": "xsaxsa"
	// }
	// ```
	//
	// *   rds
	//
	// ```
	//
	// {
	//   "configType": 1,
	//   "tag": "rds",
	//   "database": "xsaxsa",
	//   "username": "xsaxsa",
	//   "password": "xssaxsa$32050",
	//   "instanceName": "rm-xsaxs",
	//   "rdsOwnerId": "11111111"
	// }
	// ```
	//
	// *   oss
	//
	// ```
	//
	// {
	//   "accessId": "sssssxx",
	//   "accessKey": "xsaxaxsaxs",
	//   "bucket": "xsa-xs-xs",
	//   "endpoint": "http://oss-cn-shanghai.aliyuncs.com",
	//   "tag": "public"
	// }
	// ```
	//
	// *   sqlserver
	//
	// ```
	//
	// {
	//   "jdbcUrl": "jdbc:sqlserver://xsaxsa-xsaxsa.database.xxx.cn:123;DatabaseName=xsxs-xsxs",
	//   "password": "sdasda$fs",
	//   "tag": "public",
	//   "username": "sxaxacdacdd"
	// }
	// ```
	//
	// *   polardb
	//
	// ```
	//
	// {
	//   "clusterId": "pc-sdadsadsa",
	//   "database": "dsadsadsa",
	//   "ownerId": "121212122",
	//   "password": "sdasdafssa",
	//   "region": "cn-shanghai",
	//   "tag": "polardb",
	//   "username": "asdadsads"
	// }
	// ```
	//
	// *   oracle
	//
	// ```
	//
	// {
	//   "jdbcUrl": "jdbc:oracle:saaa:@xxxxx:1521:PROD",
	//   "password": "sxasaxsa",
	//   "tag": "public",
	//   "username": "sasfadfa"
	// }
	// ```
	//
	// *   mongodb
	//
	// ```
	//
	// {
	//   "address": "[\"xsaxxsa.mongodb.rds.aliyuncs.com:3717\"]",
	//   "database": "admin",
	//   "password": "sadsda@",
	//   "tag": "public",
	//   "username": "dsadsadas"
	// }
	// ```
	//
	// *   emr
	//
	// ```
	//
	// {
	//   "accessId": "xsaxsa",
	//   "emrClusterId": "C-dsads",
	//   "emrResourceQueueName": "default",
	//   "emrEndpoint": "emr.aliyuncs.com",
	//   "accessKey": "dsadsad",
	//   "emrUserId": "224833315798889783",
	//   "name": "sasdsadsa",
	//   "emrAccessMode": "simple",
	//   "region": "cn-shanghai",
	//   "authType": "2",
	//   "emrProjectId": "FP-sdadsad"
	// }
	// ```
	//
	// *   postgresql
	//
	// ```
	//
	// {
	//   "jdbcUrl": "jdbc:postgresql://xxxx:1921/ssss",
	//   "password": "sdadsads",
	//   "tag": "public",
	//   "username": "sdsasda"
	// }
	// ```
	//
	// *   analyticdb_for_mysql
	//
	// ```
	//
	// {
	//   "instanceId": "am-sadsada",
	//   "database": "xsxsx",
	//   "username": "xsxsa",
	//   "password": "asdadsa",
	//   "connectionString": "am-xssxsxs.ads.aliyuncs.com:3306"
	// }
	// ```
	//
	// *   hybriddb_for_postgresql
	//
	// ```
	//
	// {
	//   "connectionString": "gp-xsaxsaxa-master.gpdbmaster.rds.aliyuncs.com",
	//   "database": "xsaxsaxas",
	//   "password": "xsaxsaxsa@11",
	//   "instanceId": "gp-xsaxsaxsa",
	//   "port": "541132",
	//   "ownerId": "xsaxsaxsas",
	//   "username": "sadsad"
	// }
	// ```
	//
	// *   holo
	//
	// ```
	//
	// {
	//   "accessId": "xsaxsaxs",
	//   "accessKey": "xsaxsaxsa",
	//   "database": "xsaxsaxsa",
	//   "instanceId": "xsaxa",
	//   "tag": "aliyun"
	// }
	// ```
	//
	// *   kafka
	//
	// ```
	//
	// {
	//   "instanceId": "xsax-cn-xsaxsa",
	//   "regionId": "cn-shanghai",
	//   "tag": "aliyun",
	//   "ownerId": "1212121212112"
	// }
	// ```
	SubType *string `json:"SubType,omitempty" xml:"SubType,omitempty"`
}

func (s CreateDataSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataSourceRequest) GoString() string {
	return s.String()
}

func (s *CreateDataSourceRequest) SetContent(v string) *CreateDataSourceRequest {
	s.Content = &v
	return s
}

func (s *CreateDataSourceRequest) SetDataSourceType(v string) *CreateDataSourceRequest {
	s.DataSourceType = &v
	return s
}

func (s *CreateDataSourceRequest) SetDescription(v string) *CreateDataSourceRequest {
	s.Description = &v
	return s
}

func (s *CreateDataSourceRequest) SetEnvType(v int32) *CreateDataSourceRequest {
	s.EnvType = &v
	return s
}

func (s *CreateDataSourceRequest) SetName(v string) *CreateDataSourceRequest {
	s.Name = &v
	return s
}

func (s *CreateDataSourceRequest) SetProjectId(v int64) *CreateDataSourceRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateDataSourceRequest) SetSubType(v string) *CreateDataSourceRequest {
	s.SubType = &v
	return s
}

type CreateDataSourceResponseBody struct {
	// Indicates whether the request was successful.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The ID of the request.
	HttpStatusCode *string `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDataSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDataSourceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataSourceResponseBody) SetData(v int64) *CreateDataSourceResponseBody {
	s.Data = &v
	return s
}

func (s *CreateDataSourceResponseBody) SetHttpStatusCode(v string) *CreateDataSourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateDataSourceResponseBody) SetRequestId(v string) *CreateDataSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDataSourceResponseBody) SetSuccess(v bool) *CreateDataSourceResponseBody {
	s.Success = &v
	return s
}

type CreateDataSourceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateDataSourceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateDataSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDataSourceResponse) GoString() string {
	return s.String()
}

func (s *CreateDataSourceResponse) SetHeaders(v map[string]*string) *CreateDataSourceResponse {
	s.Headers = v
	return s
}

func (s *CreateDataSourceResponse) SetStatusCode(v int32) *CreateDataSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataSourceResponse) SetBody(v *CreateDataSourceResponseBody) *CreateDataSourceResponse {
	s.Body = v
	return s
}

type CreateExportMigrationRequest struct {
	// The description of the export task.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The export mode of the export task. Valid values:
	//
	// *   FULL: The export task is used to export all data objects.
	// *   INCREMENTAL: The export task is used to export data objects that were modified since the specified point in time. If you set this parameter to INCREMENTAL, you must configure the IncrementalSince parameter.
	ExportMode *string `json:"ExportMode,omitempty" xml:"ExportMode,omitempty"`
	// The status of the data objects that you want to export in the export task. The system exports data objects in the state that is specified by this parameter. Valid values:
	//
	// *   SAVED: Data objects that are in the SAVED state are exported.
	// *   SUBMITTED: Data objects that are in the SUBMITTED state are exported.
	// *   DEPLOYED: Data objects that are in the DEPLOYED state are exported.
	ExportObjectStatus *string `json:"ExportObjectStatus,omitempty" xml:"ExportObjectStatus,omitempty"`
	// The start time of the incremental export task.
	//
	// The IncrementalSince parameter takes effect only when the ExportMode parameter is set to INCREMENTAL.
	IncrementalSince *int64 `json:"IncrementalSince,omitempty" xml:"IncrementalSince,omitempty"`
	// The name of the export task.
	//
	// The name of each export task must be unique. You must ensure that no duplicate export task exists in the current workspace.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s CreateExportMigrationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateExportMigrationRequest) GoString() string {
	return s.String()
}

func (s *CreateExportMigrationRequest) SetDescription(v string) *CreateExportMigrationRequest {
	s.Description = &v
	return s
}

func (s *CreateExportMigrationRequest) SetExportMode(v string) *CreateExportMigrationRequest {
	s.ExportMode = &v
	return s
}

func (s *CreateExportMigrationRequest) SetExportObjectStatus(v string) *CreateExportMigrationRequest {
	s.ExportObjectStatus = &v
	return s
}

func (s *CreateExportMigrationRequest) SetIncrementalSince(v int64) *CreateExportMigrationRequest {
	s.IncrementalSince = &v
	return s
}

func (s *CreateExportMigrationRequest) SetName(v string) *CreateExportMigrationRequest {
	s.Name = &v
	return s
}

func (s *CreateExportMigrationRequest) SetProjectId(v int64) *CreateExportMigrationRequest {
	s.ProjectId = &v
	return s
}

type CreateExportMigrationResponseBody struct {
	// The ID of the export task.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot errors.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The call succeeded.
	// *   false: The call failed. You can locate errors based on the request ID.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateExportMigrationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateExportMigrationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateExportMigrationResponseBody) SetData(v int64) *CreateExportMigrationResponseBody {
	s.Data = &v
	return s
}

func (s *CreateExportMigrationResponseBody) SetRequestId(v string) *CreateExportMigrationResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateExportMigrationResponseBody) SetSuccess(v bool) *CreateExportMigrationResponseBody {
	s.Success = &v
	return s
}

type CreateExportMigrationResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateExportMigrationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateExportMigrationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateExportMigrationResponse) GoString() string {
	return s.String()
}

func (s *CreateExportMigrationResponse) SetHeaders(v map[string]*string) *CreateExportMigrationResponse {
	s.Headers = v
	return s
}

func (s *CreateExportMigrationResponse) SetStatusCode(v int32) *CreateExportMigrationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateExportMigrationResponse) SetBody(v *CreateExportMigrationResponseBody) *CreateExportMigrationResponse {
	s.Body = v
	return s
}

type CreateFileRequest struct {
	// The advanced configurations of the node.
	//
	// This parameter is valid only for an EMR Spark Streaming node or an EMR Streaming SQL node. This parameter corresponds to the Advanced Settings tab of the node in the [DataWorks console](https://workbench.data.aliyun.com/console).
	//
	// The value of this parameter must be in the JSON format.
	AdvancedSettings *string `json:"AdvancedSettings,omitempty" xml:"AdvancedSettings,omitempty"`
	// Specifies whether to enable the automatic parsing feature for the file. Valid values:
	//
	// *   true: enables the automatic parsing feature for the file.
	// *   false: does not enable the automatic parsing feature for the file.
	//
	// This parameter corresponds to the Analyze Code parameter that is displayed after Same Cycle is selected in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	AutoParsing *bool `json:"AutoParsing,omitempty" xml:"AutoParsing,omitempty"`
	// The interval between automatic reruns after an error occurs. Unit: milliseconds. Maximum value: 1800000 (30 minutes).
	//
	// This parameter corresponds to the Rerun Interval parameter that is displayed after the Auto Rerun upon Error check box is selected in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	//
	// The interval that you specify in the DataWorks console is measured in minutes. Pay attention to the conversion between the units of time when you call the operation.
	AutoRerunIntervalMillis *int32 `json:"AutoRerunIntervalMillis,omitempty" xml:"AutoRerunIntervalMillis,omitempty"`
	// The number of automatic reruns that are allowed after an error occurs. Maximum value: 10.
	AutoRerunTimes *int32 `json:"AutoRerunTimes,omitempty" xml:"AutoRerunTimes,omitempty"`
	// The name of the data source for which the node is run.
	//
	// You can call the [UpdateDataSource](~~211432~~) operation to query the available data sources in the workspace.
	ConnectionName *string `json:"ConnectionName,omitempty" xml:"ConnectionName,omitempty"`
	// The code for the file. The code format varies based on the file type. To view the code format for a specific file type, go to Operation Center, right-click a node of the file type, and then select View Code.
	Content                 *string `json:"Content,omitempty" xml:"Content,omitempty"`
	CreateFolderIfNotExists *bool   `json:"CreateFolderIfNotExists,omitempty" xml:"CreateFolderIfNotExists,omitempty"`
	// The CRON expression that represents the automatic scheduling policy of the node. This parameter corresponds to the Cron Expression parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console). After you configure the Scheduling Cycle and Run At parameters in the DataWorks console, DataWorks generates the value of the Cron Expression parameter.
	//
	// Examples:
	//
	// *   CRON expression for a node that is scheduled to run at 05:30 every day: `00 30 05 * * ?`
	// *   CRON expression for a node that is scheduled to run at the fifteenth minute of each hour: `00 15 00-23/1 * * ?`
	// *   CRON expression for a node that is scheduled to run every 10 minutes: `00 00/10 * * * ?`
	// *   CRON expression for a node that is scheduled to run every 10 minutes from 08:00 to 17:00 every day: `00 00-59/10 8-17 * * * ?`
	// *   CRON expression for a node that is scheduled to run at 00:20 on the first day of each month: `00 20 00 1 * ?`
	// *   CRON expression for a node that is scheduled to run every three months starting from 00:10 on January 1: `00 10 00 1 1-12/3 ?`
	// *   CRON expression for a node that is scheduled to run at 00:05 every Tuesday and Friday: `00 05 00 * * 2,5`
	//
	// The scheduling system of DataWorks imposes the following limits on CRON expressions:
	//
	// *   A node can be scheduled to run at a minimum interval of 5 minutes.
	// *   A node can be scheduled to run at 00:05 every day at the earliest.
	CronExpress *string `json:"CronExpress,omitempty" xml:"CronExpress,omitempty"`
	// The type of the scheduling cycle. Valid values: NOT_DAY and DAY. The value NOT_DAY indicates that the node is scheduled to run by minute or hour. The value DAY indicates that the node is scheduled to run by day, week, or month.
	//
	// This parameter corresponds to the Scheduling Cycle parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	CycleType *string `json:"CycleType,omitempty" xml:"CycleType,omitempty"`
	// The IDs of the nodes that generate instances in the previous cycle on which the current node depends.
	DependentNodeIdList *string `json:"DependentNodeIdList,omitempty" xml:"DependentNodeIdList,omitempty"`
	// The type of the cross-cycle scheduling dependency of the node. Valid values:
	//
	// *   SELF: The instance generated for the node in the current cycle depends on the instance generated for the node in the previous cycle.
	//
	// *   CHILD: The instance generated for the node in the current cycle depends on the instances generated for the descendant nodes at the nearest level of the node in the previous cycle.
	//
	// *   USER_DEFINE: The instance generated for the node in the current cycle depends on the instances generated for one or more specified nodes in the previous cycle.
	//
	// *   NONE: No cross-cycle scheduling dependency type is selected for the node.
	//
	// *   USER_DEFINE_AND_SELF: The instance generated for the node in the current cycle depends on the instance generated for the node in the previous cycle and the instances generated for one or more specified nodes in the previous cycle.
	//
	// *   CHILD_AND_SELF: The instance generated for the node in the current cycle depends on the instances generated for the descendant nodes at the nearest level of the node in the previous cycle and the instance generated for the node in the previous cycle.
	DependentType *string `json:"DependentType,omitempty" xml:"DependentType,omitempty"`
	// The end time of automatic scheduling. Set the value to a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	//
	// This parameter corresponds to the Validity Period parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	EndEffectDate *int64 `json:"EndEffectDate,omitempty" xml:"EndEffectDate,omitempty"`
	// The description of the file.
	FileDescription *string `json:"FileDescription,omitempty" xml:"FileDescription,omitempty"`
	// The path of the file.
	FileFolderPath *string `json:"FileFolderPath,omitempty" xml:"FileFolderPath,omitempty"`
	// The name of the file.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The type of the code in the file.
	//
	// Valid values: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3).
	//
	// You can call the [ListFileType](~~212428~~) operation to query the type of the code for the file.
	FileType                        *int32 `json:"FileType,omitempty" xml:"FileType,omitempty"`
	IgnoreParentSkipRunningProperty *bool  `json:"IgnoreParentSkipRunningProperty,omitempty" xml:"IgnoreParentSkipRunningProperty,omitempty"`
	// The output name of the parent file on which the current file depends. If you specify multiple output names, separate them with commas (,).
	//
	// This parameter corresponds to the Output Name parameter under Parent Nodes in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	InputList *string `json:"InputList,omitempty" xml:"InputList,omitempty"`
	// The input parameters of the node. The value of this parameter must be in the JSON format. For more information about the input parameters, see the InputContextParameterList parameter in the Response parameters section of the [GetFile](~~173954~~) operation.
	//
	// This parameter corresponds to the Input Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	InputParameters *string `json:"InputParameters,omitempty" xml:"InputParameters,omitempty"`
	// The output parameters of the node. The value of this parameter must be in the JSON format. For more information about the output parameters, see the OutputContextParameterList parameter in the Response parameters section of the [GetFile](~~173954~~) operation.
	//
	// This parameter corresponds to the Output Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	OutputParameters *string `json:"OutputParameters,omitempty" xml:"OutputParameters,omitempty"`
	// The ID of the Alibaba Cloud account used by the file owner. If this parameter is not configured, the ID of the Alibaba Cloud account of the user who calls the operation is used.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The scheduling parameters of the node. Separate multiple parameters with spaces.
	//
	// This parameter corresponds to the Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console). For more information about the configurations of the scheduling parameters, see [Configure scheduling parameters](~~137548~~).
	ParaValue *string `json:"ParaValue,omitempty" xml:"ParaValue,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace ID.
	//
	// You must configure this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace name.
	//
	// You must configure this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
	// Specifies whether the node that corresponds to the file can be rerun. Valid values:
	//
	// *   ALL_ALLOWED: The node can be rerun regardless of whether it is successfully run or fails to run.
	// *   FAILURE_ALLOWED: The node can be rerun only after it fails to run.
	// *   ALL_DENIED: The node cannot be rerun regardless of whether it is successfully run or fails to run.
	//
	// This parameter corresponds to the Rerun parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	RerunMode *string `json:"RerunMode,omitempty" xml:"RerunMode,omitempty"`
	// This parameter is deprecated. Do not use this parameter.
	//
	// The identifier of the resource group that is used to run the node. This parameter corresponds to the Resource Group parameter in the Resource Group section of the Properties tab in the DataWorks console. You must configure one of the ResourceGroupId and ResourceGroupIdentifier parameters to determine the resource group that is used to run the node.
	//
	// You can call the [ListResourceGroups](~~173913~~) operation to query the available resource groups in the workspace. When you call the operation, set the ResourceGroupType parameter to 1. The response parameter Id indicates the ID of an available resource group.
	ResourceGroupId *int64 `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The identifier of the resource group that is used to run the node. You can call the [ListResourceGroups](~~173913~~) operation to query the available resource groups in the workspace.
	ResourceGroupIdentifier *string `json:"ResourceGroupIdentifier,omitempty" xml:"ResourceGroupIdentifier,omitempty"`
	// The scheduling type of the inner node. Valid values:
	//
	// *   NORMAL: The node is an auto triggered node.
	// *   MANUAL: The node is a manually triggered node. Manually triggered nodes cannot be automatically triggered. They correspond to the nodes in the Manually Triggered Workflows pane.
	// *   PAUSE: The node is a paused node.
	// *   SKIP: The node is a dry-run node. Dry-run nodes are started as scheduled, but the system sets the status of the nodes to successful when it starts to run them.
	SchedulerType *string `json:"SchedulerType,omitempty" xml:"SchedulerType,omitempty"`
	// The start time of automatic scheduling. Set the value to a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	//
	// This parameter corresponds to the Validity Period parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	StartEffectDate *int64 `json:"StartEffectDate,omitempty" xml:"StartEffectDate,omitempty"`
	// Specifies whether to immediately run a node after the node is deployed to the production environment.
	//
	// This parameter is valid only for an EMR Spark Streaming node or an EMR Streaming SQL node. This parameter corresponds to the Start Method parameter in the Schedule section of the Configure tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	StartImmediately *bool `json:"StartImmediately,omitempty" xml:"StartImmediately,omitempty"`
	// Specifies whether to suspend the scheduling of the node. Valid values:
	//
	// *   true: suspends the scheduling of the node.
	// *   false: does not suspend the scheduling of the node.
	//
	// This parameter corresponds to the Recurrence parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	Stop *bool `json:"Stop,omitempty" xml:"Stop,omitempty"`
}

func (s CreateFileRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateFileRequest) GoString() string {
	return s.String()
}

func (s *CreateFileRequest) SetAdvancedSettings(v string) *CreateFileRequest {
	s.AdvancedSettings = &v
	return s
}

func (s *CreateFileRequest) SetAutoParsing(v bool) *CreateFileRequest {
	s.AutoParsing = &v
	return s
}

func (s *CreateFileRequest) SetAutoRerunIntervalMillis(v int32) *CreateFileRequest {
	s.AutoRerunIntervalMillis = &v
	return s
}

func (s *CreateFileRequest) SetAutoRerunTimes(v int32) *CreateFileRequest {
	s.AutoRerunTimes = &v
	return s
}

func (s *CreateFileRequest) SetConnectionName(v string) *CreateFileRequest {
	s.ConnectionName = &v
	return s
}

func (s *CreateFileRequest) SetContent(v string) *CreateFileRequest {
	s.Content = &v
	return s
}

func (s *CreateFileRequest) SetCreateFolderIfNotExists(v bool) *CreateFileRequest {
	s.CreateFolderIfNotExists = &v
	return s
}

func (s *CreateFileRequest) SetCronExpress(v string) *CreateFileRequest {
	s.CronExpress = &v
	return s
}

func (s *CreateFileRequest) SetCycleType(v string) *CreateFileRequest {
	s.CycleType = &v
	return s
}

func (s *CreateFileRequest) SetDependentNodeIdList(v string) *CreateFileRequest {
	s.DependentNodeIdList = &v
	return s
}

func (s *CreateFileRequest) SetDependentType(v string) *CreateFileRequest {
	s.DependentType = &v
	return s
}

func (s *CreateFileRequest) SetEndEffectDate(v int64) *CreateFileRequest {
	s.EndEffectDate = &v
	return s
}

func (s *CreateFileRequest) SetFileDescription(v string) *CreateFileRequest {
	s.FileDescription = &v
	return s
}

func (s *CreateFileRequest) SetFileFolderPath(v string) *CreateFileRequest {
	s.FileFolderPath = &v
	return s
}

func (s *CreateFileRequest) SetFileName(v string) *CreateFileRequest {
	s.FileName = &v
	return s
}

func (s *CreateFileRequest) SetFileType(v int32) *CreateFileRequest {
	s.FileType = &v
	return s
}

func (s *CreateFileRequest) SetIgnoreParentSkipRunningProperty(v bool) *CreateFileRequest {
	s.IgnoreParentSkipRunningProperty = &v
	return s
}

func (s *CreateFileRequest) SetInputList(v string) *CreateFileRequest {
	s.InputList = &v
	return s
}

func (s *CreateFileRequest) SetInputParameters(v string) *CreateFileRequest {
	s.InputParameters = &v
	return s
}

func (s *CreateFileRequest) SetOutputParameters(v string) *CreateFileRequest {
	s.OutputParameters = &v
	return s
}

func (s *CreateFileRequest) SetOwner(v string) *CreateFileRequest {
	s.Owner = &v
	return s
}

func (s *CreateFileRequest) SetParaValue(v string) *CreateFileRequest {
	s.ParaValue = &v
	return s
}

func (s *CreateFileRequest) SetProjectId(v int64) *CreateFileRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateFileRequest) SetProjectIdentifier(v string) *CreateFileRequest {
	s.ProjectIdentifier = &v
	return s
}

func (s *CreateFileRequest) SetRerunMode(v string) *CreateFileRequest {
	s.RerunMode = &v
	return s
}

func (s *CreateFileRequest) SetResourceGroupId(v int64) *CreateFileRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateFileRequest) SetResourceGroupIdentifier(v string) *CreateFileRequest {
	s.ResourceGroupIdentifier = &v
	return s
}

func (s *CreateFileRequest) SetSchedulerType(v string) *CreateFileRequest {
	s.SchedulerType = &v
	return s
}

func (s *CreateFileRequest) SetStartEffectDate(v int64) *CreateFileRequest {
	s.StartEffectDate = &v
	return s
}

func (s *CreateFileRequest) SetStartImmediately(v bool) *CreateFileRequest {
	s.StartImmediately = &v
	return s
}

func (s *CreateFileRequest) SetStop(v bool) *CreateFileRequest {
	s.Stop = &v
	return s
}

type CreateFileResponseBody struct {
	// The ID of the file that was created.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateFileResponseBody) GoString() string {
	return s.String()
}

func (s *CreateFileResponseBody) SetData(v int64) *CreateFileResponseBody {
	s.Data = &v
	return s
}

func (s *CreateFileResponseBody) SetErrorCode(v string) *CreateFileResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateFileResponseBody) SetErrorMessage(v string) *CreateFileResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateFileResponseBody) SetHttpStatusCode(v int32) *CreateFileResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateFileResponseBody) SetRequestId(v string) *CreateFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateFileResponseBody) SetSuccess(v bool) *CreateFileResponseBody {
	s.Success = &v
	return s
}

type CreateFileResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateFileResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateFileResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateFileResponse) GoString() string {
	return s.String()
}

func (s *CreateFileResponse) SetHeaders(v map[string]*string) *CreateFileResponse {
	s.Headers = v
	return s
}

func (s *CreateFileResponse) SetStatusCode(v int32) *CreateFileResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateFileResponse) SetBody(v *CreateFileResponseBody) *CreateFileResponse {
	s.Body = v
	return s
}

type CreateFolderRequest struct {
	// The HTTP status code returned.
	FolderPath *string `json:"FolderPath,omitempty" xml:"FolderPath,omitempty"`
	// The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace name. You must configure either the ProjectId or ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The path of the folder.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s CreateFolderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateFolderRequest) GoString() string {
	return s.String()
}

func (s *CreateFolderRequest) SetFolderPath(v string) *CreateFolderRequest {
	s.FolderPath = &v
	return s
}

func (s *CreateFolderRequest) SetProjectId(v int64) *CreateFolderRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateFolderRequest) SetProjectIdentifier(v string) *CreateFolderRequest {
	s.ProjectIdentifier = &v
	return s
}

type CreateFolderResponseBody struct {
	// The ID of the request. You can use the ID to troubleshoot issues.
	Data      *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The unique identifier of the folder.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The error code returned.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateFolderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateFolderResponseBody) GoString() string {
	return s.String()
}

func (s *CreateFolderResponseBody) SetData(v string) *CreateFolderResponseBody {
	s.Data = &v
	return s
}

func (s *CreateFolderResponseBody) SetErrorCode(v string) *CreateFolderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateFolderResponseBody) SetErrorMessage(v string) *CreateFolderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateFolderResponseBody) SetHttpStatusCode(v int32) *CreateFolderResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateFolderResponseBody) SetRequestId(v string) *CreateFolderResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateFolderResponseBody) SetSuccess(v bool) *CreateFolderResponseBody {
	s.Success = &v
	return s
}

type CreateFolderResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateFolderResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateFolderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateFolderResponse) GoString() string {
	return s.String()
}

func (s *CreateFolderResponse) SetHeaders(v map[string]*string) *CreateFolderResponse {
	s.Headers = v
	return s
}

func (s *CreateFolderResponse) SetStatusCode(v int32) *CreateFolderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateFolderResponse) SetBody(v *CreateFolderResponseBody) *CreateFolderResponse {
	s.Body = v
	return s
}

type CreateImportMigrationRequest struct {
	// The mapping between the source compute engine instance and the destination compute engine instance.
	//
	// The following types of compute engine instances are supported: MaxCompute, E-MapReduce (EMR), Hadoop CDH, and Hologres.
	CalculateEngineMap *string `json:"CalculateEngineMap,omitempty" xml:"CalculateEngineMap,omitempty"`
	// The rule configured for automatically committing and deploying the import task. The rule contains the following parameters:
	//
	// *   resourceAutoCommit: specifies whether resources are automatically committed. The value true indicates that the resources are automatically committed, and the value false indicates that the resources are not automatically committed.
	// *   resourceAutoDeploy: specifies whether resources are automatically deployed. The value true indicates that the resources are automatically deployed, and the value false indicates that the resources are not automatically deployed.
	// *   functionAutoCommit: specifies whether the function is automatically committed. The value true indicates that the function is automatically committed, and the value false indicates that the function is not automatically committed.
	// *   functionAutoDeploy: specifies whether the function is automatically deployed. The value true indicates that the function is automatically deployed, and the value false indicates that the function is not automatically deployed.
	// *   tableAutoCommitToDev: specifies whether the table is automatically committed to the development environment. The value true indicates that the table is automatically committed to the development environment, and the value false indicates that the table is not automatically committed to the development environment.
	// *   tableAutoCommitToProd: specifies whether the table is automatically committed to the production environment. The value true indicates that the table is automatically committed to the production environment, and the value false indicates that the table is not automatically committed to the production environment.
	// *   ignoreLock: specifies whether the lock is automatically ignored when an import task is locked. The value true indicates that the lock is automatically ignored, and the value false indicates that the lock is not automatically ignored. If you set this parameter to true for an import task, you can forcibly update the task even if the task is locked.
	// *   fileAutoCommit: specifies whether the file is automatically committed. The value true indicates that the file is automatically committed, and the value false indicates that the file is not automatically committed.
	// *   fileAutoDeploy: specifies whether the file is automatically deployed. The value true indicates that the file is automatically deployed, and the value false indicates that the file is not automatically deployed.
	CommitRule *string `json:"CommitRule,omitempty" xml:"CommitRule,omitempty"`
	// The description of the import package.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the import task. The name must be unique within the workspace.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The path of the import package.
	//
	// **The import package must be uploaded. Example of the upload method:**`  Config config = new Config(); config.setAccessKeyId(accessId); config.setAccessKeySecret(accessKey); config.setEndpoint(popEndpoint); config.setRegionId(regionId); Client client = new Client(config); CreateImportMigrationAdvanceRequest request = new CreateImportMigrationAdvanceRequest(); request.setName("test_migration_api_" + System.currentTimeMillis()); request.setProjectId(123456L); request.setPackageType("DATAWORKS_MODEL"); request.setPackageFileObject(new FileInputStream("/home/admin/Downloads/test.zip")); RuntimeOptions runtime = new RuntimeOptions(); CreateImportMigrationResponse response = client.createImportMigrationAdvance(request, runtime); ... `
	PackageFile *string `json:"PackageFile,omitempty" xml:"PackageFile,omitempty"`
	// The type of the import package. Valid values:
	//
	// *   DATAWORKS_MODEL (standard format)
	// *   DATAWORKS_V2 (Apsara Stack DataWorks V3.6.1 to V3.11)
	// *   DATAWORKS_V3 (Apsara Stack DataWorks V3.12 and later)
	PackageType *string `json:"PackageType,omitempty" xml:"PackageType,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The mapping between the resource group for scheduling and the resource group for Data Integration. The keys and values in the mapping are the identifiers of the resource groups. Specify the mapping in the following format:
	//
	// ```
	//
	// {
	//     "SCHEDULER_RESOURCE_GROUP": {
	//         "xxx": "yyy"
	//     },
	//     "DI_RESOURCE_GROUP": {
	//         "ccc": "dfdd"
	//     }
	// }
	//
	//
	// ```
	ResourceGroupMap *string `json:"ResourceGroupMap,omitempty" xml:"ResourceGroupMap,omitempty"`
	// The mapping between the prefixes for the names of the source and destination workspaces. When the system performs the import operation, the prefix for the name of the source workspace in the import package is replaced based on the mapping.
	WorkspaceMap *string `json:"WorkspaceMap,omitempty" xml:"WorkspaceMap,omitempty"`
}

func (s CreateImportMigrationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateImportMigrationRequest) GoString() string {
	return s.String()
}

func (s *CreateImportMigrationRequest) SetCalculateEngineMap(v string) *CreateImportMigrationRequest {
	s.CalculateEngineMap = &v
	return s
}

func (s *CreateImportMigrationRequest) SetCommitRule(v string) *CreateImportMigrationRequest {
	s.CommitRule = &v
	return s
}

func (s *CreateImportMigrationRequest) SetDescription(v string) *CreateImportMigrationRequest {
	s.Description = &v
	return s
}

func (s *CreateImportMigrationRequest) SetName(v string) *CreateImportMigrationRequest {
	s.Name = &v
	return s
}

func (s *CreateImportMigrationRequest) SetPackageFile(v string) *CreateImportMigrationRequest {
	s.PackageFile = &v
	return s
}

func (s *CreateImportMigrationRequest) SetPackageType(v string) *CreateImportMigrationRequest {
	s.PackageType = &v
	return s
}

func (s *CreateImportMigrationRequest) SetProjectId(v int64) *CreateImportMigrationRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateImportMigrationRequest) SetResourceGroupMap(v string) *CreateImportMigrationRequest {
	s.ResourceGroupMap = &v
	return s
}

func (s *CreateImportMigrationRequest) SetWorkspaceMap(v string) *CreateImportMigrationRequest {
	s.WorkspaceMap = &v
	return s
}

type CreateImportMigrationAdvanceRequest struct {
	// The mapping between the source compute engine instance and the destination compute engine instance.
	//
	// The following types of compute engine instances are supported: MaxCompute, E-MapReduce (EMR), Hadoop CDH, and Hologres.
	CalculateEngineMap *string `json:"CalculateEngineMap,omitempty" xml:"CalculateEngineMap,omitempty"`
	// The rule configured for automatically committing and deploying the import task. The rule contains the following parameters:
	//
	// *   resourceAutoCommit: specifies whether resources are automatically committed. The value true indicates that the resources are automatically committed, and the value false indicates that the resources are not automatically committed.
	// *   resourceAutoDeploy: specifies whether resources are automatically deployed. The value true indicates that the resources are automatically deployed, and the value false indicates that the resources are not automatically deployed.
	// *   functionAutoCommit: specifies whether the function is automatically committed. The value true indicates that the function is automatically committed, and the value false indicates that the function is not automatically committed.
	// *   functionAutoDeploy: specifies whether the function is automatically deployed. The value true indicates that the function is automatically deployed, and the value false indicates that the function is not automatically deployed.
	// *   tableAutoCommitToDev: specifies whether the table is automatically committed to the development environment. The value true indicates that the table is automatically committed to the development environment, and the value false indicates that the table is not automatically committed to the development environment.
	// *   tableAutoCommitToProd: specifies whether the table is automatically committed to the production environment. The value true indicates that the table is automatically committed to the production environment, and the value false indicates that the table is not automatically committed to the production environment.
	// *   ignoreLock: specifies whether the lock is automatically ignored when an import task is locked. The value true indicates that the lock is automatically ignored, and the value false indicates that the lock is not automatically ignored. If you set this parameter to true for an import task, you can forcibly update the task even if the task is locked.
	// *   fileAutoCommit: specifies whether the file is automatically committed. The value true indicates that the file is automatically committed, and the value false indicates that the file is not automatically committed.
	// *   fileAutoDeploy: specifies whether the file is automatically deployed. The value true indicates that the file is automatically deployed, and the value false indicates that the file is not automatically deployed.
	CommitRule *string `json:"CommitRule,omitempty" xml:"CommitRule,omitempty"`
	// The description of the import package.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the import task. The name must be unique within the workspace.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The path of the import package.
	//
	// **The import package must be uploaded. Example of the upload method:**`  Config config = new Config(); config.setAccessKeyId(accessId); config.setAccessKeySecret(accessKey); config.setEndpoint(popEndpoint); config.setRegionId(regionId); Client client = new Client(config); CreateImportMigrationAdvanceRequest request = new CreateImportMigrationAdvanceRequest(); request.setName("test_migration_api_" + System.currentTimeMillis()); request.setProjectId(123456L); request.setPackageType("DATAWORKS_MODEL"); request.setPackageFileObject(new FileInputStream("/home/admin/Downloads/test.zip")); RuntimeOptions runtime = new RuntimeOptions(); CreateImportMigrationResponse response = client.createImportMigrationAdvance(request, runtime); ... `
	PackageFileObject io.Reader `json:"PackageFile,omitempty" xml:"PackageFile,omitempty"`
	// The type of the import package. Valid values:
	//
	// *   DATAWORKS_MODEL (standard format)
	// *   DATAWORKS_V2 (Apsara Stack DataWorks V3.6.1 to V3.11)
	// *   DATAWORKS_V3 (Apsara Stack DataWorks V3.12 and later)
	PackageType *string `json:"PackageType,omitempty" xml:"PackageType,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The mapping between the resource group for scheduling and the resource group for Data Integration. The keys and values in the mapping are the identifiers of the resource groups. Specify the mapping in the following format:
	//
	// ```
	//
	// {
	//     "SCHEDULER_RESOURCE_GROUP": {
	//         "xxx": "yyy"
	//     },
	//     "DI_RESOURCE_GROUP": {
	//         "ccc": "dfdd"
	//     }
	// }
	//
	//
	// ```
	ResourceGroupMap *string `json:"ResourceGroupMap,omitempty" xml:"ResourceGroupMap,omitempty"`
	// The mapping between the prefixes for the names of the source and destination workspaces. When the system performs the import operation, the prefix for the name of the source workspace in the import package is replaced based on the mapping.
	WorkspaceMap *string `json:"WorkspaceMap,omitempty" xml:"WorkspaceMap,omitempty"`
}

func (s CreateImportMigrationAdvanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateImportMigrationAdvanceRequest) GoString() string {
	return s.String()
}

func (s *CreateImportMigrationAdvanceRequest) SetCalculateEngineMap(v string) *CreateImportMigrationAdvanceRequest {
	s.CalculateEngineMap = &v
	return s
}

func (s *CreateImportMigrationAdvanceRequest) SetCommitRule(v string) *CreateImportMigrationAdvanceRequest {
	s.CommitRule = &v
	return s
}

func (s *CreateImportMigrationAdvanceRequest) SetDescription(v string) *CreateImportMigrationAdvanceRequest {
	s.Description = &v
	return s
}

func (s *CreateImportMigrationAdvanceRequest) SetName(v string) *CreateImportMigrationAdvanceRequest {
	s.Name = &v
	return s
}

func (s *CreateImportMigrationAdvanceRequest) SetPackageFileObject(v io.Reader) *CreateImportMigrationAdvanceRequest {
	s.PackageFileObject = v
	return s
}

func (s *CreateImportMigrationAdvanceRequest) SetPackageType(v string) *CreateImportMigrationAdvanceRequest {
	s.PackageType = &v
	return s
}

func (s *CreateImportMigrationAdvanceRequest) SetProjectId(v int64) *CreateImportMigrationAdvanceRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateImportMigrationAdvanceRequest) SetResourceGroupMap(v string) *CreateImportMigrationAdvanceRequest {
	s.ResourceGroupMap = &v
	return s
}

func (s *CreateImportMigrationAdvanceRequest) SetWorkspaceMap(v string) *CreateImportMigrationAdvanceRequest {
	s.WorkspaceMap = &v
	return s
}

type CreateImportMigrationResponseBody struct {
	// The ID of the import task. The ID is used as an input parameter if you want the system to run the import task or you want to obtain the running progress of the import task.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateImportMigrationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateImportMigrationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateImportMigrationResponseBody) SetData(v int64) *CreateImportMigrationResponseBody {
	s.Data = &v
	return s
}

func (s *CreateImportMigrationResponseBody) SetErrorCode(v string) *CreateImportMigrationResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateImportMigrationResponseBody) SetErrorMessage(v string) *CreateImportMigrationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateImportMigrationResponseBody) SetHttpStatusCode(v int32) *CreateImportMigrationResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateImportMigrationResponseBody) SetRequestId(v string) *CreateImportMigrationResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateImportMigrationResponseBody) SetSuccess(v bool) *CreateImportMigrationResponseBody {
	s.Success = &v
	return s
}

type CreateImportMigrationResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateImportMigrationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateImportMigrationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateImportMigrationResponse) GoString() string {
	return s.String()
}

func (s *CreateImportMigrationResponse) SetHeaders(v map[string]*string) *CreateImportMigrationResponse {
	s.Headers = v
	return s
}

func (s *CreateImportMigrationResponse) SetStatusCode(v int32) *CreateImportMigrationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateImportMigrationResponse) SetBody(v *CreateImportMigrationResponseBody) *CreateImportMigrationResponse {
	s.Body = v
	return s
}

type CreateManualDagRequest struct {
	BizDate        *string `json:"BizDate,omitempty" xml:"BizDate,omitempty"`
	DagParameters  *string `json:"DagParameters,omitempty" xml:"DagParameters,omitempty"`
	ExcludeNodeIds *string `json:"ExcludeNodeIds,omitempty" xml:"ExcludeNodeIds,omitempty"`
	FlowName       *string `json:"FlowName,omitempty" xml:"FlowName,omitempty"`
	IncludeNodeIds *string `json:"IncludeNodeIds,omitempty" xml:"IncludeNodeIds,omitempty"`
	NodeParameters *string `json:"NodeParameters,omitempty" xml:"NodeParameters,omitempty"`
	ProjectEnv     *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
	ProjectName    *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s CreateManualDagRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateManualDagRequest) GoString() string {
	return s.String()
}

func (s *CreateManualDagRequest) SetBizDate(v string) *CreateManualDagRequest {
	s.BizDate = &v
	return s
}

func (s *CreateManualDagRequest) SetDagParameters(v string) *CreateManualDagRequest {
	s.DagParameters = &v
	return s
}

func (s *CreateManualDagRequest) SetExcludeNodeIds(v string) *CreateManualDagRequest {
	s.ExcludeNodeIds = &v
	return s
}

func (s *CreateManualDagRequest) SetFlowName(v string) *CreateManualDagRequest {
	s.FlowName = &v
	return s
}

func (s *CreateManualDagRequest) SetIncludeNodeIds(v string) *CreateManualDagRequest {
	s.IncludeNodeIds = &v
	return s
}

func (s *CreateManualDagRequest) SetNodeParameters(v string) *CreateManualDagRequest {
	s.NodeParameters = &v
	return s
}

func (s *CreateManualDagRequest) SetProjectEnv(v string) *CreateManualDagRequest {
	s.ProjectEnv = &v
	return s
}

func (s *CreateManualDagRequest) SetProjectName(v string) *CreateManualDagRequest {
	s.ProjectName = &v
	return s
}

type CreateManualDagResponseBody struct {
	DagId     *int64  `json:"DagId,omitempty" xml:"DagId,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateManualDagResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateManualDagResponseBody) GoString() string {
	return s.String()
}

func (s *CreateManualDagResponseBody) SetDagId(v int64) *CreateManualDagResponseBody {
	s.DagId = &v
	return s
}

func (s *CreateManualDagResponseBody) SetRequestId(v string) *CreateManualDagResponseBody {
	s.RequestId = &v
	return s
}

type CreateManualDagResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateManualDagResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateManualDagResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateManualDagResponse) GoString() string {
	return s.String()
}

func (s *CreateManualDagResponse) SetHeaders(v map[string]*string) *CreateManualDagResponse {
	s.Headers = v
	return s
}

func (s *CreateManualDagResponse) SetStatusCode(v int32) *CreateManualDagResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateManualDagResponse) SetBody(v *CreateManualDagResponseBody) *CreateManualDagResponse {
	s.Body = v
	return s
}

type CreateMetaCategoryRequest struct {
	// The remarks of the category.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The name of the category.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the parent category.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
}

func (s CreateMetaCategoryRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateMetaCategoryRequest) GoString() string {
	return s.String()
}

func (s *CreateMetaCategoryRequest) SetComment(v string) *CreateMetaCategoryRequest {
	s.Comment = &v
	return s
}

func (s *CreateMetaCategoryRequest) SetName(v string) *CreateMetaCategoryRequest {
	s.Name = &v
	return s
}

func (s *CreateMetaCategoryRequest) SetParentId(v int64) *CreateMetaCategoryRequest {
	s.ParentId = &v
	return s
}

type CreateMetaCategoryResponseBody struct {
	// The information about the category.
	Data *CreateMetaCategoryResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateMetaCategoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateMetaCategoryResponseBody) GoString() string {
	return s.String()
}

func (s *CreateMetaCategoryResponseBody) SetData(v *CreateMetaCategoryResponseBodyData) *CreateMetaCategoryResponseBody {
	s.Data = v
	return s
}

func (s *CreateMetaCategoryResponseBody) SetErrorCode(v string) *CreateMetaCategoryResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateMetaCategoryResponseBody) SetErrorMessage(v string) *CreateMetaCategoryResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateMetaCategoryResponseBody) SetHttpStatusCode(v int32) *CreateMetaCategoryResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateMetaCategoryResponseBody) SetRequestId(v string) *CreateMetaCategoryResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateMetaCategoryResponseBody) SetSuccess(v bool) *CreateMetaCategoryResponseBody {
	s.Success = &v
	return s
}

type CreateMetaCategoryResponseBodyData struct {
	// The ID of the category.
	CategoryId *int64 `json:"CategoryId,omitempty" xml:"CategoryId,omitempty"`
}

func (s CreateMetaCategoryResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateMetaCategoryResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateMetaCategoryResponseBodyData) SetCategoryId(v int64) *CreateMetaCategoryResponseBodyData {
	s.CategoryId = &v
	return s
}

type CreateMetaCategoryResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateMetaCategoryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateMetaCategoryResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateMetaCategoryResponse) GoString() string {
	return s.String()
}

func (s *CreateMetaCategoryResponse) SetHeaders(v map[string]*string) *CreateMetaCategoryResponse {
	s.Headers = v
	return s
}

func (s *CreateMetaCategoryResponse) SetStatusCode(v int32) *CreateMetaCategoryResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateMetaCategoryResponse) SetBody(v *CreateMetaCategoryResponseBody) *CreateMetaCategoryResponse {
	s.Body = v
	return s
}

type CreateMetaCollectionRequest struct {
	// The ID of the request.
	CollectionType *string `json:"CollectionType,omitempty" xml:"CollectionType,omitempty"`
	// The unique identifier of the parent collection.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The comment of the collection.
	//
	// The comment must be 1 to 64 characters in length.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the collection.
	ParentQualifiedName *string `json:"ParentQualifiedName,omitempty" xml:"ParentQualifiedName,omitempty"`
}

func (s CreateMetaCollectionRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateMetaCollectionRequest) GoString() string {
	return s.String()
}

func (s *CreateMetaCollectionRequest) SetCollectionType(v string) *CreateMetaCollectionRequest {
	s.CollectionType = &v
	return s
}

func (s *CreateMetaCollectionRequest) SetComment(v string) *CreateMetaCollectionRequest {
	s.Comment = &v
	return s
}

func (s *CreateMetaCollectionRequest) SetName(v string) *CreateMetaCollectionRequest {
	s.Name = &v
	return s
}

func (s *CreateMetaCollectionRequest) SetParentQualifiedName(v string) *CreateMetaCollectionRequest {
	s.ParentQualifiedName = &v
	return s
}

type CreateMetaCollectionResponseBody struct {
	// The error message returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	ErrorMessage   *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *string `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	QualifiedName *string `json:"QualifiedName,omitempty" xml:"QualifiedName,omitempty"`
	// The unique identifier of the collection.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The error code returned.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateMetaCollectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateMetaCollectionResponseBody) GoString() string {
	return s.String()
}

func (s *CreateMetaCollectionResponseBody) SetErrorCode(v string) *CreateMetaCollectionResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateMetaCollectionResponseBody) SetErrorMessage(v string) *CreateMetaCollectionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateMetaCollectionResponseBody) SetHttpStatusCode(v string) *CreateMetaCollectionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateMetaCollectionResponseBody) SetQualifiedName(v string) *CreateMetaCollectionResponseBody {
	s.QualifiedName = &v
	return s
}

func (s *CreateMetaCollectionResponseBody) SetRequestId(v string) *CreateMetaCollectionResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateMetaCollectionResponseBody) SetSuccess(v string) *CreateMetaCollectionResponseBody {
	s.Success = &v
	return s
}

type CreateMetaCollectionResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateMetaCollectionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateMetaCollectionResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateMetaCollectionResponse) GoString() string {
	return s.String()
}

func (s *CreateMetaCollectionResponse) SetHeaders(v map[string]*string) *CreateMetaCollectionResponse {
	s.Headers = v
	return s
}

func (s *CreateMetaCollectionResponse) SetStatusCode(v int32) *CreateMetaCollectionResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateMetaCollectionResponse) SetBody(v *CreateMetaCollectionResponseBody) *CreateMetaCollectionResponse {
	s.Body = v
	return s
}

type CreatePermissionApplyOrderRequest struct {
	ApplyObject []*CreatePermissionApplyOrderRequestApplyObject `json:"ApplyObject,omitempty" xml:"ApplyObject,omitempty" type:"Repeated"`
	// The reason for your request. The administrator determines whether to approve the request based on the reason.
	ApplyReason *string `json:"ApplyReason,omitempty" xml:"ApplyReason,omitempty"`
	// The ID of the Alibaba Cloud account for which you want to request permissions. If you want to request permissions for multiple Alibaba Cloud accounts, separate the IDs of the accounts with commas (,).
	ApplyUserIds *string `json:"ApplyUserIds,omitempty" xml:"ApplyUserIds,omitempty"`
	// The expiration time of the permissions that you request. This value is a UNIX timestamp. If you do not specify a value for this parameter, January 1, 2065 is used as the expiration time.
	//
	// If LabelSecurity is disabled for the MaxCompute project in which you want to request permissions on the fields of a table, or the security level of the fields is 0 or is lower than or equal to the security level of the Alibaba Cloud account for which you want to request permissions, you can request only permanent permissions.
	//
	// You can go to the Workspace Management page of the DataWorks console, click MaxCompute Management in the left-side navigation pane, and then check whether column-level access control is enabled.
	//
	// You can go to your DataWorks workspace, view the security level of the fields in DataMap, and then view the security level of the Alibaba Cloud account on the User Management page.
	Deadline *int64 `json:"Deadline,omitempty" xml:"Deadline,omitempty"`
	// The type of the compute engine instance in which you want to request permissions on the fields of a table. The parameter value is odps and cannot be changed. This value indicates that you can request permissions only on fields of tables in MaxCompute compute engine instances.
	EngineType *string `json:"EngineType,omitempty" xml:"EngineType,omitempty"`
	// The name of the MaxCompute project in which you request permissions on the fields of a table.
	MaxComputeProjectName *string `json:"MaxComputeProjectName,omitempty" xml:"MaxComputeProjectName,omitempty"`
	// The type of the permission request order. The parameter value is 1 and cannot be changed. This value indicates ACL-based authorization.
	OrderType *int32 `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	// The ID of the DataWorks workspace that is associated with the MaxCompute project in which you want to request permissions on the fields of a table. You can go to the Workspace Management page in the DataWorks console to view the workspace ID.
	WorkspaceId *int32 `json:"WorkspaceId,omitempty" xml:"WorkspaceId,omitempty"`
}

func (s CreatePermissionApplyOrderRequest) String() string {
	return tea.Prettify(s)
}

func (s CreatePermissionApplyOrderRequest) GoString() string {
	return s.String()
}

func (s *CreatePermissionApplyOrderRequest) SetApplyObject(v []*CreatePermissionApplyOrderRequestApplyObject) *CreatePermissionApplyOrderRequest {
	s.ApplyObject = v
	return s
}

func (s *CreatePermissionApplyOrderRequest) SetApplyReason(v string) *CreatePermissionApplyOrderRequest {
	s.ApplyReason = &v
	return s
}

func (s *CreatePermissionApplyOrderRequest) SetApplyUserIds(v string) *CreatePermissionApplyOrderRequest {
	s.ApplyUserIds = &v
	return s
}

func (s *CreatePermissionApplyOrderRequest) SetDeadline(v int64) *CreatePermissionApplyOrderRequest {
	s.Deadline = &v
	return s
}

func (s *CreatePermissionApplyOrderRequest) SetEngineType(v string) *CreatePermissionApplyOrderRequest {
	s.EngineType = &v
	return s
}

func (s *CreatePermissionApplyOrderRequest) SetMaxComputeProjectName(v string) *CreatePermissionApplyOrderRequest {
	s.MaxComputeProjectName = &v
	return s
}

func (s *CreatePermissionApplyOrderRequest) SetOrderType(v int32) *CreatePermissionApplyOrderRequest {
	s.OrderType = &v
	return s
}

func (s *CreatePermissionApplyOrderRequest) SetWorkspaceId(v int32) *CreatePermissionApplyOrderRequest {
	s.WorkspaceId = &v
	return s
}

type CreatePermissionApplyOrderRequestApplyObject struct {
	// The permission that you want to request. If you want to request multiple permissions at the same time, separate them with commas (,). You can request only the following permissions: Select, Describe, Drop, Alter, Update, and Download.
	Actions        *string                                                       `json:"Actions,omitempty" xml:"Actions,omitempty"`
	ColumnMetaList []*CreatePermissionApplyOrderRequestApplyObjectColumnMetaList `json:"ColumnMetaList,omitempty" xml:"ColumnMetaList,omitempty" type:"Repeated"`
	// The name of the object on which you want to request permissions. You can request permissions only on MaxCompute tables. Set this parameter to the name of the table on which you want to request permissions.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s CreatePermissionApplyOrderRequestApplyObject) String() string {
	return tea.Prettify(s)
}

func (s CreatePermissionApplyOrderRequestApplyObject) GoString() string {
	return s.String()
}

func (s *CreatePermissionApplyOrderRequestApplyObject) SetActions(v string) *CreatePermissionApplyOrderRequestApplyObject {
	s.Actions = &v
	return s
}

func (s *CreatePermissionApplyOrderRequestApplyObject) SetColumnMetaList(v []*CreatePermissionApplyOrderRequestApplyObjectColumnMetaList) *CreatePermissionApplyOrderRequestApplyObject {
	s.ColumnMetaList = v
	return s
}

func (s *CreatePermissionApplyOrderRequestApplyObject) SetName(v string) *CreatePermissionApplyOrderRequestApplyObject {
	s.Name = &v
	return s
}

type CreatePermissionApplyOrderRequestApplyObjectColumnMetaList struct {
	// The name of the field on which you want to request permissions. If you want to request permissions on an entire table, enter the names of all fields in the table.
	//
	// You can request permissions on specific fields of a table in a MaxCompute project only after LabelSecurity is enabled for this project. If LabelSecurity is disabled, you can request permissions only on an entire table.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s CreatePermissionApplyOrderRequestApplyObjectColumnMetaList) String() string {
	return tea.Prettify(s)
}

func (s CreatePermissionApplyOrderRequestApplyObjectColumnMetaList) GoString() string {
	return s.String()
}

func (s *CreatePermissionApplyOrderRequestApplyObjectColumnMetaList) SetName(v string) *CreatePermissionApplyOrderRequestApplyObjectColumnMetaList {
	s.Name = &v
	return s
}

type CreatePermissionApplyOrderResponseBody struct {
	// The ID of the request order. If you request permissions on multiple objects but each object has a different request approver, one request order is generated for each object and is sent to the related approver. In this case, an array is returned.
	FlowId []*string `json:"FlowId,omitempty" xml:"FlowId,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreatePermissionApplyOrderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreatePermissionApplyOrderResponseBody) GoString() string {
	return s.String()
}

func (s *CreatePermissionApplyOrderResponseBody) SetFlowId(v []*string) *CreatePermissionApplyOrderResponseBody {
	s.FlowId = v
	return s
}

func (s *CreatePermissionApplyOrderResponseBody) SetRequestId(v string) *CreatePermissionApplyOrderResponseBody {
	s.RequestId = &v
	return s
}

type CreatePermissionApplyOrderResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreatePermissionApplyOrderResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreatePermissionApplyOrderResponse) String() string {
	return tea.Prettify(s)
}

func (s CreatePermissionApplyOrderResponse) GoString() string {
	return s.String()
}

func (s *CreatePermissionApplyOrderResponse) SetHeaders(v map[string]*string) *CreatePermissionApplyOrderResponse {
	s.Headers = v
	return s
}

func (s *CreatePermissionApplyOrderResponse) SetStatusCode(v int32) *CreatePermissionApplyOrderResponse {
	s.StatusCode = &v
	return s
}

func (s *CreatePermissionApplyOrderResponse) SetBody(v *CreatePermissionApplyOrderResponseBody) *CreatePermissionApplyOrderResponse {
	s.Body = v
	return s
}

type CreateProjectRequest struct {
	ClientToken                    *string                     `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DisableDevelopment             *bool                       `json:"DisableDevelopment,omitempty" xml:"DisableDevelopment,omitempty"`
	IsAllowDownload                *int32                      `json:"IsAllowDownload,omitempty" xml:"IsAllowDownload,omitempty"`
	ProjectDescription             *string                     `json:"ProjectDescription,omitempty" xml:"ProjectDescription,omitempty"`
	ProjectIdentifier              *string                     `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
	ProjectMode                    *int32                      `json:"ProjectMode,omitempty" xml:"ProjectMode,omitempty"`
	ProjectName                    *string                     `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	ResourceManagerResourceGroupId *string                     `json:"ResourceManagerResourceGroupId,omitempty" xml:"ResourceManagerResourceGroupId,omitempty"`
	Tags                           []*CreateProjectRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s CreateProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateProjectRequest) GoString() string {
	return s.String()
}

func (s *CreateProjectRequest) SetClientToken(v string) *CreateProjectRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateProjectRequest) SetDisableDevelopment(v bool) *CreateProjectRequest {
	s.DisableDevelopment = &v
	return s
}

func (s *CreateProjectRequest) SetIsAllowDownload(v int32) *CreateProjectRequest {
	s.IsAllowDownload = &v
	return s
}

func (s *CreateProjectRequest) SetProjectDescription(v string) *CreateProjectRequest {
	s.ProjectDescription = &v
	return s
}

func (s *CreateProjectRequest) SetProjectIdentifier(v string) *CreateProjectRequest {
	s.ProjectIdentifier = &v
	return s
}

func (s *CreateProjectRequest) SetProjectMode(v int32) *CreateProjectRequest {
	s.ProjectMode = &v
	return s
}

func (s *CreateProjectRequest) SetProjectName(v string) *CreateProjectRequest {
	s.ProjectName = &v
	return s
}

func (s *CreateProjectRequest) SetResourceManagerResourceGroupId(v string) *CreateProjectRequest {
	s.ResourceManagerResourceGroupId = &v
	return s
}

func (s *CreateProjectRequest) SetTags(v []*CreateProjectRequestTags) *CreateProjectRequest {
	s.Tags = v
	return s
}

type CreateProjectRequestTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateProjectRequestTags) String() string {
	return tea.Prettify(s)
}

func (s CreateProjectRequestTags) GoString() string {
	return s.String()
}

func (s *CreateProjectRequestTags) SetKey(v string) *CreateProjectRequestTags {
	s.Key = &v
	return s
}

func (s *CreateProjectRequestTags) SetValue(v string) *CreateProjectRequestTags {
	s.Value = &v
	return s
}

type CreateProjectShrinkRequest struct {
	ClientToken                    *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	DisableDevelopment             *bool   `json:"DisableDevelopment,omitempty" xml:"DisableDevelopment,omitempty"`
	IsAllowDownload                *int32  `json:"IsAllowDownload,omitempty" xml:"IsAllowDownload,omitempty"`
	ProjectDescription             *string `json:"ProjectDescription,omitempty" xml:"ProjectDescription,omitempty"`
	ProjectIdentifier              *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
	ProjectMode                    *int32  `json:"ProjectMode,omitempty" xml:"ProjectMode,omitempty"`
	ProjectName                    *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	ResourceManagerResourceGroupId *string `json:"ResourceManagerResourceGroupId,omitempty" xml:"ResourceManagerResourceGroupId,omitempty"`
	TagsShrink                     *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s CreateProjectShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateProjectShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateProjectShrinkRequest) SetClientToken(v string) *CreateProjectShrinkRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateProjectShrinkRequest) SetDisableDevelopment(v bool) *CreateProjectShrinkRequest {
	s.DisableDevelopment = &v
	return s
}

func (s *CreateProjectShrinkRequest) SetIsAllowDownload(v int32) *CreateProjectShrinkRequest {
	s.IsAllowDownload = &v
	return s
}

func (s *CreateProjectShrinkRequest) SetProjectDescription(v string) *CreateProjectShrinkRequest {
	s.ProjectDescription = &v
	return s
}

func (s *CreateProjectShrinkRequest) SetProjectIdentifier(v string) *CreateProjectShrinkRequest {
	s.ProjectIdentifier = &v
	return s
}

func (s *CreateProjectShrinkRequest) SetProjectMode(v int32) *CreateProjectShrinkRequest {
	s.ProjectMode = &v
	return s
}

func (s *CreateProjectShrinkRequest) SetProjectName(v string) *CreateProjectShrinkRequest {
	s.ProjectName = &v
	return s
}

func (s *CreateProjectShrinkRequest) SetResourceManagerResourceGroupId(v string) *CreateProjectShrinkRequest {
	s.ResourceManagerResourceGroupId = &v
	return s
}

func (s *CreateProjectShrinkRequest) SetTagsShrink(v string) *CreateProjectShrinkRequest {
	s.TagsShrink = &v
	return s
}

type CreateProjectResponseBody struct {
	Data           *int64  `json:"Data,omitempty" xml:"Data,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateProjectResponseBody) GoString() string {
	return s.String()
}

func (s *CreateProjectResponseBody) SetData(v int64) *CreateProjectResponseBody {
	s.Data = &v
	return s
}

func (s *CreateProjectResponseBody) SetHttpStatusCode(v int32) *CreateProjectResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateProjectResponseBody) SetRequestId(v string) *CreateProjectResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateProjectResponseBody) SetSuccess(v bool) *CreateProjectResponseBody {
	s.Success = &v
	return s
}

type CreateProjectResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateProjectResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateProjectResponse) GoString() string {
	return s.String()
}

func (s *CreateProjectResponse) SetHeaders(v map[string]*string) *CreateProjectResponse {
	s.Headers = v
	return s
}

func (s *CreateProjectResponse) SetStatusCode(v int32) *CreateProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateProjectResponse) SetBody(v *CreateProjectResponseBody) *CreateProjectResponse {
	s.Body = v
	return s
}

type CreateProjectMemberRequest struct {
	// The ID of the request.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The client token that is used to ensure the idempotence of the request. We recommend that you set this parameter to a UUID.
	ProjectId *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	RoleCode  *string `json:"RoleCode,omitempty" xml:"RoleCode,omitempty"`
	// The code of the role. This parameter is optional. If you specify the RoleCode parameter, the user is assigned the role.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s CreateProjectMemberRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateProjectMemberRequest) GoString() string {
	return s.String()
}

func (s *CreateProjectMemberRequest) SetClientToken(v string) *CreateProjectMemberRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateProjectMemberRequest) SetProjectId(v int64) *CreateProjectMemberRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateProjectMemberRequest) SetRoleCode(v string) *CreateProjectMemberRequest {
	s.RoleCode = &v
	return s
}

func (s *CreateProjectMemberRequest) SetUserId(v string) *CreateProjectMemberRequest {
	s.UserId = &v
	return s
}

type CreateProjectMemberResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateProjectMemberResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateProjectMemberResponseBody) GoString() string {
	return s.String()
}

func (s *CreateProjectMemberResponseBody) SetRequestId(v string) *CreateProjectMemberResponseBody {
	s.RequestId = &v
	return s
}

type CreateProjectMemberResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateProjectMemberResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateProjectMemberResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateProjectMemberResponse) GoString() string {
	return s.String()
}

func (s *CreateProjectMemberResponse) SetHeaders(v map[string]*string) *CreateProjectMemberResponse {
	s.Headers = v
	return s
}

func (s *CreateProjectMemberResponse) SetStatusCode(v int32) *CreateProjectMemberResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateProjectMemberResponse) SetBody(v *CreateProjectMemberResponseBody) *CreateProjectMemberResponse {
	s.Body = v
	return s
}

type CreateQualityEntityRequest struct {
	// Valid values: 0 (corrected when SQl is completed) and 1 (corrected when task is completed).
	EntityLevel *int32 `json:"EntityLevel,omitempty" xml:"EntityLevel,omitempty"`
	// The engine or data source type.
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The partition expression.
	MatchExpression *string `json:"MatchExpression,omitempty" xml:"MatchExpression,omitempty"`
	ProjectId       *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the maxcompute project or data source.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s CreateQualityEntityRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateQualityEntityRequest) GoString() string {
	return s.String()
}

func (s *CreateQualityEntityRequest) SetEntityLevel(v int32) *CreateQualityEntityRequest {
	s.EntityLevel = &v
	return s
}

func (s *CreateQualityEntityRequest) SetEnvType(v string) *CreateQualityEntityRequest {
	s.EnvType = &v
	return s
}

func (s *CreateQualityEntityRequest) SetMatchExpression(v string) *CreateQualityEntityRequest {
	s.MatchExpression = &v
	return s
}

func (s *CreateQualityEntityRequest) SetProjectId(v int64) *CreateQualityEntityRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateQualityEntityRequest) SetProjectName(v string) *CreateQualityEntityRequest {
	s.ProjectName = &v
	return s
}

func (s *CreateQualityEntityRequest) SetTableName(v string) *CreateQualityEntityRequest {
	s.TableName = &v
	return s
}

type CreateQualityEntityResponseBody struct {
	// The ID of the partition expression.
	Data *int32 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The returned message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP request error codes.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateQualityEntityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateQualityEntityResponseBody) GoString() string {
	return s.String()
}

func (s *CreateQualityEntityResponseBody) SetData(v int32) *CreateQualityEntityResponseBody {
	s.Data = &v
	return s
}

func (s *CreateQualityEntityResponseBody) SetErrorCode(v string) *CreateQualityEntityResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateQualityEntityResponseBody) SetErrorMessage(v string) *CreateQualityEntityResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateQualityEntityResponseBody) SetHttpStatusCode(v int32) *CreateQualityEntityResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateQualityEntityResponseBody) SetRequestId(v string) *CreateQualityEntityResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateQualityEntityResponseBody) SetSuccess(v bool) *CreateQualityEntityResponseBody {
	s.Success = &v
	return s
}

type CreateQualityEntityResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateQualityEntityResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateQualityEntityResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateQualityEntityResponse) GoString() string {
	return s.String()
}

func (s *CreateQualityEntityResponse) SetHeaders(v map[string]*string) *CreateQualityEntityResponse {
	s.Headers = v
	return s
}

func (s *CreateQualityEntityResponse) SetStatusCode(v int32) *CreateQualityEntityResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateQualityEntityResponse) SetBody(v *CreateQualityEntityResponseBody) *CreateQualityEntityResponse {
	s.Body = v
	return s
}

type CreateQualityFollowerRequest struct {
	// The notification method. Valid values: 1, 2, 4, and 5. 1 indicates that the notification is sent by email. 2 indicates that the notification is sent by email and text message. 4 indicates that the notification is sent by a DingTalk chatbot. 5 indicates that the notification is sent by a DingTalk chatbot to all members in a DingTalk group.
	AlarmMode *int32 `json:"AlarmMode,omitempty" xml:"AlarmMode,omitempty"`
	// The ID of the partition filter expression.
	EntityId *int64 `json:"EntityId,omitempty" xml:"EntityId,omitempty"`
	// The user ID of the subscriber.
	Follower  *string `json:"Follower,omitempty" xml:"Follower,omitempty"`
	ProjectId *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the computing engine instance or data source.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s CreateQualityFollowerRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateQualityFollowerRequest) GoString() string {
	return s.String()
}

func (s *CreateQualityFollowerRequest) SetAlarmMode(v int32) *CreateQualityFollowerRequest {
	s.AlarmMode = &v
	return s
}

func (s *CreateQualityFollowerRequest) SetEntityId(v int64) *CreateQualityFollowerRequest {
	s.EntityId = &v
	return s
}

func (s *CreateQualityFollowerRequest) SetFollower(v string) *CreateQualityFollowerRequest {
	s.Follower = &v
	return s
}

func (s *CreateQualityFollowerRequest) SetProjectId(v int64) *CreateQualityFollowerRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateQualityFollowerRequest) SetProjectName(v string) *CreateQualityFollowerRequest {
	s.ProjectName = &v
	return s
}

type CreateQualityFollowerResponseBody struct {
	// The ID of the created subscription relationship.
	Data *int32 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateQualityFollowerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateQualityFollowerResponseBody) GoString() string {
	return s.String()
}

func (s *CreateQualityFollowerResponseBody) SetData(v int32) *CreateQualityFollowerResponseBody {
	s.Data = &v
	return s
}

func (s *CreateQualityFollowerResponseBody) SetErrorCode(v string) *CreateQualityFollowerResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateQualityFollowerResponseBody) SetErrorMessage(v string) *CreateQualityFollowerResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateQualityFollowerResponseBody) SetHttpStatusCode(v int32) *CreateQualityFollowerResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateQualityFollowerResponseBody) SetRequestId(v string) *CreateQualityFollowerResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateQualityFollowerResponseBody) SetSuccess(v bool) *CreateQualityFollowerResponseBody {
	s.Success = &v
	return s
}

type CreateQualityFollowerResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateQualityFollowerResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateQualityFollowerResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateQualityFollowerResponse) GoString() string {
	return s.String()
}

func (s *CreateQualityFollowerResponse) SetHeaders(v map[string]*string) *CreateQualityFollowerResponse {
	s.Headers = v
	return s
}

func (s *CreateQualityFollowerResponse) SetStatusCode(v int32) *CreateQualityFollowerResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateQualityFollowerResponse) SetBody(v *CreateQualityFollowerResponseBody) *CreateQualityFollowerResponse {
	s.Body = v
	return s
}

type CreateQualityRelativeNodeRequest struct {
	// The type of the compute engine instance or data source.
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The partition filter expression.
	MatchExpression *string `json:"MatchExpression,omitempty" xml:"MatchExpression,omitempty"`
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the compute engine instance or data source.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the workspace to which the node to be associated with the partition filter expression belongs.
	TargetNodeProjectId *int64 `json:"TargetNodeProjectId,omitempty" xml:"TargetNodeProjectId,omitempty"`
	// The name of the workspace to which the node to be associated with the partition filter expression belongs.
	TargetNodeProjectName *string `json:"TargetNodeProjectName,omitempty" xml:"TargetNodeProjectName,omitempty"`
}

func (s CreateQualityRelativeNodeRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateQualityRelativeNodeRequest) GoString() string {
	return s.String()
}

func (s *CreateQualityRelativeNodeRequest) SetEnvType(v string) *CreateQualityRelativeNodeRequest {
	s.EnvType = &v
	return s
}

func (s *CreateQualityRelativeNodeRequest) SetMatchExpression(v string) *CreateQualityRelativeNodeRequest {
	s.MatchExpression = &v
	return s
}

func (s *CreateQualityRelativeNodeRequest) SetNodeId(v int64) *CreateQualityRelativeNodeRequest {
	s.NodeId = &v
	return s
}

func (s *CreateQualityRelativeNodeRequest) SetProjectId(v int64) *CreateQualityRelativeNodeRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateQualityRelativeNodeRequest) SetProjectName(v string) *CreateQualityRelativeNodeRequest {
	s.ProjectName = &v
	return s
}

func (s *CreateQualityRelativeNodeRequest) SetTableName(v string) *CreateQualityRelativeNodeRequest {
	s.TableName = &v
	return s
}

func (s *CreateQualityRelativeNodeRequest) SetTargetNodeProjectId(v int64) *CreateQualityRelativeNodeRequest {
	s.TargetNodeProjectId = &v
	return s
}

func (s *CreateQualityRelativeNodeRequest) SetTargetNodeProjectName(v string) *CreateQualityRelativeNodeRequest {
	s.TargetNodeProjectName = &v
	return s
}

type CreateQualityRelativeNodeResponseBody struct {
	// Indicates whether the node is associated with the partition filter expression.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateQualityRelativeNodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateQualityRelativeNodeResponseBody) GoString() string {
	return s.String()
}

func (s *CreateQualityRelativeNodeResponseBody) SetData(v bool) *CreateQualityRelativeNodeResponseBody {
	s.Data = &v
	return s
}

func (s *CreateQualityRelativeNodeResponseBody) SetErrorCode(v string) *CreateQualityRelativeNodeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateQualityRelativeNodeResponseBody) SetErrorMessage(v string) *CreateQualityRelativeNodeResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateQualityRelativeNodeResponseBody) SetHttpStatusCode(v int32) *CreateQualityRelativeNodeResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateQualityRelativeNodeResponseBody) SetRequestId(v string) *CreateQualityRelativeNodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateQualityRelativeNodeResponseBody) SetSuccess(v bool) *CreateQualityRelativeNodeResponseBody {
	s.Success = &v
	return s
}

type CreateQualityRelativeNodeResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateQualityRelativeNodeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateQualityRelativeNodeResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateQualityRelativeNodeResponse) GoString() string {
	return s.String()
}

func (s *CreateQualityRelativeNodeResponse) SetHeaders(v map[string]*string) *CreateQualityRelativeNodeResponse {
	s.Headers = v
	return s
}

func (s *CreateQualityRelativeNodeResponse) SetStatusCode(v int32) *CreateQualityRelativeNodeResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateQualityRelativeNodeResponse) SetBody(v *CreateQualityRelativeNodeResponseBody) *CreateQualityRelativeNodeResponse {
	s.Body = v
	return s
}

type CreateQualityRuleRequest struct {
	// The strength of the monitoring rule. Valid values: 0 and 1. 0 indicates that the monitoring rule is a weak rule. 1 indicates that the monitoring rule is a strong rule.
	BlockType *int32 `json:"BlockType,omitempty" xml:"BlockType,omitempty"`
	// The ID of the checker.
	Checker *int32 `json:"Checker,omitempty" xml:"Checker,omitempty"`
	// The description of the monitoring rule.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The threshold for a critical alert. The threshold indicates the deviation of the monitoring result from the expected value. You can customize this threshold based on your business requirements. If a strong rule is used and a critical alert is reported, nodes are blocked.
	CriticalThreshold *string `json:"CriticalThreshold,omitempty" xml:"CriticalThreshold,omitempty"`
	// The ID of the partition filter expression.
	EntityId *int64 `json:"EntityId,omitempty" xml:"EntityId,omitempty"`
	// The expected value of the monitoring result.
	ExpectValue *string `json:"ExpectValue,omitempty" xml:"ExpectValue,omitempty"`
	// The method used to collect sample data. If you want to use a custom SQL statement as a sampling method, set this parameter to user_defined.
	MethodName *string `json:"MethodName,omitempty" xml:"MethodName,omitempty"`
	// The comparison operator of the monitoring rule.
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// Specifies whether the monitoring rule is a dynamic threshold rule. Valid values: 0 and 2. 0 indicates that the monitoring rule is not a dynamic threshold rule. 2 indicates that the monitoring rule is a dynamic threshold rule.
	PredictType *int32 `json:"PredictType,omitempty" xml:"PredictType,omitempty"`
	ProjectId   *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the compute engine instance or data source.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The fields that you want to monitor. If you want to monitor all fields in a table and check the table rows, set this parameter to table_count. If you want to monitor all fields in a table and check the table size, set this parameter to table_size.
	Property *string `json:"Property,omitempty" xml:"Property,omitempty"`
	// The data type of the fields that you want to monitor. If you want to monitor all fields in a table, set this parameter to table. If you want to monitor only a specific field, set this parameter to bigint.
	PropertyType *string `json:"PropertyType,omitempty" xml:"PropertyType,omitempty"`
	// The name of the monitoring rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The type of the monitoring rule. Valid values: 0, 1, and 2. 0 indicates that the monitoring rule is created by the system. 1 indicates that the monitoring rule is created by a user. 2 indicates that the monitoring rule is a workspace-level rule.
	RuleType    *int32  `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
	TaskSetting *string `json:"TaskSetting,omitempty" xml:"TaskSetting,omitempty"`
	// The ID of the template that is used to create the monitoring rule.
	TemplateId *int32 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The trend of the monitoring result. Valid values:
	//
	// *   up: increasing
	// *   down: decreasing
	// *   abs: absolute value
	Trend *string `json:"Trend,omitempty" xml:"Trend,omitempty"`
	// The threshold for a warning alert. The threshold indicates the deviation of the monitoring result from the expected value. You can customize this threshold based on your business requirements.
	WarningThreshold *string `json:"WarningThreshold,omitempty" xml:"WarningThreshold,omitempty"`
	// The filter condition or custom SQL statement.
	WhereCondition *string `json:"WhereCondition,omitempty" xml:"WhereCondition,omitempty"`
}

func (s CreateQualityRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateQualityRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateQualityRuleRequest) SetBlockType(v int32) *CreateQualityRuleRequest {
	s.BlockType = &v
	return s
}

func (s *CreateQualityRuleRequest) SetChecker(v int32) *CreateQualityRuleRequest {
	s.Checker = &v
	return s
}

func (s *CreateQualityRuleRequest) SetComment(v string) *CreateQualityRuleRequest {
	s.Comment = &v
	return s
}

func (s *CreateQualityRuleRequest) SetCriticalThreshold(v string) *CreateQualityRuleRequest {
	s.CriticalThreshold = &v
	return s
}

func (s *CreateQualityRuleRequest) SetEntityId(v int64) *CreateQualityRuleRequest {
	s.EntityId = &v
	return s
}

func (s *CreateQualityRuleRequest) SetExpectValue(v string) *CreateQualityRuleRequest {
	s.ExpectValue = &v
	return s
}

func (s *CreateQualityRuleRequest) SetMethodName(v string) *CreateQualityRuleRequest {
	s.MethodName = &v
	return s
}

func (s *CreateQualityRuleRequest) SetOperator(v string) *CreateQualityRuleRequest {
	s.Operator = &v
	return s
}

func (s *CreateQualityRuleRequest) SetPredictType(v int32) *CreateQualityRuleRequest {
	s.PredictType = &v
	return s
}

func (s *CreateQualityRuleRequest) SetProjectId(v int64) *CreateQualityRuleRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateQualityRuleRequest) SetProjectName(v string) *CreateQualityRuleRequest {
	s.ProjectName = &v
	return s
}

func (s *CreateQualityRuleRequest) SetProperty(v string) *CreateQualityRuleRequest {
	s.Property = &v
	return s
}

func (s *CreateQualityRuleRequest) SetPropertyType(v string) *CreateQualityRuleRequest {
	s.PropertyType = &v
	return s
}

func (s *CreateQualityRuleRequest) SetRuleName(v string) *CreateQualityRuleRequest {
	s.RuleName = &v
	return s
}

func (s *CreateQualityRuleRequest) SetRuleType(v int32) *CreateQualityRuleRequest {
	s.RuleType = &v
	return s
}

func (s *CreateQualityRuleRequest) SetTaskSetting(v string) *CreateQualityRuleRequest {
	s.TaskSetting = &v
	return s
}

func (s *CreateQualityRuleRequest) SetTemplateId(v int32) *CreateQualityRuleRequest {
	s.TemplateId = &v
	return s
}

func (s *CreateQualityRuleRequest) SetTrend(v string) *CreateQualityRuleRequest {
	s.Trend = &v
	return s
}

func (s *CreateQualityRuleRequest) SetWarningThreshold(v string) *CreateQualityRuleRequest {
	s.WarningThreshold = &v
	return s
}

func (s *CreateQualityRuleRequest) SetWhereCondition(v string) *CreateQualityRuleRequest {
	s.WhereCondition = &v
	return s
}

type CreateQualityRuleResponseBody struct {
	// The ID of the monitoring rule that you created.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateQualityRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateQualityRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateQualityRuleResponseBody) SetData(v string) *CreateQualityRuleResponseBody {
	s.Data = &v
	return s
}

func (s *CreateQualityRuleResponseBody) SetErrorCode(v string) *CreateQualityRuleResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateQualityRuleResponseBody) SetErrorMessage(v string) *CreateQualityRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateQualityRuleResponseBody) SetHttpStatusCode(v int32) *CreateQualityRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateQualityRuleResponseBody) SetRequestId(v string) *CreateQualityRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateQualityRuleResponseBody) SetSuccess(v bool) *CreateQualityRuleResponseBody {
	s.Success = &v
	return s
}

type CreateQualityRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateQualityRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateQualityRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateQualityRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateQualityRuleResponse) SetHeaders(v map[string]*string) *CreateQualityRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateQualityRuleResponse) SetStatusCode(v int32) *CreateQualityRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateQualityRuleResponse) SetBody(v *CreateQualityRuleResponseBody) *CreateQualityRuleResponse {
	s.Body = v
	return s
}

type CreateRemindRequest struct {
	// The recipient of the alert. Valid values: OWNER and OTHER. The value OWNER indicates the node owner. The value OTHER indicates a specified user.
	AlertInterval *int32 `json:"AlertInterval,omitempty" xml:"AlertInterval,omitempty"`
	// The webhook URL of the DingTalk chatbot. You can specify multiple webhook URLs. Separate the specified webhook URLs with commas (,).
	AlertMethods *string `json:"AlertMethods,omitempty" xml:"AlertMethods,omitempty"`
	// The webhook URL of the WeCom or Lark chatbot. You can specify multiple webhook URLs. Separate the specified webhook URLs with commas (,). The WEBHOOKS notification method must be specified for alertMethods.
	//
	// Only DataWorks Enterprise Edition supports this parameter.
	//
	// The webhook URL-based alerting feature is supported in the following regions: China (Shanghai), China (Chengdu), China (Zhangjiakou), China (Beijing), China (Hangzhou), China (Shenzhen), China (Hong Kong), Germany (Frankfurt), and Singapore.
	AlertTargets *string `json:"AlertTargets,omitempty" xml:"AlertTargets,omitempty"`
	// *   If the AlertUnit parameter is set to OWNER, leave this parameter empty.
	// *   If the AlertUnit parameter is set to OTHER, set this parameter to the ID of the Alibaba Cloud account used by a specific user. You can specify multiple IDs. Separate multiple IDs with commas (,). You can specify a maximum of 10 IDs.
	AlertUnit *string `json:"AlertUnit,omitempty" xml:"AlertUnit,omitempty"`
	// The ID of the workflow to which the custom alert rule is applied. This parameter takes effect when the RemindUnit parameter is set to BIZPROCESS. You can specify multiple IDs. Separate multiple IDs with commas (,). A maximum of five workflows can be specified for a custom alert rule.
	BaselineIds *string `json:"BaselineIds,omitempty" xml:"BaselineIds,omitempty"`
	// The maximum number of alerts. Valid values: 1 to 10. Default value: 3.
	BizProcessIds *string `json:"BizProcessIds,omitempty" xml:"BizProcessIds,omitempty"`
	// The notification method. Valid values:
	//
	// *   MAIL: Alert notifications are sent by emails.
	//
	// *   SMS: Alert notifications are sent by text messages.
	//
	//     Alert notifications can be sent by text messages only in the Singapore, Malaysia (Kuala Lumpur), and Germany (Frankfurt) regions.
	//
	// *   WEBHOOKS (WeCom or Lark chatbot): Alert notifications are sent by WeCom or Lark messages. If you want to use this notification method, you must configure the Webhooks parameter.
	//
	// You can specify multiple notification methods. Separate them with commas (,).
	Detail *string `json:"Detail,omitempty" xml:"Detail,omitempty"`
	// The ID of the node to which the custom alert rule is applied. This parameter takes effect when the RemindUnit parameter is set to NODE. You can specify multiple IDs. Separate multiple IDs with commas (,). A maximum of 50 nodes can be specified for a custom alert rule.
	DndEnd *string `json:"DndEnd,omitempty" xml:"DndEnd,omitempty"`
	// The details of the conditions that trigger an alert.
	//
	// *   If the RemindType parameter is set to FINISHED, leave this parameter empty.
	// *   If the RemindType parameter is set to UNFINISHED, specify this parameter as key-value pairs. Example: {"hour":23,"minu":59}. Valid values of hour: 0 to 47. Valid values of minu: 0 to 59.
	// *   If the RemindType parameter is set to ERROR, leave this parameter empty.
	// *   If the RemindType parameter is set to CYCLE_UNFINISHED, specify this parameter as key-value pairs. Example: {"1":"05:50","2":"06:50","3":"07:50","4":"08:50","5":"09:50","6":"10:50","7":"11:50","8":"12:50","9":"13:50","10":"14:50","11":"15:50","12":"16:50","13":"17:50","14":"18:50","15":"19:50","16":"20:50","17":"21:50","18":"22:50","19":"23:50","20":"24:50","21":"25:50"}. The key indicates the ID of the cycle. Valid values of the ID: 1 to 288. The value indicates the timeout period of the node that is running in the cycle. Specify the value in the hh:mm format. Valid values of hh: 0 to 47. Valid values of mm: 0 to 59.
	// *   If the RemindType parameter is set to TIMEOUT, set this parameter to the timeout period. Unit: seconds. Example: 1800. This value indicates that an alert is reported if the node has run for more than 30 minutes.
	MaxAlertTimes *int32 `json:"MaxAlertTimes,omitempty" xml:"MaxAlertTimes,omitempty"`
	// The ID of the workspace to which the custom alert rule is applied. This parameter takes effect when the RemindUnit parameter is set to PROJECT. Only one workspace can be specified for a custom alert rule.
	NodeIds *string `json:"NodeIds,omitempty" xml:"NodeIds,omitempty"`
	// The conditions that trigger an alert. Valid values: FINISHED, UNFINISHED, ERROR, CYCLE_UNFINISHED, and TIMEOUT. The value FINISHED indicates that the node is run. The value UNFINISHED indicates that the node is still running at the specified point in time. The value ERROR indicates that an error occurs when the node is running. The value CYCLE_UNFINISHED indicates that the node is still running in the specified cycle. The value TIMEOUT indicates that the node times out.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The type of the object to which the custom alert rule is applied. Valid values: NODE, BASELINE, PROJECT, and BIZPROCESS. The value NODE indicates a node. The value BASELINE indicates a baseline. The value PROJECT indicates a workspace. The value BIZPROCESS indicates a workflow.
	RemindName *string `json:"RemindName,omitempty" xml:"RemindName,omitempty"`
	// The minimum interval at which alerts are reported. Unit: seconds. Minimum value: 1200. Default value: 1800.
	RemindType *string `json:"RemindType,omitempty" xml:"RemindType,omitempty"`
	// The ID of the baseline to which the custom alert rule is applied. This parameter takes effect when the RemindUnit parameter is set to BASELINE. You can specify multiple IDs. Separate multiple IDs with commas (,). A maximum of five baselines can be specified for a custom alert rule.
	RemindUnit *string `json:"RemindUnit,omitempty" xml:"RemindUnit,omitempty"`
	// The HTTP status code returned.
	RobotUrls *string `json:"RobotUrls,omitempty" xml:"RobotUrls,omitempty"`
	// The ID of the custom alert rule returned.
	Webhooks *string `json:"Webhooks,omitempty" xml:"Webhooks,omitempty"`
}

func (s CreateRemindRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateRemindRequest) GoString() string {
	return s.String()
}

func (s *CreateRemindRequest) SetAlertInterval(v int32) *CreateRemindRequest {
	s.AlertInterval = &v
	return s
}

func (s *CreateRemindRequest) SetAlertMethods(v string) *CreateRemindRequest {
	s.AlertMethods = &v
	return s
}

func (s *CreateRemindRequest) SetAlertTargets(v string) *CreateRemindRequest {
	s.AlertTargets = &v
	return s
}

func (s *CreateRemindRequest) SetAlertUnit(v string) *CreateRemindRequest {
	s.AlertUnit = &v
	return s
}

func (s *CreateRemindRequest) SetBaselineIds(v string) *CreateRemindRequest {
	s.BaselineIds = &v
	return s
}

func (s *CreateRemindRequest) SetBizProcessIds(v string) *CreateRemindRequest {
	s.BizProcessIds = &v
	return s
}

func (s *CreateRemindRequest) SetDetail(v string) *CreateRemindRequest {
	s.Detail = &v
	return s
}

func (s *CreateRemindRequest) SetDndEnd(v string) *CreateRemindRequest {
	s.DndEnd = &v
	return s
}

func (s *CreateRemindRequest) SetMaxAlertTimes(v int32) *CreateRemindRequest {
	s.MaxAlertTimes = &v
	return s
}

func (s *CreateRemindRequest) SetNodeIds(v string) *CreateRemindRequest {
	s.NodeIds = &v
	return s
}

func (s *CreateRemindRequest) SetProjectId(v int64) *CreateRemindRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateRemindRequest) SetRemindName(v string) *CreateRemindRequest {
	s.RemindName = &v
	return s
}

func (s *CreateRemindRequest) SetRemindType(v string) *CreateRemindRequest {
	s.RemindType = &v
	return s
}

func (s *CreateRemindRequest) SetRemindUnit(v string) *CreateRemindRequest {
	s.RemindUnit = &v
	return s
}

func (s *CreateRemindRequest) SetRobotUrls(v string) *CreateRemindRequest {
	s.RobotUrls = &v
	return s
}

func (s *CreateRemindRequest) SetWebhooks(v string) *CreateRemindRequest {
	s.Webhooks = &v
	return s
}

type CreateRemindResponseBody struct {
	// The ID of the request. You can use the ID to troubleshoot issues.
	Data      *int64  `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The error message returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error code returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateRemindResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateRemindResponseBody) GoString() string {
	return s.String()
}

func (s *CreateRemindResponseBody) SetData(v int64) *CreateRemindResponseBody {
	s.Data = &v
	return s
}

func (s *CreateRemindResponseBody) SetErrorCode(v string) *CreateRemindResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateRemindResponseBody) SetErrorMessage(v string) *CreateRemindResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateRemindResponseBody) SetHttpStatusCode(v int32) *CreateRemindResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateRemindResponseBody) SetRequestId(v string) *CreateRemindResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateRemindResponseBody) SetSuccess(v bool) *CreateRemindResponseBody {
	s.Success = &v
	return s
}

type CreateRemindResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateRemindResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateRemindResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateRemindResponse) GoString() string {
	return s.String()
}

func (s *CreateRemindResponse) SetHeaders(v map[string]*string) *CreateRemindResponse {
	s.Headers = v
	return s
}

func (s *CreateRemindResponse) SetStatusCode(v int32) *CreateRemindResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateRemindResponse) SetBody(v *CreateRemindResponseBody) *CreateRemindResponse {
	s.Body = v
	return s
}

type CreateResourceFileRequest struct {
	Content              *string `json:"Content,omitempty" xml:"Content,omitempty"`
	FileDescription      *string `json:"FileDescription,omitempty" xml:"FileDescription,omitempty"`
	FileFolderPath       *string `json:"FileFolderPath,omitempty" xml:"FileFolderPath,omitempty"`
	FileName             *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	FileType             *int32  `json:"FileType,omitempty" xml:"FileType,omitempty"`
	OriginResourceName   *string `json:"OriginResourceName,omitempty" xml:"OriginResourceName,omitempty"`
	Owner                *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	ProjectId            *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	RegisterToCalcEngine *bool   `json:"RegisterToCalcEngine,omitempty" xml:"RegisterToCalcEngine,omitempty"`
	ResourceFile         *string `json:"ResourceFile,omitempty" xml:"ResourceFile,omitempty"`
	StorageURL           *string `json:"StorageURL,omitempty" xml:"StorageURL,omitempty"`
	UploadMode           *bool   `json:"UploadMode,omitempty" xml:"UploadMode,omitempty"`
}

func (s CreateResourceFileRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateResourceFileRequest) GoString() string {
	return s.String()
}

func (s *CreateResourceFileRequest) SetContent(v string) *CreateResourceFileRequest {
	s.Content = &v
	return s
}

func (s *CreateResourceFileRequest) SetFileDescription(v string) *CreateResourceFileRequest {
	s.FileDescription = &v
	return s
}

func (s *CreateResourceFileRequest) SetFileFolderPath(v string) *CreateResourceFileRequest {
	s.FileFolderPath = &v
	return s
}

func (s *CreateResourceFileRequest) SetFileName(v string) *CreateResourceFileRequest {
	s.FileName = &v
	return s
}

func (s *CreateResourceFileRequest) SetFileType(v int32) *CreateResourceFileRequest {
	s.FileType = &v
	return s
}

func (s *CreateResourceFileRequest) SetOriginResourceName(v string) *CreateResourceFileRequest {
	s.OriginResourceName = &v
	return s
}

func (s *CreateResourceFileRequest) SetOwner(v string) *CreateResourceFileRequest {
	s.Owner = &v
	return s
}

func (s *CreateResourceFileRequest) SetProjectId(v int64) *CreateResourceFileRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateResourceFileRequest) SetRegisterToCalcEngine(v bool) *CreateResourceFileRequest {
	s.RegisterToCalcEngine = &v
	return s
}

func (s *CreateResourceFileRequest) SetResourceFile(v string) *CreateResourceFileRequest {
	s.ResourceFile = &v
	return s
}

func (s *CreateResourceFileRequest) SetStorageURL(v string) *CreateResourceFileRequest {
	s.StorageURL = &v
	return s
}

func (s *CreateResourceFileRequest) SetUploadMode(v bool) *CreateResourceFileRequest {
	s.UploadMode = &v
	return s
}

type CreateResourceFileAdvanceRequest struct {
	Content              *string   `json:"Content,omitempty" xml:"Content,omitempty"`
	FileDescription      *string   `json:"FileDescription,omitempty" xml:"FileDescription,omitempty"`
	FileFolderPath       *string   `json:"FileFolderPath,omitempty" xml:"FileFolderPath,omitempty"`
	FileName             *string   `json:"FileName,omitempty" xml:"FileName,omitempty"`
	FileType             *int32    `json:"FileType,omitempty" xml:"FileType,omitempty"`
	OriginResourceName   *string   `json:"OriginResourceName,omitempty" xml:"OriginResourceName,omitempty"`
	Owner                *string   `json:"Owner,omitempty" xml:"Owner,omitempty"`
	ProjectId            *int64    `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	RegisterToCalcEngine *bool     `json:"RegisterToCalcEngine,omitempty" xml:"RegisterToCalcEngine,omitempty"`
	ResourceFileObject   io.Reader `json:"ResourceFile,omitempty" xml:"ResourceFile,omitempty"`
	StorageURL           *string   `json:"StorageURL,omitempty" xml:"StorageURL,omitempty"`
	UploadMode           *bool     `json:"UploadMode,omitempty" xml:"UploadMode,omitempty"`
}

func (s CreateResourceFileAdvanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateResourceFileAdvanceRequest) GoString() string {
	return s.String()
}

func (s *CreateResourceFileAdvanceRequest) SetContent(v string) *CreateResourceFileAdvanceRequest {
	s.Content = &v
	return s
}

func (s *CreateResourceFileAdvanceRequest) SetFileDescription(v string) *CreateResourceFileAdvanceRequest {
	s.FileDescription = &v
	return s
}

func (s *CreateResourceFileAdvanceRequest) SetFileFolderPath(v string) *CreateResourceFileAdvanceRequest {
	s.FileFolderPath = &v
	return s
}

func (s *CreateResourceFileAdvanceRequest) SetFileName(v string) *CreateResourceFileAdvanceRequest {
	s.FileName = &v
	return s
}

func (s *CreateResourceFileAdvanceRequest) SetFileType(v int32) *CreateResourceFileAdvanceRequest {
	s.FileType = &v
	return s
}

func (s *CreateResourceFileAdvanceRequest) SetOriginResourceName(v string) *CreateResourceFileAdvanceRequest {
	s.OriginResourceName = &v
	return s
}

func (s *CreateResourceFileAdvanceRequest) SetOwner(v string) *CreateResourceFileAdvanceRequest {
	s.Owner = &v
	return s
}

func (s *CreateResourceFileAdvanceRequest) SetProjectId(v int64) *CreateResourceFileAdvanceRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateResourceFileAdvanceRequest) SetRegisterToCalcEngine(v bool) *CreateResourceFileAdvanceRequest {
	s.RegisterToCalcEngine = &v
	return s
}

func (s *CreateResourceFileAdvanceRequest) SetResourceFileObject(v io.Reader) *CreateResourceFileAdvanceRequest {
	s.ResourceFileObject = v
	return s
}

func (s *CreateResourceFileAdvanceRequest) SetStorageURL(v string) *CreateResourceFileAdvanceRequest {
	s.StorageURL = &v
	return s
}

func (s *CreateResourceFileAdvanceRequest) SetUploadMode(v bool) *CreateResourceFileAdvanceRequest {
	s.UploadMode = &v
	return s
}

type CreateResourceFileResponseBody struct {
	Data      *int64  `json:"Data,omitempty" xml:"Data,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s CreateResourceFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateResourceFileResponseBody) GoString() string {
	return s.String()
}

func (s *CreateResourceFileResponseBody) SetData(v int64) *CreateResourceFileResponseBody {
	s.Data = &v
	return s
}

func (s *CreateResourceFileResponseBody) SetRequestId(v string) *CreateResourceFileResponseBody {
	s.RequestId = &v
	return s
}

type CreateResourceFileResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateResourceFileResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateResourceFileResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateResourceFileResponse) GoString() string {
	return s.String()
}

func (s *CreateResourceFileResponse) SetHeaders(v map[string]*string) *CreateResourceFileResponse {
	s.Headers = v
	return s
}

func (s *CreateResourceFileResponse) SetStatusCode(v int32) *CreateResourceFileResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateResourceFileResponse) SetBody(v *CreateResourceFileResponseBody) *CreateResourceFileResponse {
	s.Body = v
	return s
}

type CreateTableRequest struct {
	// The comment.
	AppGuid *string `json:"AppGuid,omitempty" xml:"AppGuid,omitempty"`
	// The ID of the logical level.
	CategoryId *int64 `json:"CategoryId,omitempty" xml:"CategoryId,omitempty"`
	// The schema information of the table. You need to enter the schema information of the table if you enable the table schema in MaxCompute.
	ClientToken *string                      `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	Columns     []*CreateTableRequestColumns `json:"Columns,omitempty" xml:"Columns,omitempty" type:"Repeated"`
	// Specifies whether the MaxCompute table is a partitioned table. Valid values: 1 and 0. The value 1 indicates that the MaxCompute table is a partitioned table. The value 0 indicates that the MaxCompute table is not a partitioned table. This parameter is deprecated. Do not use this parameter.
	//
	// The Column.N.isPartitionCol parameter is used to specify whether the MaxCompute table is a partitioned table. If the Column.N.isPartitionCol parameter is set to true, the MaxCompute table is a partitioned table.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The environment of the DataWorks workspace. Valid values:
	//
	// *   0: development environment
	// *   1: production environment
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The globally unique identifier (GUID) of the MaxCompute project. Specify the GUID in the odps.{projectName} format.
	EnvType *int32 `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The storage location of the external table.
	ExternalTableType *string `json:"ExternalTableType,omitempty" xml:"ExternalTableType,omitempty"`
	// A reserved parameter.
	HasPart *int32 `json:"HasPart,omitempty" xml:"HasPart,omitempty"`
	// Specifies whether the table or workspace is visible:
	//
	// *   0: Both the table and workspace are not visible.
	// *   1: The table and workspace are visible.
	// *   2: Only the workspace is visible.
	IsView *int32 `json:"IsView,omitempty" xml:"IsView,omitempty"`
	// The ID of the associated category. You can call the [GetMetaCategory](~~173932~~) operation to query the ID of the category that can be associated.
	LifeCycle *int32 `json:"LifeCycle,omitempty" xml:"LifeCycle,omitempty"`
	// The ID of the DataWorks workspace.
	Location *string `json:"Location,omitempty" xml:"Location,omitempty"`
	// The ID of the physical level.
	LogicalLevelId *int64  `json:"LogicalLevelId,omitempty" xml:"LogicalLevelId,omitempty"`
	OwnerId        *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The storage type of the external table. Valid values:
	//
	// *   0: Object Storage Service (OSS)
	// *   1: Tablestore
	// *   2: Volume
	// *   3: MySQL
	PhysicsLevelId *int64 `json:"PhysicsLevelId,omitempty" xml:"PhysicsLevelId,omitempty"`
	// The name of the table.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The display name of the field.
	Schema *string `json:"Schema,omitempty" xml:"Schema,omitempty"`
	// The endpoint of MaxCompute.
	TableName *string                     `json:"TableName,omitempty" xml:"TableName,omitempty"`
	Themes    []*CreateTableRequestThemes `json:"Themes,omitempty" xml:"Themes,omitempty" type:"Repeated"`
	// The lifecycle of the table. Unit: days. By default, this parameter is left empty, which indicates that the table is permanently stored.
	Visibility *int32 `json:"Visibility,omitempty" xml:"Visibility,omitempty"`
}

func (s CreateTableRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTableRequest) GoString() string {
	return s.String()
}

func (s *CreateTableRequest) SetAppGuid(v string) *CreateTableRequest {
	s.AppGuid = &v
	return s
}

func (s *CreateTableRequest) SetCategoryId(v int64) *CreateTableRequest {
	s.CategoryId = &v
	return s
}

func (s *CreateTableRequest) SetClientToken(v string) *CreateTableRequest {
	s.ClientToken = &v
	return s
}

func (s *CreateTableRequest) SetColumns(v []*CreateTableRequestColumns) *CreateTableRequest {
	s.Columns = v
	return s
}

func (s *CreateTableRequest) SetComment(v string) *CreateTableRequest {
	s.Comment = &v
	return s
}

func (s *CreateTableRequest) SetEndpoint(v string) *CreateTableRequest {
	s.Endpoint = &v
	return s
}

func (s *CreateTableRequest) SetEnvType(v int32) *CreateTableRequest {
	s.EnvType = &v
	return s
}

func (s *CreateTableRequest) SetExternalTableType(v string) *CreateTableRequest {
	s.ExternalTableType = &v
	return s
}

func (s *CreateTableRequest) SetHasPart(v int32) *CreateTableRequest {
	s.HasPart = &v
	return s
}

func (s *CreateTableRequest) SetIsView(v int32) *CreateTableRequest {
	s.IsView = &v
	return s
}

func (s *CreateTableRequest) SetLifeCycle(v int32) *CreateTableRequest {
	s.LifeCycle = &v
	return s
}

func (s *CreateTableRequest) SetLocation(v string) *CreateTableRequest {
	s.Location = &v
	return s
}

func (s *CreateTableRequest) SetLogicalLevelId(v int64) *CreateTableRequest {
	s.LogicalLevelId = &v
	return s
}

func (s *CreateTableRequest) SetOwnerId(v string) *CreateTableRequest {
	s.OwnerId = &v
	return s
}

func (s *CreateTableRequest) SetPhysicsLevelId(v int64) *CreateTableRequest {
	s.PhysicsLevelId = &v
	return s
}

func (s *CreateTableRequest) SetProjectId(v int64) *CreateTableRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateTableRequest) SetSchema(v string) *CreateTableRequest {
	s.Schema = &v
	return s
}

func (s *CreateTableRequest) SetTableName(v string) *CreateTableRequest {
	s.TableName = &v
	return s
}

func (s *CreateTableRequest) SetThemes(v []*CreateTableRequestThemes) *CreateTableRequest {
	s.Themes = v
	return s
}

func (s *CreateTableRequest) SetVisibility(v int32) *CreateTableRequest {
	s.Visibility = &v
	return s
}

type CreateTableRequestColumns struct {
	// The comment of the field.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The name of the field.
	//
	// You can call the CreateTable operation to configure a maximum of 1,000 fields.
	ColumnNameCn *string `json:"ColumnNameCn,omitempty" xml:"ColumnNameCn,omitempty"`
	// The sequence number of the field. You can use this parameter to specify how fields are sorted in a table. By default, fields are sorted in the order in which requests are created.
	//
	// If the field is a partition field, this parameter is not supported.
	ColumnType *string `json:"ColumnType,omitempty" xml:"ColumnType,omitempty"`
	// The data type of the field.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ID of the topic.
	IsPartitionCol *bool `json:"IsPartitionCol,omitempty" xml:"IsPartitionCol,omitempty"`
	// Specifies whether the current field is a partition field.
	Length *int32 `json:"Length,omitempty" xml:"Length,omitempty"`
	// The length of the field. For more information, see [MaxCompute V2.0 data type edition](~~159541#concept-2454988~~).
	SeqNumber *int32 `json:"SeqNumber,omitempty" xml:"SeqNumber,omitempty"`
}

func (s CreateTableRequestColumns) String() string {
	return tea.Prettify(s)
}

func (s CreateTableRequestColumns) GoString() string {
	return s.String()
}

func (s *CreateTableRequestColumns) SetColumnName(v string) *CreateTableRequestColumns {
	s.ColumnName = &v
	return s
}

func (s *CreateTableRequestColumns) SetColumnNameCn(v string) *CreateTableRequestColumns {
	s.ColumnNameCn = &v
	return s
}

func (s *CreateTableRequestColumns) SetColumnType(v string) *CreateTableRequestColumns {
	s.ColumnType = &v
	return s
}

func (s *CreateTableRequestColumns) SetComment(v string) *CreateTableRequestColumns {
	s.Comment = &v
	return s
}

func (s *CreateTableRequestColumns) SetIsPartitionCol(v bool) *CreateTableRequestColumns {
	s.IsPartitionCol = &v
	return s
}

func (s *CreateTableRequestColumns) SetLength(v int32) *CreateTableRequestColumns {
	s.Length = &v
	return s
}

func (s *CreateTableRequestColumns) SetSeqNumber(v int32) *CreateTableRequestColumns {
	s.SeqNumber = &v
	return s
}

type CreateTableRequestThemes struct {
	// The level that corresponds to the topic ID.
	ThemeId *int64 `json:"ThemeId,omitempty" xml:"ThemeId,omitempty"`
	// The ID of the request.
	ThemeLevel *int32 `json:"ThemeLevel,omitempty" xml:"ThemeLevel,omitempty"`
}

func (s CreateTableRequestThemes) String() string {
	return tea.Prettify(s)
}

func (s CreateTableRequestThemes) GoString() string {
	return s.String()
}

func (s *CreateTableRequestThemes) SetThemeId(v int64) *CreateTableRequestThemes {
	s.ThemeId = &v
	return s
}

func (s *CreateTableRequestThemes) SetThemeLevel(v int32) *CreateTableRequestThemes {
	s.ThemeLevel = &v
	return s
}

type CreateTableResponseBody struct {
	// The information about the request task.
	//
	// After a request task is submitted, it is divided into multiple subtasks that are run in sequence. After the current subtask is complete, the next subtask starts to run. After all subtasks are complete, the request task is complete.
	//
	// If a request task is aborted due to one of the following issues, address the issue based on the error code and initiate the request task again:
	//
	// *   The request task fails to be submitted.
	// *   After the request task is submitted, a subtask fails to run.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the current subtask. Valid values:
	//
	// *   operating: The subtask is running.
	// *   success: The subtask succeeds.
	// *   failure: The subtask fails to run. For more information about the error details, see the Content parameter.
	TaskInfo *CreateTableResponseBodyTaskInfo `json:"TaskInfo,omitempty" xml:"TaskInfo,omitempty" type:"Struct"`
}

func (s CreateTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTableResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTableResponseBody) SetRequestId(v string) *CreateTableResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTableResponseBody) SetTaskInfo(v *CreateTableResponseBodyTaskInfo) *CreateTableResponseBody {
	s.TaskInfo = v
	return s
}

type CreateTableResponseBodyTaskInfo struct {
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the current subtask.
	NextTaskId *string `json:"NextTaskId,omitempty" xml:"NextTaskId,omitempty"`
	// The ID of the subtask that you want to run. If this parameter is left empty, all subtasks are complete. You can call the [GetDDLJobStatus](~~185659~~) operation to query the status of the subtask based on the subtask ID.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Details about the status of the current subtask.
	//
	// *   If the current subtask succeeds, success is returned.
	// *   If the current subtask fails, the error details are displayed.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s CreateTableResponseBodyTaskInfo) String() string {
	return tea.Prettify(s)
}

func (s CreateTableResponseBodyTaskInfo) GoString() string {
	return s.String()
}

func (s *CreateTableResponseBodyTaskInfo) SetContent(v string) *CreateTableResponseBodyTaskInfo {
	s.Content = &v
	return s
}

func (s *CreateTableResponseBodyTaskInfo) SetNextTaskId(v string) *CreateTableResponseBodyTaskInfo {
	s.NextTaskId = &v
	return s
}

func (s *CreateTableResponseBodyTaskInfo) SetStatus(v string) *CreateTableResponseBodyTaskInfo {
	s.Status = &v
	return s
}

func (s *CreateTableResponseBodyTaskInfo) SetTaskId(v string) *CreateTableResponseBodyTaskInfo {
	s.TaskId = &v
	return s
}

type CreateTableResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateTableResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateTableResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTableResponse) GoString() string {
	return s.String()
}

func (s *CreateTableResponse) SetHeaders(v map[string]*string) *CreateTableResponse {
	s.Headers = v
	return s
}

func (s *CreateTableResponse) SetStatusCode(v int32) *CreateTableResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTableResponse) SetBody(v *CreateTableResponseBody) *CreateTableResponse {
	s.Body = v
	return s
}

type CreateTableLevelRequest struct {
	// Level Description
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the region where the service is activated.
	LevelType *int32 `json:"LevelType,omitempty" xml:"LevelType,omitempty"`
	// Level 1
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the table level. Valid values: 1 and 2. A value of 1 indicates the logical level. A value of 2 indicates the physical level.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s CreateTableLevelRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTableLevelRequest) GoString() string {
	return s.String()
}

func (s *CreateTableLevelRequest) SetDescription(v string) *CreateTableLevelRequest {
	s.Description = &v
	return s
}

func (s *CreateTableLevelRequest) SetLevelType(v int32) *CreateTableLevelRequest {
	s.LevelType = &v
	return s
}

func (s *CreateTableLevelRequest) SetName(v string) *CreateTableLevelRequest {
	s.Name = &v
	return s
}

func (s *CreateTableLevelRequest) SetProjectId(v int64) *CreateTableLevelRequest {
	s.ProjectId = &v
	return s
}

type CreateTableLevelResponseBody struct {
	// Indicates whether the request is successful.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error code returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	LevelId        *int64 `json:"LevelId,omitempty" xml:"LevelId,omitempty"`
	// 1AAE721C-F9EC-5923-BAFC-99802C4E0F21
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the table level.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateTableLevelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTableLevelResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTableLevelResponseBody) SetErrorCode(v string) *CreateTableLevelResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateTableLevelResponseBody) SetErrorMessage(v string) *CreateTableLevelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateTableLevelResponseBody) SetHttpStatusCode(v int32) *CreateTableLevelResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateTableLevelResponseBody) SetLevelId(v int64) *CreateTableLevelResponseBody {
	s.LevelId = &v
	return s
}

func (s *CreateTableLevelResponseBody) SetRequestId(v string) *CreateTableLevelResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTableLevelResponseBody) SetSuccess(v bool) *CreateTableLevelResponseBody {
	s.Success = &v
	return s
}

type CreateTableLevelResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateTableLevelResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateTableLevelResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTableLevelResponse) GoString() string {
	return s.String()
}

func (s *CreateTableLevelResponse) SetHeaders(v map[string]*string) *CreateTableLevelResponse {
	s.Headers = v
	return s
}

func (s *CreateTableLevelResponse) SetStatusCode(v int32) *CreateTableLevelResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTableLevelResponse) SetBody(v *CreateTableLevelResponseBody) *CreateTableLevelResponse {
	s.Body = v
	return s
}

type CreateTableThemeRequest struct {
	// The level of the table folder. Valid values: 1 and 2. A value of 1 indicates a first-level table folder. A value of 2 indicates a second-level table folder.
	Level *int32 `json:"Level,omitempty" xml:"Level,omitempty"`
	// The name of the table folder.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the level of the parent table folder.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The ID of the DataWorks workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s CreateTableThemeRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTableThemeRequest) GoString() string {
	return s.String()
}

func (s *CreateTableThemeRequest) SetLevel(v int32) *CreateTableThemeRequest {
	s.Level = &v
	return s
}

func (s *CreateTableThemeRequest) SetName(v string) *CreateTableThemeRequest {
	s.Name = &v
	return s
}

func (s *CreateTableThemeRequest) SetParentId(v int64) *CreateTableThemeRequest {
	s.ParentId = &v
	return s
}

func (s *CreateTableThemeRequest) SetProjectId(v int64) *CreateTableThemeRequest {
	s.ProjectId = &v
	return s
}

type CreateTableThemeResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The ID of the created table folder.
	ThemeId *int64 `json:"ThemeId,omitempty" xml:"ThemeId,omitempty"`
}

func (s CreateTableThemeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTableThemeResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTableThemeResponseBody) SetErrorCode(v string) *CreateTableThemeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateTableThemeResponseBody) SetErrorMessage(v string) *CreateTableThemeResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateTableThemeResponseBody) SetHttpStatusCode(v int32) *CreateTableThemeResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateTableThemeResponseBody) SetRequestId(v string) *CreateTableThemeResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTableThemeResponseBody) SetSuccess(v bool) *CreateTableThemeResponseBody {
	s.Success = &v
	return s
}

func (s *CreateTableThemeResponseBody) SetThemeId(v int64) *CreateTableThemeResponseBody {
	s.ThemeId = &v
	return s
}

type CreateTableThemeResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateTableThemeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateTableThemeResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTableThemeResponse) GoString() string {
	return s.String()
}

func (s *CreateTableThemeResponse) SetHeaders(v map[string]*string) *CreateTableThemeResponse {
	s.Headers = v
	return s
}

func (s *CreateTableThemeResponse) SetStatusCode(v int32) *CreateTableThemeResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTableThemeResponse) SetBody(v *CreateTableThemeResponseBody) *CreateTableThemeResponse {
	s.Body = v
	return s
}

type CreateUdfFileRequest struct {
	// The name of the class in which the function is defined. This parameter corresponds to the Class Name parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
	ClassName *string `json:"ClassName,omitempty" xml:"ClassName,omitempty"`
	// The syntax used for calling the function. This parameter corresponds to the Expression Syntax parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
	CmdDescription          *string `json:"CmdDescription,omitempty" xml:"CmdDescription,omitempty"`
	CreateFolderIfNotExists *bool   `json:"CreateFolderIfNotExists,omitempty" xml:"CreateFolderIfNotExists,omitempty"`
	// The example for calling the function. This parameter corresponds to the Example parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
	Example *string `json:"Example,omitempty" xml:"Example,omitempty"`
	// The path of the folder in which the file for the function is stored.
	FileFolderPath *string `json:"FileFolderPath,omitempty" xml:"FileFolderPath,omitempty"`
	// The name of the file for the function.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The type of the function. Valid values: MATH, AGGREGATE, STRING, DATE, ANALYTIC, and OTHER. This parameter corresponds to the Function Type parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
	FunctionType *string `json:"FunctionType,omitempty" xml:"FunctionType,omitempty"`
	// The description of the input parameters of the function. This parameter corresponds to the Parameter Description parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The ID of the DataWorks workspace. You can click the Workspace Manage icon in the upper-right corner of the DataStudio page to go to the Workspace Management page and view the workspace ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The unique identifier of the DataWorks workspace. You can click the identifier in the upper-left corner of the DataStudio page to switch to another workspace.
	//
	// You must specify either this parameter or the projectId parameter to determine the DataWorks workspace to which the operation is called.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
	// The names of the resources that are referenced by the function. This parameter corresponds to the Resources parameter in the Register Function section of the configuration tab of the function in the DataWorks console. Multiple resource names are separated by commas (,).
	Resources *string `json:"Resources,omitempty" xml:"Resources,omitempty"`
	// The description of the return value of the function. This parameter corresponds to the Return Value parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
	ReturnValue *string `json:"ReturnValue,omitempty" xml:"ReturnValue,omitempty"`
	// The description of the function. This parameter corresponds to the Description parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
	UdfDescription *string `json:"UdfDescription,omitempty" xml:"UdfDescription,omitempty"`
}

func (s CreateUdfFileRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateUdfFileRequest) GoString() string {
	return s.String()
}

func (s *CreateUdfFileRequest) SetClassName(v string) *CreateUdfFileRequest {
	s.ClassName = &v
	return s
}

func (s *CreateUdfFileRequest) SetCmdDescription(v string) *CreateUdfFileRequest {
	s.CmdDescription = &v
	return s
}

func (s *CreateUdfFileRequest) SetCreateFolderIfNotExists(v bool) *CreateUdfFileRequest {
	s.CreateFolderIfNotExists = &v
	return s
}

func (s *CreateUdfFileRequest) SetExample(v string) *CreateUdfFileRequest {
	s.Example = &v
	return s
}

func (s *CreateUdfFileRequest) SetFileFolderPath(v string) *CreateUdfFileRequest {
	s.FileFolderPath = &v
	return s
}

func (s *CreateUdfFileRequest) SetFileName(v string) *CreateUdfFileRequest {
	s.FileName = &v
	return s
}

func (s *CreateUdfFileRequest) SetFunctionType(v string) *CreateUdfFileRequest {
	s.FunctionType = &v
	return s
}

func (s *CreateUdfFileRequest) SetParameterDescription(v string) *CreateUdfFileRequest {
	s.ParameterDescription = &v
	return s
}

func (s *CreateUdfFileRequest) SetProjectId(v int64) *CreateUdfFileRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateUdfFileRequest) SetProjectIdentifier(v string) *CreateUdfFileRequest {
	s.ProjectIdentifier = &v
	return s
}

func (s *CreateUdfFileRequest) SetResources(v string) *CreateUdfFileRequest {
	s.Resources = &v
	return s
}

func (s *CreateUdfFileRequest) SetReturnValue(v string) *CreateUdfFileRequest {
	s.ReturnValue = &v
	return s
}

func (s *CreateUdfFileRequest) SetUdfDescription(v string) *CreateUdfFileRequest {
	s.UdfDescription = &v
	return s
}

type CreateUdfFileResponseBody struct {
	// The ID of the file that was created.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateUdfFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateUdfFileResponseBody) GoString() string {
	return s.String()
}

func (s *CreateUdfFileResponseBody) SetData(v int64) *CreateUdfFileResponseBody {
	s.Data = &v
	return s
}

func (s *CreateUdfFileResponseBody) SetErrorCode(v string) *CreateUdfFileResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *CreateUdfFileResponseBody) SetErrorMessage(v string) *CreateUdfFileResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateUdfFileResponseBody) SetHttpStatusCode(v int32) *CreateUdfFileResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *CreateUdfFileResponseBody) SetRequestId(v string) *CreateUdfFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateUdfFileResponseBody) SetSuccess(v bool) *CreateUdfFileResponseBody {
	s.Success = &v
	return s
}

type CreateUdfFileResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *CreateUdfFileResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s CreateUdfFileResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateUdfFileResponse) GoString() string {
	return s.String()
}

func (s *CreateUdfFileResponse) SetHeaders(v map[string]*string) *CreateUdfFileResponse {
	s.Headers = v
	return s
}

func (s *CreateUdfFileResponse) SetStatusCode(v int32) *CreateUdfFileResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateUdfFileResponse) SetBody(v *CreateUdfFileResponseBody) *CreateUdfFileResponse {
	s.Body = v
	return s
}

type DeleteBaselineRequest struct {
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	ProjectId  *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s DeleteBaselineRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBaselineRequest) GoString() string {
	return s.String()
}

func (s *DeleteBaselineRequest) SetBaselineId(v int64) *DeleteBaselineRequest {
	s.BaselineId = &v
	return s
}

func (s *DeleteBaselineRequest) SetProjectId(v int64) *DeleteBaselineRequest {
	s.ProjectId = &v
	return s
}

type DeleteBaselineResponseBody struct {
	Data           *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteBaselineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteBaselineResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteBaselineResponseBody) SetData(v bool) *DeleteBaselineResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteBaselineResponseBody) SetErrorCode(v string) *DeleteBaselineResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteBaselineResponseBody) SetErrorMessage(v string) *DeleteBaselineResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteBaselineResponseBody) SetHttpStatusCode(v int32) *DeleteBaselineResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteBaselineResponseBody) SetRequestId(v string) *DeleteBaselineResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteBaselineResponseBody) SetSuccess(v bool) *DeleteBaselineResponseBody {
	s.Success = &v
	return s
}

type DeleteBaselineResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteBaselineResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteBaselineResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteBaselineResponse) GoString() string {
	return s.String()
}

func (s *DeleteBaselineResponse) SetHeaders(v map[string]*string) *DeleteBaselineResponse {
	s.Headers = v
	return s
}

func (s *DeleteBaselineResponse) SetStatusCode(v int32) *DeleteBaselineResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteBaselineResponse) SetBody(v *DeleteBaselineResponseBody) *DeleteBaselineResponse {
	s.Body = v
	return s
}

type DeleteBusinessRequest struct {
	// The ID of the workflow. You can call the [ListBusiness](~~173945~~) operation to query the workflow ID.
	BusinessId *int64 `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID. You must specify either this parameter or ProjectIdentifier to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Settings panel to obtain the name. You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s DeleteBusinessRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteBusinessRequest) GoString() string {
	return s.String()
}

func (s *DeleteBusinessRequest) SetBusinessId(v int64) *DeleteBusinessRequest {
	s.BusinessId = &v
	return s
}

func (s *DeleteBusinessRequest) SetProjectId(v int64) *DeleteBusinessRequest {
	s.ProjectId = &v
	return s
}

func (s *DeleteBusinessRequest) SetProjectIdentifier(v string) *DeleteBusinessRequest {
	s.ProjectIdentifier = &v
	return s
}

type DeleteBusinessResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteBusinessResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteBusinessResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteBusinessResponseBody) SetErrorCode(v string) *DeleteBusinessResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteBusinessResponseBody) SetErrorMessage(v string) *DeleteBusinessResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteBusinessResponseBody) SetHttpStatusCode(v int32) *DeleteBusinessResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteBusinessResponseBody) SetRequestId(v string) *DeleteBusinessResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteBusinessResponseBody) SetSuccess(v bool) *DeleteBusinessResponseBody {
	s.Success = &v
	return s
}

type DeleteBusinessResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteBusinessResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteBusinessResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteBusinessResponse) GoString() string {
	return s.String()
}

func (s *DeleteBusinessResponse) SetHeaders(v map[string]*string) *DeleteBusinessResponse {
	s.Headers = v
	return s
}

func (s *DeleteBusinessResponse) SetStatusCode(v int32) *DeleteBusinessResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteBusinessResponse) SetBody(v *DeleteBusinessResponseBody) *DeleteBusinessResponse {
	s.Body = v
	return s
}

type DeleteConnectionRequest struct {
	ConnectionId *int64 `json:"ConnectionId,omitempty" xml:"ConnectionId,omitempty"`
}

func (s DeleteConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteConnectionRequest) GoString() string {
	return s.String()
}

func (s *DeleteConnectionRequest) SetConnectionId(v int64) *DeleteConnectionRequest {
	s.ConnectionId = &v
	return s
}

type DeleteConnectionResponseBody struct {
	Data           *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	HttpStatusCode *string `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteConnectionResponseBody) SetData(v bool) *DeleteConnectionResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteConnectionResponseBody) SetHttpStatusCode(v string) *DeleteConnectionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteConnectionResponseBody) SetRequestId(v string) *DeleteConnectionResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteConnectionResponseBody) SetSuccess(v bool) *DeleteConnectionResponseBody {
	s.Success = &v
	return s
}

type DeleteConnectionResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteConnectionResponse) GoString() string {
	return s.String()
}

func (s *DeleteConnectionResponse) SetHeaders(v map[string]*string) *DeleteConnectionResponse {
	s.Headers = v
	return s
}

func (s *DeleteConnectionResponse) SetStatusCode(v int32) *DeleteConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteConnectionResponse) SetBody(v *DeleteConnectionResponseBody) *DeleteConnectionResponse {
	s.Body = v
	return s
}

type DeleteDIAlarmRuleRequest struct {
	DIAlarmRuleId *int64 `json:"DIAlarmRuleId,omitempty" xml:"DIAlarmRuleId,omitempty"`
}

func (s DeleteDIAlarmRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDIAlarmRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteDIAlarmRuleRequest) SetDIAlarmRuleId(v int64) *DeleteDIAlarmRuleRequest {
	s.DIAlarmRuleId = &v
	return s
}

type DeleteDIAlarmRuleResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDIAlarmRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDIAlarmRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDIAlarmRuleResponseBody) SetRequestId(v string) *DeleteDIAlarmRuleResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDIAlarmRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteDIAlarmRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteDIAlarmRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDIAlarmRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteDIAlarmRuleResponse) SetHeaders(v map[string]*string) *DeleteDIAlarmRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteDIAlarmRuleResponse) SetStatusCode(v int32) *DeleteDIAlarmRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDIAlarmRuleResponse) SetBody(v *DeleteDIAlarmRuleResponseBody) *DeleteDIAlarmRuleResponse {
	s.Body = v
	return s
}

type DeleteDIJobRequest struct {
	DIJobId *int64 `json:"DIJobId,omitempty" xml:"DIJobId,omitempty"`
}

func (s DeleteDIJobRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDIJobRequest) GoString() string {
	return s.String()
}

func (s *DeleteDIJobRequest) SetDIJobId(v int64) *DeleteDIJobRequest {
	s.DIJobId = &v
	return s
}

type DeleteDIJobResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteDIJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDIJobResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDIJobResponseBody) SetRequestId(v string) *DeleteDIJobResponseBody {
	s.RequestId = &v
	return s
}

type DeleteDIJobResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteDIJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteDIJobResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDIJobResponse) GoString() string {
	return s.String()
}

func (s *DeleteDIJobResponse) SetHeaders(v map[string]*string) *DeleteDIJobResponse {
	s.Headers = v
	return s
}

func (s *DeleteDIJobResponse) SetStatusCode(v int32) *DeleteDIJobResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDIJobResponse) SetBody(v *DeleteDIJobResponseBody) *DeleteDIJobResponse {
	s.Body = v
	return s
}

type DeleteDISyncTaskRequest struct {
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request failed.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The type of the synchronization node in Data Integration.
	//
	// The parameter value is DI_REALTIME and cannot be changed. The value indicates a real-time synchronization node.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the real-time synchronization node. You can call the [ListFiles](~~173942~~) operation to query the ID of the node.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s DeleteDISyncTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDISyncTaskRequest) GoString() string {
	return s.String()
}

func (s *DeleteDISyncTaskRequest) SetFileId(v int64) *DeleteDISyncTaskRequest {
	s.FileId = &v
	return s
}

func (s *DeleteDISyncTaskRequest) SetProjectId(v int64) *DeleteDISyncTaskRequest {
	s.ProjectId = &v
	return s
}

func (s *DeleteDISyncTaskRequest) SetTaskType(v string) *DeleteDISyncTaskRequest {
	s.TaskType = &v
	return s
}

type DeleteDISyncTaskResponseBody struct {
	// Indicates whether the synchronization node in Data Integration is deleted. Valid values:
	//
	// *   success: The synchronization node in Data Integration is deleted.
	// *   fail: The synchronization node in Data Integration failed to be deleted. You can troubleshoot the issue based on the failure reason.
	Data *DeleteDISyncTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The result returned after you called the DeleteDISyncTask operation.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteDISyncTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDISyncTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDISyncTaskResponseBody) SetData(v *DeleteDISyncTaskResponseBodyData) *DeleteDISyncTaskResponseBody {
	s.Data = v
	return s
}

func (s *DeleteDISyncTaskResponseBody) SetRequestId(v string) *DeleteDISyncTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDISyncTaskResponseBody) SetSuccess(v bool) *DeleteDISyncTaskResponseBody {
	s.Success = &v
	return s
}

type DeleteDISyncTaskResponseBodyData struct {
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The reason why the synchronization node in Data Integration failed to be deleted.
	//
	// If the synchronization node in Data Integration is deleted, the value null is returned.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DeleteDISyncTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteDISyncTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteDISyncTaskResponseBodyData) SetMessage(v string) *DeleteDISyncTaskResponseBodyData {
	s.Message = &v
	return s
}

func (s *DeleteDISyncTaskResponseBodyData) SetStatus(v string) *DeleteDISyncTaskResponseBodyData {
	s.Status = &v
	return s
}

type DeleteDISyncTaskResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteDISyncTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteDISyncTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDISyncTaskResponse) GoString() string {
	return s.String()
}

func (s *DeleteDISyncTaskResponse) SetHeaders(v map[string]*string) *DeleteDISyncTaskResponse {
	s.Headers = v
	return s
}

func (s *DeleteDISyncTaskResponse) SetStatusCode(v int32) *DeleteDISyncTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDISyncTaskResponse) SetBody(v *DeleteDISyncTaskResponseBody) *DeleteDISyncTaskResponse {
	s.Body = v
	return s
}

type DeleteDataServiceApiRequest struct {
	// The ID of the API in DataService Studio.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s DeleteDataServiceApiRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataServiceApiRequest) GoString() string {
	return s.String()
}

func (s *DeleteDataServiceApiRequest) SetApiId(v int64) *DeleteDataServiceApiRequest {
	s.ApiId = &v
	return s
}

func (s *DeleteDataServiceApiRequest) SetProjectId(v int64) *DeleteDataServiceApiRequest {
	s.ProjectId = &v
	return s
}

func (s *DeleteDataServiceApiRequest) SetTenantId(v int64) *DeleteDataServiceApiRequest {
	s.TenantId = &v
	return s
}

type DeleteDataServiceApiResponseBody struct {
	// Indicates whether the API was deleted.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteDataServiceApiResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataServiceApiResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDataServiceApiResponseBody) SetData(v bool) *DeleteDataServiceApiResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteDataServiceApiResponseBody) SetErrorCode(v string) *DeleteDataServiceApiResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteDataServiceApiResponseBody) SetErrorMessage(v string) *DeleteDataServiceApiResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteDataServiceApiResponseBody) SetHttpStatusCode(v int32) *DeleteDataServiceApiResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteDataServiceApiResponseBody) SetRequestId(v string) *DeleteDataServiceApiResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDataServiceApiResponseBody) SetSuccess(v bool) *DeleteDataServiceApiResponseBody {
	s.Success = &v
	return s
}

type DeleteDataServiceApiResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteDataServiceApiResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteDataServiceApiResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataServiceApiResponse) GoString() string {
	return s.String()
}

func (s *DeleteDataServiceApiResponse) SetHeaders(v map[string]*string) *DeleteDataServiceApiResponse {
	s.Headers = v
	return s
}

func (s *DeleteDataServiceApiResponse) SetStatusCode(v int32) *DeleteDataServiceApiResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDataServiceApiResponse) SetBody(v *DeleteDataServiceApiResponseBody) *DeleteDataServiceApiResponse {
	s.Body = v
	return s
}

type DeleteDataServiceApiAuthorityRequest struct {
	// The ID of the API.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The ID of the workspace from which you want to revoke the access permissions on the API.
	AuthorizedProjectId *int64 `json:"AuthorizedProjectId,omitempty" xml:"AuthorizedProjectId,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s DeleteDataServiceApiAuthorityRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataServiceApiAuthorityRequest) GoString() string {
	return s.String()
}

func (s *DeleteDataServiceApiAuthorityRequest) SetApiId(v int64) *DeleteDataServiceApiAuthorityRequest {
	s.ApiId = &v
	return s
}

func (s *DeleteDataServiceApiAuthorityRequest) SetAuthorizedProjectId(v int64) *DeleteDataServiceApiAuthorityRequest {
	s.AuthorizedProjectId = &v
	return s
}

func (s *DeleteDataServiceApiAuthorityRequest) SetProjectId(v int64) *DeleteDataServiceApiAuthorityRequest {
	s.ProjectId = &v
	return s
}

func (s *DeleteDataServiceApiAuthorityRequest) SetTenantId(v int64) *DeleteDataServiceApiAuthorityRequest {
	s.TenantId = &v
	return s
}

type DeleteDataServiceApiAuthorityResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the access permissions are revoked.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteDataServiceApiAuthorityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataServiceApiAuthorityResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDataServiceApiAuthorityResponseBody) SetRequestId(v string) *DeleteDataServiceApiAuthorityResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDataServiceApiAuthorityResponseBody) SetSuccess(v bool) *DeleteDataServiceApiAuthorityResponseBody {
	s.Success = &v
	return s
}

type DeleteDataServiceApiAuthorityResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteDataServiceApiAuthorityResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteDataServiceApiAuthorityResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataServiceApiAuthorityResponse) GoString() string {
	return s.String()
}

func (s *DeleteDataServiceApiAuthorityResponse) SetHeaders(v map[string]*string) *DeleteDataServiceApiAuthorityResponse {
	s.Headers = v
	return s
}

func (s *DeleteDataServiceApiAuthorityResponse) SetStatusCode(v int32) *DeleteDataServiceApiAuthorityResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDataServiceApiAuthorityResponse) SetBody(v *DeleteDataServiceApiAuthorityResponseBody) *DeleteDataServiceApiAuthorityResponse {
	s.Body = v
	return s
}

type DeleteDataSourceRequest struct {
	// The ID of the data source. You can call the [ListDataSources](~~211431~~) operation to obtain the ID.
	DataSourceId *int64 `json:"DataSourceId,omitempty" xml:"DataSourceId,omitempty"`
}

func (s DeleteDataSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataSourceRequest) GoString() string {
	return s.String()
}

func (s *DeleteDataSourceRequest) SetDataSourceId(v int64) *DeleteDataSourceRequest {
	s.DataSourceId = &v
	return s
}

type DeleteDataSourceResponseBody struct {
	// Indicates whether the request is successful.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *string `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteDataSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataSourceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDataSourceResponseBody) SetData(v bool) *DeleteDataSourceResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteDataSourceResponseBody) SetHttpStatusCode(v string) *DeleteDataSourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteDataSourceResponseBody) SetRequestId(v string) *DeleteDataSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDataSourceResponseBody) SetSuccess(v bool) *DeleteDataSourceResponseBody {
	s.Success = &v
	return s
}

type DeleteDataSourceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteDataSourceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteDataSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataSourceResponse) GoString() string {
	return s.String()
}

func (s *DeleteDataSourceResponse) SetHeaders(v map[string]*string) *DeleteDataSourceResponse {
	s.Headers = v
	return s
}

func (s *DeleteDataSourceResponse) SetStatusCode(v int32) *DeleteDataSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDataSourceResponse) SetBody(v *DeleteDataSourceResponseBody) *DeleteDataSourceResponse {
	s.Body = v
	return s
}

type DeleteFileRequest struct {
	// The HTTP status code.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to view the workspace name.
	//
	// You must specify one of the ProjectId and ProjectIdentifier parameters to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the file. You can call the [ListFiles](~~173942~~) operation to query the ID of the file.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s DeleteFileRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteFileRequest) GoString() string {
	return s.String()
}

func (s *DeleteFileRequest) SetFileId(v int64) *DeleteFileRequest {
	s.FileId = &v
	return s
}

func (s *DeleteFileRequest) SetProjectId(v int64) *DeleteFileRequest {
	s.ProjectId = &v
	return s
}

func (s *DeleteFileRequest) SetProjectIdentifier(v string) *DeleteFileRequest {
	s.ProjectIdentifier = &v
	return s
}

type DeleteFileResponseBody struct {
	// The ID of the request. You can troubleshoot errors based on the ID.
	DeploymentId *int64  `json:"DeploymentId,omitempty" xml:"DeploymentId,omitempty"`
	ErrorCode    *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the deployment task that deploys the file. If the file has been committed, an asynchronous process is triggered to delete the file in the scheduling system. The value of this parameter is used to call the GetDeployment operation to poll the status of the asynchronous process.
	//
	// If this parameter is empty, the file is deleted and the polling is not required.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The error code returned.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteFileResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteFileResponseBody) SetDeploymentId(v int64) *DeleteFileResponseBody {
	s.DeploymentId = &v
	return s
}

func (s *DeleteFileResponseBody) SetErrorCode(v string) *DeleteFileResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteFileResponseBody) SetErrorMessage(v string) *DeleteFileResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteFileResponseBody) SetHttpStatusCode(v int32) *DeleteFileResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteFileResponseBody) SetRequestId(v string) *DeleteFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteFileResponseBody) SetSuccess(v bool) *DeleteFileResponseBody {
	s.Success = &v
	return s
}

type DeleteFileResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteFileResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteFileResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteFileResponse) GoString() string {
	return s.String()
}

func (s *DeleteFileResponse) SetHeaders(v map[string]*string) *DeleteFileResponse {
	s.Headers = v
	return s
}

func (s *DeleteFileResponse) SetStatusCode(v int32) *DeleteFileResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteFileResponse) SetBody(v *DeleteFileResponseBody) *DeleteFileResponse {
	s.Body = v
	return s
}

type DeleteFolderRequest struct {
	// The ID of the folder. You can call the [ListFolders](~~173955~~) operation to query the ID.
	FolderId *string `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID. You must specify either this parameter or ProjectIdentifier to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Settings panel to obtain the name. You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s DeleteFolderRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteFolderRequest) GoString() string {
	return s.String()
}

func (s *DeleteFolderRequest) SetFolderId(v string) *DeleteFolderRequest {
	s.FolderId = &v
	return s
}

func (s *DeleteFolderRequest) SetProjectId(v int64) *DeleteFolderRequest {
	s.ProjectId = &v
	return s
}

func (s *DeleteFolderRequest) SetProjectIdentifier(v string) *DeleteFolderRequest {
	s.ProjectIdentifier = &v
	return s
}

type DeleteFolderResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteFolderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteFolderResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteFolderResponseBody) SetErrorCode(v string) *DeleteFolderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteFolderResponseBody) SetErrorMessage(v string) *DeleteFolderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteFolderResponseBody) SetHttpStatusCode(v int32) *DeleteFolderResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteFolderResponseBody) SetRequestId(v string) *DeleteFolderResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteFolderResponseBody) SetSuccess(v bool) *DeleteFolderResponseBody {
	s.Success = &v
	return s
}

type DeleteFolderResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteFolderResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteFolderResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteFolderResponse) GoString() string {
	return s.String()
}

func (s *DeleteFolderResponse) SetHeaders(v map[string]*string) *DeleteFolderResponse {
	s.Headers = v
	return s
}

func (s *DeleteFolderResponse) SetStatusCode(v int32) *DeleteFolderResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteFolderResponse) SetBody(v *DeleteFolderResponseBody) *DeleteFolderResponse {
	s.Body = v
	return s
}

type DeleteFromMetaCategoryRequest struct {
	// The ID of the category.
	CategoryId *int64 `json:"CategoryId,omitempty" xml:"CategoryId,omitempty"`
	// The GUID of the metatable.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
}

func (s DeleteFromMetaCategoryRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteFromMetaCategoryRequest) GoString() string {
	return s.String()
}

func (s *DeleteFromMetaCategoryRequest) SetCategoryId(v int64) *DeleteFromMetaCategoryRequest {
	s.CategoryId = &v
	return s
}

func (s *DeleteFromMetaCategoryRequest) SetTableGuid(v string) *DeleteFromMetaCategoryRequest {
	s.TableGuid = &v
	return s
}

type DeleteFromMetaCategoryResponseBody struct {
	// Indicates whether the metatable was removed from the specified category.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteFromMetaCategoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteFromMetaCategoryResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteFromMetaCategoryResponseBody) SetData(v bool) *DeleteFromMetaCategoryResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteFromMetaCategoryResponseBody) SetErrorCode(v string) *DeleteFromMetaCategoryResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteFromMetaCategoryResponseBody) SetErrorMessage(v string) *DeleteFromMetaCategoryResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteFromMetaCategoryResponseBody) SetHttpStatusCode(v int32) *DeleteFromMetaCategoryResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteFromMetaCategoryResponseBody) SetRequestId(v string) *DeleteFromMetaCategoryResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteFromMetaCategoryResponseBody) SetSuccess(v bool) *DeleteFromMetaCategoryResponseBody {
	s.Success = &v
	return s
}

type DeleteFromMetaCategoryResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteFromMetaCategoryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteFromMetaCategoryResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteFromMetaCategoryResponse) GoString() string {
	return s.String()
}

func (s *DeleteFromMetaCategoryResponse) SetHeaders(v map[string]*string) *DeleteFromMetaCategoryResponse {
	s.Headers = v
	return s
}

func (s *DeleteFromMetaCategoryResponse) SetStatusCode(v int32) *DeleteFromMetaCategoryResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteFromMetaCategoryResponse) SetBody(v *DeleteFromMetaCategoryResponseBody) *DeleteFromMetaCategoryResponse {
	s.Body = v
	return s
}

type DeleteLineageRelationRequest struct {
	DestEntityQualifiedName *string `json:"DestEntityQualifiedName,omitempty" xml:"DestEntityQualifiedName,omitempty"`
	RelationshipGuid        *string `json:"RelationshipGuid,omitempty" xml:"RelationshipGuid,omitempty"`
	SrcEntityQualifiedName  *string `json:"SrcEntityQualifiedName,omitempty" xml:"SrcEntityQualifiedName,omitempty"`
}

func (s DeleteLineageRelationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteLineageRelationRequest) GoString() string {
	return s.String()
}

func (s *DeleteLineageRelationRequest) SetDestEntityQualifiedName(v string) *DeleteLineageRelationRequest {
	s.DestEntityQualifiedName = &v
	return s
}

func (s *DeleteLineageRelationRequest) SetRelationshipGuid(v string) *DeleteLineageRelationRequest {
	s.RelationshipGuid = &v
	return s
}

func (s *DeleteLineageRelationRequest) SetSrcEntityQualifiedName(v string) *DeleteLineageRelationRequest {
	s.SrcEntityQualifiedName = &v
	return s
}

type DeleteLineageRelationResponseBody struct {
	ErrorCode      *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Status         *bool   `json:"Status,omitempty" xml:"Status,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteLineageRelationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteLineageRelationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteLineageRelationResponseBody) SetErrorCode(v string) *DeleteLineageRelationResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteLineageRelationResponseBody) SetErrorMessage(v string) *DeleteLineageRelationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteLineageRelationResponseBody) SetHttpStatusCode(v int32) *DeleteLineageRelationResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteLineageRelationResponseBody) SetRequestId(v string) *DeleteLineageRelationResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteLineageRelationResponseBody) SetStatus(v bool) *DeleteLineageRelationResponseBody {
	s.Status = &v
	return s
}

func (s *DeleteLineageRelationResponseBody) SetSuccess(v bool) *DeleteLineageRelationResponseBody {
	s.Success = &v
	return s
}

type DeleteLineageRelationResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteLineageRelationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteLineageRelationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteLineageRelationResponse) GoString() string {
	return s.String()
}

func (s *DeleteLineageRelationResponse) SetHeaders(v map[string]*string) *DeleteLineageRelationResponse {
	s.Headers = v
	return s
}

func (s *DeleteLineageRelationResponse) SetStatusCode(v int32) *DeleteLineageRelationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteLineageRelationResponse) SetBody(v *DeleteLineageRelationResponseBody) *DeleteLineageRelationResponse {
	s.Body = v
	return s
}

type DeleteMetaCategoryRequest struct {
	// The ID of the category.
	CategoryId *int64 `json:"CategoryId,omitempty" xml:"CategoryId,omitempty"`
}

func (s DeleteMetaCategoryRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteMetaCategoryRequest) GoString() string {
	return s.String()
}

func (s *DeleteMetaCategoryRequest) SetCategoryId(v int64) *DeleteMetaCategoryRequest {
	s.CategoryId = &v
	return s
}

type DeleteMetaCategoryResponseBody struct {
	// The business data returned.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteMetaCategoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteMetaCategoryResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteMetaCategoryResponseBody) SetData(v bool) *DeleteMetaCategoryResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteMetaCategoryResponseBody) SetErrorCode(v string) *DeleteMetaCategoryResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteMetaCategoryResponseBody) SetErrorMessage(v string) *DeleteMetaCategoryResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteMetaCategoryResponseBody) SetHttpStatusCode(v int32) *DeleteMetaCategoryResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteMetaCategoryResponseBody) SetRequestId(v string) *DeleteMetaCategoryResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteMetaCategoryResponseBody) SetSuccess(v bool) *DeleteMetaCategoryResponseBody {
	s.Success = &v
	return s
}

type DeleteMetaCategoryResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteMetaCategoryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteMetaCategoryResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteMetaCategoryResponse) GoString() string {
	return s.String()
}

func (s *DeleteMetaCategoryResponse) SetHeaders(v map[string]*string) *DeleteMetaCategoryResponse {
	s.Headers = v
	return s
}

func (s *DeleteMetaCategoryResponse) SetStatusCode(v int32) *DeleteMetaCategoryResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteMetaCategoryResponse) SetBody(v *DeleteMetaCategoryResponseBody) *DeleteMetaCategoryResponse {
	s.Body = v
	return s
}

type DeleteMetaCollectionRequest struct {
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	QualifiedName *string `json:"QualifiedName,omitempty" xml:"QualifiedName,omitempty"`
}

func (s DeleteMetaCollectionRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteMetaCollectionRequest) GoString() string {
	return s.String()
}

func (s *DeleteMetaCollectionRequest) SetQualifiedName(v string) *DeleteMetaCollectionRequest {
	s.QualifiedName = &v
	return s
}

type DeleteMetaCollectionResponseBody struct {
	// Indicates whether the request was successful. Valid values:
	//
	// true: The request was successful.
	//
	// false: The request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error code returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The error message returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The result of the operation. Valid values:
	//
	// true: succeeded
	//
	// false: failed
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The HTTP status code returned.
	Status  *bool `json:"Status,omitempty" xml:"Status,omitempty"`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteMetaCollectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteMetaCollectionResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteMetaCollectionResponseBody) SetErrorCode(v string) *DeleteMetaCollectionResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteMetaCollectionResponseBody) SetErrorMessage(v string) *DeleteMetaCollectionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteMetaCollectionResponseBody) SetHttpStatusCode(v int32) *DeleteMetaCollectionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteMetaCollectionResponseBody) SetRequestId(v string) *DeleteMetaCollectionResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteMetaCollectionResponseBody) SetStatus(v bool) *DeleteMetaCollectionResponseBody {
	s.Status = &v
	return s
}

func (s *DeleteMetaCollectionResponseBody) SetSuccess(v bool) *DeleteMetaCollectionResponseBody {
	s.Success = &v
	return s
}

type DeleteMetaCollectionResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteMetaCollectionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteMetaCollectionResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteMetaCollectionResponse) GoString() string {
	return s.String()
}

func (s *DeleteMetaCollectionResponse) SetHeaders(v map[string]*string) *DeleteMetaCollectionResponse {
	s.Headers = v
	return s
}

func (s *DeleteMetaCollectionResponse) SetStatusCode(v int32) *DeleteMetaCollectionResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteMetaCollectionResponse) SetBody(v *DeleteMetaCollectionResponseBody) *DeleteMetaCollectionResponse {
	s.Body = v
	return s
}

type DeleteMetaCollectionEntityRequest struct {
	// The unique identifier of the entity.
	CollectionQualifiedName *string `json:"CollectionQualifiedName,omitempty" xml:"CollectionQualifiedName,omitempty"`
	// The ID of the request.
	EntityQualifiedName *string `json:"EntityQualifiedName,omitempty" xml:"EntityQualifiedName,omitempty"`
}

func (s DeleteMetaCollectionEntityRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteMetaCollectionEntityRequest) GoString() string {
	return s.String()
}

func (s *DeleteMetaCollectionEntityRequest) SetCollectionQualifiedName(v string) *DeleteMetaCollectionEntityRequest {
	s.CollectionQualifiedName = &v
	return s
}

func (s *DeleteMetaCollectionEntityRequest) SetEntityQualifiedName(v string) *DeleteMetaCollectionEntityRequest {
	s.EntityQualifiedName = &v
	return s
}

type DeleteMetaCollectionEntityResponseBody struct {
	// Indicates whether the request was successful. Valid values:
	//
	// true: The request was successful.
	//
	// false: The request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error code returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The error message returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The result of the operation. Valid values:
	//
	// true: succeeded
	//
	// false: failed
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The HTTP status code returned.
	Status  *bool `json:"Status,omitempty" xml:"Status,omitempty"`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteMetaCollectionEntityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteMetaCollectionEntityResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteMetaCollectionEntityResponseBody) SetErrorCode(v string) *DeleteMetaCollectionEntityResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteMetaCollectionEntityResponseBody) SetErrorMessage(v string) *DeleteMetaCollectionEntityResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteMetaCollectionEntityResponseBody) SetHttpStatusCode(v int32) *DeleteMetaCollectionEntityResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteMetaCollectionEntityResponseBody) SetRequestId(v string) *DeleteMetaCollectionEntityResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteMetaCollectionEntityResponseBody) SetStatus(v bool) *DeleteMetaCollectionEntityResponseBody {
	s.Status = &v
	return s
}

func (s *DeleteMetaCollectionEntityResponseBody) SetSuccess(v bool) *DeleteMetaCollectionEntityResponseBody {
	s.Success = &v
	return s
}

type DeleteMetaCollectionEntityResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteMetaCollectionEntityResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteMetaCollectionEntityResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteMetaCollectionEntityResponse) GoString() string {
	return s.String()
}

func (s *DeleteMetaCollectionEntityResponse) SetHeaders(v map[string]*string) *DeleteMetaCollectionEntityResponse {
	s.Headers = v
	return s
}

func (s *DeleteMetaCollectionEntityResponse) SetStatusCode(v int32) *DeleteMetaCollectionEntityResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteMetaCollectionEntityResponse) SetBody(v *DeleteMetaCollectionEntityResponseBody) *DeleteMetaCollectionEntityResponse {
	s.Body = v
	return s
}

type DeleteProjectMemberRequest struct {
	// The ID of the region.
	ProjectId *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	UserId    *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s DeleteProjectMemberRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteProjectMemberRequest) GoString() string {
	return s.String()
}

func (s *DeleteProjectMemberRequest) SetProjectId(v int64) *DeleteProjectMemberRequest {
	s.ProjectId = &v
	return s
}

func (s *DeleteProjectMemberRequest) SetUserId(v string) *DeleteProjectMemberRequest {
	s.UserId = &v
	return s
}

type DeleteProjectMemberResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteProjectMemberResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteProjectMemberResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteProjectMemberResponseBody) SetRequestId(v string) *DeleteProjectMemberResponseBody {
	s.RequestId = &v
	return s
}

type DeleteProjectMemberResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteProjectMemberResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteProjectMemberResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteProjectMemberResponse) GoString() string {
	return s.String()
}

func (s *DeleteProjectMemberResponse) SetHeaders(v map[string]*string) *DeleteProjectMemberResponse {
	s.Headers = v
	return s
}

func (s *DeleteProjectMemberResponse) SetStatusCode(v int32) *DeleteProjectMemberResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteProjectMemberResponse) SetBody(v *DeleteProjectMemberResponseBody) *DeleteProjectMemberResponse {
	s.Body = v
	return s
}

type DeleteQualityEntityRequest struct {
	// The ID of the partition filter expression.
	EntityId *int64 `json:"EntityId,omitempty" xml:"EntityId,omitempty"`
	// The type of the compute engine instance or data source. Valid values: EMR, Hologres, AnalyticDB for PostgreSQL, CDH, MaxCompute, Kafka and DataHub.
	EnvType   *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	ProjectId *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the compute engine instance or data source.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s DeleteQualityEntityRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteQualityEntityRequest) GoString() string {
	return s.String()
}

func (s *DeleteQualityEntityRequest) SetEntityId(v int64) *DeleteQualityEntityRequest {
	s.EntityId = &v
	return s
}

func (s *DeleteQualityEntityRequest) SetEnvType(v string) *DeleteQualityEntityRequest {
	s.EnvType = &v
	return s
}

func (s *DeleteQualityEntityRequest) SetProjectId(v int64) *DeleteQualityEntityRequest {
	s.ProjectId = &v
	return s
}

func (s *DeleteQualityEntityRequest) SetProjectName(v string) *DeleteQualityEntityRequest {
	s.ProjectName = &v
	return s
}

type DeleteQualityEntityResponseBody struct {
	// The result returned.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteQualityEntityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteQualityEntityResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteQualityEntityResponseBody) SetData(v bool) *DeleteQualityEntityResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteQualityEntityResponseBody) SetErrorCode(v string) *DeleteQualityEntityResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteQualityEntityResponseBody) SetErrorMessage(v string) *DeleteQualityEntityResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteQualityEntityResponseBody) SetHttpStatusCode(v int32) *DeleteQualityEntityResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteQualityEntityResponseBody) SetRequestId(v string) *DeleteQualityEntityResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteQualityEntityResponseBody) SetSuccess(v bool) *DeleteQualityEntityResponseBody {
	s.Success = &v
	return s
}

type DeleteQualityEntityResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteQualityEntityResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteQualityEntityResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteQualityEntityResponse) GoString() string {
	return s.String()
}

func (s *DeleteQualityEntityResponse) SetHeaders(v map[string]*string) *DeleteQualityEntityResponse {
	s.Headers = v
	return s
}

func (s *DeleteQualityEntityResponse) SetStatusCode(v int32) *DeleteQualityEntityResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteQualityEntityResponse) SetBody(v *DeleteQualityEntityResponseBody) *DeleteQualityEntityResponse {
	s.Body = v
	return s
}

type DeleteQualityFollowerRequest struct {
	// The ID of the subscription relationship between the partition filter expression and the subscriber. You can call the [GetQualityFollower](~~174000~~) operation to obtain the ID of the subscription relationship.
	FollowerId *int64 `json:"FollowerId,omitempty" xml:"FollowerId,omitempty"`
	ProjectId  *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the compute engine or data source for which the partition filter expression is configured. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Monitoring Rules page of Data Quality to obtain the name.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s DeleteQualityFollowerRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteQualityFollowerRequest) GoString() string {
	return s.String()
}

func (s *DeleteQualityFollowerRequest) SetFollowerId(v int64) *DeleteQualityFollowerRequest {
	s.FollowerId = &v
	return s
}

func (s *DeleteQualityFollowerRequest) SetProjectId(v int64) *DeleteQualityFollowerRequest {
	s.ProjectId = &v
	return s
}

func (s *DeleteQualityFollowerRequest) SetProjectName(v string) *DeleteQualityFollowerRequest {
	s.ProjectName = &v
	return s
}

type DeleteQualityFollowerResponseBody struct {
	// Indicates whether the subscriber was successfully deleted. Valid values:
	//
	// *   true: The subscriber was successfully deleted.
	// *   false: The subscriber failed to be deleted. You can troubleshoot errors based on the error message returned.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned when the subscriber failed to be deleted.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot errors.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteQualityFollowerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteQualityFollowerResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteQualityFollowerResponseBody) SetData(v bool) *DeleteQualityFollowerResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteQualityFollowerResponseBody) SetErrorCode(v string) *DeleteQualityFollowerResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteQualityFollowerResponseBody) SetErrorMessage(v string) *DeleteQualityFollowerResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteQualityFollowerResponseBody) SetHttpStatusCode(v int32) *DeleteQualityFollowerResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteQualityFollowerResponseBody) SetRequestId(v string) *DeleteQualityFollowerResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteQualityFollowerResponseBody) SetSuccess(v bool) *DeleteQualityFollowerResponseBody {
	s.Success = &v
	return s
}

type DeleteQualityFollowerResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteQualityFollowerResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteQualityFollowerResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteQualityFollowerResponse) GoString() string {
	return s.String()
}

func (s *DeleteQualityFollowerResponse) SetHeaders(v map[string]*string) *DeleteQualityFollowerResponse {
	s.Headers = v
	return s
}

func (s *DeleteQualityFollowerResponse) SetStatusCode(v int32) *DeleteQualityFollowerResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteQualityFollowerResponse) SetBody(v *DeleteQualityFollowerResponseBody) *DeleteQualityFollowerResponse {
	s.Body = v
	return s
}

type DeleteQualityRelativeNodeRequest struct {
	// The environment in which the compute engine instance runs. Valid values: DEV and PRD. The value DEV indicates the development environment, and the value PRD indicates the production environment.
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The partition filter expression.
	MatchExpression *string `json:"MatchExpression,omitempty" xml:"MatchExpression,omitempty"`
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the compute engine instance or data source.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The name of the table that is generated by the node.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the workspace to which the node associated with the partition filter expression belongs.
	TargetNodeProjectId *int64 `json:"TargetNodeProjectId,omitempty" xml:"TargetNodeProjectId,omitempty"`
	// The name of the workspace to which the node associated with the partition filter expression belongs.
	TargetNodeProjectName *string `json:"TargetNodeProjectName,omitempty" xml:"TargetNodeProjectName,omitempty"`
}

func (s DeleteQualityRelativeNodeRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteQualityRelativeNodeRequest) GoString() string {
	return s.String()
}

func (s *DeleteQualityRelativeNodeRequest) SetEnvType(v string) *DeleteQualityRelativeNodeRequest {
	s.EnvType = &v
	return s
}

func (s *DeleteQualityRelativeNodeRequest) SetMatchExpression(v string) *DeleteQualityRelativeNodeRequest {
	s.MatchExpression = &v
	return s
}

func (s *DeleteQualityRelativeNodeRequest) SetNodeId(v int64) *DeleteQualityRelativeNodeRequest {
	s.NodeId = &v
	return s
}

func (s *DeleteQualityRelativeNodeRequest) SetProjectId(v int64) *DeleteQualityRelativeNodeRequest {
	s.ProjectId = &v
	return s
}

func (s *DeleteQualityRelativeNodeRequest) SetProjectName(v string) *DeleteQualityRelativeNodeRequest {
	s.ProjectName = &v
	return s
}

func (s *DeleteQualityRelativeNodeRequest) SetTableName(v string) *DeleteQualityRelativeNodeRequest {
	s.TableName = &v
	return s
}

func (s *DeleteQualityRelativeNodeRequest) SetTargetNodeProjectId(v int64) *DeleteQualityRelativeNodeRequest {
	s.TargetNodeProjectId = &v
	return s
}

func (s *DeleteQualityRelativeNodeRequest) SetTargetNodeProjectName(v string) *DeleteQualityRelativeNodeRequest {
	s.TargetNodeProjectName = &v
	return s
}

type DeleteQualityRelativeNodeResponseBody struct {
	// Indicates whether the node is disassociated from the partition filter expression.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteQualityRelativeNodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteQualityRelativeNodeResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteQualityRelativeNodeResponseBody) SetData(v bool) *DeleteQualityRelativeNodeResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteQualityRelativeNodeResponseBody) SetErrorCode(v string) *DeleteQualityRelativeNodeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteQualityRelativeNodeResponseBody) SetErrorMessage(v string) *DeleteQualityRelativeNodeResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteQualityRelativeNodeResponseBody) SetHttpStatusCode(v int32) *DeleteQualityRelativeNodeResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteQualityRelativeNodeResponseBody) SetRequestId(v string) *DeleteQualityRelativeNodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteQualityRelativeNodeResponseBody) SetSuccess(v bool) *DeleteQualityRelativeNodeResponseBody {
	s.Success = &v
	return s
}

type DeleteQualityRelativeNodeResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteQualityRelativeNodeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteQualityRelativeNodeResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteQualityRelativeNodeResponse) GoString() string {
	return s.String()
}

func (s *DeleteQualityRelativeNodeResponse) SetHeaders(v map[string]*string) *DeleteQualityRelativeNodeResponse {
	s.Headers = v
	return s
}

func (s *DeleteQualityRelativeNodeResponse) SetStatusCode(v int32) *DeleteQualityRelativeNodeResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteQualityRelativeNodeResponse) SetBody(v *DeleteQualityRelativeNodeResponseBody) *DeleteQualityRelativeNodeResponse {
	s.Body = v
	return s
}

type DeleteQualityRuleRequest struct {
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the database engine or data source.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The ID of the rule.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s DeleteQualityRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteQualityRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteQualityRuleRequest) SetProjectId(v int64) *DeleteQualityRuleRequest {
	s.ProjectId = &v
	return s
}

func (s *DeleteQualityRuleRequest) SetProjectName(v string) *DeleteQualityRuleRequest {
	s.ProjectName = &v
	return s
}

func (s *DeleteQualityRuleRequest) SetRuleId(v int64) *DeleteQualityRuleRequest {
	s.RuleId = &v
	return s
}

type DeleteQualityRuleResponseBody struct {
	// Indicates whether the deletion was successful.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The returned message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteQualityRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteQualityRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteQualityRuleResponseBody) SetData(v bool) *DeleteQualityRuleResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteQualityRuleResponseBody) SetErrorCode(v string) *DeleteQualityRuleResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteQualityRuleResponseBody) SetErrorMessage(v string) *DeleteQualityRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteQualityRuleResponseBody) SetHttpStatusCode(v int32) *DeleteQualityRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteQualityRuleResponseBody) SetRequestId(v string) *DeleteQualityRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteQualityRuleResponseBody) SetSuccess(v bool) *DeleteQualityRuleResponseBody {
	s.Success = &v
	return s
}

type DeleteQualityRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteQualityRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteQualityRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteQualityRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteQualityRuleResponse) SetHeaders(v map[string]*string) *DeleteQualityRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteQualityRuleResponse) SetStatusCode(v int32) *DeleteQualityRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteQualityRuleResponse) SetBody(v *DeleteQualityRuleResponseBody) *DeleteQualityRuleResponse {
	s.Body = v
	return s
}

type DeleteRecognizeRuleRequest struct {
	SensitiveId *string `json:"SensitiveId,omitempty" xml:"SensitiveId,omitempty"`
	TenantId    *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s DeleteRecognizeRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRecognizeRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteRecognizeRuleRequest) SetSensitiveId(v string) *DeleteRecognizeRuleRequest {
	s.SensitiveId = &v
	return s
}

func (s *DeleteRecognizeRuleRequest) SetTenantId(v string) *DeleteRecognizeRuleRequest {
	s.TenantId = &v
	return s
}

type DeleteRecognizeRuleResponseBody struct {
	Data           interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string     `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32      `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteRecognizeRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRecognizeRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRecognizeRuleResponseBody) SetData(v interface{}) *DeleteRecognizeRuleResponseBody {
	s.Data = v
	return s
}

func (s *DeleteRecognizeRuleResponseBody) SetErrorCode(v string) *DeleteRecognizeRuleResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteRecognizeRuleResponseBody) SetErrorMessage(v string) *DeleteRecognizeRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteRecognizeRuleResponseBody) SetHttpStatusCode(v int32) *DeleteRecognizeRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteRecognizeRuleResponseBody) SetRequestId(v string) *DeleteRecognizeRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteRecognizeRuleResponseBody) SetSuccess(v bool) *DeleteRecognizeRuleResponseBody {
	s.Success = &v
	return s
}

type DeleteRecognizeRuleResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteRecognizeRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteRecognizeRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRecognizeRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteRecognizeRuleResponse) SetHeaders(v map[string]*string) *DeleteRecognizeRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteRecognizeRuleResponse) SetStatusCode(v int32) *DeleteRecognizeRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRecognizeRuleResponse) SetBody(v *DeleteRecognizeRuleResponseBody) *DeleteRecognizeRuleResponse {
	s.Body = v
	return s
}

type DeleteRemindRequest struct {
	// The ID of the custom alert rule.
	RemindId *int64 `json:"RemindId,omitempty" xml:"RemindId,omitempty"`
}

func (s DeleteRemindRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRemindRequest) GoString() string {
	return s.String()
}

func (s *DeleteRemindRequest) SetRemindId(v int64) *DeleteRemindRequest {
	s.RemindId = &v
	return s
}

type DeleteRemindResponseBody struct {
	// Indicates whether the custom alert rule is deleted. Valid values: true and false. The value true indicates that the custom alert rule is deleted. The value false indicates that the custom alert rule fails to be deleted.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteRemindResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRemindResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRemindResponseBody) SetData(v bool) *DeleteRemindResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteRemindResponseBody) SetErrorCode(v string) *DeleteRemindResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteRemindResponseBody) SetErrorMessage(v string) *DeleteRemindResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteRemindResponseBody) SetHttpStatusCode(v int32) *DeleteRemindResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteRemindResponseBody) SetRequestId(v string) *DeleteRemindResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteRemindResponseBody) SetSuccess(v bool) *DeleteRemindResponseBody {
	s.Success = &v
	return s
}

type DeleteRemindResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteRemindResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteRemindResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRemindResponse) GoString() string {
	return s.String()
}

func (s *DeleteRemindResponse) SetHeaders(v map[string]*string) *DeleteRemindResponse {
	s.Headers = v
	return s
}

func (s *DeleteRemindResponse) SetStatusCode(v int32) *DeleteRemindResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRemindResponse) SetBody(v *DeleteRemindResponseBody) *DeleteRemindResponse {
	s.Body = v
	return s
}

type DeleteTableRequest struct {
	// The globally unique identifier (GUID) of the MaxCompute project. Specify the GUID in the odps.{projectName} format.
	AppGuid *string `json:"AppGuid,omitempty" xml:"AppGuid,omitempty"`
	// The environment of the DataWorks workspace. Valid values: 0 and 1. The value 0 indicates the development environment. The value 1 indicates the production environment.
	EnvType *int32 `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The ID of the DataWorks workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The schema information of the table. You need to enter the schema information of the table if you enable the table schema in MaxCompute.
	Schema *string `json:"Schema,omitempty" xml:"Schema,omitempty"`
	// The name of the MaxCompute table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s DeleteTableRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTableRequest) GoString() string {
	return s.String()
}

func (s *DeleteTableRequest) SetAppGuid(v string) *DeleteTableRequest {
	s.AppGuid = &v
	return s
}

func (s *DeleteTableRequest) SetEnvType(v int32) *DeleteTableRequest {
	s.EnvType = &v
	return s
}

func (s *DeleteTableRequest) SetProjectId(v int64) *DeleteTableRequest {
	s.ProjectId = &v
	return s
}

func (s *DeleteTableRequest) SetSchema(v string) *DeleteTableRequest {
	s.Schema = &v
	return s
}

func (s *DeleteTableRequest) SetTableName(v string) *DeleteTableRequest {
	s.TableName = &v
	return s
}

type DeleteTableResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the task that is used to delete the table.
	TaskInfo *DeleteTableResponseBodyTaskInfo `json:"TaskInfo,omitempty" xml:"TaskInfo,omitempty" type:"Struct"`
}

func (s DeleteTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTableResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTableResponseBody) SetRequestId(v string) *DeleteTableResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteTableResponseBody) SetTaskInfo(v *DeleteTableResponseBodyTaskInfo) *DeleteTableResponseBody {
	s.TaskInfo = v
	return s
}

type DeleteTableResponseBodyTaskInfo struct {
	// The content of the task.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the task that is running.
	NextTaskId *string `json:"NextTaskId,omitempty" xml:"NextTaskId,omitempty"`
	// The status of the task that is complete.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the task that is complete.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s DeleteTableResponseBodyTaskInfo) String() string {
	return tea.Prettify(s)
}

func (s DeleteTableResponseBodyTaskInfo) GoString() string {
	return s.String()
}

func (s *DeleteTableResponseBodyTaskInfo) SetContent(v string) *DeleteTableResponseBodyTaskInfo {
	s.Content = &v
	return s
}

func (s *DeleteTableResponseBodyTaskInfo) SetNextTaskId(v string) *DeleteTableResponseBodyTaskInfo {
	s.NextTaskId = &v
	return s
}

func (s *DeleteTableResponseBodyTaskInfo) SetStatus(v string) *DeleteTableResponseBodyTaskInfo {
	s.Status = &v
	return s
}

func (s *DeleteTableResponseBodyTaskInfo) SetTaskId(v string) *DeleteTableResponseBodyTaskInfo {
	s.TaskId = &v
	return s
}

type DeleteTableResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteTableResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteTableResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTableResponse) GoString() string {
	return s.String()
}

func (s *DeleteTableResponse) SetHeaders(v map[string]*string) *DeleteTableResponse {
	s.Headers = v
	return s
}

func (s *DeleteTableResponse) SetStatusCode(v int32) *DeleteTableResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTableResponse) SetBody(v *DeleteTableResponseBody) *DeleteTableResponse {
	s.Body = v
	return s
}

type DeleteTableLevelRequest struct {
	// The ID of the table level to be deleted. You can call the ListTableLevel operation to obtain the ID.
	LevelId *int64 `json:"LevelId,omitempty" xml:"LevelId,omitempty"`
	// The ID of the DataWorks workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s DeleteTableLevelRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTableLevelRequest) GoString() string {
	return s.String()
}

func (s *DeleteTableLevelRequest) SetLevelId(v int64) *DeleteTableLevelRequest {
	s.LevelId = &v
	return s
}

func (s *DeleteTableLevelRequest) SetProjectId(v int64) *DeleteTableLevelRequest {
	s.ProjectId = &v
	return s
}

type DeleteTableLevelResponseBody struct {
	// Indicates whether the table level is deleted.
	DeleteResult *bool `json:"DeleteResult,omitempty" xml:"DeleteResult,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DeleteTableLevelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTableLevelResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTableLevelResponseBody) SetDeleteResult(v bool) *DeleteTableLevelResponseBody {
	s.DeleteResult = &v
	return s
}

func (s *DeleteTableLevelResponseBody) SetRequestId(v string) *DeleteTableLevelResponseBody {
	s.RequestId = &v
	return s
}

type DeleteTableLevelResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteTableLevelResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteTableLevelResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTableLevelResponse) GoString() string {
	return s.String()
}

func (s *DeleteTableLevelResponse) SetHeaders(v map[string]*string) *DeleteTableLevelResponse {
	s.Headers = v
	return s
}

func (s *DeleteTableLevelResponse) SetStatusCode(v int32) *DeleteTableLevelResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTableLevelResponse) SetBody(v *DeleteTableLevelResponseBody) *DeleteTableLevelResponse {
	s.Body = v
	return s
}

type DeleteTableThemeRequest struct {
	// The ID of the DataWorks workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the table folder.
	ThemeId *int64 `json:"ThemeId,omitempty" xml:"ThemeId,omitempty"`
}

func (s DeleteTableThemeRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTableThemeRequest) GoString() string {
	return s.String()
}

func (s *DeleteTableThemeRequest) SetProjectId(v int64) *DeleteTableThemeRequest {
	s.ProjectId = &v
	return s
}

func (s *DeleteTableThemeRequest) SetThemeId(v int64) *DeleteTableThemeRequest {
	s.ThemeId = &v
	return s
}

type DeleteTableThemeResponseBody struct {
	// Indicates whether the table folder is deleted.
	DeleteResult *bool `json:"DeleteResult,omitempty" xml:"DeleteResult,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteTableThemeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTableThemeResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTableThemeResponseBody) SetDeleteResult(v bool) *DeleteTableThemeResponseBody {
	s.DeleteResult = &v
	return s
}

func (s *DeleteTableThemeResponseBody) SetErrorCode(v string) *DeleteTableThemeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeleteTableThemeResponseBody) SetErrorMessage(v string) *DeleteTableThemeResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteTableThemeResponseBody) SetHttpStatusCode(v int32) *DeleteTableThemeResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeleteTableThemeResponseBody) SetRequestId(v string) *DeleteTableThemeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteTableThemeResponseBody) SetSuccess(v bool) *DeleteTableThemeResponseBody {
	s.Success = &v
	return s
}

type DeleteTableThemeResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeleteTableThemeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeleteTableThemeResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTableThemeResponse) GoString() string {
	return s.String()
}

func (s *DeleteTableThemeResponse) SetHeaders(v map[string]*string) *DeleteTableThemeResponse {
	s.Headers = v
	return s
}

func (s *DeleteTableThemeResponse) SetStatusCode(v int32) *DeleteTableThemeResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTableThemeResponse) SetBody(v *DeleteTableThemeResponseBody) *DeleteTableThemeResponse {
	s.Body = v
	return s
}

type DeployDISyncTaskRequest struct {
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The type of the object that you want to deploy. Valid values:
	//
	// *   DI_REALTIME: real-time synchronization node
	// *   DI_SOLUTION: data synchronization solution
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// *   If you set the TaskType parameter to DI_REALTIME, set the FileId parameter to the ID of the real-time synchronization node that you want to deploy.
	// *   If you set the TaskType parameter to DI_SOLUTION, set the FileId parameter to the ID of the data synchronization solution that you want to deploy.
	//
	// You can call the [ListFiles](~~173942~~) operation to query the ID of the real-time synchronization node or data synchronization solution.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s DeployDISyncTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s DeployDISyncTaskRequest) GoString() string {
	return s.String()
}

func (s *DeployDISyncTaskRequest) SetFileId(v int64) *DeployDISyncTaskRequest {
	s.FileId = &v
	return s
}

func (s *DeployDISyncTaskRequest) SetProjectId(v int64) *DeployDISyncTaskRequest {
	s.ProjectId = &v
	return s
}

func (s *DeployDISyncTaskRequest) SetTaskType(v string) *DeployDISyncTaskRequest {
	s.TaskType = &v
	return s
}

type DeployDISyncTaskResponseBody struct {
	// Indicates whether the real-time synchronization node or data synchronization solution is deployed. Valid values:
	//
	// *   success: The real-time synchronization node or data synchronization solution is deployed.
	// *   fail: The real-time synchronization node or data synchronization solution fails to be deployed.
	Data *DeployDISyncTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The result of deploying the real-time synchronization node or data synchronization solution.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request. You can query logs and troubleshoot issues based on the ID.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeployDISyncTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeployDISyncTaskResponseBody) GoString() string {
	return s.String()
}

func (s *DeployDISyncTaskResponseBody) SetData(v *DeployDISyncTaskResponseBodyData) *DeployDISyncTaskResponseBody {
	s.Data = v
	return s
}

func (s *DeployDISyncTaskResponseBody) SetRequestId(v string) *DeployDISyncTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeployDISyncTaskResponseBody) SetSuccess(v bool) *DeployDISyncTaskResponseBody {
	s.Success = &v
	return s
}

type DeployDISyncTaskResponseBodyData struct {
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The cause of the failure to deploy the real-time synchronization node or data synchronization solution.
	//
	// If the real-time synchronization node or data synchronization solution is deployed, the value null is returned.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s DeployDISyncTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeployDISyncTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeployDISyncTaskResponseBodyData) SetMessage(v string) *DeployDISyncTaskResponseBodyData {
	s.Message = &v
	return s
}

func (s *DeployDISyncTaskResponseBodyData) SetStatus(v string) *DeployDISyncTaskResponseBodyData {
	s.Status = &v
	return s
}

type DeployDISyncTaskResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeployDISyncTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeployDISyncTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s DeployDISyncTaskResponse) GoString() string {
	return s.String()
}

func (s *DeployDISyncTaskResponse) SetHeaders(v map[string]*string) *DeployDISyncTaskResponse {
	s.Headers = v
	return s
}

func (s *DeployDISyncTaskResponse) SetStatusCode(v int32) *DeployDISyncTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *DeployDISyncTaskResponse) SetBody(v *DeployDISyncTaskResponseBody) *DeployDISyncTaskResponse {
	s.Body = v
	return s
}

type DeployFileRequest struct {
	// The description of the deployment operation.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ID of the file. You can call the [ListFiles](~~173942~~) operation to query the ID.
	//
	// You must configure either the FileId parameter or the NodeId parameter.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The ID of the node in the scheduling system that corresponds to the file that you want to deploy. You must configure either the NodeId parameter or the FileId parameter.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace ID. You must configure either this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace name. You must configure either this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s DeployFileRequest) String() string {
	return tea.Prettify(s)
}

func (s DeployFileRequest) GoString() string {
	return s.String()
}

func (s *DeployFileRequest) SetComment(v string) *DeployFileRequest {
	s.Comment = &v
	return s
}

func (s *DeployFileRequest) SetFileId(v int64) *DeployFileRequest {
	s.FileId = &v
	return s
}

func (s *DeployFileRequest) SetNodeId(v int64) *DeployFileRequest {
	s.NodeId = &v
	return s
}

func (s *DeployFileRequest) SetProjectId(v int64) *DeployFileRequest {
	s.ProjectId = &v
	return s
}

func (s *DeployFileRequest) SetProjectIdentifier(v string) *DeployFileRequest {
	s.ProjectIdentifier = &v
	return s
}

type DeployFileResponseBody struct {
	// The ID of the deployment task. The ID is used as the value of a specific request parameter when you call the [GetDeployment](~~173950~~) operation to query the details of the deployment task.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeployFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeployFileResponseBody) GoString() string {
	return s.String()
}

func (s *DeployFileResponseBody) SetData(v int64) *DeployFileResponseBody {
	s.Data = &v
	return s
}

func (s *DeployFileResponseBody) SetErrorCode(v string) *DeployFileResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DeployFileResponseBody) SetErrorMessage(v string) *DeployFileResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeployFileResponseBody) SetHttpStatusCode(v int32) *DeployFileResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DeployFileResponseBody) SetRequestId(v string) *DeployFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeployFileResponseBody) SetSuccess(v bool) *DeployFileResponseBody {
	s.Success = &v
	return s
}

type DeployFileResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DeployFileResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DeployFileResponse) String() string {
	return tea.Prettify(s)
}

func (s DeployFileResponse) GoString() string {
	return s.String()
}

func (s *DeployFileResponse) SetHeaders(v map[string]*string) *DeployFileResponse {
	s.Headers = v
	return s
}

func (s *DeployFileResponse) SetStatusCode(v int32) *DeployFileResponse {
	s.StatusCode = &v
	return s
}

func (s *DeployFileResponse) SetBody(v *DeployFileResponseBody) *DeployFileResponse {
	s.Body = v
	return s
}

type DesensitizeDataRequest struct {
	// The data that you want to mask.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The code of the data masking scene. You can view the code on the Data Masking page in Data Security Guard of the DataWorks console.
	SceneCode *string `json:"SceneCode,omitempty" xml:"SceneCode,omitempty"`
}

func (s DesensitizeDataRequest) String() string {
	return tea.Prettify(s)
}

func (s DesensitizeDataRequest) GoString() string {
	return s.String()
}

func (s *DesensitizeDataRequest) SetData(v string) *DesensitizeDataRequest {
	s.Data = &v
	return s
}

func (s *DesensitizeDataRequest) SetSceneCode(v string) *DesensitizeDataRequest {
	s.SceneCode = &v
	return s
}

type DesensitizeDataResponseBody struct {
	// The data returned after masking.
	DesensitizeData *string `json:"DesensitizeData,omitempty" xml:"DesensitizeData,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s DesensitizeDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DesensitizeDataResponseBody) GoString() string {
	return s.String()
}

func (s *DesensitizeDataResponseBody) SetDesensitizeData(v string) *DesensitizeDataResponseBody {
	s.DesensitizeData = &v
	return s
}

func (s *DesensitizeDataResponseBody) SetRequestId(v string) *DesensitizeDataResponseBody {
	s.RequestId = &v
	return s
}

type DesensitizeDataResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DesensitizeDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DesensitizeDataResponse) String() string {
	return tea.Prettify(s)
}

func (s DesensitizeDataResponse) GoString() string {
	return s.String()
}

func (s *DesensitizeDataResponse) SetHeaders(v map[string]*string) *DesensitizeDataResponse {
	s.Headers = v
	return s
}

func (s *DesensitizeDataResponse) SetStatusCode(v int32) *DesensitizeDataResponse {
	s.StatusCode = &v
	return s
}

func (s *DesensitizeDataResponse) SetBody(v *DesensitizeDataResponseBody) *DesensitizeDataResponse {
	s.Body = v
	return s
}

type DsgQuerySensResultRequest struct {
	Col           *string `json:"Col,omitempty" xml:"Col,omitempty"`
	DbType        *string `json:"DbType,omitempty" xml:"DbType,omitempty"`
	Level         *string `json:"Level,omitempty" xml:"Level,omitempty"`
	NodeName      *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	Order         *string `json:"Order,omitempty" xml:"Order,omitempty"`
	OrderField    *string `json:"OrderField,omitempty" xml:"OrderField,omitempty"`
	PageNo        *int32  `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProjectName   *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	SchemaName    *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	SensStatus    *string `json:"SensStatus,omitempty" xml:"SensStatus,omitempty"`
	SensitiveId   *string `json:"SensitiveId,omitempty" xml:"SensitiveId,omitempty"`
	SensitiveName *string `json:"SensitiveName,omitempty" xml:"SensitiveName,omitempty"`
	Table         *string `json:"Table,omitempty" xml:"Table,omitempty"`
	TenantId      *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s DsgQuerySensResultRequest) String() string {
	return tea.Prettify(s)
}

func (s DsgQuerySensResultRequest) GoString() string {
	return s.String()
}

func (s *DsgQuerySensResultRequest) SetCol(v string) *DsgQuerySensResultRequest {
	s.Col = &v
	return s
}

func (s *DsgQuerySensResultRequest) SetDbType(v string) *DsgQuerySensResultRequest {
	s.DbType = &v
	return s
}

func (s *DsgQuerySensResultRequest) SetLevel(v string) *DsgQuerySensResultRequest {
	s.Level = &v
	return s
}

func (s *DsgQuerySensResultRequest) SetNodeName(v string) *DsgQuerySensResultRequest {
	s.NodeName = &v
	return s
}

func (s *DsgQuerySensResultRequest) SetOrder(v string) *DsgQuerySensResultRequest {
	s.Order = &v
	return s
}

func (s *DsgQuerySensResultRequest) SetOrderField(v string) *DsgQuerySensResultRequest {
	s.OrderField = &v
	return s
}

func (s *DsgQuerySensResultRequest) SetPageNo(v int32) *DsgQuerySensResultRequest {
	s.PageNo = &v
	return s
}

func (s *DsgQuerySensResultRequest) SetPageSize(v int32) *DsgQuerySensResultRequest {
	s.PageSize = &v
	return s
}

func (s *DsgQuerySensResultRequest) SetProjectName(v string) *DsgQuerySensResultRequest {
	s.ProjectName = &v
	return s
}

func (s *DsgQuerySensResultRequest) SetSchemaName(v string) *DsgQuerySensResultRequest {
	s.SchemaName = &v
	return s
}

func (s *DsgQuerySensResultRequest) SetSensStatus(v string) *DsgQuerySensResultRequest {
	s.SensStatus = &v
	return s
}

func (s *DsgQuerySensResultRequest) SetSensitiveId(v string) *DsgQuerySensResultRequest {
	s.SensitiveId = &v
	return s
}

func (s *DsgQuerySensResultRequest) SetSensitiveName(v string) *DsgQuerySensResultRequest {
	s.SensitiveName = &v
	return s
}

func (s *DsgQuerySensResultRequest) SetTable(v string) *DsgQuerySensResultRequest {
	s.Table = &v
	return s
}

func (s *DsgQuerySensResultRequest) SetTenantId(v string) *DsgQuerySensResultRequest {
	s.TenantId = &v
	return s
}

type DsgQuerySensResultResponseBody struct {
	Data                interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	DynamicErrorCode    *string     `json:"DynamicErrorCode,omitempty" xml:"DynamicErrorCode,omitempty"`
	DynamicErrorMessage *string     `json:"DynamicErrorMessage,omitempty" xml:"DynamicErrorMessage,omitempty"`
	ErrorCode           *string     `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage        *string     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode      *int32      `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId           *string     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success             *bool       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DsgQuerySensResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DsgQuerySensResultResponseBody) GoString() string {
	return s.String()
}

func (s *DsgQuerySensResultResponseBody) SetData(v interface{}) *DsgQuerySensResultResponseBody {
	s.Data = v
	return s
}

func (s *DsgQuerySensResultResponseBody) SetDynamicErrorCode(v string) *DsgQuerySensResultResponseBody {
	s.DynamicErrorCode = &v
	return s
}

func (s *DsgQuerySensResultResponseBody) SetDynamicErrorMessage(v string) *DsgQuerySensResultResponseBody {
	s.DynamicErrorMessage = &v
	return s
}

func (s *DsgQuerySensResultResponseBody) SetErrorCode(v string) *DsgQuerySensResultResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DsgQuerySensResultResponseBody) SetErrorMessage(v string) *DsgQuerySensResultResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DsgQuerySensResultResponseBody) SetHttpStatusCode(v int32) *DsgQuerySensResultResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DsgQuerySensResultResponseBody) SetRequestId(v string) *DsgQuerySensResultResponseBody {
	s.RequestId = &v
	return s
}

func (s *DsgQuerySensResultResponseBody) SetSuccess(v bool) *DsgQuerySensResultResponseBody {
	s.Success = &v
	return s
}

type DsgQuerySensResultResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DsgQuerySensResultResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DsgQuerySensResultResponse) String() string {
	return tea.Prettify(s)
}

func (s DsgQuerySensResultResponse) GoString() string {
	return s.String()
}

func (s *DsgQuerySensResultResponse) SetHeaders(v map[string]*string) *DsgQuerySensResultResponse {
	s.Headers = v
	return s
}

func (s *DsgQuerySensResultResponse) SetStatusCode(v int32) *DsgQuerySensResultResponse {
	s.StatusCode = &v
	return s
}

func (s *DsgQuerySensResultResponse) SetBody(v *DsgQuerySensResultResponseBody) *DsgQuerySensResultResponse {
	s.Body = v
	return s
}

type DsgRunSensIdentifyRequest struct {
	EsMetaParams []*DsgRunSensIdentifyRequestEsMetaParams `json:"EsMetaParams,omitempty" xml:"EsMetaParams,omitempty" type:"Repeated"`
	TenantId     *string                                  `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s DsgRunSensIdentifyRequest) String() string {
	return tea.Prettify(s)
}

func (s DsgRunSensIdentifyRequest) GoString() string {
	return s.String()
}

func (s *DsgRunSensIdentifyRequest) SetEsMetaParams(v []*DsgRunSensIdentifyRequestEsMetaParams) *DsgRunSensIdentifyRequest {
	s.EsMetaParams = v
	return s
}

func (s *DsgRunSensIdentifyRequest) SetTenantId(v string) *DsgRunSensIdentifyRequest {
	s.TenantId = &v
	return s
}

type DsgRunSensIdentifyRequestEsMetaParams struct {
	ClusterId     *string   `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	DbType        *string   `json:"DbType,omitempty" xml:"DbType,omitempty"`
	InstanceId    *int64    `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	ProjectName   *string   `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	SchemaName    *string   `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	TableName     *string   `json:"TableName,omitempty" xml:"TableName,omitempty"`
	TableNameList []*string `json:"TableNameList,omitempty" xml:"TableNameList,omitempty" type:"Repeated"`
	User          *string   `json:"User,omitempty" xml:"User,omitempty"`
}

func (s DsgRunSensIdentifyRequestEsMetaParams) String() string {
	return tea.Prettify(s)
}

func (s DsgRunSensIdentifyRequestEsMetaParams) GoString() string {
	return s.String()
}

func (s *DsgRunSensIdentifyRequestEsMetaParams) SetClusterId(v string) *DsgRunSensIdentifyRequestEsMetaParams {
	s.ClusterId = &v
	return s
}

func (s *DsgRunSensIdentifyRequestEsMetaParams) SetDbType(v string) *DsgRunSensIdentifyRequestEsMetaParams {
	s.DbType = &v
	return s
}

func (s *DsgRunSensIdentifyRequestEsMetaParams) SetInstanceId(v int64) *DsgRunSensIdentifyRequestEsMetaParams {
	s.InstanceId = &v
	return s
}

func (s *DsgRunSensIdentifyRequestEsMetaParams) SetProjectName(v string) *DsgRunSensIdentifyRequestEsMetaParams {
	s.ProjectName = &v
	return s
}

func (s *DsgRunSensIdentifyRequestEsMetaParams) SetSchemaName(v string) *DsgRunSensIdentifyRequestEsMetaParams {
	s.SchemaName = &v
	return s
}

func (s *DsgRunSensIdentifyRequestEsMetaParams) SetTableName(v string) *DsgRunSensIdentifyRequestEsMetaParams {
	s.TableName = &v
	return s
}

func (s *DsgRunSensIdentifyRequestEsMetaParams) SetTableNameList(v []*string) *DsgRunSensIdentifyRequestEsMetaParams {
	s.TableNameList = v
	return s
}

func (s *DsgRunSensIdentifyRequestEsMetaParams) SetUser(v string) *DsgRunSensIdentifyRequestEsMetaParams {
	s.User = &v
	return s
}

type DsgRunSensIdentifyShrinkRequest struct {
	EsMetaParamsShrink *string `json:"EsMetaParams,omitempty" xml:"EsMetaParams,omitempty"`
	TenantId           *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s DsgRunSensIdentifyShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s DsgRunSensIdentifyShrinkRequest) GoString() string {
	return s.String()
}

func (s *DsgRunSensIdentifyShrinkRequest) SetEsMetaParamsShrink(v string) *DsgRunSensIdentifyShrinkRequest {
	s.EsMetaParamsShrink = &v
	return s
}

func (s *DsgRunSensIdentifyShrinkRequest) SetTenantId(v string) *DsgRunSensIdentifyShrinkRequest {
	s.TenantId = &v
	return s
}

type DsgRunSensIdentifyResponseBody struct {
	Data           interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string     `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32      `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DsgRunSensIdentifyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DsgRunSensIdentifyResponseBody) GoString() string {
	return s.String()
}

func (s *DsgRunSensIdentifyResponseBody) SetData(v interface{}) *DsgRunSensIdentifyResponseBody {
	s.Data = v
	return s
}

func (s *DsgRunSensIdentifyResponseBody) SetErrorCode(v string) *DsgRunSensIdentifyResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DsgRunSensIdentifyResponseBody) SetErrorMessage(v string) *DsgRunSensIdentifyResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DsgRunSensIdentifyResponseBody) SetHttpStatusCode(v int32) *DsgRunSensIdentifyResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DsgRunSensIdentifyResponseBody) SetRequestId(v string) *DsgRunSensIdentifyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DsgRunSensIdentifyResponseBody) SetSuccess(v bool) *DsgRunSensIdentifyResponseBody {
	s.Success = &v
	return s
}

type DsgRunSensIdentifyResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DsgRunSensIdentifyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DsgRunSensIdentifyResponse) String() string {
	return tea.Prettify(s)
}

func (s DsgRunSensIdentifyResponse) GoString() string {
	return s.String()
}

func (s *DsgRunSensIdentifyResponse) SetHeaders(v map[string]*string) *DsgRunSensIdentifyResponse {
	s.Headers = v
	return s
}

func (s *DsgRunSensIdentifyResponse) SetStatusCode(v int32) *DsgRunSensIdentifyResponse {
	s.StatusCode = &v
	return s
}

func (s *DsgRunSensIdentifyResponse) SetBody(v *DsgRunSensIdentifyResponseBody) *DsgRunSensIdentifyResponse {
	s.Body = v
	return s
}

type DsgStopSensIdentifyRequest struct {
	JobId    *int64  `json:"JobId,omitempty" xml:"JobId,omitempty"`
	TenantId *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s DsgStopSensIdentifyRequest) String() string {
	return tea.Prettify(s)
}

func (s DsgStopSensIdentifyRequest) GoString() string {
	return s.String()
}

func (s *DsgStopSensIdentifyRequest) SetJobId(v int64) *DsgStopSensIdentifyRequest {
	s.JobId = &v
	return s
}

func (s *DsgStopSensIdentifyRequest) SetTenantId(v string) *DsgStopSensIdentifyRequest {
	s.TenantId = &v
	return s
}

type DsgStopSensIdentifyResponseBody struct {
	Data           interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string     `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32      `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DsgStopSensIdentifyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DsgStopSensIdentifyResponseBody) GoString() string {
	return s.String()
}

func (s *DsgStopSensIdentifyResponseBody) SetData(v interface{}) *DsgStopSensIdentifyResponseBody {
	s.Data = v
	return s
}

func (s *DsgStopSensIdentifyResponseBody) SetErrorCode(v string) *DsgStopSensIdentifyResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *DsgStopSensIdentifyResponseBody) SetErrorMessage(v string) *DsgStopSensIdentifyResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DsgStopSensIdentifyResponseBody) SetHttpStatusCode(v int32) *DsgStopSensIdentifyResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *DsgStopSensIdentifyResponseBody) SetRequestId(v string) *DsgStopSensIdentifyResponseBody {
	s.RequestId = &v
	return s
}

func (s *DsgStopSensIdentifyResponseBody) SetSuccess(v bool) *DsgStopSensIdentifyResponseBody {
	s.Success = &v
	return s
}

type DsgStopSensIdentifyResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *DsgStopSensIdentifyResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s DsgStopSensIdentifyResponse) String() string {
	return tea.Prettify(s)
}

func (s DsgStopSensIdentifyResponse) GoString() string {
	return s.String()
}

func (s *DsgStopSensIdentifyResponse) SetHeaders(v map[string]*string) *DsgStopSensIdentifyResponse {
	s.Headers = v
	return s
}

func (s *DsgStopSensIdentifyResponse) SetStatusCode(v int32) *DsgStopSensIdentifyResponse {
	s.StatusCode = &v
	return s
}

func (s *DsgStopSensIdentifyResponse) SetBody(v *DsgStopSensIdentifyResponseBody) *DsgStopSensIdentifyResponse {
	s.Body = v
	return s
}

type EditRecognizeRuleRequest struct {
	AccountName          *string `json:"AccountName,omitempty" xml:"AccountName,omitempty"`
	ColExclude           *string `json:"ColExclude,omitempty" xml:"ColExclude,omitempty"`
	ColScan              *string `json:"ColScan,omitempty" xml:"ColScan,omitempty"`
	CommentScan          *string `json:"CommentScan,omitempty" xml:"CommentScan,omitempty"`
	ContentScan          *string `json:"ContentScan,omitempty" xml:"ContentScan,omitempty"`
	HitThreshold         *int32  `json:"HitThreshold,omitempty" xml:"HitThreshold,omitempty"`
	LevelName            *string `json:"LevelName,omitempty" xml:"LevelName,omitempty"`
	NodeId               *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	NodeParent           *string `json:"NodeParent,omitempty" xml:"NodeParent,omitempty"`
	OperationType        *int32  `json:"OperationType,omitempty" xml:"OperationType,omitempty"`
	RecognizeRules       *string `json:"RecognizeRules,omitempty" xml:"RecognizeRules,omitempty"`
	RecognizeRulesType   *string `json:"RecognizeRulesType,omitempty" xml:"RecognizeRulesType,omitempty"`
	SensitiveDescription *string `json:"SensitiveDescription,omitempty" xml:"SensitiveDescription,omitempty"`
	SensitiveId          *string `json:"SensitiveId,omitempty" xml:"SensitiveId,omitempty"`
	SensitiveName        *string `json:"SensitiveName,omitempty" xml:"SensitiveName,omitempty"`
	Status               *int32  `json:"Status,omitempty" xml:"Status,omitempty"`
	TemplateId           *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	TenantId             *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	Level                *string `json:"level,omitempty" xml:"level,omitempty"`
}

func (s EditRecognizeRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s EditRecognizeRuleRequest) GoString() string {
	return s.String()
}

func (s *EditRecognizeRuleRequest) SetAccountName(v string) *EditRecognizeRuleRequest {
	s.AccountName = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetColExclude(v string) *EditRecognizeRuleRequest {
	s.ColExclude = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetColScan(v string) *EditRecognizeRuleRequest {
	s.ColScan = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetCommentScan(v string) *EditRecognizeRuleRequest {
	s.CommentScan = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetContentScan(v string) *EditRecognizeRuleRequest {
	s.ContentScan = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetHitThreshold(v int32) *EditRecognizeRuleRequest {
	s.HitThreshold = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetLevelName(v string) *EditRecognizeRuleRequest {
	s.LevelName = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetNodeId(v string) *EditRecognizeRuleRequest {
	s.NodeId = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetNodeParent(v string) *EditRecognizeRuleRequest {
	s.NodeParent = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetOperationType(v int32) *EditRecognizeRuleRequest {
	s.OperationType = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetRecognizeRules(v string) *EditRecognizeRuleRequest {
	s.RecognizeRules = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetRecognizeRulesType(v string) *EditRecognizeRuleRequest {
	s.RecognizeRulesType = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetSensitiveDescription(v string) *EditRecognizeRuleRequest {
	s.SensitiveDescription = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetSensitiveId(v string) *EditRecognizeRuleRequest {
	s.SensitiveId = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetSensitiveName(v string) *EditRecognizeRuleRequest {
	s.SensitiveName = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetStatus(v int32) *EditRecognizeRuleRequest {
	s.Status = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetTemplateId(v string) *EditRecognizeRuleRequest {
	s.TemplateId = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetTenantId(v string) *EditRecognizeRuleRequest {
	s.TenantId = &v
	return s
}

func (s *EditRecognizeRuleRequest) SetLevel(v string) *EditRecognizeRuleRequest {
	s.Level = &v
	return s
}

type EditRecognizeRuleResponseBody struct {
	Data           interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string     `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32      `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s EditRecognizeRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EditRecognizeRuleResponseBody) GoString() string {
	return s.String()
}

func (s *EditRecognizeRuleResponseBody) SetData(v interface{}) *EditRecognizeRuleResponseBody {
	s.Data = v
	return s
}

func (s *EditRecognizeRuleResponseBody) SetErrorCode(v string) *EditRecognizeRuleResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *EditRecognizeRuleResponseBody) SetErrorMessage(v string) *EditRecognizeRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *EditRecognizeRuleResponseBody) SetHttpStatusCode(v int32) *EditRecognizeRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *EditRecognizeRuleResponseBody) SetRequestId(v string) *EditRecognizeRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *EditRecognizeRuleResponseBody) SetSuccess(v bool) *EditRecognizeRuleResponseBody {
	s.Success = &v
	return s
}

type EditRecognizeRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EditRecognizeRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EditRecognizeRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s EditRecognizeRuleResponse) GoString() string {
	return s.String()
}

func (s *EditRecognizeRuleResponse) SetHeaders(v map[string]*string) *EditRecognizeRuleResponse {
	s.Headers = v
	return s
}

func (s *EditRecognizeRuleResponse) SetStatusCode(v int32) *EditRecognizeRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *EditRecognizeRuleResponse) SetBody(v *EditRecognizeRuleResponseBody) *EditRecognizeRuleResponse {
	s.Body = v
	return s
}

type EstablishRelationTableToBusinessRequest struct {
	// The ID of the workflow. You can call the [ListBusiness](~~173945~~) operation to query the ID.
	BusinessId *string `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	// The ID of the folder. You can call the [GetFolder](~~173952~~) or [ListFolders](~~173955~~) operation to query the ID.
	FolderId *string `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The ID of the DataWorks workspace. You can click the Workspace Manage icon in the upper-right corner of the DataStudio page to go to the Workspace Management page and view the workspace ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The unique identifier of the DataWorks workspace. You can click the identifier in the upper-left corner of the DataStudio page to switch to another workspace.
	//
	// You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
	// The universally unique identifier (UUID) of the table. You can call the [SearchMetaTables](~~173919~~) operation to query the UUID.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
}

func (s EstablishRelationTableToBusinessRequest) String() string {
	return tea.Prettify(s)
}

func (s EstablishRelationTableToBusinessRequest) GoString() string {
	return s.String()
}

func (s *EstablishRelationTableToBusinessRequest) SetBusinessId(v string) *EstablishRelationTableToBusinessRequest {
	s.BusinessId = &v
	return s
}

func (s *EstablishRelationTableToBusinessRequest) SetFolderId(v string) *EstablishRelationTableToBusinessRequest {
	s.FolderId = &v
	return s
}

func (s *EstablishRelationTableToBusinessRequest) SetProjectId(v int64) *EstablishRelationTableToBusinessRequest {
	s.ProjectId = &v
	return s
}

func (s *EstablishRelationTableToBusinessRequest) SetProjectIdentifier(v string) *EstablishRelationTableToBusinessRequest {
	s.ProjectIdentifier = &v
	return s
}

func (s *EstablishRelationTableToBusinessRequest) SetTableGuid(v string) *EstablishRelationTableToBusinessRequest {
	s.TableGuid = &v
	return s
}

type EstablishRelationTableToBusinessResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s EstablishRelationTableToBusinessResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EstablishRelationTableToBusinessResponseBody) GoString() string {
	return s.String()
}

func (s *EstablishRelationTableToBusinessResponseBody) SetErrorCode(v string) *EstablishRelationTableToBusinessResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *EstablishRelationTableToBusinessResponseBody) SetErrorMessage(v string) *EstablishRelationTableToBusinessResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *EstablishRelationTableToBusinessResponseBody) SetHttpStatusCode(v int32) *EstablishRelationTableToBusinessResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *EstablishRelationTableToBusinessResponseBody) SetRequestId(v string) *EstablishRelationTableToBusinessResponseBody {
	s.RequestId = &v
	return s
}

func (s *EstablishRelationTableToBusinessResponseBody) SetSuccess(v bool) *EstablishRelationTableToBusinessResponseBody {
	s.Success = &v
	return s
}

type EstablishRelationTableToBusinessResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *EstablishRelationTableToBusinessResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s EstablishRelationTableToBusinessResponse) String() string {
	return tea.Prettify(s)
}

func (s EstablishRelationTableToBusinessResponse) GoString() string {
	return s.String()
}

func (s *EstablishRelationTableToBusinessResponse) SetHeaders(v map[string]*string) *EstablishRelationTableToBusinessResponse {
	s.Headers = v
	return s
}

func (s *EstablishRelationTableToBusinessResponse) SetStatusCode(v int32) *EstablishRelationTableToBusinessResponse {
	s.StatusCode = &v
	return s
}

func (s *EstablishRelationTableToBusinessResponse) SetBody(v *EstablishRelationTableToBusinessResponseBody) *EstablishRelationTableToBusinessResponse {
	s.Body = v
	return s
}

type ExportDataSourcesRequest struct {
	// The data source type. Valid values:
	//
	// *   odps
	// *   mysql
	// *   rds
	// *   oss
	// *   sqlserver
	// *   polardb
	// *   oracle
	// *   mongodb
	// *   emr
	// *   postgresql
	// *   analyticdb_for_mysql
	// *   hybriddb_for_postgresql
	// *   holo
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The environment to which the data sources belong. Valid values:
	//
	// *   0: development environment
	// *   1: production environment
	EnvType *int32 `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The keyword contained in the names of the data sources to be exported.
	//
	// You can specify only one keyword. For example, if you set this parameter to test, all the data sources whose names contain test in the specified workspace are exported.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of the page to return. The value of this parameter must be a positive integer greater than or equal to 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the DataWorks workspace to which the data sources belong. You can call the [ListProjects](~~178393~~) operation to query the ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The data source subtype. This parameter takes effect only if the DataSourceType parameter is set to rds.
	//
	// If the DataSourceType parameter is set to rds, this parameter can be set to mysql, sqlserver, or postgresql.
	SubType *string `json:"SubType,omitempty" xml:"SubType,omitempty"`
}

func (s ExportDataSourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ExportDataSourcesRequest) GoString() string {
	return s.String()
}

func (s *ExportDataSourcesRequest) SetDataSourceType(v string) *ExportDataSourcesRequest {
	s.DataSourceType = &v
	return s
}

func (s *ExportDataSourcesRequest) SetEnvType(v int32) *ExportDataSourcesRequest {
	s.EnvType = &v
	return s
}

func (s *ExportDataSourcesRequest) SetName(v string) *ExportDataSourcesRequest {
	s.Name = &v
	return s
}

func (s *ExportDataSourcesRequest) SetPageNumber(v int32) *ExportDataSourcesRequest {
	s.PageNumber = &v
	return s
}

func (s *ExportDataSourcesRequest) SetPageSize(v int32) *ExportDataSourcesRequest {
	s.PageSize = &v
	return s
}

func (s *ExportDataSourcesRequest) SetProjectId(v int64) *ExportDataSourcesRequest {
	s.ProjectId = &v
	return s
}

func (s *ExportDataSourcesRequest) SetSubType(v string) *ExportDataSourcesRequest {
	s.SubType = &v
	return s
}

type ExportDataSourcesResponseBody struct {
	// The information about the export operation.
	Data *ExportDataSourcesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned. Valid values:
	//
	// *   200: The request was successful.
	// *   Other values: The request failed. You can troubleshoot issues based on the HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ExportDataSourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ExportDataSourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ExportDataSourcesResponseBody) SetData(v *ExportDataSourcesResponseBodyData) *ExportDataSourcesResponseBody {
	s.Data = v
	return s
}

func (s *ExportDataSourcesResponseBody) SetHttpStatusCode(v int32) *ExportDataSourcesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ExportDataSourcesResponseBody) SetRequestId(v string) *ExportDataSourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ExportDataSourcesResponseBody) SetSuccess(v bool) *ExportDataSourcesResponseBody {
	s.Success = &v
	return s
}

type ExportDataSourcesResponseBodyData struct {
	// The details of the exported data sources.
	//
	// The value is an array. The following parameters are the elements in the array. The sample values of these parameters show the details of a sample data source.
	DataSources []*ExportDataSourcesResponseBodyDataDataSources `json:"DataSources,omitempty" xml:"DataSources,omitempty" type:"Repeated"`
	// The page number of the returned page. The value of this parameter is a positive integer greater than or equal to 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ExportDataSourcesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ExportDataSourcesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ExportDataSourcesResponseBodyData) SetDataSources(v []*ExportDataSourcesResponseBodyDataDataSources) *ExportDataSourcesResponseBodyData {
	s.DataSources = v
	return s
}

func (s *ExportDataSourcesResponseBodyData) SetPageNumber(v int32) *ExportDataSourcesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ExportDataSourcesResponseBodyData) SetPageSize(v int32) *ExportDataSourcesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ExportDataSourcesResponseBodyData) SetTotalCount(v int32) *ExportDataSourcesResponseBodyData {
	s.TotalCount = &v
	return s
}

type ExportDataSourcesResponseBodyDataDataSources struct {
	// The ID of the compute engine to which the data source is bound.
	BindingCalcEngineId *int32 `json:"BindingCalcEngineId,omitempty" xml:"BindingCalcEngineId,omitempty"`
	// Indicates whether the data source is connected to an exclusive resource group. Valid values:
	//
	// *   1: The data source is connected to at least one exclusive resource group.
	// *   0: The data source is not connected to any exclusive resource group.
	ConnectStatus *int32 `json:"ConnectStatus,omitempty" xml:"ConnectStatus,omitempty"`
	// The configuration of the data source.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The type of the data source. Valid values:
	//
	// *   odps
	// *   mysql
	// *   rds
	// *   oss
	// *   sqlserver
	// *   polardb
	// *   oracle
	// *   mongodb
	// *   emr
	// *   postgresql
	// *   analyticdb_for_mysql
	// *   hybriddb_for_postgresql
	// *   holo
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// Indicates whether the compute engine to which the data source is bound is the default compute engine. Valid values:
	//
	// *   true: The compute engine is the default compute engine.
	// *   false: The compute engine is not the default compute engine.
	DefaultEngine *bool `json:"DefaultEngine,omitempty" xml:"DefaultEngine,omitempty"`
	// The description of the data source.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The environment to which the data source belongs. Valid values:
	//
	// *   0: development environment
	// *   1: production environment
	EnvType *int32 `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The time when the data source was created. Example: Mar 17, 2021 4:09:32 PM.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the data source was last modified. Example: Mar 17, 2021 4:09:32 PM.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the data source.
	Id *int32 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the data source.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the user who exported the data source.
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The ID of the DataWorks workspace to which the data source belongs.
	ProjectId *int32 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The sequence number of the data source.
	Sequence *int32 `json:"Sequence,omitempty" xml:"Sequence,omitempty"`
	// Indicates whether the data source can be shared. Valid values:
	//
	// *   true: The data source can be shared.
	// *   false: The data source cannot be shared.
	Shared *bool `json:"Shared,omitempty" xml:"Shared,omitempty"`
	// Indicates whether the data source is available. Valid values:
	//
	// *   1: The data source is available.
	// *   0: The data source is unavailable.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The subtype of the data source. This parameter is returned only if the value of the DataSourceType parameter is rds.
	//
	// If the value of the DataSourceType parameter is rds, the value of this parameter can be mysql, sqlserver, or postgresql.
	SubType *string `json:"SubType,omitempty" xml:"SubType,omitempty"`
	// The ID of the Alibaba Cloud account to which the data source belongs.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ExportDataSourcesResponseBodyDataDataSources) String() string {
	return tea.Prettify(s)
}

func (s ExportDataSourcesResponseBodyDataDataSources) GoString() string {
	return s.String()
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetBindingCalcEngineId(v int32) *ExportDataSourcesResponseBodyDataDataSources {
	s.BindingCalcEngineId = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetConnectStatus(v int32) *ExportDataSourcesResponseBodyDataDataSources {
	s.ConnectStatus = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetContent(v string) *ExportDataSourcesResponseBodyDataDataSources {
	s.Content = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetDataSourceType(v string) *ExportDataSourcesResponseBodyDataDataSources {
	s.DataSourceType = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetDefaultEngine(v bool) *ExportDataSourcesResponseBodyDataDataSources {
	s.DefaultEngine = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetDescription(v string) *ExportDataSourcesResponseBodyDataDataSources {
	s.Description = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetEnvType(v int32) *ExportDataSourcesResponseBodyDataDataSources {
	s.EnvType = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetGmtCreate(v string) *ExportDataSourcesResponseBodyDataDataSources {
	s.GmtCreate = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetGmtModified(v string) *ExportDataSourcesResponseBodyDataDataSources {
	s.GmtModified = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetId(v int32) *ExportDataSourcesResponseBodyDataDataSources {
	s.Id = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetName(v string) *ExportDataSourcesResponseBodyDataDataSources {
	s.Name = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetOperator(v string) *ExportDataSourcesResponseBodyDataDataSources {
	s.Operator = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetProjectId(v int32) *ExportDataSourcesResponseBodyDataDataSources {
	s.ProjectId = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetSequence(v int32) *ExportDataSourcesResponseBodyDataDataSources {
	s.Sequence = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetShared(v bool) *ExportDataSourcesResponseBodyDataDataSources {
	s.Shared = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetStatus(v int32) *ExportDataSourcesResponseBodyDataDataSources {
	s.Status = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetSubType(v string) *ExportDataSourcesResponseBodyDataDataSources {
	s.SubType = &v
	return s
}

func (s *ExportDataSourcesResponseBodyDataDataSources) SetTenantId(v int64) *ExportDataSourcesResponseBodyDataDataSources {
	s.TenantId = &v
	return s
}

type ExportDataSourcesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ExportDataSourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ExportDataSourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ExportDataSourcesResponse) GoString() string {
	return s.String()
}

func (s *ExportDataSourcesResponse) SetHeaders(v map[string]*string) *ExportDataSourcesResponse {
	s.Headers = v
	return s
}

func (s *ExportDataSourcesResponse) SetStatusCode(v int32) *ExportDataSourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ExportDataSourcesResponse) SetBody(v *ExportDataSourcesResponseBody) *ExportDataSourcesResponse {
	s.Body = v
	return s
}

type GenerateDISyncTaskConfigForCreatingRequest struct {
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The type of the object that you want to create in Data Integration in asynchronous mode. Valid values:
	//
	// *   DI_REALTIME: real-time synchronization node
	// *   DI_SOLUTION: synchronization solution
	//
	// DataWorks allows you to create real-time synchronization nodes and synchronization solutions in Data Integration only in asynchronous mode.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. This parameter is used to prevent repeated operations that are caused by multiple calls.
	TaskParam *string `json:"TaskParam,omitempty" xml:"TaskParam,omitempty"`
	// The script for the real-time synchronization node or synchronization solution in Data Integration.
	//
	// The following types of real-time synchronization nodes and synchronization solutions are supported:
	//
	// *   Real-time synchronization node or synchronization solution that is used to synchronize data from MySQL to MaxCompute
	// *   Real-time synchronization node or synchronization solution that is used to synchronize data from MySQL data to Kafka
	// *   Real-time synchronization node or synchronization solution that is used to synchronize data from MySQL to Hologres
	//
	// The SelectedTables parameter is used to specify tables that you want to synchronize from multiple databases. The Tables parameter is used to specify tables that you want to synchronize from a single database.
	//
	// *   If the script contains the SelectedTables parameter, the system synchronizes the tables that you specify in the SelectedTables parameter.
	// *   If the script contains the Tables parameter, the system synchronizes the tables that you specify in the Tables parameter.
	//
	// The following sample code provides a script for data synchronization from MySQL to MaxCompute:
	//
	// {
	//
	// "type": "realtime",
	//
	// "version": "1.0",
	//
	// "setting": {
	//
	// "resourceGroup": "S_res_group\_280749521950784\_1623033752022",
	//
	// "taskType": "oneclick_to_odps"
	//
	// },
	//
	// "steps": { "stepType": "mysql", "parameter": { "connection": \[ { "datasourceType": "mysql", "datasource": "mysql_pub1", "selectedTables": \[ { "dbName": "mysql_db", "schema": \[ { "tableInfos": \[ { "table": "molin_di_test_in_pk_v4" }
	//
	// }
	//
	// ]
	//
	// }
	//
	// ]
	//
	// }
	//
	// ]
	//
	// },
	//
	// "name": "Reader",
	//
	// "category": "reader"
	//
	// },
	//
	// {
	//
	// "stepType": "odps",
	//
	// "parameter": {
	//
	// "datasource": "odps_first"
	//
	// },
	//
	// "name": "Writer",
	//
	// "category": "writer"
	//
	// }
	//
	// ]
	//
	// }
	//
	// The following sample code provides a script for data synchronization from MySQL to Kafka:
	//
	// {
	//
	// "type": "realtime",
	//
	// "version": "1.0",
	//
	// "setting": {
	//
	// "resourceGroup": "S_res_group\_280749521950784\_1623033752022",
	//
	// "taskType": "oneclick_to_kafka"
	//
	// },
	//
	// "steps": { "stepType": "mysql", "parameter": { "connection": \[ { "datasourceType": "mysql", "datasource": "pkset_test", "selectedTables": \[ { "dbName": "mysql_db", "schema": \[ { "tableInfos": \[ { "table": "molin_di_test_in_pk_v4" }
	//
	// }
	//
	// ]
	//
	// }
	//
	// ]
	//
	// }
	//
	// ]
	//
	// },
	//
	// "name": "Reader",
	//
	// "category": "reader"
	//
	// },
	//
	// {
	//
	// "stepType": "kafka",
	//
	// "parameter": {
	//
	// "datasource": "azn_kafka"
	//
	// },
	//
	// "name": "Writer",
	//
	// "category": "writer"
	//
	// }
	//
	// ]
	//
	// }
	//
	// The following sample code provides a script for data synchronization from MySQL to Hologres:
	//
	// {
	//
	// "type": "realtime",
	//
	// "version": "1.0",
	//
	// "setting": {
	//
	// "resourceGroup": "S_res_group\_280749521950784\_1623033752022",
	//
	// "taskType": "oneclick_to_holo"
	//
	// },
	//
	// "steps": { "stepType": "mysql", "parameter": { "connection": \[ { "datasourceType": "mysql", "datasource": "mysql_pub", "selectedTables": \[ { "dbName": "mysql_db", "schema": \[ { "tableInfos": \[ { "table": "molin_di_test_in2\_pk_v3" }
	//
	// }
	//
	// ]
	//
	// }
	//
	// ]
	//
	// }
	//
	// ]
	//
	// },
	//
	// "name": "Reader",
	//
	// "category": "reader"
	//
	// },
	//
	// {
	//
	// "stepType": "holo",
	//
	// "parameter": {
	//
	// "datasource": "holo"
	//
	// },
	//
	// "name": "Writer",
	//
	// "category": "writer"
	//
	// }
	//
	// ]
	//
	// }
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s GenerateDISyncTaskConfigForCreatingRequest) String() string {
	return tea.Prettify(s)
}

func (s GenerateDISyncTaskConfigForCreatingRequest) GoString() string {
	return s.String()
}

func (s *GenerateDISyncTaskConfigForCreatingRequest) SetClientToken(v string) *GenerateDISyncTaskConfigForCreatingRequest {
	s.ClientToken = &v
	return s
}

func (s *GenerateDISyncTaskConfigForCreatingRequest) SetProjectId(v int64) *GenerateDISyncTaskConfigForCreatingRequest {
	s.ProjectId = &v
	return s
}

func (s *GenerateDISyncTaskConfigForCreatingRequest) SetTaskParam(v string) *GenerateDISyncTaskConfigForCreatingRequest {
	s.TaskParam = &v
	return s
}

func (s *GenerateDISyncTaskConfigForCreatingRequest) SetTaskType(v string) *GenerateDISyncTaskConfigForCreatingRequest {
	s.TaskType = &v
	return s
}

type GenerateDISyncTaskConfigForCreatingResponseBody struct {
	// Indicates whether the ID of the asynchronous thread is generated. Valid values:
	//
	// *   success: indicates that the ID of the asynchronous thread is generated.
	// *   fail: indicates that the ID of the asynchronous thread fails to be generated. You can view the reason for the failure and troubleshoot the issue based on the reason.
	Data *GenerateDISyncTaskConfigForCreatingResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The information returned for the ID of the asynchronous thread.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GenerateDISyncTaskConfigForCreatingResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GenerateDISyncTaskConfigForCreatingResponseBody) GoString() string {
	return s.String()
}

func (s *GenerateDISyncTaskConfigForCreatingResponseBody) SetData(v *GenerateDISyncTaskConfigForCreatingResponseBodyData) *GenerateDISyncTaskConfigForCreatingResponseBody {
	s.Data = v
	return s
}

func (s *GenerateDISyncTaskConfigForCreatingResponseBody) SetRequestId(v string) *GenerateDISyncTaskConfigForCreatingResponseBody {
	s.RequestId = &v
	return s
}

func (s *GenerateDISyncTaskConfigForCreatingResponseBody) SetSuccess(v bool) *GenerateDISyncTaskConfigForCreatingResponseBody {
	s.Success = &v
	return s
}

type GenerateDISyncTaskConfigForCreatingResponseBodyData struct {
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The reason why the ID of the asynchronous thread fails to be generated.
	//
	// If the ID is successfully generated, the value null is returned.
	ProcessId *int64 `json:"ProcessId,omitempty" xml:"ProcessId,omitempty"`
	// The ID of the asynchronous thread. You can call the [QueryDISyncTaskConfigProcessResult](~~383465~~) operation to obtain the asynchronously generated parameters based on the ID. The parameters are used to create a real-time synchronization node or a synchronization solution in Data Integration.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GenerateDISyncTaskConfigForCreatingResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GenerateDISyncTaskConfigForCreatingResponseBodyData) GoString() string {
	return s.String()
}

func (s *GenerateDISyncTaskConfigForCreatingResponseBodyData) SetMessage(v string) *GenerateDISyncTaskConfigForCreatingResponseBodyData {
	s.Message = &v
	return s
}

func (s *GenerateDISyncTaskConfigForCreatingResponseBodyData) SetProcessId(v int64) *GenerateDISyncTaskConfigForCreatingResponseBodyData {
	s.ProcessId = &v
	return s
}

func (s *GenerateDISyncTaskConfigForCreatingResponseBodyData) SetStatus(v string) *GenerateDISyncTaskConfigForCreatingResponseBodyData {
	s.Status = &v
	return s
}

type GenerateDISyncTaskConfigForCreatingResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GenerateDISyncTaskConfigForCreatingResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GenerateDISyncTaskConfigForCreatingResponse) String() string {
	return tea.Prettify(s)
}

func (s GenerateDISyncTaskConfigForCreatingResponse) GoString() string {
	return s.String()
}

func (s *GenerateDISyncTaskConfigForCreatingResponse) SetHeaders(v map[string]*string) *GenerateDISyncTaskConfigForCreatingResponse {
	s.Headers = v
	return s
}

func (s *GenerateDISyncTaskConfigForCreatingResponse) SetStatusCode(v int32) *GenerateDISyncTaskConfigForCreatingResponse {
	s.StatusCode = &v
	return s
}

func (s *GenerateDISyncTaskConfigForCreatingResponse) SetBody(v *GenerateDISyncTaskConfigForCreatingResponseBody) *GenerateDISyncTaskConfigForCreatingResponse {
	s.Body = v
	return s
}

type GenerateDISyncTaskConfigForUpdatingRequest struct {
	// The ID of the real-time synchronization node or synchronization solution.
	//
	// *   If you set the TaskType parameter to DI_REALTIME, set the TaskId parameter to the value of the FileId parameter for the real-time synchronization node.
	// *   If you set the TaskType parameter to DI_SOLUTION, set the TaskId parameter to the value of the FileId parameter for the synchronization solution.
	ClientToken *string `json:"ClientToken,omitempty" xml:"ClientToken,omitempty"`
	// The type of the object that you want to update in Data Integration in asynchronous mode. Valid values:
	//
	// *   DI_REALTIME: real-time synchronization node
	//
	// *   DI_SOLUTION: synchronization solution
	//
	//     DataWorks allows you to update real-time synchronization nodes and synchronization solutions in Data Integration only in asynchronous mode.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	TaskId *int64 `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The client token that is used to ensure the idempotence of the request. This parameter is used to prevent repeated operations that are caused by multiple calls.
	TaskParam *string `json:"TaskParam,omitempty" xml:"TaskParam,omitempty"`
	// The script for updating the real-time synchronization node or synchronization solution in Data Integration.
	//
	// DataWorks allows you to add or remove tables for a real-time synchronization node or a synchronization solution in Data Integration only in asynchronous mode. The following types of real-time synchronization nodes and synchronization solutions are supported:
	//
	// *   Real-time synchronization node or synchronization solution that is used to synchronize data from MySQL to MaxCompute
	// *   Real-time synchronization node or synchronization solution that is used to synchronize data from MySQL data to Kafka
	// *   Real-time synchronization node or synchronization solution that is used to synchronize data from MySQL to Hologres
	//
	// The SelectedTables parameter is used to specify tables that you want to synchronize from multiple databases. The Tables parameter is used to specify tables that you want to synchronize from a single database.
	//
	// *   If the script contains the SelectedTables parameter, the system synchronizes the tables that you specify in the SelectedTables parameter.
	// *   If the script contains the Tables parameter, the system synchronizes the tables that you specify in the Tables parameter.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s GenerateDISyncTaskConfigForUpdatingRequest) String() string {
	return tea.Prettify(s)
}

func (s GenerateDISyncTaskConfigForUpdatingRequest) GoString() string {
	return s.String()
}

func (s *GenerateDISyncTaskConfigForUpdatingRequest) SetClientToken(v string) *GenerateDISyncTaskConfigForUpdatingRequest {
	s.ClientToken = &v
	return s
}

func (s *GenerateDISyncTaskConfigForUpdatingRequest) SetProjectId(v int64) *GenerateDISyncTaskConfigForUpdatingRequest {
	s.ProjectId = &v
	return s
}

func (s *GenerateDISyncTaskConfigForUpdatingRequest) SetTaskId(v int64) *GenerateDISyncTaskConfigForUpdatingRequest {
	s.TaskId = &v
	return s
}

func (s *GenerateDISyncTaskConfigForUpdatingRequest) SetTaskParam(v string) *GenerateDISyncTaskConfigForUpdatingRequest {
	s.TaskParam = &v
	return s
}

func (s *GenerateDISyncTaskConfigForUpdatingRequest) SetTaskType(v string) *GenerateDISyncTaskConfigForUpdatingRequest {
	s.TaskType = &v
	return s
}

type GenerateDISyncTaskConfigForUpdatingResponseBody struct {
	// Indicates whether the ID of the asynchronous thread is generated. Valid values:
	//
	// *   success: indicates that the ID of the asynchronous thread is generated.
	// *   fail: indicates that the ID of the asynchronous thread fails to be generated. You can view the reason for the failure and troubleshoot the issue based on the reason.
	Data *GenerateDISyncTaskConfigForUpdatingResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The information returned for the ID of the asynchronous thread.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GenerateDISyncTaskConfigForUpdatingResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GenerateDISyncTaskConfigForUpdatingResponseBody) GoString() string {
	return s.String()
}

func (s *GenerateDISyncTaskConfigForUpdatingResponseBody) SetData(v *GenerateDISyncTaskConfigForUpdatingResponseBodyData) *GenerateDISyncTaskConfigForUpdatingResponseBody {
	s.Data = v
	return s
}

func (s *GenerateDISyncTaskConfigForUpdatingResponseBody) SetRequestId(v string) *GenerateDISyncTaskConfigForUpdatingResponseBody {
	s.RequestId = &v
	return s
}

func (s *GenerateDISyncTaskConfigForUpdatingResponseBody) SetSuccess(v bool) *GenerateDISyncTaskConfigForUpdatingResponseBody {
	s.Success = &v
	return s
}

type GenerateDISyncTaskConfigForUpdatingResponseBodyData struct {
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The reason why the ID of the asynchronous thread fails to be generated. If the ID is successfully generated, the value null is returned.
	ProcessId *int64 `json:"ProcessId,omitempty" xml:"ProcessId,omitempty"`
	// The ID of the asynchronous thread. You can call the [QueryDISyncTaskConfigProcessResult](~~383465~~) operation to obtain the asynchronously generated parameters based on the ID. The parameters are used to update a real-time synchronization node or a synchronization solution in Data Integration.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GenerateDISyncTaskConfigForUpdatingResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GenerateDISyncTaskConfigForUpdatingResponseBodyData) GoString() string {
	return s.String()
}

func (s *GenerateDISyncTaskConfigForUpdatingResponseBodyData) SetMessage(v string) *GenerateDISyncTaskConfigForUpdatingResponseBodyData {
	s.Message = &v
	return s
}

func (s *GenerateDISyncTaskConfigForUpdatingResponseBodyData) SetProcessId(v int64) *GenerateDISyncTaskConfigForUpdatingResponseBodyData {
	s.ProcessId = &v
	return s
}

func (s *GenerateDISyncTaskConfigForUpdatingResponseBodyData) SetStatus(v string) *GenerateDISyncTaskConfigForUpdatingResponseBodyData {
	s.Status = &v
	return s
}

type GenerateDISyncTaskConfigForUpdatingResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GenerateDISyncTaskConfigForUpdatingResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GenerateDISyncTaskConfigForUpdatingResponse) String() string {
	return tea.Prettify(s)
}

func (s GenerateDISyncTaskConfigForUpdatingResponse) GoString() string {
	return s.String()
}

func (s *GenerateDISyncTaskConfigForUpdatingResponse) SetHeaders(v map[string]*string) *GenerateDISyncTaskConfigForUpdatingResponse {
	s.Headers = v
	return s
}

func (s *GenerateDISyncTaskConfigForUpdatingResponse) SetStatusCode(v int32) *GenerateDISyncTaskConfigForUpdatingResponse {
	s.StatusCode = &v
	return s
}

func (s *GenerateDISyncTaskConfigForUpdatingResponse) SetBody(v *GenerateDISyncTaskConfigForUpdatingResponseBody) *GenerateDISyncTaskConfigForUpdatingResponse {
	s.Body = v
	return s
}

type GetAlertMessageRequest struct {
	AlertId *string `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
}

func (s GetAlertMessageRequest) String() string {
	return tea.Prettify(s)
}

func (s GetAlertMessageRequest) GoString() string {
	return s.String()
}

func (s *GetAlertMessageRequest) SetAlertId(v string) *GetAlertMessageRequest {
	s.AlertId = &v
	return s
}

type GetAlertMessageResponseBody struct {
	Data           *GetAlertMessageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorCode      *string                          `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string                          `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32                           `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string                          `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                            `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetAlertMessageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetAlertMessageResponseBody) GoString() string {
	return s.String()
}

func (s *GetAlertMessageResponseBody) SetData(v *GetAlertMessageResponseBodyData) *GetAlertMessageResponseBody {
	s.Data = v
	return s
}

func (s *GetAlertMessageResponseBody) SetErrorCode(v string) *GetAlertMessageResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetAlertMessageResponseBody) SetErrorMessage(v string) *GetAlertMessageResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetAlertMessageResponseBody) SetHttpStatusCode(v int32) *GetAlertMessageResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetAlertMessageResponseBody) SetRequestId(v string) *GetAlertMessageResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetAlertMessageResponseBody) SetSuccess(v bool) *GetAlertMessageResponseBody {
	s.Success = &v
	return s
}

type GetAlertMessageResponseBodyData struct {
	AlertId            *int64                                      `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	AlertMessageStatus *string                                     `json:"AlertMessageStatus,omitempty" xml:"AlertMessageStatus,omitempty"`
	AlertMethod        *string                                     `json:"AlertMethod,omitempty" xml:"AlertMethod,omitempty"`
	AlertTime          *int64                                      `json:"AlertTime,omitempty" xml:"AlertTime,omitempty"`
	AlertUser          *string                                     `json:"AlertUser,omitempty" xml:"AlertUser,omitempty"`
	Content            *string                                     `json:"Content,omitempty" xml:"Content,omitempty"`
	Instances          []*GetAlertMessageResponseBodyDataInstances `json:"Instances,omitempty" xml:"Instances,omitempty" type:"Repeated"`
	Nodes              []*GetAlertMessageResponseBodyDataNodes     `json:"Nodes,omitempty" xml:"Nodes,omitempty" type:"Repeated"`
	RemindId           *int64                                      `json:"RemindId,omitempty" xml:"RemindId,omitempty"`
	RemindName         *string                                     `json:"RemindName,omitempty" xml:"RemindName,omitempty"`
	SlaAlert           *GetAlertMessageResponseBodyDataSlaAlert    `json:"SlaAlert,omitempty" xml:"SlaAlert,omitempty" type:"Struct"`
	Source             *string                                     `json:"Source,omitempty" xml:"Source,omitempty"`
	Topics             []*GetAlertMessageResponseBodyDataTopics    `json:"Topics,omitempty" xml:"Topics,omitempty" type:"Repeated"`
}

func (s GetAlertMessageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetAlertMessageResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetAlertMessageResponseBodyData) SetAlertId(v int64) *GetAlertMessageResponseBodyData {
	s.AlertId = &v
	return s
}

func (s *GetAlertMessageResponseBodyData) SetAlertMessageStatus(v string) *GetAlertMessageResponseBodyData {
	s.AlertMessageStatus = &v
	return s
}

func (s *GetAlertMessageResponseBodyData) SetAlertMethod(v string) *GetAlertMessageResponseBodyData {
	s.AlertMethod = &v
	return s
}

func (s *GetAlertMessageResponseBodyData) SetAlertTime(v int64) *GetAlertMessageResponseBodyData {
	s.AlertTime = &v
	return s
}

func (s *GetAlertMessageResponseBodyData) SetAlertUser(v string) *GetAlertMessageResponseBodyData {
	s.AlertUser = &v
	return s
}

func (s *GetAlertMessageResponseBodyData) SetContent(v string) *GetAlertMessageResponseBodyData {
	s.Content = &v
	return s
}

func (s *GetAlertMessageResponseBodyData) SetInstances(v []*GetAlertMessageResponseBodyDataInstances) *GetAlertMessageResponseBodyData {
	s.Instances = v
	return s
}

func (s *GetAlertMessageResponseBodyData) SetNodes(v []*GetAlertMessageResponseBodyDataNodes) *GetAlertMessageResponseBodyData {
	s.Nodes = v
	return s
}

func (s *GetAlertMessageResponseBodyData) SetRemindId(v int64) *GetAlertMessageResponseBodyData {
	s.RemindId = &v
	return s
}

func (s *GetAlertMessageResponseBodyData) SetRemindName(v string) *GetAlertMessageResponseBodyData {
	s.RemindName = &v
	return s
}

func (s *GetAlertMessageResponseBodyData) SetSlaAlert(v *GetAlertMessageResponseBodyDataSlaAlert) *GetAlertMessageResponseBodyData {
	s.SlaAlert = v
	return s
}

func (s *GetAlertMessageResponseBodyData) SetSource(v string) *GetAlertMessageResponseBodyData {
	s.Source = &v
	return s
}

func (s *GetAlertMessageResponseBodyData) SetTopics(v []*GetAlertMessageResponseBodyDataTopics) *GetAlertMessageResponseBodyData {
	s.Topics = v
	return s
}

type GetAlertMessageResponseBodyDataInstances struct {
	InstanceId *int64  `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	NodeId     *int64  `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	NodeName   *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	ProjectId  *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	Status     *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetAlertMessageResponseBodyDataInstances) String() string {
	return tea.Prettify(s)
}

func (s GetAlertMessageResponseBodyDataInstances) GoString() string {
	return s.String()
}

func (s *GetAlertMessageResponseBodyDataInstances) SetInstanceId(v int64) *GetAlertMessageResponseBodyDataInstances {
	s.InstanceId = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataInstances) SetNodeId(v int64) *GetAlertMessageResponseBodyDataInstances {
	s.NodeId = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataInstances) SetNodeName(v string) *GetAlertMessageResponseBodyDataInstances {
	s.NodeName = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataInstances) SetProjectId(v int64) *GetAlertMessageResponseBodyDataInstances {
	s.ProjectId = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataInstances) SetStatus(v string) *GetAlertMessageResponseBodyDataInstances {
	s.Status = &v
	return s
}

type GetAlertMessageResponseBodyDataNodes struct {
	NodeId    *int64  `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	NodeName  *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	Owner     *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	ProjectId *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetAlertMessageResponseBodyDataNodes) String() string {
	return tea.Prettify(s)
}

func (s GetAlertMessageResponseBodyDataNodes) GoString() string {
	return s.String()
}

func (s *GetAlertMessageResponseBodyDataNodes) SetNodeId(v int64) *GetAlertMessageResponseBodyDataNodes {
	s.NodeId = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataNodes) SetNodeName(v string) *GetAlertMessageResponseBodyDataNodes {
	s.NodeName = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataNodes) SetOwner(v string) *GetAlertMessageResponseBodyDataNodes {
	s.Owner = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataNodes) SetProjectId(v int64) *GetAlertMessageResponseBodyDataNodes {
	s.ProjectId = &v
	return s
}

type GetAlertMessageResponseBodyDataSlaAlert struct {
	BaselineId    *int64  `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	BaselineName  *string `json:"BaselineName,omitempty" xml:"BaselineName,omitempty"`
	BaselineOwner *string `json:"BaselineOwner,omitempty" xml:"BaselineOwner,omitempty"`
	Bizdate       *int64  `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	InGroupId     *int32  `json:"InGroupId,omitempty" xml:"InGroupId,omitempty"`
	ProjectId     *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	Status        *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetAlertMessageResponseBodyDataSlaAlert) String() string {
	return tea.Prettify(s)
}

func (s GetAlertMessageResponseBodyDataSlaAlert) GoString() string {
	return s.String()
}

func (s *GetAlertMessageResponseBodyDataSlaAlert) SetBaselineId(v int64) *GetAlertMessageResponseBodyDataSlaAlert {
	s.BaselineId = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataSlaAlert) SetBaselineName(v string) *GetAlertMessageResponseBodyDataSlaAlert {
	s.BaselineName = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataSlaAlert) SetBaselineOwner(v string) *GetAlertMessageResponseBodyDataSlaAlert {
	s.BaselineOwner = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataSlaAlert) SetBizdate(v int64) *GetAlertMessageResponseBodyDataSlaAlert {
	s.Bizdate = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataSlaAlert) SetInGroupId(v int32) *GetAlertMessageResponseBodyDataSlaAlert {
	s.InGroupId = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataSlaAlert) SetProjectId(v int64) *GetAlertMessageResponseBodyDataSlaAlert {
	s.ProjectId = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataSlaAlert) SetStatus(v string) *GetAlertMessageResponseBodyDataSlaAlert {
	s.Status = &v
	return s
}

type GetAlertMessageResponseBodyDataTopics struct {
	InstanceId  *int64  `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	NodeId      *int64  `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	TopicId     *int64  `json:"TopicId,omitempty" xml:"TopicId,omitempty"`
	TopicName   *string `json:"TopicName,omitempty" xml:"TopicName,omitempty"`
	TopicOwner  *string `json:"TopicOwner,omitempty" xml:"TopicOwner,omitempty"`
	TopicStatus *string `json:"TopicStatus,omitempty" xml:"TopicStatus,omitempty"`
}

func (s GetAlertMessageResponseBodyDataTopics) String() string {
	return tea.Prettify(s)
}

func (s GetAlertMessageResponseBodyDataTopics) GoString() string {
	return s.String()
}

func (s *GetAlertMessageResponseBodyDataTopics) SetInstanceId(v int64) *GetAlertMessageResponseBodyDataTopics {
	s.InstanceId = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataTopics) SetNodeId(v int64) *GetAlertMessageResponseBodyDataTopics {
	s.NodeId = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataTopics) SetTopicId(v int64) *GetAlertMessageResponseBodyDataTopics {
	s.TopicId = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataTopics) SetTopicName(v string) *GetAlertMessageResponseBodyDataTopics {
	s.TopicName = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataTopics) SetTopicOwner(v string) *GetAlertMessageResponseBodyDataTopics {
	s.TopicOwner = &v
	return s
}

func (s *GetAlertMessageResponseBodyDataTopics) SetTopicStatus(v string) *GetAlertMessageResponseBodyDataTopics {
	s.TopicStatus = &v
	return s
}

type GetAlertMessageResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetAlertMessageResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetAlertMessageResponse) String() string {
	return tea.Prettify(s)
}

func (s GetAlertMessageResponse) GoString() string {
	return s.String()
}

func (s *GetAlertMessageResponse) SetHeaders(v map[string]*string) *GetAlertMessageResponse {
	s.Headers = v
	return s
}

func (s *GetAlertMessageResponse) SetStatusCode(v int32) *GetAlertMessageResponse {
	s.StatusCode = &v
	return s
}

func (s *GetAlertMessageResponse) SetBody(v *GetAlertMessageResponseBody) *GetAlertMessageResponse {
	s.Body = v
	return s
}

type GetBaselineRequest struct {
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	ProjectId  *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetBaselineRequest) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineRequest) GoString() string {
	return s.String()
}

func (s *GetBaselineRequest) SetBaselineId(v int64) *GetBaselineRequest {
	s.BaselineId = &v
	return s
}

func (s *GetBaselineRequest) SetProjectId(v int64) *GetBaselineRequest {
	s.ProjectId = &v
	return s
}

type GetBaselineResponseBody struct {
	Data           *GetBaselineResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorCode      *string                      `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string                      `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32                       `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string                      `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                        `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetBaselineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineResponseBody) GoString() string {
	return s.String()
}

func (s *GetBaselineResponseBody) SetData(v *GetBaselineResponseBodyData) *GetBaselineResponseBody {
	s.Data = v
	return s
}

func (s *GetBaselineResponseBody) SetErrorCode(v string) *GetBaselineResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetBaselineResponseBody) SetErrorMessage(v string) *GetBaselineResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetBaselineResponseBody) SetHttpStatusCode(v int32) *GetBaselineResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetBaselineResponseBody) SetRequestId(v string) *GetBaselineResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetBaselineResponseBody) SetSuccess(v bool) *GetBaselineResponseBody {
	s.Success = &v
	return s
}

type GetBaselineResponseBodyData struct {
	AlertEnabled         *bool                                          `json:"AlertEnabled,omitempty" xml:"AlertEnabled,omitempty"`
	AlertMarginThreshold *int32                                         `json:"AlertMarginThreshold,omitempty" xml:"AlertMarginThreshold,omitempty"`
	AlertSettings        []*GetBaselineResponseBodyDataAlertSettings    `json:"AlertSettings,omitempty" xml:"AlertSettings,omitempty" type:"Repeated"`
	BaselineId           *int64                                         `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	BaselineName         *string                                        `json:"BaselineName,omitempty" xml:"BaselineName,omitempty"`
	BaselineType         *string                                        `json:"BaselineType,omitempty" xml:"BaselineType,omitempty"`
	Enabled              *bool                                          `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	NodeIds              []*int64                                       `json:"NodeIds,omitempty" xml:"NodeIds,omitempty" type:"Repeated"`
	OverTimeSettings     []*GetBaselineResponseBodyDataOverTimeSettings `json:"OverTimeSettings,omitempty" xml:"OverTimeSettings,omitempty" type:"Repeated"`
	Owner                *string                                        `json:"Owner,omitempty" xml:"Owner,omitempty"`
	Priority             *int32                                         `json:"Priority,omitempty" xml:"Priority,omitempty"`
	ProjectId            *int64                                         `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetBaselineResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetBaselineResponseBodyData) SetAlertEnabled(v bool) *GetBaselineResponseBodyData {
	s.AlertEnabled = &v
	return s
}

func (s *GetBaselineResponseBodyData) SetAlertMarginThreshold(v int32) *GetBaselineResponseBodyData {
	s.AlertMarginThreshold = &v
	return s
}

func (s *GetBaselineResponseBodyData) SetAlertSettings(v []*GetBaselineResponseBodyDataAlertSettings) *GetBaselineResponseBodyData {
	s.AlertSettings = v
	return s
}

func (s *GetBaselineResponseBodyData) SetBaselineId(v int64) *GetBaselineResponseBodyData {
	s.BaselineId = &v
	return s
}

func (s *GetBaselineResponseBodyData) SetBaselineName(v string) *GetBaselineResponseBodyData {
	s.BaselineName = &v
	return s
}

func (s *GetBaselineResponseBodyData) SetBaselineType(v string) *GetBaselineResponseBodyData {
	s.BaselineType = &v
	return s
}

func (s *GetBaselineResponseBodyData) SetEnabled(v bool) *GetBaselineResponseBodyData {
	s.Enabled = &v
	return s
}

func (s *GetBaselineResponseBodyData) SetNodeIds(v []*int64) *GetBaselineResponseBodyData {
	s.NodeIds = v
	return s
}

func (s *GetBaselineResponseBodyData) SetOverTimeSettings(v []*GetBaselineResponseBodyDataOverTimeSettings) *GetBaselineResponseBodyData {
	s.OverTimeSettings = v
	return s
}

func (s *GetBaselineResponseBodyData) SetOwner(v string) *GetBaselineResponseBodyData {
	s.Owner = &v
	return s
}

func (s *GetBaselineResponseBodyData) SetPriority(v int32) *GetBaselineResponseBodyData {
	s.Priority = &v
	return s
}

func (s *GetBaselineResponseBodyData) SetProjectId(v int64) *GetBaselineResponseBodyData {
	s.ProjectId = &v
	return s
}

type GetBaselineResponseBodyDataAlertSettings struct {
	AlertInterval        *int32                                                `json:"AlertInterval,omitempty" xml:"AlertInterval,omitempty"`
	AlertMaximum         *int32                                                `json:"AlertMaximum,omitempty" xml:"AlertMaximum,omitempty"`
	AlertMethods         []*string                                             `json:"AlertMethods,omitempty" xml:"AlertMethods,omitempty" type:"Repeated"`
	AlertRecipient       *string                                               `json:"AlertRecipient,omitempty" xml:"AlertRecipient,omitempty"`
	AlertRecipientType   *string                                               `json:"AlertRecipientType,omitempty" xml:"AlertRecipientType,omitempty"`
	AlertType            *string                                               `json:"AlertType,omitempty" xml:"AlertType,omitempty"`
	BaselineAlertEnabled *bool                                                 `json:"BaselineAlertEnabled,omitempty" xml:"BaselineAlertEnabled,omitempty"`
	DingRobots           []*GetBaselineResponseBodyDataAlertSettingsDingRobots `json:"DingRobots,omitempty" xml:"DingRobots,omitempty" type:"Repeated"`
	SilenceEndTime       *string                                               `json:"SilenceEndTime,omitempty" xml:"SilenceEndTime,omitempty"`
	SilenceStartTime     *string                                               `json:"SilenceStartTime,omitempty" xml:"SilenceStartTime,omitempty"`
	TopicTypes           []*string                                             `json:"TopicTypes,omitempty" xml:"TopicTypes,omitempty" type:"Repeated"`
	Webhooks             []*string                                             `json:"Webhooks,omitempty" xml:"Webhooks,omitempty" type:"Repeated"`
}

func (s GetBaselineResponseBodyDataAlertSettings) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineResponseBodyDataAlertSettings) GoString() string {
	return s.String()
}

func (s *GetBaselineResponseBodyDataAlertSettings) SetAlertInterval(v int32) *GetBaselineResponseBodyDataAlertSettings {
	s.AlertInterval = &v
	return s
}

func (s *GetBaselineResponseBodyDataAlertSettings) SetAlertMaximum(v int32) *GetBaselineResponseBodyDataAlertSettings {
	s.AlertMaximum = &v
	return s
}

func (s *GetBaselineResponseBodyDataAlertSettings) SetAlertMethods(v []*string) *GetBaselineResponseBodyDataAlertSettings {
	s.AlertMethods = v
	return s
}

func (s *GetBaselineResponseBodyDataAlertSettings) SetAlertRecipient(v string) *GetBaselineResponseBodyDataAlertSettings {
	s.AlertRecipient = &v
	return s
}

func (s *GetBaselineResponseBodyDataAlertSettings) SetAlertRecipientType(v string) *GetBaselineResponseBodyDataAlertSettings {
	s.AlertRecipientType = &v
	return s
}

func (s *GetBaselineResponseBodyDataAlertSettings) SetAlertType(v string) *GetBaselineResponseBodyDataAlertSettings {
	s.AlertType = &v
	return s
}

func (s *GetBaselineResponseBodyDataAlertSettings) SetBaselineAlertEnabled(v bool) *GetBaselineResponseBodyDataAlertSettings {
	s.BaselineAlertEnabled = &v
	return s
}

func (s *GetBaselineResponseBodyDataAlertSettings) SetDingRobots(v []*GetBaselineResponseBodyDataAlertSettingsDingRobots) *GetBaselineResponseBodyDataAlertSettings {
	s.DingRobots = v
	return s
}

func (s *GetBaselineResponseBodyDataAlertSettings) SetSilenceEndTime(v string) *GetBaselineResponseBodyDataAlertSettings {
	s.SilenceEndTime = &v
	return s
}

func (s *GetBaselineResponseBodyDataAlertSettings) SetSilenceStartTime(v string) *GetBaselineResponseBodyDataAlertSettings {
	s.SilenceStartTime = &v
	return s
}

func (s *GetBaselineResponseBodyDataAlertSettings) SetTopicTypes(v []*string) *GetBaselineResponseBodyDataAlertSettings {
	s.TopicTypes = v
	return s
}

func (s *GetBaselineResponseBodyDataAlertSettings) SetWebhooks(v []*string) *GetBaselineResponseBodyDataAlertSettings {
	s.Webhooks = v
	return s
}

type GetBaselineResponseBodyDataAlertSettingsDingRobots struct {
	AtAll  *bool   `json:"AtAll,omitempty" xml:"AtAll,omitempty"`
	WebUrl *string `json:"WebUrl,omitempty" xml:"WebUrl,omitempty"`
}

func (s GetBaselineResponseBodyDataAlertSettingsDingRobots) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineResponseBodyDataAlertSettingsDingRobots) GoString() string {
	return s.String()
}

func (s *GetBaselineResponseBodyDataAlertSettingsDingRobots) SetAtAll(v bool) *GetBaselineResponseBodyDataAlertSettingsDingRobots {
	s.AtAll = &v
	return s
}

func (s *GetBaselineResponseBodyDataAlertSettingsDingRobots) SetWebUrl(v string) *GetBaselineResponseBodyDataAlertSettingsDingRobots {
	s.WebUrl = &v
	return s
}

type GetBaselineResponseBodyDataOverTimeSettings struct {
	Cycle *int32  `json:"Cycle,omitempty" xml:"Cycle,omitempty"`
	Time  *string `json:"Time,omitempty" xml:"Time,omitempty"`
}

func (s GetBaselineResponseBodyDataOverTimeSettings) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineResponseBodyDataOverTimeSettings) GoString() string {
	return s.String()
}

func (s *GetBaselineResponseBodyDataOverTimeSettings) SetCycle(v int32) *GetBaselineResponseBodyDataOverTimeSettings {
	s.Cycle = &v
	return s
}

func (s *GetBaselineResponseBodyDataOverTimeSettings) SetTime(v string) *GetBaselineResponseBodyDataOverTimeSettings {
	s.Time = &v
	return s
}

type GetBaselineResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetBaselineResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetBaselineResponse) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineResponse) GoString() string {
	return s.String()
}

func (s *GetBaselineResponse) SetHeaders(v map[string]*string) *GetBaselineResponse {
	s.Headers = v
	return s
}

func (s *GetBaselineResponse) SetStatusCode(v int32) *GetBaselineResponse {
	s.StatusCode = &v
	return s
}

func (s *GetBaselineResponse) SetBody(v *GetBaselineResponseBody) *GetBaselineResponse {
	s.Body = v
	return s
}

type GetBaselineConfigRequest struct {
	// The ID of the baseline. You can call the [GetNode](~~173977~~) operation to obtain the ID.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
}

func (s GetBaselineConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineConfigRequest) GoString() string {
	return s.String()
}

func (s *GetBaselineConfigRequest) SetBaselineId(v int64) *GetBaselineConfigRequest {
	s.BaselineId = &v
	return s
}

type GetBaselineConfigResponseBody struct {
	// The details of the baseline.
	Data *GetBaselineConfigResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetBaselineConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineConfigResponseBody) GoString() string {
	return s.String()
}

func (s *GetBaselineConfigResponseBody) SetData(v *GetBaselineConfigResponseBodyData) *GetBaselineConfigResponseBody {
	s.Data = v
	return s
}

func (s *GetBaselineConfigResponseBody) SetErrorCode(v string) *GetBaselineConfigResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetBaselineConfigResponseBody) SetErrorMessage(v string) *GetBaselineConfigResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetBaselineConfigResponseBody) SetHttpStatusCode(v int32) *GetBaselineConfigResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetBaselineConfigResponseBody) SetRequestId(v string) *GetBaselineConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetBaselineConfigResponseBody) SetSuccess(v bool) *GetBaselineConfigResponseBody {
	s.Success = &v
	return s
}

type GetBaselineConfigResponseBodyData struct {
	// The ID of the baseline.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The name of the baseline.
	BaselineName *string `json:"BaselineName,omitempty" xml:"BaselineName,omitempty"`
	// The type of the baseline. Valid values: DAILY and HOURLY. The value DAILY indicates that the baseline is a day-level baseline. The value HOURLY indicates that the baseline is an hour-level baseline.
	BaselineType *string `json:"BaselineType,omitempty" xml:"BaselineType,omitempty"`
	// The hour in the alert time of the day-level baseline. Valid values: 0 to 47.
	ExpHour *int32 `json:"ExpHour,omitempty" xml:"ExpHour,omitempty"`
	// The minute in the alert time of the day-level baseline. Valid values: 0 to 59.
	ExpMinu *int32 `json:"ExpMinu,omitempty" xml:"ExpMinu,omitempty"`
	// The alert time of the hour-level baseline. This parameter is presented as key-value pairs in the JSON format. The key indicates the ID of the cycle, and the value is presented in the hh:mm format. Valid values of hh: 0 to 47. Valid values of mm: 0 to 59.
	HourExpDetail *string `json:"HourExpDetail,omitempty" xml:"HourExpDetail,omitempty"`
	// The committed time of the hour-level baseline. This parameter is presented as key-value pairs in the JSON format. The key indicates the ID of the cycle, and the value is presented in the hh:mm format. Valid values of hh: 0 to 47. Valid values of mm: 0 to 59.
	HourSlaDetail *string `json:"HourSlaDetail,omitempty" xml:"HourSlaDetail,omitempty"`
	// Indicates whether the baseline is a default baseline of the workspace. Valid values: true and false.
	IsDefault *bool `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The ID of the Alibaba Cloud account used by the baseline owner. Multiple IDs are separated by commas (,).
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The priority of the baseline. Valid values: 1, 3, 5, 7, and 8.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The hour in the committed time of the day-level baseline. Valid values: 0 to 47.
	SlaHour *int32 `json:"SlaHour,omitempty" xml:"SlaHour,omitempty"`
	// The minute in the committed time of the day-level baseline. Valid values: 0 to 59.
	SlaMinu *int32 `json:"SlaMinu,omitempty" xml:"SlaMinu,omitempty"`
	// Indicates whether the baseline is enabled. Valid values: true and false.
	UseFlag *bool `json:"UseFlag,omitempty" xml:"UseFlag,omitempty"`
}

func (s GetBaselineConfigResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineConfigResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetBaselineConfigResponseBodyData) SetBaselineId(v int64) *GetBaselineConfigResponseBodyData {
	s.BaselineId = &v
	return s
}

func (s *GetBaselineConfigResponseBodyData) SetBaselineName(v string) *GetBaselineConfigResponseBodyData {
	s.BaselineName = &v
	return s
}

func (s *GetBaselineConfigResponseBodyData) SetBaselineType(v string) *GetBaselineConfigResponseBodyData {
	s.BaselineType = &v
	return s
}

func (s *GetBaselineConfigResponseBodyData) SetExpHour(v int32) *GetBaselineConfigResponseBodyData {
	s.ExpHour = &v
	return s
}

func (s *GetBaselineConfigResponseBodyData) SetExpMinu(v int32) *GetBaselineConfigResponseBodyData {
	s.ExpMinu = &v
	return s
}

func (s *GetBaselineConfigResponseBodyData) SetHourExpDetail(v string) *GetBaselineConfigResponseBodyData {
	s.HourExpDetail = &v
	return s
}

func (s *GetBaselineConfigResponseBodyData) SetHourSlaDetail(v string) *GetBaselineConfigResponseBodyData {
	s.HourSlaDetail = &v
	return s
}

func (s *GetBaselineConfigResponseBodyData) SetIsDefault(v bool) *GetBaselineConfigResponseBodyData {
	s.IsDefault = &v
	return s
}

func (s *GetBaselineConfigResponseBodyData) SetOwner(v string) *GetBaselineConfigResponseBodyData {
	s.Owner = &v
	return s
}

func (s *GetBaselineConfigResponseBodyData) SetPriority(v int32) *GetBaselineConfigResponseBodyData {
	s.Priority = &v
	return s
}

func (s *GetBaselineConfigResponseBodyData) SetProjectId(v int64) *GetBaselineConfigResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetBaselineConfigResponseBodyData) SetSlaHour(v int32) *GetBaselineConfigResponseBodyData {
	s.SlaHour = &v
	return s
}

func (s *GetBaselineConfigResponseBodyData) SetSlaMinu(v int32) *GetBaselineConfigResponseBodyData {
	s.SlaMinu = &v
	return s
}

func (s *GetBaselineConfigResponseBodyData) SetUseFlag(v bool) *GetBaselineConfigResponseBodyData {
	s.UseFlag = &v
	return s
}

type GetBaselineConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetBaselineConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetBaselineConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineConfigResponse) GoString() string {
	return s.String()
}

func (s *GetBaselineConfigResponse) SetHeaders(v map[string]*string) *GetBaselineConfigResponse {
	s.Headers = v
	return s
}

func (s *GetBaselineConfigResponse) SetStatusCode(v int32) *GetBaselineConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *GetBaselineConfigResponse) SetBody(v *GetBaselineConfigResponseBody) *GetBaselineConfigResponse {
	s.Body = v
	return s
}

type GetBaselineKeyPathRequest struct {
	// The name of the event.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The ID of the instance.
	Bizdate *string `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	// The ID of the event.
	InGroupId *int32 `json:"InGroupId,omitempty" xml:"InGroupId,omitempty"`
}

func (s GetBaselineKeyPathRequest) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineKeyPathRequest) GoString() string {
	return s.String()
}

func (s *GetBaselineKeyPathRequest) SetBaselineId(v int64) *GetBaselineKeyPathRequest {
	s.BaselineId = &v
	return s
}

func (s *GetBaselineKeyPathRequest) SetBizdate(v string) *GetBaselineKeyPathRequest {
	s.Bizdate = &v
	return s
}

func (s *GetBaselineKeyPathRequest) SetInGroupId(v int32) *GetBaselineKeyPathRequest {
	s.InGroupId = &v
	return s
}

type GetBaselineKeyPathResponseBody struct {
	Data         []*GetBaselineKeyPathResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	ErrorCode    *string                               `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage *string                               `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The timestamp when the event was found.
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetBaselineKeyPathResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineKeyPathResponseBody) GoString() string {
	return s.String()
}

func (s *GetBaselineKeyPathResponseBody) SetData(v []*GetBaselineKeyPathResponseBodyData) *GetBaselineKeyPathResponseBody {
	s.Data = v
	return s
}

func (s *GetBaselineKeyPathResponseBody) SetErrorCode(v string) *GetBaselineKeyPathResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetBaselineKeyPathResponseBody) SetErrorMessage(v string) *GetBaselineKeyPathResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetBaselineKeyPathResponseBody) SetHttpStatusCode(v int32) *GetBaselineKeyPathResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetBaselineKeyPathResponseBody) SetRequestId(v string) *GetBaselineKeyPathResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetBaselineKeyPathResponseBody) SetSuccess(v bool) *GetBaselineKeyPathResponseBody {
	s.Success = &v
	return s
}

type GetBaselineKeyPathResponseBodyData struct {
	Bizdate    *int64                                      `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	InGroupId  *int32                                      `json:"InGroupId,omitempty" xml:"InGroupId,omitempty"`
	InstanceId *int64                                      `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	NodeId     *int64                                      `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	NodeName   *string                                     `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	Owner      *string                                     `json:"Owner,omitempty" xml:"Owner,omitempty"`
	PrgType    *int32                                      `json:"PrgType,omitempty" xml:"PrgType,omitempty"`
	ProjectId  *int64                                      `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	Runs       []*GetBaselineKeyPathResponseBodyDataRuns   `json:"Runs,omitempty" xml:"Runs,omitempty" type:"Repeated"`
	Topics     []*GetBaselineKeyPathResponseBodyDataTopics `json:"Topics,omitempty" xml:"Topics,omitempty" type:"Repeated"`
}

func (s GetBaselineKeyPathResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineKeyPathResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetBaselineKeyPathResponseBodyData) SetBizdate(v int64) *GetBaselineKeyPathResponseBodyData {
	s.Bizdate = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyData) SetInGroupId(v int32) *GetBaselineKeyPathResponseBodyData {
	s.InGroupId = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyData) SetInstanceId(v int64) *GetBaselineKeyPathResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyData) SetNodeId(v int64) *GetBaselineKeyPathResponseBodyData {
	s.NodeId = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyData) SetNodeName(v string) *GetBaselineKeyPathResponseBodyData {
	s.NodeName = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyData) SetOwner(v string) *GetBaselineKeyPathResponseBodyData {
	s.Owner = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyData) SetPrgType(v int32) *GetBaselineKeyPathResponseBodyData {
	s.PrgType = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyData) SetProjectId(v int64) *GetBaselineKeyPathResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyData) SetRuns(v []*GetBaselineKeyPathResponseBodyDataRuns) *GetBaselineKeyPathResponseBodyData {
	s.Runs = v
	return s
}

func (s *GetBaselineKeyPathResponseBodyData) SetTopics(v []*GetBaselineKeyPathResponseBodyDataTopics) *GetBaselineKeyPathResponseBodyData {
	s.Topics = v
	return s
}

type GetBaselineKeyPathResponseBodyDataRuns struct {
	AbsTime           *int64  `json:"AbsTime,omitempty" xml:"AbsTime,omitempty"`
	BeginCast         *int64  `json:"BeginCast,omitempty" xml:"BeginCast,omitempty"`
	BeginRunningTime  *int64  `json:"BeginRunningTime,omitempty" xml:"BeginRunningTime,omitempty"`
	BeginWaitResTime  *int64  `json:"BeginWaitResTime,omitempty" xml:"BeginWaitResTime,omitempty"`
	BeginWaitTimeTime *int64  `json:"BeginWaitTimeTime,omitempty" xml:"BeginWaitTimeTime,omitempty"`
	EndCast           *int64  `json:"EndCast,omitempty" xml:"EndCast,omitempty"`
	FinishTime        *int64  `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	Status            *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetBaselineKeyPathResponseBodyDataRuns) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineKeyPathResponseBodyDataRuns) GoString() string {
	return s.String()
}

func (s *GetBaselineKeyPathResponseBodyDataRuns) SetAbsTime(v int64) *GetBaselineKeyPathResponseBodyDataRuns {
	s.AbsTime = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyDataRuns) SetBeginCast(v int64) *GetBaselineKeyPathResponseBodyDataRuns {
	s.BeginCast = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyDataRuns) SetBeginRunningTime(v int64) *GetBaselineKeyPathResponseBodyDataRuns {
	s.BeginRunningTime = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyDataRuns) SetBeginWaitResTime(v int64) *GetBaselineKeyPathResponseBodyDataRuns {
	s.BeginWaitResTime = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyDataRuns) SetBeginWaitTimeTime(v int64) *GetBaselineKeyPathResponseBodyDataRuns {
	s.BeginWaitTimeTime = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyDataRuns) SetEndCast(v int64) *GetBaselineKeyPathResponseBodyDataRuns {
	s.EndCast = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyDataRuns) SetFinishTime(v int64) *GetBaselineKeyPathResponseBodyDataRuns {
	s.FinishTime = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyDataRuns) SetStatus(v string) *GetBaselineKeyPathResponseBodyDataRuns {
	s.Status = &v
	return s
}

type GetBaselineKeyPathResponseBodyDataTopics struct {
	AddTime    *int64  `json:"AddTime,omitempty" xml:"AddTime,omitempty"`
	InstanceId *int64  `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	TopicId    *int64  `json:"TopicId,omitempty" xml:"TopicId,omitempty"`
	TopicName  *string `json:"TopicName,omitempty" xml:"TopicName,omitempty"`
}

func (s GetBaselineKeyPathResponseBodyDataTopics) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineKeyPathResponseBodyDataTopics) GoString() string {
	return s.String()
}

func (s *GetBaselineKeyPathResponseBodyDataTopics) SetAddTime(v int64) *GetBaselineKeyPathResponseBodyDataTopics {
	s.AddTime = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyDataTopics) SetInstanceId(v int64) *GetBaselineKeyPathResponseBodyDataTopics {
	s.InstanceId = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyDataTopics) SetTopicId(v int64) *GetBaselineKeyPathResponseBodyDataTopics {
	s.TopicId = &v
	return s
}

func (s *GetBaselineKeyPathResponseBodyDataTopics) SetTopicName(v string) *GetBaselineKeyPathResponseBodyDataTopics {
	s.TopicName = &v
	return s
}

type GetBaselineKeyPathResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetBaselineKeyPathResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetBaselineKeyPathResponse) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineKeyPathResponse) GoString() string {
	return s.String()
}

func (s *GetBaselineKeyPathResponse) SetHeaders(v map[string]*string) *GetBaselineKeyPathResponse {
	s.Headers = v
	return s
}

func (s *GetBaselineKeyPathResponse) SetStatusCode(v int32) *GetBaselineKeyPathResponse {
	s.StatusCode = &v
	return s
}

func (s *GetBaselineKeyPathResponse) SetBody(v *GetBaselineKeyPathResponseBody) *GetBaselineKeyPathResponse {
	s.Body = v
	return s
}

type GetBaselineStatusRequest struct {
	// The ID of the baseline.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The data timestamp of the baseline instance. Specify the time in the ISO 8601 standard in the yyyy-MM-dd\"T\"HH:mm:ssZ format. The time must be in UTC.
	Bizdate *string `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	// The ID of the scheduling cycle of the baseline instance. For a baseline instance that is scheduled by day, the value of this parameter is 1. For a baseline instance that is scheduled by hour, the value of this parameter ranges from 1 to 24.
	InGroupId *int32 `json:"InGroupId,omitempty" xml:"InGroupId,omitempty"`
}

func (s GetBaselineStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineStatusRequest) GoString() string {
	return s.String()
}

func (s *GetBaselineStatusRequest) SetBaselineId(v int64) *GetBaselineStatusRequest {
	s.BaselineId = &v
	return s
}

func (s *GetBaselineStatusRequest) SetBizdate(v string) *GetBaselineStatusRequest {
	s.Bizdate = &v
	return s
}

func (s *GetBaselineStatusRequest) SetInGroupId(v int32) *GetBaselineStatusRequest {
	s.InGroupId = &v
	return s
}

type GetBaselineStatusResponseBody struct {
	// The details of the baseline instance.
	Data *GetBaselineStatusResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetBaselineStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineStatusResponseBody) GoString() string {
	return s.String()
}

func (s *GetBaselineStatusResponseBody) SetData(v *GetBaselineStatusResponseBodyData) *GetBaselineStatusResponseBody {
	s.Data = v
	return s
}

func (s *GetBaselineStatusResponseBody) SetErrorCode(v string) *GetBaselineStatusResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetBaselineStatusResponseBody) SetErrorMessage(v string) *GetBaselineStatusResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetBaselineStatusResponseBody) SetHttpStatusCode(v int32) *GetBaselineStatusResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetBaselineStatusResponseBody) SetRequestId(v string) *GetBaselineStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetBaselineStatusResponseBody) SetSuccess(v bool) *GetBaselineStatusResponseBody {
	s.Success = &v
	return s
}

type GetBaselineStatusResponseBodyData struct {
	// The ID of the baseline.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The name of the baseline.
	BaselineName *string `json:"BaselineName,omitempty" xml:"BaselineName,omitempty"`
	// The data timestamp of the baseline instance.
	Bizdate *int64 `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	// The information about the key instance.
	BlockInstance *GetBaselineStatusResponseBodyDataBlockInstance `json:"BlockInstance,omitempty" xml:"BlockInstance,omitempty" type:"Struct"`
	// The margin of the baseline instance. Unit: seconds.
	Buffer *float32 `json:"Buffer,omitempty" xml:"Buffer,omitempty"`
	// The timestamp of the predicted time when the baseline instance finished running.
	EndCast *int64 `json:"EndCast,omitempty" xml:"EndCast,omitempty"`
	// The timestamp of the alerting time of the baseline instance.
	ExpTime *int64 `json:"ExpTime,omitempty" xml:"ExpTime,omitempty"`
	// The status of the baseline instance. Valid values: UNFINISH and FINISH. The value UNFINISH indicates that the baseline instance is still running. The value FINISH indicates that the baseline instance finishes running.
	FinishStatus *string `json:"FinishStatus,omitempty" xml:"FinishStatus,omitempty"`
	// The timestamp of the actual time when the baseline instance finished running. This parameter is returned if the value of the FinishStatus parameter is FINISH.
	FinishTime *int64 `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	// The ID of the scheduling cycle of the baseline instance. For a baseline instance that is scheduled by day, the value of this parameter is 1. For a baseline instance that is scheduled by hour, the value of this parameter ranges from 1 to 24.
	InGroupId *int32 `json:"InGroupId,omitempty" xml:"InGroupId,omitempty"`
	// The information about the last generated instance.
	LastInstance *GetBaselineStatusResponseBodyDataLastInstance `json:"LastInstance,omitempty" xml:"LastInstance,omitempty" type:"Struct"`
	// The ID of the Alibaba Cloud account used by the baseline owner. Multiple IDs are separated by commas (,).
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The priority of the baseline. Valid values: 1, 2, 5, 7, and 8.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the workspace to which the baseline belongs.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The timestamp of the committed completion time of the baseline instance.
	SlaTime *int64 `json:"SlaTime,omitempty" xml:"SlaTime,omitempty"`
	// The status of the baseline. Valid values: ERROR, SAFE, DANGEROUS, and OVER. The value ERROR indicates that no nodes are associated with the baseline, or all nodes associated with the baseline are suspended. The value SAFE indicates that nodes finish running before the alerting time. The value DANGEROUS indicates that nodes are still running after the alerting time but before the committed completion time. The value OVER indicates that nodes are still running after the committed completion time.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetBaselineStatusResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineStatusResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetBaselineStatusResponseBodyData) SetBaselineId(v int64) *GetBaselineStatusResponseBodyData {
	s.BaselineId = &v
	return s
}

func (s *GetBaselineStatusResponseBodyData) SetBaselineName(v string) *GetBaselineStatusResponseBodyData {
	s.BaselineName = &v
	return s
}

func (s *GetBaselineStatusResponseBodyData) SetBizdate(v int64) *GetBaselineStatusResponseBodyData {
	s.Bizdate = &v
	return s
}

func (s *GetBaselineStatusResponseBodyData) SetBlockInstance(v *GetBaselineStatusResponseBodyDataBlockInstance) *GetBaselineStatusResponseBodyData {
	s.BlockInstance = v
	return s
}

func (s *GetBaselineStatusResponseBodyData) SetBuffer(v float32) *GetBaselineStatusResponseBodyData {
	s.Buffer = &v
	return s
}

func (s *GetBaselineStatusResponseBodyData) SetEndCast(v int64) *GetBaselineStatusResponseBodyData {
	s.EndCast = &v
	return s
}

func (s *GetBaselineStatusResponseBodyData) SetExpTime(v int64) *GetBaselineStatusResponseBodyData {
	s.ExpTime = &v
	return s
}

func (s *GetBaselineStatusResponseBodyData) SetFinishStatus(v string) *GetBaselineStatusResponseBodyData {
	s.FinishStatus = &v
	return s
}

func (s *GetBaselineStatusResponseBodyData) SetFinishTime(v int64) *GetBaselineStatusResponseBodyData {
	s.FinishTime = &v
	return s
}

func (s *GetBaselineStatusResponseBodyData) SetInGroupId(v int32) *GetBaselineStatusResponseBodyData {
	s.InGroupId = &v
	return s
}

func (s *GetBaselineStatusResponseBodyData) SetLastInstance(v *GetBaselineStatusResponseBodyDataLastInstance) *GetBaselineStatusResponseBodyData {
	s.LastInstance = v
	return s
}

func (s *GetBaselineStatusResponseBodyData) SetOwner(v string) *GetBaselineStatusResponseBodyData {
	s.Owner = &v
	return s
}

func (s *GetBaselineStatusResponseBodyData) SetPriority(v int32) *GetBaselineStatusResponseBodyData {
	s.Priority = &v
	return s
}

func (s *GetBaselineStatusResponseBodyData) SetProjectId(v int64) *GetBaselineStatusResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetBaselineStatusResponseBodyData) SetSlaTime(v int64) *GetBaselineStatusResponseBodyData {
	s.SlaTime = &v
	return s
}

func (s *GetBaselineStatusResponseBodyData) SetStatus(v string) *GetBaselineStatusResponseBodyData {
	s.Status = &v
	return s
}

type GetBaselineStatusResponseBodyDataBlockInstance struct {
	// The timestamp of the predicted time when the instance finished running.
	EndCast *int64 `json:"EndCast,omitempty" xml:"EndCast,omitempty"`
	// The timestamp of the actual time when the instance finished running.
	FinishTime *int64 `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	// The ID of the instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The ID of the Alibaba Cloud account used by the node owner.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ID of the workspace to which the node belongs.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The status of the instance. Valid values: NOT_RUN, WAIT_TIME, WAIT_RESOURCE, RUNNING, CHECKING, CHECKING_CONDITION, FAILURE, and SUCCESS. The value NOT_RUN indicates that the instance is not run. The value WAIT_TIME indicates that the instance is waiting to be run. The value WAIT_RESOURCE indicates that the instance is waiting for resources. The value RUNNING indicates that the instance is running. The value CHECKING indicates that data quality is being checked for the instance. The value CHECKING_CONDITION indicates that branch conditions are being checked for the instance. The value FAILURE indicates that the instance fails to run. The value SUCCESS indicates that the instance is run.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetBaselineStatusResponseBodyDataBlockInstance) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineStatusResponseBodyDataBlockInstance) GoString() string {
	return s.String()
}

func (s *GetBaselineStatusResponseBodyDataBlockInstance) SetEndCast(v int64) *GetBaselineStatusResponseBodyDataBlockInstance {
	s.EndCast = &v
	return s
}

func (s *GetBaselineStatusResponseBodyDataBlockInstance) SetFinishTime(v int64) *GetBaselineStatusResponseBodyDataBlockInstance {
	s.FinishTime = &v
	return s
}

func (s *GetBaselineStatusResponseBodyDataBlockInstance) SetInstanceId(v int64) *GetBaselineStatusResponseBodyDataBlockInstance {
	s.InstanceId = &v
	return s
}

func (s *GetBaselineStatusResponseBodyDataBlockInstance) SetNodeId(v int64) *GetBaselineStatusResponseBodyDataBlockInstance {
	s.NodeId = &v
	return s
}

func (s *GetBaselineStatusResponseBodyDataBlockInstance) SetNodeName(v string) *GetBaselineStatusResponseBodyDataBlockInstance {
	s.NodeName = &v
	return s
}

func (s *GetBaselineStatusResponseBodyDataBlockInstance) SetOwner(v string) *GetBaselineStatusResponseBodyDataBlockInstance {
	s.Owner = &v
	return s
}

func (s *GetBaselineStatusResponseBodyDataBlockInstance) SetProjectId(v int64) *GetBaselineStatusResponseBodyDataBlockInstance {
	s.ProjectId = &v
	return s
}

func (s *GetBaselineStatusResponseBodyDataBlockInstance) SetStatus(v string) *GetBaselineStatusResponseBodyDataBlockInstance {
	s.Status = &v
	return s
}

type GetBaselineStatusResponseBodyDataLastInstance struct {
	// The timestamp of the predicted time when the instance finished running.
	EndCast *int64 `json:"EndCast,omitempty" xml:"EndCast,omitempty"`
	// The timestamp of the actual time when the instance finished running.
	FinishTime *int64 `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	// The ID of the instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The ID of the Alibaba Cloud account used by the node owner.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ID of the workspace to which the node belongs.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The status of the instance. Valid values: NOT_RUN, WAIT_TIME, WAIT_RESOURCE, RUNNING, CHECKING, CHECKING_CONDITION, FAILURE, and SUCCESS. The value NOT_RUN indicates that the instance is not run. The value WAIT_TIME indicates that the instance is waiting to be run. The value WAIT_RESOURCE indicates that the instance is waiting for resources. The value RUNNING indicates that the instance is running. The value CHECKING indicates that data quality is being checked for the instance. The value CHECKING_CONDITION indicates that branch conditions are being checked for the instance. The value FAILURE indicates that the instance fails to run. The value SUCCESS indicates that the instance is run.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetBaselineStatusResponseBodyDataLastInstance) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineStatusResponseBodyDataLastInstance) GoString() string {
	return s.String()
}

func (s *GetBaselineStatusResponseBodyDataLastInstance) SetEndCast(v int64) *GetBaselineStatusResponseBodyDataLastInstance {
	s.EndCast = &v
	return s
}

func (s *GetBaselineStatusResponseBodyDataLastInstance) SetFinishTime(v int64) *GetBaselineStatusResponseBodyDataLastInstance {
	s.FinishTime = &v
	return s
}

func (s *GetBaselineStatusResponseBodyDataLastInstance) SetInstanceId(v int64) *GetBaselineStatusResponseBodyDataLastInstance {
	s.InstanceId = &v
	return s
}

func (s *GetBaselineStatusResponseBodyDataLastInstance) SetNodeId(v int64) *GetBaselineStatusResponseBodyDataLastInstance {
	s.NodeId = &v
	return s
}

func (s *GetBaselineStatusResponseBodyDataLastInstance) SetNodeName(v string) *GetBaselineStatusResponseBodyDataLastInstance {
	s.NodeName = &v
	return s
}

func (s *GetBaselineStatusResponseBodyDataLastInstance) SetOwner(v string) *GetBaselineStatusResponseBodyDataLastInstance {
	s.Owner = &v
	return s
}

func (s *GetBaselineStatusResponseBodyDataLastInstance) SetProjectId(v int64) *GetBaselineStatusResponseBodyDataLastInstance {
	s.ProjectId = &v
	return s
}

func (s *GetBaselineStatusResponseBodyDataLastInstance) SetStatus(v string) *GetBaselineStatusResponseBodyDataLastInstance {
	s.Status = &v
	return s
}

type GetBaselineStatusResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetBaselineStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetBaselineStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s GetBaselineStatusResponse) GoString() string {
	return s.String()
}

func (s *GetBaselineStatusResponse) SetHeaders(v map[string]*string) *GetBaselineStatusResponse {
	s.Headers = v
	return s
}

func (s *GetBaselineStatusResponse) SetStatusCode(v int32) *GetBaselineStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *GetBaselineStatusResponse) SetBody(v *GetBaselineStatusResponseBody) *GetBaselineStatusResponse {
	s.Body = v
	return s
}

type GetBusinessRequest struct {
	// The ID of the workflow. You can call the [ListBusiness](~~173945~~) operation to query the ID.
	BusinessId *int64 `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID. You must specify either this parameter or ProjectIdentifier to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Settings panel to obtain the name. You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s GetBusinessRequest) String() string {
	return tea.Prettify(s)
}

func (s GetBusinessRequest) GoString() string {
	return s.String()
}

func (s *GetBusinessRequest) SetBusinessId(v int64) *GetBusinessRequest {
	s.BusinessId = &v
	return s
}

func (s *GetBusinessRequest) SetProjectId(v int64) *GetBusinessRequest {
	s.ProjectId = &v
	return s
}

func (s *GetBusinessRequest) SetProjectIdentifier(v string) *GetBusinessRequest {
	s.ProjectIdentifier = &v
	return s
}

type GetBusinessResponseBody struct {
	// The details of the workflow.
	Data *GetBusinessResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetBusinessResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetBusinessResponseBody) GoString() string {
	return s.String()
}

func (s *GetBusinessResponseBody) SetData(v *GetBusinessResponseBodyData) *GetBusinessResponseBody {
	s.Data = v
	return s
}

func (s *GetBusinessResponseBody) SetErrorCode(v string) *GetBusinessResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetBusinessResponseBody) SetErrorMessage(v string) *GetBusinessResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetBusinessResponseBody) SetHttpStatusCode(v int32) *GetBusinessResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetBusinessResponseBody) SetRequestId(v string) *GetBusinessResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetBusinessResponseBody) SetSuccess(v bool) *GetBusinessResponseBody {
	s.Success = &v
	return s
}

type GetBusinessResponseBodyData struct {
	// The ID of the workflow.
	BusinessId *int64 `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	// The name of the workflow.
	BusinessName *string `json:"BusinessName,omitempty" xml:"BusinessName,omitempty"`
	// The description of the workflow.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The Alibaba Cloud account ID of the workflow owner.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ID of the workspace to which the workflow belongs.
	ProjectId *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The module to which the workflow belongs. Valid values: NORMAL and MANUAL_BIZ.
	UseType *string `json:"UseType,omitempty" xml:"UseType,omitempty"`
}

func (s GetBusinessResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetBusinessResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetBusinessResponseBodyData) SetBusinessId(v int64) *GetBusinessResponseBodyData {
	s.BusinessId = &v
	return s
}

func (s *GetBusinessResponseBodyData) SetBusinessName(v string) *GetBusinessResponseBodyData {
	s.BusinessName = &v
	return s
}

func (s *GetBusinessResponseBodyData) SetDescription(v string) *GetBusinessResponseBodyData {
	s.Description = &v
	return s
}

func (s *GetBusinessResponseBodyData) SetOwner(v string) *GetBusinessResponseBodyData {
	s.Owner = &v
	return s
}

func (s *GetBusinessResponseBodyData) SetProjectId(v string) *GetBusinessResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetBusinessResponseBodyData) SetUseType(v string) *GetBusinessResponseBodyData {
	s.UseType = &v
	return s
}

type GetBusinessResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetBusinessResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetBusinessResponse) String() string {
	return tea.Prettify(s)
}

func (s GetBusinessResponse) GoString() string {
	return s.String()
}

func (s *GetBusinessResponse) SetHeaders(v map[string]*string) *GetBusinessResponse {
	s.Headers = v
	return s
}

func (s *GetBusinessResponse) SetStatusCode(v int32) *GetBusinessResponse {
	s.StatusCode = &v
	return s
}

func (s *GetBusinessResponse) SetBody(v *GetBusinessResponseBody) *GetBusinessResponse {
	s.Body = v
	return s
}

type GetDDLJobStatusRequest struct {
	// The ID of the DDL task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s GetDDLJobStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDDLJobStatusRequest) GoString() string {
	return s.String()
}

func (s *GetDDLJobStatusRequest) SetTaskId(v string) *GetDDLJobStatusRequest {
	s.TaskId = &v
	return s
}

type GetDDLJobStatusResponseBody struct {
	// The details of the task.
	Data *GetDDLJobStatusResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetDDLJobStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDDLJobStatusResponseBody) GoString() string {
	return s.String()
}

func (s *GetDDLJobStatusResponseBody) SetData(v *GetDDLJobStatusResponseBodyData) *GetDDLJobStatusResponseBody {
	s.Data = v
	return s
}

func (s *GetDDLJobStatusResponseBody) SetRequestId(v string) *GetDDLJobStatusResponseBody {
	s.RequestId = &v
	return s
}

type GetDDLJobStatusResponseBodyData struct {
	// The content of the task.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the ongoing task. If no value is returned for this parameter, all subtasks are complete.
	NextTaskId *string `json:"NextTaskId,omitempty" xml:"NextTaskId,omitempty"`
	// The status of the task
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s GetDDLJobStatusResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDDLJobStatusResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDDLJobStatusResponseBodyData) SetContent(v string) *GetDDLJobStatusResponseBodyData {
	s.Content = &v
	return s
}

func (s *GetDDLJobStatusResponseBodyData) SetNextTaskId(v string) *GetDDLJobStatusResponseBodyData {
	s.NextTaskId = &v
	return s
}

func (s *GetDDLJobStatusResponseBodyData) SetStatus(v string) *GetDDLJobStatusResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetDDLJobStatusResponseBodyData) SetTaskId(v string) *GetDDLJobStatusResponseBodyData {
	s.TaskId = &v
	return s
}

type GetDDLJobStatusResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDDLJobStatusResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDDLJobStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDDLJobStatusResponse) GoString() string {
	return s.String()
}

func (s *GetDDLJobStatusResponse) SetHeaders(v map[string]*string) *GetDDLJobStatusResponse {
	s.Headers = v
	return s
}

func (s *GetDDLJobStatusResponse) SetStatusCode(v int32) *GetDDLJobStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDDLJobStatusResponse) SetBody(v *GetDDLJobStatusResponseBody) *GetDDLJobStatusResponse {
	s.Body = v
	return s
}

type GetDIAlarmRuleRequest struct {
	DIAlarmRuleId *int64 `json:"DIAlarmRuleId,omitempty" xml:"DIAlarmRuleId,omitempty"`
}

func (s GetDIAlarmRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDIAlarmRuleRequest) GoString() string {
	return s.String()
}

func (s *GetDIAlarmRuleRequest) SetDIAlarmRuleId(v int64) *GetDIAlarmRuleRequest {
	s.DIAlarmRuleId = &v
	return s
}

type GetDIAlarmRuleResponseBody struct {
	DIAlarmRule *GetDIAlarmRuleResponseBodyDIAlarmRule `json:"DIAlarmRule,omitempty" xml:"DIAlarmRule,omitempty" type:"Struct"`
	RequestId   *string                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetDIAlarmRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDIAlarmRuleResponseBody) GoString() string {
	return s.String()
}

func (s *GetDIAlarmRuleResponseBody) SetDIAlarmRule(v *GetDIAlarmRuleResponseBodyDIAlarmRule) *GetDIAlarmRuleResponseBody {
	s.DIAlarmRule = v
	return s
}

func (s *GetDIAlarmRuleResponseBody) SetRequestId(v string) *GetDIAlarmRuleResponseBody {
	s.RequestId = &v
	return s
}

type GetDIAlarmRuleResponseBodyDIAlarmRule struct {
	CreatedTime          *int64                                                     `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	CreatedUid           *string                                                    `json:"CreatedUid,omitempty" xml:"CreatedUid,omitempty"`
	DIAlarmRuleId        *int64                                                     `json:"DIAlarmRuleId,omitempty" xml:"DIAlarmRuleId,omitempty"`
	DIJobId              *int64                                                     `json:"DIJobId,omitempty" xml:"DIJobId,omitempty"`
	Description          *string                                                    `json:"Description,omitempty" xml:"Description,omitempty"`
	Enabled              *bool                                                      `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	MetricType           *string                                                    `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	NotificationSettings *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettings `json:"NotificationSettings,omitempty" xml:"NotificationSettings,omitempty" type:"Struct"`
	TriggerConditions    []*GetDIAlarmRuleResponseBodyDIAlarmRuleTriggerConditions  `json:"TriggerConditions,omitempty" xml:"TriggerConditions,omitempty" type:"Repeated"`
	UpdatedTime          *int64                                                     `json:"UpdatedTime,omitempty" xml:"UpdatedTime,omitempty"`
	UpdatedUid           *string                                                    `json:"UpdatedUid,omitempty" xml:"UpdatedUid,omitempty"`
}

func (s GetDIAlarmRuleResponseBodyDIAlarmRule) String() string {
	return tea.Prettify(s)
}

func (s GetDIAlarmRuleResponseBodyDIAlarmRule) GoString() string {
	return s.String()
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRule) SetCreatedTime(v int64) *GetDIAlarmRuleResponseBodyDIAlarmRule {
	s.CreatedTime = &v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRule) SetCreatedUid(v string) *GetDIAlarmRuleResponseBodyDIAlarmRule {
	s.CreatedUid = &v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRule) SetDIAlarmRuleId(v int64) *GetDIAlarmRuleResponseBodyDIAlarmRule {
	s.DIAlarmRuleId = &v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRule) SetDIJobId(v int64) *GetDIAlarmRuleResponseBodyDIAlarmRule {
	s.DIJobId = &v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRule) SetDescription(v string) *GetDIAlarmRuleResponseBodyDIAlarmRule {
	s.Description = &v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRule) SetEnabled(v bool) *GetDIAlarmRuleResponseBodyDIAlarmRule {
	s.Enabled = &v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRule) SetMetricType(v string) *GetDIAlarmRuleResponseBodyDIAlarmRule {
	s.MetricType = &v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRule) SetNotificationSettings(v *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettings) *GetDIAlarmRuleResponseBodyDIAlarmRule {
	s.NotificationSettings = v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRule) SetTriggerConditions(v []*GetDIAlarmRuleResponseBodyDIAlarmRuleTriggerConditions) *GetDIAlarmRuleResponseBodyDIAlarmRule {
	s.TriggerConditions = v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRule) SetUpdatedTime(v int64) *GetDIAlarmRuleResponseBodyDIAlarmRule {
	s.UpdatedTime = &v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRule) SetUpdatedUid(v string) *GetDIAlarmRuleResponseBodyDIAlarmRule {
	s.UpdatedUid = &v
	return s
}

type GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettings struct {
	InhibitionInterval    *int32                                                                            `json:"InhibitionInterval,omitempty" xml:"InhibitionInterval,omitempty"`
	NotificationChannels  []*GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationChannels  `json:"NotificationChannels,omitempty" xml:"NotificationChannels,omitempty" type:"Repeated"`
	NotificationReceivers []*GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationReceivers `json:"NotificationReceivers,omitempty" xml:"NotificationReceivers,omitempty" type:"Repeated"`
}

func (s GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettings) String() string {
	return tea.Prettify(s)
}

func (s GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettings) GoString() string {
	return s.String()
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettings) SetInhibitionInterval(v int32) *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettings {
	s.InhibitionInterval = &v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettings) SetNotificationChannels(v []*GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationChannels) *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettings {
	s.NotificationChannels = v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettings) SetNotificationReceivers(v []*GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationReceivers) *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettings {
	s.NotificationReceivers = v
	return s
}

type GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationChannels struct {
	Channels []*string `json:"Channels,omitempty" xml:"Channels,omitempty" type:"Repeated"`
	Severity *string   `json:"Severity,omitempty" xml:"Severity,omitempty"`
}

func (s GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationChannels) String() string {
	return tea.Prettify(s)
}

func (s GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationChannels) GoString() string {
	return s.String()
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationChannels) SetChannels(v []*string) *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationChannels {
	s.Channels = v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationChannels) SetSeverity(v string) *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationChannels {
	s.Severity = &v
	return s
}

type GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationReceivers struct {
	ReceiverType   *string   `json:"ReceiverType,omitempty" xml:"ReceiverType,omitempty"`
	ReceiverValues []*string `json:"ReceiverValues,omitempty" xml:"ReceiverValues,omitempty" type:"Repeated"`
}

func (s GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationReceivers) String() string {
	return tea.Prettify(s)
}

func (s GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationReceivers) GoString() string {
	return s.String()
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationReceivers) SetReceiverType(v string) *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationReceivers {
	s.ReceiverType = &v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationReceivers) SetReceiverValues(v []*string) *GetDIAlarmRuleResponseBodyDIAlarmRuleNotificationSettingsNotificationReceivers {
	s.ReceiverValues = v
	return s
}

type GetDIAlarmRuleResponseBodyDIAlarmRuleTriggerConditions struct {
	Duration  *int64  `json:"Duration,omitempty" xml:"Duration,omitempty"`
	Severity  *string `json:"Severity,omitempty" xml:"Severity,omitempty"`
	Threshold *int64  `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s GetDIAlarmRuleResponseBodyDIAlarmRuleTriggerConditions) String() string {
	return tea.Prettify(s)
}

func (s GetDIAlarmRuleResponseBodyDIAlarmRuleTriggerConditions) GoString() string {
	return s.String()
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRuleTriggerConditions) SetDuration(v int64) *GetDIAlarmRuleResponseBodyDIAlarmRuleTriggerConditions {
	s.Duration = &v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRuleTriggerConditions) SetSeverity(v string) *GetDIAlarmRuleResponseBodyDIAlarmRuleTriggerConditions {
	s.Severity = &v
	return s
}

func (s *GetDIAlarmRuleResponseBodyDIAlarmRuleTriggerConditions) SetThreshold(v int64) *GetDIAlarmRuleResponseBodyDIAlarmRuleTriggerConditions {
	s.Threshold = &v
	return s
}

type GetDIAlarmRuleResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDIAlarmRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDIAlarmRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDIAlarmRuleResponse) GoString() string {
	return s.String()
}

func (s *GetDIAlarmRuleResponse) SetHeaders(v map[string]*string) *GetDIAlarmRuleResponse {
	s.Headers = v
	return s
}

func (s *GetDIAlarmRuleResponse) SetStatusCode(v int32) *GetDIAlarmRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDIAlarmRuleResponse) SetBody(v *GetDIAlarmRuleResponseBody) *GetDIAlarmRuleResponse {
	s.Body = v
	return s
}

type GetDIJobRequest struct {
	DIJobId     *int64 `json:"DIJobId,omitempty" xml:"DIJobId,omitempty"`
	WithDetails *bool  `json:"WithDetails,omitempty" xml:"WithDetails,omitempty"`
}

func (s GetDIJobRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobRequest) GoString() string {
	return s.String()
}

func (s *GetDIJobRequest) SetDIJobId(v int64) *GetDIJobRequest {
	s.DIJobId = &v
	return s
}

func (s *GetDIJobRequest) SetWithDetails(v bool) *GetDIJobRequest {
	s.WithDetails = &v
	return s
}

type GetDIJobResponseBody struct {
	Data      *GetDIJobResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetDIJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBody) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBody) SetData(v *GetDIJobResponseBodyData) *GetDIJobResponseBody {
	s.Data = v
	return s
}

func (s *GetDIJobResponseBody) SetRequestId(v string) *GetDIJobResponseBody {
	s.RequestId = &v
	return s
}

type GetDIJobResponseBodyData struct {
	CreatedTime                   *int64                                                   `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	CreatedUid                    *string                                                  `json:"CreatedUid,omitempty" xml:"CreatedUid,omitempty"`
	DIJobId                       *int64                                                   `json:"DIJobId,omitempty" xml:"DIJobId,omitempty"`
	Description                   *string                                                  `json:"Description,omitempty" xml:"Description,omitempty"`
	DestinationDataSourceSettings []*GetDIJobResponseBodyDataDestinationDataSourceSettings `json:"DestinationDataSourceSettings,omitempty" xml:"DestinationDataSourceSettings,omitempty" type:"Repeated"`
	DestinationDataSourceType     *string                                                  `json:"DestinationDataSourceType,omitempty" xml:"DestinationDataSourceType,omitempty"`
	ErrorMessage                  *string                                                  `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	JobName                       *string                                                  `json:"JobName,omitempty" xml:"JobName,omitempty"`
	JobSettings                   *GetDIJobResponseBodyDataJobSettings                     `json:"JobSettings,omitempty" xml:"JobSettings,omitempty" type:"Struct"`
	JobStatus                     *string                                                  `json:"JobStatus,omitempty" xml:"JobStatus,omitempty"`
	MigrationType                 *string                                                  `json:"MigrationType,omitempty" xml:"MigrationType,omitempty"`
	ProjectId                     *int64                                                   `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResourceSettings              *GetDIJobResponseBodyDataResourceSettings                `json:"ResourceSettings,omitempty" xml:"ResourceSettings,omitempty" type:"Struct"`
	RunStats                      map[string]*string                                       `json:"RunStats,omitempty" xml:"RunStats,omitempty"`
	SourceDataSourceSettings      []*GetDIJobResponseBodyDataSourceDataSourceSettings      `json:"SourceDataSourceSettings,omitempty" xml:"SourceDataSourceSettings,omitempty" type:"Repeated"`
	SourceDataSourceType          *string                                                  `json:"SourceDataSourceType,omitempty" xml:"SourceDataSourceType,omitempty"`
	StartedTime                   *int64                                                   `json:"StartedTime,omitempty" xml:"StartedTime,omitempty"`
	StartedUid                    *string                                                  `json:"StartedUid,omitempty" xml:"StartedUid,omitempty"`
	TableMappings                 []*GetDIJobResponseBodyDataTableMappings                 `json:"TableMappings,omitempty" xml:"TableMappings,omitempty" type:"Repeated"`
	TransformationRules           []*GetDIJobResponseBodyDataTransformationRules           `json:"TransformationRules,omitempty" xml:"TransformationRules,omitempty" type:"Repeated"`
	UpdatedTime                   *int64                                                   `json:"UpdatedTime,omitempty" xml:"UpdatedTime,omitempty"`
	UpdatedUid                    *string                                                  `json:"UpdatedUid,omitempty" xml:"UpdatedUid,omitempty"`
}

func (s GetDIJobResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBodyData) SetCreatedTime(v int64) *GetDIJobResponseBodyData {
	s.CreatedTime = &v
	return s
}

func (s *GetDIJobResponseBodyData) SetCreatedUid(v string) *GetDIJobResponseBodyData {
	s.CreatedUid = &v
	return s
}

func (s *GetDIJobResponseBodyData) SetDIJobId(v int64) *GetDIJobResponseBodyData {
	s.DIJobId = &v
	return s
}

func (s *GetDIJobResponseBodyData) SetDescription(v string) *GetDIJobResponseBodyData {
	s.Description = &v
	return s
}

func (s *GetDIJobResponseBodyData) SetDestinationDataSourceSettings(v []*GetDIJobResponseBodyDataDestinationDataSourceSettings) *GetDIJobResponseBodyData {
	s.DestinationDataSourceSettings = v
	return s
}

func (s *GetDIJobResponseBodyData) SetDestinationDataSourceType(v string) *GetDIJobResponseBodyData {
	s.DestinationDataSourceType = &v
	return s
}

func (s *GetDIJobResponseBodyData) SetErrorMessage(v string) *GetDIJobResponseBodyData {
	s.ErrorMessage = &v
	return s
}

func (s *GetDIJobResponseBodyData) SetJobName(v string) *GetDIJobResponseBodyData {
	s.JobName = &v
	return s
}

func (s *GetDIJobResponseBodyData) SetJobSettings(v *GetDIJobResponseBodyDataJobSettings) *GetDIJobResponseBodyData {
	s.JobSettings = v
	return s
}

func (s *GetDIJobResponseBodyData) SetJobStatus(v string) *GetDIJobResponseBodyData {
	s.JobStatus = &v
	return s
}

func (s *GetDIJobResponseBodyData) SetMigrationType(v string) *GetDIJobResponseBodyData {
	s.MigrationType = &v
	return s
}

func (s *GetDIJobResponseBodyData) SetProjectId(v int64) *GetDIJobResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetDIJobResponseBodyData) SetResourceSettings(v *GetDIJobResponseBodyDataResourceSettings) *GetDIJobResponseBodyData {
	s.ResourceSettings = v
	return s
}

func (s *GetDIJobResponseBodyData) SetRunStats(v map[string]*string) *GetDIJobResponseBodyData {
	s.RunStats = v
	return s
}

func (s *GetDIJobResponseBodyData) SetSourceDataSourceSettings(v []*GetDIJobResponseBodyDataSourceDataSourceSettings) *GetDIJobResponseBodyData {
	s.SourceDataSourceSettings = v
	return s
}

func (s *GetDIJobResponseBodyData) SetSourceDataSourceType(v string) *GetDIJobResponseBodyData {
	s.SourceDataSourceType = &v
	return s
}

func (s *GetDIJobResponseBodyData) SetStartedTime(v int64) *GetDIJobResponseBodyData {
	s.StartedTime = &v
	return s
}

func (s *GetDIJobResponseBodyData) SetStartedUid(v string) *GetDIJobResponseBodyData {
	s.StartedUid = &v
	return s
}

func (s *GetDIJobResponseBodyData) SetTableMappings(v []*GetDIJobResponseBodyDataTableMappings) *GetDIJobResponseBodyData {
	s.TableMappings = v
	return s
}

func (s *GetDIJobResponseBodyData) SetTransformationRules(v []*GetDIJobResponseBodyDataTransformationRules) *GetDIJobResponseBodyData {
	s.TransformationRules = v
	return s
}

func (s *GetDIJobResponseBodyData) SetUpdatedTime(v int64) *GetDIJobResponseBodyData {
	s.UpdatedTime = &v
	return s
}

func (s *GetDIJobResponseBodyData) SetUpdatedUid(v string) *GetDIJobResponseBodyData {
	s.UpdatedUid = &v
	return s
}

type GetDIJobResponseBodyDataDestinationDataSourceSettings struct {
	DataSourceName       *string            `json:"DataSourceName,omitempty" xml:"DataSourceName,omitempty"`
	DataSourceProperties map[string]*string `json:"DataSourceProperties,omitempty" xml:"DataSourceProperties,omitempty"`
}

func (s GetDIJobResponseBodyDataDestinationDataSourceSettings) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBodyDataDestinationDataSourceSettings) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBodyDataDestinationDataSourceSettings) SetDataSourceName(v string) *GetDIJobResponseBodyDataDestinationDataSourceSettings {
	s.DataSourceName = &v
	return s
}

func (s *GetDIJobResponseBodyDataDestinationDataSourceSettings) SetDataSourceProperties(v map[string]*string) *GetDIJobResponseBodyDataDestinationDataSourceSettings {
	s.DataSourceProperties = v
	return s
}

type GetDIJobResponseBodyDataJobSettings struct {
	ChannelSettings        *string                                                      `json:"ChannelSettings,omitempty" xml:"ChannelSettings,omitempty"`
	ColumnDataTypeSettings []*GetDIJobResponseBodyDataJobSettingsColumnDataTypeSettings `json:"ColumnDataTypeSettings,omitempty" xml:"ColumnDataTypeSettings,omitempty" type:"Repeated"`
	CycleScheduleSettings  *GetDIJobResponseBodyDataJobSettingsCycleScheduleSettings    `json:"CycleScheduleSettings,omitempty" xml:"CycleScheduleSettings,omitempty" type:"Struct"`
	DdlHandlingSettings    []*GetDIJobResponseBodyDataJobSettingsDdlHandlingSettings    `json:"DdlHandlingSettings,omitempty" xml:"DdlHandlingSettings,omitempty" type:"Repeated"`
	RuntimeSettings        []*GetDIJobResponseBodyDataJobSettingsRuntimeSettings        `json:"RuntimeSettings,omitempty" xml:"RuntimeSettings,omitempty" type:"Repeated"`
}

func (s GetDIJobResponseBodyDataJobSettings) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBodyDataJobSettings) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBodyDataJobSettings) SetChannelSettings(v string) *GetDIJobResponseBodyDataJobSettings {
	s.ChannelSettings = &v
	return s
}

func (s *GetDIJobResponseBodyDataJobSettings) SetColumnDataTypeSettings(v []*GetDIJobResponseBodyDataJobSettingsColumnDataTypeSettings) *GetDIJobResponseBodyDataJobSettings {
	s.ColumnDataTypeSettings = v
	return s
}

func (s *GetDIJobResponseBodyDataJobSettings) SetCycleScheduleSettings(v *GetDIJobResponseBodyDataJobSettingsCycleScheduleSettings) *GetDIJobResponseBodyDataJobSettings {
	s.CycleScheduleSettings = v
	return s
}

func (s *GetDIJobResponseBodyDataJobSettings) SetDdlHandlingSettings(v []*GetDIJobResponseBodyDataJobSettingsDdlHandlingSettings) *GetDIJobResponseBodyDataJobSettings {
	s.DdlHandlingSettings = v
	return s
}

func (s *GetDIJobResponseBodyDataJobSettings) SetRuntimeSettings(v []*GetDIJobResponseBodyDataJobSettingsRuntimeSettings) *GetDIJobResponseBodyDataJobSettings {
	s.RuntimeSettings = v
	return s
}

type GetDIJobResponseBodyDataJobSettingsColumnDataTypeSettings struct {
	DestinationDataType *string `json:"DestinationDataType,omitempty" xml:"DestinationDataType,omitempty"`
	SourceDataType      *string `json:"SourceDataType,omitempty" xml:"SourceDataType,omitempty"`
}

func (s GetDIJobResponseBodyDataJobSettingsColumnDataTypeSettings) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBodyDataJobSettingsColumnDataTypeSettings) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBodyDataJobSettingsColumnDataTypeSettings) SetDestinationDataType(v string) *GetDIJobResponseBodyDataJobSettingsColumnDataTypeSettings {
	s.DestinationDataType = &v
	return s
}

func (s *GetDIJobResponseBodyDataJobSettingsColumnDataTypeSettings) SetSourceDataType(v string) *GetDIJobResponseBodyDataJobSettingsColumnDataTypeSettings {
	s.SourceDataType = &v
	return s
}

type GetDIJobResponseBodyDataJobSettingsCycleScheduleSettings struct {
	CycleMigrationType *string `json:"CycleMigrationType,omitempty" xml:"CycleMigrationType,omitempty"`
	ScheduleParameters *string `json:"ScheduleParameters,omitempty" xml:"ScheduleParameters,omitempty"`
}

func (s GetDIJobResponseBodyDataJobSettingsCycleScheduleSettings) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBodyDataJobSettingsCycleScheduleSettings) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBodyDataJobSettingsCycleScheduleSettings) SetCycleMigrationType(v string) *GetDIJobResponseBodyDataJobSettingsCycleScheduleSettings {
	s.CycleMigrationType = &v
	return s
}

func (s *GetDIJobResponseBodyDataJobSettingsCycleScheduleSettings) SetScheduleParameters(v string) *GetDIJobResponseBodyDataJobSettingsCycleScheduleSettings {
	s.ScheduleParameters = &v
	return s
}

type GetDIJobResponseBodyDataJobSettingsDdlHandlingSettings struct {
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	Type   *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetDIJobResponseBodyDataJobSettingsDdlHandlingSettings) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBodyDataJobSettingsDdlHandlingSettings) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBodyDataJobSettingsDdlHandlingSettings) SetAction(v string) *GetDIJobResponseBodyDataJobSettingsDdlHandlingSettings {
	s.Action = &v
	return s
}

func (s *GetDIJobResponseBodyDataJobSettingsDdlHandlingSettings) SetType(v string) *GetDIJobResponseBodyDataJobSettingsDdlHandlingSettings {
	s.Type = &v
	return s
}

type GetDIJobResponseBodyDataJobSettingsRuntimeSettings struct {
	Name  *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetDIJobResponseBodyDataJobSettingsRuntimeSettings) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBodyDataJobSettingsRuntimeSettings) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBodyDataJobSettingsRuntimeSettings) SetName(v string) *GetDIJobResponseBodyDataJobSettingsRuntimeSettings {
	s.Name = &v
	return s
}

func (s *GetDIJobResponseBodyDataJobSettingsRuntimeSettings) SetValue(v string) *GetDIJobResponseBodyDataJobSettingsRuntimeSettings {
	s.Value = &v
	return s
}

type GetDIJobResponseBodyDataResourceSettings struct {
	OfflineResourceSettings  *GetDIJobResponseBodyDataResourceSettingsOfflineResourceSettings  `json:"OfflineResourceSettings,omitempty" xml:"OfflineResourceSettings,omitempty" type:"Struct"`
	RealtimeResourceSettings *GetDIJobResponseBodyDataResourceSettingsRealtimeResourceSettings `json:"RealtimeResourceSettings,omitempty" xml:"RealtimeResourceSettings,omitempty" type:"Struct"`
}

func (s GetDIJobResponseBodyDataResourceSettings) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBodyDataResourceSettings) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBodyDataResourceSettings) SetOfflineResourceSettings(v *GetDIJobResponseBodyDataResourceSettingsOfflineResourceSettings) *GetDIJobResponseBodyDataResourceSettings {
	s.OfflineResourceSettings = v
	return s
}

func (s *GetDIJobResponseBodyDataResourceSettings) SetRealtimeResourceSettings(v *GetDIJobResponseBodyDataResourceSettingsRealtimeResourceSettings) *GetDIJobResponseBodyDataResourceSettings {
	s.RealtimeResourceSettings = v
	return s
}

type GetDIJobResponseBodyDataResourceSettingsOfflineResourceSettings struct {
	ResourceGroupIdentifier *string `json:"ResourceGroupIdentifier,omitempty" xml:"ResourceGroupIdentifier,omitempty"`
}

func (s GetDIJobResponseBodyDataResourceSettingsOfflineResourceSettings) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBodyDataResourceSettingsOfflineResourceSettings) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBodyDataResourceSettingsOfflineResourceSettings) SetResourceGroupIdentifier(v string) *GetDIJobResponseBodyDataResourceSettingsOfflineResourceSettings {
	s.ResourceGroupIdentifier = &v
	return s
}

type GetDIJobResponseBodyDataResourceSettingsRealtimeResourceSettings struct {
	ResourceGroupIdentifier *string `json:"ResourceGroupIdentifier,omitempty" xml:"ResourceGroupIdentifier,omitempty"`
}

func (s GetDIJobResponseBodyDataResourceSettingsRealtimeResourceSettings) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBodyDataResourceSettingsRealtimeResourceSettings) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBodyDataResourceSettingsRealtimeResourceSettings) SetResourceGroupIdentifier(v string) *GetDIJobResponseBodyDataResourceSettingsRealtimeResourceSettings {
	s.ResourceGroupIdentifier = &v
	return s
}

type GetDIJobResponseBodyDataSourceDataSourceSettings struct {
	DataSourceName       *string            `json:"DataSourceName,omitempty" xml:"DataSourceName,omitempty"`
	DataSourceProperties map[string]*string `json:"DataSourceProperties,omitempty" xml:"DataSourceProperties,omitempty"`
}

func (s GetDIJobResponseBodyDataSourceDataSourceSettings) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBodyDataSourceDataSourceSettings) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBodyDataSourceDataSourceSettings) SetDataSourceName(v string) *GetDIJobResponseBodyDataSourceDataSourceSettings {
	s.DataSourceName = &v
	return s
}

func (s *GetDIJobResponseBodyDataSourceDataSourceSettings) SetDataSourceProperties(v map[string]*string) *GetDIJobResponseBodyDataSourceDataSourceSettings {
	s.DataSourceProperties = v
	return s
}

type GetDIJobResponseBodyDataTableMappings struct {
	SourceObjectSelectionRules []*GetDIJobResponseBodyDataTableMappingsSourceObjectSelectionRules `json:"SourceObjectSelectionRules,omitempty" xml:"SourceObjectSelectionRules,omitempty" type:"Repeated"`
	TransformationRules        []*GetDIJobResponseBodyDataTableMappingsTransformationRules        `json:"TransformationRules,omitempty" xml:"TransformationRules,omitempty" type:"Repeated"`
}

func (s GetDIJobResponseBodyDataTableMappings) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBodyDataTableMappings) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBodyDataTableMappings) SetSourceObjectSelectionRules(v []*GetDIJobResponseBodyDataTableMappingsSourceObjectSelectionRules) *GetDIJobResponseBodyDataTableMappings {
	s.SourceObjectSelectionRules = v
	return s
}

func (s *GetDIJobResponseBodyDataTableMappings) SetTransformationRules(v []*GetDIJobResponseBodyDataTableMappingsTransformationRules) *GetDIJobResponseBodyDataTableMappings {
	s.TransformationRules = v
	return s
}

type GetDIJobResponseBodyDataTableMappingsSourceObjectSelectionRules struct {
	Expression *string `json:"Expression,omitempty" xml:"Expression,omitempty"`
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
}

func (s GetDIJobResponseBodyDataTableMappingsSourceObjectSelectionRules) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBodyDataTableMappingsSourceObjectSelectionRules) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBodyDataTableMappingsSourceObjectSelectionRules) SetExpression(v string) *GetDIJobResponseBodyDataTableMappingsSourceObjectSelectionRules {
	s.Expression = &v
	return s
}

func (s *GetDIJobResponseBodyDataTableMappingsSourceObjectSelectionRules) SetObjectType(v string) *GetDIJobResponseBodyDataTableMappingsSourceObjectSelectionRules {
	s.ObjectType = &v
	return s
}

type GetDIJobResponseBodyDataTableMappingsTransformationRules struct {
	RuleActionType *string `json:"RuleActionType,omitempty" xml:"RuleActionType,omitempty"`
	RuleName       *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	RuleTargetType *string `json:"RuleTargetType,omitempty" xml:"RuleTargetType,omitempty"`
}

func (s GetDIJobResponseBodyDataTableMappingsTransformationRules) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBodyDataTableMappingsTransformationRules) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBodyDataTableMappingsTransformationRules) SetRuleActionType(v string) *GetDIJobResponseBodyDataTableMappingsTransformationRules {
	s.RuleActionType = &v
	return s
}

func (s *GetDIJobResponseBodyDataTableMappingsTransformationRules) SetRuleName(v string) *GetDIJobResponseBodyDataTableMappingsTransformationRules {
	s.RuleName = &v
	return s
}

func (s *GetDIJobResponseBodyDataTableMappingsTransformationRules) SetRuleTargetType(v string) *GetDIJobResponseBodyDataTableMappingsTransformationRules {
	s.RuleTargetType = &v
	return s
}

type GetDIJobResponseBodyDataTransformationRules struct {
	RuleActionType *string `json:"RuleActionType,omitempty" xml:"RuleActionType,omitempty"`
	RuleExpression *string `json:"RuleExpression,omitempty" xml:"RuleExpression,omitempty"`
	RuleName       *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	RuleTargetType *string `json:"RuleTargetType,omitempty" xml:"RuleTargetType,omitempty"`
}

func (s GetDIJobResponseBodyDataTransformationRules) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponseBodyDataTransformationRules) GoString() string {
	return s.String()
}

func (s *GetDIJobResponseBodyDataTransformationRules) SetRuleActionType(v string) *GetDIJobResponseBodyDataTransformationRules {
	s.RuleActionType = &v
	return s
}

func (s *GetDIJobResponseBodyDataTransformationRules) SetRuleExpression(v string) *GetDIJobResponseBodyDataTransformationRules {
	s.RuleExpression = &v
	return s
}

func (s *GetDIJobResponseBodyDataTransformationRules) SetRuleName(v string) *GetDIJobResponseBodyDataTransformationRules {
	s.RuleName = &v
	return s
}

func (s *GetDIJobResponseBodyDataTransformationRules) SetRuleTargetType(v string) *GetDIJobResponseBodyDataTransformationRules {
	s.RuleTargetType = &v
	return s
}

type GetDIJobResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDIJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDIJobResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDIJobResponse) GoString() string {
	return s.String()
}

func (s *GetDIJobResponse) SetHeaders(v map[string]*string) *GetDIJobResponse {
	s.Headers = v
	return s
}

func (s *GetDIJobResponse) SetStatusCode(v int32) *GetDIJobResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDIJobResponse) SetBody(v *GetDIJobResponseBody) *GetDIJobResponse {
	s.Body = v
	return s
}

type GetDISyncInstanceInfoRequest struct {
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The type of the object that you want to query. Valid values:
	//
	// *   DI_REALTIME: real-time synchronization node
	// *   DI_SOLUTION: data synchronization solution
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// *   If you set the TaskType parameter to DI_REALTIME, set the FileId parameter to the ID of the real-time synchronization node that you want to query.
	// *   If you set the TaskType parameter to DI_SOLUTION, set the FileId parameter to the ID of the data synchronization solution that you want to query.
	//
	// You can call the [ListFiles](~~173942~~) operation to obtain the ID of the real-time synchronization node or data synchronization solution.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s GetDISyncInstanceInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDISyncInstanceInfoRequest) GoString() string {
	return s.String()
}

func (s *GetDISyncInstanceInfoRequest) SetFileId(v int64) *GetDISyncInstanceInfoRequest {
	s.FileId = &v
	return s
}

func (s *GetDISyncInstanceInfoRequest) SetProjectId(v int64) *GetDISyncInstanceInfoRequest {
	s.ProjectId = &v
	return s
}

func (s *GetDISyncInstanceInfoRequest) SetTaskType(v string) *GetDISyncInstanceInfoRequest {
	s.TaskType = &v
	return s
}

type GetDISyncInstanceInfoResponseBody struct {
	// *   If the TaskType parameter is set to DI_REALTIME, the Status parameter indicates the status of the real-time synchronization node. Valid values: PAUSE, NORUN, RUN, KILLING, and WAIT.
	// *   If the TaskType parameter is set to DI_SOLITION, the Status parameter indicates the status of the data synchronization solution. Valid values: success and fail.
	Data *GetDISyncInstanceInfoResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The status of the real-time synchronization node or data synchronization solution.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDISyncInstanceInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDISyncInstanceInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetDISyncInstanceInfoResponseBody) SetData(v *GetDISyncInstanceInfoResponseBodyData) *GetDISyncInstanceInfoResponseBody {
	s.Data = v
	return s
}

func (s *GetDISyncInstanceInfoResponseBody) SetRequestId(v string) *GetDISyncInstanceInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDISyncInstanceInfoResponseBody) SetSuccess(v bool) *GetDISyncInstanceInfoResponseBody {
	s.Success = &v
	return s
}

type GetDISyncInstanceInfoResponseBodyData struct {
	// *   If the TaskType parameter is set to DI_REALTIME, the Name parameter indicates the name of the real-time synchronization node.
	// *   If the TaskType parameter is set to DI_SOLITION, the value null is returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// *   If the TaskType parameter is set to DI_REALTIME, the value null is returned.
	// *   If the TaskType parameter is set to DI_SOLITION, the SolutionInfo parameter indicates the details of the data synchronization solution.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The status of the data synchronization solution.
	SolutionInfo *GetDISyncInstanceInfoResponseBodyDataSolutionInfo `json:"SolutionInfo,omitempty" xml:"SolutionInfo,omitempty" type:"Struct"`
	// The cause of the failure to obtain the status of the real-time synchronization node or data synchronization solution. If the status of the real-time synchronization node or data synchronization solution is obtained, the value null is returned.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetDISyncInstanceInfoResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDISyncInstanceInfoResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDISyncInstanceInfoResponseBodyData) SetMessage(v string) *GetDISyncInstanceInfoResponseBodyData {
	s.Message = &v
	return s
}

func (s *GetDISyncInstanceInfoResponseBodyData) SetName(v string) *GetDISyncInstanceInfoResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetDISyncInstanceInfoResponseBodyData) SetSolutionInfo(v *GetDISyncInstanceInfoResponseBodyDataSolutionInfo) *GetDISyncInstanceInfoResponseBodyData {
	s.SolutionInfo = v
	return s
}

func (s *GetDISyncInstanceInfoResponseBodyData) SetStatus(v string) *GetDISyncInstanceInfoResponseBodyData {
	s.Status = &v
	return s
}

type GetDISyncInstanceInfoResponseBodyDataSolutionInfo struct {
	// The step details of the synchronization solution.
	CreatorName *string `json:"CreatorName,omitempty" xml:"CreatorName,omitempty"`
	// The creator of the data synchronization solution.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the data synchronization solution.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The status of the step in the data synchronization solution.
	StepDetail []*GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail `json:"StepDetail,omitempty" xml:"StepDetail,omitempty" type:"Repeated"`
}

func (s GetDISyncInstanceInfoResponseBodyDataSolutionInfo) String() string {
	return tea.Prettify(s)
}

func (s GetDISyncInstanceInfoResponseBodyDataSolutionInfo) GoString() string {
	return s.String()
}

func (s *GetDISyncInstanceInfoResponseBodyDataSolutionInfo) SetCreatorName(v string) *GetDISyncInstanceInfoResponseBodyDataSolutionInfo {
	s.CreatorName = &v
	return s
}

func (s *GetDISyncInstanceInfoResponseBodyDataSolutionInfo) SetId(v int64) *GetDISyncInstanceInfoResponseBodyDataSolutionInfo {
	s.Id = &v
	return s
}

func (s *GetDISyncInstanceInfoResponseBodyDataSolutionInfo) SetStatus(v string) *GetDISyncInstanceInfoResponseBodyDataSolutionInfo {
	s.Status = &v
	return s
}

func (s *GetDISyncInstanceInfoResponseBodyDataSolutionInfo) SetStepDetail(v []*GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail) *GetDISyncInstanceInfoResponseBodyDataSolutionInfo {
	s.StepDetail = v
	return s
}

type GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail struct {
	Info *string `json:"Info,omitempty" xml:"Info,omitempty"`
	// The ID of the step in the data synchronization solution.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The name of the step in the data synchronization solution.
	StepId *int64 `json:"StepId,omitempty" xml:"StepId,omitempty"`
	// The information of the data synchronization solution.
	StepName *string `json:"StepName,omitempty" xml:"StepName,omitempty"`
}

func (s GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail) String() string {
	return tea.Prettify(s)
}

func (s GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail) GoString() string {
	return s.String()
}

func (s *GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail) SetInfo(v string) *GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail {
	s.Info = &v
	return s
}

func (s *GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail) SetStatus(v string) *GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail {
	s.Status = &v
	return s
}

func (s *GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail) SetStepId(v int64) *GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail {
	s.StepId = &v
	return s
}

func (s *GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail) SetStepName(v string) *GetDISyncInstanceInfoResponseBodyDataSolutionInfoStepDetail {
	s.StepName = &v
	return s
}

type GetDISyncInstanceInfoResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDISyncInstanceInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDISyncInstanceInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDISyncInstanceInfoResponse) GoString() string {
	return s.String()
}

func (s *GetDISyncInstanceInfoResponse) SetHeaders(v map[string]*string) *GetDISyncInstanceInfoResponse {
	s.Headers = v
	return s
}

func (s *GetDISyncInstanceInfoResponse) SetStatusCode(v int32) *GetDISyncInstanceInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDISyncInstanceInfoResponse) SetBody(v *GetDISyncInstanceInfoResponseBody) *GetDISyncInstanceInfoResponse {
	s.Body = v
	return s
}

type GetDISyncTaskRequest struct {
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The type of the object that you want to query. Valid values:
	//
	// *   DI_REALTIME: real-time synchronization node
	// *   DI_SOLUTION: data synchronization solution
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// *   If you set the TaskType parameter to DI_REALTIME, set the FileId parameter to the ID of the real-time synchronization node that you want to query.
	// *   If you set the TaskType parameter to DI_SOLUTION, set the FileId parameter to the ID of the data synchronization solution that you want to query.
	//
	// You can call the [ListFiles](~~173942~~) operation to query the ID of the real-time synchronization node or data synchronization solution.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s GetDISyncTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDISyncTaskRequest) GoString() string {
	return s.String()
}

func (s *GetDISyncTaskRequest) SetFileId(v int64) *GetDISyncTaskRequest {
	s.FileId = &v
	return s
}

func (s *GetDISyncTaskRequest) SetProjectId(v int64) *GetDISyncTaskRequest {
	s.ProjectId = &v
	return s
}

func (s *GetDISyncTaskRequest) SetTaskType(v string) *GetDISyncTaskRequest {
	s.TaskType = &v
	return s
}

type GetDISyncTaskResponseBody struct {
	// *   If the TaskType parameter is set to DI_REALTIME, the details of the real-time synchronization node are returned.
	// *   If the TaskType parameter is set to DI_SOLUTION, the value null is returned.
	Data *GetDISyncTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The details of the real-time synchronization node or data synchronization solution.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request. You can query logs and troubleshoot issues based on the ID.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDISyncTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDISyncTaskResponseBody) GoString() string {
	return s.String()
}

func (s *GetDISyncTaskResponseBody) SetData(v *GetDISyncTaskResponseBodyData) *GetDISyncTaskResponseBody {
	s.Data = v
	return s
}

func (s *GetDISyncTaskResponseBody) SetRequestId(v string) *GetDISyncTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDISyncTaskResponseBody) SetSuccess(v bool) *GetDISyncTaskResponseBody {
	s.Success = &v
	return s
}

type GetDISyncTaskResponseBodyData struct {
	// Indicates whether the details of the real-time synchronization node or data synchronization solution are obtained. Valid values:
	//
	// success: The details are obtained.
	//
	// fail: The details fail to be obtained.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// *   If the TaskType parameter is set to DI_REALTIME, the value null is returned.
	// *   If the TaskType parameter is set to DI_SOLUTION, the details of the data synchronization solution task are returned.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The status of the data synchronization solution. Valid values:
	//
	// *   0: successful
	// *   1: not running
	// *   2: running
	// *   3: failed
	// *   4: committed
	// *   5: pending manual confirmation
	// *   6: manually confirmed
	// *   7: others
	// *   8: waiting
	// *   9: deleted
	SolutionDetail *GetDISyncTaskResponseBodyDataSolutionDetail `json:"SolutionDetail,omitempty" xml:"SolutionDetail,omitempty" type:"Struct"`
	// The cause of the failure to obtain the details of the real-time synchronization node or data synchronization solution.
	//
	// If the details of the real-time synchronization node or data synchronization solution are obtained, the value null is returned.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetDISyncTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDISyncTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDISyncTaskResponseBodyData) SetCode(v string) *GetDISyncTaskResponseBodyData {
	s.Code = &v
	return s
}

func (s *GetDISyncTaskResponseBodyData) SetMessage(v string) *GetDISyncTaskResponseBodyData {
	s.Message = &v
	return s
}

func (s *GetDISyncTaskResponseBodyData) SetSolutionDetail(v *GetDISyncTaskResponseBodyDataSolutionDetail) *GetDISyncTaskResponseBodyData {
	s.SolutionDetail = v
	return s
}

func (s *GetDISyncTaskResponseBodyData) SetStatus(v string) *GetDISyncTaskResponseBodyData {
	s.Status = &v
	return s
}

type GetDISyncTaskResponseBodyDataSolutionDetail struct {
	// The ID of the project to which the data synchronization solution belongs.
	CreatorName *string `json:"CreatorName,omitempty" xml:"CreatorName,omitempty"`
	Id          *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	// The additional parameters of the data synchronization solution.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The name of the data synchronization solution.
	ProcessContent *string `json:"ProcessContent,omitempty" xml:"ProcessContent,omitempty"`
	// The time when the data synchronization solution was committed.
	ProcessExtra *string `json:"ProcessExtra,omitempty" xml:"ProcessExtra,omitempty"`
	// The type of the source of the data synchronization solution.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The configuration details of the data synchronization solution.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	// The creator of the data synchronization solution.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The type of the data synchronization solution.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the data synchronization solution.
	SubmitTime *string `json:"SubmitTime,omitempty" xml:"SubmitTime,omitempty"`
	// The start time of the data synchronization solution.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetDISyncTaskResponseBodyDataSolutionDetail) String() string {
	return tea.Prettify(s)
}

func (s GetDISyncTaskResponseBodyDataSolutionDetail) GoString() string {
	return s.String()
}

func (s *GetDISyncTaskResponseBodyDataSolutionDetail) SetCreatorName(v string) *GetDISyncTaskResponseBodyDataSolutionDetail {
	s.CreatorName = &v
	return s
}

func (s *GetDISyncTaskResponseBodyDataSolutionDetail) SetId(v int64) *GetDISyncTaskResponseBodyDataSolutionDetail {
	s.Id = &v
	return s
}

func (s *GetDISyncTaskResponseBodyDataSolutionDetail) SetName(v string) *GetDISyncTaskResponseBodyDataSolutionDetail {
	s.Name = &v
	return s
}

func (s *GetDISyncTaskResponseBodyDataSolutionDetail) SetProcessContent(v string) *GetDISyncTaskResponseBodyDataSolutionDetail {
	s.ProcessContent = &v
	return s
}

func (s *GetDISyncTaskResponseBodyDataSolutionDetail) SetProcessExtra(v string) *GetDISyncTaskResponseBodyDataSolutionDetail {
	s.ProcessExtra = &v
	return s
}

func (s *GetDISyncTaskResponseBodyDataSolutionDetail) SetProjectId(v int64) *GetDISyncTaskResponseBodyDataSolutionDetail {
	s.ProjectId = &v
	return s
}

func (s *GetDISyncTaskResponseBodyDataSolutionDetail) SetSourceType(v string) *GetDISyncTaskResponseBodyDataSolutionDetail {
	s.SourceType = &v
	return s
}

func (s *GetDISyncTaskResponseBodyDataSolutionDetail) SetStartTime(v string) *GetDISyncTaskResponseBodyDataSolutionDetail {
	s.StartTime = &v
	return s
}

func (s *GetDISyncTaskResponseBodyDataSolutionDetail) SetStatus(v string) *GetDISyncTaskResponseBodyDataSolutionDetail {
	s.Status = &v
	return s
}

func (s *GetDISyncTaskResponseBodyDataSolutionDetail) SetSubmitTime(v string) *GetDISyncTaskResponseBodyDataSolutionDetail {
	s.SubmitTime = &v
	return s
}

func (s *GetDISyncTaskResponseBodyDataSolutionDetail) SetType(v string) *GetDISyncTaskResponseBodyDataSolutionDetail {
	s.Type = &v
	return s
}

type GetDISyncTaskResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDISyncTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDISyncTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDISyncTaskResponse) GoString() string {
	return s.String()
}

func (s *GetDISyncTaskResponse) SetHeaders(v map[string]*string) *GetDISyncTaskResponse {
	s.Headers = v
	return s
}

func (s *GetDISyncTaskResponse) SetStatusCode(v int32) *GetDISyncTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDISyncTaskResponse) SetBody(v *GetDISyncTaskResponseBody) *GetDISyncTaskResponse {
	s.Body = v
	return s
}

type GetDagRequest struct {
	// The ID of the DAG. You can set this parameter to the value of the DagId parameter returned by the CreateDagComplement, CreateTest, or CreateManualDag operation.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The environment type. Valid values: PROD and DEV. The value PROD indicates the production environment. The value DEV indicates the development environment.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s GetDagRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDagRequest) GoString() string {
	return s.String()
}

func (s *GetDagRequest) SetDagId(v int64) *GetDagRequest {
	s.DagId = &v
	return s
}

func (s *GetDagRequest) SetProjectEnv(v string) *GetDagRequest {
	s.ProjectEnv = &v
	return s
}

type GetDagResponseBody struct {
	// The details of the DAG.
	Data *GetDagResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage   *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDagResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDagResponseBody) GoString() string {
	return s.String()
}

func (s *GetDagResponseBody) SetData(v *GetDagResponseBodyData) *GetDagResponseBody {
	s.Data = v
	return s
}

func (s *GetDagResponseBody) SetErrorCode(v string) *GetDagResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDagResponseBody) SetErrorMessage(v string) *GetDagResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDagResponseBody) SetHttpStatusCode(v int32) *GetDagResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetDagResponseBody) SetRequestId(v string) *GetDagResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDagResponseBody) SetSuccess(v bool) *GetDagResponseBody {
	s.Success = &v
	return s
}

type GetDagResponseBodyData struct {
	// The data timestamp.
	Bizdate *int64 `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	// The time at which the DAG was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The user who created the DAG.
	CreateUser *string `json:"CreateUser,omitempty" xml:"CreateUser,omitempty"`
	// The ID of the DAG.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The time at which the DAG finished running. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	FinishTime *int64 `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	// The time at which the DAG was scheduled to run.
	Gmtdate *int64 `json:"Gmtdate,omitempty" xml:"Gmtdate,omitempty"`
	// The time at which the DAG was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	ModifyTime *int64 `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The name of the DAG.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The sequence number of the operation.
	OpSeq *int64 `json:"OpSeq,omitempty" xml:"OpSeq,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The time at which the DAG started to run.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The status of the DAG. Valid values: CREATED, RUNNING, FAILURE, and SUCCESS.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the DAG. Valid values: MANUAL, SMOKE_TEST, SUPPLY_DATA, and BUSINESS_PROCESS_DAG.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetDagResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDagResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDagResponseBodyData) SetBizdate(v int64) *GetDagResponseBodyData {
	s.Bizdate = &v
	return s
}

func (s *GetDagResponseBodyData) SetCreateTime(v int64) *GetDagResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *GetDagResponseBodyData) SetCreateUser(v string) *GetDagResponseBodyData {
	s.CreateUser = &v
	return s
}

func (s *GetDagResponseBodyData) SetDagId(v int64) *GetDagResponseBodyData {
	s.DagId = &v
	return s
}

func (s *GetDagResponseBodyData) SetFinishTime(v int64) *GetDagResponseBodyData {
	s.FinishTime = &v
	return s
}

func (s *GetDagResponseBodyData) SetGmtdate(v int64) *GetDagResponseBodyData {
	s.Gmtdate = &v
	return s
}

func (s *GetDagResponseBodyData) SetModifyTime(v int64) *GetDagResponseBodyData {
	s.ModifyTime = &v
	return s
}

func (s *GetDagResponseBodyData) SetName(v string) *GetDagResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetDagResponseBodyData) SetOpSeq(v int64) *GetDagResponseBodyData {
	s.OpSeq = &v
	return s
}

func (s *GetDagResponseBodyData) SetProjectId(v int64) *GetDagResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetDagResponseBodyData) SetStartTime(v int64) *GetDagResponseBodyData {
	s.StartTime = &v
	return s
}

func (s *GetDagResponseBodyData) SetStatus(v string) *GetDagResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetDagResponseBodyData) SetType(v string) *GetDagResponseBodyData {
	s.Type = &v
	return s
}

type GetDagResponse struct {
	Headers    map[string]*string  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDagResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDagResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDagResponse) GoString() string {
	return s.String()
}

func (s *GetDagResponse) SetHeaders(v map[string]*string) *GetDagResponse {
	s.Headers = v
	return s
}

func (s *GetDagResponse) SetStatusCode(v int32) *GetDagResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDagResponse) SetBody(v *GetDagResponseBody) *GetDagResponse {
	s.Body = v
	return s
}

type GetDataServiceApiRequest struct {
	// The ID of the DataService Studio API.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s GetDataServiceApiRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiRequest) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiRequest) SetApiId(v int64) *GetDataServiceApiRequest {
	s.ApiId = &v
	return s
}

func (s *GetDataServiceApiRequest) SetProjectId(v int64) *GetDataServiceApiRequest {
	s.ProjectId = &v
	return s
}

func (s *GetDataServiceApiRequest) SetTenantId(v int64) *GetDataServiceApiRequest {
	s.TenantId = &v
	return s
}

type GetDataServiceApiResponseBody struct {
	// The data returned.
	Data *GetDataServiceApiResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataServiceApiResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiResponseBody) SetData(v *GetDataServiceApiResponseBodyData) *GetDataServiceApiResponseBody {
	s.Data = v
	return s
}

func (s *GetDataServiceApiResponseBody) SetErrorCode(v string) *GetDataServiceApiResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataServiceApiResponseBody) SetErrorMessage(v string) *GetDataServiceApiResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataServiceApiResponseBody) SetHttpStatusCode(v int32) *GetDataServiceApiResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetDataServiceApiResponseBody) SetRequestId(v string) *GetDataServiceApiResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataServiceApiResponseBody) SetSuccess(v bool) *GetDataServiceApiResponseBody {
	s.Success = &v
	return s
}

type GetDataServiceApiResponseBodyData struct {
	// The ID of the DataService Studio API.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The type of the API. Valid values: 0, 1, and 2. The value 0 indicates that the API is generated in wizard mode. The value 1 indicates that the API is generated in script mode. The value 2 indicates that the API is generated by registration.
	ApiMode *int32 `json:"ApiMode,omitempty" xml:"ApiMode,omitempty"`
	// The name of the API.
	ApiName *string `json:"ApiName,omitempty" xml:"ApiName,omitempty"`
	// The path of the API.
	ApiPath *string `json:"ApiPath,omitempty" xml:"ApiPath,omitempty"`
	// The creation time.
	CreatedTime *string `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The ID of the Alibaba Cloud account used by the creator of the API.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the folder.
	FolderId *int64 `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The ID of the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The time when the API was last modified.
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The ID of the Alibaba Cloud account used by the user who last modified the API.
	OperatorId *string `json:"OperatorId,omitempty" xml:"OperatorId,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The list of fields.
	Protocols []*int32 `json:"Protocols,omitempty" xml:"Protocols,omitempty" type:"Repeated"`
	// The details of the API generated by registration. This parameter is returned only if the API is generated by registration.
	RegistrationDetails *GetDataServiceApiResponseBodyDataRegistrationDetails `json:"RegistrationDetails,omitempty" xml:"RegistrationDetails,omitempty" type:"Struct"`
	// The request method of the API. Valid values: 0, 1, 2, and 3. The value 0 indicates the GET method, the value 1 indicates the POST method, the value 2 indicates the PUT method, and the value 3 indicates the DELETE method. APIs generated in wizard or script mode support the GET and POST methods. APIs generated by registration support the GET, POST, PUT, and DELETE methods.
	RequestMethod *int32 `json:"RequestMethod,omitempty" xml:"RequestMethod,omitempty"`
	// The format in which the response of the API request is returned. Valid values: 0 and 1. The value 0 indicates the JSON format. The value 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
	ResponseContentType *int32 `json:"ResponseContentType,omitempty" xml:"ResponseContentType,omitempty"`
	// The details of the API generated in script mode. This parameter is returned only if the API is generated in script mode.
	ScriptDetails *GetDataServiceApiResponseBodyDataScriptDetails `json:"ScriptDetails,omitempty" xml:"ScriptDetails,omitempty" type:"Struct"`
	// The status of the API. Valid values: 0 and 1. The value 0 indicates that the API is not published. The value 1 indicates that the API is published.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	// The timeout period of the API request. Unit: milliseconds.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The scope in which the API is visible. Valid values: 0 and 1. The value 0 indicates that the API is visible to the members in a specific workspace. The value 1 indicates that the API is visible only to the API creator.
	VisibleRange *int32 `json:"VisibleRange,omitempty" xml:"VisibleRange,omitempty"`
	// The details of the API generated in wizard mode. This parameter is returned only if the API is generated in wizard mode.
	WizardDetails *GetDataServiceApiResponseBodyDataWizardDetails `json:"WizardDetails,omitempty" xml:"WizardDetails,omitempty" type:"Struct"`
}

func (s GetDataServiceApiResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiResponseBodyData) SetApiId(v int64) *GetDataServiceApiResponseBodyData {
	s.ApiId = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetApiMode(v int32) *GetDataServiceApiResponseBodyData {
	s.ApiMode = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetApiName(v string) *GetDataServiceApiResponseBodyData {
	s.ApiName = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetApiPath(v string) *GetDataServiceApiResponseBodyData {
	s.ApiPath = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetCreatedTime(v string) *GetDataServiceApiResponseBodyData {
	s.CreatedTime = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetCreatorId(v string) *GetDataServiceApiResponseBodyData {
	s.CreatorId = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetDescription(v string) *GetDataServiceApiResponseBodyData {
	s.Description = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetFolderId(v int64) *GetDataServiceApiResponseBodyData {
	s.FolderId = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetGroupId(v string) *GetDataServiceApiResponseBodyData {
	s.GroupId = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetModifiedTime(v string) *GetDataServiceApiResponseBodyData {
	s.ModifiedTime = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetOperatorId(v string) *GetDataServiceApiResponseBodyData {
	s.OperatorId = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetProjectId(v int64) *GetDataServiceApiResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetProtocols(v []*int32) *GetDataServiceApiResponseBodyData {
	s.Protocols = v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetRegistrationDetails(v *GetDataServiceApiResponseBodyDataRegistrationDetails) *GetDataServiceApiResponseBodyData {
	s.RegistrationDetails = v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetRequestMethod(v int32) *GetDataServiceApiResponseBodyData {
	s.RequestMethod = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetResponseContentType(v int32) *GetDataServiceApiResponseBodyData {
	s.ResponseContentType = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetScriptDetails(v *GetDataServiceApiResponseBodyDataScriptDetails) *GetDataServiceApiResponseBodyData {
	s.ScriptDetails = v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetStatus(v int32) *GetDataServiceApiResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetTenantId(v int64) *GetDataServiceApiResponseBodyData {
	s.TenantId = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetTimeout(v int32) *GetDataServiceApiResponseBodyData {
	s.Timeout = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetVisibleRange(v int32) *GetDataServiceApiResponseBodyData {
	s.VisibleRange = &v
	return s
}

func (s *GetDataServiceApiResponseBodyData) SetWizardDetails(v *GetDataServiceApiResponseBodyDataWizardDetails) *GetDataServiceApiResponseBodyData {
	s.WizardDetails = v
	return s
}

type GetDataServiceApiResponseBodyDataRegistrationDetails struct {
	// The sample error response of the API.
	FailedResultSample *string `json:"FailedResultSample,omitempty" xml:"FailedResultSample,omitempty"`
	// The error codes returned for the API generated by registration.
	RegistrationErrorCodes []*GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes `json:"RegistrationErrorCodes,omitempty" xml:"RegistrationErrorCodes,omitempty" type:"Repeated"`
	// The request parameters of the API generated by registration.
	RegistrationRequestParameters []*GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters `json:"RegistrationRequestParameters,omitempty" xml:"RegistrationRequestParameters,omitempty" type:"Repeated"`
	// The format in which the response of the API request is returned. Valid values:
	//
	// *   0: indicates the JSON format.
	// *   1: indicates the XML format.
	//
	// APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
	ServiceContentType *int32 `json:"ServiceContentType,omitempty" xml:"ServiceContentType,omitempty"`
	// The address of the backend service.
	ServiceHost *string `json:"ServiceHost,omitempty" xml:"ServiceHost,omitempty"`
	// The path of the backend service.
	ServicePath *string `json:"ServicePath,omitempty" xml:"ServicePath,omitempty"`
	// The description of the request body initiated to call the backend service.
	ServiceRequestBodyDescription *string `json:"ServiceRequestBodyDescription,omitempty" xml:"ServiceRequestBodyDescription,omitempty"`
	// Sample success responses
	SuccessfulResultSample *string `json:"SuccessfulResultSample,omitempty" xml:"SuccessfulResultSample,omitempty"`
}

func (s GetDataServiceApiResponseBodyDataRegistrationDetails) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiResponseBodyDataRegistrationDetails) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetails) SetFailedResultSample(v string) *GetDataServiceApiResponseBodyDataRegistrationDetails {
	s.FailedResultSample = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetails) SetRegistrationErrorCodes(v []*GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes) *GetDataServiceApiResponseBodyDataRegistrationDetails {
	s.RegistrationErrorCodes = v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetails) SetRegistrationRequestParameters(v []*GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) *GetDataServiceApiResponseBodyDataRegistrationDetails {
	s.RegistrationRequestParameters = v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetails) SetServiceContentType(v int32) *GetDataServiceApiResponseBodyDataRegistrationDetails {
	s.ServiceContentType = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetails) SetServiceHost(v string) *GetDataServiceApiResponseBodyDataRegistrationDetails {
	s.ServiceHost = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetails) SetServicePath(v string) *GetDataServiceApiResponseBodyDataRegistrationDetails {
	s.ServicePath = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetails) SetServiceRequestBodyDescription(v string) *GetDataServiceApiResponseBodyDataRegistrationDetails {
	s.ServiceRequestBodyDescription = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetails) SetSuccessfulResultSample(v string) *GetDataServiceApiResponseBodyDataRegistrationDetails {
	s.SuccessfulResultSample = &v
	return s
}

type GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The solution used to fix the error.
	ErrorSolution *string `json:"ErrorSolution,omitempty" xml:"ErrorSolution,omitempty"`
}

func (s GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes) SetErrorCode(v string) *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes {
	s.ErrorCode = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes) SetErrorMessage(v string) *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes) SetErrorSolution(v string) *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes {
	s.ErrorSolution = &v
	return s
}

type GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters struct {
	// The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The default value.
	DefaultValue *string `json:"DefaultValue,omitempty" xml:"DefaultValue,omitempty"`
	// The sample value.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// Indicates whether the parameter is required.
	IsRequiredParameter *bool `json:"IsRequiredParameter,omitempty" xml:"IsRequiredParameter,omitempty"`
	// The data type of the parameter. Valid values: 0, 1, 2, 3, 4, and 5. The value 0 indicates the STRING data type, the value 1 indicates the INT data type, the value 2 indicates the LONG data type, the value 3 indicates the FLOAT data type, the value 4 indicates the DOUBLE data type, and the value 5 indicates the BOOLEAN data type.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The operator used for the value of the parameter. Valid values:
	//
	// *   0: indicates that the operator is Equal.
	// *   1: indicates that the operator is Like.
	// *   2: indicates that the operator is Const.
	// *   3: indicates that the operator is In.
	//
	// APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
	ParameterOperator *int32 `json:"ParameterOperator,omitempty" xml:"ParameterOperator,omitempty"`
	// The position of the parameter. Valid values:
	//
	// *   0: indicates that the parameter is in the URL path of the request.
	// *   1: indicates that the parameter is in the Query parameter of the request URL.
	// *   2: indicates that the parameter is in the request header.
	// *   3: indicates that the parameter is in the request body.
	//
	// APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
	ParameterPosition *int32 `json:"ParameterPosition,omitempty" xml:"ParameterPosition,omitempty"`
}

func (s GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetColumnName(v string) *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.ColumnName = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetDefaultValue(v string) *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.DefaultValue = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetExampleValue(v string) *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.ExampleValue = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetIsRequiredParameter(v bool) *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.IsRequiredParameter = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetParameterDataType(v int32) *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.ParameterDataType = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetParameterDescription(v string) *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.ParameterDescription = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetParameterName(v string) *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.ParameterName = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetParameterOperator(v int32) *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.ParameterOperator = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetParameterPosition(v int32) *GetDataServiceApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.ParameterPosition = &v
	return s
}

type GetDataServiceApiResponseBodyDataScriptDetails struct {
	// Indicates whether the entries were returned by page.
	IsPagedResponse *bool `json:"IsPagedResponse,omitempty" xml:"IsPagedResponse,omitempty"`
	// The SQL script.
	Script *string `json:"Script,omitempty" xml:"Script,omitempty"`
	// The data source information of the API generated in script mode.
	ScriptConnection *GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection `json:"ScriptConnection,omitempty" xml:"ScriptConnection,omitempty" type:"Struct"`
	// The request parameters of the API generated in script mode.
	ScriptRequestParameters []*GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters `json:"ScriptRequestParameters,omitempty" xml:"ScriptRequestParameters,omitempty" type:"Repeated"`
	// The response parameters of the API generated in script mode.
	ScriptResponseParameters []*GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters `json:"ScriptResponseParameters,omitempty" xml:"ScriptResponseParameters,omitempty" type:"Repeated"`
}

func (s GetDataServiceApiResponseBodyDataScriptDetails) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiResponseBodyDataScriptDetails) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiResponseBodyDataScriptDetails) SetIsPagedResponse(v bool) *GetDataServiceApiResponseBodyDataScriptDetails {
	s.IsPagedResponse = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetails) SetScript(v string) *GetDataServiceApiResponseBodyDataScriptDetails {
	s.Script = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetails) SetScriptConnection(v *GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection) *GetDataServiceApiResponseBodyDataScriptDetails {
	s.ScriptConnection = v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetails) SetScriptRequestParameters(v []*GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters) *GetDataServiceApiResponseBodyDataScriptDetails {
	s.ScriptRequestParameters = v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetails) SetScriptResponseParameters(v []*GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters) *GetDataServiceApiResponseBodyDataScriptDetails {
	s.ScriptResponseParameters = v
	return s
}

type GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection struct {
	// The ID of the data source.
	ConnectionId *int64 `json:"ConnectionId,omitempty" xml:"ConnectionId,omitempty"`
	// The name of the table in the data source.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection) SetConnectionId(v int64) *GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection {
	s.ConnectionId = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection) SetTableName(v string) *GetDataServiceApiResponseBodyDataScriptDetailsScriptConnection {
	s.TableName = &v
	return s
}

type GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters struct {
	// The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The default value.
	DefaultValue *string `json:"DefaultValue,omitempty" xml:"DefaultValue,omitempty"`
	// The sample value.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// Indicates whether the parameter is required.
	IsRequiredParameter *bool `json:"IsRequiredParameter,omitempty" xml:"IsRequiredParameter,omitempty"`
	// The data type of the parameter. Valid values: 0, 1, 2, 3, 4, and 5. The value 0 indicates the STRING data type, the value 1 indicates the INT data type, the value 2 indicates the LONG data type, the value 3 indicates the FLOAT data type, the value 4 indicates the DOUBLE data type, and the value 5 indicates the BOOLEAN data type.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The operator used for the value of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates that the operator is Equal, the value 1 indicates that the operator is Like, the value 2 indicates that the operator is Const, and the value 3 indicates that the operator is In. APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
	ParameterOperator *int32 `json:"ParameterOperator,omitempty" xml:"ParameterOperator,omitempty"`
	// The position of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates that the parameter is in the URL path of the request, the value 1 indicates that the parameter is in the Query parameter of the request URL, the value 2 indicates that the parameter is in the request header, and the value 3 indicates that the parameter is in the request body. APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
	ParameterPosition *int32 `json:"ParameterPosition,omitempty" xml:"ParameterPosition,omitempty"`
}

func (s GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters) SetColumnName(v string) *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.ColumnName = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters) SetDefaultValue(v string) *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.DefaultValue = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters) SetExampleValue(v string) *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.ExampleValue = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters) SetIsRequiredParameter(v bool) *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.IsRequiredParameter = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters) SetParameterDataType(v int32) *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.ParameterDataType = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters) SetParameterDescription(v string) *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.ParameterDescription = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters) SetParameterName(v string) *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.ParameterName = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters) SetParameterOperator(v int32) *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.ParameterOperator = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters) SetParameterPosition(v int32) *GetDataServiceApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.ParameterPosition = &v
	return s
}

type GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters struct {
	// The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The sample value.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// The data type of the parameter. Valid values: 0, 1, 2, 3, 4, and 5. The value 0 indicates the STRING data type, the value 1 indicates the INT data type, the value 2 indicates the LONG data type, the value 3 indicates the FLOAT data type, the value 4 indicates the DOUBLE data type, and the value 5 indicates the BOOLEAN data type.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
}

func (s GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters) SetColumnName(v string) *GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters {
	s.ColumnName = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters) SetExampleValue(v string) *GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters {
	s.ExampleValue = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters) SetParameterDataType(v int32) *GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters {
	s.ParameterDataType = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters) SetParameterDescription(v string) *GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters {
	s.ParameterDescription = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters) SetParameterName(v string) *GetDataServiceApiResponseBodyDataScriptDetailsScriptResponseParameters {
	s.ParameterName = &v
	return s
}

type GetDataServiceApiResponseBodyDataWizardDetails struct {
	// Indicates whether the entries were returned by page.
	IsPagedResponse *bool `json:"IsPagedResponse,omitempty" xml:"IsPagedResponse,omitempty"`
	// The data source information of the API generated in wizard mode.
	WizardConnection *GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection `json:"WizardConnection,omitempty" xml:"WizardConnection,omitempty" type:"Struct"`
	// The request parameters of the API generated in wizard mode.
	WizardRequestParameters []*GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters `json:"WizardRequestParameters,omitempty" xml:"WizardRequestParameters,omitempty" type:"Repeated"`
	// The response parameters of the API generated in wizard mode.
	WizardResponseParameters []*GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters `json:"WizardResponseParameters,omitempty" xml:"WizardResponseParameters,omitempty" type:"Repeated"`
}

func (s GetDataServiceApiResponseBodyDataWizardDetails) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiResponseBodyDataWizardDetails) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiResponseBodyDataWizardDetails) SetIsPagedResponse(v bool) *GetDataServiceApiResponseBodyDataWizardDetails {
	s.IsPagedResponse = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetails) SetWizardConnection(v *GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection) *GetDataServiceApiResponseBodyDataWizardDetails {
	s.WizardConnection = v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetails) SetWizardRequestParameters(v []*GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters) *GetDataServiceApiResponseBodyDataWizardDetails {
	s.WizardRequestParameters = v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetails) SetWizardResponseParameters(v []*GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters) *GetDataServiceApiResponseBodyDataWizardDetails {
	s.WizardResponseParameters = v
	return s
}

type GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection struct {
	// The ID of the data source.
	ConnectionId *int64 `json:"ConnectionId,omitempty" xml:"ConnectionId,omitempty"`
	// The name of the table in the data source.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection) SetConnectionId(v int64) *GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection {
	s.ConnectionId = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection) SetTableName(v string) *GetDataServiceApiResponseBodyDataWizardDetailsWizardConnection {
	s.TableName = &v
	return s
}

type GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters struct {
	// The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The default value.
	DefaultValue *string `json:"DefaultValue,omitempty" xml:"DefaultValue,omitempty"`
	// The sample value.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// Indicates whether the parameter is required.
	IsRequiredParameter *bool `json:"IsRequiredParameter,omitempty" xml:"IsRequiredParameter,omitempty"`
	// The data type of the parameter. Valid values: 0, 1, 2, 3, 4, and 5. The value 0 indicates the STRING data type, the value 1 indicates the INT data type, the value 2 indicates the LONG data type, the value 3 indicates the FLOAT data type, the value 4 indicates the DOUBLE data type, and the value 5 indicates the BOOLEAN data type.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The operator used for the value of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates that the operator is Equal, the value 1 indicates that the operator is Like, the value 2 indicates that the operator is Const, and the value 3 indicates that the operator is In. APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
	ParameterOperator *int32 `json:"ParameterOperator,omitempty" xml:"ParameterOperator,omitempty"`
	// The position of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates that the parameter is in the URL path of the request, the value 1 indicates that the parameter is in the Query parameter of the request URL, the value 2 indicates that the parameter is in the request header, and the value 3 indicates that the parameter is in the request body. APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
	ParameterPosition *int32 `json:"ParameterPosition,omitempty" xml:"ParameterPosition,omitempty"`
}

func (s GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters) SetColumnName(v string) *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.ColumnName = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters) SetDefaultValue(v string) *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.DefaultValue = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters) SetExampleValue(v string) *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.ExampleValue = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters) SetIsRequiredParameter(v bool) *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.IsRequiredParameter = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters) SetParameterDataType(v int32) *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.ParameterDataType = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters) SetParameterDescription(v string) *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.ParameterDescription = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters) SetParameterName(v string) *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.ParameterName = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters) SetParameterOperator(v int32) *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.ParameterOperator = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters) SetParameterPosition(v int32) *GetDataServiceApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.ParameterPosition = &v
	return s
}

type GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters struct {
	// The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The sample value.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// The data type of the parameter. Valid values: 0, 1, 2, 3, 4, and 5. The value 0 indicates the STRING data type, the value 1 indicates the INT data type, the value 2 indicates the LONG data type, the value 3 indicates the FLOAT data type, the value 4 indicates the DOUBLE data type, and the value 5 indicates the BOOLEAN data type.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
}

func (s GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters) SetColumnName(v string) *GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters {
	s.ColumnName = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters) SetExampleValue(v string) *GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters {
	s.ExampleValue = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters) SetParameterDataType(v int32) *GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters {
	s.ParameterDataType = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters) SetParameterDescription(v string) *GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters {
	s.ParameterDescription = &v
	return s
}

func (s *GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters) SetParameterName(v string) *GetDataServiceApiResponseBodyDataWizardDetailsWizardResponseParameters {
	s.ParameterName = &v
	return s
}

type GetDataServiceApiResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDataServiceApiResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDataServiceApiResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiResponse) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiResponse) SetHeaders(v map[string]*string) *GetDataServiceApiResponse {
	s.Headers = v
	return s
}

func (s *GetDataServiceApiResponse) SetStatusCode(v int32) *GetDataServiceApiResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataServiceApiResponse) SetBody(v *GetDataServiceApiResponseBody) *GetDataServiceApiResponse {
	s.Body = v
	return s
}

type GetDataServiceApiTestRequest struct {
	TestId *int64 `json:"TestId,omitempty" xml:"TestId,omitempty"`
}

func (s GetDataServiceApiTestRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiTestRequest) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiTestRequest) SetTestId(v int64) *GetDataServiceApiTestRequest {
	s.TestId = &v
	return s
}

type GetDataServiceApiTestResponseBody struct {
	Data      *GetDataServiceApiTestResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetDataServiceApiTestResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiTestResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiTestResponseBody) SetData(v *GetDataServiceApiTestResponseBodyData) *GetDataServiceApiTestResponseBody {
	s.Data = v
	return s
}

func (s *GetDataServiceApiTestResponseBody) SetRequestId(v string) *GetDataServiceApiTestResponseBody {
	s.RequestId = &v
	return s
}

type GetDataServiceApiTestResponseBodyData struct {
	ApiId          *int64  `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	CostTime       *string `json:"CostTime,omitempty" xml:"CostTime,omitempty"`
	DebugInfo      *string `json:"DebugInfo,omitempty" xml:"DebugInfo,omitempty"`
	NodesDebugInfo *string `json:"NodesDebugInfo,omitempty" xml:"NodesDebugInfo,omitempty"`
	ParamMap       *string `json:"ParamMap,omitempty" xml:"ParamMap,omitempty"`
	RetCode        *int64  `json:"RetCode,omitempty" xml:"RetCode,omitempty"`
	RetResult      *string `json:"RetResult,omitempty" xml:"RetResult,omitempty"`
	Status         *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetDataServiceApiTestResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiTestResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiTestResponseBodyData) SetApiId(v int64) *GetDataServiceApiTestResponseBodyData {
	s.ApiId = &v
	return s
}

func (s *GetDataServiceApiTestResponseBodyData) SetCostTime(v string) *GetDataServiceApiTestResponseBodyData {
	s.CostTime = &v
	return s
}

func (s *GetDataServiceApiTestResponseBodyData) SetDebugInfo(v string) *GetDataServiceApiTestResponseBodyData {
	s.DebugInfo = &v
	return s
}

func (s *GetDataServiceApiTestResponseBodyData) SetNodesDebugInfo(v string) *GetDataServiceApiTestResponseBodyData {
	s.NodesDebugInfo = &v
	return s
}

func (s *GetDataServiceApiTestResponseBodyData) SetParamMap(v string) *GetDataServiceApiTestResponseBodyData {
	s.ParamMap = &v
	return s
}

func (s *GetDataServiceApiTestResponseBodyData) SetRetCode(v int64) *GetDataServiceApiTestResponseBodyData {
	s.RetCode = &v
	return s
}

func (s *GetDataServiceApiTestResponseBodyData) SetRetResult(v string) *GetDataServiceApiTestResponseBodyData {
	s.RetResult = &v
	return s
}

func (s *GetDataServiceApiTestResponseBodyData) SetStatus(v string) *GetDataServiceApiTestResponseBodyData {
	s.Status = &v
	return s
}

type GetDataServiceApiTestResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDataServiceApiTestResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDataServiceApiTestResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApiTestResponse) GoString() string {
	return s.String()
}

func (s *GetDataServiceApiTestResponse) SetHeaders(v map[string]*string) *GetDataServiceApiTestResponse {
	s.Headers = v
	return s
}

func (s *GetDataServiceApiTestResponse) SetStatusCode(v int32) *GetDataServiceApiTestResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataServiceApiTestResponse) SetBody(v *GetDataServiceApiTestResponseBody) *GetDataServiceApiTestResponse {
	s.Body = v
	return s
}

type GetDataServiceApplicationRequest struct {
	// The ID of the application. You can view the information about the application in the API Gateway console.
	ApplicationId *int64 `json:"ApplicationId,omitempty" xml:"ApplicationId,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s GetDataServiceApplicationRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApplicationRequest) GoString() string {
	return s.String()
}

func (s *GetDataServiceApplicationRequest) SetApplicationId(v int64) *GetDataServiceApplicationRequest {
	s.ApplicationId = &v
	return s
}

func (s *GetDataServiceApplicationRequest) SetProjectId(v int64) *GetDataServiceApplicationRequest {
	s.ProjectId = &v
	return s
}

func (s *GetDataServiceApplicationRequest) SetTenantId(v int64) *GetDataServiceApplicationRequest {
	s.TenantId = &v
	return s
}

type GetDataServiceApplicationResponseBody struct {
	// The details of the application.
	Data *GetDataServiceApplicationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataServiceApplicationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApplicationResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataServiceApplicationResponseBody) SetData(v *GetDataServiceApplicationResponseBodyData) *GetDataServiceApplicationResponseBody {
	s.Data = v
	return s
}

func (s *GetDataServiceApplicationResponseBody) SetErrorCode(v string) *GetDataServiceApplicationResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataServiceApplicationResponseBody) SetErrorMessage(v string) *GetDataServiceApplicationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataServiceApplicationResponseBody) SetHttpStatusCode(v int32) *GetDataServiceApplicationResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetDataServiceApplicationResponseBody) SetRequestId(v string) *GetDataServiceApplicationResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataServiceApplicationResponseBody) SetSuccess(v bool) *GetDataServiceApplicationResponseBody {
	s.Success = &v
	return s
}

type GetDataServiceApplicationResponseBodyData struct {
	// The AppCode for simple authentication. You can select simple authentication or signature authentication when you call an API operation.
	ApplicationCode *string `json:"ApplicationCode,omitempty" xml:"ApplicationCode,omitempty"`
	// The ID of the application.
	ApplicationId *int64 `json:"ApplicationId,omitempty" xml:"ApplicationId,omitempty"`
	// The AppKey for signature authentication. You can select simple authentication or signature authentication when you call an API operation.
	ApplicationKey *string `json:"ApplicationKey,omitempty" xml:"ApplicationKey,omitempty"`
	// The name of the application.
	ApplicationName *string `json:"ApplicationName,omitempty" xml:"ApplicationName,omitempty"`
	// The AppSecret for signature authentication. You can select simple authentication or signature authentication when you call an API operation.
	ApplicationSecret *string `json:"ApplicationSecret,omitempty" xml:"ApplicationSecret,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetDataServiceApplicationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApplicationResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDataServiceApplicationResponseBodyData) SetApplicationCode(v string) *GetDataServiceApplicationResponseBodyData {
	s.ApplicationCode = &v
	return s
}

func (s *GetDataServiceApplicationResponseBodyData) SetApplicationId(v int64) *GetDataServiceApplicationResponseBodyData {
	s.ApplicationId = &v
	return s
}

func (s *GetDataServiceApplicationResponseBodyData) SetApplicationKey(v string) *GetDataServiceApplicationResponseBodyData {
	s.ApplicationKey = &v
	return s
}

func (s *GetDataServiceApplicationResponseBodyData) SetApplicationName(v string) *GetDataServiceApplicationResponseBodyData {
	s.ApplicationName = &v
	return s
}

func (s *GetDataServiceApplicationResponseBodyData) SetApplicationSecret(v string) *GetDataServiceApplicationResponseBodyData {
	s.ApplicationSecret = &v
	return s
}

func (s *GetDataServiceApplicationResponseBodyData) SetProjectId(v int64) *GetDataServiceApplicationResponseBodyData {
	s.ProjectId = &v
	return s
}

type GetDataServiceApplicationResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDataServiceApplicationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDataServiceApplicationResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceApplicationResponse) GoString() string {
	return s.String()
}

func (s *GetDataServiceApplicationResponse) SetHeaders(v map[string]*string) *GetDataServiceApplicationResponse {
	s.Headers = v
	return s
}

func (s *GetDataServiceApplicationResponse) SetStatusCode(v int32) *GetDataServiceApplicationResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataServiceApplicationResponse) SetBody(v *GetDataServiceApplicationResponseBody) *GetDataServiceApplicationResponse {
	s.Body = v
	return s
}

type GetDataServiceFolderRequest struct {
	// The ID of the folder.
	FolderId *int64 `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s GetDataServiceFolderRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceFolderRequest) GoString() string {
	return s.String()
}

func (s *GetDataServiceFolderRequest) SetFolderId(v int64) *GetDataServiceFolderRequest {
	s.FolderId = &v
	return s
}

func (s *GetDataServiceFolderRequest) SetProjectId(v int64) *GetDataServiceFolderRequest {
	s.ProjectId = &v
	return s
}

func (s *GetDataServiceFolderRequest) SetTenantId(v int64) *GetDataServiceFolderRequest {
	s.TenantId = &v
	return s
}

type GetDataServiceFolderResponseBody struct {
	// The details of the folder.
	Folder *GetDataServiceFolderResponseBodyFolder `json:"Folder,omitempty" xml:"Folder,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetDataServiceFolderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceFolderResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataServiceFolderResponseBody) SetFolder(v *GetDataServiceFolderResponseBodyFolder) *GetDataServiceFolderResponseBody {
	s.Folder = v
	return s
}

func (s *GetDataServiceFolderResponseBody) SetRequestId(v string) *GetDataServiceFolderResponseBody {
	s.RequestId = &v
	return s
}

type GetDataServiceFolderResponseBodyFolder struct {
	// The time when the folder was created.
	CreatedTime *string `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The ID of the folder.
	FolderId *int64 `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The name of the folder.
	FolderName *string `json:"FolderName,omitempty" xml:"FolderName,omitempty"`
	// The ID of the business process to which the folder belongs.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The time when the folder was last modified.
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The ID of the parent folder. The ID of the root folder in a business process is 0, and the ID of a folder created by a user in a business process is greater than 0.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s GetDataServiceFolderResponseBodyFolder) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceFolderResponseBodyFolder) GoString() string {
	return s.String()
}

func (s *GetDataServiceFolderResponseBodyFolder) SetCreatedTime(v string) *GetDataServiceFolderResponseBodyFolder {
	s.CreatedTime = &v
	return s
}

func (s *GetDataServiceFolderResponseBodyFolder) SetFolderId(v int64) *GetDataServiceFolderResponseBodyFolder {
	s.FolderId = &v
	return s
}

func (s *GetDataServiceFolderResponseBodyFolder) SetFolderName(v string) *GetDataServiceFolderResponseBodyFolder {
	s.FolderName = &v
	return s
}

func (s *GetDataServiceFolderResponseBodyFolder) SetGroupId(v string) *GetDataServiceFolderResponseBodyFolder {
	s.GroupId = &v
	return s
}

func (s *GetDataServiceFolderResponseBodyFolder) SetModifiedTime(v string) *GetDataServiceFolderResponseBodyFolder {
	s.ModifiedTime = &v
	return s
}

func (s *GetDataServiceFolderResponseBodyFolder) SetParentId(v int64) *GetDataServiceFolderResponseBodyFolder {
	s.ParentId = &v
	return s
}

func (s *GetDataServiceFolderResponseBodyFolder) SetProjectId(v int64) *GetDataServiceFolderResponseBodyFolder {
	s.ProjectId = &v
	return s
}

func (s *GetDataServiceFolderResponseBodyFolder) SetTenantId(v int64) *GetDataServiceFolderResponseBodyFolder {
	s.TenantId = &v
	return s
}

type GetDataServiceFolderResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDataServiceFolderResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDataServiceFolderResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceFolderResponse) GoString() string {
	return s.String()
}

func (s *GetDataServiceFolderResponse) SetHeaders(v map[string]*string) *GetDataServiceFolderResponse {
	s.Headers = v
	return s
}

func (s *GetDataServiceFolderResponse) SetStatusCode(v int32) *GetDataServiceFolderResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataServiceFolderResponse) SetBody(v *GetDataServiceFolderResponseBody) *GetDataServiceFolderResponse {
	s.Body = v
	return s
}

type GetDataServiceGroupRequest struct {
	// The ID of the business process.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s GetDataServiceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceGroupRequest) GoString() string {
	return s.String()
}

func (s *GetDataServiceGroupRequest) SetGroupId(v string) *GetDataServiceGroupRequest {
	s.GroupId = &v
	return s
}

func (s *GetDataServiceGroupRequest) SetProjectId(v int64) *GetDataServiceGroupRequest {
	s.ProjectId = &v
	return s
}

func (s *GetDataServiceGroupRequest) SetTenantId(v int64) *GetDataServiceGroupRequest {
	s.TenantId = &v
	return s
}

type GetDataServiceGroupResponseBody struct {
	// The details of the business process.
	Group *GetDataServiceGroupResponseBodyGroup `json:"Group,omitempty" xml:"Group,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetDataServiceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataServiceGroupResponseBody) SetGroup(v *GetDataServiceGroupResponseBodyGroup) *GetDataServiceGroupResponseBody {
	s.Group = v
	return s
}

func (s *GetDataServiceGroupResponseBody) SetRequestId(v string) *GetDataServiceGroupResponseBody {
	s.RequestId = &v
	return s
}

type GetDataServiceGroupResponseBodyGroup struct {
	// The ID of the API group that is associated with the business process in the API Gateway console.
	ApiGatewayGroupId *string `json:"ApiGatewayGroupId,omitempty" xml:"ApiGatewayGroupId,omitempty"`
	// The time when the business process was created.
	CreatedTime *string `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The user identifier (UID) of the creator of the business process. The value of this parameter may be empty for creators of some existing business processes.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The description of the business process.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the business process.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the business process.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The time when the business process was last modified.
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s GetDataServiceGroupResponseBodyGroup) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceGroupResponseBodyGroup) GoString() string {
	return s.String()
}

func (s *GetDataServiceGroupResponseBodyGroup) SetApiGatewayGroupId(v string) *GetDataServiceGroupResponseBodyGroup {
	s.ApiGatewayGroupId = &v
	return s
}

func (s *GetDataServiceGroupResponseBodyGroup) SetCreatedTime(v string) *GetDataServiceGroupResponseBodyGroup {
	s.CreatedTime = &v
	return s
}

func (s *GetDataServiceGroupResponseBodyGroup) SetCreatorId(v string) *GetDataServiceGroupResponseBodyGroup {
	s.CreatorId = &v
	return s
}

func (s *GetDataServiceGroupResponseBodyGroup) SetDescription(v string) *GetDataServiceGroupResponseBodyGroup {
	s.Description = &v
	return s
}

func (s *GetDataServiceGroupResponseBodyGroup) SetGroupId(v string) *GetDataServiceGroupResponseBodyGroup {
	s.GroupId = &v
	return s
}

func (s *GetDataServiceGroupResponseBodyGroup) SetGroupName(v string) *GetDataServiceGroupResponseBodyGroup {
	s.GroupName = &v
	return s
}

func (s *GetDataServiceGroupResponseBodyGroup) SetModifiedTime(v string) *GetDataServiceGroupResponseBodyGroup {
	s.ModifiedTime = &v
	return s
}

func (s *GetDataServiceGroupResponseBodyGroup) SetProjectId(v int64) *GetDataServiceGroupResponseBodyGroup {
	s.ProjectId = &v
	return s
}

func (s *GetDataServiceGroupResponseBodyGroup) SetTenantId(v int64) *GetDataServiceGroupResponseBodyGroup {
	s.TenantId = &v
	return s
}

type GetDataServiceGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDataServiceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDataServiceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataServiceGroupResponse) GoString() string {
	return s.String()
}

func (s *GetDataServiceGroupResponse) SetHeaders(v map[string]*string) *GetDataServiceGroupResponse {
	s.Headers = v
	return s
}

func (s *GetDataServiceGroupResponse) SetStatusCode(v int32) *GetDataServiceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataServiceGroupResponse) SetBody(v *GetDataServiceGroupResponseBody) *GetDataServiceGroupResponse {
	s.Body = v
	return s
}

type GetDataServicePublishedApiRequest struct {
	// The ID of the API.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s GetDataServicePublishedApiRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiRequest) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiRequest) SetApiId(v int64) *GetDataServicePublishedApiRequest {
	s.ApiId = &v
	return s
}

func (s *GetDataServicePublishedApiRequest) SetProjectId(v int64) *GetDataServicePublishedApiRequest {
	s.ProjectId = &v
	return s
}

func (s *GetDataServicePublishedApiRequest) SetTenantId(v int64) *GetDataServicePublishedApiRequest {
	s.TenantId = &v
	return s
}

type GetDataServicePublishedApiResponseBody struct {
	// The latest information of the API in the published state.
	Data *GetDataServicePublishedApiResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataServicePublishedApiResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponseBody) SetData(v *GetDataServicePublishedApiResponseBodyData) *GetDataServicePublishedApiResponseBody {
	s.Data = v
	return s
}

func (s *GetDataServicePublishedApiResponseBody) SetErrorCode(v string) *GetDataServicePublishedApiResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBody) SetErrorMessage(v string) *GetDataServicePublishedApiResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBody) SetHttpStatusCode(v int32) *GetDataServicePublishedApiResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBody) SetRequestId(v string) *GetDataServicePublishedApiResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBody) SetSuccess(v bool) *GetDataServicePublishedApiResponseBody {
	s.Success = &v
	return s
}

type GetDataServicePublishedApiResponseBodyData struct {
	// The ID of the DataService Studio API.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The type of the API. Valid values: 0, 1, and 2. The value 0 indicates that the API is generated in wizard mode. The value 1 indicates that the API is generated in script mode. The value 2 indicates that the API is generated by registration.
	ApiMode *int32 `json:"ApiMode,omitempty" xml:"ApiMode,omitempty"`
	// The name of the API.
	ApiName *string `json:"ApiName,omitempty" xml:"ApiName,omitempty"`
	// The path of the API.
	ApiPath *string `json:"ApiPath,omitempty" xml:"ApiPath,omitempty"`
	// The creation time.
	CreatedTime *string `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The ID of the Alibaba Cloud account used by the creator of the API.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The description.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The time when the API was last modified.
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The ID of the Alibaba Cloud account used by the user who last modified the API.
	OperatorId *string `json:"OperatorId,omitempty" xml:"OperatorId,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The list of fields.
	Protocols []*int32 `json:"Protocols,omitempty" xml:"Protocols,omitempty" type:"Repeated"`
	// The details of the API generated by registration. This parameter is returned only if the API is generated by registration.
	RegistrationDetails *GetDataServicePublishedApiResponseBodyDataRegistrationDetails `json:"RegistrationDetails,omitempty" xml:"RegistrationDetails,omitempty" type:"Struct"`
	// The request method of the API. Valid values: 0, 1, 2, and 3. The value 0 indicates the GET method, the value 1 indicates the POST method, the value 2 indicates the PUT method, and the value 3 indicates the DELETE method. APIs generated in wizard or script mode support the GET and POST methods. APIs generated by registration support the GET, POST, PUT, and DELETE methods.
	RequestMethod *int32 `json:"RequestMethod,omitempty" xml:"RequestMethod,omitempty"`
	// The format in which the response of the API request is returned. Valid values: 0 and 1. The value 0 indicates the JSON format. The value 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
	ResponseContentType *int32 `json:"ResponseContentType,omitempty" xml:"ResponseContentType,omitempty"`
	// The details of the API generated in script mode. This parameter is returned only if the API is generated in script mode.
	ScriptDetails *GetDataServicePublishedApiResponseBodyDataScriptDetails `json:"ScriptDetails,omitempty" xml:"ScriptDetails,omitempty" type:"Struct"`
	// The status of the API. Valid values: 0 and 1. The value 0 indicates that the API is not published. The value 1 indicates that the API is published.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	// The timeout period of the API request. Unit: milliseconds.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The scope in which the API is visible. Valid values: 0 and 1. The value 0 indicates that the API is visible to the members in a specific workspace. The value 1 indicates that the API is visible only to the API creator.
	VisibleRange *int32 `json:"VisibleRange,omitempty" xml:"VisibleRange,omitempty"`
	// The details of the API generated in wizard mode. This parameter is returned only if the API is generated in wizard mode.
	WizardDetails *GetDataServicePublishedApiResponseBodyDataWizardDetails `json:"WizardDetails,omitempty" xml:"WizardDetails,omitempty" type:"Struct"`
}

func (s GetDataServicePublishedApiResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponseBodyData) SetApiId(v int64) *GetDataServicePublishedApiResponseBodyData {
	s.ApiId = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetApiMode(v int32) *GetDataServicePublishedApiResponseBodyData {
	s.ApiMode = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetApiName(v string) *GetDataServicePublishedApiResponseBodyData {
	s.ApiName = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetApiPath(v string) *GetDataServicePublishedApiResponseBodyData {
	s.ApiPath = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetCreatedTime(v string) *GetDataServicePublishedApiResponseBodyData {
	s.CreatedTime = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetCreatorId(v string) *GetDataServicePublishedApiResponseBodyData {
	s.CreatorId = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetDescription(v string) *GetDataServicePublishedApiResponseBodyData {
	s.Description = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetGroupId(v string) *GetDataServicePublishedApiResponseBodyData {
	s.GroupId = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetModifiedTime(v string) *GetDataServicePublishedApiResponseBodyData {
	s.ModifiedTime = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetOperatorId(v string) *GetDataServicePublishedApiResponseBodyData {
	s.OperatorId = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetProjectId(v int64) *GetDataServicePublishedApiResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetProtocols(v []*int32) *GetDataServicePublishedApiResponseBodyData {
	s.Protocols = v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetRegistrationDetails(v *GetDataServicePublishedApiResponseBodyDataRegistrationDetails) *GetDataServicePublishedApiResponseBodyData {
	s.RegistrationDetails = v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetRequestMethod(v int32) *GetDataServicePublishedApiResponseBodyData {
	s.RequestMethod = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetResponseContentType(v int32) *GetDataServicePublishedApiResponseBodyData {
	s.ResponseContentType = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetScriptDetails(v *GetDataServicePublishedApiResponseBodyDataScriptDetails) *GetDataServicePublishedApiResponseBodyData {
	s.ScriptDetails = v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetStatus(v int32) *GetDataServicePublishedApiResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetTenantId(v int64) *GetDataServicePublishedApiResponseBodyData {
	s.TenantId = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetTimeout(v int32) *GetDataServicePublishedApiResponseBodyData {
	s.Timeout = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetVisibleRange(v int32) *GetDataServicePublishedApiResponseBodyData {
	s.VisibleRange = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyData) SetWizardDetails(v *GetDataServicePublishedApiResponseBodyDataWizardDetails) *GetDataServicePublishedApiResponseBodyData {
	s.WizardDetails = v
	return s
}

type GetDataServicePublishedApiResponseBodyDataRegistrationDetails struct {
	// The sample error response of the API.
	FailedResultSample *string `json:"FailedResultSample,omitempty" xml:"FailedResultSample,omitempty"`
	// The error codes returned for the API generated by registration.
	RegistrationErrorCodes []*GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes `json:"RegistrationErrorCodes,omitempty" xml:"RegistrationErrorCodes,omitempty" type:"Repeated"`
	// The request parameters of the API generated by registration.
	RegistrationRequestParameters []*GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters `json:"RegistrationRequestParameters,omitempty" xml:"RegistrationRequestParameters,omitempty" type:"Repeated"`
	// The format in which the response of the API request is returned. Valid values: 0 and 1. The value 0 indicates the JSON format. The value 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
	ServiceContentType *int32 `json:"ServiceContentType,omitempty" xml:"ServiceContentType,omitempty"`
	// The address of the backend service.
	ServiceHost *string `json:"ServiceHost,omitempty" xml:"ServiceHost,omitempty"`
	// The path of the backend service.
	ServicePath *string `json:"ServicePath,omitempty" xml:"ServicePath,omitempty"`
	// The description of the request body initiated to call the backend service.
	ServiceRequestBodyDescription *string `json:"ServiceRequestBodyDescription,omitempty" xml:"ServiceRequestBodyDescription,omitempty"`
	// The sample success response of the API.
	SuccessfulResultSample *string `json:"SuccessfulResultSample,omitempty" xml:"SuccessfulResultSample,omitempty"`
}

func (s GetDataServicePublishedApiResponseBodyDataRegistrationDetails) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponseBodyDataRegistrationDetails) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetails) SetFailedResultSample(v string) *GetDataServicePublishedApiResponseBodyDataRegistrationDetails {
	s.FailedResultSample = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetails) SetRegistrationErrorCodes(v []*GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes) *GetDataServicePublishedApiResponseBodyDataRegistrationDetails {
	s.RegistrationErrorCodes = v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetails) SetRegistrationRequestParameters(v []*GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) *GetDataServicePublishedApiResponseBodyDataRegistrationDetails {
	s.RegistrationRequestParameters = v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetails) SetServiceContentType(v int32) *GetDataServicePublishedApiResponseBodyDataRegistrationDetails {
	s.ServiceContentType = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetails) SetServiceHost(v string) *GetDataServicePublishedApiResponseBodyDataRegistrationDetails {
	s.ServiceHost = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetails) SetServicePath(v string) *GetDataServicePublishedApiResponseBodyDataRegistrationDetails {
	s.ServicePath = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetails) SetServiceRequestBodyDescription(v string) *GetDataServicePublishedApiResponseBodyDataRegistrationDetails {
	s.ServiceRequestBodyDescription = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetails) SetSuccessfulResultSample(v string) *GetDataServicePublishedApiResponseBodyDataRegistrationDetails {
	s.SuccessfulResultSample = &v
	return s
}

type GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The solution used to fix the error.
	ErrorSolution *string `json:"ErrorSolution,omitempty" xml:"ErrorSolution,omitempty"`
}

func (s GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes) SetErrorCode(v string) *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes {
	s.ErrorCode = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes) SetErrorMessage(v string) *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes) SetErrorSolution(v string) *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationErrorCodes {
	s.ErrorSolution = &v
	return s
}

type GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters struct {
	// The default value.
	DefaultValue *string `json:"DefaultValue,omitempty" xml:"DefaultValue,omitempty"`
	// The sample value.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// Indicates whether the parameter is required.
	IsRequiredParameter *bool `json:"IsRequiredParameter,omitempty" xml:"IsRequiredParameter,omitempty"`
	// The data type of the parameter. Valid values: 0, 1, 2, 3, 4, and 5. The value 0 indicates the STRING data type, the value 1 indicates the INT data type, the value 2 indicates the LONG data type, the value 3 indicates the FLOAT data type, the value 4 indicates the DOUBLE data type, and the value 5 indicates the BOOLEAN data type.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The operator used for the value of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates that the operator is Equal, the value 1 indicates that the operator is Like, the value 2 indicates that the operator is Const, and the value 3 indicates that the operator is In. APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
	ParameterOperator *int32 `json:"ParameterOperator,omitempty" xml:"ParameterOperator,omitempty"`
	// The position of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates that the parameter is in the URL path of the request, the value 1 indicates that the parameter is in the Query parameter of the request URL, the value 2 indicates that the parameter is in the request header, and the value 3 indicates that the parameter is in the request body. APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
	ParameterPosition *int32 `json:"ParameterPosition,omitempty" xml:"ParameterPosition,omitempty"`
}

func (s GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetDefaultValue(v string) *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.DefaultValue = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetExampleValue(v string) *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.ExampleValue = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetIsRequiredParameter(v bool) *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.IsRequiredParameter = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetParameterDataType(v int32) *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.ParameterDataType = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetParameterDescription(v string) *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.ParameterDescription = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetParameterName(v string) *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.ParameterName = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetParameterOperator(v int32) *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.ParameterOperator = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters) SetParameterPosition(v int32) *GetDataServicePublishedApiResponseBodyDataRegistrationDetailsRegistrationRequestParameters {
	s.ParameterPosition = &v
	return s
}

type GetDataServicePublishedApiResponseBodyDataScriptDetails struct {
	// The sample error response of the API.
	FailedResultSample *string `json:"FailedResultSample,omitempty" xml:"FailedResultSample,omitempty"`
	// Indicates whether the entries were returned by page.
	IsPagedResponse *bool `json:"IsPagedResponse,omitempty" xml:"IsPagedResponse,omitempty"`
	// The SQL script.
	Script *string `json:"Script,omitempty" xml:"Script,omitempty"`
	// The data source information of the API generated in script mode.
	ScriptConnection *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection `json:"ScriptConnection,omitempty" xml:"ScriptConnection,omitempty" type:"Struct"`
	// The error codes returned for the API generated in script mode.
	ScriptErrorCodes []*GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes `json:"ScriptErrorCodes,omitempty" xml:"ScriptErrorCodes,omitempty" type:"Repeated"`
	// The request parameters of the API generated in script mode.
	ScriptRequestParameters []*GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters `json:"ScriptRequestParameters,omitempty" xml:"ScriptRequestParameters,omitempty" type:"Repeated"`
	// The response parameters of the API generated in script mode.
	ScriptResponseParameters []*GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters `json:"ScriptResponseParameters,omitempty" xml:"ScriptResponseParameters,omitempty" type:"Repeated"`
	// The sample success response of the API.
	SuccessfulResultSample *string `json:"SuccessfulResultSample,omitempty" xml:"SuccessfulResultSample,omitempty"`
}

func (s GetDataServicePublishedApiResponseBodyDataScriptDetails) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponseBodyDataScriptDetails) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetails) SetFailedResultSample(v string) *GetDataServicePublishedApiResponseBodyDataScriptDetails {
	s.FailedResultSample = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetails) SetIsPagedResponse(v bool) *GetDataServicePublishedApiResponseBodyDataScriptDetails {
	s.IsPagedResponse = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetails) SetScript(v string) *GetDataServicePublishedApiResponseBodyDataScriptDetails {
	s.Script = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetails) SetScriptConnection(v *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection) *GetDataServicePublishedApiResponseBodyDataScriptDetails {
	s.ScriptConnection = v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetails) SetScriptErrorCodes(v []*GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes) *GetDataServicePublishedApiResponseBodyDataScriptDetails {
	s.ScriptErrorCodes = v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetails) SetScriptRequestParameters(v []*GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters) *GetDataServicePublishedApiResponseBodyDataScriptDetails {
	s.ScriptRequestParameters = v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetails) SetScriptResponseParameters(v []*GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters) *GetDataServicePublishedApiResponseBodyDataScriptDetails {
	s.ScriptResponseParameters = v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetails) SetSuccessfulResultSample(v string) *GetDataServicePublishedApiResponseBodyDataScriptDetails {
	s.SuccessfulResultSample = &v
	return s
}

type GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection struct {
	// The ID of the data source.
	ConnectionId *int64 `json:"ConnectionId,omitempty" xml:"ConnectionId,omitempty"`
	// The name of the table in the data source.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection) SetConnectionId(v int64) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection {
	s.ConnectionId = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection) SetTableName(v string) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptConnection {
	s.TableName = &v
	return s
}

type GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The solution used to fix the error.
	ErrorSolution *string `json:"ErrorSolution,omitempty" xml:"ErrorSolution,omitempty"`
}

func (s GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes) SetErrorCode(v string) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes {
	s.ErrorCode = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes) SetErrorMessage(v string) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes) SetErrorSolution(v string) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptErrorCodes {
	s.ErrorSolution = &v
	return s
}

type GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters struct {
	// The default value.
	DefaultValue *string `json:"DefaultValue,omitempty" xml:"DefaultValue,omitempty"`
	// The sample value.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// Indicates whether the parameter is required.
	IsRequiredParameter *bool `json:"IsRequiredParameter,omitempty" xml:"IsRequiredParameter,omitempty"`
	// The data type of the parameter. Valid values:
	//
	// *   0: indicates the STRING data type.
	// *   1: indicates the INT data type.
	// *   2: indicates the LONG data type.
	// *   3: indicates the FLOAT data type.
	// *   4: indicates the DOUBLE data type.
	// *   5: indicates the BOOLEAN data type.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The operator used for the value of the parameter. Valid values:
	//
	// *   0: indicates that the operator is Equal.
	// *   1: indicates that the operator is Like.
	// *   2: indicates that the operator is Const.
	// *   3: indicates that the operator is In.
	//
	// APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
	ParameterOperator *int32 `json:"ParameterOperator,omitempty" xml:"ParameterOperator,omitempty"`
	// The position of the parameter. Valid values:
	//
	// *   0: indicates that the parameter is in the URL path of the request.
	// *   1: indicates that the parameter is in the Query parameter of the request URL.
	// *   2: indicates that the parameter is in the request header.
	// *   3: indicates that the parameter is in the request body.
	//
	// APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
	ParameterPosition *int32 `json:"ParameterPosition,omitempty" xml:"ParameterPosition,omitempty"`
}

func (s GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters) SetDefaultValue(v string) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.DefaultValue = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters) SetExampleValue(v string) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.ExampleValue = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters) SetIsRequiredParameter(v bool) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.IsRequiredParameter = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters) SetParameterDataType(v int32) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.ParameterDataType = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters) SetParameterDescription(v string) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.ParameterDescription = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters) SetParameterName(v string) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.ParameterName = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters) SetParameterOperator(v int32) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.ParameterOperator = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters) SetParameterPosition(v int32) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptRequestParameters {
	s.ParameterPosition = &v
	return s
}

type GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters struct {
	// The sample value.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// The data type of the parameter. Valid values: 0, 1, 2, 3, 4, and 5. The value 0 indicates the STRING data type, the value 1 indicates the INT data type, the value 2 indicates the LONG data type, the value 3 indicates the FLOAT data type, the value 4 indicates the DOUBLE data type, and the value 5 indicates the BOOLEAN data type.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
}

func (s GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters) SetExampleValue(v string) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters {
	s.ExampleValue = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters) SetParameterDataType(v int32) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters {
	s.ParameterDataType = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters) SetParameterDescription(v string) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters {
	s.ParameterDescription = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters) SetParameterName(v string) *GetDataServicePublishedApiResponseBodyDataScriptDetailsScriptResponseParameters {
	s.ParameterName = &v
	return s
}

type GetDataServicePublishedApiResponseBodyDataWizardDetails struct {
	// The sample error response of the API.
	FailedResultSample *string `json:"FailedResultSample,omitempty" xml:"FailedResultSample,omitempty"`
	// Indicates whether the entries were returned by page.
	IsPagedResponse *bool `json:"IsPagedResponse,omitempty" xml:"IsPagedResponse,omitempty"`
	// The sample success response of the API.
	SuccessfulResultSample *string `json:"SuccessfulResultSample,omitempty" xml:"SuccessfulResultSample,omitempty"`
	// The data source information of the API generated in wizard mode.
	WizardConnection *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection `json:"WizardConnection,omitempty" xml:"WizardConnection,omitempty" type:"Struct"`
	// The error codes returned for the API generated in wizard mode.
	WizardErrorCodes []*GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes `json:"WizardErrorCodes,omitempty" xml:"WizardErrorCodes,omitempty" type:"Repeated"`
	// The request parameters of the API generated in wizard mode.
	WizardRequestParameters []*GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters `json:"WizardRequestParameters,omitempty" xml:"WizardRequestParameters,omitempty" type:"Repeated"`
	// The response parameters of the API generated in wizard mode.
	WizardResponseParameters []*GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters `json:"WizardResponseParameters,omitempty" xml:"WizardResponseParameters,omitempty" type:"Repeated"`
}

func (s GetDataServicePublishedApiResponseBodyDataWizardDetails) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponseBodyDataWizardDetails) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetails) SetFailedResultSample(v string) *GetDataServicePublishedApiResponseBodyDataWizardDetails {
	s.FailedResultSample = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetails) SetIsPagedResponse(v bool) *GetDataServicePublishedApiResponseBodyDataWizardDetails {
	s.IsPagedResponse = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetails) SetSuccessfulResultSample(v string) *GetDataServicePublishedApiResponseBodyDataWizardDetails {
	s.SuccessfulResultSample = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetails) SetWizardConnection(v *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection) *GetDataServicePublishedApiResponseBodyDataWizardDetails {
	s.WizardConnection = v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetails) SetWizardErrorCodes(v []*GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes) *GetDataServicePublishedApiResponseBodyDataWizardDetails {
	s.WizardErrorCodes = v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetails) SetWizardRequestParameters(v []*GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters) *GetDataServicePublishedApiResponseBodyDataWizardDetails {
	s.WizardRequestParameters = v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetails) SetWizardResponseParameters(v []*GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters) *GetDataServicePublishedApiResponseBodyDataWizardDetails {
	s.WizardResponseParameters = v
	return s
}

type GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection struct {
	// The ID of the data source.
	ConnectionId *int64 `json:"ConnectionId,omitempty" xml:"ConnectionId,omitempty"`
	// The name of the table in the data source.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection) SetConnectionId(v int64) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection {
	s.ConnectionId = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection) SetTableName(v string) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardConnection {
	s.TableName = &v
	return s
}

type GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The solution used to fix the error.
	ErrorSolution *string `json:"ErrorSolution,omitempty" xml:"ErrorSolution,omitempty"`
}

func (s GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes) SetErrorCode(v string) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes {
	s.ErrorCode = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes) SetErrorMessage(v string) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes) SetErrorSolution(v string) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardErrorCodes {
	s.ErrorSolution = &v
	return s
}

type GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters struct {
	// The default value.
	DefaultValue *string `json:"DefaultValue,omitempty" xml:"DefaultValue,omitempty"`
	// The sample value.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// Indicates whether the parameter is required.
	IsRequiredParameter *bool `json:"IsRequiredParameter,omitempty" xml:"IsRequiredParameter,omitempty"`
	// The data type of the parameter. Valid values: 0, 1, 2, 3, 4, and 5. The value 0 indicates the STRING data type, the value 1 indicates the INT data type, the value 2 indicates the LONG data type, the value 3 indicates the FLOAT data type, the value 4 indicates the DOUBLE data type, and the value 5 indicates the BOOLEAN data type.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The operator used for the value of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates that the operator is Equal, the value 1 indicates that the operator is Like, the value 2 indicates that the operator is Const, and the value 3 indicates that the operator is In. APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
	ParameterOperator *int32 `json:"ParameterOperator,omitempty" xml:"ParameterOperator,omitempty"`
	// The position of the parameter. Valid values: 0, 1, 2, and 3. The value 0 indicates that the parameter is in the URL path of the request, the value 1 indicates that the parameter is in the Query parameter of the request URL, the value 2 indicates that the parameter is in the request header, and the value 3 indicates that the parameter is in the request body. APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
	ParameterPosition *int32 `json:"ParameterPosition,omitempty" xml:"ParameterPosition,omitempty"`
}

func (s GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters) SetDefaultValue(v string) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.DefaultValue = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters) SetExampleValue(v string) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.ExampleValue = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters) SetIsRequiredParameter(v bool) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.IsRequiredParameter = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters) SetParameterDataType(v int32) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.ParameterDataType = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters) SetParameterDescription(v string) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.ParameterDescription = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters) SetParameterName(v string) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.ParameterName = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters) SetParameterOperator(v int32) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.ParameterOperator = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters) SetParameterPosition(v int32) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardRequestParameters {
	s.ParameterPosition = &v
	return s
}

type GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters struct {
	// The sample value.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// The data type of the parameter. Valid values: 0, 1, 2, 3, 4, and 5. The value 0 indicates the STRING data type, the value 1 indicates the INT data type, the value 2 indicates the LONG data type, the value 3 indicates the FLOAT data type, the value 4 indicates the DOUBLE data type, and the value 5 indicates the BOOLEAN data type.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
}

func (s GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters) SetExampleValue(v string) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters {
	s.ExampleValue = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters) SetParameterDataType(v int32) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters {
	s.ParameterDataType = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters) SetParameterDescription(v string) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters {
	s.ParameterDescription = &v
	return s
}

func (s *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters) SetParameterName(v string) *GetDataServicePublishedApiResponseBodyDataWizardDetailsWizardResponseParameters {
	s.ParameterName = &v
	return s
}

type GetDataServicePublishedApiResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDataServicePublishedApiResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDataServicePublishedApiResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataServicePublishedApiResponse) GoString() string {
	return s.String()
}

func (s *GetDataServicePublishedApiResponse) SetHeaders(v map[string]*string) *GetDataServicePublishedApiResponse {
	s.Headers = v
	return s
}

func (s *GetDataServicePublishedApiResponse) SetStatusCode(v int32) *GetDataServicePublishedApiResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataServicePublishedApiResponse) SetBody(v *GetDataServicePublishedApiResponseBody) *GetDataServicePublishedApiResponse {
	s.Body = v
	return s
}

type GetDataSourceMetaRequest struct {
	// The number of the page to return.
	DatasourceName *string `json:"DatasourceName,omitempty" xml:"DatasourceName,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The number of entries to return on each page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The environment to which the data source belongs. Valid values:
	//
	// *   0: development environment
	// *   1: production environment
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The name of the data source.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetDataSourceMetaRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataSourceMetaRequest) GoString() string {
	return s.String()
}

func (s *GetDataSourceMetaRequest) SetDatasourceName(v string) *GetDataSourceMetaRequest {
	s.DatasourceName = &v
	return s
}

func (s *GetDataSourceMetaRequest) SetEnvType(v string) *GetDataSourceMetaRequest {
	s.EnvType = &v
	return s
}

func (s *GetDataSourceMetaRequest) SetPageNumber(v int64) *GetDataSourceMetaRequest {
	s.PageNumber = &v
	return s
}

func (s *GetDataSourceMetaRequest) SetPageSize(v int64) *GetDataSourceMetaRequest {
	s.PageSize = &v
	return s
}

func (s *GetDataSourceMetaRequest) SetProjectId(v int64) *GetDataSourceMetaRequest {
	s.ProjectId = &v
	return s
}

type GetDataSourceMetaResponseBody struct {
	// Indicates whether the metadata of the data source was retrieved. Valid values:
	//
	// *   success: The metadata of the data source was retrieved.
	// *   fail: The metadata of the data source failed to be retrieved. You can troubleshoot issues based on the Message parameter.
	Data *GetDataSourceMetaResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The information about the query operation.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The unique ID of the request. You can query logs and troubleshoot issues based on the unique ID.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataSourceMetaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataSourceMetaResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataSourceMetaResponseBody) SetData(v *GetDataSourceMetaResponseBodyData) *GetDataSourceMetaResponseBody {
	s.Data = v
	return s
}

func (s *GetDataSourceMetaResponseBody) SetRequestId(v string) *GetDataSourceMetaResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataSourceMetaResponseBody) SetSuccess(v bool) *GetDataSourceMetaResponseBody {
	s.Success = &v
	return s
}

type GetDataSourceMetaResponseBodyData struct {
	// The returned metadata of the data source. The returned metadata is in the JSON format.
	//
	// `{"dbTables":[{"dbName":"testdb","schema":[{"tableInfos":[{"dbName":"testdb","enable":true,"table":"table1","tableName":"table1"}]},{"tableInfos":[{"dbName":"testdb","enable":true,"table":"table2","tableName":"table2"}]}]}]}`
	//
	// Parameter description:
	//
	// *   dbName: the name of the database in which the data source resides.
	// *   schema: the schema of the database.
	// *   enable: indicates whether the database is available. A value of true indicates that the database is available. A value of false indicates that the database is unavailable.
	// *   tableName: the name of the table in the database.
	// *   tableInfos: the information about the table in the database.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	Meta    *string `json:"Meta,omitempty" xml:"Meta,omitempty"`
	// The reason why the metadata of the data source failed to be retrieved. If the metadata of the data source was retrieved, this parameter is left empty.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetDataSourceMetaResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDataSourceMetaResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDataSourceMetaResponseBodyData) SetMessage(v string) *GetDataSourceMetaResponseBodyData {
	s.Message = &v
	return s
}

func (s *GetDataSourceMetaResponseBodyData) SetMeta(v string) *GetDataSourceMetaResponseBodyData {
	s.Meta = &v
	return s
}

func (s *GetDataSourceMetaResponseBodyData) SetStatus(v string) *GetDataSourceMetaResponseBodyData {
	s.Status = &v
	return s
}

type GetDataSourceMetaResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDataSourceMetaResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDataSourceMetaResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataSourceMetaResponse) GoString() string {
	return s.String()
}

func (s *GetDataSourceMetaResponse) SetHeaders(v map[string]*string) *GetDataSourceMetaResponse {
	s.Headers = v
	return s
}

func (s *GetDataSourceMetaResponse) SetStatusCode(v int32) *GetDataSourceMetaResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataSourceMetaResponse) SetBody(v *GetDataSourceMetaResponseBody) *GetDataSourceMetaResponse {
	s.Body = v
	return s
}

type GetDeploymentRequest struct {
	// The ID of the deployment task. A deployment task ID is generated when you call the [SubmitFile](~~173944~~) or [DeployFile](~~173956~~) operation.
	DeploymentId *int64 `json:"DeploymentId,omitempty" xml:"DeploymentId,omitempty"`
	// The ID of the DataWorks workspace. You can click the Workspace Manage icon in the upper-right corner of the DataStudio page to go to the Workspace Management page and view the workspace ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The GUID of the DataWorks workspace. You can view the GUID in the upper part of the DataStudio page. You can also select another GUID to switch to another workspace.
	//
	// You must specify either this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s GetDeploymentRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDeploymentRequest) GoString() string {
	return s.String()
}

func (s *GetDeploymentRequest) SetDeploymentId(v int64) *GetDeploymentRequest {
	s.DeploymentId = &v
	return s
}

func (s *GetDeploymentRequest) SetProjectId(v int64) *GetDeploymentRequest {
	s.ProjectId = &v
	return s
}

func (s *GetDeploymentRequest) SetProjectIdentifier(v string) *GetDeploymentRequest {
	s.ProjectIdentifier = &v
	return s
}

type GetDeploymentResponseBody struct {
	// The data about the deployment task.
	Data *GetDeploymentResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can troubleshoot errors based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDeploymentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDeploymentResponseBody) GoString() string {
	return s.String()
}

func (s *GetDeploymentResponseBody) SetData(v *GetDeploymentResponseBodyData) *GetDeploymentResponseBody {
	s.Data = v
	return s
}

func (s *GetDeploymentResponseBody) SetErrorCode(v string) *GetDeploymentResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetDeploymentResponseBody) SetErrorMessage(v string) *GetDeploymentResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDeploymentResponseBody) SetHttpStatusCode(v int32) *GetDeploymentResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetDeploymentResponseBody) SetRequestId(v string) *GetDeploymentResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDeploymentResponseBody) SetSuccess(v bool) *GetDeploymentResponseBody {
	s.Success = &v
	return s
}

type GetDeploymentResponseBodyData struct {
	DeployedItems []*GetDeploymentResponseBodyDataDeployedItems `json:"DeployedItems,omitempty" xml:"DeployedItems,omitempty" type:"Repeated"`
	// The details of the deployment task.
	Deployment *GetDeploymentResponseBodyDataDeployment `json:"Deployment,omitempty" xml:"Deployment,omitempty" type:"Struct"`
}

func (s GetDeploymentResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDeploymentResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDeploymentResponseBodyData) SetDeployedItems(v []*GetDeploymentResponseBodyDataDeployedItems) *GetDeploymentResponseBodyData {
	s.DeployedItems = v
	return s
}

func (s *GetDeploymentResponseBodyData) SetDeployment(v *GetDeploymentResponseBodyDataDeployment) *GetDeploymentResponseBodyData {
	s.Deployment = v
	return s
}

type GetDeploymentResponseBodyDataDeployedItems struct {
	FileId      *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	FileVersion *int64 `json:"FileVersion,omitempty" xml:"FileVersion,omitempty"`
	Status      *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetDeploymentResponseBodyDataDeployedItems) String() string {
	return tea.Prettify(s)
}

func (s GetDeploymentResponseBodyDataDeployedItems) GoString() string {
	return s.String()
}

func (s *GetDeploymentResponseBodyDataDeployedItems) SetFileId(v int64) *GetDeploymentResponseBodyDataDeployedItems {
	s.FileId = &v
	return s
}

func (s *GetDeploymentResponseBodyDataDeployedItems) SetFileVersion(v int64) *GetDeploymentResponseBodyDataDeployedItems {
	s.FileVersion = &v
	return s
}

func (s *GetDeploymentResponseBodyDataDeployedItems) SetStatus(v int32) *GetDeploymentResponseBodyDataDeployedItems {
	s.Status = &v
	return s
}

type GetDeploymentResponseBodyDataDeployment struct {
	// The check status of one or more files in the deployment task. If the value of the ToEnvironment parameter is 1, the files can be deployed to the production environment only when the value of the Status parameter is 1 and the CheckingStatus parameter is empty. Valid values:
	//
	// *   7: The file failed the check.
	// *   8: The file is being checked.
	CheckingStatus *int32 `json:"CheckingStatus,omitempty" xml:"CheckingStatus,omitempty"`
	// The time when the deployment task was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the Alibaba Cloud account used by the user who created the deployment task.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The error message that was returned when the deployment task failed. In this case, the value of the Status parameter is 2.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The time when the deployment task was run. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	ExecuteTime *int64 `json:"ExecuteTime,omitempty" xml:"ExecuteTime,omitempty"`
	// The environment in which the deployment task was run. Valid values: 0 and 1. A value of 0 indicates the on-premises environment. A value of 1 indicates the development environment.
	FromEnvironment *int32 `json:"FromEnvironment,omitempty" xml:"FromEnvironment,omitempty"`
	// The ID of the Alibaba Cloud account used by the user who ran the deployment task.
	HandlerId *string `json:"HandlerId,omitempty" xml:"HandlerId,omitempty"`
	// The name of the deployment task. The value is the same as the name of the specific deployment task that is displayed on the Release Package page in the Deploy module.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The status of the deployment task. Valid values: 0, 1, and 2. A value of 0 indicates that the task is ready. A value of 1 indicates that the task was successful. A value of 2 indicates that the task failed.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The environment to which the file was deployed. Valid values: 1 and 2. A value of 1 indicates the development environment. A value of 2 indicates the production environment.
	ToEnvironment *int32 `json:"ToEnvironment,omitempty" xml:"ToEnvironment,omitempty"`
}

func (s GetDeploymentResponseBodyDataDeployment) String() string {
	return tea.Prettify(s)
}

func (s GetDeploymentResponseBodyDataDeployment) GoString() string {
	return s.String()
}

func (s *GetDeploymentResponseBodyDataDeployment) SetCheckingStatus(v int32) *GetDeploymentResponseBodyDataDeployment {
	s.CheckingStatus = &v
	return s
}

func (s *GetDeploymentResponseBodyDataDeployment) SetCreateTime(v int64) *GetDeploymentResponseBodyDataDeployment {
	s.CreateTime = &v
	return s
}

func (s *GetDeploymentResponseBodyDataDeployment) SetCreatorId(v string) *GetDeploymentResponseBodyDataDeployment {
	s.CreatorId = &v
	return s
}

func (s *GetDeploymentResponseBodyDataDeployment) SetErrorMessage(v string) *GetDeploymentResponseBodyDataDeployment {
	s.ErrorMessage = &v
	return s
}

func (s *GetDeploymentResponseBodyDataDeployment) SetExecuteTime(v int64) *GetDeploymentResponseBodyDataDeployment {
	s.ExecuteTime = &v
	return s
}

func (s *GetDeploymentResponseBodyDataDeployment) SetFromEnvironment(v int32) *GetDeploymentResponseBodyDataDeployment {
	s.FromEnvironment = &v
	return s
}

func (s *GetDeploymentResponseBodyDataDeployment) SetHandlerId(v string) *GetDeploymentResponseBodyDataDeployment {
	s.HandlerId = &v
	return s
}

func (s *GetDeploymentResponseBodyDataDeployment) SetName(v string) *GetDeploymentResponseBodyDataDeployment {
	s.Name = &v
	return s
}

func (s *GetDeploymentResponseBodyDataDeployment) SetStatus(v int32) *GetDeploymentResponseBodyDataDeployment {
	s.Status = &v
	return s
}

func (s *GetDeploymentResponseBodyDataDeployment) SetToEnvironment(v int32) *GetDeploymentResponseBodyDataDeployment {
	s.ToEnvironment = &v
	return s
}

type GetDeploymentResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetDeploymentResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetDeploymentResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDeploymentResponse) GoString() string {
	return s.String()
}

func (s *GetDeploymentResponse) SetHeaders(v map[string]*string) *GetDeploymentResponse {
	s.Headers = v
	return s
}

func (s *GetDeploymentResponse) SetStatusCode(v int32) *GetDeploymentResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDeploymentResponse) SetBody(v *GetDeploymentResponseBody) *GetDeploymentResponse {
	s.Body = v
	return s
}

type GetExtensionRequest struct {
	// The unique code of the extension.
	ExtensionCode *string `json:"ExtensionCode,omitempty" xml:"ExtensionCode,omitempty"`
}

func (s GetExtensionRequest) String() string {
	return tea.Prettify(s)
}

func (s GetExtensionRequest) GoString() string {
	return s.String()
}

func (s *GetExtensionRequest) SetExtensionCode(v string) *GetExtensionRequest {
	s.ExtensionCode = &v
	return s
}

type GetExtensionResponseBody struct {
	// The details of the extension.
	Extension *GetExtensionResponseBodyExtension `json:"Extension,omitempty" xml:"Extension,omitempty" type:"Struct"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetExtensionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetExtensionResponseBody) GoString() string {
	return s.String()
}

func (s *GetExtensionResponseBody) SetExtension(v *GetExtensionResponseBodyExtension) *GetExtensionResponseBody {
	s.Extension = v
	return s
}

func (s *GetExtensionResponseBody) SetRequestId(v string) *GetExtensionResponseBody {
	s.RequestId = &v
	return s
}

type GetExtensionResponseBodyExtension struct {
	// The extension point events.
	BindEventList []*GetExtensionResponseBodyExtensionBindEventList `json:"BindEventList,omitempty" xml:"BindEventList,omitempty" type:"Repeated"`
	// The URL of the help document about the extension. You can visit the URL for the details of the extension.
	DetailUrl *string `json:"DetailUrl,omitempty" xml:"DetailUrl,omitempty"`
	// The types of the events.
	EventCategoryList []*GetExtensionResponseBodyExtensionEventCategoryList `json:"EventCategoryList,omitempty" xml:"EventCategoryList,omitempty" type:"Repeated"`
	// The unique code of the extension.
	ExtensionCode *string `json:"ExtensionCode,omitempty" xml:"ExtensionCode,omitempty"`
	// The description of the extension.
	ExtensionDesc *string `json:"ExtensionDesc,omitempty" xml:"ExtensionDesc,omitempty"`
	// The name of the extension.
	ExtensionName *string `json:"ExtensionName,omitempty" xml:"ExtensionName,omitempty"`
	// The URL of the help document about the extension.
	HelpDocUrl *string `json:"HelpDocUrl,omitempty" xml:"HelpDocUrl,omitempty"`
	// The option settings of the extension.
	OptionSetting *string `json:"OptionSetting,omitempty" xml:"OptionSetting,omitempty"`
	// The parameter settings of the extension. For more information, visit https://www.alibabacloud.com/help/en/dataworks/latest/set-extension-parameters.
	ParameterSetting *string `json:"ParameterSetting,omitempty" xml:"ParameterSetting,omitempty"`
	// The workspace for testing. If the extension is in the testing state, the extension can be used only in the workspace for testing.
	ProjectTesting *int64 `json:"ProjectTesting,omitempty" xml:"ProjectTesting,omitempty"`
	// The state of the extension. 0: testing. 1: publishing. 3: disabled. 4: approving. 5: approved. 6: approval failed.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetExtensionResponseBodyExtension) String() string {
	return tea.Prettify(s)
}

func (s GetExtensionResponseBodyExtension) GoString() string {
	return s.String()
}

func (s *GetExtensionResponseBodyExtension) SetBindEventList(v []*GetExtensionResponseBodyExtensionBindEventList) *GetExtensionResponseBodyExtension {
	s.BindEventList = v
	return s
}

func (s *GetExtensionResponseBodyExtension) SetDetailUrl(v string) *GetExtensionResponseBodyExtension {
	s.DetailUrl = &v
	return s
}

func (s *GetExtensionResponseBodyExtension) SetEventCategoryList(v []*GetExtensionResponseBodyExtensionEventCategoryList) *GetExtensionResponseBodyExtension {
	s.EventCategoryList = v
	return s
}

func (s *GetExtensionResponseBodyExtension) SetExtensionCode(v string) *GetExtensionResponseBodyExtension {
	s.ExtensionCode = &v
	return s
}

func (s *GetExtensionResponseBodyExtension) SetExtensionDesc(v string) *GetExtensionResponseBodyExtension {
	s.ExtensionDesc = &v
	return s
}

func (s *GetExtensionResponseBodyExtension) SetExtensionName(v string) *GetExtensionResponseBodyExtension {
	s.ExtensionName = &v
	return s
}

func (s *GetExtensionResponseBodyExtension) SetHelpDocUrl(v string) *GetExtensionResponseBodyExtension {
	s.HelpDocUrl = &v
	return s
}

func (s *GetExtensionResponseBodyExtension) SetOptionSetting(v string) *GetExtensionResponseBodyExtension {
	s.OptionSetting = &v
	return s
}

func (s *GetExtensionResponseBodyExtension) SetParameterSetting(v string) *GetExtensionResponseBodyExtension {
	s.ParameterSetting = &v
	return s
}

func (s *GetExtensionResponseBodyExtension) SetProjectTesting(v int64) *GetExtensionResponseBodyExtension {
	s.ProjectTesting = &v
	return s
}

func (s *GetExtensionResponseBodyExtension) SetStatus(v int32) *GetExtensionResponseBodyExtension {
	s.Status = &v
	return s
}

type GetExtensionResponseBodyExtensionBindEventList struct {
	// The code of the extension point event.
	EventCode *string `json:"EventCode,omitempty" xml:"EventCode,omitempty"`
	// The name of the extension point event.
	EventName *string `json:"EventName,omitempty" xml:"EventName,omitempty"`
}

func (s GetExtensionResponseBodyExtensionBindEventList) String() string {
	return tea.Prettify(s)
}

func (s GetExtensionResponseBodyExtensionBindEventList) GoString() string {
	return s.String()
}

func (s *GetExtensionResponseBodyExtensionBindEventList) SetEventCode(v string) *GetExtensionResponseBodyExtensionBindEventList {
	s.EventCode = &v
	return s
}

func (s *GetExtensionResponseBodyExtensionBindEventList) SetEventName(v string) *GetExtensionResponseBodyExtensionBindEventList {
	s.EventName = &v
	return s
}

type GetExtensionResponseBodyExtensionEventCategoryList struct {
	// The code of the event type.
	CategoryCode *string `json:"CategoryCode,omitempty" xml:"CategoryCode,omitempty"`
	// The name of the event type.
	CategoryName *string `json:"CategoryName,omitempty" xml:"CategoryName,omitempty"`
}

func (s GetExtensionResponseBodyExtensionEventCategoryList) String() string {
	return tea.Prettify(s)
}

func (s GetExtensionResponseBodyExtensionEventCategoryList) GoString() string {
	return s.String()
}

func (s *GetExtensionResponseBodyExtensionEventCategoryList) SetCategoryCode(v string) *GetExtensionResponseBodyExtensionEventCategoryList {
	s.CategoryCode = &v
	return s
}

func (s *GetExtensionResponseBodyExtensionEventCategoryList) SetCategoryName(v string) *GetExtensionResponseBodyExtensionEventCategoryList {
	s.CategoryName = &v
	return s
}

type GetExtensionResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetExtensionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetExtensionResponse) String() string {
	return tea.Prettify(s)
}

func (s GetExtensionResponse) GoString() string {
	return s.String()
}

func (s *GetExtensionResponse) SetHeaders(v map[string]*string) *GetExtensionResponse {
	s.Headers = v
	return s
}

func (s *GetExtensionResponse) SetStatusCode(v int32) *GetExtensionResponse {
	s.StatusCode = &v
	return s
}

func (s *GetExtensionResponse) SetBody(v *GetExtensionResponseBody) *GetExtensionResponse {
	s.Body = v
	return s
}

type GetFileRequest struct {
	// The ID of the file. You can call the [ListFiles](~~173942~~) operation to obtain the ID.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The ID of the node that is scheduled. You can call the [ListFiles](~~173942~~) operation to obtain the node ID.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace ID.
	//
	// You must configure this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace name.
	//
	// You must configure this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s GetFileRequest) String() string {
	return tea.Prettify(s)
}

func (s GetFileRequest) GoString() string {
	return s.String()
}

func (s *GetFileRequest) SetFileId(v int64) *GetFileRequest {
	s.FileId = &v
	return s
}

func (s *GetFileRequest) SetNodeId(v int64) *GetFileRequest {
	s.NodeId = &v
	return s
}

func (s *GetFileRequest) SetProjectId(v int64) *GetFileRequest {
	s.ProjectId = &v
	return s
}

func (s *GetFileRequest) SetProjectIdentifier(v string) *GetFileRequest {
	s.ProjectIdentifier = &v
	return s
}

type GetFileResponseBody struct {
	// The details of the file.
	Data *GetFileResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetFileResponseBody) GoString() string {
	return s.String()
}

func (s *GetFileResponseBody) SetData(v *GetFileResponseBodyData) *GetFileResponseBody {
	s.Data = v
	return s
}

func (s *GetFileResponseBody) SetErrorCode(v string) *GetFileResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetFileResponseBody) SetErrorMessage(v string) *GetFileResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetFileResponseBody) SetHttpStatusCode(v int32) *GetFileResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetFileResponseBody) SetRequestId(v string) *GetFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetFileResponseBody) SetSuccess(v bool) *GetFileResponseBody {
	s.Success = &v
	return s
}

type GetFileResponseBodyData struct {
	// The basic information about the file.
	File *GetFileResponseBodyDataFile `json:"File,omitempty" xml:"File,omitempty" type:"Struct"`
	// The scheduling configurations of the file.
	NodeConfiguration *GetFileResponseBodyDataNodeConfiguration `json:"NodeConfiguration,omitempty" xml:"NodeConfiguration,omitempty" type:"Struct"`
}

func (s GetFileResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetFileResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetFileResponseBodyData) SetFile(v *GetFileResponseBodyDataFile) *GetFileResponseBodyData {
	s.File = v
	return s
}

func (s *GetFileResponseBodyData) SetNodeConfiguration(v *GetFileResponseBodyDataNodeConfiguration) *GetFileResponseBodyData {
	s.NodeConfiguration = v
	return s
}

type GetFileResponseBodyDataFile struct {
	// The advanced configurations of the node.
	//
	// This parameter is valid only for an EMR Spark Streaming node or an EMR Streaming SQL node. This parameter corresponds to the Advanced Settings tab of the node in the [DataWorks console](https://workbench.data.aliyun.com/console).
	//
	// This parameter is configured in the JSON format.
	AdvancedSettings *string `json:"AdvancedSettings,omitempty" xml:"AdvancedSettings,omitempty"`
	// Indicates whether the automatic parsing feature is enabled for the file. Valid values:
	//
	// *   true: The automatic parsing feature is enabled for the file.
	// *   false: The automatic parsing feature is not enabled for the file.
	//
	// This parameter corresponds to the Analyze Code parameter that is displayed after Same Cycle is selected in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	AutoParsing *bool `json:"AutoParsing,omitempty" xml:"AutoParsing,omitempty"`
	// The ID of the workflow to which the file belongs. This parameter is deprecated and replaced by the BusinessId parameter.
	BizId *int64 `json:"BizId,omitempty" xml:"BizId,omitempty"`
	// The ID of the workflow to which the file belongs.
	BusinessId *int64 `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	// Indicates whether the latest code in the file is committed. Valid values: 0 and 1. The value 0 indicates that the latest code in the file is not committed. The value 1 indicates that the latest code in the file is committed.
	CommitStatus *int32 `json:"CommitStatus,omitempty" xml:"CommitStatus,omitempty"`
	// The ID of the compute engine instance that is used to run the node that corresponds to the file.
	ConnectionName *string `json:"ConnectionName,omitempty" xml:"ConnectionName,omitempty"`
	// The code in the file.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The time when the file was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the Alibaba Cloud account used to create the file.
	CreateUser *string `json:"CreateUser,omitempty" xml:"CreateUser,omitempty"`
	// The latest version number of the file.
	CurrentVersion *int32 `json:"CurrentVersion,omitempty" xml:"CurrentVersion,omitempty"`
	// The status of the file. Valid values:
	//
	// *   NORMAL: The file is not deleted.
	// *   RECYCLE_BIN: The file is stored in the recycle bin.
	// *   DELETED: The file is deleted.
	DeletedStatus *string `json:"DeletedStatus,omitempty" xml:"DeletedStatus,omitempty"`
	// The description of the file.
	FileDescription *string `json:"FileDescription,omitempty" xml:"FileDescription,omitempty"`
	// The ID of the folder to which the file belongs.
	FileFolderId *string `json:"FileFolderId,omitempty" xml:"FileFolderId,omitempty"`
	FileId       *int64  `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The name of the file.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The type of the code for the file. Valid values: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3).
	FileType *int32 `json:"FileType,omitempty" xml:"FileType,omitempty"`
	// Indicates whether the file needs to be uploaded to MaxCompute.
	//
	// This parameter is returned only if the file is a MaxCompute resource file.
	IsMaxCompute *bool `json:"IsMaxCompute,omitempty" xml:"IsMaxCompute,omitempty"`
	// The time when the file was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	LastEditTime *int64 `json:"LastEditTime,omitempty" xml:"LastEditTime,omitempty"`
	// The ID of the Alibaba Cloud account used to last modify the file.
	LastEditUser *string `json:"LastEditUser,omitempty" xml:"LastEditUser,omitempty"`
	// The ID of the auto triggered node that is generated in the scheduling system after the file is committed.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the Alibaba Cloud account used by the file owner.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ID of the node group file to which the current file belongs. This parameter is returned only if the current file is an inner file of the node group file.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The module to which the file belongs. Valid values:
	//
	// *   NORMAL: The file is used for DataStudio.
	// *   MANUAL: The file is used for a manually triggered node.
	// *   MANUAL_BIZ: The file is used for a manually triggered workflow.
	// *   SKIP: The file is used for a dry-run DataStudio node.
	// *   ADHOCQUERY: The file is used for an ad hoc query.
	// *   COMPONENT: The file is used for a snippet.
	UseType *string `json:"UseType,omitempty" xml:"UseType,omitempty"`
}

func (s GetFileResponseBodyDataFile) String() string {
	return tea.Prettify(s)
}

func (s GetFileResponseBodyDataFile) GoString() string {
	return s.String()
}

func (s *GetFileResponseBodyDataFile) SetAdvancedSettings(v string) *GetFileResponseBodyDataFile {
	s.AdvancedSettings = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetAutoParsing(v bool) *GetFileResponseBodyDataFile {
	s.AutoParsing = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetBizId(v int64) *GetFileResponseBodyDataFile {
	s.BizId = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetBusinessId(v int64) *GetFileResponseBodyDataFile {
	s.BusinessId = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetCommitStatus(v int32) *GetFileResponseBodyDataFile {
	s.CommitStatus = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetConnectionName(v string) *GetFileResponseBodyDataFile {
	s.ConnectionName = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetContent(v string) *GetFileResponseBodyDataFile {
	s.Content = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetCreateTime(v int64) *GetFileResponseBodyDataFile {
	s.CreateTime = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetCreateUser(v string) *GetFileResponseBodyDataFile {
	s.CreateUser = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetCurrentVersion(v int32) *GetFileResponseBodyDataFile {
	s.CurrentVersion = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetDeletedStatus(v string) *GetFileResponseBodyDataFile {
	s.DeletedStatus = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetFileDescription(v string) *GetFileResponseBodyDataFile {
	s.FileDescription = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetFileFolderId(v string) *GetFileResponseBodyDataFile {
	s.FileFolderId = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetFileId(v int64) *GetFileResponseBodyDataFile {
	s.FileId = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetFileName(v string) *GetFileResponseBodyDataFile {
	s.FileName = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetFileType(v int32) *GetFileResponseBodyDataFile {
	s.FileType = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetIsMaxCompute(v bool) *GetFileResponseBodyDataFile {
	s.IsMaxCompute = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetLastEditTime(v int64) *GetFileResponseBodyDataFile {
	s.LastEditTime = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetLastEditUser(v string) *GetFileResponseBodyDataFile {
	s.LastEditUser = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetNodeId(v int64) *GetFileResponseBodyDataFile {
	s.NodeId = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetOwner(v string) *GetFileResponseBodyDataFile {
	s.Owner = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetParentId(v int64) *GetFileResponseBodyDataFile {
	s.ParentId = &v
	return s
}

func (s *GetFileResponseBodyDataFile) SetUseType(v string) *GetFileResponseBodyDataFile {
	s.UseType = &v
	return s
}

type GetFileResponseBodyDataNodeConfiguration struct {
	// The interval between automatic reruns after an error occurs. Unit: milliseconds.
	//
	// This parameter corresponds to the Rerun Interval parameter that is displayed after the Auto Rerun upon Error check box is selected in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	//
	// The interval that you specify in the DataWorks console is measured in minutes. Pay attention to the conversion between the units of time when you call the operation.
	AutoRerunIntervalMillis *int32 `json:"AutoRerunIntervalMillis,omitempty" xml:"AutoRerunIntervalMillis,omitempty"`
	// The number of automatic reruns that are allowed after an error occurs.
	AutoRerunTimes *int32 `json:"AutoRerunTimes,omitempty" xml:"AutoRerunTimes,omitempty"`
	// The CRON expression that represents the periodic scheduling policy of the node.
	CronExpress *string `json:"CronExpress,omitempty" xml:"CronExpress,omitempty"`
	// The type of the scheduling cycle. Valid values: NOT_DAY and DAY. The value NOT_DAY indicates that the node is scheduled to run by minute or hour. The value DAY indicates that the node is scheduled to run by day, week, or month.
	//
	// This parameter corresponds to the Scheduling Cycle parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	CycleType *string `json:"CycleType,omitempty" xml:"CycleType,omitempty"`
	// The ID of the node on which the node corresponding to the file depends when the DependentType parameter is set to USER_DEFINE. Multiple IDs are separated by commas (,).
	//
	// The value of this parameter is equivalent to the ID of the node that you specified after you select Previous Cycle and set Depend On to Other Nodes in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	DependentNodeIdList *string `json:"DependentNodeIdList,omitempty" xml:"DependentNodeIdList,omitempty"`
	// The type of the cross-cycle scheduling dependency of the node. Valid values:
	//
	// *   SELF: The instance generated for the node in the current cycle depends on the instance generated for the node in the previous cycle.
	// *   CHILD: The instance generated for the node in the current cycle depends on the instances generated for the descendant nodes at the nearest level of the node in the previous cycle.
	// *   USER_DEFINE: The instance generated for the node in the current cycle depends on the instances generated for one or more specified nodes in the previous cycle.
	// *   NONE: No cross-cycle scheduling dependency type is selected for the node.
	DependentType *string `json:"DependentType,omitempty" xml:"DependentType,omitempty"`
	// The end time of automatic scheduling. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	//
	// This parameter corresponds to the Validity Period parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	EndEffectDate *int64 `json:"EndEffectDate,omitempty" xml:"EndEffectDate,omitempty"`
	// The output names of the parent files on which the current file depends.
	InputList []*GetFileResponseBodyDataNodeConfigurationInputList `json:"InputList,omitempty" xml:"InputList,omitempty" type:"Repeated"`
	// Input parameters of the node.
	//
	// This parameter corresponds to the Input Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	InputParameters []*GetFileResponseBodyDataNodeConfigurationInputParameters `json:"InputParameters,omitempty" xml:"InputParameters,omitempty" type:"Repeated"`
	// The output names of the current file.
	//
	// This parameter corresponds to the Output Name parameter under Output after Same Cycle is selected in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	OutputList []*GetFileResponseBodyDataNodeConfigurationOutputList `json:"OutputList,omitempty" xml:"OutputList,omitempty" type:"Repeated"`
	// Output parameters of the node.
	//
	// This parameter corresponds to the Output Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	OutputParameters []*GetFileResponseBodyDataNodeConfigurationOutputParameters `json:"OutputParameters,omitempty" xml:"OutputParameters,omitempty" type:"Repeated"`
	// The scheduling parameters of the node.
	//
	// This parameter corresponds to the Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console). For more information about the configurations of the scheduling parameters, see [Configure scheduling parameters](~~137548~~).
	ParaValue *string `json:"ParaValue,omitempty" xml:"ParaValue,omitempty"`
	// Indicates whether the node that corresponds to the file can be rerun. Valid values:
	//
	// *   ALL_ALLOWED: The node can be rerun regardless of whether it is successfully run or fails to run.
	// *   FAILURE_ALLOWED: The node can be rerun only after it fails to run.
	// *   ALL_DENIED: The node cannot be rerun regardless of whether it is successfully run or fails to run.
	//
	// This parameter corresponds to the Rerun parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	RerunMode *string `json:"RerunMode,omitempty" xml:"RerunMode,omitempty"`
	// The ID of the resource group that is used to run the node. You can call the [ListResourceGroups](~~173913~~) operation to query the available resource groups in the workspace.
	ResourceGroupId *int64 `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The scheduling type of the node. Valid values:
	//
	// *   NORMAL: The node is an auto triggered node.
	// *   MANUAL: The node is a manually triggered node. Manually triggered nodes cannot be automatically triggered. They correspond to the nodes in the Manually Triggered Workflows pane.
	// *   PAUSE: The node is a paused node.
	// *   SKIP: The node is a dry-run node. Dry-run nodes are started as scheduled but the system sets the status of the nodes to successful when it starts to run them.
	SchedulerType *string `json:"SchedulerType,omitempty" xml:"SchedulerType,omitempty"`
	// The start time of automatic scheduling. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	//
	// This parameter corresponds to the Validity Period parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	StartEffectDate *int64 `json:"StartEffectDate,omitempty" xml:"StartEffectDate,omitempty"`
	// Indicates whether a node is immediately run after the node is deployed to the production environment.
	//
	// This parameter is valid only for an EMR Spark Streaming node or an EMR Streaming SQL node. This parameter corresponds to the Start Method parameter in the Schedule section of the Configure tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	StartImmediately *bool `json:"StartImmediately,omitempty" xml:"StartImmediately,omitempty"`
	// Indicates whether the scheduling for the node is suspended Valid values:
	//
	// *   true: The scheduling for the node is suspended.
	// *   false: The scheduling for the node is not suspended.
	//
	// This parameter corresponds to the Recurrence parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	Stop *bool `json:"Stop,omitempty" xml:"Stop,omitempty"`
}

func (s GetFileResponseBodyDataNodeConfiguration) String() string {
	return tea.Prettify(s)
}

func (s GetFileResponseBodyDataNodeConfiguration) GoString() string {
	return s.String()
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetAutoRerunIntervalMillis(v int32) *GetFileResponseBodyDataNodeConfiguration {
	s.AutoRerunIntervalMillis = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetAutoRerunTimes(v int32) *GetFileResponseBodyDataNodeConfiguration {
	s.AutoRerunTimes = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetCronExpress(v string) *GetFileResponseBodyDataNodeConfiguration {
	s.CronExpress = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetCycleType(v string) *GetFileResponseBodyDataNodeConfiguration {
	s.CycleType = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetDependentNodeIdList(v string) *GetFileResponseBodyDataNodeConfiguration {
	s.DependentNodeIdList = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetDependentType(v string) *GetFileResponseBodyDataNodeConfiguration {
	s.DependentType = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetEndEffectDate(v int64) *GetFileResponseBodyDataNodeConfiguration {
	s.EndEffectDate = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetInputList(v []*GetFileResponseBodyDataNodeConfigurationInputList) *GetFileResponseBodyDataNodeConfiguration {
	s.InputList = v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetInputParameters(v []*GetFileResponseBodyDataNodeConfigurationInputParameters) *GetFileResponseBodyDataNodeConfiguration {
	s.InputParameters = v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetOutputList(v []*GetFileResponseBodyDataNodeConfigurationOutputList) *GetFileResponseBodyDataNodeConfiguration {
	s.OutputList = v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetOutputParameters(v []*GetFileResponseBodyDataNodeConfigurationOutputParameters) *GetFileResponseBodyDataNodeConfiguration {
	s.OutputParameters = v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetParaValue(v string) *GetFileResponseBodyDataNodeConfiguration {
	s.ParaValue = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetRerunMode(v string) *GetFileResponseBodyDataNodeConfiguration {
	s.RerunMode = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetResourceGroupId(v int64) *GetFileResponseBodyDataNodeConfiguration {
	s.ResourceGroupId = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetSchedulerType(v string) *GetFileResponseBodyDataNodeConfiguration {
	s.SchedulerType = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetStartEffectDate(v int64) *GetFileResponseBodyDataNodeConfiguration {
	s.StartEffectDate = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetStartImmediately(v bool) *GetFileResponseBodyDataNodeConfiguration {
	s.StartImmediately = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfiguration) SetStop(v bool) *GetFileResponseBodyDataNodeConfiguration {
	s.Stop = &v
	return s
}

type GetFileResponseBodyDataNodeConfigurationInputList struct {
	// The output name of the parent file on which the current file depends.
	//
	// This parameter corresponds to the Output Name parameter under Parent Nodes after Same Cycle is selected in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	Input *string `json:"Input,omitempty" xml:"Input,omitempty"`
	// The mode of the configuration file dependency. Valid values:
	//
	// *   MANUAL: Scheduling dependencies are manually configured.
	// *   AUTO: Scheduling dependencies are automatically parsed.
	ParseType *string `json:"ParseType,omitempty" xml:"ParseType,omitempty"`
}

func (s GetFileResponseBodyDataNodeConfigurationInputList) String() string {
	return tea.Prettify(s)
}

func (s GetFileResponseBodyDataNodeConfigurationInputList) GoString() string {
	return s.String()
}

func (s *GetFileResponseBodyDataNodeConfigurationInputList) SetInput(v string) *GetFileResponseBodyDataNodeConfigurationInputList {
	s.Input = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfigurationInputList) SetParseType(v string) *GetFileResponseBodyDataNodeConfigurationInputList {
	s.ParseType = &v
	return s
}

type GetFileResponseBodyDataNodeConfigurationInputParameters struct {
	// The name of the input parameter of the node. In the code, you can use the ${...} method to reference the input parameter of the node.
	//
	// This parameter corresponds to the Parameter Name parameter in the Input Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The value source of the input parameter of the node.
	//
	// This parameter corresponds to the Value Source parameter in the Input Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	ValueSource *string `json:"ValueSource,omitempty" xml:"ValueSource,omitempty"`
}

func (s GetFileResponseBodyDataNodeConfigurationInputParameters) String() string {
	return tea.Prettify(s)
}

func (s GetFileResponseBodyDataNodeConfigurationInputParameters) GoString() string {
	return s.String()
}

func (s *GetFileResponseBodyDataNodeConfigurationInputParameters) SetParameterName(v string) *GetFileResponseBodyDataNodeConfigurationInputParameters {
	s.ParameterName = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfigurationInputParameters) SetValueSource(v string) *GetFileResponseBodyDataNodeConfigurationInputParameters {
	s.ValueSource = &v
	return s
}

type GetFileResponseBodyDataNodeConfigurationOutputList struct {
	// The output name of the current file.
	//
	// This parameter corresponds to the Output Name parameter under Output after Same Cycle is selected in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	Output *string `json:"Output,omitempty" xml:"Output,omitempty"`
	// The output table name of the current file.
	//
	// This parameter corresponds to the Output Table Name parameter under Output after Same Cycle is selected in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	RefTableName *string `json:"RefTableName,omitempty" xml:"RefTableName,omitempty"`
}

func (s GetFileResponseBodyDataNodeConfigurationOutputList) String() string {
	return tea.Prettify(s)
}

func (s GetFileResponseBodyDataNodeConfigurationOutputList) GoString() string {
	return s.String()
}

func (s *GetFileResponseBodyDataNodeConfigurationOutputList) SetOutput(v string) *GetFileResponseBodyDataNodeConfigurationOutputList {
	s.Output = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfigurationOutputList) SetRefTableName(v string) *GetFileResponseBodyDataNodeConfigurationOutputList {
	s.RefTableName = &v
	return s
}

type GetFileResponseBodyDataNodeConfigurationOutputParameters struct {
	// The description of the output parameter of the node.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The name of the output parameter of the node.
	//
	// This parameter corresponds to the Parameter Name parameter in the Output Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The type of the output parameter of the node. Valid values:
	//
	// *   1: indicates a constant.
	// *   2: indicates a variable.
	// *   3: indicates a pass-through variable.
	//
	// This parameter corresponds to the Type parameter in the Output Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The value of the output parameter of the node.
	//
	// This parameter corresponds to the Value parameter in the Output Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetFileResponseBodyDataNodeConfigurationOutputParameters) String() string {
	return tea.Prettify(s)
}

func (s GetFileResponseBodyDataNodeConfigurationOutputParameters) GoString() string {
	return s.String()
}

func (s *GetFileResponseBodyDataNodeConfigurationOutputParameters) SetDescription(v string) *GetFileResponseBodyDataNodeConfigurationOutputParameters {
	s.Description = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfigurationOutputParameters) SetParameterName(v string) *GetFileResponseBodyDataNodeConfigurationOutputParameters {
	s.ParameterName = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfigurationOutputParameters) SetType(v string) *GetFileResponseBodyDataNodeConfigurationOutputParameters {
	s.Type = &v
	return s
}

func (s *GetFileResponseBodyDataNodeConfigurationOutputParameters) SetValue(v string) *GetFileResponseBodyDataNodeConfigurationOutputParameters {
	s.Value = &v
	return s
}

type GetFileResponse struct {
	Headers    map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetFileResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetFileResponse) String() string {
	return tea.Prettify(s)
}

func (s GetFileResponse) GoString() string {
	return s.String()
}

func (s *GetFileResponse) SetHeaders(v map[string]*string) *GetFileResponse {
	s.Headers = v
	return s
}

func (s *GetFileResponse) SetStatusCode(v int32) *GetFileResponse {
	s.StatusCode = &v
	return s
}

func (s *GetFileResponse) SetBody(v *GetFileResponseBody) *GetFileResponse {
	s.Body = v
	return s
}

type GetFileTypeStatisticRequest struct {
	// The environment of the workspace. Valid values: PROD and DEV. The value PROD indicates the production environment. The value DEV indicates the development environment.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetFileTypeStatisticRequest) String() string {
	return tea.Prettify(s)
}

func (s GetFileTypeStatisticRequest) GoString() string {
	return s.String()
}

func (s *GetFileTypeStatisticRequest) SetProjectEnv(v string) *GetFileTypeStatisticRequest {
	s.ProjectEnv = &v
	return s
}

func (s *GetFileTypeStatisticRequest) SetProjectId(v int64) *GetFileTypeStatisticRequest {
	s.ProjectId = &v
	return s
}

type GetFileTypeStatisticResponseBody struct {
	// An array of node types and quantity.
	ProgramTypeAndCounts []*GetFileTypeStatisticResponseBodyProgramTypeAndCounts `json:"ProgramTypeAndCounts,omitempty" xml:"ProgramTypeAndCounts,omitempty" type:"Repeated"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetFileTypeStatisticResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetFileTypeStatisticResponseBody) GoString() string {
	return s.String()
}

func (s *GetFileTypeStatisticResponseBody) SetProgramTypeAndCounts(v []*GetFileTypeStatisticResponseBodyProgramTypeAndCounts) *GetFileTypeStatisticResponseBody {
	s.ProgramTypeAndCounts = v
	return s
}

func (s *GetFileTypeStatisticResponseBody) SetRequestId(v string) *GetFileTypeStatisticResponseBody {
	s.RequestId = &v
	return s
}

type GetFileTypeStatisticResponseBodyProgramTypeAndCounts struct {
	// The number of nodes.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The type of the node.
	//
	// Valid values:
	//
	// 6 (Shell node), 10 (ODPS SQL node), 11 (ODPS MR node), 23 (Data Integration node), 24 (ODPS Script node), 99 (zero load node), 221 (PyODPS 2 node), 225 (ODPS Spark node), 227 (EMR Hive node), 228 (EMR Spark node), 229 (EMR Spark SQL node), 230 (EMR MR node), 239 (OSS object inspection node), 257 (EMR Shell node), 258 (EMR Spark Shell node), 259 (EMR Presto node), 260 (EMR Impala node), 900 (real-time data synchronization node), 1089 (cross-tenant collaboration node), 1091 (Hologres development node), 1093 (Hologres SQL node), 1100 (assignment node), and 1221 (PyODPS 3 node).
	ProgramType *string `json:"ProgramType,omitempty" xml:"ProgramType,omitempty"`
}

func (s GetFileTypeStatisticResponseBodyProgramTypeAndCounts) String() string {
	return tea.Prettify(s)
}

func (s GetFileTypeStatisticResponseBodyProgramTypeAndCounts) GoString() string {
	return s.String()
}

func (s *GetFileTypeStatisticResponseBodyProgramTypeAndCounts) SetCount(v int32) *GetFileTypeStatisticResponseBodyProgramTypeAndCounts {
	s.Count = &v
	return s
}

func (s *GetFileTypeStatisticResponseBodyProgramTypeAndCounts) SetProgramType(v string) *GetFileTypeStatisticResponseBodyProgramTypeAndCounts {
	s.ProgramType = &v
	return s
}

type GetFileTypeStatisticResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetFileTypeStatisticResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetFileTypeStatisticResponse) String() string {
	return tea.Prettify(s)
}

func (s GetFileTypeStatisticResponse) GoString() string {
	return s.String()
}

func (s *GetFileTypeStatisticResponse) SetHeaders(v map[string]*string) *GetFileTypeStatisticResponse {
	s.Headers = v
	return s
}

func (s *GetFileTypeStatisticResponse) SetStatusCode(v int32) *GetFileTypeStatisticResponse {
	s.StatusCode = &v
	return s
}

func (s *GetFileTypeStatisticResponse) SetBody(v *GetFileTypeStatisticResponseBody) *GetFileTypeStatisticResponse {
	s.Body = v
	return s
}

type GetFileVersionRequest struct {
	// The ID of the file. You can call the [ListFiles](~~173942~~) operation to query the ID.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The file version whose details you want to query.
	FileVersion *int32 `json:"FileVersion,omitempty" xml:"FileVersion,omitempty"`
	// The ID of the DataWorks workspace. You can click the Workspace Manage icon in the upper-right corner of the DataStudio page to go to the Workspace Management page and view the workspace ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The unique identifier of the DataWorks workspace. You can click the identifier in the upper-left corner of the DataStudio page to switch to another workspace.
	//
	// You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s GetFileVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s GetFileVersionRequest) GoString() string {
	return s.String()
}

func (s *GetFileVersionRequest) SetFileId(v int64) *GetFileVersionRequest {
	s.FileId = &v
	return s
}

func (s *GetFileVersionRequest) SetFileVersion(v int32) *GetFileVersionRequest {
	s.FileVersion = &v
	return s
}

func (s *GetFileVersionRequest) SetProjectId(v int64) *GetFileVersionRequest {
	s.ProjectId = &v
	return s
}

func (s *GetFileVersionRequest) SetProjectIdentifier(v string) *GetFileVersionRequest {
	s.ProjectIdentifier = &v
	return s
}

type GetFileVersionResponseBody struct {
	// The details of the file version.
	Data *GetFileVersionResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetFileVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetFileVersionResponseBody) GoString() string {
	return s.String()
}

func (s *GetFileVersionResponseBody) SetData(v *GetFileVersionResponseBodyData) *GetFileVersionResponseBody {
	s.Data = v
	return s
}

func (s *GetFileVersionResponseBody) SetErrorCode(v string) *GetFileVersionResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetFileVersionResponseBody) SetErrorMessage(v string) *GetFileVersionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetFileVersionResponseBody) SetHttpStatusCode(v int32) *GetFileVersionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetFileVersionResponseBody) SetRequestId(v string) *GetFileVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetFileVersionResponseBody) SetSuccess(v bool) *GetFileVersionResponseBody {
	s.Success = &v
	return s
}

type GetFileVersionResponseBodyData struct {
	// The change type of the file version. Valid values: CREATE, UPDATE, and DELETE.
	ChangeType *string `json:"ChangeType,omitempty" xml:"ChangeType,omitempty"`
	// The description of the file version.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The time when the version was generated. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CommitTime *int64 `json:"CommitTime,omitempty" xml:"CommitTime,omitempty"`
	// The ID of the Alibaba Cloud account that is used to create the file version.
	CommitUser *string `json:"CommitUser,omitempty" xml:"CommitUser,omitempty"`
	// The file code.
	FileContent *string `json:"FileContent,omitempty" xml:"FileContent,omitempty"`
	// The file name.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The basic information about the file.
	FilePropertyContent *string `json:"FilePropertyContent,omitempty" xml:"FilePropertyContent,omitempty"`
	// The file version.
	FileVersion *int32 `json:"FileVersion,omitempty" xml:"FileVersion,omitempty"`
	// Indicates whether the version is the latest version in the production environment.
	IsCurrentProd *bool `json:"IsCurrentProd,omitempty" xml:"IsCurrentProd,omitempty"`
	// The scheduling configurations of the node that corresponds to the file version.
	NodeContent *string `json:"NodeContent,omitempty" xml:"NodeContent,omitempty"`
	// The ID of the node that corresponds to the file version.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The status of the file version. Valid values: COMMITTING, COMMITTED, CHECK_OK, PACKAGED, DEPLOYING, DEPLOYED, and CANCELLED. The value CHECK_OK is equivalent to the value COMMITTED.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The functional module to which the file belongs. Valid values: NORMAL, MANUAL, MANUAL_BIZ, SKIP, ADHOCQUERY, and COMPONENT. The value NORMAL indicates DataStudio. The value MANUAL indicates a manually triggered node. The value MANUAL_BIZ indicates a manually triggered workflow. The value SKIP indicates a dry-run DataStudio node. The value ADHOCQUERY indicates an ad hoc query. The value COMPONENT indicates snippets.
	UseType *string `json:"UseType,omitempty" xml:"UseType,omitempty"`
}

func (s GetFileVersionResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetFileVersionResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetFileVersionResponseBodyData) SetChangeType(v string) *GetFileVersionResponseBodyData {
	s.ChangeType = &v
	return s
}

func (s *GetFileVersionResponseBodyData) SetComment(v string) *GetFileVersionResponseBodyData {
	s.Comment = &v
	return s
}

func (s *GetFileVersionResponseBodyData) SetCommitTime(v int64) *GetFileVersionResponseBodyData {
	s.CommitTime = &v
	return s
}

func (s *GetFileVersionResponseBodyData) SetCommitUser(v string) *GetFileVersionResponseBodyData {
	s.CommitUser = &v
	return s
}

func (s *GetFileVersionResponseBodyData) SetFileContent(v string) *GetFileVersionResponseBodyData {
	s.FileContent = &v
	return s
}

func (s *GetFileVersionResponseBodyData) SetFileName(v string) *GetFileVersionResponseBodyData {
	s.FileName = &v
	return s
}

func (s *GetFileVersionResponseBodyData) SetFilePropertyContent(v string) *GetFileVersionResponseBodyData {
	s.FilePropertyContent = &v
	return s
}

func (s *GetFileVersionResponseBodyData) SetFileVersion(v int32) *GetFileVersionResponseBodyData {
	s.FileVersion = &v
	return s
}

func (s *GetFileVersionResponseBodyData) SetIsCurrentProd(v bool) *GetFileVersionResponseBodyData {
	s.IsCurrentProd = &v
	return s
}

func (s *GetFileVersionResponseBodyData) SetNodeContent(v string) *GetFileVersionResponseBodyData {
	s.NodeContent = &v
	return s
}

func (s *GetFileVersionResponseBodyData) SetNodeId(v int64) *GetFileVersionResponseBodyData {
	s.NodeId = &v
	return s
}

func (s *GetFileVersionResponseBodyData) SetStatus(v string) *GetFileVersionResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetFileVersionResponseBodyData) SetUseType(v string) *GetFileVersionResponseBodyData {
	s.UseType = &v
	return s
}

type GetFileVersionResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetFileVersionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetFileVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s GetFileVersionResponse) GoString() string {
	return s.String()
}

func (s *GetFileVersionResponse) SetHeaders(v map[string]*string) *GetFileVersionResponse {
	s.Headers = v
	return s
}

func (s *GetFileVersionResponse) SetStatusCode(v int32) *GetFileVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *GetFileVersionResponse) SetBody(v *GetFileVersionResponseBody) *GetFileVersionResponse {
	s.Body = v
	return s
}

type GetFolderRequest struct {
	// The ID of the folder. You can call the [ListFolders](~~173955~~) operation to query the ID.
	//
	// You must specify either this parameter or the FolderPath parameter.
	FolderId *string `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The path of the folder. You can call the [ListFolders](~~173955~~) operation to query the path.
	//
	// You must specify either this parameter or the FolderId parameter.
	FolderPath *string `json:"FolderPath,omitempty" xml:"FolderPath,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID. You must specify either this parameter or ProjectIdentifier to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Settings panel to obtain the name. You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s GetFolderRequest) String() string {
	return tea.Prettify(s)
}

func (s GetFolderRequest) GoString() string {
	return s.String()
}

func (s *GetFolderRequest) SetFolderId(v string) *GetFolderRequest {
	s.FolderId = &v
	return s
}

func (s *GetFolderRequest) SetFolderPath(v string) *GetFolderRequest {
	s.FolderPath = &v
	return s
}

func (s *GetFolderRequest) SetProjectId(v int64) *GetFolderRequest {
	s.ProjectId = &v
	return s
}

func (s *GetFolderRequest) SetProjectIdentifier(v string) *GetFolderRequest {
	s.ProjectIdentifier = &v
	return s
}

type GetFolderResponseBody struct {
	// The details of the folder.
	Data *GetFolderResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetFolderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetFolderResponseBody) GoString() string {
	return s.String()
}

func (s *GetFolderResponseBody) SetData(v *GetFolderResponseBodyData) *GetFolderResponseBody {
	s.Data = v
	return s
}

func (s *GetFolderResponseBody) SetErrorCode(v string) *GetFolderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetFolderResponseBody) SetErrorMessage(v string) *GetFolderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetFolderResponseBody) SetHttpStatusCode(v int32) *GetFolderResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetFolderResponseBody) SetRequestId(v string) *GetFolderResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetFolderResponseBody) SetSuccess(v bool) *GetFolderResponseBody {
	s.Success = &v
	return s
}

type GetFolderResponseBodyData struct {
	// The ID of the folder.
	FolderId *string `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The path of the folder.
	FolderPath *string `json:"FolderPath,omitempty" xml:"FolderPath,omitempty"`
}

func (s GetFolderResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetFolderResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetFolderResponseBodyData) SetFolderId(v string) *GetFolderResponseBodyData {
	s.FolderId = &v
	return s
}

func (s *GetFolderResponseBodyData) SetFolderPath(v string) *GetFolderResponseBodyData {
	s.FolderPath = &v
	return s
}

type GetFolderResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetFolderResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetFolderResponse) String() string {
	return tea.Prettify(s)
}

func (s GetFolderResponse) GoString() string {
	return s.String()
}

func (s *GetFolderResponse) SetHeaders(v map[string]*string) *GetFolderResponse {
	s.Headers = v
	return s
}

func (s *GetFolderResponse) SetStatusCode(v int32) *GetFolderResponse {
	s.StatusCode = &v
	return s
}

func (s *GetFolderResponse) SetBody(v *GetFolderResponseBody) *GetFolderResponse {
	s.Body = v
	return s
}

type GetIDEEventDetailRequest struct {
	// The ID of the message. You can obtain the ID from the received message when the extension point event is triggered.
	MessageId *string `json:"MessageId,omitempty" xml:"MessageId,omitempty"`
	// The ID of the workspace. You can obtain the ID from the message.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetIDEEventDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetIDEEventDetailRequest) GoString() string {
	return s.String()
}

func (s *GetIDEEventDetailRequest) SetMessageId(v string) *GetIDEEventDetailRequest {
	s.MessageId = &v
	return s
}

func (s *GetIDEEventDetailRequest) SetProjectId(v int64) *GetIDEEventDetailRequest {
	s.ProjectId = &v
	return s
}

type GetIDEEventDetailResponseBody struct {
	// The data snapshot that is generated when the extension point event is triggered.
	//
	// The fields contained in data snapshots vary based on the types of the triggered extension point events. For more information, see the description of the fields.
	EventDetail *GetIDEEventDetailResponseBodyEventDetail `json:"EventDetail,omitempty" xml:"EventDetail,omitempty" type:"Struct"`
	// The ID of the request. You can troubleshoot errors based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetIDEEventDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetIDEEventDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetIDEEventDetailResponseBody) SetEventDetail(v *GetIDEEventDetailResponseBodyEventDetail) *GetIDEEventDetailResponseBody {
	s.EventDetail = v
	return s
}

func (s *GetIDEEventDetailResponseBody) SetRequestId(v string) *GetIDEEventDetailResponseBody {
	s.RequestId = &v
	return s
}

type GetIDEEventDetailResponseBodyEventDetail struct {
	// The data snapshot when the file is committed and deployed.
	//
	// The value of this parameter is not empty only when the message type is IDE_FILE_SUBMIT_BEFORE or IDE_FILE_DEPLOY_BEFORE.
	CommittedFile *GetIDEEventDetailResponseBodyEventDetailCommittedFile `json:"CommittedFile,omitempty" xml:"CommittedFile,omitempty" type:"Struct"`
	// The data snapshot when the file is deleted. The value of this parameter is not empty only when the message type is IDE_FILE_DELETE_BEFORE.
	DeletedFile *GetIDEEventDetailResponseBodyEventDetailDeletedFile `json:"DeletedFile,omitempty" xml:"DeletedFile,omitempty" type:"Struct"`
	// The data snapshot when the code in the file is run. The value of this parameter is not empty only when the message type is IDE_FILE_EXECUTE_BEFORE.
	FileExecutionCommand *GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand `json:"FileExecutionCommand,omitempty" xml:"FileExecutionCommand,omitempty" type:"Struct"`
	// The data snapshot when the table is committed and deployed. The value of this parameter is not empty only when the message type is IDE_TABLE_SUBMIT_BEFORE or IDE_TABLE_DEPLOY_BEFORE.
	TableModel *GetIDEEventDetailResponseBodyEventDetailTableModel `json:"TableModel,omitempty" xml:"TableModel,omitempty" type:"Struct"`
}

func (s GetIDEEventDetailResponseBodyEventDetail) String() string {
	return tea.Prettify(s)
}

func (s GetIDEEventDetailResponseBodyEventDetail) GoString() string {
	return s.String()
}

func (s *GetIDEEventDetailResponseBodyEventDetail) SetCommittedFile(v *GetIDEEventDetailResponseBodyEventDetailCommittedFile) *GetIDEEventDetailResponseBodyEventDetail {
	s.CommittedFile = v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetail) SetDeletedFile(v *GetIDEEventDetailResponseBodyEventDetailDeletedFile) *GetIDEEventDetailResponseBodyEventDetail {
	s.DeletedFile = v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetail) SetFileExecutionCommand(v *GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand) *GetIDEEventDetailResponseBodyEventDetail {
	s.FileExecutionCommand = v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetail) SetTableModel(v *GetIDEEventDetailResponseBodyEventDetailTableModel) *GetIDEEventDetailResponseBodyEventDetail {
	s.TableModel = v
	return s
}

type GetIDEEventDetailResponseBodyEventDetailCommittedFile struct {
	// The type of the change to the file of the current version. Valid values: CREATE, UPDATE, and DELETE.
	ChangeType *string `json:"ChangeType,omitempty" xml:"ChangeType,omitempty"`
	// The description of the file version.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ID of the Alibaba Cloud account that is used to create the file of the current version.
	Committor *string `json:"Committor,omitempty" xml:"Committor,omitempty"`
	// The code in the file of the current version.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the file.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The name of the file.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The details of the file.
	FilePropertyContent *GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent `json:"FilePropertyContent,omitempty" xml:"FilePropertyContent,omitempty" type:"Struct"`
	// The type of the code in the file. Examples: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time sync), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3).
	FileType *int64 `json:"FileType,omitempty" xml:"FileType,omitempty"`
	// The scheduling properties of the node that corresponds to the file.
	NodeConfiguration *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration `json:"NodeConfiguration,omitempty" xml:"NodeConfiguration,omitempty" type:"Struct"`
	// The ID of the node that is scheduled.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The module to which the file belongs. Valid values:
	//
	// *   NORMAL: The file is used for DataStudio.
	// *   MANUAL: The file is used for a manually triggered node.
	// *   MANUAL_BIZ: The file is used for a manually triggered workflow.
	// *   SKIP: The file is used for a dry-run DataStudio node.
	// *   ADHOCQUERY: The file is used for an ad hoc query.
	// *   COMPONENT: The file is used for a snippet.
	UseType *string `json:"UseType,omitempty" xml:"UseType,omitempty"`
}

func (s GetIDEEventDetailResponseBodyEventDetailCommittedFile) String() string {
	return tea.Prettify(s)
}

func (s GetIDEEventDetailResponseBodyEventDetailCommittedFile) GoString() string {
	return s.String()
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFile) SetChangeType(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFile {
	s.ChangeType = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFile) SetComment(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFile {
	s.Comment = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFile) SetCommittor(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFile {
	s.Committor = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFile) SetContent(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFile {
	s.Content = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFile) SetFileId(v int64) *GetIDEEventDetailResponseBodyEventDetailCommittedFile {
	s.FileId = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFile) SetFileName(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFile {
	s.FileName = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFile) SetFilePropertyContent(v *GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent) *GetIDEEventDetailResponseBodyEventDetailCommittedFile {
	s.FilePropertyContent = v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFile) SetFileType(v int64) *GetIDEEventDetailResponseBodyEventDetailCommittedFile {
	s.FileType = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFile) SetNodeConfiguration(v *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration) *GetIDEEventDetailResponseBodyEventDetailCommittedFile {
	s.NodeConfiguration = v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFile) SetNodeId(v int64) *GetIDEEventDetailResponseBodyEventDetailCommittedFile {
	s.NodeId = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFile) SetUseType(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFile {
	s.UseType = &v
	return s
}

type GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent struct {
	// The ID of the workflow to which the file belongs.
	BusinessId *int64 `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	// The latest version number of the file.
	CurrentVersion *int64 `json:"CurrentVersion,omitempty" xml:"CurrentVersion,omitempty"`
	// The name of the compute engine instance with which the file is associated.
	DataSourceName *string `json:"DataSourceName,omitempty" xml:"DataSourceName,omitempty"`
	// The ID of the folder to which the file belongs. You can call the [GetFolder](~~173952~~) operation to query the details of the file based on the folder ID.
	FolderId *string `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The owner of the file.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ID of the do-while node or for-each node that corresponds to the file.
	ParentFileId *int64 `json:"ParentFileId,omitempty" xml:"ParentFileId,omitempty"`
}

func (s GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent) String() string {
	return tea.Prettify(s)
}

func (s GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent) GoString() string {
	return s.String()
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent) SetBusinessId(v int64) *GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent {
	s.BusinessId = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent) SetCurrentVersion(v int64) *GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent {
	s.CurrentVersion = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent) SetDataSourceName(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent {
	s.DataSourceName = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent) SetFolderId(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent {
	s.FolderId = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent) SetOwner(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent {
	s.Owner = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent) SetParentFileId(v int64) *GetIDEEventDetailResponseBodyEventDetailCommittedFileFilePropertyContent {
	s.ParentFileId = &v
	return s
}

type GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration struct {
	// The interval at which the node corresponding to the file is rerun. Unit: milliseconds.
	AutoRerunIntervalMillis *int64 `json:"AutoRerunIntervalMillis,omitempty" xml:"AutoRerunIntervalMillis,omitempty"`
	// The number of times that the node corresponding to the file can be rerun.
	AutoRerunTimes *int64 `json:"AutoRerunTimes,omitempty" xml:"AutoRerunTimes,omitempty"`
	// The CRON expression that is used to schedule the node corresponding to the file.
	CronExpress *string `json:"CronExpress,omitempty" xml:"CronExpress,omitempty"`
	// The type of the scheduling cycle of the node that corresponds to the file. Valid values: NOT_DAY and DAY. A value of NOT_DAY indicates that the node is scheduled to run by minute or hour. A value of DAY indicates that the node is scheduled to run by day, week, or month.
	//
	// This parameter is equivalent to the Scheduling Cycle parameter in the Schedule section of the Properties panel in the [DataWorks console](https://workbench.data.aliyun.com/console).
	CycleType *string `json:"CycleType,omitempty" xml:"CycleType,omitempty"`
	// The IDs of the nodes on which the node corresponding to the file depends when the DependentType parameter is set to USER_DEFINE. Multiple IDs are separated by commas (,).
	//
	// This parameter is equivalent to the field that appears after Previous Cycle is selected and the Depend On parameter is set to Other Nodes in the Dependencies section of the Properties panel in the [DataWorks console](https://workbench.data.aliyun.com/console).
	DependentNodeIdList *string `json:"DependentNodeIdList,omitempty" xml:"DependentNodeIdList,omitempty"`
	// The type of the cross-cycle scheduling dependency of the node that corresponds to the file. Valid values:
	//
	// *   SELF: The instance generated for the node in the current cycle depends on the instance generated for the node in the previous cycle.
	// *   CHILD: The instance generated for the node in the current cycle depends on the instances generated for the descendant nodes at the nearest level of the node in the previous cycle.
	// *   USER_DEFINE: The instance generated for the node in the current cycle depends on the instances generated for one or more specified nodes in the previous cycle.
	// *   NONE: No cross-cycle scheduling dependency type is selected for the node.
	DependentType *string `json:"DependentType,omitempty" xml:"DependentType,omitempty"`
	// The output names of the parent files on which the current file depends.
	InputList []*GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList `json:"InputList,omitempty" xml:"InputList,omitempty" type:"Repeated"`
	// The output names of the current file.
	//
	// This parameter is equivalent to the Output Name parameter under Output in the Dependencies section of the Properties panel in the [DataWorks console](https://workbench.data.aliyun.com/console).
	OutputList []*GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList `json:"OutputList,omitempty" xml:"OutputList,omitempty" type:"Repeated"`
	// The scheduling parameters.
	//
	// This parameter is equivalent to the configuration of the scheduling parameters in the Parameters section of the Properties panel in the [DataWorks console](https://workbench.data.aliyun.com/console). For more information, see [Configure scheduling parameters](~~137548~~).
	ParaValue *string `json:"ParaValue,omitempty" xml:"ParaValue,omitempty"`
	// Indicates whether the node can be rerun. Valid values:
	//
	// *   ALL_ALLOWED: The node can be rerun regardless of whether it is successfully run or fails to run.
	// *   FAILURE_ALLOWED: The node can be rerun only after it fails to run.
	// *   ALL_DENIED: The node cannot be rerun regardless of whether it is successfully run or fails to run.
	//
	// This parameter is equivalent to the Rerun parameter in the Schedule section of the Properties panel in the [DataWorks console](https://workbench.data.aliyun.com/console).
	RerunMode *string `json:"RerunMode,omitempty" xml:"RerunMode,omitempty"`
	// The ID of the resource group that is used to run the node that corresponds to the file. You can call the [ListResourceGroups](~~173913~~) operation to query the available resource groups in the workspace.
	ResourceGroupId *int64 `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The scheduling type of the node. Valid values:
	//
	// *   NORMAL: The node is an auto triggered node.
	// *   MANUAL: The node is a manually triggered node. Manually triggered nodes cannot be automatically triggered. They correspond to the nodes in the Manually Triggered Workflows pane.
	// *   PAUSE: The node is a paused node.
	// *   SKIP: The node is a dry-run node. Dry-run nodes are started as scheduled but the system sets the status of the nodes to successful when it starts to run them.
	SchedulerType *string `json:"SchedulerType,omitempty" xml:"SchedulerType,omitempty"`
}

func (s GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration) String() string {
	return tea.Prettify(s)
}

func (s GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration) GoString() string {
	return s.String()
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration) SetAutoRerunIntervalMillis(v int64) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration {
	s.AutoRerunIntervalMillis = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration) SetAutoRerunTimes(v int64) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration {
	s.AutoRerunTimes = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration) SetCronExpress(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration {
	s.CronExpress = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration) SetCycleType(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration {
	s.CycleType = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration) SetDependentNodeIdList(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration {
	s.DependentNodeIdList = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration) SetDependentType(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration {
	s.DependentType = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration) SetInputList(v []*GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration {
	s.InputList = v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration) SetOutputList(v []*GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration {
	s.OutputList = v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration) SetParaValue(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration {
	s.ParaValue = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration) SetRerunMode(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration {
	s.RerunMode = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration) SetResourceGroupId(v int64) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration {
	s.ResourceGroupId = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration) SetSchedulerType(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfiguration {
	s.SchedulerType = &v
	return s
}

type GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList struct {
	// The output names of the parent files on which the current file depends.
	//
	// This parameter is equivalent to the Output Name parameter under Parent Nodes in the Dependencies section of the Properties panel in the [DataWorks console](https://workbench.data.aliyun.com/console).
	Input *string `json:"Input,omitempty" xml:"Input,omitempty"`
	// The mode of the configuration file dependency. Valid values:
	//
	// *   MANUAL: The scheduling dependencies are manually configured.
	// *   AUTO: The scheduling dependencies are automatically parsed.
	ParseType *string `json:"ParseType,omitempty" xml:"ParseType,omitempty"`
}

func (s GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList) String() string {
	return tea.Prettify(s)
}

func (s GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList) GoString() string {
	return s.String()
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList) SetInput(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList {
	s.Input = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList) SetParseType(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationInputList {
	s.ParseType = &v
	return s
}

type GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList struct {
	// The output name of the current file.
	//
	// This parameter is equivalent to the Output Name parameter under Output in the Dependencies section of the Properties panel in the [DataWorks console](https://workbench.data.aliyun.com/console).
	Output *string `json:"Output,omitempty" xml:"Output,omitempty"`
	// The output table name of the current file.
	//
	// This parameter is equivalent to the Output Table Name parameter under Output in the Dependencies section of the Properties panel in the [DataWorks console](https://workbench.data.aliyun.com/console).
	RefTableName *string `json:"RefTableName,omitempty" xml:"RefTableName,omitempty"`
}

func (s GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList) String() string {
	return tea.Prettify(s)
}

func (s GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList) GoString() string {
	return s.String()
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList) SetOutput(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList {
	s.Output = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList) SetRefTableName(v string) *GetIDEEventDetailResponseBodyEventDetailCommittedFileNodeConfigurationOutputList {
	s.RefTableName = &v
	return s
}

type GetIDEEventDetailResponseBodyEventDetailDeletedFile struct {
	// The ID of the workflow to which the file belongs.
	BusinessId *int64 `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	// The code in the file of the current version.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The latest version number of the file.
	CurrentVersion *int64 `json:"CurrentVersion,omitempty" xml:"CurrentVersion,omitempty"`
	// The name of the compute engine instance with which the file is associated.
	DataSourceName *string `json:"DataSourceName,omitempty" xml:"DataSourceName,omitempty"`
	// The ID of the file.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The name of the file.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The type of the code in the file. Examples: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time sync), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3).
	FileType *int64 `json:"FileType,omitempty" xml:"FileType,omitempty"`
	// The ID of the folder to which the file belongs. You can call the [GetFolder](~~173952~~) operation to query the details of the file based on the folder ID.
	FolderId *string `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The ID of the node that is scheduled.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The owner of the file.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ID of the do-while node or for-each node that corresponds to the file.
	ParentFileId *int64 `json:"ParentFileId,omitempty" xml:"ParentFileId,omitempty"`
	// The module to which the file belongs. Valid values:
	//
	// *   NORMAL: The file is used for DataStudio.
	// *   MANUAL: The file is used for a manually triggered node.
	// *   MANUAL_BIZ: The file is used for a manually triggered workflow.
	// *   SKIP: The file is used for a dry-run DataStudio node.
	// *   ADHOCQUERY: The file is used for an ad hoc query.
	// *   COMPONENT: The file is used for a snippet.
	UseType *string `json:"UseType,omitempty" xml:"UseType,omitempty"`
}

func (s GetIDEEventDetailResponseBodyEventDetailDeletedFile) String() string {
	return tea.Prettify(s)
}

func (s GetIDEEventDetailResponseBodyEventDetailDeletedFile) GoString() string {
	return s.String()
}

func (s *GetIDEEventDetailResponseBodyEventDetailDeletedFile) SetBusinessId(v int64) *GetIDEEventDetailResponseBodyEventDetailDeletedFile {
	s.BusinessId = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailDeletedFile) SetContent(v string) *GetIDEEventDetailResponseBodyEventDetailDeletedFile {
	s.Content = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailDeletedFile) SetCurrentVersion(v int64) *GetIDEEventDetailResponseBodyEventDetailDeletedFile {
	s.CurrentVersion = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailDeletedFile) SetDataSourceName(v string) *GetIDEEventDetailResponseBodyEventDetailDeletedFile {
	s.DataSourceName = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailDeletedFile) SetFileId(v int64) *GetIDEEventDetailResponseBodyEventDetailDeletedFile {
	s.FileId = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailDeletedFile) SetFileName(v string) *GetIDEEventDetailResponseBodyEventDetailDeletedFile {
	s.FileName = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailDeletedFile) SetFileType(v int64) *GetIDEEventDetailResponseBodyEventDetailDeletedFile {
	s.FileType = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailDeletedFile) SetFolderId(v string) *GetIDEEventDetailResponseBodyEventDetailDeletedFile {
	s.FolderId = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailDeletedFile) SetNodeId(v int64) *GetIDEEventDetailResponseBodyEventDetailDeletedFile {
	s.NodeId = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailDeletedFile) SetOwner(v string) *GetIDEEventDetailResponseBodyEventDetailDeletedFile {
	s.Owner = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailDeletedFile) SetParentFileId(v int64) *GetIDEEventDetailResponseBodyEventDetailDeletedFile {
	s.ParentFileId = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailDeletedFile) SetUseType(v string) *GetIDEEventDetailResponseBodyEventDetailDeletedFile {
	s.UseType = &v
	return s
}

type GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand struct {
	// The code in the file of the current version.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The name of the compute engine instance with which the file is associated.
	DataSourceName *string `json:"DataSourceName,omitempty" xml:"DataSourceName,omitempty"`
	// The ID of the file.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The type of the code in the file. Examples: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time sync), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3).
	FileType *int64 `json:"FileType,omitempty" xml:"FileType,omitempty"`
}

func (s GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand) String() string {
	return tea.Prettify(s)
}

func (s GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand) GoString() string {
	return s.String()
}

func (s *GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand) SetContent(v string) *GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand {
	s.Content = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand) SetDataSourceName(v string) *GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand {
	s.DataSourceName = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand) SetFileId(v int64) *GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand {
	s.FileId = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand) SetFileType(v int64) *GetIDEEventDetailResponseBodyEventDetailFileExecutionCommand {
	s.FileType = &v
	return s
}

type GetIDEEventDetailResponseBodyEventDetailTableModel struct {
	// The columns in the table.
	Columns []*GetIDEEventDetailResponseBodyEventDetailTableModelColumns `json:"Columns,omitempty" xml:"Columns,omitempty" type:"Repeated"`
	// The description of the table.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The name of the compute engine instance to which the table belongs.
	DataSourceName *string `json:"DataSourceName,omitempty" xml:"DataSourceName,omitempty"`
	// The environment in which the table is used. Valid values:
	//
	// - DEV: development environment
	// - PROD: production environment
	Env *string `json:"Env,omitempty" xml:"Env,omitempty"`
	// The lifecycle of the table. Unit: days.
	LifeCycle *int64 `json:"LifeCycle,omitempty" xml:"LifeCycle,omitempty"`
	// The path of the table.
	Location *string `json:"Location,omitempty" xml:"Location,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetIDEEventDetailResponseBodyEventDetailTableModel) String() string {
	return tea.Prettify(s)
}

func (s GetIDEEventDetailResponseBodyEventDetailTableModel) GoString() string {
	return s.String()
}

func (s *GetIDEEventDetailResponseBodyEventDetailTableModel) SetColumns(v []*GetIDEEventDetailResponseBodyEventDetailTableModelColumns) *GetIDEEventDetailResponseBodyEventDetailTableModel {
	s.Columns = v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailTableModel) SetComment(v string) *GetIDEEventDetailResponseBodyEventDetailTableModel {
	s.Comment = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailTableModel) SetDataSourceName(v string) *GetIDEEventDetailResponseBodyEventDetailTableModel {
	s.DataSourceName = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailTableModel) SetEnv(v string) *GetIDEEventDetailResponseBodyEventDetailTableModel {
	s.Env = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailTableModel) SetLifeCycle(v int64) *GetIDEEventDetailResponseBodyEventDetailTableModel {
	s.LifeCycle = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailTableModel) SetLocation(v string) *GetIDEEventDetailResponseBodyEventDetailTableModel {
	s.Location = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailTableModel) SetTableName(v string) *GetIDEEventDetailResponseBodyEventDetailTableModel {
	s.TableName = &v
	return s
}

type GetIDEEventDetailResponseBodyEventDetailTableModelColumns struct {
	// The name of the column.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The data type of the column.
	ColumnType *string `json:"ColumnType,omitempty" xml:"ColumnType,omitempty"`
	// The remarks of the column.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// Indicates whether the column is a partition key column. Valid values:
	//
	// - true: The column is a partition key column.
	// - false: The column is not a partition key column.
	IsPartitionColumn *bool `json:"IsPartitionColumn,omitempty" xml:"IsPartitionColumn,omitempty"`
}

func (s GetIDEEventDetailResponseBodyEventDetailTableModelColumns) String() string {
	return tea.Prettify(s)
}

func (s GetIDEEventDetailResponseBodyEventDetailTableModelColumns) GoString() string {
	return s.String()
}

func (s *GetIDEEventDetailResponseBodyEventDetailTableModelColumns) SetColumnName(v string) *GetIDEEventDetailResponseBodyEventDetailTableModelColumns {
	s.ColumnName = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailTableModelColumns) SetColumnType(v string) *GetIDEEventDetailResponseBodyEventDetailTableModelColumns {
	s.ColumnType = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailTableModelColumns) SetComment(v string) *GetIDEEventDetailResponseBodyEventDetailTableModelColumns {
	s.Comment = &v
	return s
}

func (s *GetIDEEventDetailResponseBodyEventDetailTableModelColumns) SetIsPartitionColumn(v bool) *GetIDEEventDetailResponseBodyEventDetailTableModelColumns {
	s.IsPartitionColumn = &v
	return s
}

type GetIDEEventDetailResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetIDEEventDetailResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetIDEEventDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetIDEEventDetailResponse) GoString() string {
	return s.String()
}

func (s *GetIDEEventDetailResponse) SetHeaders(v map[string]*string) *GetIDEEventDetailResponse {
	s.Headers = v
	return s
}

func (s *GetIDEEventDetailResponse) SetStatusCode(v int32) *GetIDEEventDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetIDEEventDetailResponse) SetBody(v *GetIDEEventDetailResponseBody) *GetIDEEventDetailResponse {
	s.Body = v
	return s
}

type GetInstanceRequest struct {
	// The ID of the instance. You can call the [ListInstances](~~173982~~) operation to query the ID.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV. The value PROD indicates the production environment, and the value DEV indicates the development environment.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s GetInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceRequest) GoString() string {
	return s.String()
}

func (s *GetInstanceRequest) SetInstanceId(v int64) *GetInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *GetInstanceRequest) SetProjectEnv(v string) *GetInstanceRequest {
	s.ProjectEnv = &v
	return s
}

type GetInstanceResponseBody struct {
	// The details about the instance.
	Data *GetInstanceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned because the instance fails to be scheduled.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *GetInstanceResponseBody) SetData(v *GetInstanceResponseBodyData) *GetInstanceResponseBody {
	s.Data = v
	return s
}

func (s *GetInstanceResponseBody) SetErrorCode(v string) *GetInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetInstanceResponseBody) SetErrorMessage(v string) *GetInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetInstanceResponseBody) SetHttpStatusCode(v int32) *GetInstanceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetInstanceResponseBody) SetRequestId(v string) *GetInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetInstanceResponseBody) SetSuccess(v bool) *GetInstanceResponseBody {
	s.Success = &v
	return s
}

type GetInstanceResponseBodyData struct {
	// The ID of the baseline.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The time when the instance started to run.
	BeginRunningTime *int64 `json:"BeginRunningTime,omitempty" xml:"BeginRunningTime,omitempty"`
	// The time when the instance started to wait for resources.
	BeginWaitResTime *int64 `json:"BeginWaitResTime,omitempty" xml:"BeginWaitResTime,omitempty"`
	// The time when the instance started to wait to be run.
	BeginWaitTimeTime *int64 `json:"BeginWaitTimeTime,omitempty" xml:"BeginWaitTimeTime,omitempty"`
	// The data timestamp. In most cases, the value is one day before the date when the instance is run.
	Bizdate *int64 `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	// The ID of the workflow.
	BusinessId *int64 `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	// The connection string.
	Connection *string `json:"Connection,omitempty" xml:"Connection,omitempty"`
	// The time when the instance was generated.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The owner of the instance.
	CreateUser *string `json:"CreateUser,omitempty" xml:"CreateUser,omitempty"`
	// The scheduled time of the instance.
	CycTime *int64 `json:"CycTime,omitempty" xml:"CycTime,omitempty"`
	// The ID of the workflow.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The type of the workflow. Valid values:
	//
	// *   DAILY: The workflow is used to run auto triggered nodes.
	// *   MANUAL: The workflow is used to run manually triggered nodes.
	// *   SMOKE_TEST: The workflow is used to perform smoke testing.
	// *   SUPPLY_DATA: The workflow is used to backfill data.
	DagType *string `json:"DagType,omitempty" xml:"DagType,omitempty"`
	// The table and partition filter expression in Data Quality that are associated with the instance.
	DqcDescription *string `json:"DqcDescription,omitempty" xml:"DqcDescription,omitempty"`
	// Indicates whether the instance is associated with a monitoring rule in Data Quality. Valid values:
	//
	// *   0: The instance is associated with a monitoring rule in Data Quality.
	// *   1: The instance is not associated with a monitoring rule in Data Quality.
	DqcType *int32 `json:"DqcType,omitempty" xml:"DqcType,omitempty"`
	// The time when the running of the instance was complete.
	FinishTime *int64 `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	// The ID of the instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The time when the instance was last modified.
	ModifyTime *int64 `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The ID of the node that generates the instance.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node that generates the instance.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The values of the parameters related to the node.
	ParamValues *string `json:"ParamValues,omitempty" xml:"ParamValues,omitempty"`
	// The priority of the instance. Valid values: 1, 3, 5, 7, and 8. A great value indicates a high priority. Default value: 1.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the workflow to which the node that generates the instance belongs.
	RelatedFlowId *int64 `json:"RelatedFlowId,omitempty" xml:"RelatedFlowId,omitempty"`
	// The interval at which the node that generates the instance is rerun after the node fails to run. Unit: milliseconds.
	RepeatInterval *int64 `json:"RepeatInterval,omitempty" xml:"RepeatInterval,omitempty"`
	// Indicates whether the node that generates the instance can be rerun.
	Repeatability *bool `json:"Repeatability,omitempty" xml:"Repeatability,omitempty"`
	// The status of the node that generates the instance. Valid values:
	//
	// *   NOT_RUN: The node is not run.
	// *   WAIT_TIME: The node is waiting for its scheduled time to arrive.
	// *   WAIT_RESOURCE: The node is waiting for resources.
	// *   RUNNING: The node is running.
	// *   CHECKING: Data quality is being checked for the node.
	// *   CHECKING_CONDITION: Branch conditions are being checked for the node.
	// *   FAILURE: The node fails to run.
	// *   SUCCESS: The node is successfully run.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The number of times the node that generates the instance can be rerun. This parameter can be left empty, or the value of this parameter can be an integer that is greater than or equal to 0.
	//
	// *   If this parameter is left empty, the number of rerun times is not specified for the node.
	// *   If the value of this parameter is 0, the node cannot be rerun.
	// *   If the value of this parameter is n (an integer that is greater than 0), the node can be rerun n times. For example, if the value of this parameter is 1, the node can be rerun once. If the value of this parameter is 2, the node can be rerun two times, and so on.
	TaskRerunTime *int32 `json:"TaskRerunTime,omitempty" xml:"TaskRerunTime,omitempty"`
	// The scheduling type of the node that generates the instance. Valid values:
	//
	// *   NORMAL(0): The node is an auto triggered node. It is run on a regular basis.
	// *   MANUAL(1): The node is a manually triggered node. It is not run on a regular basis.
	// *   PAUSE(2): The node is a frozen node. The scheduling system still runs the node on a regular basis but sets it to FAILURE when the scheduling system starts to run the node.
	// *   SKIP(3): The node is a dry-run node. The scheduling system still runs the node on a regular basis but sets it to SUCCESS when the scheduling system starts to run the node.
	// *   SKIP_UNCHOOSE(4): The node is an unselected node in a temporary workflow. This type of node exists only in temporary workflows. The scheduling system sets the node to SUCCESS when the scheduling system starts to run the node.
	// *   SKIP_CYCLE(5): The node is a node that is scheduled by week or month and is waiting for its scheduled time. The scheduling system still runs the node on a regular basis but sets it to SUCCESS when the scheduling system starts to run the node.
	// *   CONDITION_UNCHOOSE(6): The node is not selected by its ancestor branch node and is run as a dry-run node.
	// *   REALTIME_DEPRECATED(7): The node has instances generated in real time but deprecated. The scheduling system directly sets the node to SUCCESS.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s GetInstanceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetInstanceResponseBodyData) SetBaselineId(v int64) *GetInstanceResponseBodyData {
	s.BaselineId = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetBeginRunningTime(v int64) *GetInstanceResponseBodyData {
	s.BeginRunningTime = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetBeginWaitResTime(v int64) *GetInstanceResponseBodyData {
	s.BeginWaitResTime = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetBeginWaitTimeTime(v int64) *GetInstanceResponseBodyData {
	s.BeginWaitTimeTime = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetBizdate(v int64) *GetInstanceResponseBodyData {
	s.Bizdate = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetBusinessId(v int64) *GetInstanceResponseBodyData {
	s.BusinessId = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetConnection(v string) *GetInstanceResponseBodyData {
	s.Connection = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetCreateTime(v int64) *GetInstanceResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetCreateUser(v string) *GetInstanceResponseBodyData {
	s.CreateUser = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetCycTime(v int64) *GetInstanceResponseBodyData {
	s.CycTime = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetDagId(v int64) *GetInstanceResponseBodyData {
	s.DagId = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetDagType(v string) *GetInstanceResponseBodyData {
	s.DagType = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetDqcDescription(v string) *GetInstanceResponseBodyData {
	s.DqcDescription = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetDqcType(v int32) *GetInstanceResponseBodyData {
	s.DqcType = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetFinishTime(v int64) *GetInstanceResponseBodyData {
	s.FinishTime = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetInstanceId(v int64) *GetInstanceResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetModifyTime(v int64) *GetInstanceResponseBodyData {
	s.ModifyTime = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetNodeId(v int64) *GetInstanceResponseBodyData {
	s.NodeId = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetNodeName(v string) *GetInstanceResponseBodyData {
	s.NodeName = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetParamValues(v string) *GetInstanceResponseBodyData {
	s.ParamValues = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetPriority(v int32) *GetInstanceResponseBodyData {
	s.Priority = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetRelatedFlowId(v int64) *GetInstanceResponseBodyData {
	s.RelatedFlowId = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetRepeatInterval(v int64) *GetInstanceResponseBodyData {
	s.RepeatInterval = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetRepeatability(v bool) *GetInstanceResponseBodyData {
	s.Repeatability = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetStatus(v string) *GetInstanceResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetTaskRerunTime(v int32) *GetInstanceResponseBodyData {
	s.TaskRerunTime = &v
	return s
}

func (s *GetInstanceResponseBodyData) SetTaskType(v string) *GetInstanceResponseBodyData {
	s.TaskType = &v
	return s
}

type GetInstanceResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceResponse) GoString() string {
	return s.String()
}

func (s *GetInstanceResponse) SetHeaders(v map[string]*string) *GetInstanceResponse {
	s.Headers = v
	return s
}

func (s *GetInstanceResponse) SetStatusCode(v int32) *GetInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetInstanceResponse) SetBody(v *GetInstanceResponseBody) *GetInstanceResponse {
	s.Body = v
	return s
}

type GetInstanceConsumeTimeRankRequest struct {
	Bizdate   *string `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	ProjectId *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetInstanceConsumeTimeRankRequest) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceConsumeTimeRankRequest) GoString() string {
	return s.String()
}

func (s *GetInstanceConsumeTimeRankRequest) SetBizdate(v string) *GetInstanceConsumeTimeRankRequest {
	s.Bizdate = &v
	return s
}

func (s *GetInstanceConsumeTimeRankRequest) SetProjectId(v int64) *GetInstanceConsumeTimeRankRequest {
	s.ProjectId = &v
	return s
}

type GetInstanceConsumeTimeRankResponseBody struct {
	InstanceConsumeTimeRank *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank `json:"InstanceConsumeTimeRank,omitempty" xml:"InstanceConsumeTimeRank,omitempty" type:"Struct"`
	RequestId               *string                                                        `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetInstanceConsumeTimeRankResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceConsumeTimeRankResponseBody) GoString() string {
	return s.String()
}

func (s *GetInstanceConsumeTimeRankResponseBody) SetInstanceConsumeTimeRank(v *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank) *GetInstanceConsumeTimeRankResponseBody {
	s.InstanceConsumeTimeRank = v
	return s
}

func (s *GetInstanceConsumeTimeRankResponseBody) SetRequestId(v string) *GetInstanceConsumeTimeRankResponseBody {
	s.RequestId = &v
	return s
}

type GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank struct {
	ConsumeTimeRank []*GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank `json:"ConsumeTimeRank,omitempty" xml:"ConsumeTimeRank,omitempty" type:"Repeated"`
	UpdateTime      *int64                                                                          `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank) GoString() string {
	return s.String()
}

func (s *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank) SetConsumeTimeRank(v []*GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank) *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank {
	s.ConsumeTimeRank = v
	return s
}

func (s *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank) SetUpdateTime(v int64) *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRank {
	s.UpdateTime = &v
	return s
}

type GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank struct {
	Bizdate    *int64  `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	Consumed   *int64  `json:"Consumed,omitempty" xml:"Consumed,omitempty"`
	InstanceId *int64  `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	NodeId     *int64  `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	NodeName   *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	Owner      *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	PrgType    *int32  `json:"PrgType,omitempty" xml:"PrgType,omitempty"`
}

func (s GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank) GoString() string {
	return s.String()
}

func (s *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank) SetBizdate(v int64) *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank {
	s.Bizdate = &v
	return s
}

func (s *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank) SetConsumed(v int64) *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank {
	s.Consumed = &v
	return s
}

func (s *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank) SetInstanceId(v int64) *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank {
	s.InstanceId = &v
	return s
}

func (s *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank) SetNodeId(v int64) *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank {
	s.NodeId = &v
	return s
}

func (s *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank) SetNodeName(v string) *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank {
	s.NodeName = &v
	return s
}

func (s *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank) SetOwner(v string) *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank {
	s.Owner = &v
	return s
}

func (s *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank) SetPrgType(v int32) *GetInstanceConsumeTimeRankResponseBodyInstanceConsumeTimeRankConsumeTimeRank {
	s.PrgType = &v
	return s
}

type GetInstanceConsumeTimeRankResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetInstanceConsumeTimeRankResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetInstanceConsumeTimeRankResponse) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceConsumeTimeRankResponse) GoString() string {
	return s.String()
}

func (s *GetInstanceConsumeTimeRankResponse) SetHeaders(v map[string]*string) *GetInstanceConsumeTimeRankResponse {
	s.Headers = v
	return s
}

func (s *GetInstanceConsumeTimeRankResponse) SetStatusCode(v int32) *GetInstanceConsumeTimeRankResponse {
	s.StatusCode = &v
	return s
}

func (s *GetInstanceConsumeTimeRankResponse) SetBody(v *GetInstanceConsumeTimeRankResponseBody) *GetInstanceConsumeTimeRankResponse {
	s.Body = v
	return s
}

type GetInstanceCountTrendRequest struct {
	BeginDate *string `json:"BeginDate,omitempty" xml:"BeginDate,omitempty"`
	EndDate   *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	ProjectId *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetInstanceCountTrendRequest) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceCountTrendRequest) GoString() string {
	return s.String()
}

func (s *GetInstanceCountTrendRequest) SetBeginDate(v string) *GetInstanceCountTrendRequest {
	s.BeginDate = &v
	return s
}

func (s *GetInstanceCountTrendRequest) SetEndDate(v string) *GetInstanceCountTrendRequest {
	s.EndDate = &v
	return s
}

func (s *GetInstanceCountTrendRequest) SetProjectId(v int64) *GetInstanceCountTrendRequest {
	s.ProjectId = &v
	return s
}

type GetInstanceCountTrendResponseBody struct {
	InstanceCounts []*GetInstanceCountTrendResponseBodyInstanceCounts `json:"InstanceCounts,omitempty" xml:"InstanceCounts,omitempty" type:"Repeated"`
	RequestId      *string                                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetInstanceCountTrendResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceCountTrendResponseBody) GoString() string {
	return s.String()
}

func (s *GetInstanceCountTrendResponseBody) SetInstanceCounts(v []*GetInstanceCountTrendResponseBodyInstanceCounts) *GetInstanceCountTrendResponseBody {
	s.InstanceCounts = v
	return s
}

func (s *GetInstanceCountTrendResponseBody) SetRequestId(v string) *GetInstanceCountTrendResponseBody {
	s.RequestId = &v
	return s
}

type GetInstanceCountTrendResponseBodyInstanceCounts struct {
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	Date  *int64 `json:"Date,omitempty" xml:"Date,omitempty"`
}

func (s GetInstanceCountTrendResponseBodyInstanceCounts) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceCountTrendResponseBodyInstanceCounts) GoString() string {
	return s.String()
}

func (s *GetInstanceCountTrendResponseBodyInstanceCounts) SetCount(v int32) *GetInstanceCountTrendResponseBodyInstanceCounts {
	s.Count = &v
	return s
}

func (s *GetInstanceCountTrendResponseBodyInstanceCounts) SetDate(v int64) *GetInstanceCountTrendResponseBodyInstanceCounts {
	s.Date = &v
	return s
}

type GetInstanceCountTrendResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetInstanceCountTrendResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetInstanceCountTrendResponse) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceCountTrendResponse) GoString() string {
	return s.String()
}

func (s *GetInstanceCountTrendResponse) SetHeaders(v map[string]*string) *GetInstanceCountTrendResponse {
	s.Headers = v
	return s
}

func (s *GetInstanceCountTrendResponse) SetStatusCode(v int32) *GetInstanceCountTrendResponse {
	s.StatusCode = &v
	return s
}

func (s *GetInstanceCountTrendResponse) SetBody(v *GetInstanceCountTrendResponseBody) *GetInstanceCountTrendResponse {
	s.Body = v
	return s
}

type GetInstanceErrorRankRequest struct {
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetInstanceErrorRankRequest) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceErrorRankRequest) GoString() string {
	return s.String()
}

func (s *GetInstanceErrorRankRequest) SetProjectId(v int64) *GetInstanceErrorRankRequest {
	s.ProjectId = &v
	return s
}

type GetInstanceErrorRankResponseBody struct {
	InstanceErrorRank *GetInstanceErrorRankResponseBodyInstanceErrorRank `json:"InstanceErrorRank,omitempty" xml:"InstanceErrorRank,omitempty" type:"Struct"`
	RequestId         *string                                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetInstanceErrorRankResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceErrorRankResponseBody) GoString() string {
	return s.String()
}

func (s *GetInstanceErrorRankResponseBody) SetInstanceErrorRank(v *GetInstanceErrorRankResponseBodyInstanceErrorRank) *GetInstanceErrorRankResponseBody {
	s.InstanceErrorRank = v
	return s
}

func (s *GetInstanceErrorRankResponseBody) SetRequestId(v string) *GetInstanceErrorRankResponseBody {
	s.RequestId = &v
	return s
}

type GetInstanceErrorRankResponseBodyInstanceErrorRank struct {
	ErrorRank  []*GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank `json:"ErrorRank,omitempty" xml:"ErrorRank,omitempty" type:"Repeated"`
	UpdateTime *int64                                                        `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s GetInstanceErrorRankResponseBodyInstanceErrorRank) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceErrorRankResponseBodyInstanceErrorRank) GoString() string {
	return s.String()
}

func (s *GetInstanceErrorRankResponseBodyInstanceErrorRank) SetErrorRank(v []*GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank) *GetInstanceErrorRankResponseBodyInstanceErrorRank {
	s.ErrorRank = v
	return s
}

func (s *GetInstanceErrorRankResponseBodyInstanceErrorRank) SetUpdateTime(v int64) *GetInstanceErrorRankResponseBodyInstanceErrorRank {
	s.UpdateTime = &v
	return s
}

type GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank struct {
	Count     *int32  `json:"Count,omitempty" xml:"Count,omitempty"`
	NodeId    *int64  `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	NodeName  *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	Owner     *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	PrgType   *int32  `json:"PrgType,omitempty" xml:"PrgType,omitempty"`
	ProjectId *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank) GoString() string {
	return s.String()
}

func (s *GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank) SetCount(v int32) *GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank {
	s.Count = &v
	return s
}

func (s *GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank) SetNodeId(v int64) *GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank {
	s.NodeId = &v
	return s
}

func (s *GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank) SetNodeName(v string) *GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank {
	s.NodeName = &v
	return s
}

func (s *GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank) SetOwner(v string) *GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank {
	s.Owner = &v
	return s
}

func (s *GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank) SetPrgType(v int32) *GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank {
	s.PrgType = &v
	return s
}

func (s *GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank) SetProjectId(v int64) *GetInstanceErrorRankResponseBodyInstanceErrorRankErrorRank {
	s.ProjectId = &v
	return s
}

type GetInstanceErrorRankResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetInstanceErrorRankResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetInstanceErrorRankResponse) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceErrorRankResponse) GoString() string {
	return s.String()
}

func (s *GetInstanceErrorRankResponse) SetHeaders(v map[string]*string) *GetInstanceErrorRankResponse {
	s.Headers = v
	return s
}

func (s *GetInstanceErrorRankResponse) SetStatusCode(v int32) *GetInstanceErrorRankResponse {
	s.StatusCode = &v
	return s
}

func (s *GetInstanceErrorRankResponse) SetBody(v *GetInstanceErrorRankResponseBody) *GetInstanceErrorRankResponse {
	s.Body = v
	return s
}

type GetInstanceLogRequest struct {
	// The historical record number of the instance. You can call the ListInstanceHistory operation to query the ID.
	InstanceHistoryId *int64 `json:"InstanceHistoryId,omitempty" xml:"InstanceHistoryId,omitempty"`
	// The ID of the instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s GetInstanceLogRequest) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceLogRequest) GoString() string {
	return s.String()
}

func (s *GetInstanceLogRequest) SetInstanceHistoryId(v int64) *GetInstanceLogRequest {
	s.InstanceHistoryId = &v
	return s
}

func (s *GetInstanceLogRequest) SetInstanceId(v int64) *GetInstanceLogRequest {
	s.InstanceId = &v
	return s
}

func (s *GetInstanceLogRequest) SetProjectEnv(v string) *GetInstanceLogRequest {
	s.ProjectEnv = &v
	return s
}

type GetInstanceLogResponseBody struct {
	// The content of the logs.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetInstanceLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceLogResponseBody) GoString() string {
	return s.String()
}

func (s *GetInstanceLogResponseBody) SetData(v string) *GetInstanceLogResponseBody {
	s.Data = &v
	return s
}

func (s *GetInstanceLogResponseBody) SetErrorCode(v string) *GetInstanceLogResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetInstanceLogResponseBody) SetErrorMessage(v string) *GetInstanceLogResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetInstanceLogResponseBody) SetHttpStatusCode(v int32) *GetInstanceLogResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetInstanceLogResponseBody) SetRequestId(v string) *GetInstanceLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetInstanceLogResponseBody) SetSuccess(v bool) *GetInstanceLogResponseBody {
	s.Success = &v
	return s
}

type GetInstanceLogResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetInstanceLogResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetInstanceLogResponse) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceLogResponse) GoString() string {
	return s.String()
}

func (s *GetInstanceLogResponse) SetHeaders(v map[string]*string) *GetInstanceLogResponse {
	s.Headers = v
	return s
}

func (s *GetInstanceLogResponse) SetStatusCode(v int32) *GetInstanceLogResponse {
	s.StatusCode = &v
	return s
}

func (s *GetInstanceLogResponse) SetBody(v *GetInstanceLogResponseBody) *GetInstanceLogResponse {
	s.Body = v
	return s
}

type GetInstanceStatusCountRequest struct {
	// The business date of the instance.
	BizDate *string `json:"BizDate,omitempty" xml:"BizDate,omitempty"`
	// The running environment in PROD and DEV modes.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
	// The ID of the DataWorks workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetInstanceStatusCountRequest) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceStatusCountRequest) GoString() string {
	return s.String()
}

func (s *GetInstanceStatusCountRequest) SetBizDate(v string) *GetInstanceStatusCountRequest {
	s.BizDate = &v
	return s
}

func (s *GetInstanceStatusCountRequest) SetProjectEnv(v string) *GetInstanceStatusCountRequest {
	s.ProjectEnv = &v
	return s
}

func (s *GetInstanceStatusCountRequest) SetProjectId(v int64) *GetInstanceStatusCountRequest {
	s.ProjectId = &v
	return s
}

type GetInstanceStatusCountResponseBody struct {
	// The request ID, which is used to locate the logs and troubleshoot problems.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status statistics of the instance.
	StatusCount *GetInstanceStatusCountResponseBodyStatusCount `json:"StatusCount,omitempty" xml:"StatusCount,omitempty" type:"Struct"`
}

func (s GetInstanceStatusCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceStatusCountResponseBody) GoString() string {
	return s.String()
}

func (s *GetInstanceStatusCountResponseBody) SetRequestId(v string) *GetInstanceStatusCountResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetInstanceStatusCountResponseBody) SetStatusCount(v *GetInstanceStatusCountResponseBodyStatusCount) *GetInstanceStatusCountResponseBody {
	s.StatusCount = v
	return s
}

type GetInstanceStatusCountResponseBodyStatusCount struct {
	// The number of failed instances.
	FailureCount *int32 `json:"FailureCount,omitempty" xml:"FailureCount,omitempty"`
	// The number of instances that are not running.
	NotRunCount *int32 `json:"NotRunCount,omitempty" xml:"NotRunCount,omitempty"`
	// The number of running instances.
	RunningCount *int32 `json:"RunningCount,omitempty" xml:"RunningCount,omitempty"`
	// The number of successful instances.
	SuccessCount *int32 `json:"SuccessCount,omitempty" xml:"SuccessCount,omitempty"`
	// The total number of instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The number of instances waiting for resources.
	WaitResCount *int32 `json:"WaitResCount,omitempty" xml:"WaitResCount,omitempty"`
	// The number of instances to be run that meet the conditions.
	WaitTimeCount *int32 `json:"WaitTimeCount,omitempty" xml:"WaitTimeCount,omitempty"`
}

func (s GetInstanceStatusCountResponseBodyStatusCount) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceStatusCountResponseBodyStatusCount) GoString() string {
	return s.String()
}

func (s *GetInstanceStatusCountResponseBodyStatusCount) SetFailureCount(v int32) *GetInstanceStatusCountResponseBodyStatusCount {
	s.FailureCount = &v
	return s
}

func (s *GetInstanceStatusCountResponseBodyStatusCount) SetNotRunCount(v int32) *GetInstanceStatusCountResponseBodyStatusCount {
	s.NotRunCount = &v
	return s
}

func (s *GetInstanceStatusCountResponseBodyStatusCount) SetRunningCount(v int32) *GetInstanceStatusCountResponseBodyStatusCount {
	s.RunningCount = &v
	return s
}

func (s *GetInstanceStatusCountResponseBodyStatusCount) SetSuccessCount(v int32) *GetInstanceStatusCountResponseBodyStatusCount {
	s.SuccessCount = &v
	return s
}

func (s *GetInstanceStatusCountResponseBodyStatusCount) SetTotalCount(v int32) *GetInstanceStatusCountResponseBodyStatusCount {
	s.TotalCount = &v
	return s
}

func (s *GetInstanceStatusCountResponseBodyStatusCount) SetWaitResCount(v int32) *GetInstanceStatusCountResponseBodyStatusCount {
	s.WaitResCount = &v
	return s
}

func (s *GetInstanceStatusCountResponseBodyStatusCount) SetWaitTimeCount(v int32) *GetInstanceStatusCountResponseBodyStatusCount {
	s.WaitTimeCount = &v
	return s
}

type GetInstanceStatusCountResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetInstanceStatusCountResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetInstanceStatusCountResponse) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceStatusCountResponse) GoString() string {
	return s.String()
}

func (s *GetInstanceStatusCountResponse) SetHeaders(v map[string]*string) *GetInstanceStatusCountResponse {
	s.Headers = v
	return s
}

func (s *GetInstanceStatusCountResponse) SetStatusCode(v int32) *GetInstanceStatusCountResponse {
	s.StatusCode = &v
	return s
}

func (s *GetInstanceStatusCountResponse) SetBody(v *GetInstanceStatusCountResponseBody) *GetInstanceStatusCountResponse {
	s.Body = v
	return s
}

type GetInstanceStatusStatisticRequest struct {
	// The date on which the numbers of instances in different states are obtained. Specify the date in the yyyy-MM-dd format.
	BizDate *string `json:"BizDate,omitempty" xml:"BizDate,omitempty"`
	// The type of the directed acyclic graph (DAG). Valid values:
	//
	// *   MANUAL: DAG for a manually triggered workflow
	// *   SMOKE_TEST: DAG for a smoke testing workflow
	// *   SUPPLY_DATA: DAG for a data backfill instance
	// *   BUSINESS_PROCESS_DAG: DAG for a one-time workflow
	DagType *string `json:"DagType,omitempty" xml:"DagType,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV. The value PROD indicates the production environment. The value DEV indicates the development environment.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace ID.
	ProjectId       *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	SchedulerPeriod *string `json:"SchedulerPeriod,omitempty" xml:"SchedulerPeriod,omitempty"`
	// The scheduling type of the node. Valid values:
	//
	// *   NORMAL: auto triggered node
	// *   MANUAL: manually triggered node
	// *   PAUSE: paused node
	// *   SKIP: dry-run node
	SchedulerType *string `json:"SchedulerType,omitempty" xml:"SchedulerType,omitempty"`
}

func (s GetInstanceStatusStatisticRequest) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceStatusStatisticRequest) GoString() string {
	return s.String()
}

func (s *GetInstanceStatusStatisticRequest) SetBizDate(v string) *GetInstanceStatusStatisticRequest {
	s.BizDate = &v
	return s
}

func (s *GetInstanceStatusStatisticRequest) SetDagType(v string) *GetInstanceStatusStatisticRequest {
	s.DagType = &v
	return s
}

func (s *GetInstanceStatusStatisticRequest) SetProjectEnv(v string) *GetInstanceStatusStatisticRequest {
	s.ProjectEnv = &v
	return s
}

func (s *GetInstanceStatusStatisticRequest) SetProjectId(v int64) *GetInstanceStatusStatisticRequest {
	s.ProjectId = &v
	return s
}

func (s *GetInstanceStatusStatisticRequest) SetSchedulerPeriod(v string) *GetInstanceStatusStatisticRequest {
	s.SchedulerPeriod = &v
	return s
}

func (s *GetInstanceStatusStatisticRequest) SetSchedulerType(v string) *GetInstanceStatusStatisticRequest {
	s.SchedulerType = &v
	return s
}

type GetInstanceStatusStatisticResponseBody struct {
	// The ID of the request. You can use the ID to search for logs and troubleshoot issues based on the logs.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The numbers of instances in different states.
	StatusCount *GetInstanceStatusStatisticResponseBodyStatusCount `json:"StatusCount,omitempty" xml:"StatusCount,omitempty" type:"Struct"`
}

func (s GetInstanceStatusStatisticResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceStatusStatisticResponseBody) GoString() string {
	return s.String()
}

func (s *GetInstanceStatusStatisticResponseBody) SetRequestId(v string) *GetInstanceStatusStatisticResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetInstanceStatusStatisticResponseBody) SetStatusCount(v *GetInstanceStatusStatisticResponseBodyStatusCount) *GetInstanceStatusStatisticResponseBody {
	s.StatusCount = v
	return s
}

type GetInstanceStatusStatisticResponseBodyStatusCount struct {
	// The number of instances that failed to run.
	FailureCount *int32 `json:"FailureCount,omitempty" xml:"FailureCount,omitempty"`
	// The number of instances that are not run.
	NotRunCount *int32 `json:"NotRunCount,omitempty" xml:"NotRunCount,omitempty"`
	// The number of instances that are running.
	RunningCount *int32 `json:"RunningCount,omitempty" xml:"RunningCount,omitempty"`
	// The number of instances that are successfully run.
	SuccessCount *int32 `json:"SuccessCount,omitempty" xml:"SuccessCount,omitempty"`
	// The total number of instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
	// The number of instances that are waiting for resources.
	WaitResCount *int32 `json:"WaitResCount,omitempty" xml:"WaitResCount,omitempty"`
	// The number of instances that are waiting to run.
	WaitTimeCount *int32 `json:"WaitTimeCount,omitempty" xml:"WaitTimeCount,omitempty"`
}

func (s GetInstanceStatusStatisticResponseBodyStatusCount) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceStatusStatisticResponseBodyStatusCount) GoString() string {
	return s.String()
}

func (s *GetInstanceStatusStatisticResponseBodyStatusCount) SetFailureCount(v int32) *GetInstanceStatusStatisticResponseBodyStatusCount {
	s.FailureCount = &v
	return s
}

func (s *GetInstanceStatusStatisticResponseBodyStatusCount) SetNotRunCount(v int32) *GetInstanceStatusStatisticResponseBodyStatusCount {
	s.NotRunCount = &v
	return s
}

func (s *GetInstanceStatusStatisticResponseBodyStatusCount) SetRunningCount(v int32) *GetInstanceStatusStatisticResponseBodyStatusCount {
	s.RunningCount = &v
	return s
}

func (s *GetInstanceStatusStatisticResponseBodyStatusCount) SetSuccessCount(v int32) *GetInstanceStatusStatisticResponseBodyStatusCount {
	s.SuccessCount = &v
	return s
}

func (s *GetInstanceStatusStatisticResponseBodyStatusCount) SetTotalCount(v int32) *GetInstanceStatusStatisticResponseBodyStatusCount {
	s.TotalCount = &v
	return s
}

func (s *GetInstanceStatusStatisticResponseBodyStatusCount) SetWaitResCount(v int32) *GetInstanceStatusStatisticResponseBodyStatusCount {
	s.WaitResCount = &v
	return s
}

func (s *GetInstanceStatusStatisticResponseBodyStatusCount) SetWaitTimeCount(v int32) *GetInstanceStatusStatisticResponseBodyStatusCount {
	s.WaitTimeCount = &v
	return s
}

type GetInstanceStatusStatisticResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetInstanceStatusStatisticResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetInstanceStatusStatisticResponse) String() string {
	return tea.Prettify(s)
}

func (s GetInstanceStatusStatisticResponse) GoString() string {
	return s.String()
}

func (s *GetInstanceStatusStatisticResponse) SetHeaders(v map[string]*string) *GetInstanceStatusStatisticResponse {
	s.Headers = v
	return s
}

func (s *GetInstanceStatusStatisticResponse) SetStatusCode(v int32) *GetInstanceStatusStatisticResponse {
	s.StatusCode = &v
	return s
}

func (s *GetInstanceStatusStatisticResponse) SetBody(v *GetInstanceStatusStatisticResponseBody) *GetInstanceStatusStatisticResponse {
	s.Body = v
	return s
}

type GetManualDagInstancesRequest struct {
	DagId       *string `json:"DagId,omitempty" xml:"DagId,omitempty"`
	ProjectEnv  *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s GetManualDagInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s GetManualDagInstancesRequest) GoString() string {
	return s.String()
}

func (s *GetManualDagInstancesRequest) SetDagId(v string) *GetManualDagInstancesRequest {
	s.DagId = &v
	return s
}

func (s *GetManualDagInstancesRequest) SetProjectEnv(v string) *GetManualDagInstancesRequest {
	s.ProjectEnv = &v
	return s
}

func (s *GetManualDagInstancesRequest) SetProjectName(v string) *GetManualDagInstancesRequest {
	s.ProjectName = &v
	return s
}

type GetManualDagInstancesResponseBody struct {
	Instances []*GetManualDagInstancesResponseBodyInstances `json:"Instances,omitempty" xml:"Instances,omitempty" type:"Repeated"`
	RequestId *string                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetManualDagInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetManualDagInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *GetManualDagInstancesResponseBody) SetInstances(v []*GetManualDagInstancesResponseBodyInstances) *GetManualDagInstancesResponseBody {
	s.Instances = v
	return s
}

func (s *GetManualDagInstancesResponseBody) SetRequestId(v string) *GetManualDagInstancesResponseBody {
	s.RequestId = &v
	return s
}

type GetManualDagInstancesResponseBodyInstances struct {
	BeginRunningTime  *int64  `json:"BeginRunningTime,omitempty" xml:"BeginRunningTime,omitempty"`
	BeginWaitResTime  *int64  `json:"BeginWaitResTime,omitempty" xml:"BeginWaitResTime,omitempty"`
	BeginWaitTimeTime *int64  `json:"BeginWaitTimeTime,omitempty" xml:"BeginWaitTimeTime,omitempty"`
	BizDate           *int64  `json:"BizDate,omitempty" xml:"BizDate,omitempty"`
	CreateTime        *int64  `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	CreateUser        *string `json:"CreateUser,omitempty" xml:"CreateUser,omitempty"`
	CycTime           *int64  `json:"CycTime,omitempty" xml:"CycTime,omitempty"`
	DagId             *int64  `json:"DagId,omitempty" xml:"DagId,omitempty"`
	DagType           *string `json:"DagType,omitempty" xml:"DagType,omitempty"`
	FinishTime        *int64  `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	InstanceId        *int64  `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	ModifyTime        *int64  `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	NodeId            *int64  `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	NodeName          *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	ParamValues       *string `json:"ParamValues,omitempty" xml:"ParamValues,omitempty"`
	Status            *string `json:"Status,omitempty" xml:"Status,omitempty"`
	TaskType          *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s GetManualDagInstancesResponseBodyInstances) String() string {
	return tea.Prettify(s)
}

func (s GetManualDagInstancesResponseBodyInstances) GoString() string {
	return s.String()
}

func (s *GetManualDagInstancesResponseBodyInstances) SetBeginRunningTime(v int64) *GetManualDagInstancesResponseBodyInstances {
	s.BeginRunningTime = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetBeginWaitResTime(v int64) *GetManualDagInstancesResponseBodyInstances {
	s.BeginWaitResTime = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetBeginWaitTimeTime(v int64) *GetManualDagInstancesResponseBodyInstances {
	s.BeginWaitTimeTime = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetBizDate(v int64) *GetManualDagInstancesResponseBodyInstances {
	s.BizDate = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetCreateTime(v int64) *GetManualDagInstancesResponseBodyInstances {
	s.CreateTime = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetCreateUser(v string) *GetManualDagInstancesResponseBodyInstances {
	s.CreateUser = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetCycTime(v int64) *GetManualDagInstancesResponseBodyInstances {
	s.CycTime = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetDagId(v int64) *GetManualDagInstancesResponseBodyInstances {
	s.DagId = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetDagType(v string) *GetManualDagInstancesResponseBodyInstances {
	s.DagType = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetFinishTime(v int64) *GetManualDagInstancesResponseBodyInstances {
	s.FinishTime = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetInstanceId(v int64) *GetManualDagInstancesResponseBodyInstances {
	s.InstanceId = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetModifyTime(v int64) *GetManualDagInstancesResponseBodyInstances {
	s.ModifyTime = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetNodeId(v int64) *GetManualDagInstancesResponseBodyInstances {
	s.NodeId = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetNodeName(v string) *GetManualDagInstancesResponseBodyInstances {
	s.NodeName = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetParamValues(v string) *GetManualDagInstancesResponseBodyInstances {
	s.ParamValues = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetStatus(v string) *GetManualDagInstancesResponseBodyInstances {
	s.Status = &v
	return s
}

func (s *GetManualDagInstancesResponseBodyInstances) SetTaskType(v string) *GetManualDagInstancesResponseBodyInstances {
	s.TaskType = &v
	return s
}

type GetManualDagInstancesResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetManualDagInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetManualDagInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s GetManualDagInstancesResponse) GoString() string {
	return s.String()
}

func (s *GetManualDagInstancesResponse) SetHeaders(v map[string]*string) *GetManualDagInstancesResponse {
	s.Headers = v
	return s
}

func (s *GetManualDagInstancesResponse) SetStatusCode(v int32) *GetManualDagInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *GetManualDagInstancesResponse) SetBody(v *GetManualDagInstancesResponseBody) *GetManualDagInstancesResponse {
	s.Body = v
	return s
}

type GetMetaCategoryRequest struct {
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the category tree.
	ParentCategoryId *int64 `json:"ParentCategoryId,omitempty" xml:"ParentCategoryId,omitempty"`
}

func (s GetMetaCategoryRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaCategoryRequest) GoString() string {
	return s.String()
}

func (s *GetMetaCategoryRequest) SetPageNum(v int32) *GetMetaCategoryRequest {
	s.PageNum = &v
	return s
}

func (s *GetMetaCategoryRequest) SetPageSize(v int32) *GetMetaCategoryRequest {
	s.PageSize = &v
	return s
}

func (s *GetMetaCategoryRequest) SetParentCategoryId(v int64) *GetMetaCategoryRequest {
	s.ParentCategoryId = &v
	return s
}

type GetMetaCategoryResponseBody struct {
	// The returned result.
	Data *GetMetaCategoryResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaCategoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaCategoryResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaCategoryResponseBody) SetData(v *GetMetaCategoryResponseBodyData) *GetMetaCategoryResponseBody {
	s.Data = v
	return s
}

func (s *GetMetaCategoryResponseBody) SetErrorCode(v string) *GetMetaCategoryResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaCategoryResponseBody) SetErrorMessage(v string) *GetMetaCategoryResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaCategoryResponseBody) SetHttpStatusCode(v int32) *GetMetaCategoryResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMetaCategoryResponseBody) SetRequestId(v string) *GetMetaCategoryResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaCategoryResponseBody) SetSuccess(v bool) *GetMetaCategoryResponseBody {
	s.Success = &v
	return s
}

type GetMetaCategoryResponseBodyData struct {
	// The information about the category tree.
	DataEntityList []*GetMetaCategoryResponseBodyDataDataEntityList `json:"DataEntityList,omitempty" xml:"DataEntityList,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of categories.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetMetaCategoryResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMetaCategoryResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMetaCategoryResponseBodyData) SetDataEntityList(v []*GetMetaCategoryResponseBodyDataDataEntityList) *GetMetaCategoryResponseBodyData {
	s.DataEntityList = v
	return s
}

func (s *GetMetaCategoryResponseBodyData) SetPageNum(v int32) *GetMetaCategoryResponseBodyData {
	s.PageNum = &v
	return s
}

func (s *GetMetaCategoryResponseBodyData) SetPageSize(v int32) *GetMetaCategoryResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetMetaCategoryResponseBodyData) SetTotalCount(v int64) *GetMetaCategoryResponseBodyData {
	s.TotalCount = &v
	return s
}

type GetMetaCategoryResponseBodyDataDataEntityList struct {
	// The ID of the category.
	CategoryId *int64 `json:"CategoryId,omitempty" xml:"CategoryId,omitempty"`
	// The remarks of the category.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The time when the category was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The number of category levels.
	Depth *int32 `json:"Depth,omitempty" xml:"Depth,omitempty"`
	// The ID of the user that performed the last operation.
	LastOperatorId *string `json:"LastOperatorId,omitempty" xml:"LastOperatorId,omitempty"`
	// The time when the category was last modified.
	ModifiedTime *int64 `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The name of the category.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the category owner.
	OwnerId *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the parent category.
	ParentCategoryId *int64 `json:"ParentCategoryId,omitempty" xml:"ParentCategoryId,omitempty"`
}

func (s GetMetaCategoryResponseBodyDataDataEntityList) String() string {
	return tea.Prettify(s)
}

func (s GetMetaCategoryResponseBodyDataDataEntityList) GoString() string {
	return s.String()
}

func (s *GetMetaCategoryResponseBodyDataDataEntityList) SetCategoryId(v int64) *GetMetaCategoryResponseBodyDataDataEntityList {
	s.CategoryId = &v
	return s
}

func (s *GetMetaCategoryResponseBodyDataDataEntityList) SetComment(v string) *GetMetaCategoryResponseBodyDataDataEntityList {
	s.Comment = &v
	return s
}

func (s *GetMetaCategoryResponseBodyDataDataEntityList) SetCreateTime(v int64) *GetMetaCategoryResponseBodyDataDataEntityList {
	s.CreateTime = &v
	return s
}

func (s *GetMetaCategoryResponseBodyDataDataEntityList) SetDepth(v int32) *GetMetaCategoryResponseBodyDataDataEntityList {
	s.Depth = &v
	return s
}

func (s *GetMetaCategoryResponseBodyDataDataEntityList) SetLastOperatorId(v string) *GetMetaCategoryResponseBodyDataDataEntityList {
	s.LastOperatorId = &v
	return s
}

func (s *GetMetaCategoryResponseBodyDataDataEntityList) SetModifiedTime(v int64) *GetMetaCategoryResponseBodyDataDataEntityList {
	s.ModifiedTime = &v
	return s
}

func (s *GetMetaCategoryResponseBodyDataDataEntityList) SetName(v string) *GetMetaCategoryResponseBodyDataDataEntityList {
	s.Name = &v
	return s
}

func (s *GetMetaCategoryResponseBodyDataDataEntityList) SetOwnerId(v string) *GetMetaCategoryResponseBodyDataDataEntityList {
	s.OwnerId = &v
	return s
}

func (s *GetMetaCategoryResponseBodyDataDataEntityList) SetParentCategoryId(v int64) *GetMetaCategoryResponseBodyDataDataEntityList {
	s.ParentCategoryId = &v
	return s
}

type GetMetaCategoryResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaCategoryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaCategoryResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaCategoryResponse) GoString() string {
	return s.String()
}

func (s *GetMetaCategoryResponse) SetHeaders(v map[string]*string) *GetMetaCategoryResponse {
	s.Headers = v
	return s
}

func (s *GetMetaCategoryResponse) SetStatusCode(v int32) *GetMetaCategoryResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaCategoryResponse) SetBody(v *GetMetaCategoryResponseBody) *GetMetaCategoryResponse {
	s.Body = v
	return s
}

type GetMetaCollectionDetailRequest struct {
	// The unique identifier of the collection.
	QualifiedName *string `json:"QualifiedName,omitempty" xml:"QualifiedName,omitempty"`
}

func (s GetMetaCollectionDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaCollectionDetailRequest) GoString() string {
	return s.String()
}

func (s *GetMetaCollectionDetailRequest) SetQualifiedName(v string) *GetMetaCollectionDetailRequest {
	s.QualifiedName = &v
	return s
}

type GetMetaCollectionDetailResponseBody struct {
	// The collection.
	Collection *Collection `json:"Collection,omitempty" xml:"Collection,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// true: The request was successful.
	//
	// false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaCollectionDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaCollectionDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaCollectionDetailResponseBody) SetCollection(v *Collection) *GetMetaCollectionDetailResponseBody {
	s.Collection = v
	return s
}

func (s *GetMetaCollectionDetailResponseBody) SetErrorCode(v string) *GetMetaCollectionDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaCollectionDetailResponseBody) SetErrorMessage(v string) *GetMetaCollectionDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaCollectionDetailResponseBody) SetHttpStatusCode(v int32) *GetMetaCollectionDetailResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMetaCollectionDetailResponseBody) SetRequestId(v string) *GetMetaCollectionDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaCollectionDetailResponseBody) SetSuccess(v bool) *GetMetaCollectionDetailResponseBody {
	s.Success = &v
	return s
}

type GetMetaCollectionDetailResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaCollectionDetailResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaCollectionDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaCollectionDetailResponse) GoString() string {
	return s.String()
}

func (s *GetMetaCollectionDetailResponse) SetHeaders(v map[string]*string) *GetMetaCollectionDetailResponse {
	s.Headers = v
	return s
}

func (s *GetMetaCollectionDetailResponse) SetStatusCode(v int32) *GetMetaCollectionDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaCollectionDetailResponse) SetBody(v *GetMetaCollectionDetailResponseBody) *GetMetaCollectionDetailResponse {
	s.Body = v
	return s
}

type GetMetaColumnLineageRequest struct {
	// The ID of the E-MapReduce (EMR) cluster. Configure this parameter only when you query data in an EMR compute engine instance.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The GUID of the field.
	ColumnGuid *string `json:"ColumnGuid,omitempty" xml:"ColumnGuid,omitempty"`
	// The name of the field.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The type of the data source. Valid values: odps and emr.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The name of the database.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// Specifies whether to query the ancestor or descendant lineage of the field. The value up indicates the ancestor lineage. The value down indicates the descendant lineage.
	Direction *string `json:"Direction,omitempty" xml:"Direction,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The name of the metatable.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetMetaColumnLineageRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaColumnLineageRequest) GoString() string {
	return s.String()
}

func (s *GetMetaColumnLineageRequest) SetClusterId(v string) *GetMetaColumnLineageRequest {
	s.ClusterId = &v
	return s
}

func (s *GetMetaColumnLineageRequest) SetColumnGuid(v string) *GetMetaColumnLineageRequest {
	s.ColumnGuid = &v
	return s
}

func (s *GetMetaColumnLineageRequest) SetColumnName(v string) *GetMetaColumnLineageRequest {
	s.ColumnName = &v
	return s
}

func (s *GetMetaColumnLineageRequest) SetDataSourceType(v string) *GetMetaColumnLineageRequest {
	s.DataSourceType = &v
	return s
}

func (s *GetMetaColumnLineageRequest) SetDatabaseName(v string) *GetMetaColumnLineageRequest {
	s.DatabaseName = &v
	return s
}

func (s *GetMetaColumnLineageRequest) SetDirection(v string) *GetMetaColumnLineageRequest {
	s.Direction = &v
	return s
}

func (s *GetMetaColumnLineageRequest) SetPageNum(v int32) *GetMetaColumnLineageRequest {
	s.PageNum = &v
	return s
}

func (s *GetMetaColumnLineageRequest) SetPageSize(v int32) *GetMetaColumnLineageRequest {
	s.PageSize = &v
	return s
}

func (s *GetMetaColumnLineageRequest) SetTableName(v string) *GetMetaColumnLineageRequest {
	s.TableName = &v
	return s
}

type GetMetaColumnLineageResponseBody struct {
	// The business data returned.
	Data *GetMetaColumnLineageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaColumnLineageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaColumnLineageResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaColumnLineageResponseBody) SetData(v *GetMetaColumnLineageResponseBodyData) *GetMetaColumnLineageResponseBody {
	s.Data = v
	return s
}

func (s *GetMetaColumnLineageResponseBody) SetErrorCode(v string) *GetMetaColumnLineageResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaColumnLineageResponseBody) SetErrorMessage(v string) *GetMetaColumnLineageResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaColumnLineageResponseBody) SetHttpStatusCode(v int32) *GetMetaColumnLineageResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMetaColumnLineageResponseBody) SetRequestId(v string) *GetMetaColumnLineageResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaColumnLineageResponseBody) SetSuccess(v bool) *GetMetaColumnLineageResponseBody {
	s.Success = &v
	return s
}

type GetMetaColumnLineageResponseBodyData struct {
	// The list of metatables in the compute engine instance.
	DataEntityList []*GetMetaColumnLineageResponseBodyDataDataEntityList `json:"DataEntityList,omitempty" xml:"DataEntityList,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of fields.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetMetaColumnLineageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMetaColumnLineageResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMetaColumnLineageResponseBodyData) SetDataEntityList(v []*GetMetaColumnLineageResponseBodyDataDataEntityList) *GetMetaColumnLineageResponseBodyData {
	s.DataEntityList = v
	return s
}

func (s *GetMetaColumnLineageResponseBodyData) SetPageNum(v int32) *GetMetaColumnLineageResponseBodyData {
	s.PageNum = &v
	return s
}

func (s *GetMetaColumnLineageResponseBodyData) SetPageSize(v int32) *GetMetaColumnLineageResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetMetaColumnLineageResponseBodyData) SetTotalCount(v int64) *GetMetaColumnLineageResponseBodyData {
	s.TotalCount = &v
	return s
}

type GetMetaColumnLineageResponseBodyDataDataEntityList struct {
	// The ID of the EMR cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The GUID of the field.
	ColumnGuid *string `json:"ColumnGuid,omitempty" xml:"ColumnGuid,omitempty"`
	// The name of the field.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The name of the database.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// The name of the metatable.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetMetaColumnLineageResponseBodyDataDataEntityList) String() string {
	return tea.Prettify(s)
}

func (s GetMetaColumnLineageResponseBodyDataDataEntityList) GoString() string {
	return s.String()
}

func (s *GetMetaColumnLineageResponseBodyDataDataEntityList) SetClusterId(v string) *GetMetaColumnLineageResponseBodyDataDataEntityList {
	s.ClusterId = &v
	return s
}

func (s *GetMetaColumnLineageResponseBodyDataDataEntityList) SetColumnGuid(v string) *GetMetaColumnLineageResponseBodyDataDataEntityList {
	s.ColumnGuid = &v
	return s
}

func (s *GetMetaColumnLineageResponseBodyDataDataEntityList) SetColumnName(v string) *GetMetaColumnLineageResponseBodyDataDataEntityList {
	s.ColumnName = &v
	return s
}

func (s *GetMetaColumnLineageResponseBodyDataDataEntityList) SetDatabaseName(v string) *GetMetaColumnLineageResponseBodyDataDataEntityList {
	s.DatabaseName = &v
	return s
}

func (s *GetMetaColumnLineageResponseBodyDataDataEntityList) SetTableName(v string) *GetMetaColumnLineageResponseBodyDataDataEntityList {
	s.TableName = &v
	return s
}

type GetMetaColumnLineageResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaColumnLineageResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaColumnLineageResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaColumnLineageResponse) GoString() string {
	return s.String()
}

func (s *GetMetaColumnLineageResponse) SetHeaders(v map[string]*string) *GetMetaColumnLineageResponse {
	s.Headers = v
	return s
}

func (s *GetMetaColumnLineageResponse) SetStatusCode(v int32) *GetMetaColumnLineageResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaColumnLineageResponse) SetBody(v *GetMetaColumnLineageResponseBody) *GetMetaColumnLineageResponse {
	s.Body = v
	return s
}

type GetMetaDBInfoRequest struct {
	// The ID of the request.
	AppGuid *string `json:"AppGuid,omitempty" xml:"AppGuid,omitempty"`
	// The business data returned.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The comment.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The type of the metadatabase. Only hive is supported.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
}

func (s GetMetaDBInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaDBInfoRequest) GoString() string {
	return s.String()
}

func (s *GetMetaDBInfoRequest) SetAppGuid(v string) *GetMetaDBInfoRequest {
	s.AppGuid = &v
	return s
}

func (s *GetMetaDBInfoRequest) SetClusterId(v string) *GetMetaDBInfoRequest {
	s.ClusterId = &v
	return s
}

func (s *GetMetaDBInfoRequest) SetDataSourceType(v string) *GetMetaDBInfoRequest {
	s.DataSourceType = &v
	return s
}

func (s *GetMetaDBInfoRequest) SetDatabaseName(v string) *GetMetaDBInfoRequest {
	s.DatabaseName = &v
	return s
}

type GetMetaDBInfoResponseBody struct {
	// The time when the compute engine instance was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	Data *GetMetaDBInfoResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// test table
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMetaDBInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaDBInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaDBInfoResponseBody) SetData(v *GetMetaDBInfoResponseBodyData) *GetMetaDBInfoResponseBody {
	s.Data = v
	return s
}

func (s *GetMetaDBInfoResponseBody) SetRequestId(v string) *GetMetaDBInfoResponseBody {
	s.RequestId = &v
	return s
}

type GetMetaDBInfoResponseBodyData struct {
	// The display name of the workspace.
	AppGuid *string `json:"AppGuid,omitempty" xml:"AppGuid,omitempty"`
	// The time when the compute engine instance was modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	ClusterBizId *string `json:"ClusterBizId,omitempty" xml:"ClusterBizId,omitempty"`
	// The name of the workspace.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The name of the workspace owner.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the tenant.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The ID of the EMR cluster. This parameter is returned only for an EMR compute engine instance.
	EnvType    *int32  `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	Location   *string `json:"Location,omitempty" xml:"Location,omitempty"`
	ModifyTime *int64  `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	Name       *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The endpoint of the service.
	OwnerId *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Test items
	OwnerName *string `json:"OwnerName,omitempty" xml:"OwnerName,omitempty"`
	// The ID of the Alibaba Cloud account used by the workspace owner.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The type of the environment. Valid values: 0 and 1. The value 0 indicates the development environment. The value 1 indicates the production environment.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The name of the metadatabase.
	ProjectNameCn *string `json:"ProjectNameCn,omitempty" xml:"ProjectNameCn,omitempty"`
	TenantId      *int64  `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	// The ID of the workspace.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetMetaDBInfoResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMetaDBInfoResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMetaDBInfoResponseBodyData) SetAppGuid(v string) *GetMetaDBInfoResponseBodyData {
	s.AppGuid = &v
	return s
}

func (s *GetMetaDBInfoResponseBodyData) SetClusterBizId(v string) *GetMetaDBInfoResponseBodyData {
	s.ClusterBizId = &v
	return s
}

func (s *GetMetaDBInfoResponseBodyData) SetComment(v string) *GetMetaDBInfoResponseBodyData {
	s.Comment = &v
	return s
}

func (s *GetMetaDBInfoResponseBodyData) SetCreateTime(v int64) *GetMetaDBInfoResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *GetMetaDBInfoResponseBodyData) SetEndpoint(v string) *GetMetaDBInfoResponseBodyData {
	s.Endpoint = &v
	return s
}

func (s *GetMetaDBInfoResponseBodyData) SetEnvType(v int32) *GetMetaDBInfoResponseBodyData {
	s.EnvType = &v
	return s
}

func (s *GetMetaDBInfoResponseBodyData) SetLocation(v string) *GetMetaDBInfoResponseBodyData {
	s.Location = &v
	return s
}

func (s *GetMetaDBInfoResponseBodyData) SetModifyTime(v int64) *GetMetaDBInfoResponseBodyData {
	s.ModifyTime = &v
	return s
}

func (s *GetMetaDBInfoResponseBodyData) SetName(v string) *GetMetaDBInfoResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetMetaDBInfoResponseBodyData) SetOwnerId(v string) *GetMetaDBInfoResponseBodyData {
	s.OwnerId = &v
	return s
}

func (s *GetMetaDBInfoResponseBodyData) SetOwnerName(v string) *GetMetaDBInfoResponseBodyData {
	s.OwnerName = &v
	return s
}

func (s *GetMetaDBInfoResponseBodyData) SetProjectId(v int64) *GetMetaDBInfoResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetMetaDBInfoResponseBodyData) SetProjectName(v string) *GetMetaDBInfoResponseBodyData {
	s.ProjectName = &v
	return s
}

func (s *GetMetaDBInfoResponseBodyData) SetProjectNameCn(v string) *GetMetaDBInfoResponseBodyData {
	s.ProjectNameCn = &v
	return s
}

func (s *GetMetaDBInfoResponseBodyData) SetTenantId(v int64) *GetMetaDBInfoResponseBodyData {
	s.TenantId = &v
	return s
}

func (s *GetMetaDBInfoResponseBodyData) SetType(v string) *GetMetaDBInfoResponseBodyData {
	s.Type = &v
	return s
}

type GetMetaDBInfoResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaDBInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaDBInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaDBInfoResponse) GoString() string {
	return s.String()
}

func (s *GetMetaDBInfoResponse) SetHeaders(v map[string]*string) *GetMetaDBInfoResponse {
	s.Headers = v
	return s
}

func (s *GetMetaDBInfoResponse) SetStatusCode(v int32) *GetMetaDBInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaDBInfoResponse) SetBody(v *GetMetaDBInfoResponseBody) *GetMetaDBInfoResponse {
	s.Body = v
	return s
}

type GetMetaDBTableListRequest struct {
	// The name of the metadatabase.
	AppGuid *string `json:"AppGuid,omitempty" xml:"AppGuid,omitempty"`
	// The type of the data source. Valid values: odps and emr.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The business data.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The ID of the request.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// The globally unique identifier (GUID) of the MaxCompute project. Specify the GUID in the `odps.{projectName}` format. This parameter must be configured if you set the DataSourceType parameter to odps.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the E-MapReduce (EMR) cluster. This parameter must be configured if you set the DataSourceType parameter to emr.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s GetMetaDBTableListRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaDBTableListRequest) GoString() string {
	return s.String()
}

func (s *GetMetaDBTableListRequest) SetAppGuid(v string) *GetMetaDBTableListRequest {
	s.AppGuid = &v
	return s
}

func (s *GetMetaDBTableListRequest) SetClusterId(v string) *GetMetaDBTableListRequest {
	s.ClusterId = &v
	return s
}

func (s *GetMetaDBTableListRequest) SetDataSourceType(v string) *GetMetaDBTableListRequest {
	s.DataSourceType = &v
	return s
}

func (s *GetMetaDBTableListRequest) SetDatabaseName(v string) *GetMetaDBTableListRequest {
	s.DatabaseName = &v
	return s
}

func (s *GetMetaDBTableListRequest) SetPageNumber(v int32) *GetMetaDBTableListRequest {
	s.PageNumber = &v
	return s
}

func (s *GetMetaDBTableListRequest) SetPageSize(v int32) *GetMetaDBTableListRequest {
	s.PageSize = &v
	return s
}

type GetMetaDBTableListResponseBody struct {
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	Data *GetMetaDBTableListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The page number of the returned page.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetMetaDBTableListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaDBTableListResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaDBTableListResponseBody) SetData(v *GetMetaDBTableListResponseBodyData) *GetMetaDBTableListResponseBody {
	s.Data = v
	return s
}

func (s *GetMetaDBTableListResponseBody) SetRequestId(v string) *GetMetaDBTableListResponseBody {
	s.RequestId = &v
	return s
}

type GetMetaDBTableListResponseBodyData struct {
	// The total number of compute engine instances.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The list of metatables in the compute engine instance.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The GUID of the metatable.
	TableEntityList []*GetMetaDBTableListResponseBodyDataTableEntityList `json:"TableEntityList,omitempty" xml:"TableEntityList,omitempty" type:"Repeated"`
	// The name of the metatable.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetMetaDBTableListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMetaDBTableListResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMetaDBTableListResponseBodyData) SetPageNumber(v int32) *GetMetaDBTableListResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *GetMetaDBTableListResponseBodyData) SetPageSize(v int32) *GetMetaDBTableListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetMetaDBTableListResponseBodyData) SetTableEntityList(v []*GetMetaDBTableListResponseBodyDataTableEntityList) *GetMetaDBTableListResponseBodyData {
	s.TableEntityList = v
	return s
}

func (s *GetMetaDBTableListResponseBodyData) SetTotalCount(v int64) *GetMetaDBTableListResponseBodyData {
	s.TotalCount = &v
	return s
}

type GetMetaDBTableListResponseBodyDataTableEntityList struct {
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	TableGuid    *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The name of the metadatabase.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetMetaDBTableListResponseBodyDataTableEntityList) String() string {
	return tea.Prettify(s)
}

func (s GetMetaDBTableListResponseBodyDataTableEntityList) GoString() string {
	return s.String()
}

func (s *GetMetaDBTableListResponseBodyDataTableEntityList) SetDatabaseName(v string) *GetMetaDBTableListResponseBodyDataTableEntityList {
	s.DatabaseName = &v
	return s
}

func (s *GetMetaDBTableListResponseBodyDataTableEntityList) SetTableGuid(v string) *GetMetaDBTableListResponseBodyDataTableEntityList {
	s.TableGuid = &v
	return s
}

func (s *GetMetaDBTableListResponseBodyDataTableEntityList) SetTableName(v string) *GetMetaDBTableListResponseBodyDataTableEntityList {
	s.TableName = &v
	return s
}

type GetMetaDBTableListResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaDBTableListResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaDBTableListResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaDBTableListResponse) GoString() string {
	return s.String()
}

func (s *GetMetaDBTableListResponse) SetHeaders(v map[string]*string) *GetMetaDBTableListResponse {
	s.Headers = v
	return s
}

func (s *GetMetaDBTableListResponse) SetStatusCode(v int32) *GetMetaDBTableListResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaDBTableListResponse) SetBody(v *GetMetaDBTableListResponseBody) *GetMetaDBTableListResponse {
	s.Body = v
	return s
}

type GetMetaTableBasicInfoRequest struct {
	// The name of the metatable in the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
	//
	// You can call the [GetMetaDBTableList](~~173916~~) operation to query the name of the metatable.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The HTTP status code returned.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The type of the data source. Valid values: odps and emr.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// The error message returned.
	Extension *bool `json:"Extension,omitempty" xml:"Extension,omitempty"`
	// The name of the metadatabase. This parameter is required only if you set the DataSourceType parameter to emr.
	//
	// You can call the [ListMetaDB](~~185662~~) operation to query the name of the metadatabase.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// Specifies whether to include extended fields in query results.
	//
	// The extended fields include ReadCount, FavoriteCount, and ViewCount.
	//
	// This parameter takes effect only if you set the DataSourceType parameter to odps.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetMetaTableBasicInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableBasicInfoRequest) GoString() string {
	return s.String()
}

func (s *GetMetaTableBasicInfoRequest) SetClusterId(v string) *GetMetaTableBasicInfoRequest {
	s.ClusterId = &v
	return s
}

func (s *GetMetaTableBasicInfoRequest) SetDataSourceType(v string) *GetMetaTableBasicInfoRequest {
	s.DataSourceType = &v
	return s
}

func (s *GetMetaTableBasicInfoRequest) SetDatabaseName(v string) *GetMetaTableBasicInfoRequest {
	s.DatabaseName = &v
	return s
}

func (s *GetMetaTableBasicInfoRequest) SetExtension(v bool) *GetMetaTableBasicInfoRequest {
	s.Extension = &v
	return s
}

func (s *GetMetaTableBasicInfoRequest) SetTableGuid(v string) *GetMetaTableBasicInfoRequest {
	s.TableGuid = &v
	return s
}

func (s *GetMetaTableBasicInfoRequest) SetTableName(v string) *GetMetaTableBasicInfoRequest {
	s.TableName = &v
	return s
}

type GetMetaTableBasicInfoResponseBody struct {
	// The number of times the metatable was added to a favorite list. This parameter is returned only if you set the Extension parameter to true and takes effect only if you set the DataSourceType parameter to odps.
	Data *GetMetaTableBasicInfoResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The name of the metatable.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error code returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The business data returned.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaTableBasicInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableBasicInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaTableBasicInfoResponseBody) SetData(v *GetMetaTableBasicInfoResponseBodyData) *GetMetaTableBasicInfoResponseBody {
	s.Data = v
	return s
}

func (s *GetMetaTableBasicInfoResponseBody) SetErrorCode(v string) *GetMetaTableBasicInfoResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBody) SetErrorMessage(v string) *GetMetaTableBasicInfoResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBody) SetHttpStatusCode(v int32) *GetMetaTableBasicInfoResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBody) SetRequestId(v string) *GetMetaTableBasicInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBody) SetSuccess(v bool) *GetMetaTableBasicInfoResponseBody {
	s.Success = &v
	return s
}

type GetMetaTableBasicInfoResponseBodyData struct {
	// The schema information of the metatable. This parameter is returned only if you enable the table schema in MaxCompute.
	Caption *string `json:"Caption,omitempty" xml:"Caption,omitempty"`
	// Indicates whether the metatable is a view. Valid values:
	//
	// *   true: The metatable is a view.
	// *   false: The metatable is not a view.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The ID of the workspace.
	ColumnCount *int32 `json:"ColumnCount,omitempty" xml:"ColumnCount,omitempty"`
	// The time when the metatable was created.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ID of the metatable owner.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The time when the schema of the metatable was last changed.
	DataSize *int64 `json:"DataSize,omitempty" xml:"DataSize,omitempty"`
	// The GUID of the metatable.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// The scope in which the metatable is visible. Valid values:
	//
	// *   0: The metatable is visible to workspace members.
	// *   1: The metatable is visible to users within the tenant.
	// *   2: The metatable is visible to all tenants.
	// *   3: The metatable is visible only to the metatable owner.
	EnvType *int32 `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The number of fields.
	FavoriteCount *int64 `json:"FavoriteCount,omitempty" xml:"FavoriteCount,omitempty"`
	// The lifecycle of the metatable. Unit: days.
	IsPartitionTable *bool `json:"IsPartitionTable,omitempty" xml:"IsPartitionTable,omitempty"`
	// The name of the workspace.
	IsView *bool `json:"IsView,omitempty" xml:"IsView,omitempty"`
	// The number of times the metatable was read. This parameter is returned only if you set the Extension parameter to true and takes effect only if you set the DataSourceType parameter to odps.
	IsVisible *int32 `json:"IsVisible,omitempty" xml:"IsVisible,omitempty"`
	// The time when the metatable was last updated.
	LastAccessTime *int64 `json:"LastAccessTime,omitempty" xml:"LastAccessTime,omitempty"`
	// The storage path of the Hive metadatabase.
	LastDdlTime *int64 `json:"LastDdlTime,omitempty" xml:"LastDdlTime,omitempty"`
	// The partition key of the Hive metatable.
	LastModifyTime *int64 `json:"LastModifyTime,omitempty" xml:"LastModifyTime,omitempty"`
	// The number of times the metatable was viewed. This parameter is returned only if you set the Extension parameter to true and takes effect only if you set the DataSourceType parameter to odps.
	LifeCycle *int32 `json:"LifeCycle,omitempty" xml:"LifeCycle,omitempty"`
	// The ID of the tenant.
	Location *string `json:"Location,omitempty" xml:"Location,omitempty"`
	// The name of the metadatabase.
	OwnerId *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The display name of the metatable.
	PartitionKeys *string `json:"PartitionKeys,omitempty" xml:"PartitionKeys,omitempty"`
	// The type of the environment. Valid values:
	//
	// *   0: development environment
	// *   1: production environment
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The time when the metatable was last accessed.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// Indicates whether the metatable is a partitioned table. Valid values:
	//
	// *   true: The metatable is a partitioned table.
	// *   false: The metatable is a non-partitioned table.
	ReadCount *int64  `json:"ReadCount,omitempty" xml:"ReadCount,omitempty"`
	Schema    *string `json:"Schema,omitempty" xml:"Schema,omitempty"`
	// The ID of the EMR cluster.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The comment of the metatable.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	TenantId  *int64  `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	// The size of storage space that is occupied by the metatable. Unit: bytes.
	ViewCount *int64 `json:"ViewCount,omitempty" xml:"ViewCount,omitempty"`
}

func (s GetMetaTableBasicInfoResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableBasicInfoResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetCaption(v string) *GetMetaTableBasicInfoResponseBodyData {
	s.Caption = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetClusterId(v string) *GetMetaTableBasicInfoResponseBodyData {
	s.ClusterId = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetColumnCount(v int32) *GetMetaTableBasicInfoResponseBodyData {
	s.ColumnCount = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetComment(v string) *GetMetaTableBasicInfoResponseBodyData {
	s.Comment = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetCreateTime(v int64) *GetMetaTableBasicInfoResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetDataSize(v int64) *GetMetaTableBasicInfoResponseBodyData {
	s.DataSize = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetDatabaseName(v string) *GetMetaTableBasicInfoResponseBodyData {
	s.DatabaseName = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetEnvType(v int32) *GetMetaTableBasicInfoResponseBodyData {
	s.EnvType = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetFavoriteCount(v int64) *GetMetaTableBasicInfoResponseBodyData {
	s.FavoriteCount = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetIsPartitionTable(v bool) *GetMetaTableBasicInfoResponseBodyData {
	s.IsPartitionTable = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetIsView(v bool) *GetMetaTableBasicInfoResponseBodyData {
	s.IsView = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetIsVisible(v int32) *GetMetaTableBasicInfoResponseBodyData {
	s.IsVisible = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetLastAccessTime(v int64) *GetMetaTableBasicInfoResponseBodyData {
	s.LastAccessTime = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetLastDdlTime(v int64) *GetMetaTableBasicInfoResponseBodyData {
	s.LastDdlTime = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetLastModifyTime(v int64) *GetMetaTableBasicInfoResponseBodyData {
	s.LastModifyTime = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetLifeCycle(v int32) *GetMetaTableBasicInfoResponseBodyData {
	s.LifeCycle = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetLocation(v string) *GetMetaTableBasicInfoResponseBodyData {
	s.Location = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetOwnerId(v string) *GetMetaTableBasicInfoResponseBodyData {
	s.OwnerId = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetPartitionKeys(v string) *GetMetaTableBasicInfoResponseBodyData {
	s.PartitionKeys = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetProjectId(v int64) *GetMetaTableBasicInfoResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetProjectName(v string) *GetMetaTableBasicInfoResponseBodyData {
	s.ProjectName = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetReadCount(v int64) *GetMetaTableBasicInfoResponseBodyData {
	s.ReadCount = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetSchema(v string) *GetMetaTableBasicInfoResponseBodyData {
	s.Schema = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetTableGuid(v string) *GetMetaTableBasicInfoResponseBodyData {
	s.TableGuid = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetTableName(v string) *GetMetaTableBasicInfoResponseBodyData {
	s.TableName = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetTenantId(v int64) *GetMetaTableBasicInfoResponseBodyData {
	s.TenantId = &v
	return s
}

func (s *GetMetaTableBasicInfoResponseBodyData) SetViewCount(v int64) *GetMetaTableBasicInfoResponseBodyData {
	s.ViewCount = &v
	return s
}

type GetMetaTableBasicInfoResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaTableBasicInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaTableBasicInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableBasicInfoResponse) GoString() string {
	return s.String()
}

func (s *GetMetaTableBasicInfoResponse) SetHeaders(v map[string]*string) *GetMetaTableBasicInfoResponse {
	s.Headers = v
	return s
}

func (s *GetMetaTableBasicInfoResponse) SetStatusCode(v int32) *GetMetaTableBasicInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaTableBasicInfoResponse) SetBody(v *GetMetaTableBasicInfoResponseBody) *GetMetaTableBasicInfoResponse {
	s.Body = v
	return s
}

type GetMetaTableChangeLogRequest struct {
	// The beginning of the time range to query. Specify the time in the yyyy-MM-dd HH:mm:ss format.
	//
	// *   By default, the system uses the current time as the value of this parameter if the time that you specify is invalid.
	// *   If both the values of the StartDate and EndDate parameters are invalid, the system automatically queries the change logs that are generated within the last 30 days.
	ChangeType *string `json:"ChangeType,omitempty" xml:"ChangeType,omitempty"`
	// The error message returned.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The end of the time range to query. Specify the time in the yyyy-MM-dd HH:mm:ss format.
	//
	// *   By default, the system uses the current time as the value of this parameter if the time that you specify is invalid.
	// *   If both the values of the StartDate and EndDate parameters are invalid, the system automatically queries the change logs that are generated within the last 30 days.
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	// The globally unique identifier (GUID) of the table. Specify the GUID in the format of odps.projectName.tableName. You can call the [GetMetaDBTableList](~~173916~~) operation to query the GUID of the table.
	//
	// >  To query the change logs of a MaxCompute table, you must call the [GetMetaTableChangeLog](~~173925~~) operation.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The type of the change. Valid values: CREATE_TABLE, ALTER_TABLE, DROP_TABLE, ADD_PARTITION, and DROP_PARTITION.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The HTTP status code returned.
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	// The entity on which the change is made. Valid values: TABLE and PARTITION.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
}

func (s GetMetaTableChangeLogRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableChangeLogRequest) GoString() string {
	return s.String()
}

func (s *GetMetaTableChangeLogRequest) SetChangeType(v string) *GetMetaTableChangeLogRequest {
	s.ChangeType = &v
	return s
}

func (s *GetMetaTableChangeLogRequest) SetEndDate(v string) *GetMetaTableChangeLogRequest {
	s.EndDate = &v
	return s
}

func (s *GetMetaTableChangeLogRequest) SetObjectType(v string) *GetMetaTableChangeLogRequest {
	s.ObjectType = &v
	return s
}

func (s *GetMetaTableChangeLogRequest) SetPageNumber(v int32) *GetMetaTableChangeLogRequest {
	s.PageNumber = &v
	return s
}

func (s *GetMetaTableChangeLogRequest) SetPageSize(v int32) *GetMetaTableChangeLogRequest {
	s.PageSize = &v
	return s
}

func (s *GetMetaTableChangeLogRequest) SetStartDate(v string) *GetMetaTableChangeLogRequest {
	s.StartDate = &v
	return s
}

func (s *GetMetaTableChangeLogRequest) SetTableGuid(v string) *GetMetaTableChangeLogRequest {
	s.TableGuid = &v
	return s
}

type GetMetaTableChangeLogResponseBody struct {
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	Data *GetMetaTableChangeLogResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The page number of the returned page.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request is successful.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error code returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The business data returned.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaTableChangeLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableChangeLogResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaTableChangeLogResponseBody) SetData(v *GetMetaTableChangeLogResponseBodyData) *GetMetaTableChangeLogResponseBody {
	s.Data = v
	return s
}

func (s *GetMetaTableChangeLogResponseBody) SetErrorCode(v string) *GetMetaTableChangeLogResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaTableChangeLogResponseBody) SetErrorMessage(v string) *GetMetaTableChangeLogResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaTableChangeLogResponseBody) SetHttpStatusCode(v int32) *GetMetaTableChangeLogResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMetaTableChangeLogResponseBody) SetRequestId(v string) *GetMetaTableChangeLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaTableChangeLogResponseBody) SetSuccess(v bool) *GetMetaTableChangeLogResponseBody {
	s.Success = &v
	return s
}

type GetMetaTableChangeLogResponseBodyData struct {
	// The last time when the metatable was modified.
	DataEntityList []*GetMetaTableChangeLogResponseBodyDataDataEntityList `json:"DataEntityList,omitempty" xml:"DataEntityList,omitempty" type:"Repeated"`
	// The total number of returned entries.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The information about the change logs of the metatable.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The entity on which the change was made. Valid values: TABLE and PARTITION.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetMetaTableChangeLogResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableChangeLogResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMetaTableChangeLogResponseBodyData) SetDataEntityList(v []*GetMetaTableChangeLogResponseBodyDataDataEntityList) *GetMetaTableChangeLogResponseBodyData {
	s.DataEntityList = v
	return s
}

func (s *GetMetaTableChangeLogResponseBodyData) SetPageNumber(v int32) *GetMetaTableChangeLogResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *GetMetaTableChangeLogResponseBodyData) SetPageSize(v int32) *GetMetaTableChangeLogResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetMetaTableChangeLogResponseBodyData) SetTotalCount(v int64) *GetMetaTableChangeLogResponseBodyData {
	s.TotalCount = &v
	return s
}

type GetMetaTableChangeLogResponseBodyDataDataEntityList struct {
	// The type of the change.
	ChangeContent *string `json:"ChangeContent,omitempty" xml:"ChangeContent,omitempty"`
	ChangeType    *string `json:"ChangeType,omitempty" xml:"ChangeType,omitempty"`
	// The name of the operator.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The content of the change.
	ModifiedTime *int64 `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The time when the metatable was created.
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
	Operator   *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
}

func (s GetMetaTableChangeLogResponseBodyDataDataEntityList) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableChangeLogResponseBodyDataDataEntityList) GoString() string {
	return s.String()
}

func (s *GetMetaTableChangeLogResponseBodyDataDataEntityList) SetChangeContent(v string) *GetMetaTableChangeLogResponseBodyDataDataEntityList {
	s.ChangeContent = &v
	return s
}

func (s *GetMetaTableChangeLogResponseBodyDataDataEntityList) SetChangeType(v string) *GetMetaTableChangeLogResponseBodyDataDataEntityList {
	s.ChangeType = &v
	return s
}

func (s *GetMetaTableChangeLogResponseBodyDataDataEntityList) SetCreateTime(v int64) *GetMetaTableChangeLogResponseBodyDataDataEntityList {
	s.CreateTime = &v
	return s
}

func (s *GetMetaTableChangeLogResponseBodyDataDataEntityList) SetModifiedTime(v int64) *GetMetaTableChangeLogResponseBodyDataDataEntityList {
	s.ModifiedTime = &v
	return s
}

func (s *GetMetaTableChangeLogResponseBodyDataDataEntityList) SetObjectType(v string) *GetMetaTableChangeLogResponseBodyDataDataEntityList {
	s.ObjectType = &v
	return s
}

func (s *GetMetaTableChangeLogResponseBodyDataDataEntityList) SetOperator(v string) *GetMetaTableChangeLogResponseBodyDataDataEntityList {
	s.Operator = &v
	return s
}

type GetMetaTableChangeLogResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaTableChangeLogResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaTableChangeLogResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableChangeLogResponse) GoString() string {
	return s.String()
}

func (s *GetMetaTableChangeLogResponse) SetHeaders(v map[string]*string) *GetMetaTableChangeLogResponse {
	s.Headers = v
	return s
}

func (s *GetMetaTableChangeLogResponse) SetStatusCode(v int32) *GetMetaTableChangeLogResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaTableChangeLogResponse) SetBody(v *GetMetaTableChangeLogResponseBody) *GetMetaTableChangeLogResponse {
	s.Body = v
	return s
}

type GetMetaTableColumnRequest struct {
	// The name of the metatable in the EMR cluster. You can call the [GetMetaDBTableList](~~173916~~) operation to query the name.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The error message.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The type of the data source. Only emr is supported.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// The ID of the E-MapReduce (EMR) cluster. You can log on to the EMR console to obtain the ID.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The name of the metadatabase of the EMR cluster. You can call the [ListMetaDB](~~185662~~) operation to query the name.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The HTTP status code.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetMetaTableColumnRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableColumnRequest) GoString() string {
	return s.String()
}

func (s *GetMetaTableColumnRequest) SetClusterId(v string) *GetMetaTableColumnRequest {
	s.ClusterId = &v
	return s
}

func (s *GetMetaTableColumnRequest) SetDataSourceType(v string) *GetMetaTableColumnRequest {
	s.DataSourceType = &v
	return s
}

func (s *GetMetaTableColumnRequest) SetDatabaseName(v string) *GetMetaTableColumnRequest {
	s.DatabaseName = &v
	return s
}

func (s *GetMetaTableColumnRequest) SetPageNum(v int32) *GetMetaTableColumnRequest {
	s.PageNum = &v
	return s
}

func (s *GetMetaTableColumnRequest) SetPageSize(v int32) *GetMetaTableColumnRequest {
	s.PageSize = &v
	return s
}

func (s *GetMetaTableColumnRequest) SetTableGuid(v string) *GetMetaTableColumnRequest {
	s.TableGuid = &v
	return s
}

func (s *GetMetaTableColumnRequest) SetTableName(v string) *GetMetaTableColumnRequest {
	s.TableName = &v
	return s
}

type GetMetaTableColumnResponseBody struct {
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	Data *GetMetaTableColumnResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The page number of the returned page.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request is successful.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error code.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The business data.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaTableColumnResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableColumnResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaTableColumnResponseBody) SetData(v *GetMetaTableColumnResponseBodyData) *GetMetaTableColumnResponseBody {
	s.Data = v
	return s
}

func (s *GetMetaTableColumnResponseBody) SetErrorCode(v string) *GetMetaTableColumnResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaTableColumnResponseBody) SetErrorMessage(v string) *GetMetaTableColumnResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaTableColumnResponseBody) SetHttpStatusCode(v int32) *GetMetaTableColumnResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMetaTableColumnResponseBody) SetRequestId(v string) *GetMetaTableColumnResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaTableColumnResponseBody) SetSuccess(v bool) *GetMetaTableColumnResponseBody {
	s.Success = &v
	return s
}

type GetMetaTableColumnResponseBodyData struct {
	// The name of the field.
	ColumnList []*GetMetaTableColumnResponseBodyDataColumnList `json:"ColumnList,omitempty" xml:"ColumnList,omitempty" type:"Repeated"`
	// The total number of fields.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The information of fields.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The GUID of the field.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetMetaTableColumnResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableColumnResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMetaTableColumnResponseBodyData) SetColumnList(v []*GetMetaTableColumnResponseBodyDataColumnList) *GetMetaTableColumnResponseBodyData {
	s.ColumnList = v
	return s
}

func (s *GetMetaTableColumnResponseBodyData) SetPageNum(v int32) *GetMetaTableColumnResponseBodyData {
	s.PageNum = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyData) SetPageSize(v int32) *GetMetaTableColumnResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyData) SetTotalCount(v int64) *GetMetaTableColumnResponseBodyData {
	s.TotalCount = &v
	return s
}

type GetMetaTableColumnResponseBodyDataColumnList struct {
	// The number of times the field is read.
	Caption *string `json:"Caption,omitempty" xml:"Caption,omitempty"`
	// Indicates whether the field is a partition field. Valid values:
	//
	// *   true: The field is a partition field.
	// *   false: The field is not a partition field.
	ColumnGuid *string `json:"ColumnGuid,omitempty" xml:"ColumnGuid,omitempty"`
	// The remarks of the field.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The ordinal number of the field.
	ColumnType *string `json:"ColumnType,omitempty" xml:"ColumnType,omitempty"`
	// Indicates whether the field is the primary key. Valid values:
	//
	// *   true: The field is the primary key.
	// *   false: The field is not the primary key.
	Comment      *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	IsForeignKey *bool   `json:"IsForeignKey,omitempty" xml:"IsForeignKey,omitempty"`
	// The data type of the field.
	IsPartitionColumn *bool `json:"IsPartitionColumn,omitempty" xml:"IsPartitionColumn,omitempty"`
	// The description of the field.
	IsPrimaryKey *bool `json:"IsPrimaryKey,omitempty" xml:"IsPrimaryKey,omitempty"`
	// Indicates whether the field is a foreign key. Valid values:
	//
	// *   true: The field is a foreign key.
	// *   false: The field is not a foreign key.
	Position      *int32 `json:"Position,omitempty" xml:"Position,omitempty"`
	RelationCount *int64 `json:"RelationCount,omitempty" xml:"RelationCount,omitempty"`
}

func (s GetMetaTableColumnResponseBodyDataColumnList) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableColumnResponseBodyDataColumnList) GoString() string {
	return s.String()
}

func (s *GetMetaTableColumnResponseBodyDataColumnList) SetCaption(v string) *GetMetaTableColumnResponseBodyDataColumnList {
	s.Caption = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyDataColumnList) SetColumnGuid(v string) *GetMetaTableColumnResponseBodyDataColumnList {
	s.ColumnGuid = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyDataColumnList) SetColumnName(v string) *GetMetaTableColumnResponseBodyDataColumnList {
	s.ColumnName = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyDataColumnList) SetColumnType(v string) *GetMetaTableColumnResponseBodyDataColumnList {
	s.ColumnType = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyDataColumnList) SetComment(v string) *GetMetaTableColumnResponseBodyDataColumnList {
	s.Comment = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyDataColumnList) SetIsForeignKey(v bool) *GetMetaTableColumnResponseBodyDataColumnList {
	s.IsForeignKey = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyDataColumnList) SetIsPartitionColumn(v bool) *GetMetaTableColumnResponseBodyDataColumnList {
	s.IsPartitionColumn = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyDataColumnList) SetIsPrimaryKey(v bool) *GetMetaTableColumnResponseBodyDataColumnList {
	s.IsPrimaryKey = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyDataColumnList) SetPosition(v int32) *GetMetaTableColumnResponseBodyDataColumnList {
	s.Position = &v
	return s
}

func (s *GetMetaTableColumnResponseBodyDataColumnList) SetRelationCount(v int64) *GetMetaTableColumnResponseBodyDataColumnList {
	s.RelationCount = &v
	return s
}

type GetMetaTableColumnResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaTableColumnResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaTableColumnResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableColumnResponse) GoString() string {
	return s.String()
}

func (s *GetMetaTableColumnResponse) SetHeaders(v map[string]*string) *GetMetaTableColumnResponse {
	s.Headers = v
	return s
}

func (s *GetMetaTableColumnResponse) SetStatusCode(v int32) *GetMetaTableColumnResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaTableColumnResponse) SetBody(v *GetMetaTableColumnResponseBody) *GetMetaTableColumnResponse {
	s.Body = v
	return s
}

type GetMetaTableFullInfoRequest struct {
	// The ID of the E-MapReduce (EMR) cluster. You can log on to the EMR console to obtain the ID of the cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The type of the data source. Only emr is supported.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The name of the metadatabase of the EMR cluster. You can call the [ListMetaDB](~~185662~~) operation to query the name of the metadatabase.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The GUID of the metatable. You can call the [GetMetaDBTableList](~~173916~~) operation to query the GUID of the metatable.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The name of the metatable in the EMR cluster. You can call the [GetMetaDBTableList](~~173916~~) operation to query the name of the metatable.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetMetaTableFullInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableFullInfoRequest) GoString() string {
	return s.String()
}

func (s *GetMetaTableFullInfoRequest) SetClusterId(v string) *GetMetaTableFullInfoRequest {
	s.ClusterId = &v
	return s
}

func (s *GetMetaTableFullInfoRequest) SetDataSourceType(v string) *GetMetaTableFullInfoRequest {
	s.DataSourceType = &v
	return s
}

func (s *GetMetaTableFullInfoRequest) SetDatabaseName(v string) *GetMetaTableFullInfoRequest {
	s.DatabaseName = &v
	return s
}

func (s *GetMetaTableFullInfoRequest) SetPageNum(v int32) *GetMetaTableFullInfoRequest {
	s.PageNum = &v
	return s
}

func (s *GetMetaTableFullInfoRequest) SetPageSize(v int32) *GetMetaTableFullInfoRequest {
	s.PageSize = &v
	return s
}

func (s *GetMetaTableFullInfoRequest) SetTableGuid(v string) *GetMetaTableFullInfoRequest {
	s.TableGuid = &v
	return s
}

func (s *GetMetaTableFullInfoRequest) SetTableName(v string) *GetMetaTableFullInfoRequest {
	s.TableName = &v
	return s
}

type GetMetaTableFullInfoResponseBody struct {
	// The business data returned.
	Data *GetMetaTableFullInfoResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaTableFullInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableFullInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaTableFullInfoResponseBody) SetData(v *GetMetaTableFullInfoResponseBodyData) *GetMetaTableFullInfoResponseBody {
	s.Data = v
	return s
}

func (s *GetMetaTableFullInfoResponseBody) SetErrorCode(v string) *GetMetaTableFullInfoResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBody) SetErrorMessage(v string) *GetMetaTableFullInfoResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBody) SetHttpStatusCode(v int32) *GetMetaTableFullInfoResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBody) SetRequestId(v string) *GetMetaTableFullInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBody) SetSuccess(v bool) *GetMetaTableFullInfoResponseBody {
	s.Success = &v
	return s
}

type GetMetaTableFullInfoResponseBodyData struct {
	// The ID of the EMR cluster.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The fields in the metatable.
	ColumnList []*GetMetaTableFullInfoResponseBodyDataColumnList `json:"ColumnList,omitempty" xml:"ColumnList,omitempty" type:"Repeated"`
	// The remarks of the metatable.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The time when the metatable was created. You can convert the timestamp to the related date based on the time zone that you use.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The amount of storage resources that are consumed by the metatable. Unit: bytes.
	DataSize *int64 `json:"DataSize,omitempty" xml:"DataSize,omitempty"`
	// The name of the database.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// The type of the environment in which the metatable resides. Valid values:
	//
	// *   0: indicates that the metatable resides in the development environment.
	// *   1: indicates that the metatable resides in the production environment.
	EnvType *int32 `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The scope in which the metatable is visible. Valid values:
	//
	// *   0: indicates that the metatable is visible to workspace members.
	// *   1: indicates that the metatable is visible to users within a tenant.
	// *   2: indicates that the metatable is visible to all tenants.
	// *   3: indicates that the metatable is visible only to the metatable owner.
	IsVisible *int32 `json:"IsVisible,omitempty" xml:"IsVisible,omitempty"`
	// The time when the metatable was last accessed. You can convert the timestamp to the related date based on the time zone that you use.
	LastAccessTime *int64 `json:"LastAccessTime,omitempty" xml:"LastAccessTime,omitempty"`
	// The time when the schema of the metatable was last changed. You can convert the timestamp to the related date based on the time zone that you use.
	LastDdlTime *int64 `json:"LastDdlTime,omitempty" xml:"LastDdlTime,omitempty"`
	// The time when the metatable was last updated. You can convert the timestamp to the related date based on the time zone that you use.
	LastModifyTime *int64 `json:"LastModifyTime,omitempty" xml:"LastModifyTime,omitempty"`
	// The lifecycle of the metatable. Unit: days.
	LifeCycle *int32 `json:"LifeCycle,omitempty" xml:"LifeCycle,omitempty"`
	// The storage path of the Hive metatable.
	Location *string `json:"Location,omitempty" xml:"Location,omitempty"`
	// The ID of the metatable owner.
	OwnerId *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The partition key.
	PartitionKeys *string `json:"PartitionKeys,omitempty" xml:"PartitionKeys,omitempty"`
	// The ID of the workspace to which the metatable belongs.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the workspace to which the metatable belongs.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	Schema      *string `json:"Schema,omitempty" xml:"Schema,omitempty"`
	// The GUID of the metatable.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The name of the metatable.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	// The total number of fields.
	TotalColumnCount *int64 `json:"TotalColumnCount,omitempty" xml:"TotalColumnCount,omitempty"`
}

func (s GetMetaTableFullInfoResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableFullInfoResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMetaTableFullInfoResponseBodyData) SetClusterId(v string) *GetMetaTableFullInfoResponseBodyData {
	s.ClusterId = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetColumnList(v []*GetMetaTableFullInfoResponseBodyDataColumnList) *GetMetaTableFullInfoResponseBodyData {
	s.ColumnList = v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetComment(v string) *GetMetaTableFullInfoResponseBodyData {
	s.Comment = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetCreateTime(v int64) *GetMetaTableFullInfoResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetDataSize(v int64) *GetMetaTableFullInfoResponseBodyData {
	s.DataSize = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetDatabaseName(v string) *GetMetaTableFullInfoResponseBodyData {
	s.DatabaseName = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetEnvType(v int32) *GetMetaTableFullInfoResponseBodyData {
	s.EnvType = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetIsVisible(v int32) *GetMetaTableFullInfoResponseBodyData {
	s.IsVisible = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetLastAccessTime(v int64) *GetMetaTableFullInfoResponseBodyData {
	s.LastAccessTime = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetLastDdlTime(v int64) *GetMetaTableFullInfoResponseBodyData {
	s.LastDdlTime = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetLastModifyTime(v int64) *GetMetaTableFullInfoResponseBodyData {
	s.LastModifyTime = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetLifeCycle(v int32) *GetMetaTableFullInfoResponseBodyData {
	s.LifeCycle = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetLocation(v string) *GetMetaTableFullInfoResponseBodyData {
	s.Location = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetOwnerId(v string) *GetMetaTableFullInfoResponseBodyData {
	s.OwnerId = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetPartitionKeys(v string) *GetMetaTableFullInfoResponseBodyData {
	s.PartitionKeys = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetProjectId(v int64) *GetMetaTableFullInfoResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetProjectName(v string) *GetMetaTableFullInfoResponseBodyData {
	s.ProjectName = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetSchema(v string) *GetMetaTableFullInfoResponseBodyData {
	s.Schema = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetTableGuid(v string) *GetMetaTableFullInfoResponseBodyData {
	s.TableGuid = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetTableName(v string) *GetMetaTableFullInfoResponseBodyData {
	s.TableName = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetTenantId(v int64) *GetMetaTableFullInfoResponseBodyData {
	s.TenantId = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyData) SetTotalColumnCount(v int64) *GetMetaTableFullInfoResponseBodyData {
	s.TotalColumnCount = &v
	return s
}

type GetMetaTableFullInfoResponseBodyDataColumnList struct {
	// The description of the field.
	Caption *string `json:"Caption,omitempty" xml:"Caption,omitempty"`
	// The GUID of the field.
	ColumnGuid *string `json:"ColumnGuid,omitempty" xml:"ColumnGuid,omitempty"`
	// The name of the field.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The data type of the field.
	ColumnType *string `json:"ColumnType,omitempty" xml:"ColumnType,omitempty"`
	// The remarks of the field.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// Indicates whether the field is a foreign key. Valid values:
	//
	// *   true: The field is a foreign key.
	// *   false: The field is not a foreign key.
	IsForeignKey *bool `json:"IsForeignKey,omitempty" xml:"IsForeignKey,omitempty"`
	// Indicates whether the field is a partition field. Valid values:
	//
	// *   true: The field is a partition field.
	// *   false: The field is not a partition field.
	IsPartitionColumn *bool `json:"IsPartitionColumn,omitempty" xml:"IsPartitionColumn,omitempty"`
	// Indicates whether the field is the primary key. Valid values:
	//
	// *   true: The field is the primary key.
	// *   false: The field is not the primary key.
	IsPrimaryKey *bool `json:"IsPrimaryKey,omitempty" xml:"IsPrimaryKey,omitempty"`
	// The ordinal number of the field.
	Position *int32 `json:"Position,omitempty" xml:"Position,omitempty"`
}

func (s GetMetaTableFullInfoResponseBodyDataColumnList) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableFullInfoResponseBodyDataColumnList) GoString() string {
	return s.String()
}

func (s *GetMetaTableFullInfoResponseBodyDataColumnList) SetCaption(v string) *GetMetaTableFullInfoResponseBodyDataColumnList {
	s.Caption = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyDataColumnList) SetColumnGuid(v string) *GetMetaTableFullInfoResponseBodyDataColumnList {
	s.ColumnGuid = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyDataColumnList) SetColumnName(v string) *GetMetaTableFullInfoResponseBodyDataColumnList {
	s.ColumnName = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyDataColumnList) SetColumnType(v string) *GetMetaTableFullInfoResponseBodyDataColumnList {
	s.ColumnType = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyDataColumnList) SetComment(v string) *GetMetaTableFullInfoResponseBodyDataColumnList {
	s.Comment = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyDataColumnList) SetIsForeignKey(v bool) *GetMetaTableFullInfoResponseBodyDataColumnList {
	s.IsForeignKey = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyDataColumnList) SetIsPartitionColumn(v bool) *GetMetaTableFullInfoResponseBodyDataColumnList {
	s.IsPartitionColumn = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyDataColumnList) SetIsPrimaryKey(v bool) *GetMetaTableFullInfoResponseBodyDataColumnList {
	s.IsPrimaryKey = &v
	return s
}

func (s *GetMetaTableFullInfoResponseBodyDataColumnList) SetPosition(v int32) *GetMetaTableFullInfoResponseBodyDataColumnList {
	s.Position = &v
	return s
}

type GetMetaTableFullInfoResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaTableFullInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaTableFullInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableFullInfoResponse) GoString() string {
	return s.String()
}

func (s *GetMetaTableFullInfoResponse) SetHeaders(v map[string]*string) *GetMetaTableFullInfoResponse {
	s.Headers = v
	return s
}

func (s *GetMetaTableFullInfoResponse) SetStatusCode(v int32) *GetMetaTableFullInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaTableFullInfoResponse) SetBody(v *GetMetaTableFullInfoResponseBody) *GetMetaTableFullInfoResponse {
	s.Body = v
	return s
}

type GetMetaTableIntroWikiRequest struct {
	// The GUID of the metatable.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The version of the instructions.
	WikiVersion *int64 `json:"WikiVersion,omitempty" xml:"WikiVersion,omitempty"`
}

func (s GetMetaTableIntroWikiRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableIntroWikiRequest) GoString() string {
	return s.String()
}

func (s *GetMetaTableIntroWikiRequest) SetTableGuid(v string) *GetMetaTableIntroWikiRequest {
	s.TableGuid = &v
	return s
}

func (s *GetMetaTableIntroWikiRequest) SetWikiVersion(v int64) *GetMetaTableIntroWikiRequest {
	s.WikiVersion = &v
	return s
}

type GetMetaTableIntroWikiResponseBody struct {
	// The business data returned.
	Data *GetMetaTableIntroWikiResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaTableIntroWikiResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableIntroWikiResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaTableIntroWikiResponseBody) SetData(v *GetMetaTableIntroWikiResponseBodyData) *GetMetaTableIntroWikiResponseBody {
	s.Data = v
	return s
}

func (s *GetMetaTableIntroWikiResponseBody) SetErrorCode(v string) *GetMetaTableIntroWikiResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaTableIntroWikiResponseBody) SetErrorMessage(v string) *GetMetaTableIntroWikiResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaTableIntroWikiResponseBody) SetHttpStatusCode(v int32) *GetMetaTableIntroWikiResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMetaTableIntroWikiResponseBody) SetRequestId(v string) *GetMetaTableIntroWikiResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaTableIntroWikiResponseBody) SetSuccess(v bool) *GetMetaTableIntroWikiResponseBody {
	s.Success = &v
	return s
}

type GetMetaTableIntroWikiResponseBodyData struct {
	// The description of the metatable.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The time when the metatable was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The creator of the metatable.
	Creator *string `json:"Creator,omitempty" xml:"Creator,omitempty"`
	// The name of the user who created the metatable.
	CreatorName *string `json:"CreatorName,omitempty" xml:"CreatorName,omitempty"`
	// The time when the metatable was modified.
	ModifiedTime *int64 `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The version number.
	Version *int64 `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s GetMetaTableIntroWikiResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableIntroWikiResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMetaTableIntroWikiResponseBodyData) SetContent(v string) *GetMetaTableIntroWikiResponseBodyData {
	s.Content = &v
	return s
}

func (s *GetMetaTableIntroWikiResponseBodyData) SetCreateTime(v int64) *GetMetaTableIntroWikiResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *GetMetaTableIntroWikiResponseBodyData) SetCreator(v string) *GetMetaTableIntroWikiResponseBodyData {
	s.Creator = &v
	return s
}

func (s *GetMetaTableIntroWikiResponseBodyData) SetCreatorName(v string) *GetMetaTableIntroWikiResponseBodyData {
	s.CreatorName = &v
	return s
}

func (s *GetMetaTableIntroWikiResponseBodyData) SetModifiedTime(v int64) *GetMetaTableIntroWikiResponseBodyData {
	s.ModifiedTime = &v
	return s
}

func (s *GetMetaTableIntroWikiResponseBodyData) SetVersion(v int64) *GetMetaTableIntroWikiResponseBodyData {
	s.Version = &v
	return s
}

type GetMetaTableIntroWikiResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaTableIntroWikiResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaTableIntroWikiResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableIntroWikiResponse) GoString() string {
	return s.String()
}

func (s *GetMetaTableIntroWikiResponse) SetHeaders(v map[string]*string) *GetMetaTableIntroWikiResponse {
	s.Headers = v
	return s
}

func (s *GetMetaTableIntroWikiResponse) SetStatusCode(v int32) *GetMetaTableIntroWikiResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaTableIntroWikiResponse) SetBody(v *GetMetaTableIntroWikiResponseBody) *GetMetaTableIntroWikiResponse {
	s.Body = v
	return s
}

type GetMetaTableLineageRequest struct {
	// The name of the metatable.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The error message.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The type of the data source. Valid values: odps and emr.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	Direction *string `json:"Direction,omitempty" xml:"Direction,omitempty"`
	// The ID of the E-MapReduce (EMR) cluster. Set this parameter only when you query data in an EMR compute engine instance.
	NextPrimaryKey *string `json:"NextPrimaryKey,omitempty" xml:"NextPrimaryKey,omitempty"`
	// The name of the metadatabase.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The logic of paging. Set this parameter based on the value of the response parameter NextPrimaryKey when the value of the response parameter HasNext is true in the last query.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The HTTP status code.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetMetaTableLineageRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableLineageRequest) GoString() string {
	return s.String()
}

func (s *GetMetaTableLineageRequest) SetClusterId(v string) *GetMetaTableLineageRequest {
	s.ClusterId = &v
	return s
}

func (s *GetMetaTableLineageRequest) SetDataSourceType(v string) *GetMetaTableLineageRequest {
	s.DataSourceType = &v
	return s
}

func (s *GetMetaTableLineageRequest) SetDatabaseName(v string) *GetMetaTableLineageRequest {
	s.DatabaseName = &v
	return s
}

func (s *GetMetaTableLineageRequest) SetDirection(v string) *GetMetaTableLineageRequest {
	s.Direction = &v
	return s
}

func (s *GetMetaTableLineageRequest) SetNextPrimaryKey(v string) *GetMetaTableLineageRequest {
	s.NextPrimaryKey = &v
	return s
}

func (s *GetMetaTableLineageRequest) SetPageSize(v int32) *GetMetaTableLineageRequest {
	s.PageSize = &v
	return s
}

func (s *GetMetaTableLineageRequest) SetTableGuid(v string) *GetMetaTableLineageRequest {
	s.TableGuid = &v
	return s
}

func (s *GetMetaTableLineageRequest) SetTableName(v string) *GetMetaTableLineageRequest {
	s.TableName = &v
	return s
}

type GetMetaTableLineageResponseBody struct {
	// Indicates whether the next page has more query results.
	Data *GetMetaTableLineageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The paging information.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request is successful.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error code.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The business data.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaTableLineageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableLineageResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaTableLineageResponseBody) SetData(v *GetMetaTableLineageResponseBodyData) *GetMetaTableLineageResponseBody {
	s.Data = v
	return s
}

func (s *GetMetaTableLineageResponseBody) SetErrorCode(v string) *GetMetaTableLineageResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaTableLineageResponseBody) SetErrorMessage(v string) *GetMetaTableLineageResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaTableLineageResponseBody) SetHttpStatusCode(v int32) *GetMetaTableLineageResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMetaTableLineageResponseBody) SetRequestId(v string) *GetMetaTableLineageResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaTableLineageResponseBody) SetSuccess(v bool) *GetMetaTableLineageResponseBody {
	s.Success = &v
	return s
}

type GetMetaTableLineageResponseBodyData struct {
	// The GUID of the metatable.
	DataEntityList []*GetMetaTableLineageResponseBodyDataDataEntityList `json:"DataEntityList,omitempty" xml:"DataEntityList,omitempty" type:"Repeated"`
	// The name of the metatable.
	HasNext *bool `json:"HasNext,omitempty" xml:"HasNext,omitempty"`
	// The information about the metatable.
	NextPrimaryKey *string `json:"NextPrimaryKey,omitempty" xml:"NextPrimaryKey,omitempty"`
}

func (s GetMetaTableLineageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableLineageResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMetaTableLineageResponseBodyData) SetDataEntityList(v []*GetMetaTableLineageResponseBodyDataDataEntityList) *GetMetaTableLineageResponseBodyData {
	s.DataEntityList = v
	return s
}

func (s *GetMetaTableLineageResponseBodyData) SetHasNext(v bool) *GetMetaTableLineageResponseBodyData {
	s.HasNext = &v
	return s
}

func (s *GetMetaTableLineageResponseBodyData) SetNextPrimaryKey(v string) *GetMetaTableLineageResponseBodyData {
	s.NextPrimaryKey = &v
	return s
}

type GetMetaTableLineageResponseBodyDataDataEntityList struct {
	CreateTimestamp *int64  `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	DatabaseName    *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	TableGuid       *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The time when the metatable was created.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetMetaTableLineageResponseBodyDataDataEntityList) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableLineageResponseBodyDataDataEntityList) GoString() string {
	return s.String()
}

func (s *GetMetaTableLineageResponseBodyDataDataEntityList) SetCreateTimestamp(v int64) *GetMetaTableLineageResponseBodyDataDataEntityList {
	s.CreateTimestamp = &v
	return s
}

func (s *GetMetaTableLineageResponseBodyDataDataEntityList) SetDatabaseName(v string) *GetMetaTableLineageResponseBodyDataDataEntityList {
	s.DatabaseName = &v
	return s
}

func (s *GetMetaTableLineageResponseBodyDataDataEntityList) SetTableGuid(v string) *GetMetaTableLineageResponseBodyDataDataEntityList {
	s.TableGuid = &v
	return s
}

func (s *GetMetaTableLineageResponseBodyDataDataEntityList) SetTableName(v string) *GetMetaTableLineageResponseBodyDataDataEntityList {
	s.TableName = &v
	return s
}

type GetMetaTableLineageResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaTableLineageResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaTableLineageResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableLineageResponse) GoString() string {
	return s.String()
}

func (s *GetMetaTableLineageResponse) SetHeaders(v map[string]*string) *GetMetaTableLineageResponse {
	s.Headers = v
	return s
}

func (s *GetMetaTableLineageResponse) SetStatusCode(v int32) *GetMetaTableLineageResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaTableLineageResponse) SetBody(v *GetMetaTableLineageResponseBody) *GetMetaTableLineageResponse {
	s.Body = v
	return s
}

type GetMetaTableListByCategoryRequest struct {
	CategoryId *int64 `json:"CategoryId,omitempty" xml:"CategoryId,omitempty"`
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s GetMetaTableListByCategoryRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableListByCategoryRequest) GoString() string {
	return s.String()
}

func (s *GetMetaTableListByCategoryRequest) SetCategoryId(v int64) *GetMetaTableListByCategoryRequest {
	s.CategoryId = &v
	return s
}

func (s *GetMetaTableListByCategoryRequest) SetPageNumber(v int32) *GetMetaTableListByCategoryRequest {
	s.PageNumber = &v
	return s
}

func (s *GetMetaTableListByCategoryRequest) SetPageSize(v int32) *GetMetaTableListByCategoryRequest {
	s.PageSize = &v
	return s
}

type GetMetaTableListByCategoryResponseBody struct {
	Data           *GetMetaTableListByCategoryResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorCode      *string                                     `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string                                     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32                                      `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                                       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaTableListByCategoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableListByCategoryResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaTableListByCategoryResponseBody) SetData(v *GetMetaTableListByCategoryResponseBodyData) *GetMetaTableListByCategoryResponseBody {
	s.Data = v
	return s
}

func (s *GetMetaTableListByCategoryResponseBody) SetErrorCode(v string) *GetMetaTableListByCategoryResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaTableListByCategoryResponseBody) SetErrorMessage(v string) *GetMetaTableListByCategoryResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaTableListByCategoryResponseBody) SetHttpStatusCode(v int32) *GetMetaTableListByCategoryResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMetaTableListByCategoryResponseBody) SetRequestId(v string) *GetMetaTableListByCategoryResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaTableListByCategoryResponseBody) SetSuccess(v bool) *GetMetaTableListByCategoryResponseBody {
	s.Success = &v
	return s
}

type GetMetaTableListByCategoryResponseBodyData struct {
	PageNumber    *int32    `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize      *int32    `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	TableGuidList []*string `json:"TableGuidList,omitempty" xml:"TableGuidList,omitempty" type:"Repeated"`
	TotalCount    *int64    `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetMetaTableListByCategoryResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableListByCategoryResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMetaTableListByCategoryResponseBodyData) SetPageNumber(v int32) *GetMetaTableListByCategoryResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *GetMetaTableListByCategoryResponseBodyData) SetPageSize(v int32) *GetMetaTableListByCategoryResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetMetaTableListByCategoryResponseBodyData) SetTableGuidList(v []*string) *GetMetaTableListByCategoryResponseBodyData {
	s.TableGuidList = v
	return s
}

func (s *GetMetaTableListByCategoryResponseBodyData) SetTotalCount(v int64) *GetMetaTableListByCategoryResponseBodyData {
	s.TotalCount = &v
	return s
}

type GetMetaTableListByCategoryResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaTableListByCategoryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaTableListByCategoryResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableListByCategoryResponse) GoString() string {
	return s.String()
}

func (s *GetMetaTableListByCategoryResponse) SetHeaders(v map[string]*string) *GetMetaTableListByCategoryResponse {
	s.Headers = v
	return s
}

func (s *GetMetaTableListByCategoryResponse) SetStatusCode(v int32) *GetMetaTableListByCategoryResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaTableListByCategoryResponse) SetBody(v *GetMetaTableListByCategoryResponseBody) *GetMetaTableListByCategoryResponse {
	s.Body = v
	return s
}

type GetMetaTableOutputRequest struct {
	// The HTTP status code returned.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The Globally Unique Identifier (GUID) of the MaxCompute metatable.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The start date of the time range to query. The start date must be within the previous 30 days.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the node.
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	// The end date of the time range to query. The end date must be within the previous 30 days.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The error message returned.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s GetMetaTableOutputRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableOutputRequest) GoString() string {
	return s.String()
}

func (s *GetMetaTableOutputRequest) SetEndDate(v string) *GetMetaTableOutputRequest {
	s.EndDate = &v
	return s
}

func (s *GetMetaTableOutputRequest) SetPageNumber(v int32) *GetMetaTableOutputRequest {
	s.PageNumber = &v
	return s
}

func (s *GetMetaTableOutputRequest) SetPageSize(v int32) *GetMetaTableOutputRequest {
	s.PageSize = &v
	return s
}

func (s *GetMetaTableOutputRequest) SetStartDate(v string) *GetMetaTableOutputRequest {
	s.StartDate = &v
	return s
}

func (s *GetMetaTableOutputRequest) SetTableGuid(v string) *GetMetaTableOutputRequest {
	s.TableGuid = &v
	return s
}

func (s *GetMetaTableOutputRequest) SetTaskId(v string) *GetMetaTableOutputRequest {
	s.TaskId = &v
	return s
}

type GetMetaTableOutputResponseBody struct {
	// The number of entries returned per page.
	Data *GetMetaTableOutputResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The page number of the returned page.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error code returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The output node and instance.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaTableOutputResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableOutputResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaTableOutputResponseBody) SetData(v *GetMetaTableOutputResponseBodyData) *GetMetaTableOutputResponseBody {
	s.Data = v
	return s
}

func (s *GetMetaTableOutputResponseBody) SetErrorCode(v string) *GetMetaTableOutputResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaTableOutputResponseBody) SetErrorMessage(v string) *GetMetaTableOutputResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaTableOutputResponseBody) SetHttpStatusCode(v int32) *GetMetaTableOutputResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMetaTableOutputResponseBody) SetRequestId(v string) *GetMetaTableOutputResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaTableOutputResponseBody) SetSuccess(v bool) *GetMetaTableOutputResponseBody {
	s.Success = &v
	return s
}

type GetMetaTableOutputResponseBodyData struct {
	// The ID of the instance.
	DataEntityList []*GetMetaTableOutputResponseBodyDataDataEntityList `json:"DataEntityList,omitempty" xml:"DataEntityList,omitempty" type:"Repeated"`
	// The total number of entries returned.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The information of the node and instance.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The end time of the node.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetMetaTableOutputResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableOutputResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMetaTableOutputResponseBodyData) SetDataEntityList(v []*GetMetaTableOutputResponseBodyDataDataEntityList) *GetMetaTableOutputResponseBodyData {
	s.DataEntityList = v
	return s
}

func (s *GetMetaTableOutputResponseBodyData) SetPageNumber(v int32) *GetMetaTableOutputResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *GetMetaTableOutputResponseBodyData) SetPageSize(v int32) *GetMetaTableOutputResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetMetaTableOutputResponseBodyData) SetTotalCount(v int64) *GetMetaTableOutputResponseBodyData {
	s.TotalCount = &v
	return s
}

type GetMetaTableOutputResponseBodyDataDataEntityList struct {
	// The start time of the node.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The GUID of the MaxCompute metatable.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The duration during which the node waits to start.
	StartTime *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	TaskId    *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The ID of the workspace.
	TaskInstanceId *int64 `json:"TaskInstanceId,omitempty" xml:"TaskInstanceId,omitempty"`
	// The ID of the node.
	WaitTime *string `json:"WaitTime,omitempty" xml:"WaitTime,omitempty"`
}

func (s GetMetaTableOutputResponseBodyDataDataEntityList) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableOutputResponseBodyDataDataEntityList) GoString() string {
	return s.String()
}

func (s *GetMetaTableOutputResponseBodyDataDataEntityList) SetEndTime(v string) *GetMetaTableOutputResponseBodyDataDataEntityList {
	s.EndTime = &v
	return s
}

func (s *GetMetaTableOutputResponseBodyDataDataEntityList) SetProjectId(v int64) *GetMetaTableOutputResponseBodyDataDataEntityList {
	s.ProjectId = &v
	return s
}

func (s *GetMetaTableOutputResponseBodyDataDataEntityList) SetStartTime(v string) *GetMetaTableOutputResponseBodyDataDataEntityList {
	s.StartTime = &v
	return s
}

func (s *GetMetaTableOutputResponseBodyDataDataEntityList) SetTableGuid(v string) *GetMetaTableOutputResponseBodyDataDataEntityList {
	s.TableGuid = &v
	return s
}

func (s *GetMetaTableOutputResponseBodyDataDataEntityList) SetTaskId(v string) *GetMetaTableOutputResponseBodyDataDataEntityList {
	s.TaskId = &v
	return s
}

func (s *GetMetaTableOutputResponseBodyDataDataEntityList) SetTaskInstanceId(v int64) *GetMetaTableOutputResponseBodyDataDataEntityList {
	s.TaskInstanceId = &v
	return s
}

func (s *GetMetaTableOutputResponseBodyDataDataEntityList) SetWaitTime(v string) *GetMetaTableOutputResponseBodyDataDataEntityList {
	s.WaitTime = &v
	return s
}

type GetMetaTableOutputResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaTableOutputResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaTableOutputResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableOutputResponse) GoString() string {
	return s.String()
}

func (s *GetMetaTableOutputResponse) SetHeaders(v map[string]*string) *GetMetaTableOutputResponse {
	s.Headers = v
	return s
}

func (s *GetMetaTableOutputResponse) SetStatusCode(v int32) *GetMetaTableOutputResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaTableOutputResponse) SetBody(v *GetMetaTableOutputResponseBody) *GetMetaTableOutputResponse {
	s.Body = v
	return s
}

type GetMetaTablePartitionRequest struct {
	// The name of the metatable in the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
	//
	// You can call the [GetMetaDBTableList](~~173916~~) operation to query the name of the metatable.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The field that is used to sort partitions in the metatable. Valid values: name and modify_time.
	//
	// By default, partitions in the metatable are sorted based on their creation time.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The type of the data source. Valid values: odps and emr.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// The GUID of the metatable.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
	//
	// You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID of the EMR cluster.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The order in which partitions in the metatable are sorted. Valid values: asc and desc. Default value: desc.
	SortCriterion *GetMetaTablePartitionRequestSortCriterion `json:"SortCriterion,omitempty" xml:"SortCriterion,omitempty" type:"Struct"`
	// The name of the metadatabase. This parameter is required only if you set the DataSourceType parameter to emr.
	//
	// You can call the [ListMetaDB](~~185662~~) operation to query the name of the metadatabase.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The logic for sorting partitions in the metatable.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetMetaTablePartitionRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTablePartitionRequest) GoString() string {
	return s.String()
}

func (s *GetMetaTablePartitionRequest) SetClusterId(v string) *GetMetaTablePartitionRequest {
	s.ClusterId = &v
	return s
}

func (s *GetMetaTablePartitionRequest) SetDataSourceType(v string) *GetMetaTablePartitionRequest {
	s.DataSourceType = &v
	return s
}

func (s *GetMetaTablePartitionRequest) SetDatabaseName(v string) *GetMetaTablePartitionRequest {
	s.DatabaseName = &v
	return s
}

func (s *GetMetaTablePartitionRequest) SetPageNumber(v int32) *GetMetaTablePartitionRequest {
	s.PageNumber = &v
	return s
}

func (s *GetMetaTablePartitionRequest) SetPageSize(v int32) *GetMetaTablePartitionRequest {
	s.PageSize = &v
	return s
}

func (s *GetMetaTablePartitionRequest) SetSortCriterion(v *GetMetaTablePartitionRequestSortCriterion) *GetMetaTablePartitionRequest {
	s.SortCriterion = v
	return s
}

func (s *GetMetaTablePartitionRequest) SetTableGuid(v string) *GetMetaTablePartitionRequest {
	s.TableGuid = &v
	return s
}

func (s *GetMetaTablePartitionRequest) SetTableName(v string) *GetMetaTablePartitionRequest {
	s.TableName = &v
	return s
}

type GetMetaTablePartitionRequestSortCriterion struct {
	// The error message returned.
	Order *string `json:"Order,omitempty" xml:"Order,omitempty"`
	// The HTTP status code returned.
	SortField *string `json:"SortField,omitempty" xml:"SortField,omitempty"`
}

func (s GetMetaTablePartitionRequestSortCriterion) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTablePartitionRequestSortCriterion) GoString() string {
	return s.String()
}

func (s *GetMetaTablePartitionRequestSortCriterion) SetOrder(v string) *GetMetaTablePartitionRequestSortCriterion {
	s.Order = &v
	return s
}

func (s *GetMetaTablePartitionRequestSortCriterion) SetSortField(v string) *GetMetaTablePartitionRequestSortCriterion {
	s.SortField = &v
	return s
}

type GetMetaTablePartitionShrinkRequest struct {
	// The name of the metatable in the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
	//
	// You can call the [GetMetaDBTableList](~~173916~~) operation to query the name of the metatable.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The field that is used to sort partitions in the metatable. Valid values: name and modify_time.
	//
	// By default, partitions in the metatable are sorted based on their creation time.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The type of the data source. Valid values: odps and emr.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// The GUID of the metatable.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
	//
	// You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID of the EMR cluster.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The order in which partitions in the metatable are sorted. Valid values: asc and desc. Default value: desc.
	SortCriterionShrink *string `json:"SortCriterion,omitempty" xml:"SortCriterion,omitempty"`
	// The name of the metadatabase. This parameter is required only if you set the DataSourceType parameter to emr.
	//
	// You can call the [ListMetaDB](~~185662~~) operation to query the name of the metadatabase.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The logic for sorting partitions in the metatable.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetMetaTablePartitionShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTablePartitionShrinkRequest) GoString() string {
	return s.String()
}

func (s *GetMetaTablePartitionShrinkRequest) SetClusterId(v string) *GetMetaTablePartitionShrinkRequest {
	s.ClusterId = &v
	return s
}

func (s *GetMetaTablePartitionShrinkRequest) SetDataSourceType(v string) *GetMetaTablePartitionShrinkRequest {
	s.DataSourceType = &v
	return s
}

func (s *GetMetaTablePartitionShrinkRequest) SetDatabaseName(v string) *GetMetaTablePartitionShrinkRequest {
	s.DatabaseName = &v
	return s
}

func (s *GetMetaTablePartitionShrinkRequest) SetPageNumber(v int32) *GetMetaTablePartitionShrinkRequest {
	s.PageNumber = &v
	return s
}

func (s *GetMetaTablePartitionShrinkRequest) SetPageSize(v int32) *GetMetaTablePartitionShrinkRequest {
	s.PageSize = &v
	return s
}

func (s *GetMetaTablePartitionShrinkRequest) SetSortCriterionShrink(v string) *GetMetaTablePartitionShrinkRequest {
	s.SortCriterionShrink = &v
	return s
}

func (s *GetMetaTablePartitionShrinkRequest) SetTableGuid(v string) *GetMetaTablePartitionShrinkRequest {
	s.TableGuid = &v
	return s
}

func (s *GetMetaTablePartitionShrinkRequest) SetTableName(v string) *GetMetaTablePartitionShrinkRequest {
	s.TableName = &v
	return s
}

type GetMetaTablePartitionResponseBody struct {
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	Data *GetMetaTablePartitionResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The page number of the returned page.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error code returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The business data returned.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaTablePartitionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTablePartitionResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaTablePartitionResponseBody) SetData(v *GetMetaTablePartitionResponseBodyData) *GetMetaTablePartitionResponseBody {
	s.Data = v
	return s
}

func (s *GetMetaTablePartitionResponseBody) SetErrorCode(v string) *GetMetaTablePartitionResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaTablePartitionResponseBody) SetErrorMessage(v string) *GetMetaTablePartitionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaTablePartitionResponseBody) SetHttpStatusCode(v int32) *GetMetaTablePartitionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMetaTablePartitionResponseBody) SetRequestId(v string) *GetMetaTablePartitionResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaTablePartitionResponseBody) SetSuccess(v bool) *GetMetaTablePartitionResponseBody {
	s.Success = &v
	return s
}

type GetMetaTablePartitionResponseBodyData struct {
	// The size of the partition. Unit: bytes.
	DataEntityList []*GetMetaTablePartitionResponseBodyDataDataEntityList `json:"DataEntityList,omitempty" xml:"DataEntityList,omitempty" type:"Repeated"`
	// The total number of partitions.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The list of partitions.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The path of the partition.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetMetaTablePartitionResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTablePartitionResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMetaTablePartitionResponseBodyData) SetDataEntityList(v []*GetMetaTablePartitionResponseBodyDataDataEntityList) *GetMetaTablePartitionResponseBodyData {
	s.DataEntityList = v
	return s
}

func (s *GetMetaTablePartitionResponseBodyData) SetPageNumber(v int32) *GetMetaTablePartitionResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *GetMetaTablePartitionResponseBodyData) SetPageSize(v int32) *GetMetaTablePartitionResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetMetaTablePartitionResponseBodyData) SetTotalCount(v int64) *GetMetaTablePartitionResponseBodyData {
	s.TotalCount = &v
	return s
}

type GetMetaTablePartitionResponseBodyDataDataEntityList struct {
	// The time when the partition was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The type of the partition.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The comment.
	DataSize *int64 `json:"DataSize,omitempty" xml:"DataSize,omitempty"`
	// The number of entries in the partition.
	ModifiedTime *int64 `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The GUID of the metatable.
	PartitionGuid     *string `json:"PartitionGuid,omitempty" xml:"PartitionGuid,omitempty"`
	PartitionLocation *string `json:"PartitionLocation,omitempty" xml:"PartitionLocation,omitempty"`
	// The time when the partition was modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	PartitionName *string `json:"PartitionName,omitempty" xml:"PartitionName,omitempty"`
	// The name of the partition.
	PartitionPath *string `json:"PartitionPath,omitempty" xml:"PartitionPath,omitempty"`
	// The location of the Hive partition.
	PartitionType *string `json:"PartitionType,omitempty" xml:"PartitionType,omitempty"`
	// The GUID of the partition.
	RecordCount *int64  `json:"RecordCount,omitempty" xml:"RecordCount,omitempty"`
	TableGuid   *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
}

func (s GetMetaTablePartitionResponseBodyDataDataEntityList) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTablePartitionResponseBodyDataDataEntityList) GoString() string {
	return s.String()
}

func (s *GetMetaTablePartitionResponseBodyDataDataEntityList) SetComment(v string) *GetMetaTablePartitionResponseBodyDataDataEntityList {
	s.Comment = &v
	return s
}

func (s *GetMetaTablePartitionResponseBodyDataDataEntityList) SetCreateTime(v int64) *GetMetaTablePartitionResponseBodyDataDataEntityList {
	s.CreateTime = &v
	return s
}

func (s *GetMetaTablePartitionResponseBodyDataDataEntityList) SetDataSize(v int64) *GetMetaTablePartitionResponseBodyDataDataEntityList {
	s.DataSize = &v
	return s
}

func (s *GetMetaTablePartitionResponseBodyDataDataEntityList) SetModifiedTime(v int64) *GetMetaTablePartitionResponseBodyDataDataEntityList {
	s.ModifiedTime = &v
	return s
}

func (s *GetMetaTablePartitionResponseBodyDataDataEntityList) SetPartitionGuid(v string) *GetMetaTablePartitionResponseBodyDataDataEntityList {
	s.PartitionGuid = &v
	return s
}

func (s *GetMetaTablePartitionResponseBodyDataDataEntityList) SetPartitionLocation(v string) *GetMetaTablePartitionResponseBodyDataDataEntityList {
	s.PartitionLocation = &v
	return s
}

func (s *GetMetaTablePartitionResponseBodyDataDataEntityList) SetPartitionName(v string) *GetMetaTablePartitionResponseBodyDataDataEntityList {
	s.PartitionName = &v
	return s
}

func (s *GetMetaTablePartitionResponseBodyDataDataEntityList) SetPartitionPath(v string) *GetMetaTablePartitionResponseBodyDataDataEntityList {
	s.PartitionPath = &v
	return s
}

func (s *GetMetaTablePartitionResponseBodyDataDataEntityList) SetPartitionType(v string) *GetMetaTablePartitionResponseBodyDataDataEntityList {
	s.PartitionType = &v
	return s
}

func (s *GetMetaTablePartitionResponseBodyDataDataEntityList) SetRecordCount(v int64) *GetMetaTablePartitionResponseBodyDataDataEntityList {
	s.RecordCount = &v
	return s
}

func (s *GetMetaTablePartitionResponseBodyDataDataEntityList) SetTableGuid(v string) *GetMetaTablePartitionResponseBodyDataDataEntityList {
	s.TableGuid = &v
	return s
}

type GetMetaTablePartitionResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaTablePartitionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaTablePartitionResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTablePartitionResponse) GoString() string {
	return s.String()
}

func (s *GetMetaTablePartitionResponse) SetHeaders(v map[string]*string) *GetMetaTablePartitionResponse {
	s.Headers = v
	return s
}

func (s *GetMetaTablePartitionResponse) SetStatusCode(v int32) *GetMetaTablePartitionResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaTablePartitionResponse) SetBody(v *GetMetaTablePartitionResponseBody) *GetMetaTablePartitionResponse {
	s.Body = v
	return s
}

type GetMetaTableProducingTasksRequest struct {
	ClusterId      *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	DbName         *string `json:"DbName,omitempty" xml:"DbName,omitempty"`
	SchemaName     *string `json:"SchemaName,omitempty" xml:"SchemaName,omitempty"`
	TableGuid      *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	TableName      *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetMetaTableProducingTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableProducingTasksRequest) GoString() string {
	return s.String()
}

func (s *GetMetaTableProducingTasksRequest) SetClusterId(v string) *GetMetaTableProducingTasksRequest {
	s.ClusterId = &v
	return s
}

func (s *GetMetaTableProducingTasksRequest) SetDataSourceType(v string) *GetMetaTableProducingTasksRequest {
	s.DataSourceType = &v
	return s
}

func (s *GetMetaTableProducingTasksRequest) SetDbName(v string) *GetMetaTableProducingTasksRequest {
	s.DbName = &v
	return s
}

func (s *GetMetaTableProducingTasksRequest) SetSchemaName(v string) *GetMetaTableProducingTasksRequest {
	s.SchemaName = &v
	return s
}

func (s *GetMetaTableProducingTasksRequest) SetTableGuid(v string) *GetMetaTableProducingTasksRequest {
	s.TableGuid = &v
	return s
}

func (s *GetMetaTableProducingTasksRequest) SetTableName(v string) *GetMetaTableProducingTasksRequest {
	s.TableName = &v
	return s
}

type GetMetaTableProducingTasksResponseBody struct {
	Data           []*GetMetaTableProducingTasksResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	ErrorCode      *string                                       `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string                                       `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32                                        `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                                         `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaTableProducingTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableProducingTasksResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaTableProducingTasksResponseBody) SetData(v []*GetMetaTableProducingTasksResponseBodyData) *GetMetaTableProducingTasksResponseBody {
	s.Data = v
	return s
}

func (s *GetMetaTableProducingTasksResponseBody) SetErrorCode(v string) *GetMetaTableProducingTasksResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaTableProducingTasksResponseBody) SetErrorMessage(v string) *GetMetaTableProducingTasksResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaTableProducingTasksResponseBody) SetHttpStatusCode(v int32) *GetMetaTableProducingTasksResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMetaTableProducingTasksResponseBody) SetRequestId(v string) *GetMetaTableProducingTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaTableProducingTasksResponseBody) SetSuccess(v bool) *GetMetaTableProducingTasksResponseBody {
	s.Success = &v
	return s
}

type GetMetaTableProducingTasksResponseBodyData struct {
	TaskId   *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
}

func (s GetMetaTableProducingTasksResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableProducingTasksResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMetaTableProducingTasksResponseBodyData) SetTaskId(v string) *GetMetaTableProducingTasksResponseBodyData {
	s.TaskId = &v
	return s
}

func (s *GetMetaTableProducingTasksResponseBodyData) SetTaskName(v string) *GetMetaTableProducingTasksResponseBodyData {
	s.TaskName = &v
	return s
}

type GetMetaTableProducingTasksResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaTableProducingTasksResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaTableProducingTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableProducingTasksResponse) GoString() string {
	return s.String()
}

func (s *GetMetaTableProducingTasksResponse) SetHeaders(v map[string]*string) *GetMetaTableProducingTasksResponse {
	s.Headers = v
	return s
}

func (s *GetMetaTableProducingTasksResponse) SetStatusCode(v int32) *GetMetaTableProducingTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaTableProducingTasksResponse) SetBody(v *GetMetaTableProducingTasksResponseBody) *GetMetaTableProducingTasksResponse {
	s.Body = v
	return s
}

type GetMetaTableThemeLevelRequest struct {
	// The type of the data source. Set the value to odps.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The globally unique identifier (GUID) of the table. Specify the GUID in the format of odps.${projectName}.${tableName}.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
}

func (s GetMetaTableThemeLevelRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableThemeLevelRequest) GoString() string {
	return s.String()
}

func (s *GetMetaTableThemeLevelRequest) SetDataSourceType(v string) *GetMetaTableThemeLevelRequest {
	s.DataSourceType = &v
	return s
}

func (s *GetMetaTableThemeLevelRequest) SetTableGuid(v string) *GetMetaTableThemeLevelRequest {
	s.TableGuid = &v
	return s
}

type GetMetaTableThemeLevelResponseBody struct {
	// The returned data.
	Entity *GetMetaTableThemeLevelResponseBodyEntity `json:"Entity,omitempty" xml:"Entity,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can troubleshoot errors based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMetaTableThemeLevelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableThemeLevelResponseBody) GoString() string {
	return s.String()
}

func (s *GetMetaTableThemeLevelResponseBody) SetEntity(v *GetMetaTableThemeLevelResponseBodyEntity) *GetMetaTableThemeLevelResponseBody {
	s.Entity = v
	return s
}

func (s *GetMetaTableThemeLevelResponseBody) SetErrorCode(v string) *GetMetaTableThemeLevelResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMetaTableThemeLevelResponseBody) SetErrorMessage(v string) *GetMetaTableThemeLevelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMetaTableThemeLevelResponseBody) SetHttpStatusCode(v int32) *GetMetaTableThemeLevelResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMetaTableThemeLevelResponseBody) SetRequestId(v string) *GetMetaTableThemeLevelResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMetaTableThemeLevelResponseBody) SetSuccess(v bool) *GetMetaTableThemeLevelResponseBody {
	s.Success = &v
	return s
}

type GetMetaTableThemeLevelResponseBodyEntity struct {
	// The information about the table level.
	Level []*GetMetaTableThemeLevelResponseBodyEntityLevel `json:"Level,omitempty" xml:"Level,omitempty" type:"Repeated"`
	// The information about the table folder.
	Theme []*GetMetaTableThemeLevelResponseBodyEntityTheme `json:"Theme,omitempty" xml:"Theme,omitempty" type:"Repeated"`
}

func (s GetMetaTableThemeLevelResponseBodyEntity) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableThemeLevelResponseBodyEntity) GoString() string {
	return s.String()
}

func (s *GetMetaTableThemeLevelResponseBodyEntity) SetLevel(v []*GetMetaTableThemeLevelResponseBodyEntityLevel) *GetMetaTableThemeLevelResponseBodyEntity {
	s.Level = v
	return s
}

func (s *GetMetaTableThemeLevelResponseBodyEntity) SetTheme(v []*GetMetaTableThemeLevelResponseBodyEntityTheme) *GetMetaTableThemeLevelResponseBodyEntity {
	s.Theme = v
	return s
}

type GetMetaTableThemeLevelResponseBodyEntityLevel struct {
	// The description of the table level.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the table level.
	LevelId *int64 `json:"LevelId,omitempty" xml:"LevelId,omitempty"`
	// The name of the table level.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the table level. Valid values:
	//
	// *   1: indicates the logical level.
	// *   2: indicates the physical level.
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetMetaTableThemeLevelResponseBodyEntityLevel) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableThemeLevelResponseBodyEntityLevel) GoString() string {
	return s.String()
}

func (s *GetMetaTableThemeLevelResponseBodyEntityLevel) SetDescription(v string) *GetMetaTableThemeLevelResponseBodyEntityLevel {
	s.Description = &v
	return s
}

func (s *GetMetaTableThemeLevelResponseBodyEntityLevel) SetLevelId(v int64) *GetMetaTableThemeLevelResponseBodyEntityLevel {
	s.LevelId = &v
	return s
}

func (s *GetMetaTableThemeLevelResponseBodyEntityLevel) SetName(v string) *GetMetaTableThemeLevelResponseBodyEntityLevel {
	s.Name = &v
	return s
}

func (s *GetMetaTableThemeLevelResponseBodyEntityLevel) SetType(v int32) *GetMetaTableThemeLevelResponseBodyEntityLevel {
	s.Type = &v
	return s
}

type GetMetaTableThemeLevelResponseBodyEntityTheme struct {
	// The level of the table folder. Valid values:
	//
	// *   1: indicates a table folder of level 1.
	// *   2: indicates a table folder of level 2.
	Level *int32 `json:"Level,omitempty" xml:"Level,omitempty"`
	// The name of the table folder.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the parent table folder.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The ID of the table folder.
	ThemeId *int64 `json:"ThemeId,omitempty" xml:"ThemeId,omitempty"`
}

func (s GetMetaTableThemeLevelResponseBodyEntityTheme) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableThemeLevelResponseBodyEntityTheme) GoString() string {
	return s.String()
}

func (s *GetMetaTableThemeLevelResponseBodyEntityTheme) SetLevel(v int32) *GetMetaTableThemeLevelResponseBodyEntityTheme {
	s.Level = &v
	return s
}

func (s *GetMetaTableThemeLevelResponseBodyEntityTheme) SetName(v string) *GetMetaTableThemeLevelResponseBodyEntityTheme {
	s.Name = &v
	return s
}

func (s *GetMetaTableThemeLevelResponseBodyEntityTheme) SetParentId(v int64) *GetMetaTableThemeLevelResponseBodyEntityTheme {
	s.ParentId = &v
	return s
}

func (s *GetMetaTableThemeLevelResponseBodyEntityTheme) SetThemeId(v int64) *GetMetaTableThemeLevelResponseBodyEntityTheme {
	s.ThemeId = &v
	return s
}

type GetMetaTableThemeLevelResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMetaTableThemeLevelResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMetaTableThemeLevelResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMetaTableThemeLevelResponse) GoString() string {
	return s.String()
}

func (s *GetMetaTableThemeLevelResponse) SetHeaders(v map[string]*string) *GetMetaTableThemeLevelResponse {
	s.Headers = v
	return s
}

func (s *GetMetaTableThemeLevelResponse) SetStatusCode(v int32) *GetMetaTableThemeLevelResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMetaTableThemeLevelResponse) SetBody(v *GetMetaTableThemeLevelResponseBody) *GetMetaTableThemeLevelResponse {
	s.Body = v
	return s
}

type GetMigrationProcessRequest struct {
	// The ID of the migration package. You can call the CreateImportMigration operation to query the ID.
	MigrationId *int64 `json:"MigrationId,omitempty" xml:"MigrationId,omitempty"`
	// The ID of the workspace. You can go to the Workspace Management page of the DataWorks console to view the ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetMigrationProcessRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMigrationProcessRequest) GoString() string {
	return s.String()
}

func (s *GetMigrationProcessRequest) SetMigrationId(v int64) *GetMigrationProcessRequest {
	s.MigrationId = &v
	return s
}

func (s *GetMigrationProcessRequest) SetProjectId(v int64) *GetMigrationProcessRequest {
	s.ProjectId = &v
	return s
}

type GetMigrationProcessResponseBody struct {
	// The progress information of the migration task, including the names of all steps in and status of the migration task.
	Data []*GetMigrationProcessResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMigrationProcessResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMigrationProcessResponseBody) GoString() string {
	return s.String()
}

func (s *GetMigrationProcessResponseBody) SetData(v []*GetMigrationProcessResponseBodyData) *GetMigrationProcessResponseBody {
	s.Data = v
	return s
}

func (s *GetMigrationProcessResponseBody) SetErrorCode(v string) *GetMigrationProcessResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetMigrationProcessResponseBody) SetErrorMessage(v string) *GetMigrationProcessResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetMigrationProcessResponseBody) SetHttpStatusCode(v int32) *GetMigrationProcessResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetMigrationProcessResponseBody) SetRequestId(v string) *GetMigrationProcessResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMigrationProcessResponseBody) SetSuccess(v bool) *GetMigrationProcessResponseBody {
	s.Success = &v
	return s
}

type GetMigrationProcessResponseBodyData struct {
	// The name of the step in the migration task.
	TaskName *string `json:"TaskName,omitempty" xml:"TaskName,omitempty"`
	// The running status of the step in the migration task. Valid values:
	//
	// *   INT
	// *   RUNNING
	// *   FAILURE
	// *   SUCCESS
	TaskStatus *string `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
}

func (s GetMigrationProcessResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMigrationProcessResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMigrationProcessResponseBodyData) SetTaskName(v string) *GetMigrationProcessResponseBodyData {
	s.TaskName = &v
	return s
}

func (s *GetMigrationProcessResponseBodyData) SetTaskStatus(v string) *GetMigrationProcessResponseBodyData {
	s.TaskStatus = &v
	return s
}

type GetMigrationProcessResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMigrationProcessResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMigrationProcessResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMigrationProcessResponse) GoString() string {
	return s.String()
}

func (s *GetMigrationProcessResponse) SetHeaders(v map[string]*string) *GetMigrationProcessResponse {
	s.Headers = v
	return s
}

func (s *GetMigrationProcessResponse) SetStatusCode(v int32) *GetMigrationProcessResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMigrationProcessResponse) SetBody(v *GetMigrationProcessResponseBody) *GetMigrationProcessResponse {
	s.Body = v
	return s
}

type GetMigrationSummaryRequest struct {
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	MigrationId *int64 `json:"MigrationId,omitempty" xml:"MigrationId,omitempty"`
	// The ID of the migration task.
	//
	// You can call the [CreateImportMigration](~~2809123~~) operation to obtain the ID of the import task and call the [CreateExportMigration](~~3241603~~) operation to obtain the ID of the export task.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetMigrationSummaryRequest) String() string {
	return tea.Prettify(s)
}

func (s GetMigrationSummaryRequest) GoString() string {
	return s.String()
}

func (s *GetMigrationSummaryRequest) SetMigrationId(v int64) *GetMigrationSummaryRequest {
	s.MigrationId = &v
	return s
}

func (s *GetMigrationSummaryRequest) SetProjectId(v int64) *GetMigrationSummaryRequest {
	s.ProjectId = &v
	return s
}

type GetMigrationSummaryResponseBody struct {
	// The ID of the migration task.
	Data *GetMigrationSummaryResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails. You can locate the error based on the request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of the migration task.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetMigrationSummaryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetMigrationSummaryResponseBody) GoString() string {
	return s.String()
}

func (s *GetMigrationSummaryResponseBody) SetData(v *GetMigrationSummaryResponseBodyData) *GetMigrationSummaryResponseBody {
	s.Data = v
	return s
}

func (s *GetMigrationSummaryResponseBody) SetRequestId(v string) *GetMigrationSummaryResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetMigrationSummaryResponseBody) SetSuccess(v bool) *GetMigrationSummaryResponseBody {
	s.Success = &v
	return s
}

type GetMigrationSummaryResponseBodyData struct {
	// The ID of the user who manages the migration task.
	CreateUser  *string `json:"CreateUser,omitempty" xml:"CreateUser,omitempty"`
	DownloadUrl *string `json:"DownloadUrl,omitempty" xml:"DownloadUrl,omitempty"`
	// The time when the migration task was modified.
	GmtCreate *int64 `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The ID of the user who creates the migration task.
	GmtModified *int64 `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The name of the migration task.
	MigrationId *int64 `json:"MigrationId,omitempty" xml:"MigrationId,omitempty"`
	// The time when the migration task was created.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The status of the migration task. Valid values:
	//
	// *   INIT: The migration task is initiating.
	// *   EDITING: The migration task is being edited.
	// *   IMPORTING: The migration task is importing data objects.
	// *   IMPORT_ERROR: The migration task fails to import data objects.
	// *   IMPORT_SUCCESS: Data objects are imported.
	// *   EXPORTING: The migration task is exporting data objects.
	// *   EXPORT_ERROR: The migration task fails to export data objects.
	// *   EXPORT_SUCCESS: The migration task successfully exports data objects.
	// *   REVOKED: The migration task is canceled.
	// *   PARTIAL_SUCCESS: The migration task successfully imports or exports only some data objects.
	OpUser *string `json:"OpUser,omitempty" xml:"OpUser,omitempty"`
	// The URL that is used to download the package of the export task.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the DataWorks workspace.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetMigrationSummaryResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetMigrationSummaryResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetMigrationSummaryResponseBodyData) SetCreateUser(v string) *GetMigrationSummaryResponseBodyData {
	s.CreateUser = &v
	return s
}

func (s *GetMigrationSummaryResponseBodyData) SetDownloadUrl(v string) *GetMigrationSummaryResponseBodyData {
	s.DownloadUrl = &v
	return s
}

func (s *GetMigrationSummaryResponseBodyData) SetGmtCreate(v int64) *GetMigrationSummaryResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetMigrationSummaryResponseBodyData) SetGmtModified(v int64) *GetMigrationSummaryResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetMigrationSummaryResponseBodyData) SetMigrationId(v int64) *GetMigrationSummaryResponseBodyData {
	s.MigrationId = &v
	return s
}

func (s *GetMigrationSummaryResponseBodyData) SetName(v string) *GetMigrationSummaryResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetMigrationSummaryResponseBodyData) SetOpUser(v string) *GetMigrationSummaryResponseBodyData {
	s.OpUser = &v
	return s
}

func (s *GetMigrationSummaryResponseBodyData) SetProjectId(v int64) *GetMigrationSummaryResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetMigrationSummaryResponseBodyData) SetStatus(v string) *GetMigrationSummaryResponseBodyData {
	s.Status = &v
	return s
}

type GetMigrationSummaryResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetMigrationSummaryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetMigrationSummaryResponse) String() string {
	return tea.Prettify(s)
}

func (s GetMigrationSummaryResponse) GoString() string {
	return s.String()
}

func (s *GetMigrationSummaryResponse) SetHeaders(v map[string]*string) *GetMigrationSummaryResponse {
	s.Headers = v
	return s
}

func (s *GetMigrationSummaryResponse) SetStatusCode(v int32) *GetMigrationSummaryResponse {
	s.StatusCode = &v
	return s
}

func (s *GetMigrationSummaryResponse) SetBody(v *GetMigrationSummaryResponseBody) *GetMigrationSummaryResponse {
	s.Body = v
	return s
}

type GetNodeRequest struct {
	// The interval at which the node is rerun after the node fails to run.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The priority of the node. Valid values: 1, 3, 5, 7, and 8.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s GetNodeRequest) String() string {
	return tea.Prettify(s)
}

func (s GetNodeRequest) GoString() string {
	return s.String()
}

func (s *GetNodeRequest) SetNodeId(v int64) *GetNodeRequest {
	s.NodeId = &v
	return s
}

func (s *GetNodeRequest) SetProjectEnv(v string) *GetNodeRequest {
	s.ProjectEnv = &v
	return s
}

type GetNodeResponseBody struct {
	// The details of the node.
	Data *GetNodeResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the node. You can call the [ListNodes](~~173979~~) operation to query the node ID.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The connection string.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The operation that you want to perform. Set the value to **GetNode**.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// Other parameters.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the workflow.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetNodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetNodeResponseBody) GoString() string {
	return s.String()
}

func (s *GetNodeResponseBody) SetData(v *GetNodeResponseBodyData) *GetNodeResponseBody {
	s.Data = v
	return s
}

func (s *GetNodeResponseBody) SetErrorCode(v string) *GetNodeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetNodeResponseBody) SetErrorMessage(v string) *GetNodeResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetNodeResponseBody) SetHttpStatusCode(v int32) *GetNodeResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetNodeResponseBody) SetRequestId(v string) *GetNodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetNodeResponseBody) SetSuccess(v bool) *GetNodeResponseBody {
	s.Success = &v
	return s
}

type GetNodeResponseBodyData struct {
	// The description of the node.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The operation that you want to perform. Set the value to **GetNode**.
	BusinessId *int64 `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV.
	Connection *string `json:"Connection,omitempty" xml:"Connection,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV.
	CronExpress *string `json:"CronExpress,omitempty" xml:"CronExpress,omitempty"`
	// The name of the resource group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the node. You can call the [ListNodes](~~173979~~) operation to query the node ID.
	DqcDescription *string `json:"DqcDescription,omitempty" xml:"DqcDescription,omitempty"`
	// The error message returned.
	DqcType  *int32 `json:"DqcType,omitempty" xml:"DqcType,omitempty"`
	FileType *int32 `json:"FileType,omitempty" xml:"FileType,omitempty"`
	// The HTTP status code returned.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The scheduling type of the node. Valid values:
	//
	// *   NORMAL: The node is an auto triggered node.
	// *   MANUAL: The node is a manually triggered node. Manually triggered nodes cannot be automatically triggered.
	// *   PAUSE: The node is a paused node.
	// *   SKIP: The node is a dry-run node. Dry-run nodes are started as scheduled but the system sets the status of the nodes to successful when it starts to run them.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The ID of the node.
	OwnerId *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The CRON expression returned.
	ParamValues *string `json:"ParamValues,omitempty" xml:"ParamValues,omitempty"`
	// The HTTP status code returned.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the owner of the node.
	ProgramType *string `json:"ProgramType,omitempty" xml:"ProgramType,omitempty"`
	// Indicates whether the node can be rerun.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// Indicates whether the node is associated with Data Quality. Valid values: 0 and 1. A value of 0 indicates that the node is associated with Data Quality. A value of 1 indicates that the node is not associated with Data Quality.
	RelatedFlowId *int64 `json:"RelatedFlowId,omitempty" xml:"RelatedFlowId,omitempty"`
	// The ID of the workflow to which the node belongs.
	RepeatInterval *int64 `json:"RepeatInterval,omitempty" xml:"RepeatInterval,omitempty"`
	// The type of the node.
	Repeatability      *string `json:"Repeatability,omitempty" xml:"Repeatability,omitempty"`
	ResGroupIdentifier *string `json:"ResGroupIdentifier,omitempty" xml:"ResGroupIdentifier,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	ResGroupName *string `json:"ResGroupName,omitempty" xml:"ResGroupName,omitempty"`
	// The ID of the workspace.
	SchedulerType *string `json:"SchedulerType,omitempty" xml:"SchedulerType,omitempty"`
}

func (s GetNodeResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetNodeResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetNodeResponseBodyData) SetBaselineId(v int64) *GetNodeResponseBodyData {
	s.BaselineId = &v
	return s
}

func (s *GetNodeResponseBodyData) SetBusinessId(v int64) *GetNodeResponseBodyData {
	s.BusinessId = &v
	return s
}

func (s *GetNodeResponseBodyData) SetConnection(v string) *GetNodeResponseBodyData {
	s.Connection = &v
	return s
}

func (s *GetNodeResponseBodyData) SetCronExpress(v string) *GetNodeResponseBodyData {
	s.CronExpress = &v
	return s
}

func (s *GetNodeResponseBodyData) SetDescription(v string) *GetNodeResponseBodyData {
	s.Description = &v
	return s
}

func (s *GetNodeResponseBodyData) SetDqcDescription(v string) *GetNodeResponseBodyData {
	s.DqcDescription = &v
	return s
}

func (s *GetNodeResponseBodyData) SetDqcType(v int32) *GetNodeResponseBodyData {
	s.DqcType = &v
	return s
}

func (s *GetNodeResponseBodyData) SetFileType(v int32) *GetNodeResponseBodyData {
	s.FileType = &v
	return s
}

func (s *GetNodeResponseBodyData) SetNodeId(v int64) *GetNodeResponseBodyData {
	s.NodeId = &v
	return s
}

func (s *GetNodeResponseBodyData) SetNodeName(v string) *GetNodeResponseBodyData {
	s.NodeName = &v
	return s
}

func (s *GetNodeResponseBodyData) SetOwnerId(v string) *GetNodeResponseBodyData {
	s.OwnerId = &v
	return s
}

func (s *GetNodeResponseBodyData) SetParamValues(v string) *GetNodeResponseBodyData {
	s.ParamValues = &v
	return s
}

func (s *GetNodeResponseBodyData) SetPriority(v int32) *GetNodeResponseBodyData {
	s.Priority = &v
	return s
}

func (s *GetNodeResponseBodyData) SetProgramType(v string) *GetNodeResponseBodyData {
	s.ProgramType = &v
	return s
}

func (s *GetNodeResponseBodyData) SetProjectId(v int64) *GetNodeResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetNodeResponseBodyData) SetRelatedFlowId(v int64) *GetNodeResponseBodyData {
	s.RelatedFlowId = &v
	return s
}

func (s *GetNodeResponseBodyData) SetRepeatInterval(v int64) *GetNodeResponseBodyData {
	s.RepeatInterval = &v
	return s
}

func (s *GetNodeResponseBodyData) SetRepeatability(v string) *GetNodeResponseBodyData {
	s.Repeatability = &v
	return s
}

func (s *GetNodeResponseBodyData) SetResGroupIdentifier(v string) *GetNodeResponseBodyData {
	s.ResGroupIdentifier = &v
	return s
}

func (s *GetNodeResponseBodyData) SetResGroupName(v string) *GetNodeResponseBodyData {
	s.ResGroupName = &v
	return s
}

func (s *GetNodeResponseBodyData) SetSchedulerType(v string) *GetNodeResponseBodyData {
	s.SchedulerType = &v
	return s
}

type GetNodeResponse struct {
	Headers    map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetNodeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetNodeResponse) String() string {
	return tea.Prettify(s)
}

func (s GetNodeResponse) GoString() string {
	return s.String()
}

func (s *GetNodeResponse) SetHeaders(v map[string]*string) *GetNodeResponse {
	s.Headers = v
	return s
}

func (s *GetNodeResponse) SetStatusCode(v int32) *GetNodeResponse {
	s.StatusCode = &v
	return s
}

func (s *GetNodeResponse) SetBody(v *GetNodeResponseBody) *GetNodeResponse {
	s.Body = v
	return s
}

type GetNodeChildrenRequest struct {
	// The ID of the node. You can go to the Operation Center page in the DataWorks console to view the ID.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV. The value PROD indicates the production environment, and the value DEV indicates the development environment.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s GetNodeChildrenRequest) String() string {
	return tea.Prettify(s)
}

func (s GetNodeChildrenRequest) GoString() string {
	return s.String()
}

func (s *GetNodeChildrenRequest) SetNodeId(v int64) *GetNodeChildrenRequest {
	s.NodeId = &v
	return s
}

func (s *GetNodeChildrenRequest) SetProjectEnv(v string) *GetNodeChildrenRequest {
	s.ProjectEnv = &v
	return s
}

type GetNodeChildrenResponseBody struct {
	// The information of the descendant nodes.
	Data *GetNodeChildrenResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetNodeChildrenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetNodeChildrenResponseBody) GoString() string {
	return s.String()
}

func (s *GetNodeChildrenResponseBody) SetData(v *GetNodeChildrenResponseBodyData) *GetNodeChildrenResponseBody {
	s.Data = v
	return s
}

func (s *GetNodeChildrenResponseBody) SetErrorCode(v string) *GetNodeChildrenResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetNodeChildrenResponseBody) SetErrorMessage(v string) *GetNodeChildrenResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetNodeChildrenResponseBody) SetHttpStatusCode(v int32) *GetNodeChildrenResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetNodeChildrenResponseBody) SetRequestId(v string) *GetNodeChildrenResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetNodeChildrenResponseBody) SetSuccess(v bool) *GetNodeChildrenResponseBody {
	s.Success = &v
	return s
}

type GetNodeChildrenResponseBodyData struct {
	// The descendant nodes returned.
	Nodes []*GetNodeChildrenResponseBodyDataNodes `json:"Nodes,omitempty" xml:"Nodes,omitempty" type:"Repeated"`
}

func (s GetNodeChildrenResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetNodeChildrenResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetNodeChildrenResponseBodyData) SetNodes(v []*GetNodeChildrenResponseBodyDataNodes) *GetNodeChildrenResponseBodyData {
	s.Nodes = v
	return s
}

type GetNodeChildrenResponseBodyDataNodes struct {
	// The ID of the baseline.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The cron expression. Cron expressions are used to run auto triggered nodes.
	CronExpress *string `json:"CronExpress,omitempty" xml:"CronExpress,omitempty"`
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The ID of the Alibaba Cloud account used by the node owner.
	OwnerId *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The priority of the node. Valid values: 1 to 8. A large value indicates a high priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of the node.
	ProgramType *string `json:"ProgramType,omitempty" xml:"ProgramType,omitempty"`
	// The ID of the workspace to which the node belongs.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// Indicates whether the node can be rerun if the node fails to run. Valid values:
	//
	// *   true: indicates that the node can be rerun.
	// *   false: indicates that the node cannot be rerun.
	Repeatability *bool `json:"Repeatability,omitempty" xml:"Repeatability,omitempty"`
	// The scheduling type of the node. Valid values:
	//
	// *   NORMAL: indicates that the node is an auto triggered node.
	// *   MANUAL: indicates that node is a manually triggered node.
	// *   PAUSE: indicates that the node is a paused node. Paused nodes are started as scheduled but the system sets the status of the nodes to failed when it starts to run them.
	// *   SKIP: indicates that the node is a dry-run node. Dry-run nodes are started as scheduled but the system sets the status of the nodes to successful when it starts to run them.
	SchedulerType *string `json:"SchedulerType,omitempty" xml:"SchedulerType,omitempty"`
}

func (s GetNodeChildrenResponseBodyDataNodes) String() string {
	return tea.Prettify(s)
}

func (s GetNodeChildrenResponseBodyDataNodes) GoString() string {
	return s.String()
}

func (s *GetNodeChildrenResponseBodyDataNodes) SetBaselineId(v int64) *GetNodeChildrenResponseBodyDataNodes {
	s.BaselineId = &v
	return s
}

func (s *GetNodeChildrenResponseBodyDataNodes) SetCronExpress(v string) *GetNodeChildrenResponseBodyDataNodes {
	s.CronExpress = &v
	return s
}

func (s *GetNodeChildrenResponseBodyDataNodes) SetNodeId(v int64) *GetNodeChildrenResponseBodyDataNodes {
	s.NodeId = &v
	return s
}

func (s *GetNodeChildrenResponseBodyDataNodes) SetNodeName(v string) *GetNodeChildrenResponseBodyDataNodes {
	s.NodeName = &v
	return s
}

func (s *GetNodeChildrenResponseBodyDataNodes) SetOwnerId(v string) *GetNodeChildrenResponseBodyDataNodes {
	s.OwnerId = &v
	return s
}

func (s *GetNodeChildrenResponseBodyDataNodes) SetPriority(v int32) *GetNodeChildrenResponseBodyDataNodes {
	s.Priority = &v
	return s
}

func (s *GetNodeChildrenResponseBodyDataNodes) SetProgramType(v string) *GetNodeChildrenResponseBodyDataNodes {
	s.ProgramType = &v
	return s
}

func (s *GetNodeChildrenResponseBodyDataNodes) SetProjectId(v int64) *GetNodeChildrenResponseBodyDataNodes {
	s.ProjectId = &v
	return s
}

func (s *GetNodeChildrenResponseBodyDataNodes) SetRepeatability(v bool) *GetNodeChildrenResponseBodyDataNodes {
	s.Repeatability = &v
	return s
}

func (s *GetNodeChildrenResponseBodyDataNodes) SetSchedulerType(v string) *GetNodeChildrenResponseBodyDataNodes {
	s.SchedulerType = &v
	return s
}

type GetNodeChildrenResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetNodeChildrenResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetNodeChildrenResponse) String() string {
	return tea.Prettify(s)
}

func (s GetNodeChildrenResponse) GoString() string {
	return s.String()
}

func (s *GetNodeChildrenResponse) SetHeaders(v map[string]*string) *GetNodeChildrenResponse {
	s.Headers = v
	return s
}

func (s *GetNodeChildrenResponse) SetStatusCode(v int32) *GetNodeChildrenResponse {
	s.StatusCode = &v
	return s
}

func (s *GetNodeChildrenResponse) SetBody(v *GetNodeChildrenResponseBody) *GetNodeChildrenResponse {
	s.Body = v
	return s
}

type GetNodeCodeRequest struct {
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s GetNodeCodeRequest) String() string {
	return tea.Prettify(s)
}

func (s GetNodeCodeRequest) GoString() string {
	return s.String()
}

func (s *GetNodeCodeRequest) SetNodeId(v int64) *GetNodeCodeRequest {
	s.NodeId = &v
	return s
}

func (s *GetNodeCodeRequest) SetProjectEnv(v string) *GetNodeCodeRequest {
	s.ProjectEnv = &v
	return s
}

type GetNodeCodeResponseBody struct {
	// The code of the node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request, You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetNodeCodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetNodeCodeResponseBody) GoString() string {
	return s.String()
}

func (s *GetNodeCodeResponseBody) SetData(v string) *GetNodeCodeResponseBody {
	s.Data = &v
	return s
}

func (s *GetNodeCodeResponseBody) SetErrorCode(v string) *GetNodeCodeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetNodeCodeResponseBody) SetErrorMessage(v string) *GetNodeCodeResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetNodeCodeResponseBody) SetHttpStatusCode(v int32) *GetNodeCodeResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetNodeCodeResponseBody) SetRequestId(v string) *GetNodeCodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetNodeCodeResponseBody) SetSuccess(v bool) *GetNodeCodeResponseBody {
	s.Success = &v
	return s
}

type GetNodeCodeResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetNodeCodeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetNodeCodeResponse) String() string {
	return tea.Prettify(s)
}

func (s GetNodeCodeResponse) GoString() string {
	return s.String()
}

func (s *GetNodeCodeResponse) SetHeaders(v map[string]*string) *GetNodeCodeResponse {
	s.Headers = v
	return s
}

func (s *GetNodeCodeResponse) SetStatusCode(v int32) *GetNodeCodeResponse {
	s.StatusCode = &v
	return s
}

func (s *GetNodeCodeResponse) SetBody(v *GetNodeCodeResponseBody) *GetNodeCodeResponse {
	s.Body = v
	return s
}

type GetNodeOnBaselineRequest struct {
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
}

func (s GetNodeOnBaselineRequest) String() string {
	return tea.Prettify(s)
}

func (s GetNodeOnBaselineRequest) GoString() string {
	return s.String()
}

func (s *GetNodeOnBaselineRequest) SetBaselineId(v int64) *GetNodeOnBaselineRequest {
	s.BaselineId = &v
	return s
}

type GetNodeOnBaselineResponseBody struct {
	Data           []*GetNodeOnBaselineResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	ErrorCode      *string                              `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string                              `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32                               `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string                              `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *string                              `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetNodeOnBaselineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetNodeOnBaselineResponseBody) GoString() string {
	return s.String()
}

func (s *GetNodeOnBaselineResponseBody) SetData(v []*GetNodeOnBaselineResponseBodyData) *GetNodeOnBaselineResponseBody {
	s.Data = v
	return s
}

func (s *GetNodeOnBaselineResponseBody) SetErrorCode(v string) *GetNodeOnBaselineResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetNodeOnBaselineResponseBody) SetErrorMessage(v string) *GetNodeOnBaselineResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetNodeOnBaselineResponseBody) SetHttpStatusCode(v int32) *GetNodeOnBaselineResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetNodeOnBaselineResponseBody) SetRequestId(v string) *GetNodeOnBaselineResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetNodeOnBaselineResponseBody) SetSuccess(v string) *GetNodeOnBaselineResponseBody {
	s.Success = &v
	return s
}

type GetNodeOnBaselineResponseBodyData struct {
	NodeId    *int64  `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	NodeName  *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	Owner     *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	ProjectId *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetNodeOnBaselineResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetNodeOnBaselineResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetNodeOnBaselineResponseBodyData) SetNodeId(v int64) *GetNodeOnBaselineResponseBodyData {
	s.NodeId = &v
	return s
}

func (s *GetNodeOnBaselineResponseBodyData) SetNodeName(v string) *GetNodeOnBaselineResponseBodyData {
	s.NodeName = &v
	return s
}

func (s *GetNodeOnBaselineResponseBodyData) SetOwner(v string) *GetNodeOnBaselineResponseBodyData {
	s.Owner = &v
	return s
}

func (s *GetNodeOnBaselineResponseBodyData) SetProjectId(v int64) *GetNodeOnBaselineResponseBodyData {
	s.ProjectId = &v
	return s
}

type GetNodeOnBaselineResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetNodeOnBaselineResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetNodeOnBaselineResponse) String() string {
	return tea.Prettify(s)
}

func (s GetNodeOnBaselineResponse) GoString() string {
	return s.String()
}

func (s *GetNodeOnBaselineResponse) SetHeaders(v map[string]*string) *GetNodeOnBaselineResponse {
	s.Headers = v
	return s
}

func (s *GetNodeOnBaselineResponse) SetStatusCode(v int32) *GetNodeOnBaselineResponse {
	s.StatusCode = &v
	return s
}

func (s *GetNodeOnBaselineResponse) SetBody(v *GetNodeOnBaselineResponseBody) *GetNodeOnBaselineResponse {
	s.Body = v
	return s
}

type GetNodeParentsRequest struct {
	// The ID of the node. You can go to the Operation Center page in the DataWorks console to view the node ID.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV. The value PROD indicates the production environment, and the value DEV indicates the development environment.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s GetNodeParentsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetNodeParentsRequest) GoString() string {
	return s.String()
}

func (s *GetNodeParentsRequest) SetNodeId(v int64) *GetNodeParentsRequest {
	s.NodeId = &v
	return s
}

func (s *GetNodeParentsRequest) SetProjectEnv(v string) *GetNodeParentsRequest {
	s.ProjectEnv = &v
	return s
}

type GetNodeParentsResponseBody struct {
	// The information of the ancestor nodes.
	Data *GetNodeParentsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetNodeParentsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetNodeParentsResponseBody) GoString() string {
	return s.String()
}

func (s *GetNodeParentsResponseBody) SetData(v *GetNodeParentsResponseBodyData) *GetNodeParentsResponseBody {
	s.Data = v
	return s
}

func (s *GetNodeParentsResponseBody) SetErrorCode(v string) *GetNodeParentsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetNodeParentsResponseBody) SetErrorMessage(v string) *GetNodeParentsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetNodeParentsResponseBody) SetHttpStatusCode(v int32) *GetNodeParentsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetNodeParentsResponseBody) SetRequestId(v string) *GetNodeParentsResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetNodeParentsResponseBody) SetSuccess(v bool) *GetNodeParentsResponseBody {
	s.Success = &v
	return s
}

type GetNodeParentsResponseBodyData struct {
	// The ancestor nodes returned.
	Nodes []*GetNodeParentsResponseBodyDataNodes `json:"Nodes,omitempty" xml:"Nodes,omitempty" type:"Repeated"`
}

func (s GetNodeParentsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetNodeParentsResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetNodeParentsResponseBodyData) SetNodes(v []*GetNodeParentsResponseBodyDataNodes) *GetNodeParentsResponseBodyData {
	s.Nodes = v
	return s
}

type GetNodeParentsResponseBodyDataNodes struct {
	// The ID of the baseline.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The cron expression. Cron expressions are used to run auto triggered nodes.
	CronExpress *string `json:"CronExpress,omitempty" xml:"CronExpress,omitempty"`
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The ID of the Alibaba Cloud account used by the node owner.
	OwnerId *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The priority of the node. Valid values: 1 to 8. A large value indicates a high priority.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of the node.
	ProgramType *string `json:"ProgramType,omitempty" xml:"ProgramType,omitempty"`
	// The ID of the workspace to which the node belongs.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// Indicates whether the node can be rerun if the node fails to run. Valid values:
	//
	// *   true: indicates that the node can be rerun.
	// *   false: indicates that the node cannot be rerun.
	Repeatability *bool `json:"Repeatability,omitempty" xml:"Repeatability,omitempty"`
	// The scheduling type of the node. Valid values:
	//
	// *   NORMAL: indicates that the node is an auto triggered node.
	// *   MANUAL: indicates that the node is a manually triggered node.
	// *   PAUSE: indicates that the node is a paused node. Paused nodes are started as scheduled but the system sets the status of the nodes to failed when it starts to run them.
	// *   SKIP: indicates that the node is a dry-run node. Dry-run nodes are started as scheduled but the system sets the status of the nodes to successful when it starts to run them.
	SchedulerType *string `json:"SchedulerType,omitempty" xml:"SchedulerType,omitempty"`
}

func (s GetNodeParentsResponseBodyDataNodes) String() string {
	return tea.Prettify(s)
}

func (s GetNodeParentsResponseBodyDataNodes) GoString() string {
	return s.String()
}

func (s *GetNodeParentsResponseBodyDataNodes) SetBaselineId(v int64) *GetNodeParentsResponseBodyDataNodes {
	s.BaselineId = &v
	return s
}

func (s *GetNodeParentsResponseBodyDataNodes) SetCronExpress(v string) *GetNodeParentsResponseBodyDataNodes {
	s.CronExpress = &v
	return s
}

func (s *GetNodeParentsResponseBodyDataNodes) SetNodeId(v int64) *GetNodeParentsResponseBodyDataNodes {
	s.NodeId = &v
	return s
}

func (s *GetNodeParentsResponseBodyDataNodes) SetNodeName(v string) *GetNodeParentsResponseBodyDataNodes {
	s.NodeName = &v
	return s
}

func (s *GetNodeParentsResponseBodyDataNodes) SetOwnerId(v string) *GetNodeParentsResponseBodyDataNodes {
	s.OwnerId = &v
	return s
}

func (s *GetNodeParentsResponseBodyDataNodes) SetPriority(v int32) *GetNodeParentsResponseBodyDataNodes {
	s.Priority = &v
	return s
}

func (s *GetNodeParentsResponseBodyDataNodes) SetProgramType(v string) *GetNodeParentsResponseBodyDataNodes {
	s.ProgramType = &v
	return s
}

func (s *GetNodeParentsResponseBodyDataNodes) SetProjectId(v int64) *GetNodeParentsResponseBodyDataNodes {
	s.ProjectId = &v
	return s
}

func (s *GetNodeParentsResponseBodyDataNodes) SetRepeatability(v bool) *GetNodeParentsResponseBodyDataNodes {
	s.Repeatability = &v
	return s
}

func (s *GetNodeParentsResponseBodyDataNodes) SetSchedulerType(v string) *GetNodeParentsResponseBodyDataNodes {
	s.SchedulerType = &v
	return s
}

type GetNodeParentsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetNodeParentsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetNodeParentsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetNodeParentsResponse) GoString() string {
	return s.String()
}

func (s *GetNodeParentsResponse) SetHeaders(v map[string]*string) *GetNodeParentsResponse {
	s.Headers = v
	return s
}

func (s *GetNodeParentsResponse) SetStatusCode(v int32) *GetNodeParentsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetNodeParentsResponse) SetBody(v *GetNodeParentsResponseBody) *GetNodeParentsResponse {
	s.Body = v
	return s
}

type GetNodeTypeListInfoRequest struct {
	Keyword           *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	Locale            *string `json:"Locale,omitempty" xml:"Locale,omitempty"`
	PageNumber        *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize          *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProjectId         *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s GetNodeTypeListInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetNodeTypeListInfoRequest) GoString() string {
	return s.String()
}

func (s *GetNodeTypeListInfoRequest) SetKeyword(v string) *GetNodeTypeListInfoRequest {
	s.Keyword = &v
	return s
}

func (s *GetNodeTypeListInfoRequest) SetLocale(v string) *GetNodeTypeListInfoRequest {
	s.Locale = &v
	return s
}

func (s *GetNodeTypeListInfoRequest) SetPageNumber(v int32) *GetNodeTypeListInfoRequest {
	s.PageNumber = &v
	return s
}

func (s *GetNodeTypeListInfoRequest) SetPageSize(v int32) *GetNodeTypeListInfoRequest {
	s.PageSize = &v
	return s
}

func (s *GetNodeTypeListInfoRequest) SetProjectId(v int64) *GetNodeTypeListInfoRequest {
	s.ProjectId = &v
	return s
}

func (s *GetNodeTypeListInfoRequest) SetProjectIdentifier(v string) *GetNodeTypeListInfoRequest {
	s.ProjectIdentifier = &v
	return s
}

type GetNodeTypeListInfoResponseBody struct {
	NodeTypeInfoList *GetNodeTypeListInfoResponseBodyNodeTypeInfoList `json:"NodeTypeInfoList,omitempty" xml:"NodeTypeInfoList,omitempty" type:"Struct"`
	RequestId        *string                                          `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetNodeTypeListInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetNodeTypeListInfoResponseBody) GoString() string {
	return s.String()
}

func (s *GetNodeTypeListInfoResponseBody) SetNodeTypeInfoList(v *GetNodeTypeListInfoResponseBodyNodeTypeInfoList) *GetNodeTypeListInfoResponseBody {
	s.NodeTypeInfoList = v
	return s
}

func (s *GetNodeTypeListInfoResponseBody) SetRequestId(v string) *GetNodeTypeListInfoResponseBody {
	s.RequestId = &v
	return s
}

type GetNodeTypeListInfoResponseBodyNodeTypeInfoList struct {
	NodeTypeInfo []*GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo `json:"NodeTypeInfo,omitempty" xml:"NodeTypeInfo,omitempty" type:"Repeated"`
	PageNumber   *int32                                                         `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize     *int32                                                         `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	TotalCount   *int32                                                         `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetNodeTypeListInfoResponseBodyNodeTypeInfoList) String() string {
	return tea.Prettify(s)
}

func (s GetNodeTypeListInfoResponseBodyNodeTypeInfoList) GoString() string {
	return s.String()
}

func (s *GetNodeTypeListInfoResponseBodyNodeTypeInfoList) SetNodeTypeInfo(v []*GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo) *GetNodeTypeListInfoResponseBodyNodeTypeInfoList {
	s.NodeTypeInfo = v
	return s
}

func (s *GetNodeTypeListInfoResponseBodyNodeTypeInfoList) SetPageNumber(v int32) *GetNodeTypeListInfoResponseBodyNodeTypeInfoList {
	s.PageNumber = &v
	return s
}

func (s *GetNodeTypeListInfoResponseBodyNodeTypeInfoList) SetPageSize(v int32) *GetNodeTypeListInfoResponseBodyNodeTypeInfoList {
	s.PageSize = &v
	return s
}

func (s *GetNodeTypeListInfoResponseBodyNodeTypeInfoList) SetTotalCount(v int32) *GetNodeTypeListInfoResponseBodyNodeTypeInfoList {
	s.TotalCount = &v
	return s
}

type GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo struct {
	NodeType     *int32  `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	NodeTypeName *string `json:"NodeTypeName,omitempty" xml:"NodeTypeName,omitempty"`
}

func (s GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo) String() string {
	return tea.Prettify(s)
}

func (s GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo) GoString() string {
	return s.String()
}

func (s *GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo) SetNodeType(v int32) *GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo {
	s.NodeType = &v
	return s
}

func (s *GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo) SetNodeTypeName(v string) *GetNodeTypeListInfoResponseBodyNodeTypeInfoListNodeTypeInfo {
	s.NodeTypeName = &v
	return s
}

type GetNodeTypeListInfoResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetNodeTypeListInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetNodeTypeListInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetNodeTypeListInfoResponse) GoString() string {
	return s.String()
}

func (s *GetNodeTypeListInfoResponse) SetHeaders(v map[string]*string) *GetNodeTypeListInfoResponse {
	s.Headers = v
	return s
}

func (s *GetNodeTypeListInfoResponse) SetStatusCode(v int32) *GetNodeTypeListInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetNodeTypeListInfoResponse) SetBody(v *GetNodeTypeListInfoResponseBody) *GetNodeTypeListInfoResponse {
	s.Body = v
	return s
}

type GetOpRiskDataRequest struct {
	// The date on which the access records were queried. Specify the value in the yyyyMMdd format.
	Date *string `json:"Date,omitempty" xml:"Date,omitempty"`
	// The parameters that you can specify to query the access records. Valid values:
	//
	// *   dbType: the data type
	// *   instanceName: the name of the instance
	// *   databaseName: the name of the database
	// *   projectName: the name of the workspace
	// *   clusterName: the name of the cluster
	//
	// The following example shows the parameters configured to query the access records of the sensitive data in the abc database of the ABC Hologres instance:
	//
	// {"dbType":"hologres","instanceName":"ABC","databaseName":"abc"}
	//
	// You must specify the parameters based on the compute engine that you use in your business.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of the page to return. Minimum value: 1.
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page. Maximum value: 1000.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The method that you use to identify risks.
	//
	// *   You can manually identify risks.
	// *   You can also use a risk rule to identify risks. You can go to the DataWorks console to obtain the name of the risk rule on the Custom Identification Rules page of Data Security Guard.
	RiskType *string `json:"RiskType,omitempty" xml:"RiskType,omitempty"`
}

func (s GetOpRiskDataRequest) String() string {
	return tea.Prettify(s)
}

func (s GetOpRiskDataRequest) GoString() string {
	return s.String()
}

func (s *GetOpRiskDataRequest) SetDate(v string) *GetOpRiskDataRequest {
	s.Date = &v
	return s
}

func (s *GetOpRiskDataRequest) SetName(v string) *GetOpRiskDataRequest {
	s.Name = &v
	return s
}

func (s *GetOpRiskDataRequest) SetPageNo(v int32) *GetOpRiskDataRequest {
	s.PageNo = &v
	return s
}

func (s *GetOpRiskDataRequest) SetPageSize(v int32) *GetOpRiskDataRequest {
	s.PageSize = &v
	return s
}

func (s *GetOpRiskDataRequest) SetRiskType(v string) *GetOpRiskDataRequest {
	s.RiskType = &v
	return s
}

type GetOpRiskDataResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information of the risky sensitive data returned. The information includes totalCount and opRiskDatas.
	//
	// opRiskDatas includes the following parameters:
	//
	// *   sensType: the type of the sensitive data
	// *   sensLevel: the sensitivity level of the sensitive data
	// *   opType: the type of the operation
	// *   sql: the SQL statement that is executed
	// *   opAccount: the account that is used to perform the operation
	// *   opTime: the time when the operation was performed
	RiskData *string `json:"RiskData,omitempty" xml:"RiskData,omitempty"`
}

func (s GetOpRiskDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetOpRiskDataResponseBody) GoString() string {
	return s.String()
}

func (s *GetOpRiskDataResponseBody) SetRequestId(v string) *GetOpRiskDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetOpRiskDataResponseBody) SetRiskData(v string) *GetOpRiskDataResponseBody {
	s.RiskData = &v
	return s
}

type GetOpRiskDataResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetOpRiskDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetOpRiskDataResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOpRiskDataResponse) GoString() string {
	return s.String()
}

func (s *GetOpRiskDataResponse) SetHeaders(v map[string]*string) *GetOpRiskDataResponse {
	s.Headers = v
	return s
}

func (s *GetOpRiskDataResponse) SetStatusCode(v int32) *GetOpRiskDataResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOpRiskDataResponse) SetBody(v *GetOpRiskDataResponseBody) *GetOpRiskDataResponse {
	s.Body = v
	return s
}

type GetOpSensitiveDataRequest struct {
	// The date on which access records were generated. Specify the value in the yyyyMMdd format.
	Date *string `json:"Date,omitempty" xml:"Date,omitempty"`
	// The parameters that you can specify to query the access records. Valid values:
	//
	// *   dbType: the data type
	// *   instanceName: the name of the instance
	// *   databaseName: the name of the database
	// *   projectName: the name of the workspace
	// *   clusterName: the name of the cluster
	//
	// The following example shows the parameters configured to query the access records of the sensitive data in the abc database of the ABC Hologres instance:
	//
	// {"dbType":"hologres","instanceName":"ABC","databaseName":"abc"}
	//
	// You must specify the parameters based on the compute engine that you use in your business.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The operation that is performed on the data. Valid values:
	//
	// *   SQL_SELECT: indicates that the data is accessed. For example, the SELECT statement is executed to query the data.
	// *   TUNNEL_DOWNLOAD: indicates that the data is downloaded. For example, a Tunnel command is run to download the data.
	OpType *string `json:"OpType,omitempty" xml:"OpType,omitempty"`
	// The number of the page to return. Minimum value:1. Maximum value: 1000.
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page. Minimum value: 1. Maximum value: 1000.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s GetOpSensitiveDataRequest) String() string {
	return tea.Prettify(s)
}

func (s GetOpSensitiveDataRequest) GoString() string {
	return s.String()
}

func (s *GetOpSensitiveDataRequest) SetDate(v string) *GetOpSensitiveDataRequest {
	s.Date = &v
	return s
}

func (s *GetOpSensitiveDataRequest) SetName(v string) *GetOpSensitiveDataRequest {
	s.Name = &v
	return s
}

func (s *GetOpSensitiveDataRequest) SetOpType(v string) *GetOpSensitiveDataRequest {
	s.OpType = &v
	return s
}

func (s *GetOpSensitiveDataRequest) SetPageNo(v int32) *GetOpSensitiveDataRequest {
	s.PageNo = &v
	return s
}

func (s *GetOpSensitiveDataRequest) SetPageSize(v int32) *GetOpSensitiveDataRequest {
	s.PageSize = &v
	return s
}

type GetOpSensitiveDataResponseBody struct {
	// The information of the access records returned for the sensitive data. The information includes totalCount and opRiskDatas.
	//
	// opRiskDatas includes the following parameters:
	//
	// *   sensType: indicates the type of the sensitive data.
	// *   sensLevel: indicates the sensitivity level of the sensitive data. A larger value of sensLevel indicates a higher sensitivity level.
	// *   opType: indicates the type of the operation.
	// *   sql: indicates the SQL statement that is executed.
	// *   opAccount: indicates the account that is used to perform the operation.
	// *   opTime: indicates the time when the operation was performed.
	OpSensitiveData *string `json:"OpSensitiveData,omitempty" xml:"OpSensitiveData,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetOpSensitiveDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetOpSensitiveDataResponseBody) GoString() string {
	return s.String()
}

func (s *GetOpSensitiveDataResponseBody) SetOpSensitiveData(v string) *GetOpSensitiveDataResponseBody {
	s.OpSensitiveData = &v
	return s
}

func (s *GetOpSensitiveDataResponseBody) SetRequestId(v string) *GetOpSensitiveDataResponseBody {
	s.RequestId = &v
	return s
}

type GetOpSensitiveDataResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetOpSensitiveDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetOpSensitiveDataResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOpSensitiveDataResponse) GoString() string {
	return s.String()
}

func (s *GetOpSensitiveDataResponse) SetHeaders(v map[string]*string) *GetOpSensitiveDataResponse {
	s.Headers = v
	return s
}

func (s *GetOpSensitiveDataResponse) SetStatusCode(v int32) *GetOpSensitiveDataResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOpSensitiveDataResponse) SetBody(v *GetOpSensitiveDataResponseBody) *GetOpSensitiveDataResponse {
	s.Body = v
	return s
}

type GetOptionValueForProjectRequest struct {
	// The ID of the workspace.
	ExtensionCode *string `json:"ExtensionCode,omitempty" xml:"ExtensionCode,omitempty"`
	// Id of the request
	ProjectId *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetOptionValueForProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s GetOptionValueForProjectRequest) GoString() string {
	return s.String()
}

func (s *GetOptionValueForProjectRequest) SetExtensionCode(v string) *GetOptionValueForProjectRequest {
	s.ExtensionCode = &v
	return s
}

func (s *GetOptionValueForProjectRequest) SetProjectId(v string) *GetOptionValueForProjectRequest {
	s.ProjectId = &v
	return s
}

type GetOptionValueForProjectResponseBody struct {
	OptionValue *string `json:"OptionValue,omitempty" xml:"OptionValue,omitempty"`
	// The option settings. In the example, cuNumber is a custom key.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetOptionValueForProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetOptionValueForProjectResponseBody) GoString() string {
	return s.String()
}

func (s *GetOptionValueForProjectResponseBody) SetOptionValue(v string) *GetOptionValueForProjectResponseBody {
	s.OptionValue = &v
	return s
}

func (s *GetOptionValueForProjectResponseBody) SetRequestId(v string) *GetOptionValueForProjectResponseBody {
	s.RequestId = &v
	return s
}

type GetOptionValueForProjectResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetOptionValueForProjectResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetOptionValueForProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s GetOptionValueForProjectResponse) GoString() string {
	return s.String()
}

func (s *GetOptionValueForProjectResponse) SetHeaders(v map[string]*string) *GetOptionValueForProjectResponse {
	s.Headers = v
	return s
}

func (s *GetOptionValueForProjectResponse) SetStatusCode(v int32) *GetOptionValueForProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *GetOptionValueForProjectResponse) SetBody(v *GetOptionValueForProjectResponseBody) *GetOptionValueForProjectResponse {
	s.Body = v
	return s
}

type GetPermissionApplyOrderDetailRequest struct {
	// The ID of the permission request order. You can call the ListPermissionApplyOrders operation to obtain the order ID.
	FlowId *string `json:"FlowId,omitempty" xml:"FlowId,omitempty"`
}

func (s GetPermissionApplyOrderDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetPermissionApplyOrderDetailRequest) GoString() string {
	return s.String()
}

func (s *GetPermissionApplyOrderDetailRequest) SetFlowId(v string) *GetPermissionApplyOrderDetailRequest {
	s.FlowId = &v
	return s
}

type GetPermissionApplyOrderDetailResponseBody struct {
	// Details about the permission request order.
	ApplyOrderDetail *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail `json:"ApplyOrderDetail,omitempty" xml:"ApplyOrderDetail,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetPermissionApplyOrderDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetPermissionApplyOrderDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetPermissionApplyOrderDetailResponseBody) SetApplyOrderDetail(v *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail) *GetPermissionApplyOrderDetailResponseBody {
	s.ApplyOrderDetail = v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBody) SetRequestId(v string) *GetPermissionApplyOrderDetailResponseBody {
	s.RequestId = &v
	return s
}

type GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail struct {
	// The unique ID of the Alibaba Cloud account that is used to submit the permission request order.
	ApplyBaseId *string `json:"ApplyBaseId,omitempty" xml:"ApplyBaseId,omitempty"`
	// The time when the permission request order was submitted. The parameter value is a UNIX timestamp.
	ApplyTimestamp *int64 `json:"ApplyTimestamp,omitempty" xml:"ApplyTimestamp,omitempty"`
	// The list of Alibaba Cloud accounts that are used to approve the permission request order.
	ApproveAccountList []*GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList `json:"ApproveAccountList,omitempty" xml:"ApproveAccountList,omitempty" type:"Repeated"`
	// The content of the permission request.
	ApproveContent *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent `json:"ApproveContent,omitempty" xml:"ApproveContent,omitempty" type:"Struct"`
	// The ID of the permission request order.
	FlowId *string `json:"FlowId,omitempty" xml:"FlowId,omitempty"`
	// The status of the permission request order. Valid values:
	//
	// *   1: pending approval
	// *   2: approved and authorized
	// *   3: approved but authorization failed
	// *   4: rejected
	FlowStatus *int32 `json:"FlowStatus,omitempty" xml:"FlowStatus,omitempty"`
	// Information about the account that is used to request permissions.
	GranteeObjectList []*GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList `json:"GranteeObjectList,omitempty" xml:"GranteeObjectList,omitempty" type:"Repeated"`
}

func (s GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail) String() string {
	return tea.Prettify(s)
}

func (s GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail) GoString() string {
	return s.String()
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail) SetApplyBaseId(v string) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail {
	s.ApplyBaseId = &v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail) SetApplyTimestamp(v int64) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail {
	s.ApplyTimestamp = &v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail) SetApproveAccountList(v []*GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail {
	s.ApproveAccountList = v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail) SetApproveContent(v *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail {
	s.ApproveContent = v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail) SetFlowId(v string) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail {
	s.FlowId = &v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail) SetFlowStatus(v int32) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail {
	s.FlowStatus = &v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail) SetGranteeObjectList(v []*GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetail {
	s.GranteeObjectList = v
	return s
}

type GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList struct {
	// The unique ID of the Alibaba Cloud account that is used to approve the permission request order.
	BaseId *string `json:"BaseId,omitempty" xml:"BaseId,omitempty"`
}

func (s GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList) String() string {
	return tea.Prettify(s)
}

func (s GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList) GoString() string {
	return s.String()
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList) SetBaseId(v string) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveAccountList {
	s.BaseId = &v
	return s
}

type GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent struct {
	// The reason for your request. The administrator decides whether to approve the request based on the request reason.
	ApplyReason *string `json:"ApplyReason,omitempty" xml:"ApplyReason,omitempty"`
	// The expiration time of the permissions that you requested. The parameter value is a UNIX timestamp.
	//
	// If LabelSecurity is disabled in the MaxCompute project, or the security level of fields in the MaxCompute table on which you request permissions is 0 or is less than or equal to the security level of the Alibaba Cloud account for which you request permissions, you can request only permanent permissions.
	Deadline *int64 `json:"Deadline,omitempty" xml:"Deadline,omitempty"`
	// The type of the permission request order. The parameter value is 1 and cannot be changed. 1 indicates that ACL-based authorization is requested.
	OrderType *int32 `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	// The information about the project and workspace that are associated with the object on which you requested permissions.
	ProjectMeta *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta `json:"ProjectMeta,omitempty" xml:"ProjectMeta,omitempty" type:"Struct"`
}

func (s GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent) String() string {
	return tea.Prettify(s)
}

func (s GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent) GoString() string {
	return s.String()
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent) SetApplyReason(v string) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent {
	s.ApplyReason = &v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent) SetDeadline(v int64) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent {
	s.Deadline = &v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent) SetOrderType(v int32) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent {
	s.OrderType = &v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent) SetProjectMeta(v *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContent {
	s.ProjectMeta = v
	return s
}

type GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta struct {
	// The MaxCompute project to which the object on which you request permissions belongs.
	MaxComputeProjectName *string `json:"MaxComputeProjectName,omitempty" xml:"MaxComputeProjectName,omitempty"`
	// Details about the object on which you request permissions.
	ObjectMetaList []*GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList `json:"ObjectMetaList,omitempty" xml:"ObjectMetaList,omitempty" type:"Repeated"`
	// The ID of the DataWorks workspace that is associated with the object on which you request permissions.
	WorkspaceId *int32 `json:"WorkspaceId,omitempty" xml:"WorkspaceId,omitempty"`
}

func (s GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta) String() string {
	return tea.Prettify(s)
}

func (s GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta) GoString() string {
	return s.String()
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta) SetMaxComputeProjectName(v string) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta {
	s.MaxComputeProjectName = &v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta) SetObjectMetaList(v []*GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta {
	s.ObjectMetaList = v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta) SetWorkspaceId(v int32) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMeta {
	s.WorkspaceId = &v
	return s
}

type GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList struct {
	// The information about the column fields in the object on which you request permissions.
	ColumnMetaList []*GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList `json:"ColumnMetaList,omitempty" xml:"ColumnMetaList,omitempty" type:"Repeated"`
	// The name of the table on which you request permissions.
	ObjectName *string `json:"ObjectName,omitempty" xml:"ObjectName,omitempty"`
}

func (s GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList) String() string {
	return tea.Prettify(s)
}

func (s GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList) GoString() string {
	return s.String()
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList) SetColumnMetaList(v []*GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList {
	s.ColumnMetaList = v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList) SetObjectName(v string) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaList {
	s.ObjectName = &v
	return s
}

type GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList struct {
	// The description of the column on which you request permissions.
	ColumnComment *string `json:"ColumnComment,omitempty" xml:"ColumnComment,omitempty"`
	// The name of the column on which you request permissions.
	ColumnName    *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	SecurityLevel *string `json:"SecurityLevel,omitempty" xml:"SecurityLevel,omitempty"`
}

func (s GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList) String() string {
	return tea.Prettify(s)
}

func (s GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList) GoString() string {
	return s.String()
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList) SetColumnComment(v string) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList {
	s.ColumnComment = &v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList) SetColumnName(v string) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList {
	s.ColumnName = &v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList) SetSecurityLevel(v string) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailApproveContentProjectMetaObjectMetaListColumnMetaList {
	s.SecurityLevel = &v
	return s
}

type GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList struct {
	// The unique ID of the account that is used to request permissions.
	GranteeId *string `json:"GranteeId,omitempty" xml:"GranteeId,omitempty"`
	// The name of the account that is used to request permissions. The name is in the same format as that of the account used to access the MaxCompute project.
	//
	// *   An Alibaba Cloud account is in the format of ALIYUN$+Account name.
	// *   A RAM user is in the format of RAM$+Account name.
	GranteeName *string `json:"GranteeName,omitempty" xml:"GranteeName,omitempty"`
	// The type of the subject that requests permissions. The parameter value is 1 and cannot be changed. It indicates user.
	GranteeType *int32 `json:"GranteeType,omitempty" xml:"GranteeType,omitempty"`
	// The subtype of the subject that requests permissions. Valid values:
	//
	// *   101: production account
	// *   103: individual account
	// *   105: account that requests permissions for others
	GranteeTypeSub *int32 `json:"GranteeTypeSub,omitempty" xml:"GranteeTypeSub,omitempty"`
}

func (s GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList) String() string {
	return tea.Prettify(s)
}

func (s GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList) GoString() string {
	return s.String()
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList) SetGranteeId(v string) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList {
	s.GranteeId = &v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList) SetGranteeName(v string) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList {
	s.GranteeName = &v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList) SetGranteeType(v int32) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList {
	s.GranteeType = &v
	return s
}

func (s *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList) SetGranteeTypeSub(v int32) *GetPermissionApplyOrderDetailResponseBodyApplyOrderDetailGranteeObjectList {
	s.GranteeTypeSub = &v
	return s
}

type GetPermissionApplyOrderDetailResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetPermissionApplyOrderDetailResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetPermissionApplyOrderDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetPermissionApplyOrderDetailResponse) GoString() string {
	return s.String()
}

func (s *GetPermissionApplyOrderDetailResponse) SetHeaders(v map[string]*string) *GetPermissionApplyOrderDetailResponse {
	s.Headers = v
	return s
}

func (s *GetPermissionApplyOrderDetailResponse) SetStatusCode(v int32) *GetPermissionApplyOrderDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetPermissionApplyOrderDetailResponse) SetBody(v *GetPermissionApplyOrderDetailResponseBody) *GetPermissionApplyOrderDetailResponse {
	s.Body = v
	return s
}

type GetProjectRequest struct {
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	ProjectId         *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s GetProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s GetProjectRequest) GoString() string {
	return s.String()
}

func (s *GetProjectRequest) SetProjectId(v int64) *GetProjectRequest {
	s.ProjectId = &v
	return s
}

func (s *GetProjectRequest) SetProjectIdentifier(v string) *GetProjectRequest {
	s.ProjectIdentifier = &v
	return s
}

type GetProjectResponseBody struct {
	// This parameter is deprecated.
	Data *GetProjectResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// Indicates whether the request was successful.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The description of the workspace.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the workspace. Valid values:
	//
	// *   AVAILABLE(0): The workspace is in a normal state.
	// *   DELETED(1): The workspace is deleted.
	// *   INITIALIZING(2): The workspace is being initialized.
	// *   INIT_FAILED(3): The workspace fails to be initialized.
	// *   FORBIDDEN(4): The workspace is manually disabled.
	// *   DELETING(5): The workspace is being deleted.
	// *   DEL_FAILED(6): The workspace fails to be deleted.
	// *   FROZEN(7): The workspace is frozen due to overdue payments.
	// *   UPDATING(8): The workspace is being updated. The workspace enters this state after you associate a new compute engine with the workspace and the compute engine is being initialized.
	// *   UPDATE_FAILED(9): The workspace fails to be updated.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetProjectResponseBody) GoString() string {
	return s.String()
}

func (s *GetProjectResponseBody) SetData(v *GetProjectResponseBodyData) *GetProjectResponseBody {
	s.Data = v
	return s
}

func (s *GetProjectResponseBody) SetHttpStatusCode(v int32) *GetProjectResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetProjectResponseBody) SetRequestId(v string) *GetProjectResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetProjectResponseBody) SetSuccess(v bool) *GetProjectResponseBody {
	s.Success = &v
	return s
}

type GetProjectResponseBodyData struct {
	// Indicates whether the workspace is a default workspace. Valid values:
	//
	// *   1: The workspace is a default workspace.
	// *   0: The workspace is not a default workspace.
	Appkey *string `json:"Appkey,omitempty" xml:"Appkey,omitempty"`
	// The time when the workspace was created. Example: Dec 3, 2019 9:12:20 PM.
	BaseProject                      *bool   `json:"BaseProject,omitempty" xml:"BaseProject,omitempty"`
	DefaultDiResourceGroupIdentifier *string `json:"DefaultDiResourceGroupIdentifier,omitempty" xml:"DefaultDiResourceGroupIdentifier,omitempty"`
	// The unique identifier of the workspace.
	Destination *int32 `json:"Destination,omitempty" xml:"Destination,omitempty"`
	// This parameter is deprecated.
	DevStorageQuota *string `json:"DevStorageQuota,omitempty" xml:"DevStorageQuota,omitempty"`
	// The default maximum number of automatic reruns that are allowed after an error occurs.
	DevelopmentType *int32 `json:"DevelopmentType,omitempty" xml:"DevelopmentType,omitempty"`
	// This parameter is deprecated.
	DisableDevelopment *bool `json:"DisableDevelopment,omitempty" xml:"DisableDevelopment,omitempty"`
	// The list of tags.
	//
	// The tags are added to resources in the workspace and used for authentication and cost allocation.
	EnvTypes []*string `json:"EnvTypes,omitempty" xml:"EnvTypes,omitempty" type:"Repeated"`
	// The environment of the workspace. Valid values: PROD and DEV.
	//
	// *   The value PROD indicates the production environment. Workspaces in basic mode provide only the production environment.
	// *   The value DEV indicates the development environment. Workspaces in standard mode provide both the development environment and the production environment.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The description of the workspace.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The time when the workspace was last modified. Example: Dec 3, 2019 9:12:20 PM.
	IsAllowDownload *int32 `json:"IsAllowDownload,omitempty" xml:"IsAllowDownload,omitempty"`
	// The display name of the workspace.
	IsDefault *int32 `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// Indicates whether you are allowed to download the query result from DataStudio. Valid values:
	//
	// *   1: You are allowed to download the query result from DataStudio.
	// *   0: You are not allowed to download the query result from DataStudio.
	MaxFlowNode *int32 `json:"MaxFlowNode,omitempty" xml:"MaxFlowNode,omitempty"`
	// The development type of the workspace. The value is fixed as 4. This parameter is deprecated.
	ProdStorageQuota *string `json:"ProdStorageQuota,omitempty" xml:"ProdStorageQuota,omitempty"`
	// Indicates whether the MaxCompute tables in the workspace are visible to the users within a tenant. Valid values:
	//
	// *   0: The MaxCompute tables are invisible to the users within a tenant.
	// *   1: The MaxCompute tables are visible to the users within a tenant.
	ProjectDescription *string `json:"ProjectDescription,omitempty" xml:"ProjectDescription,omitempty"`
	// The mode of the workspace. Valid values:
	//
	// *   2: The workspace is in basic mode.
	// *   3: The workspace is in standard mode.
	ProjectId *int32 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the Alibaba Cloud account used by the workspace owner.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
	// This parameter is deprecated.
	ProjectMode *int32 `json:"ProjectMode,omitempty" xml:"ProjectMode,omitempty"`
	// Indicates whether the Development role is disabled. Valid values:
	//
	// *   false: The Development role is enabled.
	// *   true: The Development role is disabled.
	//
	// <!---->
	//
	// *   Default value: false.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// Indicates whether a proxy account is used to access the MaxCompute compute engine instance associated with the workspace.
	ProjectOwnerBaseId *string `json:"ProjectOwnerBaseId,omitempty" xml:"ProjectOwnerBaseId,omitempty"`
	// This parameter is deprecated.
	ProtectedMode *int32  `json:"ProtectedMode,omitempty" xml:"ProtectedMode,omitempty"`
	ResidentArea  *string `json:"ResidentArea,omitempty" xml:"ResidentArea,omitempty"`
	// The keys of the tags that are added to resources in the workspace. The tag keys must meet the following conditions:
	//
	// *   The number of tag keys that can be added to resources ranges from 1 to 20.
	// *   Each tag key can be a maximum of 128 characters in length.
	// *   The tag keys cannot start with acs: or aliyun:.
	// *   The tag keys cannot contain http:// or https://.
	ResourceManagerResourceGroupId *string `json:"ResourceManagerResourceGroupId,omitempty" xml:"ResourceManagerResourceGroupId,omitempty"`
	// The interval between automatic reruns after an error occurs. Unit: milliseconds. The maximum interval is 30 minutes. You must pay attention to the conversion between units.
	SchedulerMaxRetryTimes *int32 `json:"SchedulerMaxRetryTimes,omitempty" xml:"SchedulerMaxRetryTimes,omitempty"`
	// This parameter is deprecated.
	SchedulerRetryInterval *int32 `json:"SchedulerRetryInterval,omitempty" xml:"SchedulerRetryInterval,omitempty"`
	// The ID of the workspace.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// Indicates whether the workspace protection feature is enabled. Valid values:
	//
	// *   1: The workspace protection feature is enabled.
	// *   0: The workspace protection feature is disabled.
	TablePrivacyMode *int32 `json:"TablePrivacyMode,omitempty" xml:"TablePrivacyMode,omitempty"`
	// The values of the tags that are added to resources in the workspace. The tag values must meet the following conditions:
	//
	// *   The number of tag values that can be added to resources ranges from 1 to 20.
	// *   Each tag value can be a maximum of 128 characters in length.
	// *   The tag values cannot start with acs:.
	// *   The tag values cannot contain http:// or https://.
	Tags []*GetProjectResponseBodyDataTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The ID of the resource group used in the workspace.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	// The ID of the tenant.
	UseProxyOdpsAccount *bool `json:"UseProxyOdpsAccount,omitempty" xml:"UseProxyOdpsAccount,omitempty"`
}

func (s GetProjectResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetProjectResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetProjectResponseBodyData) SetAppkey(v string) *GetProjectResponseBodyData {
	s.Appkey = &v
	return s
}

func (s *GetProjectResponseBodyData) SetBaseProject(v bool) *GetProjectResponseBodyData {
	s.BaseProject = &v
	return s
}

func (s *GetProjectResponseBodyData) SetDefaultDiResourceGroupIdentifier(v string) *GetProjectResponseBodyData {
	s.DefaultDiResourceGroupIdentifier = &v
	return s
}

func (s *GetProjectResponseBodyData) SetDestination(v int32) *GetProjectResponseBodyData {
	s.Destination = &v
	return s
}

func (s *GetProjectResponseBodyData) SetDevStorageQuota(v string) *GetProjectResponseBodyData {
	s.DevStorageQuota = &v
	return s
}

func (s *GetProjectResponseBodyData) SetDevelopmentType(v int32) *GetProjectResponseBodyData {
	s.DevelopmentType = &v
	return s
}

func (s *GetProjectResponseBodyData) SetDisableDevelopment(v bool) *GetProjectResponseBodyData {
	s.DisableDevelopment = &v
	return s
}

func (s *GetProjectResponseBodyData) SetEnvTypes(v []*string) *GetProjectResponseBodyData {
	s.EnvTypes = v
	return s
}

func (s *GetProjectResponseBodyData) SetGmtCreate(v string) *GetProjectResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetProjectResponseBodyData) SetGmtModified(v string) *GetProjectResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetProjectResponseBodyData) SetIsAllowDownload(v int32) *GetProjectResponseBodyData {
	s.IsAllowDownload = &v
	return s
}

func (s *GetProjectResponseBodyData) SetIsDefault(v int32) *GetProjectResponseBodyData {
	s.IsDefault = &v
	return s
}

func (s *GetProjectResponseBodyData) SetMaxFlowNode(v int32) *GetProjectResponseBodyData {
	s.MaxFlowNode = &v
	return s
}

func (s *GetProjectResponseBodyData) SetProdStorageQuota(v string) *GetProjectResponseBodyData {
	s.ProdStorageQuota = &v
	return s
}

func (s *GetProjectResponseBodyData) SetProjectDescription(v string) *GetProjectResponseBodyData {
	s.ProjectDescription = &v
	return s
}

func (s *GetProjectResponseBodyData) SetProjectId(v int32) *GetProjectResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetProjectResponseBodyData) SetProjectIdentifier(v string) *GetProjectResponseBodyData {
	s.ProjectIdentifier = &v
	return s
}

func (s *GetProjectResponseBodyData) SetProjectMode(v int32) *GetProjectResponseBodyData {
	s.ProjectMode = &v
	return s
}

func (s *GetProjectResponseBodyData) SetProjectName(v string) *GetProjectResponseBodyData {
	s.ProjectName = &v
	return s
}

func (s *GetProjectResponseBodyData) SetProjectOwnerBaseId(v string) *GetProjectResponseBodyData {
	s.ProjectOwnerBaseId = &v
	return s
}

func (s *GetProjectResponseBodyData) SetProtectedMode(v int32) *GetProjectResponseBodyData {
	s.ProtectedMode = &v
	return s
}

func (s *GetProjectResponseBodyData) SetResidentArea(v string) *GetProjectResponseBodyData {
	s.ResidentArea = &v
	return s
}

func (s *GetProjectResponseBodyData) SetResourceManagerResourceGroupId(v string) *GetProjectResponseBodyData {
	s.ResourceManagerResourceGroupId = &v
	return s
}

func (s *GetProjectResponseBodyData) SetSchedulerMaxRetryTimes(v int32) *GetProjectResponseBodyData {
	s.SchedulerMaxRetryTimes = &v
	return s
}

func (s *GetProjectResponseBodyData) SetSchedulerRetryInterval(v int32) *GetProjectResponseBodyData {
	s.SchedulerRetryInterval = &v
	return s
}

func (s *GetProjectResponseBodyData) SetStatus(v int32) *GetProjectResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetProjectResponseBodyData) SetTablePrivacyMode(v int32) *GetProjectResponseBodyData {
	s.TablePrivacyMode = &v
	return s
}

func (s *GetProjectResponseBodyData) SetTags(v []*GetProjectResponseBodyDataTags) *GetProjectResponseBodyData {
	s.Tags = v
	return s
}

func (s *GetProjectResponseBodyData) SetTenantId(v int64) *GetProjectResponseBodyData {
	s.TenantId = &v
	return s
}

func (s *GetProjectResponseBodyData) SetUseProxyOdpsAccount(v bool) *GetProjectResponseBodyData {
	s.UseProxyOdpsAccount = &v
	return s
}

type GetProjectResponseBodyDataTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetProjectResponseBodyDataTags) String() string {
	return tea.Prettify(s)
}

func (s GetProjectResponseBodyDataTags) GoString() string {
	return s.String()
}

func (s *GetProjectResponseBodyDataTags) SetKey(v string) *GetProjectResponseBodyDataTags {
	s.Key = &v
	return s
}

func (s *GetProjectResponseBodyDataTags) SetValue(v string) *GetProjectResponseBodyDataTags {
	s.Value = &v
	return s
}

type GetProjectResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetProjectResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s GetProjectResponse) GoString() string {
	return s.String()
}

func (s *GetProjectResponse) SetHeaders(v map[string]*string) *GetProjectResponse {
	s.Headers = v
	return s
}

func (s *GetProjectResponse) SetStatusCode(v int32) *GetProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *GetProjectResponse) SetBody(v *GetProjectResponseBody) *GetProjectResponse {
	s.Body = v
	return s
}

type GetProjectDetailRequest struct {
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetProjectDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetProjectDetailRequest) GoString() string {
	return s.String()
}

func (s *GetProjectDetailRequest) SetProjectId(v int64) *GetProjectDetailRequest {
	s.ProjectId = &v
	return s
}

type GetProjectDetailResponseBody struct {
	Data           *GetProjectDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	HttpStatusCode *int32                            `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string                           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                             `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetProjectDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetProjectDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetProjectDetailResponseBody) SetData(v *GetProjectDetailResponseBodyData) *GetProjectDetailResponseBody {
	s.Data = v
	return s
}

func (s *GetProjectDetailResponseBody) SetHttpStatusCode(v int32) *GetProjectDetailResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetProjectDetailResponseBody) SetRequestId(v string) *GetProjectDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetProjectDetailResponseBody) SetSuccess(v bool) *GetProjectDetailResponseBody {
	s.Success = &v
	return s
}

type GetProjectDetailResponseBodyData struct {
	DefaultDiResourceGroupIdentifier *string                                 `json:"DefaultDiResourceGroupIdentifier,omitempty" xml:"DefaultDiResourceGroupIdentifier,omitempty"`
	DevelopmentType                  *int32                                  `json:"DevelopmentType,omitempty" xml:"DevelopmentType,omitempty"`
	DisableDevelopment               *bool                                   `json:"DisableDevelopment,omitempty" xml:"DisableDevelopment,omitempty"`
	EnvTypes                         []*string                               `json:"EnvTypes,omitempty" xml:"EnvTypes,omitempty" type:"Repeated"`
	GmtCreate                        *string                                 `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtModified                      *string                                 `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	IsAllowDownload                  *int32                                  `json:"IsAllowDownload,omitempty" xml:"IsAllowDownload,omitempty"`
	IsDefault                        *int32                                  `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	ProjectDescription               *string                                 `json:"ProjectDescription,omitempty" xml:"ProjectDescription,omitempty"`
	ProjectId                        *int32                                  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ProjectIdentifier                *string                                 `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
	ProjectMode                      *int32                                  `json:"ProjectMode,omitempty" xml:"ProjectMode,omitempty"`
	ProjectName                      *string                                 `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	ProjectOwnerBaseId               *string                                 `json:"ProjectOwnerBaseId,omitempty" xml:"ProjectOwnerBaseId,omitempty"`
	ProtectedMode                    *int32                                  `json:"ProtectedMode,omitempty" xml:"ProtectedMode,omitempty"`
	ResidentArea                     *string                                 `json:"ResidentArea,omitempty" xml:"ResidentArea,omitempty"`
	ResourceManagerResourceGroupId   *string                                 `json:"ResourceManagerResourceGroupId,omitempty" xml:"ResourceManagerResourceGroupId,omitempty"`
	SchedulerMaxRetryTimes           *int32                                  `json:"SchedulerMaxRetryTimes,omitempty" xml:"SchedulerMaxRetryTimes,omitempty"`
	SchedulerRetryInterval           *int32                                  `json:"SchedulerRetryInterval,omitempty" xml:"SchedulerRetryInterval,omitempty"`
	Status                           *int32                                  `json:"Status,omitempty" xml:"Status,omitempty"`
	TablePrivacyMode                 *int32                                  `json:"TablePrivacyMode,omitempty" xml:"TablePrivacyMode,omitempty"`
	Tags                             []*GetProjectDetailResponseBodyDataTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	TenantId                         *int64                                  `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	UseProxyOdpsAccount              *bool                                   `json:"UseProxyOdpsAccount,omitempty" xml:"UseProxyOdpsAccount,omitempty"`
}

func (s GetProjectDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetProjectDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetProjectDetailResponseBodyData) SetDefaultDiResourceGroupIdentifier(v string) *GetProjectDetailResponseBodyData {
	s.DefaultDiResourceGroupIdentifier = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetDevelopmentType(v int32) *GetProjectDetailResponseBodyData {
	s.DevelopmentType = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetDisableDevelopment(v bool) *GetProjectDetailResponseBodyData {
	s.DisableDevelopment = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetEnvTypes(v []*string) *GetProjectDetailResponseBodyData {
	s.EnvTypes = v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetGmtCreate(v string) *GetProjectDetailResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetGmtModified(v string) *GetProjectDetailResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetIsAllowDownload(v int32) *GetProjectDetailResponseBodyData {
	s.IsAllowDownload = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetIsDefault(v int32) *GetProjectDetailResponseBodyData {
	s.IsDefault = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetProjectDescription(v string) *GetProjectDetailResponseBodyData {
	s.ProjectDescription = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetProjectId(v int32) *GetProjectDetailResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetProjectIdentifier(v string) *GetProjectDetailResponseBodyData {
	s.ProjectIdentifier = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetProjectMode(v int32) *GetProjectDetailResponseBodyData {
	s.ProjectMode = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetProjectName(v string) *GetProjectDetailResponseBodyData {
	s.ProjectName = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetProjectOwnerBaseId(v string) *GetProjectDetailResponseBodyData {
	s.ProjectOwnerBaseId = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetProtectedMode(v int32) *GetProjectDetailResponseBodyData {
	s.ProtectedMode = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetResidentArea(v string) *GetProjectDetailResponseBodyData {
	s.ResidentArea = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetResourceManagerResourceGroupId(v string) *GetProjectDetailResponseBodyData {
	s.ResourceManagerResourceGroupId = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetSchedulerMaxRetryTimes(v int32) *GetProjectDetailResponseBodyData {
	s.SchedulerMaxRetryTimes = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetSchedulerRetryInterval(v int32) *GetProjectDetailResponseBodyData {
	s.SchedulerRetryInterval = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetStatus(v int32) *GetProjectDetailResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetTablePrivacyMode(v int32) *GetProjectDetailResponseBodyData {
	s.TablePrivacyMode = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetTags(v []*GetProjectDetailResponseBodyDataTags) *GetProjectDetailResponseBodyData {
	s.Tags = v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetTenantId(v int64) *GetProjectDetailResponseBodyData {
	s.TenantId = &v
	return s
}

func (s *GetProjectDetailResponseBodyData) SetUseProxyOdpsAccount(v bool) *GetProjectDetailResponseBodyData {
	s.UseProxyOdpsAccount = &v
	return s
}

type GetProjectDetailResponseBodyDataTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetProjectDetailResponseBodyDataTags) String() string {
	return tea.Prettify(s)
}

func (s GetProjectDetailResponseBodyDataTags) GoString() string {
	return s.String()
}

func (s *GetProjectDetailResponseBodyDataTags) SetKey(v string) *GetProjectDetailResponseBodyDataTags {
	s.Key = &v
	return s
}

func (s *GetProjectDetailResponseBodyDataTags) SetValue(v string) *GetProjectDetailResponseBodyDataTags {
	s.Value = &v
	return s
}

type GetProjectDetailResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetProjectDetailResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetProjectDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetProjectDetailResponse) GoString() string {
	return s.String()
}

func (s *GetProjectDetailResponse) SetHeaders(v map[string]*string) *GetProjectDetailResponse {
	s.Headers = v
	return s
}

func (s *GetProjectDetailResponse) SetStatusCode(v int32) *GetProjectDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetProjectDetailResponse) SetBody(v *GetProjectDetailResponseBody) *GetProjectDetailResponse {
	s.Body = v
	return s
}

type GetQualityEntityRequest struct {
	// The type of the compute engine instance or data source.
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The partition filter expression.
	MatchExpression *string `json:"MatchExpression,omitempty" xml:"MatchExpression,omitempty"`
	ProjectId       *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the compute engine instance or data source. You can obtain the name from data source configurations.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The name of the partitioned table. You can call the [GetMetaTablePartition](~~173923~~) operation to obtain the name.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetQualityEntityRequest) String() string {
	return tea.Prettify(s)
}

func (s GetQualityEntityRequest) GoString() string {
	return s.String()
}

func (s *GetQualityEntityRequest) SetEnvType(v string) *GetQualityEntityRequest {
	s.EnvType = &v
	return s
}

func (s *GetQualityEntityRequest) SetMatchExpression(v string) *GetQualityEntityRequest {
	s.MatchExpression = &v
	return s
}

func (s *GetQualityEntityRequest) SetProjectId(v int64) *GetQualityEntityRequest {
	s.ProjectId = &v
	return s
}

func (s *GetQualityEntityRequest) SetProjectName(v string) *GetQualityEntityRequest {
	s.ProjectName = &v
	return s
}

func (s *GetQualityEntityRequest) SetTableName(v string) *GetQualityEntityRequest {
	s.TableName = &v
	return s
}

type GetQualityEntityResponseBody struct {
	// The information about the partition filter expression.
	Data []*GetQualityEntityResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetQualityEntityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetQualityEntityResponseBody) GoString() string {
	return s.String()
}

func (s *GetQualityEntityResponseBody) SetData(v []*GetQualityEntityResponseBodyData) *GetQualityEntityResponseBody {
	s.Data = v
	return s
}

func (s *GetQualityEntityResponseBody) SetErrorCode(v string) *GetQualityEntityResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetQualityEntityResponseBody) SetErrorMessage(v string) *GetQualityEntityResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetQualityEntityResponseBody) SetHttpStatusCode(v int32) *GetQualityEntityResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetQualityEntityResponseBody) SetRequestId(v string) *GetQualityEntityResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetQualityEntityResponseBody) SetSuccess(v bool) *GetQualityEntityResponseBody {
	s.Success = &v
	return s
}

type GetQualityEntityResponseBodyData struct {
	// The time when the partition filter expression was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The level of the partition filter expression. Valid values:
	//
	// *   0: The partition filter expression is at the SQL level. This indicates that the system checks data quality after each SQL statement is executed.
	// *   1: The partition filter expression is at the node level. This indicates that the system checks data quality after all the SQL statements for a node are executed.
	EntityLevel *int32 `json:"EntityLevel,omitempty" xml:"EntityLevel,omitempty"`
	// The type of the compute engine instance or data source.
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The ID of the Alibaba Cloud account that is used to receive alert notifications.
	Followers *string `json:"Followers,omitempty" xml:"Followers,omitempty"`
	// Indicates whether the partition filter expression is associated with a node. Valid values:
	//
	// *   true: The partition filter expression is associated with a node.
	// *   false: The partition filter expression is not associated with a node.
	HasRelativeNode *bool `json:"HasRelativeNode,omitempty" xml:"HasRelativeNode,omitempty"`
	// The ID of the partition filter expression.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The partition filter expression.
	MatchExpression *string `json:"MatchExpression,omitempty" xml:"MatchExpression,omitempty"`
	// The time when the partition filter expression was modified.
	ModifyTime *int64 `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The ID of the Alibaba Cloud account that is used to modify the partition filter expression.
	ModifyUser *string `json:"ModifyUser,omitempty" xml:"ModifyUser,omitempty"`
	// The ID of the Alibaba Cloud account that is used to configure the partition filter expression.
	OnDuty *string `json:"OnDuty,omitempty" xml:"OnDuty,omitempty"`
	// The name of the Alibaba Cloud account that is used to configure the partition filter expression.
	OnDutyAccountName *string `json:"OnDutyAccountName,omitempty" xml:"OnDutyAccountName,omitempty"`
	// The name of the compute engine instance or data source.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The information about the node with which the partition filter expression is associated. The information includes the following items:
	//
	// *   ProjectName: the name of the workspace to which the node belongs.
	// *   NodeID: the ID of the node.
	RelativeNode *string `json:"RelativeNode,omitempty" xml:"RelativeNode,omitempty"`
	// Indicates that the partition filter expression is at the SQL level.
	Sql *int32 `json:"Sql,omitempty" xml:"Sql,omitempty"`
	// The name of the partitioned table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The node.
	Task *int32 `json:"Task,omitempty" xml:"Task,omitempty"`
}

func (s GetQualityEntityResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetQualityEntityResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetQualityEntityResponseBodyData) SetCreateTime(v int64) *GetQualityEntityResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *GetQualityEntityResponseBodyData) SetEntityLevel(v int32) *GetQualityEntityResponseBodyData {
	s.EntityLevel = &v
	return s
}

func (s *GetQualityEntityResponseBodyData) SetEnvType(v string) *GetQualityEntityResponseBodyData {
	s.EnvType = &v
	return s
}

func (s *GetQualityEntityResponseBodyData) SetFollowers(v string) *GetQualityEntityResponseBodyData {
	s.Followers = &v
	return s
}

func (s *GetQualityEntityResponseBodyData) SetHasRelativeNode(v bool) *GetQualityEntityResponseBodyData {
	s.HasRelativeNode = &v
	return s
}

func (s *GetQualityEntityResponseBodyData) SetId(v int64) *GetQualityEntityResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetQualityEntityResponseBodyData) SetMatchExpression(v string) *GetQualityEntityResponseBodyData {
	s.MatchExpression = &v
	return s
}

func (s *GetQualityEntityResponseBodyData) SetModifyTime(v int64) *GetQualityEntityResponseBodyData {
	s.ModifyTime = &v
	return s
}

func (s *GetQualityEntityResponseBodyData) SetModifyUser(v string) *GetQualityEntityResponseBodyData {
	s.ModifyUser = &v
	return s
}

func (s *GetQualityEntityResponseBodyData) SetOnDuty(v string) *GetQualityEntityResponseBodyData {
	s.OnDuty = &v
	return s
}

func (s *GetQualityEntityResponseBodyData) SetOnDutyAccountName(v string) *GetQualityEntityResponseBodyData {
	s.OnDutyAccountName = &v
	return s
}

func (s *GetQualityEntityResponseBodyData) SetProjectName(v string) *GetQualityEntityResponseBodyData {
	s.ProjectName = &v
	return s
}

func (s *GetQualityEntityResponseBodyData) SetRelativeNode(v string) *GetQualityEntityResponseBodyData {
	s.RelativeNode = &v
	return s
}

func (s *GetQualityEntityResponseBodyData) SetSql(v int32) *GetQualityEntityResponseBodyData {
	s.Sql = &v
	return s
}

func (s *GetQualityEntityResponseBodyData) SetTableName(v string) *GetQualityEntityResponseBodyData {
	s.TableName = &v
	return s
}

func (s *GetQualityEntityResponseBodyData) SetTask(v int32) *GetQualityEntityResponseBodyData {
	s.Task = &v
	return s
}

type GetQualityEntityResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetQualityEntityResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetQualityEntityResponse) String() string {
	return tea.Prettify(s)
}

func (s GetQualityEntityResponse) GoString() string {
	return s.String()
}

func (s *GetQualityEntityResponse) SetHeaders(v map[string]*string) *GetQualityEntityResponse {
	s.Headers = v
	return s
}

func (s *GetQualityEntityResponse) SetStatusCode(v int32) *GetQualityEntityResponse {
	s.StatusCode = &v
	return s
}

func (s *GetQualityEntityResponse) SetBody(v *GetQualityEntityResponseBody) *GetQualityEntityResponse {
	s.Body = v
	return s
}

type GetQualityFollowerRequest struct {
	EntityId    *int64  `json:"EntityId,omitempty" xml:"EntityId,omitempty"`
	ProjectId   *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s GetQualityFollowerRequest) String() string {
	return tea.Prettify(s)
}

func (s GetQualityFollowerRequest) GoString() string {
	return s.String()
}

func (s *GetQualityFollowerRequest) SetEntityId(v int64) *GetQualityFollowerRequest {
	s.EntityId = &v
	return s
}

func (s *GetQualityFollowerRequest) SetProjectId(v int64) *GetQualityFollowerRequest {
	s.ProjectId = &v
	return s
}

func (s *GetQualityFollowerRequest) SetProjectName(v string) *GetQualityFollowerRequest {
	s.ProjectName = &v
	return s
}

type GetQualityFollowerResponseBody struct {
	Data           []*GetQualityFollowerResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	ErrorCode      *string                               `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string                               `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32                                `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string                               `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                                 `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetQualityFollowerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetQualityFollowerResponseBody) GoString() string {
	return s.String()
}

func (s *GetQualityFollowerResponseBody) SetData(v []*GetQualityFollowerResponseBodyData) *GetQualityFollowerResponseBody {
	s.Data = v
	return s
}

func (s *GetQualityFollowerResponseBody) SetErrorCode(v string) *GetQualityFollowerResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetQualityFollowerResponseBody) SetErrorMessage(v string) *GetQualityFollowerResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetQualityFollowerResponseBody) SetHttpStatusCode(v int32) *GetQualityFollowerResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetQualityFollowerResponseBody) SetRequestId(v string) *GetQualityFollowerResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetQualityFollowerResponseBody) SetSuccess(v bool) *GetQualityFollowerResponseBody {
	s.Success = &v
	return s
}

type GetQualityFollowerResponseBodyData struct {
	AlarmMode           *int32  `json:"AlarmMode,omitempty" xml:"AlarmMode,omitempty"`
	CreateTime          *int64  `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	EntityId            *string `json:"EntityId,omitempty" xml:"EntityId,omitempty"`
	Follower            *string `json:"Follower,omitempty" xml:"Follower,omitempty"`
	FollowerAccountName *string `json:"FollowerAccountName,omitempty" xml:"FollowerAccountName,omitempty"`
	Id                  *int64  `json:"Id,omitempty" xml:"Id,omitempty"`
	ModifyTime          *int64  `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	ProjectName         *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	TableName           *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s GetQualityFollowerResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetQualityFollowerResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetQualityFollowerResponseBodyData) SetAlarmMode(v int32) *GetQualityFollowerResponseBodyData {
	s.AlarmMode = &v
	return s
}

func (s *GetQualityFollowerResponseBodyData) SetCreateTime(v int64) *GetQualityFollowerResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *GetQualityFollowerResponseBodyData) SetEntityId(v string) *GetQualityFollowerResponseBodyData {
	s.EntityId = &v
	return s
}

func (s *GetQualityFollowerResponseBodyData) SetFollower(v string) *GetQualityFollowerResponseBodyData {
	s.Follower = &v
	return s
}

func (s *GetQualityFollowerResponseBodyData) SetFollowerAccountName(v string) *GetQualityFollowerResponseBodyData {
	s.FollowerAccountName = &v
	return s
}

func (s *GetQualityFollowerResponseBodyData) SetId(v int64) *GetQualityFollowerResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetQualityFollowerResponseBodyData) SetModifyTime(v int64) *GetQualityFollowerResponseBodyData {
	s.ModifyTime = &v
	return s
}

func (s *GetQualityFollowerResponseBodyData) SetProjectName(v string) *GetQualityFollowerResponseBodyData {
	s.ProjectName = &v
	return s
}

func (s *GetQualityFollowerResponseBodyData) SetTableName(v string) *GetQualityFollowerResponseBodyData {
	s.TableName = &v
	return s
}

type GetQualityFollowerResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetQualityFollowerResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetQualityFollowerResponse) String() string {
	return tea.Prettify(s)
}

func (s GetQualityFollowerResponse) GoString() string {
	return s.String()
}

func (s *GetQualityFollowerResponse) SetHeaders(v map[string]*string) *GetQualityFollowerResponse {
	s.Headers = v
	return s
}

func (s *GetQualityFollowerResponse) SetStatusCode(v int32) *GetQualityFollowerResponse {
	s.StatusCode = &v
	return s
}

func (s *GetQualityFollowerResponse) SetBody(v *GetQualityFollowerResponseBody) *GetQualityFollowerResponse {
	s.Body = v
	return s
}

type GetQualityRuleRequest struct {
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the compute engine instance or data source.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The ID of the monitoring rule. You can call the [ListQualityRules](~~173995~~) operation to query the ID.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s GetQualityRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s GetQualityRuleRequest) GoString() string {
	return s.String()
}

func (s *GetQualityRuleRequest) SetProjectId(v int64) *GetQualityRuleRequest {
	s.ProjectId = &v
	return s
}

func (s *GetQualityRuleRequest) SetProjectName(v string) *GetQualityRuleRequest {
	s.ProjectName = &v
	return s
}

func (s *GetQualityRuleRequest) SetRuleId(v int64) *GetQualityRuleRequest {
	s.RuleId = &v
	return s
}

type GetQualityRuleResponseBody struct {
	// The information of the monitoring rule.
	Data *GetQualityRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetQualityRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetQualityRuleResponseBody) GoString() string {
	return s.String()
}

func (s *GetQualityRuleResponseBody) SetData(v *GetQualityRuleResponseBodyData) *GetQualityRuleResponseBody {
	s.Data = v
	return s
}

func (s *GetQualityRuleResponseBody) SetErrorCode(v string) *GetQualityRuleResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetQualityRuleResponseBody) SetErrorMessage(v string) *GetQualityRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetQualityRuleResponseBody) SetHttpStatusCode(v int32) *GetQualityRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetQualityRuleResponseBody) SetRequestId(v string) *GetQualityRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetQualityRuleResponseBody) SetSuccess(v bool) *GetQualityRuleResponseBody {
	s.Success = &v
	return s
}

type GetQualityRuleResponseBodyData struct {
	// The strength of the monitoring rule. The strength of a monitoring rule indicates the importance of the rule. Valid values:
	//
	// *   1: indicates that the monitoring rule is a strong rule.
	//
	// *   0: indicates that the monitoring rule is a weak rule.
	//
	//     You can specify whether a monitoring rule is a strong rule based on your business requirements. If a strong rule is used and an error alert is triggered, nodes are blocked.
	BlockType *int32 `json:"BlockType,omitempty" xml:"BlockType,omitempty"`
	// The ID of the checker. The value of this parameter corresponds to the ID at the frontend and is converted from the ID of the primary key.
	Checker *int32 `json:"Checker,omitempty" xml:"Checker,omitempty"`
	// The name of the checker.
	CheckerName *string `json:"CheckerName,omitempty" xml:"CheckerName,omitempty"`
	// The description of the monitoring rule.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The threshold for an error alert. The threshold indicates the deviation of the monitoring result from the expected value. You can customize this threshold based on your business requirements. If a strong rule is used and an error alert is triggered, nodes are blocked.
	CriticalThreshold *string `json:"CriticalThreshold,omitempty" xml:"CriticalThreshold,omitempty"`
	// The ID of the partition filter expression.
	EntityId *int64 `json:"EntityId,omitempty" xml:"EntityId,omitempty"`
	// The expected value.
	ExpectValue *string `json:"ExpectValue,omitempty" xml:"ExpectValue,omitempty"`
	// Indicates whether the monitoring is performed based on a fixed value.
	FixCheck *bool `json:"FixCheck,omitempty" xml:"FixCheck,omitempty"`
	// The ID of the monitoring rule.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the sampling method of the monitoring rule.
	MethodId *int32 `json:"MethodId,omitempty" xml:"MethodId,omitempty"`
	// The name of the method that is used to collect sample data, such as avg, count, sum, min, max, count_distinct, user_defined, table_count, table_size, table_dt_load_count, table_dt_refuseload_count, null_value, null_value/table_count, (table_count-count_distinct)/table_count, or table_count-count_distinct.
	MethodName *string `json:"MethodName,omitempty" xml:"MethodName,omitempty"`
	// The ID of the Alibaba Cloud account that is used to configure the monitoring rule.
	OnDuty *string `json:"OnDuty,omitempty" xml:"OnDuty,omitempty"`
	// The name of the Alibaba Cloud account that is used to configure the monitoring rule.
	OnDutyAccountName *string `json:"OnDutyAccountName,omitempty" xml:"OnDutyAccountName,omitempty"`
	OpenSwitch        *bool   `json:"OpenSwitch,omitempty" xml:"OpenSwitch,omitempty"`
	// The comparison operator of the monitoring rule.
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// Indicates whether the threshold is a dynamic threshold. Valid values:
	//
	// *   0: The threshold is not a dynamic threshold.
	// *   1: The threshold is a dynamic threshold.
	PredictType *int32 `json:"PredictType,omitempty" xml:"PredictType,omitempty"`
	// The field that is monitored. This field is a column name in the data source table that is monitored.
	Property *string `json:"Property,omitempty" xml:"Property,omitempty"`
	// The name of the monitoring rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The type of the monitoring rule.
	RuleType *int32 `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
	// The ID of the monitoring template.
	TemplateId *int32 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The name of the monitoring template.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The trend of the monitoring result.
	Trend *string `json:"Trend,omitempty" xml:"Trend,omitempty"`
	// The threshold for a warning alert. The threshold indicates the deviation of the monitoring result from the expected value. You can customize this threshold based on your business requirements.
	WarningThreshold *string `json:"WarningThreshold,omitempty" xml:"WarningThreshold,omitempty"`
	// The filter condition or custom SQL statement that is used for monitoring.
	WhereCondition *string `json:"WhereCondition,omitempty" xml:"WhereCondition,omitempty"`
}

func (s GetQualityRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetQualityRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetQualityRuleResponseBodyData) SetBlockType(v int32) *GetQualityRuleResponseBodyData {
	s.BlockType = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetChecker(v int32) *GetQualityRuleResponseBodyData {
	s.Checker = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetCheckerName(v string) *GetQualityRuleResponseBodyData {
	s.CheckerName = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetComment(v string) *GetQualityRuleResponseBodyData {
	s.Comment = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetCriticalThreshold(v string) *GetQualityRuleResponseBodyData {
	s.CriticalThreshold = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetEntityId(v int64) *GetQualityRuleResponseBodyData {
	s.EntityId = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetExpectValue(v string) *GetQualityRuleResponseBodyData {
	s.ExpectValue = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetFixCheck(v bool) *GetQualityRuleResponseBodyData {
	s.FixCheck = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetId(v int64) *GetQualityRuleResponseBodyData {
	s.Id = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetMethodId(v int32) *GetQualityRuleResponseBodyData {
	s.MethodId = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetMethodName(v string) *GetQualityRuleResponseBodyData {
	s.MethodName = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetOnDuty(v string) *GetQualityRuleResponseBodyData {
	s.OnDuty = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetOnDutyAccountName(v string) *GetQualityRuleResponseBodyData {
	s.OnDutyAccountName = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetOpenSwitch(v bool) *GetQualityRuleResponseBodyData {
	s.OpenSwitch = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetOperator(v string) *GetQualityRuleResponseBodyData {
	s.Operator = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetPredictType(v int32) *GetQualityRuleResponseBodyData {
	s.PredictType = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetProperty(v string) *GetQualityRuleResponseBodyData {
	s.Property = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetRuleName(v string) *GetQualityRuleResponseBodyData {
	s.RuleName = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetRuleType(v int32) *GetQualityRuleResponseBodyData {
	s.RuleType = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetTemplateId(v int32) *GetQualityRuleResponseBodyData {
	s.TemplateId = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetTemplateName(v string) *GetQualityRuleResponseBodyData {
	s.TemplateName = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetTrend(v string) *GetQualityRuleResponseBodyData {
	s.Trend = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetWarningThreshold(v string) *GetQualityRuleResponseBodyData {
	s.WarningThreshold = &v
	return s
}

func (s *GetQualityRuleResponseBodyData) SetWhereCondition(v string) *GetQualityRuleResponseBodyData {
	s.WhereCondition = &v
	return s
}

type GetQualityRuleResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetQualityRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetQualityRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s GetQualityRuleResponse) GoString() string {
	return s.String()
}

func (s *GetQualityRuleResponse) SetHeaders(v map[string]*string) *GetQualityRuleResponse {
	s.Headers = v
	return s
}

func (s *GetQualityRuleResponse) SetStatusCode(v int32) *GetQualityRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *GetQualityRuleResponse) SetBody(v *GetQualityRuleResponseBody) *GetQualityRuleResponse {
	s.Body = v
	return s
}

type GetRemindRequest struct {
	// The ID of the custom alert rule.
	RemindId *int64 `json:"RemindId,omitempty" xml:"RemindId,omitempty"`
}

func (s GetRemindRequest) String() string {
	return tea.Prettify(s)
}

func (s GetRemindRequest) GoString() string {
	return s.String()
}

func (s *GetRemindRequest) SetRemindId(v int64) *GetRemindRequest {
	s.RemindId = &v
	return s
}

type GetRemindResponseBody struct {
	// The details of the custom alert rule.
	Data *GetRemindResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The unique ID of the request. You can troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetRemindResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetRemindResponseBody) GoString() string {
	return s.String()
}

func (s *GetRemindResponseBody) SetData(v *GetRemindResponseBodyData) *GetRemindResponseBody {
	s.Data = v
	return s
}

func (s *GetRemindResponseBody) SetErrorCode(v string) *GetRemindResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetRemindResponseBody) SetErrorMessage(v string) *GetRemindResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetRemindResponseBody) SetHttpStatusCode(v int32) *GetRemindResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetRemindResponseBody) SetRequestId(v string) *GetRemindResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetRemindResponseBody) SetSuccess(v bool) *GetRemindResponseBody {
	s.Success = &v
	return s
}

type GetRemindResponseBodyData struct {
	// The minimum interval at which alerts are reported. Unit: seconds.
	AlertInterval *int32 `json:"AlertInterval,omitempty" xml:"AlertInterval,omitempty"`
	// The notification method. Valid values:
	//
	// *   MAIL: Alert notifications are sent by emails.
	//
	// *   SMS: Alert notifications are sent by text messages.
	//
	//     Alert notifications can be sent by text messages only in the Singapore (Singapore), Malaysia (Kuala Lumpur), and Germany (Frankfurt) regions.
	//
	// *   Multiple notification methods are separated by commas (,).
	AlertMethods []*string `json:"AlertMethods,omitempty" xml:"AlertMethods,omitempty" type:"Repeated"`
	// *   If the value of the AlertUnit parameter is OWNER, this parameter is left empty.
	// *   If the value of the AlertUnit parameter is OTHER, the ID of the Alibaba Cloud account used by the specified user is returned. Multiple IDs are separated by commas (,).
	AlertTargets []*string `json:"AlertTargets,omitempty" xml:"AlertTargets,omitempty" type:"Repeated"`
	// The recipient of the alert. Valid values: OWNER and OTHER. A value of OWNER indicates the node owner. A value of OTHER indicates a specified user.
	AlertUnit *string `json:"AlertUnit,omitempty" xml:"AlertUnit,omitempty"`
	// The baselines to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is BASELINE.
	Baselines []*GetRemindResponseBodyDataBaselines `json:"Baselines,omitempty" xml:"Baselines,omitempty" type:"Repeated"`
	// The workflows to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is BIZPROCESS.
	BizProcesses []*GetRemindResponseBodyDataBizProcesses `json:"BizProcesses,omitempty" xml:"BizProcesses,omitempty" type:"Repeated"`
	// *   If the value of the RemindType parameter is FINISHED, this parameter is left empty.
	// *   If the value of the RemindType parameter is UNFINISHED, the trigger conditions are returned as key-value pairs. Example: {"hour":23,"minu":59}. Valid values of hour: 0 to 47. Valid values of minu: 0 to 59.
	// *   If the value of the RemindType parameter is ERROR, this parameter is left empty.
	// *   If the value of the RemindType parameter is CYCLE_UNFINISHED, the trigger conditions are returned as key-value pairs. Example: {"1":"05:50","2":"06:50","3":"07:50","4":"08:50","5":"09:50","6":"10:50","7":"11:50","8":"12:50","9":"13:50","10":"14:50","11":"15:50","12":"16:50","13":"17:50","14":"18:50","15":"19:50","16":"20:50","17":"21:50","18":"22:50","19":"23:50","20":"24:50","21":"25:50"}. The key indicates the ID of the cycle. Valid values: 1 to 288. The value indicates the timeout period of the node that is run in the cycle. The value is in the hh:mm format. Valid values of hh: 0 to 47. Valid values of mm: 0 to 59.
	// *   If the value of the RemindType parameter is TIMEOUT, the timeout period is returned. Unit: seconds. Example: 1800. This value indicates that an alert is reported if the node is run for more than 30 minutes.
	Detail *string `json:"Detail,omitempty" xml:"Detail,omitempty"`
	// The end time of the quiet hours. The value is in the hh:mm format. Valid values of hh: 0 to 23. Valid values of mm: 0 to 59.
	DndEnd *string `json:"DndEnd,omitempty" xml:"DndEnd,omitempty"`
	// The start time of the quiet hours. The value is in the hh:mm format. Valid values of hh: 0 to 23. Valid values of mm: 0 to 59.
	DndStart *string `json:"DndStart,omitempty" xml:"DndStart,omitempty"`
	// The ID of the Alibaba Cloud account used by the creator of the custom alert rule.
	Founder *string `json:"Founder,omitempty" xml:"Founder,omitempty"`
	// The maximum number of alerts.
	MaxAlertTimes *int32 `json:"MaxAlertTimes,omitempty" xml:"MaxAlertTimes,omitempty"`
	// The nodes to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is NODE.
	Nodes []*GetRemindResponseBodyDataNodes `json:"Nodes,omitempty" xml:"Nodes,omitempty" type:"Repeated"`
	// The workspaces to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is PROJECT.
	Projects []*GetRemindResponseBodyDataProjects `json:"Projects,omitempty" xml:"Projects,omitempty" type:"Repeated"`
	// The ID of the custom alert rule.
	RemindId *int64 `json:"RemindId,omitempty" xml:"RemindId,omitempty"`
	// The name of the custom alert rule.
	RemindName *string `json:"RemindName,omitempty" xml:"RemindName,omitempty"`
	// The conditions that trigger an alert. Valid values: FINISHED, UNFINISHED, ERROR, CYCLE_UNFINISHED, and TIMEOUT. A value of FINISHED indicates that the node is run. A value of UNFINISHED indicates that the node is still running at the specified point in time. A value of ERROR indicates that an error occurs when the node is running. A value of CYCLE_UNFINISHED indicates that the node is still running in the specified cycle. A value of TIMEOUT indicates that the node times out.
	RemindType *string `json:"RemindType,omitempty" xml:"RemindType,omitempty"`
	// The type of the object to which the custom alert rule is applied. Valid values: NODE, BASELINE, PROJECT, and BIZPROCESS. A value of NODE indicates that the monitored object is a node. A value of BASELINE indicates that the monitored object is a baseline. A value of PROJECT indicates that the monitored object is a workspace. A value of BIZPROCESS indicates that the monitored object is a workflow.
	RemindUnit *string `json:"RemindUnit,omitempty" xml:"RemindUnit,omitempty"`
	// The webhook URLs of the DingTalk chatbots.
	Robots []*GetRemindResponseBodyDataRobots `json:"Robots,omitempty" xml:"Robots,omitempty" type:"Repeated"`
	// Indicates whether the custom alert rule is enabled. Valid values: true and false.
	Useflag *bool `json:"Useflag,omitempty" xml:"Useflag,omitempty"`
	// -
	Webhooks []*string `json:"Webhooks,omitempty" xml:"Webhooks,omitempty" type:"Repeated"`
}

func (s GetRemindResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetRemindResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetRemindResponseBodyData) SetAlertInterval(v int32) *GetRemindResponseBodyData {
	s.AlertInterval = &v
	return s
}

func (s *GetRemindResponseBodyData) SetAlertMethods(v []*string) *GetRemindResponseBodyData {
	s.AlertMethods = v
	return s
}

func (s *GetRemindResponseBodyData) SetAlertTargets(v []*string) *GetRemindResponseBodyData {
	s.AlertTargets = v
	return s
}

func (s *GetRemindResponseBodyData) SetAlertUnit(v string) *GetRemindResponseBodyData {
	s.AlertUnit = &v
	return s
}

func (s *GetRemindResponseBodyData) SetBaselines(v []*GetRemindResponseBodyDataBaselines) *GetRemindResponseBodyData {
	s.Baselines = v
	return s
}

func (s *GetRemindResponseBodyData) SetBizProcesses(v []*GetRemindResponseBodyDataBizProcesses) *GetRemindResponseBodyData {
	s.BizProcesses = v
	return s
}

func (s *GetRemindResponseBodyData) SetDetail(v string) *GetRemindResponseBodyData {
	s.Detail = &v
	return s
}

func (s *GetRemindResponseBodyData) SetDndEnd(v string) *GetRemindResponseBodyData {
	s.DndEnd = &v
	return s
}

func (s *GetRemindResponseBodyData) SetDndStart(v string) *GetRemindResponseBodyData {
	s.DndStart = &v
	return s
}

func (s *GetRemindResponseBodyData) SetFounder(v string) *GetRemindResponseBodyData {
	s.Founder = &v
	return s
}

func (s *GetRemindResponseBodyData) SetMaxAlertTimes(v int32) *GetRemindResponseBodyData {
	s.MaxAlertTimes = &v
	return s
}

func (s *GetRemindResponseBodyData) SetNodes(v []*GetRemindResponseBodyDataNodes) *GetRemindResponseBodyData {
	s.Nodes = v
	return s
}

func (s *GetRemindResponseBodyData) SetProjects(v []*GetRemindResponseBodyDataProjects) *GetRemindResponseBodyData {
	s.Projects = v
	return s
}

func (s *GetRemindResponseBodyData) SetRemindId(v int64) *GetRemindResponseBodyData {
	s.RemindId = &v
	return s
}

func (s *GetRemindResponseBodyData) SetRemindName(v string) *GetRemindResponseBodyData {
	s.RemindName = &v
	return s
}

func (s *GetRemindResponseBodyData) SetRemindType(v string) *GetRemindResponseBodyData {
	s.RemindType = &v
	return s
}

func (s *GetRemindResponseBodyData) SetRemindUnit(v string) *GetRemindResponseBodyData {
	s.RemindUnit = &v
	return s
}

func (s *GetRemindResponseBodyData) SetRobots(v []*GetRemindResponseBodyDataRobots) *GetRemindResponseBodyData {
	s.Robots = v
	return s
}

func (s *GetRemindResponseBodyData) SetUseflag(v bool) *GetRemindResponseBodyData {
	s.Useflag = &v
	return s
}

func (s *GetRemindResponseBodyData) SetWebhooks(v []*string) *GetRemindResponseBodyData {
	s.Webhooks = v
	return s
}

type GetRemindResponseBodyDataBaselines struct {
	// The ID of the baseline.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The name of the baseline.
	BaselineName *string `json:"BaselineName,omitempty" xml:"BaselineName,omitempty"`
}

func (s GetRemindResponseBodyDataBaselines) String() string {
	return tea.Prettify(s)
}

func (s GetRemindResponseBodyDataBaselines) GoString() string {
	return s.String()
}

func (s *GetRemindResponseBodyDataBaselines) SetBaselineId(v int64) *GetRemindResponseBodyDataBaselines {
	s.BaselineId = &v
	return s
}

func (s *GetRemindResponseBodyDataBaselines) SetBaselineName(v string) *GetRemindResponseBodyDataBaselines {
	s.BaselineName = &v
	return s
}

type GetRemindResponseBodyDataBizProcesses struct {
	// The ID of the workflow.
	BizId *int64 `json:"BizId,omitempty" xml:"BizId,omitempty"`
	// The name of the workflow.
	BizProcessName *string `json:"BizProcessName,omitempty" xml:"BizProcessName,omitempty"`
}

func (s GetRemindResponseBodyDataBizProcesses) String() string {
	return tea.Prettify(s)
}

func (s GetRemindResponseBodyDataBizProcesses) GoString() string {
	return s.String()
}

func (s *GetRemindResponseBodyDataBizProcesses) SetBizId(v int64) *GetRemindResponseBodyDataBizProcesses {
	s.BizId = &v
	return s
}

func (s *GetRemindResponseBodyDataBizProcesses) SetBizProcessName(v string) *GetRemindResponseBodyDataBizProcesses {
	s.BizProcessName = &v
	return s
}

type GetRemindResponseBodyDataNodes struct {
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The ID of the Alibaba Cloud account used by the owner of the node.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ID of the workspace to which the node belongs.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetRemindResponseBodyDataNodes) String() string {
	return tea.Prettify(s)
}

func (s GetRemindResponseBodyDataNodes) GoString() string {
	return s.String()
}

func (s *GetRemindResponseBodyDataNodes) SetNodeId(v int64) *GetRemindResponseBodyDataNodes {
	s.NodeId = &v
	return s
}

func (s *GetRemindResponseBodyDataNodes) SetNodeName(v string) *GetRemindResponseBodyDataNodes {
	s.NodeName = &v
	return s
}

func (s *GetRemindResponseBodyDataNodes) SetOwner(v string) *GetRemindResponseBodyDataNodes {
	s.Owner = &v
	return s
}

func (s *GetRemindResponseBodyDataNodes) SetProjectId(v int64) *GetRemindResponseBodyDataNodes {
	s.ProjectId = &v
	return s
}

type GetRemindResponseBodyDataProjects struct {
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetRemindResponseBodyDataProjects) String() string {
	return tea.Prettify(s)
}

func (s GetRemindResponseBodyDataProjects) GoString() string {
	return s.String()
}

func (s *GetRemindResponseBodyDataProjects) SetProjectId(v int64) *GetRemindResponseBodyDataProjects {
	s.ProjectId = &v
	return s
}

type GetRemindResponseBodyDataRobots struct {
	// Indicates whether all group members are notified when the alert notification is sent to a DingTalk group. Valid values: true and false.
	AtAll *bool `json:"AtAll,omitempty" xml:"AtAll,omitempty"`
	// The webhook URL of the DingTalk chatbot.
	WebUrl *string `json:"WebUrl,omitempty" xml:"WebUrl,omitempty"`
}

func (s GetRemindResponseBodyDataRobots) String() string {
	return tea.Prettify(s)
}

func (s GetRemindResponseBodyDataRobots) GoString() string {
	return s.String()
}

func (s *GetRemindResponseBodyDataRobots) SetAtAll(v bool) *GetRemindResponseBodyDataRobots {
	s.AtAll = &v
	return s
}

func (s *GetRemindResponseBodyDataRobots) SetWebUrl(v string) *GetRemindResponseBodyDataRobots {
	s.WebUrl = &v
	return s
}

type GetRemindResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetRemindResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetRemindResponse) String() string {
	return tea.Prettify(s)
}

func (s GetRemindResponse) GoString() string {
	return s.String()
}

func (s *GetRemindResponse) SetHeaders(v map[string]*string) *GetRemindResponse {
	s.Headers = v
	return s
}

func (s *GetRemindResponse) SetStatusCode(v int32) *GetRemindResponse {
	s.StatusCode = &v
	return s
}

func (s *GetRemindResponse) SetBody(v *GetRemindResponseBody) *GetRemindResponse {
	s.Body = v
	return s
}

type GetSensitiveDataRequest struct {
	// The parameters that you can specify to query the access records. Valid values:
	//
	// *   dbType: the data type
	// *   instanceName: the name of the instance
	// *   databaseName: the name of the database
	// *   projectName: the name of the workspace
	// *   clusterName: the name of the cluster
	//
	// The following example shows the parameters configured to query the access records of the sensitive data in the abc database of the ABC Hologres instance:
	//
	// {"dbType":"hologres","instanceName":"ABC","databaseName":"abc"}
	//
	// You must specify the parameters based on the compute engine that you use in your business.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of the page to return. Minimum value:1.
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page. Maximum value: 1000.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s GetSensitiveDataRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSensitiveDataRequest) GoString() string {
	return s.String()
}

func (s *GetSensitiveDataRequest) SetName(v string) *GetSensitiveDataRequest {
	s.Name = &v
	return s
}

func (s *GetSensitiveDataRequest) SetPageNo(v int32) *GetSensitiveDataRequest {
	s.PageNo = &v
	return s
}

func (s *GetSensitiveDataRequest) SetPageSize(v int32) *GetSensitiveDataRequest {
	s.PageSize = &v
	return s
}

type GetSensitiveDataResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information of the sensitive data returned. The information includes totalCount and sensDatas.
	//
	// sensDatas includes the following parameters:
	//
	// *   guid: the ID of the metadata of the tenant. For example, the ID of the metadata in the MaxCompute compute engine is in the Project name.Table name.Column name format.
	// *   sensType: the type of the sensitive data.
	// *   sensLevel: the sensitivity level of the sensitive data.
	SensitiveData map[string]interface{} `json:"SensitiveData,omitempty" xml:"SensitiveData,omitempty"`
}

func (s GetSensitiveDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSensitiveDataResponseBody) GoString() string {
	return s.String()
}

func (s *GetSensitiveDataResponseBody) SetRequestId(v string) *GetSensitiveDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSensitiveDataResponseBody) SetSensitiveData(v map[string]interface{}) *GetSensitiveDataResponseBody {
	s.SensitiveData = v
	return s
}

type GetSensitiveDataResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetSensitiveDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetSensitiveDataResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSensitiveDataResponse) GoString() string {
	return s.String()
}

func (s *GetSensitiveDataResponse) SetHeaders(v map[string]*string) *GetSensitiveDataResponse {
	s.Headers = v
	return s
}

func (s *GetSensitiveDataResponse) SetStatusCode(v int32) *GetSensitiveDataResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSensitiveDataResponse) SetBody(v *GetSensitiveDataResponseBody) *GetSensitiveDataResponse {
	s.Body = v
	return s
}

type GetSuccessInstanceTrendRequest struct {
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetSuccessInstanceTrendRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSuccessInstanceTrendRequest) GoString() string {
	return s.String()
}

func (s *GetSuccessInstanceTrendRequest) SetProjectId(v int64) *GetSuccessInstanceTrendRequest {
	s.ProjectId = &v
	return s
}

type GetSuccessInstanceTrendResponseBody struct {
	InstanceStatusTrend *GetSuccessInstanceTrendResponseBodyInstanceStatusTrend `json:"InstanceStatusTrend,omitempty" xml:"InstanceStatusTrend,omitempty" type:"Struct"`
	RequestId           *string                                                 `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s GetSuccessInstanceTrendResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSuccessInstanceTrendResponseBody) GoString() string {
	return s.String()
}

func (s *GetSuccessInstanceTrendResponseBody) SetInstanceStatusTrend(v *GetSuccessInstanceTrendResponseBodyInstanceStatusTrend) *GetSuccessInstanceTrendResponseBody {
	s.InstanceStatusTrend = v
	return s
}

func (s *GetSuccessInstanceTrendResponseBody) SetRequestId(v string) *GetSuccessInstanceTrendResponseBody {
	s.RequestId = &v
	return s
}

type GetSuccessInstanceTrendResponseBodyInstanceStatusTrend struct {
	AvgTrend       []*GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend       `json:"AvgTrend,omitempty" xml:"AvgTrend,omitempty" type:"Repeated"`
	TodayTrend     []*GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend     `json:"TodayTrend,omitempty" xml:"TodayTrend,omitempty" type:"Repeated"`
	YesterdayTrend []*GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend `json:"YesterdayTrend,omitempty" xml:"YesterdayTrend,omitempty" type:"Repeated"`
}

func (s GetSuccessInstanceTrendResponseBodyInstanceStatusTrend) String() string {
	return tea.Prettify(s)
}

func (s GetSuccessInstanceTrendResponseBodyInstanceStatusTrend) GoString() string {
	return s.String()
}

func (s *GetSuccessInstanceTrendResponseBodyInstanceStatusTrend) SetAvgTrend(v []*GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend) *GetSuccessInstanceTrendResponseBodyInstanceStatusTrend {
	s.AvgTrend = v
	return s
}

func (s *GetSuccessInstanceTrendResponseBodyInstanceStatusTrend) SetTodayTrend(v []*GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend) *GetSuccessInstanceTrendResponseBodyInstanceStatusTrend {
	s.TodayTrend = v
	return s
}

func (s *GetSuccessInstanceTrendResponseBodyInstanceStatusTrend) SetYesterdayTrend(v []*GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend) *GetSuccessInstanceTrendResponseBodyInstanceStatusTrend {
	s.YesterdayTrend = v
	return s
}

type GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend struct {
	Count     *int32  `json:"Count,omitempty" xml:"Count,omitempty"`
	TimePoint *string `json:"TimePoint,omitempty" xml:"TimePoint,omitempty"`
}

func (s GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend) String() string {
	return tea.Prettify(s)
}

func (s GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend) GoString() string {
	return s.String()
}

func (s *GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend) SetCount(v int32) *GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend {
	s.Count = &v
	return s
}

func (s *GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend) SetTimePoint(v string) *GetSuccessInstanceTrendResponseBodyInstanceStatusTrendAvgTrend {
	s.TimePoint = &v
	return s
}

type GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend struct {
	Count     *int32  `json:"Count,omitempty" xml:"Count,omitempty"`
	TimePoint *string `json:"TimePoint,omitempty" xml:"TimePoint,omitempty"`
}

func (s GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend) String() string {
	return tea.Prettify(s)
}

func (s GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend) GoString() string {
	return s.String()
}

func (s *GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend) SetCount(v int32) *GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend {
	s.Count = &v
	return s
}

func (s *GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend) SetTimePoint(v string) *GetSuccessInstanceTrendResponseBodyInstanceStatusTrendTodayTrend {
	s.TimePoint = &v
	return s
}

type GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend struct {
	Count     *int32  `json:"Count,omitempty" xml:"Count,omitempty"`
	TimePoint *string `json:"TimePoint,omitempty" xml:"TimePoint,omitempty"`
}

func (s GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend) String() string {
	return tea.Prettify(s)
}

func (s GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend) GoString() string {
	return s.String()
}

func (s *GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend) SetCount(v int32) *GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend {
	s.Count = &v
	return s
}

func (s *GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend) SetTimePoint(v string) *GetSuccessInstanceTrendResponseBodyInstanceStatusTrendYesterdayTrend {
	s.TimePoint = &v
	return s
}

type GetSuccessInstanceTrendResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetSuccessInstanceTrendResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetSuccessInstanceTrendResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSuccessInstanceTrendResponse) GoString() string {
	return s.String()
}

func (s *GetSuccessInstanceTrendResponse) SetHeaders(v map[string]*string) *GetSuccessInstanceTrendResponse {
	s.Headers = v
	return s
}

func (s *GetSuccessInstanceTrendResponse) SetStatusCode(v int32) *GetSuccessInstanceTrendResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSuccessInstanceTrendResponse) SetBody(v *GetSuccessInstanceTrendResponseBody) *GetSuccessInstanceTrendResponse {
	s.Body = v
	return s
}

type GetTopicRequest struct {
	// The ID of the request. You can troubleshoot issues based on the ID.
	TopicId *int64 `json:"TopicId,omitempty" xml:"TopicId,omitempty"`
}

func (s GetTopicRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTopicRequest) GoString() string {
	return s.String()
}

func (s *GetTopicRequest) SetTopicId(v int64) *GetTopicRequest {
	s.TopicId = &v
	return s
}

type GetTopicResponseBody struct {
	// The name of the event.
	Data *GetTopicResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The details of the event.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request is successful.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The error message returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error code returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the Apsara Stack tenant account used by the event owner.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetTopicResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTopicResponseBody) GoString() string {
	return s.String()
}

func (s *GetTopicResponseBody) SetData(v *GetTopicResponseBodyData) *GetTopicResponseBody {
	s.Data = v
	return s
}

func (s *GetTopicResponseBody) SetErrorCode(v string) *GetTopicResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetTopicResponseBody) SetErrorMessage(v string) *GetTopicResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetTopicResponseBody) SetHttpStatusCode(v int32) *GetTopicResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetTopicResponseBody) SetRequestId(v string) *GetTopicResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTopicResponseBody) SetSuccess(v bool) *GetTopicResponseBody {
	s.Success = &v
	return s
}

type GetTopicResponseBodyData struct {
	AddTime *int64 `json:"AddTime,omitempty" xml:"AddTime,omitempty"`
	// The ID of the Apsara Stack tenant account used by the alert recipient.
	AlertTime *int64 `json:"AlertTime,omitempty" xml:"AlertTime,omitempty"`
	// The timestamp when the event was found.
	Assigner *string `json:"Assigner,omitempty" xml:"Assigner,omitempty"`
	// The status of the event. Valid values: IGNORE, NEW, FIXING, and RECOVER. A value of IGNORE indicates that the event is ignored. A value of NEW indicates that the event is a new event. A value of FIXING indicates that the event is being processed. A value of RECOVER indicates that the event is processed.
	BaselineBuffer *int64 `json:"BaselineBuffer,omitempty" xml:"BaselineBuffer,omitempty"`
	// The timestamp when the first alert was reported.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The type of the event. Valid values: SLOW and ERROR. A value of SLOW indicates that the duration of the task is significantly longer than the average duration of the task in previous cycles. A value of ERROR indicates that the task fails to run.
	BaselineInGroupId *int32 `json:"BaselineInGroupId,omitempty" xml:"BaselineInGroupId,omitempty"`
	// The name of the node that triggered the event.
	BaselineName *string `json:"BaselineName,omitempty" xml:"BaselineName,omitempty"`
	// The timestamp when the system reports the next alert.
	BaselineStatus *string `json:"BaselineStatus,omitempty" xml:"BaselineStatus,omitempty"`
	// The ID of the event.
	Buffer *int64 `json:"Buffer,omitempty" xml:"Buffer,omitempty"`
	// The name of the baseline to which the worst baseline instance belongs.
	DealTime *int64 `json:"DealTime,omitempty" xml:"DealTime,omitempty"`
	// The ID of the baseline to which the worst baseline instance belongs.
	DealUser *string `json:"DealUser,omitempty" xml:"DealUser,omitempty"`
	// The margin of the worst baseline instance. Unit: seconds.
	FixTime *int64 `json:"FixTime,omitempty" xml:"FixTime,omitempty"`
	// The ID of the Apsara Stack tenant account used by the user who last processed the event.
	HappenTime *int64 `json:"HappenTime,omitempty" xml:"HappenTime,omitempty"`
	// The ID of the cycle of the worst baseline instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The timestamp when the event was processed.
	NextAlertTime *int64 `json:"NextAlertTime,omitempty" xml:"NextAlertTime,omitempty"`
	NodeId        *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The margin of the event. Unit: seconds.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The status of the baseline. Valid values: ERROR, SAFE, DANGROUS, and OVER. A value of ERROR indicates that no nodes are associated with the baseline, or all nodes associated with the baseline are suspended. A value of SAFE indicates that nodes are run before the alert duration begins. A value of DANGROUS indicates that nodes are still running after the alert duration ends but the committed time does not arrive. A value of OVER indicates that nodes are still running after the committed time.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ID of the instance that triggered the event.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the node that triggered the event.
	TopicId *int64 `json:"TopicId,omitempty" xml:"TopicId,omitempty"`
	// The ID of the workspace to which the node that triggered the event belongs.
	TopicName *string `json:"TopicName,omitempty" xml:"TopicName,omitempty"`
	// The timestamp when the event was last processed.
	TopicStatus *string `json:"TopicStatus,omitempty" xml:"TopicStatus,omitempty"`
	// The timestamp when the system event occurred. A time difference may exist between the time when the event occurred and the time when the event was found.
	TopicType *string `json:"TopicType,omitempty" xml:"TopicType,omitempty"`
}

func (s GetTopicResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetTopicResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetTopicResponseBodyData) SetAddTime(v int64) *GetTopicResponseBodyData {
	s.AddTime = &v
	return s
}

func (s *GetTopicResponseBodyData) SetAlertTime(v int64) *GetTopicResponseBodyData {
	s.AlertTime = &v
	return s
}

func (s *GetTopicResponseBodyData) SetAssigner(v string) *GetTopicResponseBodyData {
	s.Assigner = &v
	return s
}

func (s *GetTopicResponseBodyData) SetBaselineBuffer(v int64) *GetTopicResponseBodyData {
	s.BaselineBuffer = &v
	return s
}

func (s *GetTopicResponseBodyData) SetBaselineId(v int64) *GetTopicResponseBodyData {
	s.BaselineId = &v
	return s
}

func (s *GetTopicResponseBodyData) SetBaselineInGroupId(v int32) *GetTopicResponseBodyData {
	s.BaselineInGroupId = &v
	return s
}

func (s *GetTopicResponseBodyData) SetBaselineName(v string) *GetTopicResponseBodyData {
	s.BaselineName = &v
	return s
}

func (s *GetTopicResponseBodyData) SetBaselineStatus(v string) *GetTopicResponseBodyData {
	s.BaselineStatus = &v
	return s
}

func (s *GetTopicResponseBodyData) SetBuffer(v int64) *GetTopicResponseBodyData {
	s.Buffer = &v
	return s
}

func (s *GetTopicResponseBodyData) SetDealTime(v int64) *GetTopicResponseBodyData {
	s.DealTime = &v
	return s
}

func (s *GetTopicResponseBodyData) SetDealUser(v string) *GetTopicResponseBodyData {
	s.DealUser = &v
	return s
}

func (s *GetTopicResponseBodyData) SetFixTime(v int64) *GetTopicResponseBodyData {
	s.FixTime = &v
	return s
}

func (s *GetTopicResponseBodyData) SetHappenTime(v int64) *GetTopicResponseBodyData {
	s.HappenTime = &v
	return s
}

func (s *GetTopicResponseBodyData) SetInstanceId(v int64) *GetTopicResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *GetTopicResponseBodyData) SetNextAlertTime(v int64) *GetTopicResponseBodyData {
	s.NextAlertTime = &v
	return s
}

func (s *GetTopicResponseBodyData) SetNodeId(v int64) *GetTopicResponseBodyData {
	s.NodeId = &v
	return s
}

func (s *GetTopicResponseBodyData) SetNodeName(v string) *GetTopicResponseBodyData {
	s.NodeName = &v
	return s
}

func (s *GetTopicResponseBodyData) SetOwner(v string) *GetTopicResponseBodyData {
	s.Owner = &v
	return s
}

func (s *GetTopicResponseBodyData) SetProjectId(v int64) *GetTopicResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *GetTopicResponseBodyData) SetTopicId(v int64) *GetTopicResponseBodyData {
	s.TopicId = &v
	return s
}

func (s *GetTopicResponseBodyData) SetTopicName(v string) *GetTopicResponseBodyData {
	s.TopicName = &v
	return s
}

func (s *GetTopicResponseBodyData) SetTopicStatus(v string) *GetTopicResponseBodyData {
	s.TopicStatus = &v
	return s
}

func (s *GetTopicResponseBodyData) SetTopicType(v string) *GetTopicResponseBodyData {
	s.TopicType = &v
	return s
}

type GetTopicResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetTopicResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetTopicResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTopicResponse) GoString() string {
	return s.String()
}

func (s *GetTopicResponse) SetHeaders(v map[string]*string) *GetTopicResponse {
	s.Headers = v
	return s
}

func (s *GetTopicResponse) SetStatusCode(v int32) *GetTopicResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTopicResponse) SetBody(v *GetTopicResponseBody) *GetTopicResponse {
	s.Body = v
	return s
}

type GetTopicInfluenceRequest struct {
	TopicId *int64 `json:"TopicId,omitempty" xml:"TopicId,omitempty"`
}

func (s GetTopicInfluenceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetTopicInfluenceRequest) GoString() string {
	return s.String()
}

func (s *GetTopicInfluenceRequest) SetTopicId(v int64) *GetTopicInfluenceRequest {
	s.TopicId = &v
	return s
}

type GetTopicInfluenceResponseBody struct {
	Data           *GetTopicInfluenceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorCode      *string                            `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string                            `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32                             `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                              `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetTopicInfluenceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetTopicInfluenceResponseBody) GoString() string {
	return s.String()
}

func (s *GetTopicInfluenceResponseBody) SetData(v *GetTopicInfluenceResponseBodyData) *GetTopicInfluenceResponseBody {
	s.Data = v
	return s
}

func (s *GetTopicInfluenceResponseBody) SetErrorCode(v string) *GetTopicInfluenceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *GetTopicInfluenceResponseBody) SetErrorMessage(v string) *GetTopicInfluenceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetTopicInfluenceResponseBody) SetHttpStatusCode(v int32) *GetTopicInfluenceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *GetTopicInfluenceResponseBody) SetRequestId(v string) *GetTopicInfluenceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetTopicInfluenceResponseBody) SetSuccess(v bool) *GetTopicInfluenceResponseBody {
	s.Success = &v
	return s
}

type GetTopicInfluenceResponseBodyData struct {
	Influences []*GetTopicInfluenceResponseBodyDataInfluences `json:"Influences,omitempty" xml:"Influences,omitempty" type:"Repeated"`
	TopicId    *int64                                         `json:"TopicId,omitempty" xml:"TopicId,omitempty"`
}

func (s GetTopicInfluenceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetTopicInfluenceResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetTopicInfluenceResponseBodyData) SetInfluences(v []*GetTopicInfluenceResponseBodyDataInfluences) *GetTopicInfluenceResponseBodyData {
	s.Influences = v
	return s
}

func (s *GetTopicInfluenceResponseBodyData) SetTopicId(v int64) *GetTopicInfluenceResponseBodyData {
	s.TopicId = &v
	return s
}

type GetTopicInfluenceResponseBodyDataInfluences struct {
	BaselineId   *int64  `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	BaselineName *string `json:"BaselineName,omitempty" xml:"BaselineName,omitempty"`
	Bizdate      *int64  `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	Buffer       *int64  `json:"Buffer,omitempty" xml:"Buffer,omitempty"`
	InGroupId    *int32  `json:"InGroupId,omitempty" xml:"InGroupId,omitempty"`
	Owner        *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	Priority     *int32  `json:"Priority,omitempty" xml:"Priority,omitempty"`
	ProjectId    *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	Status       *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetTopicInfluenceResponseBodyDataInfluences) String() string {
	return tea.Prettify(s)
}

func (s GetTopicInfluenceResponseBodyDataInfluences) GoString() string {
	return s.String()
}

func (s *GetTopicInfluenceResponseBodyDataInfluences) SetBaselineId(v int64) *GetTopicInfluenceResponseBodyDataInfluences {
	s.BaselineId = &v
	return s
}

func (s *GetTopicInfluenceResponseBodyDataInfluences) SetBaselineName(v string) *GetTopicInfluenceResponseBodyDataInfluences {
	s.BaselineName = &v
	return s
}

func (s *GetTopicInfluenceResponseBodyDataInfluences) SetBizdate(v int64) *GetTopicInfluenceResponseBodyDataInfluences {
	s.Bizdate = &v
	return s
}

func (s *GetTopicInfluenceResponseBodyDataInfluences) SetBuffer(v int64) *GetTopicInfluenceResponseBodyDataInfluences {
	s.Buffer = &v
	return s
}

func (s *GetTopicInfluenceResponseBodyDataInfluences) SetInGroupId(v int32) *GetTopicInfluenceResponseBodyDataInfluences {
	s.InGroupId = &v
	return s
}

func (s *GetTopicInfluenceResponseBodyDataInfluences) SetOwner(v string) *GetTopicInfluenceResponseBodyDataInfluences {
	s.Owner = &v
	return s
}

func (s *GetTopicInfluenceResponseBodyDataInfluences) SetPriority(v int32) *GetTopicInfluenceResponseBodyDataInfluences {
	s.Priority = &v
	return s
}

func (s *GetTopicInfluenceResponseBodyDataInfluences) SetProjectId(v int64) *GetTopicInfluenceResponseBodyDataInfluences {
	s.ProjectId = &v
	return s
}

func (s *GetTopicInfluenceResponseBodyDataInfluences) SetStatus(v string) *GetTopicInfluenceResponseBodyDataInfluences {
	s.Status = &v
	return s
}

type GetTopicInfluenceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *GetTopicInfluenceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s GetTopicInfluenceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetTopicInfluenceResponse) GoString() string {
	return s.String()
}

func (s *GetTopicInfluenceResponse) SetHeaders(v map[string]*string) *GetTopicInfluenceResponse {
	s.Headers = v
	return s
}

func (s *GetTopicInfluenceResponse) SetStatusCode(v int32) *GetTopicInfluenceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetTopicInfluenceResponse) SetBody(v *GetTopicInfluenceResponseBody) *GetTopicInfluenceResponse {
	s.Body = v
	return s
}

type ImportDataSourcesRequest struct {
	// The configurations of the data sources to be imported. The Name, DataSourceType, SubType, Description, Content, and EnvType fields are required. For more information about the fields, see [CreateDataSource](~~211429~~).
	DataSources *string `json:"DataSources,omitempty" xml:"DataSources,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ImportDataSourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportDataSourcesRequest) GoString() string {
	return s.String()
}

func (s *ImportDataSourcesRequest) SetDataSources(v string) *ImportDataSourcesRequest {
	s.DataSources = &v
	return s
}

func (s *ImportDataSourcesRequest) SetProjectId(v int64) *ImportDataSourcesRequest {
	s.ProjectId = &v
	return s
}

type ImportDataSourcesResponseBody struct {
	// The information about the import operation.
	Data *ImportDataSourcesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ImportDataSourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ImportDataSourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ImportDataSourcesResponseBody) SetData(v *ImportDataSourcesResponseBodyData) *ImportDataSourcesResponseBody {
	s.Data = v
	return s
}

func (s *ImportDataSourcesResponseBody) SetRequestId(v string) *ImportDataSourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ImportDataSourcesResponseBody) SetSuccess(v bool) *ImportDataSourcesResponseBody {
	s.Success = &v
	return s
}

type ImportDataSourcesResponseBodyData struct {
	// The reason why the data sources failed to be imported. If the data sources were imported, this parameter is left empty.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Indicates whether the data sources were imported. Valid values:
	//
	// *   true: All the data sources were imported.
	// *   false: Some of the data sources failed to be imported. You can troubleshoot issues based on the Message parameter.
	Status *bool `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ImportDataSourcesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ImportDataSourcesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ImportDataSourcesResponseBodyData) SetMessage(v string) *ImportDataSourcesResponseBodyData {
	s.Message = &v
	return s
}

func (s *ImportDataSourcesResponseBodyData) SetStatus(v bool) *ImportDataSourcesResponseBodyData {
	s.Status = &v
	return s
}

type ImportDataSourcesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ImportDataSourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ImportDataSourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ImportDataSourcesResponse) GoString() string {
	return s.String()
}

func (s *ImportDataSourcesResponse) SetHeaders(v map[string]*string) *ImportDataSourcesResponse {
	s.Headers = v
	return s
}

func (s *ImportDataSourcesResponse) SetStatusCode(v int32) *ImportDataSourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ImportDataSourcesResponse) SetBody(v *ImportDataSourcesResponseBody) *ImportDataSourcesResponse {
	s.Body = v
	return s
}

type ListAlertMessagesRequest struct {
	// The notification method. Valid values:
	//
	// *   MAIL: email
	//
	// *   SMS: text message
	//
	//     Alert notifications can be sent by text message only in the Singapore, Malaysia (Kuala Lumpur), and Germany (Frankfurt) regions.
	//
	// You can specify multiple notification methods. Separate them with commas (,).
	AlertMethods *string `json:"AlertMethods,omitempty" xml:"AlertMethods,omitempty"`
	// The type of the alert rule. Valid values: GLOBAL, USER_DEFINE, and OTHER. The value GLOBAL indicates that the alert rule is a global alert rule. The value USER_DEFINE indicates that the alert rule is customized by a user. The value OTHER indicates that the alert rule is a rule of another type. You can specify multiple types. Separate them with commas (,).
	AlertRuleTypes *string `json:"AlertRuleTypes,omitempty" xml:"AlertRuleTypes,omitempty"`
	// The ID of the Alibaba Cloud account used by the alert recipient.
	AlertUser *string `json:"AlertUser,omitempty" xml:"AlertUser,omitempty"`
	// The ID of the baseline. This parameter takes effect if the AlertRuleTypes parameter is set to GLOBAL.
	//
	// You can configure either this parameter or RemindId.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The beginning of the time range to query. Specify the time in the yyyy-MM-dd\"T\"HH:mm:ssZ format. The time must be in UTC.
	BeginTime *string `json:"BeginTime,omitempty" xml:"BeginTime,omitempty"`
	// The end of the time range to query. Specify the time in the yyyy-MM-dd\"T\"HH:mm:ssZ format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The number of the page to return. Valid values: 1 to 30. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the custom alert rule. This parameter takes effect if the AlertRuleTypes parameter is set to USER_DEFINE.
	//
	// You can configure either this parameter or BaselineId.
	RemindId *int64 `json:"RemindId,omitempty" xml:"RemindId,omitempty"`
}

func (s ListAlertMessagesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAlertMessagesRequest) GoString() string {
	return s.String()
}

func (s *ListAlertMessagesRequest) SetAlertMethods(v string) *ListAlertMessagesRequest {
	s.AlertMethods = &v
	return s
}

func (s *ListAlertMessagesRequest) SetAlertRuleTypes(v string) *ListAlertMessagesRequest {
	s.AlertRuleTypes = &v
	return s
}

func (s *ListAlertMessagesRequest) SetAlertUser(v string) *ListAlertMessagesRequest {
	s.AlertUser = &v
	return s
}

func (s *ListAlertMessagesRequest) SetBaselineId(v int64) *ListAlertMessagesRequest {
	s.BaselineId = &v
	return s
}

func (s *ListAlertMessagesRequest) SetBeginTime(v string) *ListAlertMessagesRequest {
	s.BeginTime = &v
	return s
}

func (s *ListAlertMessagesRequest) SetEndTime(v string) *ListAlertMessagesRequest {
	s.EndTime = &v
	return s
}

func (s *ListAlertMessagesRequest) SetPageNumber(v int32) *ListAlertMessagesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListAlertMessagesRequest) SetPageSize(v int32) *ListAlertMessagesRequest {
	s.PageSize = &v
	return s
}

func (s *ListAlertMessagesRequest) SetRemindId(v int64) *ListAlertMessagesRequest {
	s.RemindId = &v
	return s
}

type ListAlertMessagesResponseBody struct {
	// The information about returned alerts.
	Data *ListAlertMessagesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListAlertMessagesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAlertMessagesResponseBody) GoString() string {
	return s.String()
}

func (s *ListAlertMessagesResponseBody) SetData(v *ListAlertMessagesResponseBodyData) *ListAlertMessagesResponseBody {
	s.Data = v
	return s
}

func (s *ListAlertMessagesResponseBody) SetErrorCode(v string) *ListAlertMessagesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListAlertMessagesResponseBody) SetErrorMessage(v string) *ListAlertMessagesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListAlertMessagesResponseBody) SetHttpStatusCode(v int32) *ListAlertMessagesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListAlertMessagesResponseBody) SetRequestId(v string) *ListAlertMessagesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAlertMessagesResponseBody) SetSuccess(v bool) *ListAlertMessagesResponseBody {
	s.Success = &v
	return s
}

type ListAlertMessagesResponseBodyData struct {
	// The alerts.
	AlertMessages []*ListAlertMessagesResponseBodyDataAlertMessages `json:"AlertMessages,omitempty" xml:"AlertMessages,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *string `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *string `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of returned alerts.
	TotalCount *string `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListAlertMessagesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListAlertMessagesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListAlertMessagesResponseBodyData) SetAlertMessages(v []*ListAlertMessagesResponseBodyDataAlertMessages) *ListAlertMessagesResponseBodyData {
	s.AlertMessages = v
	return s
}

func (s *ListAlertMessagesResponseBodyData) SetPageNumber(v string) *ListAlertMessagesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListAlertMessagesResponseBodyData) SetPageSize(v string) *ListAlertMessagesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListAlertMessagesResponseBodyData) SetTotalCount(v string) *ListAlertMessagesResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListAlertMessagesResponseBodyDataAlertMessages struct {
	// The ID of the alert.
	AlertId *int64 `json:"AlertId,omitempty" xml:"AlertId,omitempty"`
	// The sending status of the notification. Valid values: READY_TO_SEND, SEND_FAIL, SEND_SUCCESS, and SEND_OVERLIMIT. The value READY_TO_SEND indicates that the notification is waiting to be sent. The value SEND_FAIL indicates that the notification fails to be sent. The value SEND_SUCCESS indicates that the notification is sent. The value SEND_OVERLIMIT indicates that the number of notifications that are sent exceeds the upper limit.
	AlertMessageStatus *string `json:"AlertMessageStatus,omitempty" xml:"AlertMessageStatus,omitempty"`
	// The notification method. Valid values: MAIL, SMS, and PHONE. The value MAIL indicates that the notification is sent by email. The value SMS indicates that the notification is sent by text message. The value PHONE indicates that the notification is sent by phone call. Only DataWorks Professional Edition and more advanced editions support the PHONE notification method.
	AlertMethod *string `json:"AlertMethod,omitempty" xml:"AlertMethod,omitempty"`
	// The timestamp when the alert was reported.
	AlertTime *int64 `json:"AlertTime,omitempty" xml:"AlertTime,omitempty"`
	// The ID of the Alibaba Cloud used by the alert recipient.
	AlertUser *string `json:"AlertUser,omitempty" xml:"AlertUser,omitempty"`
	// The content of the alert.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The instances that triggered the custom alert rule. This parameter is returned if the value of the Source parameter is REMIND_ALERT. This parameter is left empty if the value of the Source parameter is not REMIND_ALERT.
	Instances []*ListAlertMessagesResponseBodyDataAlertMessagesInstances `json:"Instances,omitempty" xml:"Instances,omitempty" type:"Repeated"`
	// The nodes returned for different alert sources.
	//
	// *   The nodes that form a loop are returned if the value of the Source parameter is NODE_CYCLE_ALERT.
	// *   The nodes that are isolated are returned if the value of the Source parameter is NODE_LONELY_ALERT.
	Nodes []*ListAlertMessagesResponseBodyDataAlertMessagesNodes `json:"Nodes,omitempty" xml:"Nodes,omitempty" type:"Repeated"`
	// The ID of the custom alert rule that was triggered. This parameter is returned if the value of the Source parameter is REMIND_ALERT.
	RemindId *int64 `json:"RemindId,omitempty" xml:"RemindId,omitempty"`
	// The name of the custom alert rule that was triggered. This parameter is returned if the value of the Source parameter is REMIND_ALERT.
	RemindName *string `json:"RemindName,omitempty" xml:"RemindName,omitempty"`
	// The basic information about the baseline instance that triggered an alert. This parameter is returned if the value of the Source parameter is SLA_ALERT. This parameter is left empty if the value of the Source parameter is not SLA_ALERT.
	SlaAlert *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert `json:"SlaAlert,omitempty" xml:"SlaAlert,omitempty" type:"Struct"`
	// The type of the alert. Valid values: REMIND_ALERT, TOPIC_ALERT, SLA_ALERT, NODE_CYCLE_ALERT, and NODE_LONELY_ALERT. The value REMIND_ALERT indicates that the alert is a custom alert. The value TOPIC_ALERT indicates that the alert is an event alert. The value SLA_ALERT indicates that the alert is a baseline alert. The value NODE_CYCLE_ALERT indicates that the alert is reported for a node dependency loop. The value NODE_LONELY_ALERT indicates that the alert is reported for isolated nodes.
	Source *string `json:"Source,omitempty" xml:"Source,omitempty"`
	// The events that triggered alerts. This parameter is returned if the value of the Source parameter is TOPIC_ALERT. This parameter is left empty if the value of the Source parameter is not TOPIC_ALERT.
	Topics []*ListAlertMessagesResponseBodyDataAlertMessagesTopics `json:"Topics,omitempty" xml:"Topics,omitempty" type:"Repeated"`
}

func (s ListAlertMessagesResponseBodyDataAlertMessages) String() string {
	return tea.Prettify(s)
}

func (s ListAlertMessagesResponseBodyDataAlertMessages) GoString() string {
	return s.String()
}

func (s *ListAlertMessagesResponseBodyDataAlertMessages) SetAlertId(v int64) *ListAlertMessagesResponseBodyDataAlertMessages {
	s.AlertId = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessages) SetAlertMessageStatus(v string) *ListAlertMessagesResponseBodyDataAlertMessages {
	s.AlertMessageStatus = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessages) SetAlertMethod(v string) *ListAlertMessagesResponseBodyDataAlertMessages {
	s.AlertMethod = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessages) SetAlertTime(v int64) *ListAlertMessagesResponseBodyDataAlertMessages {
	s.AlertTime = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessages) SetAlertUser(v string) *ListAlertMessagesResponseBodyDataAlertMessages {
	s.AlertUser = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessages) SetContent(v string) *ListAlertMessagesResponseBodyDataAlertMessages {
	s.Content = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessages) SetInstances(v []*ListAlertMessagesResponseBodyDataAlertMessagesInstances) *ListAlertMessagesResponseBodyDataAlertMessages {
	s.Instances = v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessages) SetNodes(v []*ListAlertMessagesResponseBodyDataAlertMessagesNodes) *ListAlertMessagesResponseBodyDataAlertMessages {
	s.Nodes = v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessages) SetRemindId(v int64) *ListAlertMessagesResponseBodyDataAlertMessages {
	s.RemindId = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessages) SetRemindName(v string) *ListAlertMessagesResponseBodyDataAlertMessages {
	s.RemindName = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessages) SetSlaAlert(v *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert) *ListAlertMessagesResponseBodyDataAlertMessages {
	s.SlaAlert = v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessages) SetSource(v string) *ListAlertMessagesResponseBodyDataAlertMessages {
	s.Source = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessages) SetTopics(v []*ListAlertMessagesResponseBodyDataAlertMessagesTopics) *ListAlertMessagesResponseBodyDataAlertMessages {
	s.Topics = v
	return s
}

type ListAlertMessagesResponseBodyDataAlertMessagesInstances struct {
	// The ID of the instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The ID of the workspace to which the node belongs.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The status of the instance. Valid values: NOT_RUN, WAIT_TIME, WAIT_RESOURCE, RUNNING, CHECKING, CHECKING_CONDITION, FAILURE, and SUCCESS. The value NOT_RUN indicates that the instance is not run. The value WAIT_TIME indicates that the instance is waiting to be run. The value WAIT_RESOURCE indicates that the instance is waiting for resources. The value RUNNING indicates that the instance is running. The value CHECKING indicates that data quality is being checked for the node. The value CHECKING_CONDITION indicates that branch conditions are being checked for the node. The value FAILURE indicates that the instance fails to run. The value SUCCESS indicates that the instance is successfully run.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListAlertMessagesResponseBodyDataAlertMessagesInstances) String() string {
	return tea.Prettify(s)
}

func (s ListAlertMessagesResponseBodyDataAlertMessagesInstances) GoString() string {
	return s.String()
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesInstances) SetInstanceId(v int64) *ListAlertMessagesResponseBodyDataAlertMessagesInstances {
	s.InstanceId = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesInstances) SetNodeId(v int64) *ListAlertMessagesResponseBodyDataAlertMessagesInstances {
	s.NodeId = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesInstances) SetNodeName(v string) *ListAlertMessagesResponseBodyDataAlertMessagesInstances {
	s.NodeName = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesInstances) SetProjectId(v int64) *ListAlertMessagesResponseBodyDataAlertMessagesInstances {
	s.ProjectId = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesInstances) SetStatus(v string) *ListAlertMessagesResponseBodyDataAlertMessagesInstances {
	s.Status = &v
	return s
}

type ListAlertMessagesResponseBodyDataAlertMessagesNodes struct {
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The ID of the Alibaba Cloud account used by the owner of the node.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ID of the workspace to which the node belongs.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListAlertMessagesResponseBodyDataAlertMessagesNodes) String() string {
	return tea.Prettify(s)
}

func (s ListAlertMessagesResponseBodyDataAlertMessagesNodes) GoString() string {
	return s.String()
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesNodes) SetNodeId(v int64) *ListAlertMessagesResponseBodyDataAlertMessagesNodes {
	s.NodeId = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesNodes) SetNodeName(v string) *ListAlertMessagesResponseBodyDataAlertMessagesNodes {
	s.NodeName = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesNodes) SetOwner(v string) *ListAlertMessagesResponseBodyDataAlertMessagesNodes {
	s.Owner = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesNodes) SetProjectId(v int64) *ListAlertMessagesResponseBodyDataAlertMessagesNodes {
	s.ProjectId = &v
	return s
}

type ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert struct {
	// The ID of the baseline.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The name of the baseline.
	BaselineName *string `json:"BaselineName,omitempty" xml:"BaselineName,omitempty"`
	// The ID of the Alibaba Cloud account used by the baseline owner. Multiple IDs are separated by commas (,).
	BaselineOwner *string `json:"BaselineOwner,omitempty" xml:"BaselineOwner,omitempty"`
	// The data timestamp of the baseline instance.
	Bizdate *int64 `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	// The ID of the cycle of the baseline instance. Valid values of the ID of an hour-level cycle: 1 to 24. The ID of a day-level cycle is 1.
	InGroupId *int32 `json:"InGroupId,omitempty" xml:"InGroupId,omitempty"`
	// The ID of the workspace to which the baseline belongs.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The status of the baseline. Valid values: ERROR, SAFE, DANGROUS, and OVER. The value ERROR indicates that no nodes are associated with the baseline, or all nodes associated with the baseline are suspended. The value SAFE indicates that nodes are run before the alert duration begins. The value DANGROUS indicates that nodes are still running after the alert duration ends but the committed time does not arrive. The value OVER indicates that nodes are still running after the committed time.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert) String() string {
	return tea.Prettify(s)
}

func (s ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert) GoString() string {
	return s.String()
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert) SetBaselineId(v int64) *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert {
	s.BaselineId = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert) SetBaselineName(v string) *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert {
	s.BaselineName = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert) SetBaselineOwner(v string) *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert {
	s.BaselineOwner = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert) SetBizdate(v int64) *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert {
	s.Bizdate = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert) SetInGroupId(v int32) *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert {
	s.InGroupId = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert) SetProjectId(v int64) *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert {
	s.ProjectId = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert) SetStatus(v string) *ListAlertMessagesResponseBodyDataAlertMessagesSlaAlert {
	s.Status = &v
	return s
}

type ListAlertMessagesResponseBodyDataAlertMessagesTopics struct {
	// The ID of the instance that triggered the event.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the node that triggered the event.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the event.
	TopicId *int64 `json:"TopicId,omitempty" xml:"TopicId,omitempty"`
	// The name of the event.
	TopicName *string `json:"TopicName,omitempty" xml:"TopicName,omitempty"`
	// The ID of the Alibaba Cloud account used by the event owner.
	TopicOwner *string `json:"TopicOwner,omitempty" xml:"TopicOwner,omitempty"`
	// The status of the event. Valid values: IGNORE, NEW, FIXING, and RECOVER. The value IGNORE indicates that the event is ignored. The value NEW indicates that the event is a new event. The value FIXING indicates that the event is being handled. The value RECOVER indicates that the event is handled.
	TopicStatus *string `json:"TopicStatus,omitempty" xml:"TopicStatus,omitempty"`
}

func (s ListAlertMessagesResponseBodyDataAlertMessagesTopics) String() string {
	return tea.Prettify(s)
}

func (s ListAlertMessagesResponseBodyDataAlertMessagesTopics) GoString() string {
	return s.String()
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesTopics) SetInstanceId(v int64) *ListAlertMessagesResponseBodyDataAlertMessagesTopics {
	s.InstanceId = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesTopics) SetNodeId(v int64) *ListAlertMessagesResponseBodyDataAlertMessagesTopics {
	s.NodeId = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesTopics) SetTopicId(v int64) *ListAlertMessagesResponseBodyDataAlertMessagesTopics {
	s.TopicId = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesTopics) SetTopicName(v string) *ListAlertMessagesResponseBodyDataAlertMessagesTopics {
	s.TopicName = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesTopics) SetTopicOwner(v string) *ListAlertMessagesResponseBodyDataAlertMessagesTopics {
	s.TopicOwner = &v
	return s
}

func (s *ListAlertMessagesResponseBodyDataAlertMessagesTopics) SetTopicStatus(v string) *ListAlertMessagesResponseBodyDataAlertMessagesTopics {
	s.TopicStatus = &v
	return s
}

type ListAlertMessagesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListAlertMessagesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListAlertMessagesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAlertMessagesResponse) GoString() string {
	return s.String()
}

func (s *ListAlertMessagesResponse) SetHeaders(v map[string]*string) *ListAlertMessagesResponse {
	s.Headers = v
	return s
}

func (s *ListAlertMessagesResponse) SetStatusCode(v int32) *ListAlertMessagesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAlertMessagesResponse) SetBody(v *ListAlertMessagesResponseBody) *ListAlertMessagesResponse {
	s.Body = v
	return s
}

type ListBaselineConfigsRequest struct {
	// The type of the baseline. Valid values: DAILY and HOURLY. A value of DAILY indicates that the baseline is a day-level baseline. A value of HOURLY indicates that the baseline is an hour-level baseline. Separate multiple baseline types with commas (,).
	BaselineTypes *string `json:"BaselineTypes,omitempty" xml:"BaselineTypes,omitempty"`
	// The ID of the Alibaba Cloud account used by the baseline owner.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The number of the page to return. Valid values: 1 to 30. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 100. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The priority of the baseline. Valid values: 1, 3, 5, 7, and 8. Separate multiple priorities with commas (,).
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the workspace. You can call the ListProjects operation to query the ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The keyword in the baseline name used to search for the baseline.
	SearchText *string `json:"SearchText,omitempty" xml:"SearchText,omitempty"`
	// Specifies whether to enable the baseline. Valid values: true and false.
	Useflag *bool `json:"Useflag,omitempty" xml:"Useflag,omitempty"`
}

func (s ListBaselineConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListBaselineConfigsRequest) GoString() string {
	return s.String()
}

func (s *ListBaselineConfigsRequest) SetBaselineTypes(v string) *ListBaselineConfigsRequest {
	s.BaselineTypes = &v
	return s
}

func (s *ListBaselineConfigsRequest) SetOwner(v string) *ListBaselineConfigsRequest {
	s.Owner = &v
	return s
}

func (s *ListBaselineConfigsRequest) SetPageNumber(v int32) *ListBaselineConfigsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListBaselineConfigsRequest) SetPageSize(v int32) *ListBaselineConfigsRequest {
	s.PageSize = &v
	return s
}

func (s *ListBaselineConfigsRequest) SetPriority(v string) *ListBaselineConfigsRequest {
	s.Priority = &v
	return s
}

func (s *ListBaselineConfigsRequest) SetProjectId(v int64) *ListBaselineConfigsRequest {
	s.ProjectId = &v
	return s
}

func (s *ListBaselineConfigsRequest) SetSearchText(v string) *ListBaselineConfigsRequest {
	s.SearchText = &v
	return s
}

func (s *ListBaselineConfigsRequest) SetUseflag(v bool) *ListBaselineConfigsRequest {
	s.Useflag = &v
	return s
}

type ListBaselineConfigsResponseBody struct {
	// The return results of the request.
	Data *ListBaselineConfigsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The unique ID of the request. You can troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListBaselineConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListBaselineConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *ListBaselineConfigsResponseBody) SetData(v *ListBaselineConfigsResponseBodyData) *ListBaselineConfigsResponseBody {
	s.Data = v
	return s
}

func (s *ListBaselineConfigsResponseBody) SetErrorCode(v string) *ListBaselineConfigsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListBaselineConfigsResponseBody) SetErrorMessage(v string) *ListBaselineConfigsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListBaselineConfigsResponseBody) SetHttpStatusCode(v int32) *ListBaselineConfigsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListBaselineConfigsResponseBody) SetRequestId(v string) *ListBaselineConfigsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListBaselineConfigsResponseBody) SetSuccess(v bool) *ListBaselineConfigsResponseBody {
	s.Success = &v
	return s
}

type ListBaselineConfigsResponseBodyData struct {
	// The list of baselines.
	Baselines []*ListBaselineConfigsResponseBodyDataBaselines `json:"Baselines,omitempty" xml:"Baselines,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of baselines returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListBaselineConfigsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListBaselineConfigsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListBaselineConfigsResponseBodyData) SetBaselines(v []*ListBaselineConfigsResponseBodyDataBaselines) *ListBaselineConfigsResponseBodyData {
	s.Baselines = v
	return s
}

func (s *ListBaselineConfigsResponseBodyData) SetPageNumber(v int32) *ListBaselineConfigsResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListBaselineConfigsResponseBodyData) SetPageSize(v int32) *ListBaselineConfigsResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListBaselineConfigsResponseBodyData) SetTotalCount(v int32) *ListBaselineConfigsResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListBaselineConfigsResponseBodyDataBaselines struct {
	// The ID of the baseline.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The name of the baseline.
	BaselineName *string `json:"BaselineName,omitempty" xml:"BaselineName,omitempty"`
	// The type of the baseline. Valid values: DAILY and HOURLY. A value of DAILY indicates that the baseline is a day-level baseline. A value of HOURLY indicates that the baseline is an hour-level baseline.
	BaselineType *string `json:"BaselineType,omitempty" xml:"BaselineType,omitempty"`
	// The hour in the alert time of the day-level baseline. Valid values: 0 to 47.
	ExpHour *int32 `json:"ExpHour,omitempty" xml:"ExpHour,omitempty"`
	// The minute in the alert time of the day-level baseline. Valid values: 0 to 59.
	ExpMinu *int32 `json:"ExpMinu,omitempty" xml:"ExpMinu,omitempty"`
	// The alert time of the hour-level baseline. This parameter is presented as key-value pairs in the JSON format. The key indicates the ID of the cycle, and the value is presented in the hh:mm format. Valid values of hh: 0 to 47. Valid values of mm: 0 to 59.
	HourExpDetail *string `json:"HourExpDetail,omitempty" xml:"HourExpDetail,omitempty"`
	// The committed time of the hour-level baseline. This parameter is presented as key-value pairs in the JSON format. The key indicates the ID of the cycle, and the value is presented in the hh:mm format. Valid values of hh: 0 to 47. Valid values of mm: 0 to 59.
	HourSlaDetail *string `json:"HourSlaDetail,omitempty" xml:"HourSlaDetail,omitempty"`
	// Indicates whether the baseline is a default baseline of the workspace. Valid values: true and false.
	IsDefault *bool `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The ID of the Alibaba Cloud account used by the baseline owner. Multiple IDs are separated by commas (,).
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The priority of the baseline. Valid values: 1, 3, 5, 7, and 8.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the workspace to which the baseline belongs.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The hour in the committed time of the day-level baseline. Valid values: 0 to 47.
	SlaHour *int32 `json:"SlaHour,omitempty" xml:"SlaHour,omitempty"`
	// The minute in the alert time of the day-level baseline. Valid values: 0 to 59.
	SlaMinu *int32 `json:"SlaMinu,omitempty" xml:"SlaMinu,omitempty"`
	// Indicates whether the baseline is enabled. Valid values: true and false.
	UseFlag *bool `json:"UseFlag,omitempty" xml:"UseFlag,omitempty"`
}

func (s ListBaselineConfigsResponseBodyDataBaselines) String() string {
	return tea.Prettify(s)
}

func (s ListBaselineConfigsResponseBodyDataBaselines) GoString() string {
	return s.String()
}

func (s *ListBaselineConfigsResponseBodyDataBaselines) SetBaselineId(v int64) *ListBaselineConfigsResponseBodyDataBaselines {
	s.BaselineId = &v
	return s
}

func (s *ListBaselineConfigsResponseBodyDataBaselines) SetBaselineName(v string) *ListBaselineConfigsResponseBodyDataBaselines {
	s.BaselineName = &v
	return s
}

func (s *ListBaselineConfigsResponseBodyDataBaselines) SetBaselineType(v string) *ListBaselineConfigsResponseBodyDataBaselines {
	s.BaselineType = &v
	return s
}

func (s *ListBaselineConfigsResponseBodyDataBaselines) SetExpHour(v int32) *ListBaselineConfigsResponseBodyDataBaselines {
	s.ExpHour = &v
	return s
}

func (s *ListBaselineConfigsResponseBodyDataBaselines) SetExpMinu(v int32) *ListBaselineConfigsResponseBodyDataBaselines {
	s.ExpMinu = &v
	return s
}

func (s *ListBaselineConfigsResponseBodyDataBaselines) SetHourExpDetail(v string) *ListBaselineConfigsResponseBodyDataBaselines {
	s.HourExpDetail = &v
	return s
}

func (s *ListBaselineConfigsResponseBodyDataBaselines) SetHourSlaDetail(v string) *ListBaselineConfigsResponseBodyDataBaselines {
	s.HourSlaDetail = &v
	return s
}

func (s *ListBaselineConfigsResponseBodyDataBaselines) SetIsDefault(v bool) *ListBaselineConfigsResponseBodyDataBaselines {
	s.IsDefault = &v
	return s
}

func (s *ListBaselineConfigsResponseBodyDataBaselines) SetOwner(v string) *ListBaselineConfigsResponseBodyDataBaselines {
	s.Owner = &v
	return s
}

func (s *ListBaselineConfigsResponseBodyDataBaselines) SetPriority(v int32) *ListBaselineConfigsResponseBodyDataBaselines {
	s.Priority = &v
	return s
}

func (s *ListBaselineConfigsResponseBodyDataBaselines) SetProjectId(v int64) *ListBaselineConfigsResponseBodyDataBaselines {
	s.ProjectId = &v
	return s
}

func (s *ListBaselineConfigsResponseBodyDataBaselines) SetSlaHour(v int32) *ListBaselineConfigsResponseBodyDataBaselines {
	s.SlaHour = &v
	return s
}

func (s *ListBaselineConfigsResponseBodyDataBaselines) SetSlaMinu(v int32) *ListBaselineConfigsResponseBodyDataBaselines {
	s.SlaMinu = &v
	return s
}

func (s *ListBaselineConfigsResponseBodyDataBaselines) SetUseFlag(v bool) *ListBaselineConfigsResponseBodyDataBaselines {
	s.UseFlag = &v
	return s
}

type ListBaselineConfigsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListBaselineConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListBaselineConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListBaselineConfigsResponse) GoString() string {
	return s.String()
}

func (s *ListBaselineConfigsResponse) SetHeaders(v map[string]*string) *ListBaselineConfigsResponse {
	s.Headers = v
	return s
}

func (s *ListBaselineConfigsResponse) SetStatusCode(v int32) *ListBaselineConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListBaselineConfigsResponse) SetBody(v *ListBaselineConfigsResponseBody) *ListBaselineConfigsResponse {
	s.Body = v
	return s
}

type ListBaselineStatusesRequest struct {
	// The type of the baseline. Valid values: DAILY and HOURLY. The value DAILY indicates that the baseline is scheduled by day. The value HOURLY indicates that the baseline is scheduled by hour. Multiple types are separated by commas (,).
	BaselineTypes *string `json:"BaselineTypes,omitempty" xml:"BaselineTypes,omitempty"`
	// The data timestamp of the baseline instance. Specify the time in the ISO 8601 standard in the yyyy-MM-dd\"T\"HH:mm:ssZ format. The time must be in UTC.
	Bizdate *string `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	// The status of the baseline instance. Valid values: UNFINISH and FINISH. The value UNFINISH indicates that the baseline instance is still running. The value FINISH indicates that the baseline instance finishes running. Multiple states are separated by commas (,).
	FinishStatus *string `json:"FinishStatus,omitempty" xml:"FinishStatus,omitempty"`
	// The ID of the Alibaba Cloud account used by the baseline owner.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The number of the page to return. Valid values: 1 to 30. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The priority of the baseline. Valid values: 1, 3, 5, 7, and 8. Multiple priorities are separated by commas (,).
	Priority *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The keyword of the baseline name used to search for the baseline.
	SearchText *string `json:"SearchText,omitempty" xml:"SearchText,omitempty"`
	// The status of the baseline. Valid values: ERROR, SAFE, DANGEROUS, and OVER. The value ERROR indicates that no nodes are associated with the baseline, or all nodes associated with the baseline are suspended. The value SAFE indicates that nodes finish running before the alerting time. The value DANGEROUS indicates that nodes are still running after the alerting time but before the committed completion time. The value OVER indicates that nodes are still running after the committed completion time. Multiple states are separated by commas (,).
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the event.
	TopicId *int64 `json:"TopicId,omitempty" xml:"TopicId,omitempty"`
}

func (s ListBaselineStatusesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListBaselineStatusesRequest) GoString() string {
	return s.String()
}

func (s *ListBaselineStatusesRequest) SetBaselineTypes(v string) *ListBaselineStatusesRequest {
	s.BaselineTypes = &v
	return s
}

func (s *ListBaselineStatusesRequest) SetBizdate(v string) *ListBaselineStatusesRequest {
	s.Bizdate = &v
	return s
}

func (s *ListBaselineStatusesRequest) SetFinishStatus(v string) *ListBaselineStatusesRequest {
	s.FinishStatus = &v
	return s
}

func (s *ListBaselineStatusesRequest) SetOwner(v string) *ListBaselineStatusesRequest {
	s.Owner = &v
	return s
}

func (s *ListBaselineStatusesRequest) SetPageNumber(v int32) *ListBaselineStatusesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListBaselineStatusesRequest) SetPageSize(v int32) *ListBaselineStatusesRequest {
	s.PageSize = &v
	return s
}

func (s *ListBaselineStatusesRequest) SetPriority(v string) *ListBaselineStatusesRequest {
	s.Priority = &v
	return s
}

func (s *ListBaselineStatusesRequest) SetSearchText(v string) *ListBaselineStatusesRequest {
	s.SearchText = &v
	return s
}

func (s *ListBaselineStatusesRequest) SetStatus(v string) *ListBaselineStatusesRequest {
	s.Status = &v
	return s
}

func (s *ListBaselineStatusesRequest) SetTopicId(v int64) *ListBaselineStatusesRequest {
	s.TopicId = &v
	return s
}

type ListBaselineStatusesResponseBody struct {
	// The list of baseline instances returned.
	Data *ListBaselineStatusesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListBaselineStatusesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListBaselineStatusesResponseBody) GoString() string {
	return s.String()
}

func (s *ListBaselineStatusesResponseBody) SetData(v *ListBaselineStatusesResponseBodyData) *ListBaselineStatusesResponseBody {
	s.Data = v
	return s
}

func (s *ListBaselineStatusesResponseBody) SetErrorCode(v string) *ListBaselineStatusesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListBaselineStatusesResponseBody) SetErrorMessage(v string) *ListBaselineStatusesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListBaselineStatusesResponseBody) SetHttpStatusCode(v int32) *ListBaselineStatusesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListBaselineStatusesResponseBody) SetRequestId(v string) *ListBaselineStatusesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListBaselineStatusesResponseBody) SetSuccess(v bool) *ListBaselineStatusesResponseBody {
	s.Success = &v
	return s
}

type ListBaselineStatusesResponseBodyData struct {
	// The list of baseline instances.
	BaselineStatuses []*ListBaselineStatusesResponseBodyDataBaselineStatuses `json:"BaselineStatuses,omitempty" xml:"BaselineStatuses,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of baseline instances.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListBaselineStatusesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListBaselineStatusesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListBaselineStatusesResponseBodyData) SetBaselineStatuses(v []*ListBaselineStatusesResponseBodyDataBaselineStatuses) *ListBaselineStatusesResponseBodyData {
	s.BaselineStatuses = v
	return s
}

func (s *ListBaselineStatusesResponseBodyData) SetPageNumber(v int32) *ListBaselineStatusesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListBaselineStatusesResponseBodyData) SetPageSize(v int32) *ListBaselineStatusesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListBaselineStatusesResponseBodyData) SetTotalCount(v int32) *ListBaselineStatusesResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListBaselineStatusesResponseBodyDataBaselineStatuses struct {
	// The ID of the baseline.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The name of the baseline.
	BaselineName *string `json:"BaselineName,omitempty" xml:"BaselineName,omitempty"`
	// The data timestamp of the baseline instance.
	Bizdate *int64 `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	// The margin of the baseline instance. Unit: seconds.
	Buffer *int64 `json:"Buffer,omitempty" xml:"Buffer,omitempty"`
	// The predicted time when the baseline instance finished running.
	EndCast *int64 `json:"EndCast,omitempty" xml:"EndCast,omitempty"`
	// The alerting time of the baseline instance.
	ExpTime *int64 `json:"ExpTime,omitempty" xml:"ExpTime,omitempty"`
	// The status of the baseline instance. Valid values: UNFINISH and FINISH. The value UNFINISH indicates that the baseline instance is still running. The value FINISH indicates that the baseline instance finishes running.
	FinishStatus *string `json:"FinishStatus,omitempty" xml:"FinishStatus,omitempty"`
	// The timestamp of the actual time when the baseline instance finished running. This parameter is returned if the value of the FinishStatus parameter is FINISH.
	FinishTime *int64 `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	// The ID of the scheduling cycle of the baseline instance. For a baseline instance that is scheduled by day, the value of this parameter is 1. For a baseline instance that is scheduled by hour, the value of this parameter ranges from 1 to 24.
	InGroupId *int32 `json:"InGroupId,omitempty" xml:"InGroupId,omitempty"`
	// The ID of the Alibaba Cloud account used by the baseline owner. Multiple IDs are separated by commas (,).
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The priority of the baseline. Valid values: 1, 3, 5, 7, and 8.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The ID of the workspace to which the baseline belongs.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The actual time when the baseline instance finished running.
	SlaTime *int64 `json:"SlaTime,omitempty" xml:"SlaTime,omitempty"`
	// The status of the baseline. Valid values: ERROR, SAFE, DANGEROUS, and OVER. The value ERROR indicates that no nodes are associated with the baseline, or all nodes associated with the baseline are suspended. The value SAFE indicates that nodes finish running before the alerting time. The value DANGEROUS indicates that nodes are still running after the alerting time but before the committed completion time. The value OVER indicates that nodes are still running after the committed completion time.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListBaselineStatusesResponseBodyDataBaselineStatuses) String() string {
	return tea.Prettify(s)
}

func (s ListBaselineStatusesResponseBodyDataBaselineStatuses) GoString() string {
	return s.String()
}

func (s *ListBaselineStatusesResponseBodyDataBaselineStatuses) SetBaselineId(v int64) *ListBaselineStatusesResponseBodyDataBaselineStatuses {
	s.BaselineId = &v
	return s
}

func (s *ListBaselineStatusesResponseBodyDataBaselineStatuses) SetBaselineName(v string) *ListBaselineStatusesResponseBodyDataBaselineStatuses {
	s.BaselineName = &v
	return s
}

func (s *ListBaselineStatusesResponseBodyDataBaselineStatuses) SetBizdate(v int64) *ListBaselineStatusesResponseBodyDataBaselineStatuses {
	s.Bizdate = &v
	return s
}

func (s *ListBaselineStatusesResponseBodyDataBaselineStatuses) SetBuffer(v int64) *ListBaselineStatusesResponseBodyDataBaselineStatuses {
	s.Buffer = &v
	return s
}

func (s *ListBaselineStatusesResponseBodyDataBaselineStatuses) SetEndCast(v int64) *ListBaselineStatusesResponseBodyDataBaselineStatuses {
	s.EndCast = &v
	return s
}

func (s *ListBaselineStatusesResponseBodyDataBaselineStatuses) SetExpTime(v int64) *ListBaselineStatusesResponseBodyDataBaselineStatuses {
	s.ExpTime = &v
	return s
}

func (s *ListBaselineStatusesResponseBodyDataBaselineStatuses) SetFinishStatus(v string) *ListBaselineStatusesResponseBodyDataBaselineStatuses {
	s.FinishStatus = &v
	return s
}

func (s *ListBaselineStatusesResponseBodyDataBaselineStatuses) SetFinishTime(v int64) *ListBaselineStatusesResponseBodyDataBaselineStatuses {
	s.FinishTime = &v
	return s
}

func (s *ListBaselineStatusesResponseBodyDataBaselineStatuses) SetInGroupId(v int32) *ListBaselineStatusesResponseBodyDataBaselineStatuses {
	s.InGroupId = &v
	return s
}

func (s *ListBaselineStatusesResponseBodyDataBaselineStatuses) SetOwner(v string) *ListBaselineStatusesResponseBodyDataBaselineStatuses {
	s.Owner = &v
	return s
}

func (s *ListBaselineStatusesResponseBodyDataBaselineStatuses) SetPriority(v int32) *ListBaselineStatusesResponseBodyDataBaselineStatuses {
	s.Priority = &v
	return s
}

func (s *ListBaselineStatusesResponseBodyDataBaselineStatuses) SetProjectId(v int64) *ListBaselineStatusesResponseBodyDataBaselineStatuses {
	s.ProjectId = &v
	return s
}

func (s *ListBaselineStatusesResponseBodyDataBaselineStatuses) SetSlaTime(v int64) *ListBaselineStatusesResponseBodyDataBaselineStatuses {
	s.SlaTime = &v
	return s
}

func (s *ListBaselineStatusesResponseBodyDataBaselineStatuses) SetStatus(v string) *ListBaselineStatusesResponseBodyDataBaselineStatuses {
	s.Status = &v
	return s
}

type ListBaselineStatusesResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListBaselineStatusesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListBaselineStatusesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListBaselineStatusesResponse) GoString() string {
	return s.String()
}

func (s *ListBaselineStatusesResponse) SetHeaders(v map[string]*string) *ListBaselineStatusesResponse {
	s.Headers = v
	return s
}

func (s *ListBaselineStatusesResponse) SetStatusCode(v int32) *ListBaselineStatusesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListBaselineStatusesResponse) SetBody(v *ListBaselineStatusesResponseBody) *ListBaselineStatusesResponse {
	s.Body = v
	return s
}

type ListBaselinesRequest struct {
	BaselineTypes *string `json:"BaselineTypes,omitempty" xml:"BaselineTypes,omitempty"`
	Enable        *bool   `json:"Enable,omitempty" xml:"Enable,omitempty"`
	Owner         *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	PageNumber    *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Priority      *string `json:"Priority,omitempty" xml:"Priority,omitempty"`
	ProjectId     *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	SearchText    *string `json:"SearchText,omitempty" xml:"SearchText,omitempty"`
}

func (s ListBaselinesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListBaselinesRequest) GoString() string {
	return s.String()
}

func (s *ListBaselinesRequest) SetBaselineTypes(v string) *ListBaselinesRequest {
	s.BaselineTypes = &v
	return s
}

func (s *ListBaselinesRequest) SetEnable(v bool) *ListBaselinesRequest {
	s.Enable = &v
	return s
}

func (s *ListBaselinesRequest) SetOwner(v string) *ListBaselinesRequest {
	s.Owner = &v
	return s
}

func (s *ListBaselinesRequest) SetPageNumber(v int32) *ListBaselinesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListBaselinesRequest) SetPageSize(v int32) *ListBaselinesRequest {
	s.PageSize = &v
	return s
}

func (s *ListBaselinesRequest) SetPriority(v string) *ListBaselinesRequest {
	s.Priority = &v
	return s
}

func (s *ListBaselinesRequest) SetProjectId(v int64) *ListBaselinesRequest {
	s.ProjectId = &v
	return s
}

func (s *ListBaselinesRequest) SetSearchText(v string) *ListBaselinesRequest {
	s.SearchText = &v
	return s
}

type ListBaselinesResponseBody struct {
	Data           *ListBaselinesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorCode      *string                        `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string                        `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32                         `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string                        `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                          `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListBaselinesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListBaselinesResponseBody) GoString() string {
	return s.String()
}

func (s *ListBaselinesResponseBody) SetData(v *ListBaselinesResponseBodyData) *ListBaselinesResponseBody {
	s.Data = v
	return s
}

func (s *ListBaselinesResponseBody) SetErrorCode(v string) *ListBaselinesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListBaselinesResponseBody) SetErrorMessage(v string) *ListBaselinesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListBaselinesResponseBody) SetHttpStatusCode(v int32) *ListBaselinesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListBaselinesResponseBody) SetRequestId(v string) *ListBaselinesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListBaselinesResponseBody) SetSuccess(v bool) *ListBaselinesResponseBody {
	s.Success = &v
	return s
}

type ListBaselinesResponseBodyData struct {
	Baselines  []*ListBaselinesResponseBodyDataBaselines `json:"Baselines,omitempty" xml:"Baselines,omitempty" type:"Repeated"`
	PageNumber *string                                   `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *string                                   `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	TotalCount *string                                   `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListBaselinesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListBaselinesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListBaselinesResponseBodyData) SetBaselines(v []*ListBaselinesResponseBodyDataBaselines) *ListBaselinesResponseBodyData {
	s.Baselines = v
	return s
}

func (s *ListBaselinesResponseBodyData) SetPageNumber(v string) *ListBaselinesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListBaselinesResponseBodyData) SetPageSize(v string) *ListBaselinesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListBaselinesResponseBodyData) SetTotalCount(v string) *ListBaselinesResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListBaselinesResponseBodyDataBaselines struct {
	AlertEnabled         *bool                                                     `json:"AlertEnabled,omitempty" xml:"AlertEnabled,omitempty"`
	AlertMarginThreshold *int32                                                    `json:"AlertMarginThreshold,omitempty" xml:"AlertMarginThreshold,omitempty"`
	BaselineId           *int64                                                    `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	BaselineName         *string                                                   `json:"BaselineName,omitempty" xml:"BaselineName,omitempty"`
	BaselineType         *string                                                   `json:"BaselineType,omitempty" xml:"BaselineType,omitempty"`
	Enabled              *bool                                                     `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	OverTimeSettings     []*ListBaselinesResponseBodyDataBaselinesOverTimeSettings `json:"OverTimeSettings,omitempty" xml:"OverTimeSettings,omitempty" type:"Repeated"`
	Owner                *string                                                   `json:"Owner,omitempty" xml:"Owner,omitempty"`
	Priority             *int32                                                    `json:"Priority,omitempty" xml:"Priority,omitempty"`
	ProjectId            *int64                                                    `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListBaselinesResponseBodyDataBaselines) String() string {
	return tea.Prettify(s)
}

func (s ListBaselinesResponseBodyDataBaselines) GoString() string {
	return s.String()
}

func (s *ListBaselinesResponseBodyDataBaselines) SetAlertEnabled(v bool) *ListBaselinesResponseBodyDataBaselines {
	s.AlertEnabled = &v
	return s
}

func (s *ListBaselinesResponseBodyDataBaselines) SetAlertMarginThreshold(v int32) *ListBaselinesResponseBodyDataBaselines {
	s.AlertMarginThreshold = &v
	return s
}

func (s *ListBaselinesResponseBodyDataBaselines) SetBaselineId(v int64) *ListBaselinesResponseBodyDataBaselines {
	s.BaselineId = &v
	return s
}

func (s *ListBaselinesResponseBodyDataBaselines) SetBaselineName(v string) *ListBaselinesResponseBodyDataBaselines {
	s.BaselineName = &v
	return s
}

func (s *ListBaselinesResponseBodyDataBaselines) SetBaselineType(v string) *ListBaselinesResponseBodyDataBaselines {
	s.BaselineType = &v
	return s
}

func (s *ListBaselinesResponseBodyDataBaselines) SetEnabled(v bool) *ListBaselinesResponseBodyDataBaselines {
	s.Enabled = &v
	return s
}

func (s *ListBaselinesResponseBodyDataBaselines) SetOverTimeSettings(v []*ListBaselinesResponseBodyDataBaselinesOverTimeSettings) *ListBaselinesResponseBodyDataBaselines {
	s.OverTimeSettings = v
	return s
}

func (s *ListBaselinesResponseBodyDataBaselines) SetOwner(v string) *ListBaselinesResponseBodyDataBaselines {
	s.Owner = &v
	return s
}

func (s *ListBaselinesResponseBodyDataBaselines) SetPriority(v int32) *ListBaselinesResponseBodyDataBaselines {
	s.Priority = &v
	return s
}

func (s *ListBaselinesResponseBodyDataBaselines) SetProjectId(v int64) *ListBaselinesResponseBodyDataBaselines {
	s.ProjectId = &v
	return s
}

type ListBaselinesResponseBodyDataBaselinesOverTimeSettings struct {
	Cycle *int32  `json:"Cycle,omitempty" xml:"Cycle,omitempty"`
	Time  *string `json:"Time,omitempty" xml:"Time,omitempty"`
}

func (s ListBaselinesResponseBodyDataBaselinesOverTimeSettings) String() string {
	return tea.Prettify(s)
}

func (s ListBaselinesResponseBodyDataBaselinesOverTimeSettings) GoString() string {
	return s.String()
}

func (s *ListBaselinesResponseBodyDataBaselinesOverTimeSettings) SetCycle(v int32) *ListBaselinesResponseBodyDataBaselinesOverTimeSettings {
	s.Cycle = &v
	return s
}

func (s *ListBaselinesResponseBodyDataBaselinesOverTimeSettings) SetTime(v string) *ListBaselinesResponseBodyDataBaselinesOverTimeSettings {
	s.Time = &v
	return s
}

type ListBaselinesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListBaselinesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListBaselinesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListBaselinesResponse) GoString() string {
	return s.String()
}

func (s *ListBaselinesResponse) SetHeaders(v map[string]*string) *ListBaselinesResponse {
	s.Headers = v
	return s
}

func (s *ListBaselinesResponse) SetStatusCode(v int32) *ListBaselinesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListBaselinesResponse) SetBody(v *ListBaselinesResponseBody) *ListBaselinesResponse {
	s.Body = v
	return s
}

type ListBusinessRequest struct {
	// The keyword that is used to perform a fuzzy match.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace ID. You must configure either this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace name. You must configure either this parameter or ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s ListBusinessRequest) String() string {
	return tea.Prettify(s)
}

func (s ListBusinessRequest) GoString() string {
	return s.String()
}

func (s *ListBusinessRequest) SetKeyword(v string) *ListBusinessRequest {
	s.Keyword = &v
	return s
}

func (s *ListBusinessRequest) SetPageNumber(v int32) *ListBusinessRequest {
	s.PageNumber = &v
	return s
}

func (s *ListBusinessRequest) SetPageSize(v int32) *ListBusinessRequest {
	s.PageSize = &v
	return s
}

func (s *ListBusinessRequest) SetProjectId(v int64) *ListBusinessRequest {
	s.ProjectId = &v
	return s
}

func (s *ListBusinessRequest) SetProjectIdentifier(v string) *ListBusinessRequest {
	s.ProjectIdentifier = &v
	return s
}

type ListBusinessResponseBody struct {
	// The information about the workflows returned.
	Data *ListBusinessResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListBusinessResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListBusinessResponseBody) GoString() string {
	return s.String()
}

func (s *ListBusinessResponseBody) SetData(v *ListBusinessResponseBodyData) *ListBusinessResponseBody {
	s.Data = v
	return s
}

func (s *ListBusinessResponseBody) SetErrorCode(v string) *ListBusinessResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListBusinessResponseBody) SetErrorMessage(v string) *ListBusinessResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListBusinessResponseBody) SetHttpStatusCode(v int32) *ListBusinessResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListBusinessResponseBody) SetRequestId(v string) *ListBusinessResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListBusinessResponseBody) SetSuccess(v bool) *ListBusinessResponseBody {
	s.Success = &v
	return s
}

type ListBusinessResponseBodyData struct {
	// The details of the workflow.
	Business []*ListBusinessResponseBodyDataBusiness `json:"Business,omitempty" xml:"Business,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListBusinessResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListBusinessResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListBusinessResponseBodyData) SetBusiness(v []*ListBusinessResponseBodyDataBusiness) *ListBusinessResponseBodyData {
	s.Business = v
	return s
}

func (s *ListBusinessResponseBodyData) SetPageNumber(v int32) *ListBusinessResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListBusinessResponseBodyData) SetPageSize(v int32) *ListBusinessResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListBusinessResponseBodyData) SetTotalCount(v int32) *ListBusinessResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListBusinessResponseBodyDataBusiness struct {
	// The ID of the workflow.
	BusinessId *int64 `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	// The name of the workflow.
	BusinessName *string `json:"BusinessName,omitempty" xml:"BusinessName,omitempty"`
	// The description of the workflow.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The owner of the workflow.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ID of the workspace to which the workflow belongs.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The module to which the workflow belongs. Valid values: NORMAL and MANUAL_BIZ. The value NORMAL indicates that the workflow belongs to auto triggered workflows. The value MANUAL_BIZ indicates that the workflow belongs to manually triggered workflows.
	UseType *string `json:"UseType,omitempty" xml:"UseType,omitempty"`
}

func (s ListBusinessResponseBodyDataBusiness) String() string {
	return tea.Prettify(s)
}

func (s ListBusinessResponseBodyDataBusiness) GoString() string {
	return s.String()
}

func (s *ListBusinessResponseBodyDataBusiness) SetBusinessId(v int64) *ListBusinessResponseBodyDataBusiness {
	s.BusinessId = &v
	return s
}

func (s *ListBusinessResponseBodyDataBusiness) SetBusinessName(v string) *ListBusinessResponseBodyDataBusiness {
	s.BusinessName = &v
	return s
}

func (s *ListBusinessResponseBodyDataBusiness) SetDescription(v string) *ListBusinessResponseBodyDataBusiness {
	s.Description = &v
	return s
}

func (s *ListBusinessResponseBodyDataBusiness) SetOwner(v string) *ListBusinessResponseBodyDataBusiness {
	s.Owner = &v
	return s
}

func (s *ListBusinessResponseBodyDataBusiness) SetProjectId(v int64) *ListBusinessResponseBodyDataBusiness {
	s.ProjectId = &v
	return s
}

func (s *ListBusinessResponseBodyDataBusiness) SetUseType(v string) *ListBusinessResponseBodyDataBusiness {
	s.UseType = &v
	return s
}

type ListBusinessResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListBusinessResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListBusinessResponse) String() string {
	return tea.Prettify(s)
}

func (s ListBusinessResponse) GoString() string {
	return s.String()
}

func (s *ListBusinessResponse) SetHeaders(v map[string]*string) *ListBusinessResponse {
	s.Headers = v
	return s
}

func (s *ListBusinessResponse) SetStatusCode(v int32) *ListBusinessResponse {
	s.StatusCode = &v
	return s
}

func (s *ListBusinessResponse) SetBody(v *ListBusinessResponseBody) *ListBusinessResponse {
	s.Body = v
	return s
}

type ListCalcEnginesRequest struct {
	CalcEngineType *string `json:"CalcEngineType,omitempty" xml:"CalcEngineType,omitempty"`
	EnvType        *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	Name           *string `json:"Name,omitempty" xml:"Name,omitempty"`
	PageNumber     *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize       *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProjectId      *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListCalcEnginesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListCalcEnginesRequest) GoString() string {
	return s.String()
}

func (s *ListCalcEnginesRequest) SetCalcEngineType(v string) *ListCalcEnginesRequest {
	s.CalcEngineType = &v
	return s
}

func (s *ListCalcEnginesRequest) SetEnvType(v string) *ListCalcEnginesRequest {
	s.EnvType = &v
	return s
}

func (s *ListCalcEnginesRequest) SetName(v string) *ListCalcEnginesRequest {
	s.Name = &v
	return s
}

func (s *ListCalcEnginesRequest) SetPageNumber(v int32) *ListCalcEnginesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListCalcEnginesRequest) SetPageSize(v int32) *ListCalcEnginesRequest {
	s.PageSize = &v
	return s
}

func (s *ListCalcEnginesRequest) SetProjectId(v int64) *ListCalcEnginesRequest {
	s.ProjectId = &v
	return s
}

type ListCalcEnginesResponseBody struct {
	Data           *ListCalcEnginesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	HttpStatusCode *int32                           `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string                          `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                            `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListCalcEnginesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListCalcEnginesResponseBody) GoString() string {
	return s.String()
}

func (s *ListCalcEnginesResponseBody) SetData(v *ListCalcEnginesResponseBodyData) *ListCalcEnginesResponseBody {
	s.Data = v
	return s
}

func (s *ListCalcEnginesResponseBody) SetHttpStatusCode(v int32) *ListCalcEnginesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListCalcEnginesResponseBody) SetRequestId(v string) *ListCalcEnginesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListCalcEnginesResponseBody) SetSuccess(v bool) *ListCalcEnginesResponseBody {
	s.Success = &v
	return s
}

type ListCalcEnginesResponseBodyData struct {
	CalcEngines []*ListCalcEnginesResponseBodyDataCalcEngines `json:"CalcEngines,omitempty" xml:"CalcEngines,omitempty" type:"Repeated"`
	PageNumber  *int32                                        `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize    *int32                                        `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	TotalCount  *int32                                        `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListCalcEnginesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListCalcEnginesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListCalcEnginesResponseBodyData) SetCalcEngines(v []*ListCalcEnginesResponseBodyDataCalcEngines) *ListCalcEnginesResponseBodyData {
	s.CalcEngines = v
	return s
}

func (s *ListCalcEnginesResponseBodyData) SetPageNumber(v int32) *ListCalcEnginesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListCalcEnginesResponseBodyData) SetPageSize(v int32) *ListCalcEnginesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListCalcEnginesResponseBodyData) SetTotalCount(v int32) *ListCalcEnginesResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListCalcEnginesResponseBodyDataCalcEngines struct {
	BindingProjectId   *int32                 `json:"BindingProjectId,omitempty" xml:"BindingProjectId,omitempty"`
	BindingProjectName *string                `json:"BindingProjectName,omitempty" xml:"BindingProjectName,omitempty"`
	CalcEngineType     *string                `json:"CalcEngineType,omitempty" xml:"CalcEngineType,omitempty"`
	DwRegion           *string                `json:"DwRegion,omitempty" xml:"DwRegion,omitempty"`
	EngineId           *int32                 `json:"EngineId,omitempty" xml:"EngineId,omitempty"`
	EngineInfo         map[string]interface{} `json:"EngineInfo,omitempty" xml:"EngineInfo,omitempty"`
	EnvType            *string                `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	GmtCreate          *string                `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	IsDefault          *bool                  `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	Name               *string                `json:"Name,omitempty" xml:"Name,omitempty"`
	Region             *string                `json:"Region,omitempty" xml:"Region,omitempty"`
	TaskAuthType       *string                `json:"TaskAuthType,omitempty" xml:"TaskAuthType,omitempty"`
	TenantId           *int64                 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ListCalcEnginesResponseBodyDataCalcEngines) String() string {
	return tea.Prettify(s)
}

func (s ListCalcEnginesResponseBodyDataCalcEngines) GoString() string {
	return s.String()
}

func (s *ListCalcEnginesResponseBodyDataCalcEngines) SetBindingProjectId(v int32) *ListCalcEnginesResponseBodyDataCalcEngines {
	s.BindingProjectId = &v
	return s
}

func (s *ListCalcEnginesResponseBodyDataCalcEngines) SetBindingProjectName(v string) *ListCalcEnginesResponseBodyDataCalcEngines {
	s.BindingProjectName = &v
	return s
}

func (s *ListCalcEnginesResponseBodyDataCalcEngines) SetCalcEngineType(v string) *ListCalcEnginesResponseBodyDataCalcEngines {
	s.CalcEngineType = &v
	return s
}

func (s *ListCalcEnginesResponseBodyDataCalcEngines) SetDwRegion(v string) *ListCalcEnginesResponseBodyDataCalcEngines {
	s.DwRegion = &v
	return s
}

func (s *ListCalcEnginesResponseBodyDataCalcEngines) SetEngineId(v int32) *ListCalcEnginesResponseBodyDataCalcEngines {
	s.EngineId = &v
	return s
}

func (s *ListCalcEnginesResponseBodyDataCalcEngines) SetEngineInfo(v map[string]interface{}) *ListCalcEnginesResponseBodyDataCalcEngines {
	s.EngineInfo = v
	return s
}

func (s *ListCalcEnginesResponseBodyDataCalcEngines) SetEnvType(v string) *ListCalcEnginesResponseBodyDataCalcEngines {
	s.EnvType = &v
	return s
}

func (s *ListCalcEnginesResponseBodyDataCalcEngines) SetGmtCreate(v string) *ListCalcEnginesResponseBodyDataCalcEngines {
	s.GmtCreate = &v
	return s
}

func (s *ListCalcEnginesResponseBodyDataCalcEngines) SetIsDefault(v bool) *ListCalcEnginesResponseBodyDataCalcEngines {
	s.IsDefault = &v
	return s
}

func (s *ListCalcEnginesResponseBodyDataCalcEngines) SetName(v string) *ListCalcEnginesResponseBodyDataCalcEngines {
	s.Name = &v
	return s
}

func (s *ListCalcEnginesResponseBodyDataCalcEngines) SetRegion(v string) *ListCalcEnginesResponseBodyDataCalcEngines {
	s.Region = &v
	return s
}

func (s *ListCalcEnginesResponseBodyDataCalcEngines) SetTaskAuthType(v string) *ListCalcEnginesResponseBodyDataCalcEngines {
	s.TaskAuthType = &v
	return s
}

func (s *ListCalcEnginesResponseBodyDataCalcEngines) SetTenantId(v int64) *ListCalcEnginesResponseBodyDataCalcEngines {
	s.TenantId = &v
	return s
}

type ListCalcEnginesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListCalcEnginesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListCalcEnginesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListCalcEnginesResponse) GoString() string {
	return s.String()
}

func (s *ListCalcEnginesResponse) SetHeaders(v map[string]*string) *ListCalcEnginesResponse {
	s.Headers = v
	return s
}

func (s *ListCalcEnginesResponse) SetStatusCode(v int32) *ListCalcEnginesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListCalcEnginesResponse) SetBody(v *ListCalcEnginesResponseBody) *ListCalcEnginesResponse {
	s.Body = v
	return s
}

type ListConnectionsRequest struct {
	ConnectionType *string `json:"ConnectionType,omitempty" xml:"ConnectionType,omitempty"`
	EnvType        *int32  `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	Name           *string `json:"Name,omitempty" xml:"Name,omitempty"`
	PageNumber     *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize       *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProjectId      *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	Status         *string `json:"Status,omitempty" xml:"Status,omitempty"`
	SubType        *string `json:"SubType,omitempty" xml:"SubType,omitempty"`
}

func (s ListConnectionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListConnectionsRequest) GoString() string {
	return s.String()
}

func (s *ListConnectionsRequest) SetConnectionType(v string) *ListConnectionsRequest {
	s.ConnectionType = &v
	return s
}

func (s *ListConnectionsRequest) SetEnvType(v int32) *ListConnectionsRequest {
	s.EnvType = &v
	return s
}

func (s *ListConnectionsRequest) SetName(v string) *ListConnectionsRequest {
	s.Name = &v
	return s
}

func (s *ListConnectionsRequest) SetPageNumber(v int32) *ListConnectionsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListConnectionsRequest) SetPageSize(v int32) *ListConnectionsRequest {
	s.PageSize = &v
	return s
}

func (s *ListConnectionsRequest) SetProjectId(v int64) *ListConnectionsRequest {
	s.ProjectId = &v
	return s
}

func (s *ListConnectionsRequest) SetStatus(v string) *ListConnectionsRequest {
	s.Status = &v
	return s
}

func (s *ListConnectionsRequest) SetSubType(v string) *ListConnectionsRequest {
	s.SubType = &v
	return s
}

type ListConnectionsResponseBody struct {
	Data           *ListConnectionsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	HttpStatusCode *int32                           `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string                          `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                            `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListConnectionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListConnectionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListConnectionsResponseBody) SetData(v *ListConnectionsResponseBodyData) *ListConnectionsResponseBody {
	s.Data = v
	return s
}

func (s *ListConnectionsResponseBody) SetHttpStatusCode(v int32) *ListConnectionsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListConnectionsResponseBody) SetRequestId(v string) *ListConnectionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListConnectionsResponseBody) SetSuccess(v bool) *ListConnectionsResponseBody {
	s.Success = &v
	return s
}

type ListConnectionsResponseBodyData struct {
	Connections []*ListConnectionsResponseBodyDataConnections `json:"Connections,omitempty" xml:"Connections,omitempty" type:"Repeated"`
	PageNumber  *int32                                        `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize    *int32                                        `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	TotalCount  *int32                                        `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListConnectionsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListConnectionsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListConnectionsResponseBodyData) SetConnections(v []*ListConnectionsResponseBodyDataConnections) *ListConnectionsResponseBodyData {
	s.Connections = v
	return s
}

func (s *ListConnectionsResponseBodyData) SetPageNumber(v int32) *ListConnectionsResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListConnectionsResponseBodyData) SetPageSize(v int32) *ListConnectionsResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListConnectionsResponseBodyData) SetTotalCount(v int32) *ListConnectionsResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListConnectionsResponseBodyDataConnections struct {
	BindingCalcEngineId *int32  `json:"BindingCalcEngineId,omitempty" xml:"BindingCalcEngineId,omitempty"`
	ConnectStatus       *int32  `json:"ConnectStatus,omitempty" xml:"ConnectStatus,omitempty"`
	ConnectionType      *string `json:"ConnectionType,omitempty" xml:"ConnectionType,omitempty"`
	Content             *string `json:"Content,omitempty" xml:"Content,omitempty"`
	DefaultEngine       *bool   `json:"DefaultEngine,omitempty" xml:"DefaultEngine,omitempty"`
	Description         *string `json:"Description,omitempty" xml:"Description,omitempty"`
	EnvType             *int32  `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	GmtCreate           *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtModified         *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	Id                  *int32  `json:"Id,omitempty" xml:"Id,omitempty"`
	Name                *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Operator            *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	ProjectId           *int32  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	Sequence            *int32  `json:"Sequence,omitempty" xml:"Sequence,omitempty"`
	Shared              *bool   `json:"Shared,omitempty" xml:"Shared,omitempty"`
	Status              *int32  `json:"Status,omitempty" xml:"Status,omitempty"`
	SubType             *string `json:"SubType,omitempty" xml:"SubType,omitempty"`
	TenantId            *int64  `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ListConnectionsResponseBodyDataConnections) String() string {
	return tea.Prettify(s)
}

func (s ListConnectionsResponseBodyDataConnections) GoString() string {
	return s.String()
}

func (s *ListConnectionsResponseBodyDataConnections) SetBindingCalcEngineId(v int32) *ListConnectionsResponseBodyDataConnections {
	s.BindingCalcEngineId = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetConnectStatus(v int32) *ListConnectionsResponseBodyDataConnections {
	s.ConnectStatus = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetConnectionType(v string) *ListConnectionsResponseBodyDataConnections {
	s.ConnectionType = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetContent(v string) *ListConnectionsResponseBodyDataConnections {
	s.Content = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetDefaultEngine(v bool) *ListConnectionsResponseBodyDataConnections {
	s.DefaultEngine = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetDescription(v string) *ListConnectionsResponseBodyDataConnections {
	s.Description = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetEnvType(v int32) *ListConnectionsResponseBodyDataConnections {
	s.EnvType = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetGmtCreate(v string) *ListConnectionsResponseBodyDataConnections {
	s.GmtCreate = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetGmtModified(v string) *ListConnectionsResponseBodyDataConnections {
	s.GmtModified = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetId(v int32) *ListConnectionsResponseBodyDataConnections {
	s.Id = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetName(v string) *ListConnectionsResponseBodyDataConnections {
	s.Name = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetOperator(v string) *ListConnectionsResponseBodyDataConnections {
	s.Operator = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetProjectId(v int32) *ListConnectionsResponseBodyDataConnections {
	s.ProjectId = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetSequence(v int32) *ListConnectionsResponseBodyDataConnections {
	s.Sequence = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetShared(v bool) *ListConnectionsResponseBodyDataConnections {
	s.Shared = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetStatus(v int32) *ListConnectionsResponseBodyDataConnections {
	s.Status = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetSubType(v string) *ListConnectionsResponseBodyDataConnections {
	s.SubType = &v
	return s
}

func (s *ListConnectionsResponseBodyDataConnections) SetTenantId(v int64) *ListConnectionsResponseBodyDataConnections {
	s.TenantId = &v
	return s
}

type ListConnectionsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListConnectionsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListConnectionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListConnectionsResponse) GoString() string {
	return s.String()
}

func (s *ListConnectionsResponse) SetHeaders(v map[string]*string) *ListConnectionsResponse {
	s.Headers = v
	return s
}

func (s *ListConnectionsResponse) SetStatusCode(v int32) *ListConnectionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListConnectionsResponse) SetBody(v *ListConnectionsResponseBody) *ListConnectionsResponse {
	s.Body = v
	return s
}

type ListDIAlarmRulesRequest struct {
	DIJobId    *int64 `json:"DIJobId,omitempty" xml:"DIJobId,omitempty"`
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListDIAlarmRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDIAlarmRulesRequest) GoString() string {
	return s.String()
}

func (s *ListDIAlarmRulesRequest) SetDIJobId(v int64) *ListDIAlarmRulesRequest {
	s.DIJobId = &v
	return s
}

func (s *ListDIAlarmRulesRequest) SetPageNumber(v int64) *ListDIAlarmRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDIAlarmRulesRequest) SetPageSize(v int64) *ListDIAlarmRulesRequest {
	s.PageSize = &v
	return s
}

type ListDIAlarmRulesResponseBody struct {
	DIAlarmRulePaging *ListDIAlarmRulesResponseBodyDIAlarmRulePaging `json:"DIAlarmRulePaging,omitempty" xml:"DIAlarmRulePaging,omitempty" type:"Struct"`
	RequestId         *string                                        `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListDIAlarmRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDIAlarmRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListDIAlarmRulesResponseBody) SetDIAlarmRulePaging(v *ListDIAlarmRulesResponseBodyDIAlarmRulePaging) *ListDIAlarmRulesResponseBody {
	s.DIAlarmRulePaging = v
	return s
}

func (s *ListDIAlarmRulesResponseBody) SetRequestId(v string) *ListDIAlarmRulesResponseBody {
	s.RequestId = &v
	return s
}

type ListDIAlarmRulesResponseBodyDIAlarmRulePaging struct {
	DIJobAlarmRules []*ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules `json:"DIJobAlarmRules,omitempty" xml:"DIJobAlarmRules,omitempty" type:"Repeated"`
	PageNumber      *int64                                                          `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize        *int64                                                          `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	TotalCount      *int64                                                          `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDIAlarmRulesResponseBodyDIAlarmRulePaging) String() string {
	return tea.Prettify(s)
}

func (s ListDIAlarmRulesResponseBodyDIAlarmRulePaging) GoString() string {
	return s.String()
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePaging) SetDIJobAlarmRules(v []*ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules) *ListDIAlarmRulesResponseBodyDIAlarmRulePaging {
	s.DIJobAlarmRules = v
	return s
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePaging) SetPageNumber(v int64) *ListDIAlarmRulesResponseBodyDIAlarmRulePaging {
	s.PageNumber = &v
	return s
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePaging) SetPageSize(v int64) *ListDIAlarmRulesResponseBodyDIAlarmRulePaging {
	s.PageSize = &v
	return s
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePaging) SetTotalCount(v int64) *ListDIAlarmRulesResponseBodyDIAlarmRulePaging {
	s.TotalCount = &v
	return s
}

type ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules struct {
	DIAlarmRuleId        *int64                                                                            `json:"DIAlarmRuleId,omitempty" xml:"DIAlarmRuleId,omitempty"`
	DIJobId              *int64                                                                            `json:"DIJobId,omitempty" xml:"DIJobId,omitempty"`
	Description          *string                                                                           `json:"Description,omitempty" xml:"Description,omitempty"`
	Enabled              *bool                                                                             `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	MetricType           *string                                                                           `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	NotificationSettings *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettings `json:"NotificationSettings,omitempty" xml:"NotificationSettings,omitempty" type:"Struct"`
	TriggerConditions    []*ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesTriggerConditions  `json:"TriggerConditions,omitempty" xml:"TriggerConditions,omitempty" type:"Repeated"`
}

func (s ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules) String() string {
	return tea.Prettify(s)
}

func (s ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules) GoString() string {
	return s.String()
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules) SetDIAlarmRuleId(v int64) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules {
	s.DIAlarmRuleId = &v
	return s
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules) SetDIJobId(v int64) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules {
	s.DIJobId = &v
	return s
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules) SetDescription(v string) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules {
	s.Description = &v
	return s
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules) SetEnabled(v bool) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules {
	s.Enabled = &v
	return s
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules) SetMetricType(v string) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules {
	s.MetricType = &v
	return s
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules) SetNotificationSettings(v *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettings) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules {
	s.NotificationSettings = v
	return s
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules) SetTriggerConditions(v []*ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesTriggerConditions) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRules {
	s.TriggerConditions = v
	return s
}

type ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettings struct {
	InhibitionInterval    *int32                                                                                                   `json:"InhibitionInterval,omitempty" xml:"InhibitionInterval,omitempty"`
	NotificationChannels  []*ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationChannels  `json:"NotificationChannels,omitempty" xml:"NotificationChannels,omitempty" type:"Repeated"`
	NotificationReceivers []*ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationReceivers `json:"NotificationReceivers,omitempty" xml:"NotificationReceivers,omitempty" type:"Repeated"`
}

func (s ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettings) String() string {
	return tea.Prettify(s)
}

func (s ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettings) GoString() string {
	return s.String()
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettings) SetInhibitionInterval(v int32) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettings {
	s.InhibitionInterval = &v
	return s
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettings) SetNotificationChannels(v []*ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationChannels) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettings {
	s.NotificationChannels = v
	return s
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettings) SetNotificationReceivers(v []*ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationReceivers) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettings {
	s.NotificationReceivers = v
	return s
}

type ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationChannels struct {
	Channels []*string `json:"Channels,omitempty" xml:"Channels,omitempty" type:"Repeated"`
	Severity *string   `json:"Severity,omitempty" xml:"Severity,omitempty"`
}

func (s ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationChannels) String() string {
	return tea.Prettify(s)
}

func (s ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationChannels) GoString() string {
	return s.String()
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationChannels) SetChannels(v []*string) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationChannels {
	s.Channels = v
	return s
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationChannels) SetSeverity(v string) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationChannels {
	s.Severity = &v
	return s
}

type ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationReceivers struct {
	ReceiverType   *string   `json:"ReceiverType,omitempty" xml:"ReceiverType,omitempty"`
	ReceiverValues []*string `json:"ReceiverValues,omitempty" xml:"ReceiverValues,omitempty" type:"Repeated"`
}

func (s ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationReceivers) String() string {
	return tea.Prettify(s)
}

func (s ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationReceivers) GoString() string {
	return s.String()
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationReceivers) SetReceiverType(v string) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationReceivers {
	s.ReceiverType = &v
	return s
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationReceivers) SetReceiverValues(v []*string) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesNotificationSettingsNotificationReceivers {
	s.ReceiverValues = v
	return s
}

type ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesTriggerConditions struct {
	Duration  *int64  `json:"Duration,omitempty" xml:"Duration,omitempty"`
	Severity  *string `json:"Severity,omitempty" xml:"Severity,omitempty"`
	Threshold *int64  `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesTriggerConditions) String() string {
	return tea.Prettify(s)
}

func (s ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesTriggerConditions) GoString() string {
	return s.String()
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesTriggerConditions) SetDuration(v int64) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesTriggerConditions {
	s.Duration = &v
	return s
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesTriggerConditions) SetSeverity(v string) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesTriggerConditions {
	s.Severity = &v
	return s
}

func (s *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesTriggerConditions) SetThreshold(v int64) *ListDIAlarmRulesResponseBodyDIAlarmRulePagingDIJobAlarmRulesTriggerConditions {
	s.Threshold = &v
	return s
}

type ListDIAlarmRulesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDIAlarmRulesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDIAlarmRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDIAlarmRulesResponse) GoString() string {
	return s.String()
}

func (s *ListDIAlarmRulesResponse) SetHeaders(v map[string]*string) *ListDIAlarmRulesResponse {
	s.Headers = v
	return s
}

func (s *ListDIAlarmRulesResponse) SetStatusCode(v int32) *ListDIAlarmRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDIAlarmRulesResponse) SetBody(v *ListDIAlarmRulesResponseBody) *ListDIAlarmRulesResponse {
	s.Body = v
	return s
}

type ListDIJobsRequest struct {
	DestinationDataSourceType *string `json:"DestinationDataSourceType,omitempty" xml:"DestinationDataSourceType,omitempty"`
	JobName                   *string `json:"JobName,omitempty" xml:"JobName,omitempty"`
	PageNumber                *int32  `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize                  *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProjectId                 *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	SourceDataSourceType      *string `json:"SourceDataSourceType,omitempty" xml:"SourceDataSourceType,omitempty"`
}

func (s ListDIJobsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDIJobsRequest) GoString() string {
	return s.String()
}

func (s *ListDIJobsRequest) SetDestinationDataSourceType(v string) *ListDIJobsRequest {
	s.DestinationDataSourceType = &v
	return s
}

func (s *ListDIJobsRequest) SetJobName(v string) *ListDIJobsRequest {
	s.JobName = &v
	return s
}

func (s *ListDIJobsRequest) SetPageNumber(v int32) *ListDIJobsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDIJobsRequest) SetPageSize(v int32) *ListDIJobsRequest {
	s.PageSize = &v
	return s
}

func (s *ListDIJobsRequest) SetProjectId(v int64) *ListDIJobsRequest {
	s.ProjectId = &v
	return s
}

func (s *ListDIJobsRequest) SetSourceDataSourceType(v string) *ListDIJobsRequest {
	s.SourceDataSourceType = &v
	return s
}

type ListDIJobsResponseBody struct {
	DIJobPaging *ListDIJobsResponseBodyDIJobPaging `json:"DIJobPaging,omitempty" xml:"DIJobPaging,omitempty" type:"Struct"`
	RequestId   *string                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListDIJobsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDIJobsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDIJobsResponseBody) SetDIJobPaging(v *ListDIJobsResponseBodyDIJobPaging) *ListDIJobsResponseBody {
	s.DIJobPaging = v
	return s
}

func (s *ListDIJobsResponseBody) SetRequestId(v string) *ListDIJobsResponseBody {
	s.RequestId = &v
	return s
}

type ListDIJobsResponseBodyDIJobPaging struct {
	DIJobs     []*ListDIJobsResponseBodyDIJobPagingDIJobs `json:"DIJobs,omitempty" xml:"DIJobs,omitempty" type:"Repeated"`
	PageNumber *int32                                     `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	PageSize   *int32                                     `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	TotalCount *int32                                     `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDIJobsResponseBodyDIJobPaging) String() string {
	return tea.Prettify(s)
}

func (s ListDIJobsResponseBodyDIJobPaging) GoString() string {
	return s.String()
}

func (s *ListDIJobsResponseBodyDIJobPaging) SetDIJobs(v []*ListDIJobsResponseBodyDIJobPagingDIJobs) *ListDIJobsResponseBodyDIJobPaging {
	s.DIJobs = v
	return s
}

func (s *ListDIJobsResponseBodyDIJobPaging) SetPageNumber(v int32) *ListDIJobsResponseBodyDIJobPaging {
	s.PageNumber = &v
	return s
}

func (s *ListDIJobsResponseBodyDIJobPaging) SetPageSize(v int32) *ListDIJobsResponseBodyDIJobPaging {
	s.PageSize = &v
	return s
}

func (s *ListDIJobsResponseBodyDIJobPaging) SetTotalCount(v int32) *ListDIJobsResponseBodyDIJobPaging {
	s.TotalCount = &v
	return s
}

type ListDIJobsResponseBodyDIJobPagingDIJobs struct {
	DIJobId                   *int64  `json:"DIJobId,omitempty" xml:"DIJobId,omitempty"`
	DestinationDataSourceType *string `json:"DestinationDataSourceType,omitempty" xml:"DestinationDataSourceType,omitempty"`
	JobName                   *string `json:"JobName,omitempty" xml:"JobName,omitempty"`
	JobStatus                 *string `json:"JobStatus,omitempty" xml:"JobStatus,omitempty"`
	MigrationType             *string `json:"MigrationType,omitempty" xml:"MigrationType,omitempty"`
	ProjectId                 *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	SourceDataSourceType      *string `json:"SourceDataSourceType,omitempty" xml:"SourceDataSourceType,omitempty"`
}

func (s ListDIJobsResponseBodyDIJobPagingDIJobs) String() string {
	return tea.Prettify(s)
}

func (s ListDIJobsResponseBodyDIJobPagingDIJobs) GoString() string {
	return s.String()
}

func (s *ListDIJobsResponseBodyDIJobPagingDIJobs) SetDIJobId(v int64) *ListDIJobsResponseBodyDIJobPagingDIJobs {
	s.DIJobId = &v
	return s
}

func (s *ListDIJobsResponseBodyDIJobPagingDIJobs) SetDestinationDataSourceType(v string) *ListDIJobsResponseBodyDIJobPagingDIJobs {
	s.DestinationDataSourceType = &v
	return s
}

func (s *ListDIJobsResponseBodyDIJobPagingDIJobs) SetJobName(v string) *ListDIJobsResponseBodyDIJobPagingDIJobs {
	s.JobName = &v
	return s
}

func (s *ListDIJobsResponseBodyDIJobPagingDIJobs) SetJobStatus(v string) *ListDIJobsResponseBodyDIJobPagingDIJobs {
	s.JobStatus = &v
	return s
}

func (s *ListDIJobsResponseBodyDIJobPagingDIJobs) SetMigrationType(v string) *ListDIJobsResponseBodyDIJobPagingDIJobs {
	s.MigrationType = &v
	return s
}

func (s *ListDIJobsResponseBodyDIJobPagingDIJobs) SetProjectId(v int64) *ListDIJobsResponseBodyDIJobPagingDIJobs {
	s.ProjectId = &v
	return s
}

func (s *ListDIJobsResponseBodyDIJobPagingDIJobs) SetSourceDataSourceType(v string) *ListDIJobsResponseBodyDIJobPagingDIJobs {
	s.SourceDataSourceType = &v
	return s
}

type ListDIJobsResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDIJobsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDIJobsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDIJobsResponse) GoString() string {
	return s.String()
}

func (s *ListDIJobsResponse) SetHeaders(v map[string]*string) *ListDIJobsResponse {
	s.Headers = v
	return s
}

func (s *ListDIJobsResponse) SetStatusCode(v int32) *ListDIJobsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDIJobsResponse) SetBody(v *ListDIJobsResponseBody) *ListDIJobsResponse {
	s.Body = v
	return s
}

type ListDIProjectConfigRequest struct {
	// The type of the destination data source of the sync solution. This parameter cannot be left empty.
	//
	// Valid values: analyticdb_for_mysql, odps, elasticsearch, holo, mysql, and polardb. You can call the ListDIProjectConfig operation to query the supported types of destination data sources.
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The type of the source data source of the sync solution.
	//
	// Valid values: oracle, mysql, polardb, datahub, drds, and analyticdb_for_mysql. You can call the ListDIProjectConfig operation to query the supported types of source data sources.
	//
	// If you do not set this parameter, DataWorks applies the default global configuration to all the source data sources of the preceding types.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s ListDIProjectConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDIProjectConfigRequest) GoString() string {
	return s.String()
}

func (s *ListDIProjectConfigRequest) SetDestinationType(v string) *ListDIProjectConfigRequest {
	s.DestinationType = &v
	return s
}

func (s *ListDIProjectConfigRequest) SetProjectId(v int64) *ListDIProjectConfigRequest {
	s.ProjectId = &v
	return s
}

func (s *ListDIProjectConfigRequest) SetSourceType(v string) *ListDIProjectConfigRequest {
	s.SourceType = &v
	return s
}

type ListDIProjectConfigResponseBody struct {
	// The information about the query operation.
	Data *ListDIProjectConfigResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDIProjectConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDIProjectConfigResponseBody) GoString() string {
	return s.String()
}

func (s *ListDIProjectConfigResponseBody) SetData(v *ListDIProjectConfigResponseBodyData) *ListDIProjectConfigResponseBody {
	s.Data = v
	return s
}

func (s *ListDIProjectConfigResponseBody) SetRequestId(v string) *ListDIProjectConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDIProjectConfigResponseBody) SetSuccess(v bool) *ListDIProjectConfigResponseBody {
	s.Success = &v
	return s
}

type ListDIProjectConfigResponseBodyData struct {
	// The default global configuration of sync solutions. The value indicates the processing rules of different types of DDL messages. Example:
	//
	// {"RENAMECOLUMN":"WARNING","DROPTABLE":"WARNING","CREATETABLE":"WARNING","MODIFYCOLUMN":"WARNING","TRUNCATETABLE":"WARNING","DROPCOLUMN":"WARNING","ADDCOLUMN":"WARNING","RENAMETABLE":"WARNING"}
	//
	// Field description:
	//
	// *   RENAMECOLUMN: renames the column.
	// *   DROPTABLE: deletes the table.
	// *   CREATETABLE: creates a table.
	// *   MODIFYCOLUMN: changes the column data type.
	// *   TRUNCATETABLE: clears the table.
	// *   DROPCOLUMN: deletes the column.
	// *   ADDCOLUMN: creates a column.
	// *   RENAMETABLE: renames the table.
	//
	// DataWorks processes a DDL message of a specific type based on the following policies after it receives the message:
	//
	// *   WARNING: ignores the message and records an alert in real-time sync logs. The alert contains information about the situation that the message is ignored because of an execution error.
	// *   IGNORE: discards the message and does not send it to the destination data source.
	// *   CRITICAL: terminates the real-time sync node and sets the node status to Failed.
	// *   NORMAL: sends the message to the destination data source to process the message. Each destination data source may process DDL messages based on its own business logic. If DataWorks adopts the NORMAL policy, DataWorks only forwards DDL messages.
	Config *string `json:"Config,omitempty" xml:"Config,omitempty"`
}

func (s ListDIProjectConfigResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListDIProjectConfigResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListDIProjectConfigResponseBodyData) SetConfig(v string) *ListDIProjectConfigResponseBodyData {
	s.Config = &v
	return s
}

type ListDIProjectConfigResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDIProjectConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDIProjectConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDIProjectConfigResponse) GoString() string {
	return s.String()
}

func (s *ListDIProjectConfigResponse) SetHeaders(v map[string]*string) *ListDIProjectConfigResponse {
	s.Headers = v
	return s
}

func (s *ListDIProjectConfigResponse) SetStatusCode(v int32) *ListDIProjectConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDIProjectConfigResponse) SetBody(v *ListDIProjectConfigResponseBody) *ListDIProjectConfigResponse {
	s.Body = v
	return s
}

type ListDagsRequest struct {
	// The environment of the workspace. Valid values: PROD and DEV. PROD indicates the production environment. DEV indicates the development environment.
	OpSeq *int64 `json:"OpSeq,omitempty" xml:"OpSeq,omitempty"`
	// The HTTP status code returned.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s ListDagsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDagsRequest) GoString() string {
	return s.String()
}

func (s *ListDagsRequest) SetOpSeq(v int64) *ListDagsRequest {
	s.OpSeq = &v
	return s
}

func (s *ListDagsRequest) SetProjectEnv(v string) *ListDagsRequest {
	s.ProjectEnv = &v
	return s
}

type ListDagsResponseBody struct {
	// The entities returned.
	Data *ListDagsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// Indicates whether the request is successful.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error code returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The details of DAGs.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDagsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDagsResponseBody) SetData(v *ListDagsResponseBodyData) *ListDagsResponseBody {
	s.Data = v
	return s
}

func (s *ListDagsResponseBody) SetErrorCode(v string) *ListDagsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDagsResponseBody) SetErrorMessage(v string) *ListDagsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDagsResponseBody) SetHttpStatusCode(v int32) *ListDagsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListDagsResponseBody) SetRequestId(v string) *ListDagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDagsResponseBody) SetSuccess(v bool) *ListDagsResponseBody {
	s.Success = &v
	return s
}

type ListDagsResponseBodyData struct {
	// The type of the DAG. Valid values: MANUAL, SMOKE_TEST, SUPPLY_DATA, and BUSINESS_PROCESS_DAG.
	Dags []*ListDagsResponseBodyDataDags `json:"Dags,omitempty" xml:"Dags,omitempty" type:"Repeated"`
}

func (s ListDagsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListDagsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListDagsResponseBodyData) SetDags(v []*ListDagsResponseBodyDataDags) *ListDagsResponseBodyData {
	s.Dags = v
	return s
}

type ListDagsResponseBodyDataDags struct {
	// The name of the DAG.
	Bizdate *int64 `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	// The ID of the workspace.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The data timestamp.
	CreateUser *string `json:"CreateUser,omitempty" xml:"CreateUser,omitempty"`
	// The time at which the DAG was scheduled to run.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The time at which the DAG was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	FinishTime *int64 `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	// The time at which the DAG started to run.
	Gmtdate *int64 `json:"Gmtdate,omitempty" xml:"Gmtdate,omitempty"`
	// The sequence number of the operation.
	ModifyTime *int64 `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The time at which the DAG was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	Name  *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OpSeq *int64  `json:"OpSeq,omitempty" xml:"OpSeq,omitempty"`
	// The ID of the DAG.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The user who created the DAG.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The time at which the DAG finished running. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The status of the DAG. Valid values: CREATED, RUNNING, FAILURE, and SUCCESS.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListDagsResponseBodyDataDags) String() string {
	return tea.Prettify(s)
}

func (s ListDagsResponseBodyDataDags) GoString() string {
	return s.String()
}

func (s *ListDagsResponseBodyDataDags) SetBizdate(v int64) *ListDagsResponseBodyDataDags {
	s.Bizdate = &v
	return s
}

func (s *ListDagsResponseBodyDataDags) SetCreateTime(v int64) *ListDagsResponseBodyDataDags {
	s.CreateTime = &v
	return s
}

func (s *ListDagsResponseBodyDataDags) SetCreateUser(v string) *ListDagsResponseBodyDataDags {
	s.CreateUser = &v
	return s
}

func (s *ListDagsResponseBodyDataDags) SetDagId(v int64) *ListDagsResponseBodyDataDags {
	s.DagId = &v
	return s
}

func (s *ListDagsResponseBodyDataDags) SetFinishTime(v int64) *ListDagsResponseBodyDataDags {
	s.FinishTime = &v
	return s
}

func (s *ListDagsResponseBodyDataDags) SetGmtdate(v int64) *ListDagsResponseBodyDataDags {
	s.Gmtdate = &v
	return s
}

func (s *ListDagsResponseBodyDataDags) SetModifyTime(v int64) *ListDagsResponseBodyDataDags {
	s.ModifyTime = &v
	return s
}

func (s *ListDagsResponseBodyDataDags) SetName(v string) *ListDagsResponseBodyDataDags {
	s.Name = &v
	return s
}

func (s *ListDagsResponseBodyDataDags) SetOpSeq(v int64) *ListDagsResponseBodyDataDags {
	s.OpSeq = &v
	return s
}

func (s *ListDagsResponseBodyDataDags) SetProjectId(v int64) *ListDagsResponseBodyDataDags {
	s.ProjectId = &v
	return s
}

func (s *ListDagsResponseBodyDataDags) SetStartTime(v int64) *ListDagsResponseBodyDataDags {
	s.StartTime = &v
	return s
}

func (s *ListDagsResponseBodyDataDags) SetStatus(v string) *ListDagsResponseBodyDataDags {
	s.Status = &v
	return s
}

func (s *ListDagsResponseBodyDataDags) SetType(v string) *ListDagsResponseBodyDataDags {
	s.Type = &v
	return s
}

type ListDagsResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDagsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDagsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDagsResponse) GoString() string {
	return s.String()
}

func (s *ListDagsResponse) SetHeaders(v map[string]*string) *ListDagsResponse {
	s.Headers = v
	return s
}

func (s *ListDagsResponse) SetStatusCode(v int32) *ListDagsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDagsResponse) SetBody(v *ListDagsResponseBody) *ListDagsResponse {
	s.Body = v
	return s
}

type ListDataServiceApiAuthoritiesRequest struct {
	// The keyword in the name of the API. The keyword can be used to search for the API whose name contains the keyword.
	ApiNameKeyword *string `json:"ApiNameKeyword,omitempty" xml:"ApiNameKeyword,omitempty"`
	// The number of the page to return. Pages start from page 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ListDataServiceApiAuthoritiesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApiAuthoritiesRequest) GoString() string {
	return s.String()
}

func (s *ListDataServiceApiAuthoritiesRequest) SetApiNameKeyword(v string) *ListDataServiceApiAuthoritiesRequest {
	s.ApiNameKeyword = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesRequest) SetPageNumber(v int32) *ListDataServiceApiAuthoritiesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesRequest) SetPageSize(v int32) *ListDataServiceApiAuthoritiesRequest {
	s.PageSize = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesRequest) SetProjectId(v int64) *ListDataServiceApiAuthoritiesRequest {
	s.ProjectId = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesRequest) SetTenantId(v int64) *ListDataServiceApiAuthoritiesRequest {
	s.TenantId = &v
	return s
}

type ListDataServiceApiAuthoritiesResponseBody struct {
	// The APIs on which other users are granted the access permissions.
	Data *ListDataServiceApiAuthoritiesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDataServiceApiAuthoritiesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApiAuthoritiesResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataServiceApiAuthoritiesResponseBody) SetData(v *ListDataServiceApiAuthoritiesResponseBodyData) *ListDataServiceApiAuthoritiesResponseBody {
	s.Data = v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBody) SetErrorCode(v string) *ListDataServiceApiAuthoritiesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBody) SetErrorMessage(v string) *ListDataServiceApiAuthoritiesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBody) SetHttpStatusCode(v int32) *ListDataServiceApiAuthoritiesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBody) SetRequestId(v string) *ListDataServiceApiAuthoritiesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBody) SetSuccess(v bool) *ListDataServiceApiAuthoritiesResponseBody {
	s.Success = &v
	return s
}

type ListDataServiceApiAuthoritiesResponseBodyData struct {
	// The APIs on which other users are granted the access permissions and the authorization records.
	ApiAuthorizationList []*ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList `json:"ApiAuthorizationList,omitempty" xml:"ApiAuthorizationList,omitempty" type:"Repeated"`
	// The page number of the returned page. The value of this parameter is the same as that of the PageNumber parameter in the request.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDataServiceApiAuthoritiesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApiAuthoritiesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListDataServiceApiAuthoritiesResponseBodyData) SetApiAuthorizationList(v []*ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList) *ListDataServiceApiAuthoritiesResponseBodyData {
	s.ApiAuthorizationList = v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyData) SetPageNumber(v int32) *ListDataServiceApiAuthoritiesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyData) SetPageSize(v int32) *ListDataServiceApiAuthoritiesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyData) SetTotalCount(v int32) *ListDataServiceApiAuthoritiesResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList struct {
	// The ID of the API.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The name of the API.
	ApiName *string `json:"ApiName,omitempty" xml:"ApiName,omitempty"`
	// The path of the API.
	ApiPath *string `json:"ApiPath,omitempty" xml:"ApiPath,omitempty"`
	// The status of the API. Valid values: 0 and 1. The value 0 indicates that the API is not published. The value 1 indicates that the API is published.
	ApiStatus *int32 `json:"ApiStatus,omitempty" xml:"ApiStatus,omitempty"`
	// The authorization records.
	AuthorizationRecords []*ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords `json:"AuthorizationRecords,omitempty" xml:"AuthorizationRecords,omitempty" type:"Repeated"`
	// The time when the API was created.
	CreatedTime *string `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The ID of the Alibaba Cloud account used by the API owner.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The ID of the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The time when the API was last updated.
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList) GoString() string {
	return s.String()
}

func (s *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList) SetApiId(v int64) *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList {
	s.ApiId = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList) SetApiName(v string) *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList {
	s.ApiName = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList) SetApiPath(v string) *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList {
	s.ApiPath = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList) SetApiStatus(v int32) *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList {
	s.ApiStatus = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList) SetAuthorizationRecords(v []*ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords) *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList {
	s.AuthorizationRecords = v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList) SetCreatedTime(v string) *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList {
	s.CreatedTime = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList) SetCreatorId(v string) *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList {
	s.CreatorId = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList) SetGroupId(v string) *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList {
	s.GroupId = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList) SetModifiedTime(v string) *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList {
	s.ModifiedTime = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList) SetProjectId(v int64) *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList {
	s.ProjectId = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList) SetTenantId(v int64) *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationList {
	s.TenantId = &v
	return s
}

type ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords struct {
	// The time when the access permissions on the API were granted to other users.
	CreatedTime *string `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The ID of the Alibaba Cloud account used by the user who granted other users the access permissions on the API.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The end time of the validity period of the authorization.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the workspace to which the access permissions on the API are granted.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords) GoString() string {
	return s.String()
}

func (s *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords) SetCreatedTime(v string) *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords {
	s.CreatedTime = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords) SetCreatorId(v string) *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords {
	s.CreatorId = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords) SetEndTime(v string) *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords {
	s.EndTime = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords) SetProjectId(v int64) *ListDataServiceApiAuthoritiesResponseBodyDataApiAuthorizationListAuthorizationRecords {
	s.ProjectId = &v
	return s
}

type ListDataServiceApiAuthoritiesResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDataServiceApiAuthoritiesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDataServiceApiAuthoritiesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApiAuthoritiesResponse) GoString() string {
	return s.String()
}

func (s *ListDataServiceApiAuthoritiesResponse) SetHeaders(v map[string]*string) *ListDataServiceApiAuthoritiesResponse {
	s.Headers = v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponse) SetStatusCode(v int32) *ListDataServiceApiAuthoritiesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataServiceApiAuthoritiesResponse) SetBody(v *ListDataServiceApiAuthoritiesResponseBody) *ListDataServiceApiAuthoritiesResponse {
	s.Body = v
	return s
}

type ListDataServiceApiTestRequest struct {
	// The ID of the DataService Studio API on which tests are performed.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The number of entries to return on each page. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListDataServiceApiTestRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApiTestRequest) GoString() string {
	return s.String()
}

func (s *ListDataServiceApiTestRequest) SetApiId(v int64) *ListDataServiceApiTestRequest {
	s.ApiId = &v
	return s
}

func (s *ListDataServiceApiTestRequest) SetPageSize(v int32) *ListDataServiceApiTestRequest {
	s.PageSize = &v
	return s
}

type ListDataServiceApiTestResponseBody struct {
	// The list of test records.
	Data []*ListDataServiceApiTestResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListDataServiceApiTestResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApiTestResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataServiceApiTestResponseBody) SetData(v []*ListDataServiceApiTestResponseBodyData) *ListDataServiceApiTestResponseBody {
	s.Data = v
	return s
}

func (s *ListDataServiceApiTestResponseBody) SetRequestId(v string) *ListDataServiceApiTestResponseBody {
	s.RequestId = &v
	return s
}

type ListDataServiceApiTestResponseBodyData struct {
	// The ID of the DataService Studio API on which the test is performed.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The time that is consumed to complete the test.
	CostTime *int32 `json:"CostTime,omitempty" xml:"CostTime,omitempty"`
	// The time when the test was initiated.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The request parameters configured for the test.
	ParamMap *string `json:"ParamMap,omitempty" xml:"ParamMap,omitempty"`
	// The status code returned for the test. If the test is not complete, this parameter is not returned.
	RetCode *int64 `json:"RetCode,omitempty" xml:"RetCode,omitempty"`
	// The result returned for the test.
	RetResult *string `json:"RetResult,omitempty" xml:"RetResult,omitempty"`
	// The status of the test. Valid values: RUNNING and FINISHED.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the test.
	TestId *int64 `json:"TestId,omitempty" xml:"TestId,omitempty"`
}

func (s ListDataServiceApiTestResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApiTestResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListDataServiceApiTestResponseBodyData) SetApiId(v int64) *ListDataServiceApiTestResponseBodyData {
	s.ApiId = &v
	return s
}

func (s *ListDataServiceApiTestResponseBodyData) SetCostTime(v int32) *ListDataServiceApiTestResponseBodyData {
	s.CostTime = &v
	return s
}

func (s *ListDataServiceApiTestResponseBodyData) SetCreateTime(v int64) *ListDataServiceApiTestResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *ListDataServiceApiTestResponseBodyData) SetParamMap(v string) *ListDataServiceApiTestResponseBodyData {
	s.ParamMap = &v
	return s
}

func (s *ListDataServiceApiTestResponseBodyData) SetRetCode(v int64) *ListDataServiceApiTestResponseBodyData {
	s.RetCode = &v
	return s
}

func (s *ListDataServiceApiTestResponseBodyData) SetRetResult(v string) *ListDataServiceApiTestResponseBodyData {
	s.RetResult = &v
	return s
}

func (s *ListDataServiceApiTestResponseBodyData) SetStatus(v string) *ListDataServiceApiTestResponseBodyData {
	s.Status = &v
	return s
}

func (s *ListDataServiceApiTestResponseBodyData) SetTestId(v int64) *ListDataServiceApiTestResponseBodyData {
	s.TestId = &v
	return s
}

type ListDataServiceApiTestResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDataServiceApiTestResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDataServiceApiTestResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApiTestResponse) GoString() string {
	return s.String()
}

func (s *ListDataServiceApiTestResponse) SetHeaders(v map[string]*string) *ListDataServiceApiTestResponse {
	s.Headers = v
	return s
}

func (s *ListDataServiceApiTestResponse) SetStatusCode(v int32) *ListDataServiceApiTestResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataServiceApiTestResponse) SetBody(v *ListDataServiceApiTestResponseBody) *ListDataServiceApiTestResponse {
	s.Body = v
	return s
}

type ListDataServiceApisRequest struct {
	// The ID of the tenant.
	ApiNameKeyword *string `json:"ApiNameKeyword,omitempty" xml:"ApiNameKeyword,omitempty"`
	// The keyword in the name of the API. The keyword can be used to search for the API whose name contains the keyword.
	ApiPathKeyword *string `json:"ApiPathKeyword,omitempty" xml:"ApiPathKeyword,omitempty"`
	// The keyword in the path of the API. The keyword can be used to search for the API whose path contains the keyword.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The operation that you want to perform. Set the value to **ListDataServiceApis**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of the page to return. Pages start from page 1. Default value: 1.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of entries to return on each page. Default value: 10. A maximum of 100 entries can be returned on each page.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the workspace.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ListDataServiceApisRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisRequest) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisRequest) SetApiNameKeyword(v string) *ListDataServiceApisRequest {
	s.ApiNameKeyword = &v
	return s
}

func (s *ListDataServiceApisRequest) SetApiPathKeyword(v string) *ListDataServiceApisRequest {
	s.ApiPathKeyword = &v
	return s
}

func (s *ListDataServiceApisRequest) SetCreatorId(v string) *ListDataServiceApisRequest {
	s.CreatorId = &v
	return s
}

func (s *ListDataServiceApisRequest) SetPageNumber(v int32) *ListDataServiceApisRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDataServiceApisRequest) SetPageSize(v int32) *ListDataServiceApisRequest {
	s.PageSize = &v
	return s
}

func (s *ListDataServiceApisRequest) SetProjectId(v int64) *ListDataServiceApisRequest {
	s.ProjectId = &v
	return s
}

func (s *ListDataServiceApisRequest) SetTenantId(v int64) *ListDataServiceApisRequest {
	s.TenantId = &v
	return s
}

type ListDataServiceApisResponseBody struct {
	// The error code.
	Data *ListDataServiceApisResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// Indicates whether the request is successful.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The ID of the request.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the Alibaba Cloud account used by the creator of the API. The ID can be used to search for the API created by the creator.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The HTTP status code.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The error message.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDataServiceApisResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisResponseBody) SetData(v *ListDataServiceApisResponseBodyData) *ListDataServiceApisResponseBody {
	s.Data = v
	return s
}

func (s *ListDataServiceApisResponseBody) SetErrorCode(v string) *ListDataServiceApisResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDataServiceApisResponseBody) SetErrorMessage(v string) *ListDataServiceApisResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDataServiceApisResponseBody) SetHttpStatusCode(v int32) *ListDataServiceApisResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListDataServiceApisResponseBody) SetRequestId(v string) *ListDataServiceApisResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDataServiceApisResponseBody) SetSuccess(v bool) *ListDataServiceApisResponseBody {
	s.Success = &v
	return s
}

type ListDataServiceApisResponseBodyData struct {
	// The total number of entries.
	Apis []*ListDataServiceApisResponseBodyDataApis `json:"Apis,omitempty" xml:"Apis,omitempty" type:"Repeated"`
	// The information about the APIs in the development state.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The page number of the returned page. The value of this parameter is the same as that of the PageNumber parameter in the request.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of entries returned per page. Default value: 10. A maximum of 100 entries can be returned on each page.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDataServiceApisResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisResponseBodyData) SetApis(v []*ListDataServiceApisResponseBodyDataApis) *ListDataServiceApisResponseBodyData {
	s.Apis = v
	return s
}

func (s *ListDataServiceApisResponseBodyData) SetPageNumber(v int32) *ListDataServiceApisResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListDataServiceApisResponseBodyData) SetPageSize(v int32) *ListDataServiceApisResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListDataServiceApisResponseBodyData) SetTotalCount(v int32) *ListDataServiceApisResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListDataServiceApisResponseBodyDataApis struct {
	// The status of the API. Valid values: 0 and 1. A value of 0 indicates that the API is not published. A value of 1 indicates that the API is published.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The ID of the API.
	ApiMode *int32 `json:"ApiMode,omitempty" xml:"ApiMode,omitempty"`
	// The time when the API was created.
	ApiName *string `json:"ApiName,omitempty" xml:"ApiName,omitempty"`
	// The ID of the tenant.
	ApiPath *string `json:"ApiPath,omitempty" xml:"ApiPath,omitempty"`
	// The request method of the API. Valid values: 0, 1, 2, and 3. A value of 0 indicates the GET method. A value of 1 indicates the POST method. A value of 2 indicates the PUT method. A value of 3 indicates the DELETE method. APIs generated in wizard or script mode support the GET and POST methods. APIs generated by registration support the GET, POST, PUT, and DELETE methods.
	CreatedTime *string `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The format in which the response of the API request is returned. Valid values: 0 and 1. A value of 0 indicates the JSON format. A value of 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The ID of the API group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The description of the API.
	FolderId *int64 `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The ID of the Alibaba Cloud account used by the user who last modified the API.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The scope in which the API is visible. Valid values: 0 and 1. A value of 0 indicates that the API is visible within the workspace. A value of 1 indicates that the API is visible only to the API creator.
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The time when the API was last modified.
	OperatorId *string `json:"OperatorId,omitempty" xml:"OperatorId,omitempty"`
	// The type of the API. Valid values: 0, 1, and 2. A value of 0 indicates that the API is generated in wizard mode. A value of 1 indicates that the API is generated in script mode. A value of 2 indicates that the API is generated by registration.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The path of the API.
	Protocols []*int32 `json:"Protocols,omitempty" xml:"Protocols,omitempty" type:"Repeated"`
	// The protocols used by the API. Valid values: 0 and 1. A value of 0 indicates that the API uses HTTP. A value of 1 indicates that the API uses HTTPS. Multiple protocols are presented in a list.
	RegistrationDetails *ListDataServiceApisResponseBodyDataApisRegistrationDetails `json:"RegistrationDetails,omitempty" xml:"RegistrationDetails,omitempty" type:"Struct"`
	// The ID of the folder in which the API is stored.
	RequestMethod *int32 `json:"RequestMethod,omitempty" xml:"RequestMethod,omitempty"`
	// The ID of the workspace.
	ResponseContentType *int32 `json:"ResponseContentType,omitempty" xml:"ResponseContentType,omitempty"`
	// The details of the API generated in script mode. This parameter is returned only if the API is generated in script mode.
	ScriptDetails *ListDataServiceApisResponseBodyDataApisScriptDetails `json:"ScriptDetails,omitempty" xml:"ScriptDetails,omitempty" type:"Struct"`
	// The timeout period of the API request. Unit: milliseconds.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The name of the API.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	// The APIs in the development state.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The ID of the Alibaba Cloud account used by the creator of the API.
	VisibleRange *int32 `json:"VisibleRange,omitempty" xml:"VisibleRange,omitempty"`
	// The details of the API generated in wizard mode. This parameter is returned only if the API is generated in wizard mode.
	WizardDetails *ListDataServiceApisResponseBodyDataApisWizardDetails `json:"WizardDetails,omitempty" xml:"WizardDetails,omitempty" type:"Struct"`
}

func (s ListDataServiceApisResponseBodyDataApis) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisResponseBodyDataApis) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisResponseBodyDataApis) SetApiId(v int64) *ListDataServiceApisResponseBodyDataApis {
	s.ApiId = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetApiMode(v int32) *ListDataServiceApisResponseBodyDataApis {
	s.ApiMode = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetApiName(v string) *ListDataServiceApisResponseBodyDataApis {
	s.ApiName = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetApiPath(v string) *ListDataServiceApisResponseBodyDataApis {
	s.ApiPath = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetCreatedTime(v string) *ListDataServiceApisResponseBodyDataApis {
	s.CreatedTime = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetCreatorId(v string) *ListDataServiceApisResponseBodyDataApis {
	s.CreatorId = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetDescription(v string) *ListDataServiceApisResponseBodyDataApis {
	s.Description = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetFolderId(v int64) *ListDataServiceApisResponseBodyDataApis {
	s.FolderId = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetGroupId(v string) *ListDataServiceApisResponseBodyDataApis {
	s.GroupId = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetModifiedTime(v string) *ListDataServiceApisResponseBodyDataApis {
	s.ModifiedTime = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetOperatorId(v string) *ListDataServiceApisResponseBodyDataApis {
	s.OperatorId = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetProjectId(v int64) *ListDataServiceApisResponseBodyDataApis {
	s.ProjectId = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetProtocols(v []*int32) *ListDataServiceApisResponseBodyDataApis {
	s.Protocols = v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetRegistrationDetails(v *ListDataServiceApisResponseBodyDataApisRegistrationDetails) *ListDataServiceApisResponseBodyDataApis {
	s.RegistrationDetails = v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetRequestMethod(v int32) *ListDataServiceApisResponseBodyDataApis {
	s.RequestMethod = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetResponseContentType(v int32) *ListDataServiceApisResponseBodyDataApis {
	s.ResponseContentType = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetScriptDetails(v *ListDataServiceApisResponseBodyDataApisScriptDetails) *ListDataServiceApisResponseBodyDataApis {
	s.ScriptDetails = v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetStatus(v int32) *ListDataServiceApisResponseBodyDataApis {
	s.Status = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetTenantId(v int64) *ListDataServiceApisResponseBodyDataApis {
	s.TenantId = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetTimeout(v int32) *ListDataServiceApisResponseBodyDataApis {
	s.Timeout = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetVisibleRange(v int32) *ListDataServiceApisResponseBodyDataApis {
	s.VisibleRange = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApis) SetWizardDetails(v *ListDataServiceApisResponseBodyDataApisWizardDetails) *ListDataServiceApisResponseBodyDataApis {
	s.WizardDetails = v
	return s
}

type ListDataServiceApisResponseBodyDataApisRegistrationDetails struct {
	// The sample success response of the API.
	FailedResultSample *string `json:"FailedResultSample,omitempty" xml:"FailedResultSample,omitempty"`
	// The body of the request initiated to call the backend service.
	RegistrationErrorCodes []*ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes `json:"RegistrationErrorCodes,omitempty" xml:"RegistrationErrorCodes,omitempty" type:"Repeated"`
	// The solution used to resolve the issue.
	RegistrationRequestParameters []*ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters `json:"RegistrationRequestParameters,omitempty" xml:"RegistrationRequestParameters,omitempty" type:"Repeated"`
	// The URL of the backend service.
	ServiceContentType *int32 `json:"ServiceContentType,omitempty" xml:"ServiceContentType,omitempty"`
	// The details of the API generated by registration. This parameter is returned only if the API is generated by registration.
	ServiceHost *string `json:"ServiceHost,omitempty" xml:"ServiceHost,omitempty"`
	// The format in which the response of the API request is returned. Valid values: 0 and 1. A value of 0 indicates the JSON format. A value of 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
	ServicePath *string `json:"ServicePath,omitempty" xml:"ServicePath,omitempty"`
	// The sample error response of the API.
	ServiceRequestBodyDescription *string `json:"ServiceRequestBodyDescription,omitempty" xml:"ServiceRequestBodyDescription,omitempty"`
	// The path of the backend service.
	SuccessfulResultSample *string `json:"SuccessfulResultSample,omitempty" xml:"SuccessfulResultSample,omitempty"`
}

func (s ListDataServiceApisResponseBodyDataApisRegistrationDetails) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisResponseBodyDataApisRegistrationDetails) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetails) SetFailedResultSample(v string) *ListDataServiceApisResponseBodyDataApisRegistrationDetails {
	s.FailedResultSample = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetails) SetRegistrationErrorCodes(v []*ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes) *ListDataServiceApisResponseBodyDataApisRegistrationDetails {
	s.RegistrationErrorCodes = v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetails) SetRegistrationRequestParameters(v []*ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) *ListDataServiceApisResponseBodyDataApisRegistrationDetails {
	s.RegistrationRequestParameters = v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetails) SetServiceContentType(v int32) *ListDataServiceApisResponseBodyDataApisRegistrationDetails {
	s.ServiceContentType = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetails) SetServiceHost(v string) *ListDataServiceApisResponseBodyDataApisRegistrationDetails {
	s.ServiceHost = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetails) SetServicePath(v string) *ListDataServiceApisResponseBodyDataApisRegistrationDetails {
	s.ServicePath = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetails) SetServiceRequestBodyDescription(v string) *ListDataServiceApisResponseBodyDataApisRegistrationDetails {
	s.ServiceRequestBodyDescription = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetails) SetSuccessfulResultSample(v string) *ListDataServiceApisResponseBodyDataApisRegistrationDetails {
	s.SuccessfulResultSample = &v
	return s
}

type ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes struct {
	// The error message.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error codes returned for the API generated by registration.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The error code.
	ErrorSolution *string `json:"ErrorSolution,omitempty" xml:"ErrorSolution,omitempty"`
}

func (s ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes) SetErrorCode(v string) *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes {
	s.ErrorCode = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes) SetErrorMessage(v string) *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes {
	s.ErrorMessage = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes) SetErrorSolution(v string) *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes {
	s.ErrorSolution = &v
	return s
}

type ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters struct {
	// The request parameters of the API generated by registration.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The description of the parameter.
	DefaultValue *string `json:"DefaultValue,omitempty" xml:"DefaultValue,omitempty"`
	// The data type of the parameter. Valid values: 0, 1, 2, 3, 4, and 5. A value of 0 indicates the STRING data type. A value of 1 indicates the INT data type. A value of 2 indicates the LONG data type. A value of 3 indicates the FLOAT data type. A value of 4 indicates the DOUBLE data type. A value of 5 indicates the BOOLEAN data type.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// The sample value of the parameter.
	IsRequiredParameter *bool `json:"IsRequiredParameter,omitempty" xml:"IsRequiredParameter,omitempty"`
	// The operator used for the value of the parameter. Valid values: 0, 1, 2, and 3. A value of 0 indicates that the operator is Equal. A value of 1 indicates that the operator is Like. A value of 2 indicates that the operator is Const. A value of 3 indicates that the operator is In. APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The position of the parameter. Valid values: 0, 1, 2, and 3. A value of 0 indicates that the parameter is in the URL path of the request. A value of 1 indicates that the parameter is in the Query parameter of the request URL. A value of 2 indicates that the parameter is in the request header. A value of 3 indicates that the parameter is in the request body. APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The default value of the parameter.
	ParameterOperator *int32 `json:"ParameterOperator,omitempty" xml:"ParameterOperator,omitempty"`
	// The name of the parameter.
	ParameterPosition *int32 `json:"ParameterPosition,omitempty" xml:"ParameterPosition,omitempty"`
}

func (s ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetColumnName(v string) *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.ColumnName = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetDefaultValue(v string) *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.DefaultValue = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetExampleValue(v string) *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.ExampleValue = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetIsRequiredParameter(v bool) *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.IsRequiredParameter = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetParameterDataType(v int32) *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.ParameterDataType = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetParameterDescription(v string) *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.ParameterDescription = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetParameterName(v string) *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.ParameterName = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetParameterOperator(v int32) *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.ParameterOperator = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetParameterPosition(v int32) *ListDataServiceApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.ParameterPosition = &v
	return s
}

type ListDataServiceApisResponseBodyDataApisScriptDetails struct {
	// Indicates whether the entries are returned by page.
	IsPagedResponse *bool `json:"IsPagedResponse,omitempty" xml:"IsPagedResponse,omitempty"`
	// The SQL script.
	Script *string `json:"Script,omitempty" xml:"Script,omitempty"`
	// The data source information of the API generated in script mode.
	ScriptConnection *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection `json:"ScriptConnection,omitempty" xml:"ScriptConnection,omitempty" type:"Struct"`
	// The request parameters of the API generated in script mode.
	ScriptRequestParameters []*ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters `json:"ScriptRequestParameters,omitempty" xml:"ScriptRequestParameters,omitempty" type:"Repeated"`
	// The response parameters of the API generated in script mode.
	ScriptResponseParameters []*ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters `json:"ScriptResponseParameters,omitempty" xml:"ScriptResponseParameters,omitempty" type:"Repeated"`
}

func (s ListDataServiceApisResponseBodyDataApisScriptDetails) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisResponseBodyDataApisScriptDetails) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetails) SetIsPagedResponse(v bool) *ListDataServiceApisResponseBodyDataApisScriptDetails {
	s.IsPagedResponse = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetails) SetScript(v string) *ListDataServiceApisResponseBodyDataApisScriptDetails {
	s.Script = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetails) SetScriptConnection(v *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection) *ListDataServiceApisResponseBodyDataApisScriptDetails {
	s.ScriptConnection = v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetails) SetScriptRequestParameters(v []*ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters) *ListDataServiceApisResponseBodyDataApisScriptDetails {
	s.ScriptRequestParameters = v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetails) SetScriptResponseParameters(v []*ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters) *ListDataServiceApisResponseBodyDataApisScriptDetails {
	s.ScriptResponseParameters = v
	return s
}

type ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection struct {
	// The ID of the data source.
	ConnectionId *int64 `json:"ConnectionId,omitempty" xml:"ConnectionId,omitempty"`
	// The name of the table in the data source.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection) SetConnectionId(v int64) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection {
	s.ConnectionId = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection) SetTableName(v string) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptConnection {
	s.TableName = &v
	return s
}

type ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters struct {
	// The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The default value of the parameter.
	DefaultValue *string `json:"DefaultValue,omitempty" xml:"DefaultValue,omitempty"`
	// The sample value of the parameter.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// Indicates whether the request parameter is required.
	IsRequiredParameter *bool `json:"IsRequiredParameter,omitempty" xml:"IsRequiredParameter,omitempty"`
	// The data type of the parameter. Valid values:
	//
	// - 0: STRING
	// - 1: INT
	// - 2: LONG
	// - 3: FLOAT
	// - 4: DOUBLE
	// - 5: BOOLEAN
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description of the parameter.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The operator used for the value of the parameter. Valid values:
	//
	// - 0: Equal
	// - 1: Like
	// - 2: Const
	// - 3: In
	//
	// APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
	ParameterOperator *int32 `json:"ParameterOperator,omitempty" xml:"ParameterOperator,omitempty"`
	// The position of the parameter. Valid values:
	//
	// - 0: Path
	// - 1: Query
	// - 2: Head
	// - 3: Body
	//
	// APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
	ParameterPosition *int32 `json:"ParameterPosition,omitempty" xml:"ParameterPosition,omitempty"`
}

func (s ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetColumnName(v string) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.ColumnName = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetDefaultValue(v string) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.DefaultValue = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetExampleValue(v string) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.ExampleValue = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetIsRequiredParameter(v bool) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.IsRequiredParameter = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetParameterDataType(v int32) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.ParameterDataType = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetParameterDescription(v string) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.ParameterDescription = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetParameterName(v string) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.ParameterName = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetParameterOperator(v int32) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.ParameterOperator = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetParameterPosition(v int32) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.ParameterPosition = &v
	return s
}

type ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters struct {
	// The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The sample value of the parameter.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// The data type of the parameter. Valid values:
	//
	// - 0: STRING
	// - 1: INT
	// - 2: LONG
	// - 3: FLOAT
	// - 4: DOUBLE
	// - 5: BOOLEAN
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description of the parameter.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
}

func (s ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters) SetColumnName(v string) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters {
	s.ColumnName = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters) SetExampleValue(v string) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters {
	s.ExampleValue = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters) SetParameterDataType(v int32) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters {
	s.ParameterDataType = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters) SetParameterDescription(v string) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters {
	s.ParameterDescription = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters) SetParameterName(v string) *ListDataServiceApisResponseBodyDataApisScriptDetailsScriptResponseParameters {
	s.ParameterName = &v
	return s
}

type ListDataServiceApisResponseBodyDataApisWizardDetails struct {
	// Indicates whether the entries are returned by page.
	IsPagedResponse *bool `json:"IsPagedResponse,omitempty" xml:"IsPagedResponse,omitempty"`
	// The data source information of the API generated in wizard mode.
	WizardConnection *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection `json:"WizardConnection,omitempty" xml:"WizardConnection,omitempty" type:"Struct"`
	// The request parameters of the API generated in wizard mode.
	WizardRequestParameters []*ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters `json:"WizardRequestParameters,omitempty" xml:"WizardRequestParameters,omitempty" type:"Repeated"`
	// The response parameters of the API generated in wizard mode.
	WizardResponseParameters []*ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters `json:"WizardResponseParameters,omitempty" xml:"WizardResponseParameters,omitempty" type:"Repeated"`
}

func (s ListDataServiceApisResponseBodyDataApisWizardDetails) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisResponseBodyDataApisWizardDetails) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetails) SetIsPagedResponse(v bool) *ListDataServiceApisResponseBodyDataApisWizardDetails {
	s.IsPagedResponse = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetails) SetWizardConnection(v *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection) *ListDataServiceApisResponseBodyDataApisWizardDetails {
	s.WizardConnection = v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetails) SetWizardRequestParameters(v []*ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters) *ListDataServiceApisResponseBodyDataApisWizardDetails {
	s.WizardRequestParameters = v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetails) SetWizardResponseParameters(v []*ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters) *ListDataServiceApisResponseBodyDataApisWizardDetails {
	s.WizardResponseParameters = v
	return s
}

type ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection struct {
	// The ID of the data source.
	ConnectionId *int64 `json:"ConnectionId,omitempty" xml:"ConnectionId,omitempty"`
	// The name of the table in the data source.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection) SetConnectionId(v int64) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection {
	s.ConnectionId = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection) SetTableName(v string) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardConnection {
	s.TableName = &v
	return s
}

type ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters struct {
	// The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The default value of the parameter.
	DefaultValue *string `json:"DefaultValue,omitempty" xml:"DefaultValue,omitempty"`
	// The sample value of the parameter.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// Indicates whether the request parameter is required.
	IsRequiredParameter *bool `json:"IsRequiredParameter,omitempty" xml:"IsRequiredParameter,omitempty"`
	// The data type of the parameter. Valid values: 0, 1, 2, 3, 4, and 5. A value of 0 indicates the STRING data type. A value of 1 indicates the INT data type. A value of 2 indicates the LONG data type. A value of 3 indicates the FLOAT data type. A value of 4 indicates the DOUBLE data type. A value of 5 indicates the BOOLEAN data type.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description of the parameter.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The operator used for the value of the parameter. Valid values: 0, 1, 2, and 3. A value of 0 indicates that the operator is Equal. A value of 1 indicates that the operator is Like. A value of 2 indicates that the operator is Const. A value of 3 indicates that the operator is In. APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
	ParameterOperator *int32 `json:"ParameterOperator,omitempty" xml:"ParameterOperator,omitempty"`
	// The position of the parameter. Valid values: 0, 1, 2, and 3. A value of 0 indicates that the parameter is in the URL path of the request. A value of 1 indicates that the parameter is in the Query parameter of the request URL. A value of 2 indicates that the parameter is in the request header. A value of 3 indicates that the parameter is in the request body. APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
	ParameterPosition *int32 `json:"ParameterPosition,omitempty" xml:"ParameterPosition,omitempty"`
}

func (s ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetColumnName(v string) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.ColumnName = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetDefaultValue(v string) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.DefaultValue = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetExampleValue(v string) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.ExampleValue = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetIsRequiredParameter(v bool) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.IsRequiredParameter = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetParameterDataType(v int32) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.ParameterDataType = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetParameterDescription(v string) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.ParameterDescription = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetParameterName(v string) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.ParameterName = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetParameterOperator(v int32) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.ParameterOperator = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetParameterPosition(v int32) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.ParameterPosition = &v
	return s
}

type ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters struct {
	// The name of the associated field. This parameter is supported only if the API is generated in wizard mode.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The sample value of the parameter.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// The data type of the parameter. Valid values: 0, 1, 2, 3, 4, and 5. A value of 0 indicates the STRING data type. A value of 1 indicates the INT data type. A value of 2 indicates the LONG data type. A value of 3 indicates the FLOAT data type. A value of 4 indicates the DOUBLE data type. A value of 5 indicates the BOOLEAN data type.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description of the parameter.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
}

func (s ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters) SetColumnName(v string) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters {
	s.ColumnName = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters) SetExampleValue(v string) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters {
	s.ExampleValue = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters) SetParameterDataType(v int32) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters {
	s.ParameterDataType = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters) SetParameterDescription(v string) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters {
	s.ParameterDescription = &v
	return s
}

func (s *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters) SetParameterName(v string) *ListDataServiceApisResponseBodyDataApisWizardDetailsWizardResponseParameters {
	s.ParameterName = &v
	return s
}

type ListDataServiceApisResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDataServiceApisResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDataServiceApisResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApisResponse) GoString() string {
	return s.String()
}

func (s *ListDataServiceApisResponse) SetHeaders(v map[string]*string) *ListDataServiceApisResponse {
	s.Headers = v
	return s
}

func (s *ListDataServiceApisResponse) SetStatusCode(v int32) *ListDataServiceApisResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataServiceApisResponse) SetBody(v *ListDataServiceApisResponseBody) *ListDataServiceApisResponse {
	s.Body = v
	return s
}

type ListDataServiceApplicationsRequest struct {
	// The number of the page to return. Pages start from page 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the workspace based on which you want to query the basic information of applications. You can specify multiple IDs. Separate them with commas (,). You must specify at least one workspace ID. You can specify a maximum of 50 workspace IDs.
	ProjectIdList *string `json:"ProjectIdList,omitempty" xml:"ProjectIdList,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ListDataServiceApplicationsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApplicationsRequest) GoString() string {
	return s.String()
}

func (s *ListDataServiceApplicationsRequest) SetPageNumber(v int32) *ListDataServiceApplicationsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDataServiceApplicationsRequest) SetPageSize(v int32) *ListDataServiceApplicationsRequest {
	s.PageSize = &v
	return s
}

func (s *ListDataServiceApplicationsRequest) SetProjectIdList(v string) *ListDataServiceApplicationsRequest {
	s.ProjectIdList = &v
	return s
}

func (s *ListDataServiceApplicationsRequest) SetTenantId(v int64) *ListDataServiceApplicationsRequest {
	s.TenantId = &v
	return s
}

type ListDataServiceApplicationsResponseBody struct {
	// The returned result.
	Data *ListDataServiceApplicationsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDataServiceApplicationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApplicationsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataServiceApplicationsResponseBody) SetData(v *ListDataServiceApplicationsResponseBodyData) *ListDataServiceApplicationsResponseBody {
	s.Data = v
	return s
}

func (s *ListDataServiceApplicationsResponseBody) SetErrorCode(v string) *ListDataServiceApplicationsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDataServiceApplicationsResponseBody) SetErrorMessage(v string) *ListDataServiceApplicationsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDataServiceApplicationsResponseBody) SetHttpStatusCode(v int32) *ListDataServiceApplicationsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListDataServiceApplicationsResponseBody) SetRequestId(v string) *ListDataServiceApplicationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDataServiceApplicationsResponseBody) SetSuccess(v bool) *ListDataServiceApplicationsResponseBody {
	s.Success = &v
	return s
}

type ListDataServiceApplicationsResponseBodyData struct {
	// The basic information of the applications.
	Applications []*ListDataServiceApplicationsResponseBodyDataApplications `json:"Applications,omitempty" xml:"Applications,omitempty" type:"Repeated"`
	// The page number of the returned page. The value of this parameter is the same as that of the PageNumber parameter in the request.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDataServiceApplicationsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApplicationsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListDataServiceApplicationsResponseBodyData) SetApplications(v []*ListDataServiceApplicationsResponseBodyDataApplications) *ListDataServiceApplicationsResponseBodyData {
	s.Applications = v
	return s
}

func (s *ListDataServiceApplicationsResponseBodyData) SetPageNumber(v int32) *ListDataServiceApplicationsResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListDataServiceApplicationsResponseBodyData) SetPageSize(v int32) *ListDataServiceApplicationsResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListDataServiceApplicationsResponseBodyData) SetTotalCount(v int32) *ListDataServiceApplicationsResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListDataServiceApplicationsResponseBodyDataApplications struct {
	// The ID of the application.
	ApplicationId *int64 `json:"ApplicationId,omitempty" xml:"ApplicationId,omitempty"`
	// The name of the application.
	ApplicationName *string `json:"ApplicationName,omitempty" xml:"ApplicationName,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListDataServiceApplicationsResponseBodyDataApplications) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApplicationsResponseBodyDataApplications) GoString() string {
	return s.String()
}

func (s *ListDataServiceApplicationsResponseBodyDataApplications) SetApplicationId(v int64) *ListDataServiceApplicationsResponseBodyDataApplications {
	s.ApplicationId = &v
	return s
}

func (s *ListDataServiceApplicationsResponseBodyDataApplications) SetApplicationName(v string) *ListDataServiceApplicationsResponseBodyDataApplications {
	s.ApplicationName = &v
	return s
}

func (s *ListDataServiceApplicationsResponseBodyDataApplications) SetProjectId(v int64) *ListDataServiceApplicationsResponseBodyDataApplications {
	s.ProjectId = &v
	return s
}

type ListDataServiceApplicationsResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDataServiceApplicationsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDataServiceApplicationsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceApplicationsResponse) GoString() string {
	return s.String()
}

func (s *ListDataServiceApplicationsResponse) SetHeaders(v map[string]*string) *ListDataServiceApplicationsResponse {
	s.Headers = v
	return s
}

func (s *ListDataServiceApplicationsResponse) SetStatusCode(v int32) *ListDataServiceApplicationsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataServiceApplicationsResponse) SetBody(v *ListDataServiceApplicationsResponseBody) *ListDataServiceApplicationsResponse {
	s.Body = v
	return s
}

type ListDataServiceAuthorizedApisRequest struct {
	// The keyword in API names. The keyword is used to search for the APIs whose names contain the keyword.
	ApiNameKeyword *string `json:"ApiNameKeyword,omitempty" xml:"ApiNameKeyword,omitempty"`
	// The number of the page to return. Pages start from page 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ListDataServiceAuthorizedApisRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceAuthorizedApisRequest) GoString() string {
	return s.String()
}

func (s *ListDataServiceAuthorizedApisRequest) SetApiNameKeyword(v string) *ListDataServiceAuthorizedApisRequest {
	s.ApiNameKeyword = &v
	return s
}

func (s *ListDataServiceAuthorizedApisRequest) SetPageNumber(v int32) *ListDataServiceAuthorizedApisRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDataServiceAuthorizedApisRequest) SetPageSize(v int32) *ListDataServiceAuthorizedApisRequest {
	s.PageSize = &v
	return s
}

func (s *ListDataServiceAuthorizedApisRequest) SetProjectId(v int64) *ListDataServiceAuthorizedApisRequest {
	s.ProjectId = &v
	return s
}

func (s *ListDataServiceAuthorizedApisRequest) SetTenantId(v int64) *ListDataServiceAuthorizedApisRequest {
	s.TenantId = &v
	return s
}

type ListDataServiceAuthorizedApisResponseBody struct {
	// The information about the APIs that you are authorized to access.
	Data *ListDataServiceAuthorizedApisResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDataServiceAuthorizedApisResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceAuthorizedApisResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataServiceAuthorizedApisResponseBody) SetData(v *ListDataServiceAuthorizedApisResponseBodyData) *ListDataServiceAuthorizedApisResponseBody {
	s.Data = v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBody) SetErrorCode(v string) *ListDataServiceAuthorizedApisResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBody) SetErrorMessage(v string) *ListDataServiceAuthorizedApisResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBody) SetHttpStatusCode(v int32) *ListDataServiceAuthorizedApisResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBody) SetRequestId(v string) *ListDataServiceAuthorizedApisResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBody) SetSuccess(v bool) *ListDataServiceAuthorizedApisResponseBody {
	s.Success = &v
	return s
}

type ListDataServiceAuthorizedApisResponseBodyData struct {
	// The list of APIs that you are authorized to access.
	ApiAuthorizedList []*ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList `json:"ApiAuthorizedList,omitempty" xml:"ApiAuthorizedList,omitempty" type:"Repeated"`
	// The page number of the returned page. The value of this parameter is the same as that of the PageNumber parameter in the request.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of returned entries.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDataServiceAuthorizedApisResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceAuthorizedApisResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListDataServiceAuthorizedApisResponseBodyData) SetApiAuthorizedList(v []*ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) *ListDataServiceAuthorizedApisResponseBodyData {
	s.ApiAuthorizedList = v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBodyData) SetPageNumber(v int32) *ListDataServiceAuthorizedApisResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBodyData) SetPageSize(v int32) *ListDataServiceAuthorizedApisResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBodyData) SetTotalCount(v int32) *ListDataServiceAuthorizedApisResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList struct {
	// The ID of the API.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The name of the API.
	ApiName *string `json:"ApiName,omitempty" xml:"ApiName,omitempty"`
	// The path of the API.
	ApiPath *string `json:"ApiPath,omitempty" xml:"ApiPath,omitempty"`
	// The status of the API. Valid values: 0 and 1. The value 0 indicates that the API is not published. The value 1 indicates that the API is published.
	ApiStatus *int32 `json:"ApiStatus,omitempty" xml:"ApiStatus,omitempty"`
	// The time when the API was created.
	CreatedTime *string `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The ID of the Alibaba Cloud account used by the API owner.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The time when the access permissions of the API were granted.
	GrantCreatedTime *string `json:"GrantCreatedTime,omitempty" xml:"GrantCreatedTime,omitempty"`
	// The expiration time for the granted access permissions of the API.
	GrantEndTime *string `json:"GrantEndTime,omitempty" xml:"GrantEndTime,omitempty"`
	// The ID of the Alibaba Cloud account used by the user who granted the access permissions of the API.
	GrantOperatorId *string `json:"GrantOperatorId,omitempty" xml:"GrantOperatorId,omitempty"`
	// The ID of the API group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The time when the API was last updated.
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) GoString() string {
	return s.String()
}

func (s *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) SetApiId(v int64) *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList {
	s.ApiId = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) SetApiName(v string) *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList {
	s.ApiName = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) SetApiPath(v string) *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList {
	s.ApiPath = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) SetApiStatus(v int32) *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList {
	s.ApiStatus = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) SetCreatedTime(v string) *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList {
	s.CreatedTime = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) SetCreatorId(v string) *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList {
	s.CreatorId = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) SetGrantCreatedTime(v string) *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList {
	s.GrantCreatedTime = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) SetGrantEndTime(v string) *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList {
	s.GrantEndTime = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) SetGrantOperatorId(v string) *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList {
	s.GrantOperatorId = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) SetGroupId(v string) *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList {
	s.GroupId = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) SetModifiedTime(v string) *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList {
	s.ModifiedTime = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) SetProjectId(v int64) *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList {
	s.ProjectId = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList) SetTenantId(v int64) *ListDataServiceAuthorizedApisResponseBodyDataApiAuthorizedList {
	s.TenantId = &v
	return s
}

type ListDataServiceAuthorizedApisResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDataServiceAuthorizedApisResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDataServiceAuthorizedApisResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceAuthorizedApisResponse) GoString() string {
	return s.String()
}

func (s *ListDataServiceAuthorizedApisResponse) SetHeaders(v map[string]*string) *ListDataServiceAuthorizedApisResponse {
	s.Headers = v
	return s
}

func (s *ListDataServiceAuthorizedApisResponse) SetStatusCode(v int32) *ListDataServiceAuthorizedApisResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataServiceAuthorizedApisResponse) SetBody(v *ListDataServiceAuthorizedApisResponseBody) *ListDataServiceAuthorizedApisResponse {
	s.Body = v
	return s
}

type ListDataServiceFoldersRequest struct {
	// The keyword in folder names. The keyword is used to search for folders whose names contain this keyword.
	FolderNameKeyword *string `json:"FolderNameKeyword,omitempty" xml:"FolderNameKeyword,omitempty"`
	// The ID of the business process to which the folders belong.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The number of the page to return. Pages start from page 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ListDataServiceFoldersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceFoldersRequest) GoString() string {
	return s.String()
}

func (s *ListDataServiceFoldersRequest) SetFolderNameKeyword(v string) *ListDataServiceFoldersRequest {
	s.FolderNameKeyword = &v
	return s
}

func (s *ListDataServiceFoldersRequest) SetGroupId(v string) *ListDataServiceFoldersRequest {
	s.GroupId = &v
	return s
}

func (s *ListDataServiceFoldersRequest) SetPageNumber(v int32) *ListDataServiceFoldersRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDataServiceFoldersRequest) SetPageSize(v int32) *ListDataServiceFoldersRequest {
	s.PageSize = &v
	return s
}

func (s *ListDataServiceFoldersRequest) SetProjectId(v int64) *ListDataServiceFoldersRequest {
	s.ProjectId = &v
	return s
}

func (s *ListDataServiceFoldersRequest) SetTenantId(v int64) *ListDataServiceFoldersRequest {
	s.TenantId = &v
	return s
}

type ListDataServiceFoldersResponseBody struct {
	// The paging result for the folders.
	FolderPagingResult *ListDataServiceFoldersResponseBodyFolderPagingResult `json:"FolderPagingResult,omitempty" xml:"FolderPagingResult,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListDataServiceFoldersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceFoldersResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataServiceFoldersResponseBody) SetFolderPagingResult(v *ListDataServiceFoldersResponseBodyFolderPagingResult) *ListDataServiceFoldersResponseBody {
	s.FolderPagingResult = v
	return s
}

func (s *ListDataServiceFoldersResponseBody) SetRequestId(v string) *ListDataServiceFoldersResponseBody {
	s.RequestId = &v
	return s
}

type ListDataServiceFoldersResponseBodyFolderPagingResult struct {
	// The folders.
	Folders []*ListDataServiceFoldersResponseBodyFolderPagingResultFolders `json:"Folders,omitempty" xml:"Folders,omitempty" type:"Repeated"`
	// The page number of the returned page. The value of this parameter is the same as that of the PageNumber parameter in the request.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of returned entries.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDataServiceFoldersResponseBodyFolderPagingResult) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceFoldersResponseBodyFolderPagingResult) GoString() string {
	return s.String()
}

func (s *ListDataServiceFoldersResponseBodyFolderPagingResult) SetFolders(v []*ListDataServiceFoldersResponseBodyFolderPagingResultFolders) *ListDataServiceFoldersResponseBodyFolderPagingResult {
	s.Folders = v
	return s
}

func (s *ListDataServiceFoldersResponseBodyFolderPagingResult) SetPageNumber(v int32) *ListDataServiceFoldersResponseBodyFolderPagingResult {
	s.PageNumber = &v
	return s
}

func (s *ListDataServiceFoldersResponseBodyFolderPagingResult) SetPageSize(v int32) *ListDataServiceFoldersResponseBodyFolderPagingResult {
	s.PageSize = &v
	return s
}

func (s *ListDataServiceFoldersResponseBodyFolderPagingResult) SetTotalCount(v int32) *ListDataServiceFoldersResponseBodyFolderPagingResult {
	s.TotalCount = &v
	return s
}

type ListDataServiceFoldersResponseBodyFolderPagingResultFolders struct {
	// The time when the folder was created.
	CreatedTime *string `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The ID of the folder.
	FolderId *int64 `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The name of the folder.
	FolderName *string `json:"FolderName,omitempty" xml:"FolderName,omitempty"`
	// The ID of the business process to which the folder belongs.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The time when the folder was last modified.
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The ID of the parent folder. The ID of the root folder in a business process is 0, and the ID of a folder created by a user in a business process is greater than 0.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ListDataServiceFoldersResponseBodyFolderPagingResultFolders) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceFoldersResponseBodyFolderPagingResultFolders) GoString() string {
	return s.String()
}

func (s *ListDataServiceFoldersResponseBodyFolderPagingResultFolders) SetCreatedTime(v string) *ListDataServiceFoldersResponseBodyFolderPagingResultFolders {
	s.CreatedTime = &v
	return s
}

func (s *ListDataServiceFoldersResponseBodyFolderPagingResultFolders) SetFolderId(v int64) *ListDataServiceFoldersResponseBodyFolderPagingResultFolders {
	s.FolderId = &v
	return s
}

func (s *ListDataServiceFoldersResponseBodyFolderPagingResultFolders) SetFolderName(v string) *ListDataServiceFoldersResponseBodyFolderPagingResultFolders {
	s.FolderName = &v
	return s
}

func (s *ListDataServiceFoldersResponseBodyFolderPagingResultFolders) SetGroupId(v string) *ListDataServiceFoldersResponseBodyFolderPagingResultFolders {
	s.GroupId = &v
	return s
}

func (s *ListDataServiceFoldersResponseBodyFolderPagingResultFolders) SetModifiedTime(v string) *ListDataServiceFoldersResponseBodyFolderPagingResultFolders {
	s.ModifiedTime = &v
	return s
}

func (s *ListDataServiceFoldersResponseBodyFolderPagingResultFolders) SetParentId(v int64) *ListDataServiceFoldersResponseBodyFolderPagingResultFolders {
	s.ParentId = &v
	return s
}

func (s *ListDataServiceFoldersResponseBodyFolderPagingResultFolders) SetProjectId(v int64) *ListDataServiceFoldersResponseBodyFolderPagingResultFolders {
	s.ProjectId = &v
	return s
}

func (s *ListDataServiceFoldersResponseBodyFolderPagingResultFolders) SetTenantId(v int64) *ListDataServiceFoldersResponseBodyFolderPagingResultFolders {
	s.TenantId = &v
	return s
}

type ListDataServiceFoldersResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDataServiceFoldersResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDataServiceFoldersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceFoldersResponse) GoString() string {
	return s.String()
}

func (s *ListDataServiceFoldersResponse) SetHeaders(v map[string]*string) *ListDataServiceFoldersResponse {
	s.Headers = v
	return s
}

func (s *ListDataServiceFoldersResponse) SetStatusCode(v int32) *ListDataServiceFoldersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataServiceFoldersResponse) SetBody(v *ListDataServiceFoldersResponseBody) *ListDataServiceFoldersResponse {
	s.Body = v
	return s
}

type ListDataServiceGroupsRequest struct {
	// The keyword of a business process name. The keyword is used to search for business processes whose names contain this keyword.
	GroupNameKeyword *string `json:"GroupNameKeyword,omitempty" xml:"GroupNameKeyword,omitempty"`
	// The number of the page to return. Pages start from page 1. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ListDataServiceGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceGroupsRequest) GoString() string {
	return s.String()
}

func (s *ListDataServiceGroupsRequest) SetGroupNameKeyword(v string) *ListDataServiceGroupsRequest {
	s.GroupNameKeyword = &v
	return s
}

func (s *ListDataServiceGroupsRequest) SetPageNumber(v int32) *ListDataServiceGroupsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDataServiceGroupsRequest) SetPageSize(v int32) *ListDataServiceGroupsRequest {
	s.PageSize = &v
	return s
}

func (s *ListDataServiceGroupsRequest) SetProjectId(v int64) *ListDataServiceGroupsRequest {
	s.ProjectId = &v
	return s
}

func (s *ListDataServiceGroupsRequest) SetTenantId(v int64) *ListDataServiceGroupsRequest {
	s.TenantId = &v
	return s
}

type ListDataServiceGroupsResponseBody struct {
	// The paging result for the business processes.
	GroupPagingResult *ListDataServiceGroupsResponseBodyGroupPagingResult `json:"GroupPagingResult,omitempty" xml:"GroupPagingResult,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListDataServiceGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataServiceGroupsResponseBody) SetGroupPagingResult(v *ListDataServiceGroupsResponseBodyGroupPagingResult) *ListDataServiceGroupsResponseBody {
	s.GroupPagingResult = v
	return s
}

func (s *ListDataServiceGroupsResponseBody) SetRequestId(v string) *ListDataServiceGroupsResponseBody {
	s.RequestId = &v
	return s
}

type ListDataServiceGroupsResponseBodyGroupPagingResult struct {
	// The business processes.
	Groups []*ListDataServiceGroupsResponseBodyGroupPagingResultGroups `json:"Groups,omitempty" xml:"Groups,omitempty" type:"Repeated"`
	// The page number of the returned page. The value of this parameter is the same as that of the PageNumber parameter in the request.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDataServiceGroupsResponseBodyGroupPagingResult) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceGroupsResponseBodyGroupPagingResult) GoString() string {
	return s.String()
}

func (s *ListDataServiceGroupsResponseBodyGroupPagingResult) SetGroups(v []*ListDataServiceGroupsResponseBodyGroupPagingResultGroups) *ListDataServiceGroupsResponseBodyGroupPagingResult {
	s.Groups = v
	return s
}

func (s *ListDataServiceGroupsResponseBodyGroupPagingResult) SetPageNumber(v int32) *ListDataServiceGroupsResponseBodyGroupPagingResult {
	s.PageNumber = &v
	return s
}

func (s *ListDataServiceGroupsResponseBodyGroupPagingResult) SetPageSize(v int32) *ListDataServiceGroupsResponseBodyGroupPagingResult {
	s.PageSize = &v
	return s
}

func (s *ListDataServiceGroupsResponseBodyGroupPagingResult) SetTotalCount(v int32) *ListDataServiceGroupsResponseBodyGroupPagingResult {
	s.TotalCount = &v
	return s
}

type ListDataServiceGroupsResponseBodyGroupPagingResultGroups struct {
	// The ID of the API group that is associated with the business process in the API Gateway console.
	ApiGatewayGroupId *string `json:"ApiGatewayGroupId,omitempty" xml:"ApiGatewayGroupId,omitempty"`
	// The time when the business process was created.
	CreatedTime *string `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The user identifier (UID) of the creator of the business process. The value of this parameter may be empty for creators of some existing business processes.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The description of the business process.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the business process.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the business process.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The time when the business process was modified.
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ListDataServiceGroupsResponseBodyGroupPagingResultGroups) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceGroupsResponseBodyGroupPagingResultGroups) GoString() string {
	return s.String()
}

func (s *ListDataServiceGroupsResponseBodyGroupPagingResultGroups) SetApiGatewayGroupId(v string) *ListDataServiceGroupsResponseBodyGroupPagingResultGroups {
	s.ApiGatewayGroupId = &v
	return s
}

func (s *ListDataServiceGroupsResponseBodyGroupPagingResultGroups) SetCreatedTime(v string) *ListDataServiceGroupsResponseBodyGroupPagingResultGroups {
	s.CreatedTime = &v
	return s
}

func (s *ListDataServiceGroupsResponseBodyGroupPagingResultGroups) SetCreatorId(v string) *ListDataServiceGroupsResponseBodyGroupPagingResultGroups {
	s.CreatorId = &v
	return s
}

func (s *ListDataServiceGroupsResponseBodyGroupPagingResultGroups) SetDescription(v string) *ListDataServiceGroupsResponseBodyGroupPagingResultGroups {
	s.Description = &v
	return s
}

func (s *ListDataServiceGroupsResponseBodyGroupPagingResultGroups) SetGroupId(v string) *ListDataServiceGroupsResponseBodyGroupPagingResultGroups {
	s.GroupId = &v
	return s
}

func (s *ListDataServiceGroupsResponseBodyGroupPagingResultGroups) SetGroupName(v string) *ListDataServiceGroupsResponseBodyGroupPagingResultGroups {
	s.GroupName = &v
	return s
}

func (s *ListDataServiceGroupsResponseBodyGroupPagingResultGroups) SetModifiedTime(v string) *ListDataServiceGroupsResponseBodyGroupPagingResultGroups {
	s.ModifiedTime = &v
	return s
}

func (s *ListDataServiceGroupsResponseBodyGroupPagingResultGroups) SetProjectId(v int64) *ListDataServiceGroupsResponseBodyGroupPagingResultGroups {
	s.ProjectId = &v
	return s
}

func (s *ListDataServiceGroupsResponseBodyGroupPagingResultGroups) SetTenantId(v int64) *ListDataServiceGroupsResponseBodyGroupPagingResultGroups {
	s.TenantId = &v
	return s
}

type ListDataServiceGroupsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDataServiceGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDataServiceGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataServiceGroupsResponse) GoString() string {
	return s.String()
}

func (s *ListDataServiceGroupsResponse) SetHeaders(v map[string]*string) *ListDataServiceGroupsResponse {
	s.Headers = v
	return s
}

func (s *ListDataServiceGroupsResponse) SetStatusCode(v int32) *ListDataServiceGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataServiceGroupsResponse) SetBody(v *ListDataServiceGroupsResponseBody) *ListDataServiceGroupsResponse {
	s.Body = v
	return s
}

type ListDataServicePublishedApisRequest struct {
	// The ID of the tenant.
	ApiNameKeyword *string `json:"ApiNameKeyword,omitempty" xml:"ApiNameKeyword,omitempty"`
	// The keyword in the name of the API. The keyword can be used to search for the API whose name contains the keyword.
	ApiPathKeyword *string `json:"ApiPathKeyword,omitempty" xml:"ApiPathKeyword,omitempty"`
	// The keyword in the path of the API. The keyword can be used to search for the API whose path contains the keyword.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The operation that you want to perform. Set the value to **ListDataServicePublishedApis**.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of the page to return. Pages start from page 1. Default value: 1.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of entries to return on each page. Default value: 10. A maximum of 100 entries can be returned on each page.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the workspace.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ListDataServicePublishedApisRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisRequest) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisRequest) SetApiNameKeyword(v string) *ListDataServicePublishedApisRequest {
	s.ApiNameKeyword = &v
	return s
}

func (s *ListDataServicePublishedApisRequest) SetApiPathKeyword(v string) *ListDataServicePublishedApisRequest {
	s.ApiPathKeyword = &v
	return s
}

func (s *ListDataServicePublishedApisRequest) SetCreatorId(v string) *ListDataServicePublishedApisRequest {
	s.CreatorId = &v
	return s
}

func (s *ListDataServicePublishedApisRequest) SetPageNumber(v int32) *ListDataServicePublishedApisRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDataServicePublishedApisRequest) SetPageSize(v int32) *ListDataServicePublishedApisRequest {
	s.PageSize = &v
	return s
}

func (s *ListDataServicePublishedApisRequest) SetProjectId(v int64) *ListDataServicePublishedApisRequest {
	s.ProjectId = &v
	return s
}

func (s *ListDataServicePublishedApisRequest) SetTenantId(v int64) *ListDataServicePublishedApisRequest {
	s.TenantId = &v
	return s
}

type ListDataServicePublishedApisResponseBody struct {
	// The error code.
	Data *ListDataServicePublishedApisResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// Indicates whether the request is successful.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The ID of the request.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the Alibaba Cloud account used by the creator of the API. The ID can be used to search for the API created by the creator.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The HTTP status code.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The error message.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDataServicePublishedApisResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBody) SetData(v *ListDataServicePublishedApisResponseBodyData) *ListDataServicePublishedApisResponseBody {
	s.Data = v
	return s
}

func (s *ListDataServicePublishedApisResponseBody) SetErrorCode(v string) *ListDataServicePublishedApisResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBody) SetErrorMessage(v string) *ListDataServicePublishedApisResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBody) SetHttpStatusCode(v int32) *ListDataServicePublishedApisResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBody) SetRequestId(v string) *ListDataServicePublishedApisResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBody) SetSuccess(v bool) *ListDataServicePublishedApisResponseBody {
	s.Success = &v
	return s
}

type ListDataServicePublishedApisResponseBodyData struct {
	// The total number of entries.
	Apis []*ListDataServicePublishedApisResponseBodyDataApis `json:"Apis,omitempty" xml:"Apis,omitempty" type:"Repeated"`
	// The APIs in the published state.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The page number of the returned page. The value of this parameter is the same as that of the PageNumber parameter in the request.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of entries returned per page. Default value: 10. A maximum of 100 entries can be returned on each page.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDataServicePublishedApisResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBodyData) SetApis(v []*ListDataServicePublishedApisResponseBodyDataApis) *ListDataServicePublishedApisResponseBodyData {
	s.Apis = v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyData) SetPageNumber(v int32) *ListDataServicePublishedApisResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyData) SetPageSize(v int32) *ListDataServicePublishedApisResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyData) SetTotalCount(v int32) *ListDataServicePublishedApisResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListDataServicePublishedApisResponseBodyDataApis struct {
	// The status of the API. Valid values: 0 and 1. A value of 0 indicates that the API is not published. A value of 1 indicates that the API is published.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The ID of the API.
	ApiMode *int32 `json:"ApiMode,omitempty" xml:"ApiMode,omitempty"`
	// The time when the API was created.
	ApiName *string `json:"ApiName,omitempty" xml:"ApiName,omitempty"`
	// The ID of the tenant.
	ApiPath *string `json:"ApiPath,omitempty" xml:"ApiPath,omitempty"`
	// The request method of the API. Valid values: 0, 1, 2, and 3. A value of 0 indicates the GET method. A value of 1 indicates the POST method. A value of 2 indicates the PUT method. A value of 3 indicates the DELETE method. APIs generated in wizard or script mode support the GET and POST methods. APIs generated by registration support the GET, POST, PUT, and DELETE methods.
	CreatedTime *string `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	// The format in which the response of the API request is returned. Valid values: 0 and 1. A value of 0 indicates the JSON format. A value of 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
	CreatorId *string `json:"CreatorId,omitempty" xml:"CreatorId,omitempty"`
	// The ID of the API group.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the Alibaba Cloud account used by the user who last modified the API.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The scope in which the API is visible. Valid values: 0 and 1. A value of 0 indicates that the API is visible within the workspace. A value of 1 indicates that the API is visible only to the API creator.
	ModifiedTime *string `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The time when the API was last modified.
	OperatorId *string `json:"OperatorId,omitempty" xml:"OperatorId,omitempty"`
	// The type of the API. Valid values: 0, 1, and 2. A value of 0 indicates that the API is generated in wizard mode. A value of 1 indicates that the API is generated in script mode. A value of 2 indicates that the API is generated by registration.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The path of the API.
	Protocols []*int32 `json:"Protocols,omitempty" xml:"Protocols,omitempty" type:"Repeated"`
	// The protocol used by the API. Valid values: 0 and 1. A value of 0 indicates that the API uses HTTP. A value of 1 indicates that the API uses HTTPS.
	RegistrationDetails *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails `json:"RegistrationDetails,omitempty" xml:"RegistrationDetails,omitempty" type:"Struct"`
	// The description of the API.
	RequestMethod *int32 `json:"RequestMethod,omitempty" xml:"RequestMethod,omitempty"`
	// The ID of the workspace.
	ResponseContentType *int32 `json:"ResponseContentType,omitempty" xml:"ResponseContentType,omitempty"`
	// The details of the API generated in script mode. This parameter is returned only if the API is generated in script mode.
	ScriptDetails *ListDataServicePublishedApisResponseBodyDataApisScriptDetails `json:"ScriptDetails,omitempty" xml:"ScriptDetails,omitempty" type:"Struct"`
	// The timeout period of the API request. Unit: milliseconds.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The name of the API.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	// The information about the APIs in the published state.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The ID of the Alibaba Cloud account used by the creator of the API.
	VisibleRange *int32 `json:"VisibleRange,omitempty" xml:"VisibleRange,omitempty"`
	// The details of the API generated in wizard mode. This parameter is returned only if the API is generated in wizard mode.
	WizardDetails *ListDataServicePublishedApisResponseBodyDataApisWizardDetails `json:"WizardDetails,omitempty" xml:"WizardDetails,omitempty" type:"Struct"`
}

func (s ListDataServicePublishedApisResponseBodyDataApis) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBodyDataApis) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetApiId(v int64) *ListDataServicePublishedApisResponseBodyDataApis {
	s.ApiId = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetApiMode(v int32) *ListDataServicePublishedApisResponseBodyDataApis {
	s.ApiMode = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetApiName(v string) *ListDataServicePublishedApisResponseBodyDataApis {
	s.ApiName = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetApiPath(v string) *ListDataServicePublishedApisResponseBodyDataApis {
	s.ApiPath = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetCreatedTime(v string) *ListDataServicePublishedApisResponseBodyDataApis {
	s.CreatedTime = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetCreatorId(v string) *ListDataServicePublishedApisResponseBodyDataApis {
	s.CreatorId = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetDescription(v string) *ListDataServicePublishedApisResponseBodyDataApis {
	s.Description = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetGroupId(v string) *ListDataServicePublishedApisResponseBodyDataApis {
	s.GroupId = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetModifiedTime(v string) *ListDataServicePublishedApisResponseBodyDataApis {
	s.ModifiedTime = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetOperatorId(v string) *ListDataServicePublishedApisResponseBodyDataApis {
	s.OperatorId = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetProjectId(v int64) *ListDataServicePublishedApisResponseBodyDataApis {
	s.ProjectId = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetProtocols(v []*int32) *ListDataServicePublishedApisResponseBodyDataApis {
	s.Protocols = v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetRegistrationDetails(v *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails) *ListDataServicePublishedApisResponseBodyDataApis {
	s.RegistrationDetails = v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetRequestMethod(v int32) *ListDataServicePublishedApisResponseBodyDataApis {
	s.RequestMethod = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetResponseContentType(v int32) *ListDataServicePublishedApisResponseBodyDataApis {
	s.ResponseContentType = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetScriptDetails(v *ListDataServicePublishedApisResponseBodyDataApisScriptDetails) *ListDataServicePublishedApisResponseBodyDataApis {
	s.ScriptDetails = v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetStatus(v int32) *ListDataServicePublishedApisResponseBodyDataApis {
	s.Status = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetTenantId(v int64) *ListDataServicePublishedApisResponseBodyDataApis {
	s.TenantId = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetTimeout(v int32) *ListDataServicePublishedApisResponseBodyDataApis {
	s.Timeout = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetVisibleRange(v int32) *ListDataServicePublishedApisResponseBodyDataApis {
	s.VisibleRange = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApis) SetWizardDetails(v *ListDataServicePublishedApisResponseBodyDataApisWizardDetails) *ListDataServicePublishedApisResponseBodyDataApis {
	s.WizardDetails = v
	return s
}

type ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails struct {
	// The sample success response of the API.
	FailedResultSample *string `json:"FailedResultSample,omitempty" xml:"FailedResultSample,omitempty"`
	// The body of the request initiated to call the backend service.
	RegistrationErrorCodes []*ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes `json:"RegistrationErrorCodes,omitempty" xml:"RegistrationErrorCodes,omitempty" type:"Repeated"`
	// The solution used to resolve the issue.
	RegistrationRequestParameters []*ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters `json:"RegistrationRequestParameters,omitempty" xml:"RegistrationRequestParameters,omitempty" type:"Repeated"`
	// The URL of the backend service.
	ServiceContentType *int32 `json:"ServiceContentType,omitempty" xml:"ServiceContentType,omitempty"`
	// The details of the API generated by registration. This parameter is returned only if the API is generated by registration.
	ServiceHost *string `json:"ServiceHost,omitempty" xml:"ServiceHost,omitempty"`
	// The format in which the response of the API request is returned. Valid values: 0 and 1. A value of 0 indicates the JSON format. A value of 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
	ServicePath *string `json:"ServicePath,omitempty" xml:"ServicePath,omitempty"`
	// The sample error response of the API.
	ServiceRequestBodyDescription *string `json:"ServiceRequestBodyDescription,omitempty" xml:"ServiceRequestBodyDescription,omitempty"`
	// The path of the backend service.
	SuccessfulResultSample *string `json:"SuccessfulResultSample,omitempty" xml:"SuccessfulResultSample,omitempty"`
}

func (s ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails) SetFailedResultSample(v string) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails {
	s.FailedResultSample = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails) SetRegistrationErrorCodes(v []*ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails {
	s.RegistrationErrorCodes = v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails) SetRegistrationRequestParameters(v []*ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails {
	s.RegistrationRequestParameters = v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails) SetServiceContentType(v int32) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails {
	s.ServiceContentType = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails) SetServiceHost(v string) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails {
	s.ServiceHost = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails) SetServicePath(v string) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails {
	s.ServicePath = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails) SetServiceRequestBodyDescription(v string) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails {
	s.ServiceRequestBodyDescription = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails) SetSuccessfulResultSample(v string) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetails {
	s.SuccessfulResultSample = &v
	return s
}

type ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes struct {
	// The error message.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error codes returned for the API generated by registration.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The error code.
	ErrorSolution *string `json:"ErrorSolution,omitempty" xml:"ErrorSolution,omitempty"`
}

func (s ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes) SetErrorCode(v string) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes {
	s.ErrorCode = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes) SetErrorMessage(v string) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes {
	s.ErrorMessage = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes) SetErrorSolution(v string) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationErrorCodes {
	s.ErrorSolution = &v
	return s
}

type ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters struct {
	// The description of the parameter.
	DefaultValue *string `json:"DefaultValue,omitempty" xml:"DefaultValue,omitempty"`
	// The operator used for the value of the parameter. Valid values:
	//
	// *   0: Equal
	// *   1: Like
	// *   2: Const
	// *   3: In
	//
	// APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// The data type of the parameter. Valid values:
	//
	// *   0: STRING
	// *   1: INT
	// *   2: LONG
	// *   3: FLOAT
	// *   4: DOUBLE
	// *   5: BOOLEAN
	IsRequiredParameter *bool `json:"IsRequiredParameter,omitempty" xml:"IsRequiredParameter,omitempty"`
	// The sample value of the parameter.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The position of the parameter. Valid values:
	//
	// *   0: Path
	// *   1: Query
	// *   2: Head
	// *   3: Body
	//
	// APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The request parameters of the API generated by registration.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The default value of the parameter.
	ParameterOperator *int32 `json:"ParameterOperator,omitempty" xml:"ParameterOperator,omitempty"`
	// The name of the parameter.
	ParameterPosition *int32 `json:"ParameterPosition,omitempty" xml:"ParameterPosition,omitempty"`
}

func (s ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetDefaultValue(v string) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.DefaultValue = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetExampleValue(v string) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.ExampleValue = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetIsRequiredParameter(v bool) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.IsRequiredParameter = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetParameterDataType(v int32) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.ParameterDataType = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetParameterDescription(v string) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.ParameterDescription = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetParameterName(v string) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.ParameterName = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetParameterOperator(v int32) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.ParameterOperator = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters) SetParameterPosition(v int32) *ListDataServicePublishedApisResponseBodyDataApisRegistrationDetailsRegistrationRequestParameters {
	s.ParameterPosition = &v
	return s
}

type ListDataServicePublishedApisResponseBodyDataApisScriptDetails struct {
	// The sample error response of the API.
	FailedResultSample *string `json:"FailedResultSample,omitempty" xml:"FailedResultSample,omitempty"`
	// Indicates whether the entries are returned by page.
	IsPagedResponse *bool `json:"IsPagedResponse,omitempty" xml:"IsPagedResponse,omitempty"`
	// The SQL script.
	Script *string `json:"Script,omitempty" xml:"Script,omitempty"`
	// The data source information of the API generated in script mode.
	ScriptConnection *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection `json:"ScriptConnection,omitempty" xml:"ScriptConnection,omitempty" type:"Struct"`
	// The error codes returned for the API generated in script mode.
	ScriptErrorCodes []*ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes `json:"ScriptErrorCodes,omitempty" xml:"ScriptErrorCodes,omitempty" type:"Repeated"`
	// The request parameters of the API generated in script mode.
	ScriptRequestParameters []*ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters `json:"ScriptRequestParameters,omitempty" xml:"ScriptRequestParameters,omitempty" type:"Repeated"`
	// The response parameters of the API generated in script mode.
	ScriptResponseParameters []*ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters `json:"ScriptResponseParameters,omitempty" xml:"ScriptResponseParameters,omitempty" type:"Repeated"`
	// The sample success response of the API.
	SuccessfulResultSample *string `json:"SuccessfulResultSample,omitempty" xml:"SuccessfulResultSample,omitempty"`
}

func (s ListDataServicePublishedApisResponseBodyDataApisScriptDetails) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBodyDataApisScriptDetails) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetails) SetFailedResultSample(v string) *ListDataServicePublishedApisResponseBodyDataApisScriptDetails {
	s.FailedResultSample = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetails) SetIsPagedResponse(v bool) *ListDataServicePublishedApisResponseBodyDataApisScriptDetails {
	s.IsPagedResponse = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetails) SetScript(v string) *ListDataServicePublishedApisResponseBodyDataApisScriptDetails {
	s.Script = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetails) SetScriptConnection(v *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection) *ListDataServicePublishedApisResponseBodyDataApisScriptDetails {
	s.ScriptConnection = v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetails) SetScriptErrorCodes(v []*ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes) *ListDataServicePublishedApisResponseBodyDataApisScriptDetails {
	s.ScriptErrorCodes = v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetails) SetScriptRequestParameters(v []*ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters) *ListDataServicePublishedApisResponseBodyDataApisScriptDetails {
	s.ScriptRequestParameters = v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetails) SetScriptResponseParameters(v []*ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters) *ListDataServicePublishedApisResponseBodyDataApisScriptDetails {
	s.ScriptResponseParameters = v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetails) SetSuccessfulResultSample(v string) *ListDataServicePublishedApisResponseBodyDataApisScriptDetails {
	s.SuccessfulResultSample = &v
	return s
}

type ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection struct {
	// The ID of the data source.
	ConnectionId *int64 `json:"ConnectionId,omitempty" xml:"ConnectionId,omitempty"`
	// The name of the table in the data source.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection) SetConnectionId(v int64) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection {
	s.ConnectionId = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection) SetTableName(v string) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptConnection {
	s.TableName = &v
	return s
}

type ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The solution used to resolve the issue.
	ErrorSolution *string `json:"ErrorSolution,omitempty" xml:"ErrorSolution,omitempty"`
}

func (s ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes) SetErrorCode(v string) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes {
	s.ErrorCode = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes) SetErrorMessage(v string) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes {
	s.ErrorMessage = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes) SetErrorSolution(v string) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptErrorCodes {
	s.ErrorSolution = &v
	return s
}

type ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters struct {
	// The default value of the parameter.
	DefaultValue *string `json:"DefaultValue,omitempty" xml:"DefaultValue,omitempty"`
	// The sample value of the parameter.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// Indicates whether the request parameter is required.
	IsRequiredParameter *bool `json:"IsRequiredParameter,omitempty" xml:"IsRequiredParameter,omitempty"`
	// The data type of the parameter. Valid values:
	//
	// - 0: STRING
	// - 1: INT
	// - 2: LONG
	// - 3: FLOAT
	// - 4: DOUBLE
	// - 5: BOOLEAN
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description of the parameter.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The operator used for the value of the parameter. Valid values:
	//
	// - 0: Equal
	// - 1: Like
	// - 2: Const
	// - 3: In
	//
	// APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
	ParameterOperator *int32 `json:"ParameterOperator,omitempty" xml:"ParameterOperator,omitempty"`
	// The position of the parameter. Valid values:
	//
	// - 0: Path
	// - 1: Query
	// - 2: Head
	// - 3: Body
	//
	// APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
	ParameterPosition *int32 `json:"ParameterPosition,omitempty" xml:"ParameterPosition,omitempty"`
}

func (s ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetDefaultValue(v string) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.DefaultValue = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetExampleValue(v string) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.ExampleValue = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetIsRequiredParameter(v bool) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.IsRequiredParameter = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetParameterDataType(v int32) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.ParameterDataType = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetParameterDescription(v string) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.ParameterDescription = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetParameterName(v string) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.ParameterName = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetParameterOperator(v int32) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.ParameterOperator = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters) SetParameterPosition(v int32) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptRequestParameters {
	s.ParameterPosition = &v
	return s
}

type ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters struct {
	// The sample value of the parameter.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// The data type of the parameter. Valid values:
	//
	// - 0: STRING
	// - 1: INT
	// - 2: LONG
	// - 3: FLOAT
	// - 4: DOUBLE
	// - 5: BOOLEAN
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description of the parameter.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
}

func (s ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters) SetExampleValue(v string) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters {
	s.ExampleValue = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters) SetParameterDataType(v int32) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters {
	s.ParameterDataType = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters) SetParameterDescription(v string) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters {
	s.ParameterDescription = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters) SetParameterName(v string) *ListDataServicePublishedApisResponseBodyDataApisScriptDetailsScriptResponseParameters {
	s.ParameterName = &v
	return s
}

type ListDataServicePublishedApisResponseBodyDataApisWizardDetails struct {
	// The sample error response of the API.
	FailedResultSample *string `json:"FailedResultSample,omitempty" xml:"FailedResultSample,omitempty"`
	// Indicates whether the entries are returned by page.
	IsPagedResponse *bool `json:"IsPagedResponse,omitempty" xml:"IsPagedResponse,omitempty"`
	// The sample success response of the API.
	SuccessfulResultSample *string `json:"SuccessfulResultSample,omitempty" xml:"SuccessfulResultSample,omitempty"`
	// The data source information of the API generated in wizard mode.
	WizardConnection *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection `json:"WizardConnection,omitempty" xml:"WizardConnection,omitempty" type:"Struct"`
	// The error codes returned for the API generated in wizard mode.
	WizardErrorCodes []*ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes `json:"WizardErrorCodes,omitempty" xml:"WizardErrorCodes,omitempty" type:"Repeated"`
	// The request parameters of the API generated in wizard mode.
	WizardRequestParameters []*ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters `json:"WizardRequestParameters,omitempty" xml:"WizardRequestParameters,omitempty" type:"Repeated"`
	// The response parameters of the API generated in wizard mode.
	WizardResponseParameters []*ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters `json:"WizardResponseParameters,omitempty" xml:"WizardResponseParameters,omitempty" type:"Repeated"`
}

func (s ListDataServicePublishedApisResponseBodyDataApisWizardDetails) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBodyDataApisWizardDetails) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetails) SetFailedResultSample(v string) *ListDataServicePublishedApisResponseBodyDataApisWizardDetails {
	s.FailedResultSample = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetails) SetIsPagedResponse(v bool) *ListDataServicePublishedApisResponseBodyDataApisWizardDetails {
	s.IsPagedResponse = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetails) SetSuccessfulResultSample(v string) *ListDataServicePublishedApisResponseBodyDataApisWizardDetails {
	s.SuccessfulResultSample = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetails) SetWizardConnection(v *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection) *ListDataServicePublishedApisResponseBodyDataApisWizardDetails {
	s.WizardConnection = v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetails) SetWizardErrorCodes(v []*ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes) *ListDataServicePublishedApisResponseBodyDataApisWizardDetails {
	s.WizardErrorCodes = v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetails) SetWizardRequestParameters(v []*ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters) *ListDataServicePublishedApisResponseBodyDataApisWizardDetails {
	s.WizardRequestParameters = v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetails) SetWizardResponseParameters(v []*ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters) *ListDataServicePublishedApisResponseBodyDataApisWizardDetails {
	s.WizardResponseParameters = v
	return s
}

type ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection struct {
	// The ID of the data source.
	ConnectionId *int64 `json:"ConnectionId,omitempty" xml:"ConnectionId,omitempty"`
	// The name of the table in the data source.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection) SetConnectionId(v int64) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection {
	s.ConnectionId = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection) SetTableName(v string) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardConnection {
	s.TableName = &v
	return s
}

type ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes struct {
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The solution used to resolve the issue.
	ErrorSolution *string `json:"ErrorSolution,omitempty" xml:"ErrorSolution,omitempty"`
}

func (s ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes) SetErrorCode(v string) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes {
	s.ErrorCode = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes) SetErrorMessage(v string) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes {
	s.ErrorMessage = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes) SetErrorSolution(v string) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardErrorCodes {
	s.ErrorSolution = &v
	return s
}

type ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters struct {
	// The default value of the parameter.
	DefaultValue *string `json:"DefaultValue,omitempty" xml:"DefaultValue,omitempty"`
	// The sample value of the parameter.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// Indicates whether the request parameter is required.
	IsRequiredParameter *bool `json:"IsRequiredParameter,omitempty" xml:"IsRequiredParameter,omitempty"`
	// The data type of the parameter. Valid values: 0, 1, 2, 3, 4, and 5. A value of 0 indicates the STRING data type. A value of 1 indicates the INT data type. A value of 2 indicates the LONG data type. A value of 3 indicates the FLOAT data type. A value of 4 indicates the DOUBLE data type. A value of 5 indicates the BOOLEAN data type.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description of the parameter.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
	// The operator used for the value of the parameter. Valid values: 0, 1, 2, and 3. A value of 0 indicates that the operator is Equal. A value of 1 indicates that the operator is Like. A value of 2 indicates that the operator is Const. A value of 3 indicates that the operator is In. APIs generated in wizard mode support the Equal, Like, and In operators. APIs generated in script mode support the Equal operator. APIs generated by registration support the Equal and Const operators.
	ParameterOperator *int32 `json:"ParameterOperator,omitempty" xml:"ParameterOperator,omitempty"`
	// The position of the parameter. Valid values: 0, 1, 2, and 3. A value of 0 indicates that the parameter is in the URL path of the request. A value of 1 indicates that the parameter is in the Query parameter of the request URL. A value of 2 indicates that the parameter is in the request header. A value of 3 indicates that the parameter is in the request body. APIs generated in wizard or script mode support only the Query position. APIs generated by registration whose request method is GET or DELETE support the Query and Head positions. APIs generated by registration whose request method is PUT or POST support the Query, Head, and Body positions.
	ParameterPosition *int32 `json:"ParameterPosition,omitempty" xml:"ParameterPosition,omitempty"`
}

func (s ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetDefaultValue(v string) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.DefaultValue = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetExampleValue(v string) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.ExampleValue = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetIsRequiredParameter(v bool) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.IsRequiredParameter = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetParameterDataType(v int32) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.ParameterDataType = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetParameterDescription(v string) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.ParameterDescription = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetParameterName(v string) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.ParameterName = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetParameterOperator(v int32) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.ParameterOperator = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters) SetParameterPosition(v int32) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardRequestParameters {
	s.ParameterPosition = &v
	return s
}

type ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters struct {
	// The sample value of the parameter.
	ExampleValue *string `json:"ExampleValue,omitempty" xml:"ExampleValue,omitempty"`
	// The data type of the parameter. Valid values: 0, 1, 2, 3, 4, and 5. A value of 0 indicates the STRING data type. A value of 1 indicates the INT data type. A value of 2 indicates the LONG data type. A value of 3 indicates the FLOAT data type. A value of 4 indicates the DOUBLE data type. A value of 5 indicates the BOOLEAN data type.
	ParameterDataType *int32 `json:"ParameterDataType,omitempty" xml:"ParameterDataType,omitempty"`
	// The description of the parameter.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The name of the parameter.
	ParameterName *string `json:"ParameterName,omitempty" xml:"ParameterName,omitempty"`
}

func (s ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters) SetExampleValue(v string) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters {
	s.ExampleValue = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters) SetParameterDataType(v int32) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters {
	s.ParameterDataType = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters) SetParameterDescription(v string) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters {
	s.ParameterDescription = &v
	return s
}

func (s *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters) SetParameterName(v string) *ListDataServicePublishedApisResponseBodyDataApisWizardDetailsWizardResponseParameters {
	s.ParameterName = &v
	return s
}

type ListDataServicePublishedApisResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDataServicePublishedApisResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDataServicePublishedApisResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataServicePublishedApisResponse) GoString() string {
	return s.String()
}

func (s *ListDataServicePublishedApisResponse) SetHeaders(v map[string]*string) *ListDataServicePublishedApisResponse {
	s.Headers = v
	return s
}

func (s *ListDataServicePublishedApisResponse) SetStatusCode(v int32) *ListDataServicePublishedApisResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataServicePublishedApisResponse) SetBody(v *ListDataServicePublishedApisResponseBody) *ListDataServicePublishedApisResponse {
	s.Body = v
	return s
}

type ListDataSourcesRequest struct {
	// The status of the data source. Valid values:
	//
	// *   ENABLED: The data source is accessible.
	// *   DISABLED: The data source is inaccessible.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The number of the page to return. The value of this parameter must be an integer greater than or equal to 1.
	EnvType *int32 `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The subtype of the data source. This parameter takes effect only if the DataSourceType parameter is set to rds.
	//
	// If the DataSourceType parameter is set to rds, this parameter can be set to mysql, sqlserver, or postgresql.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the request.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The HTTP status code returned.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of the data source. Valid values:
	//
	// *   odps
	// *   mysql
	// *   rds
	// *   oss
	// *   sqlserver
	// *   polardb
	// *   oracle
	// *   mongodb
	// *   emr
	// *   postgresql
	// *   analyticdb_for_mysql
	// *   hybriddb_for_postgresql
	// *   holo
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The environment in which the data source is used. Valid values: 0 and 1. The value 0 indicates the development environment. The value 1 indicates the production environment.
	SubType *string `json:"SubType,omitempty" xml:"SubType,omitempty"`
}

func (s ListDataSourcesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDataSourcesRequest) GoString() string {
	return s.String()
}

func (s *ListDataSourcesRequest) SetDataSourceType(v string) *ListDataSourcesRequest {
	s.DataSourceType = &v
	return s
}

func (s *ListDataSourcesRequest) SetEnvType(v int32) *ListDataSourcesRequest {
	s.EnvType = &v
	return s
}

func (s *ListDataSourcesRequest) SetName(v string) *ListDataSourcesRequest {
	s.Name = &v
	return s
}

func (s *ListDataSourcesRequest) SetPageNumber(v int32) *ListDataSourcesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDataSourcesRequest) SetPageSize(v int32) *ListDataSourcesRequest {
	s.PageSize = &v
	return s
}

func (s *ListDataSourcesRequest) SetProjectId(v int64) *ListDataSourcesRequest {
	s.ProjectId = &v
	return s
}

func (s *ListDataSourcesRequest) SetStatus(v string) *ListDataSourcesRequest {
	s.Status = &v
	return s
}

func (s *ListDataSourcesRequest) SetSubType(v string) *ListDataSourcesRequest {
	s.SubType = &v
	return s
}

type ListDataSourcesResponseBody struct {
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	Data *ListDataSourcesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// Indicates whether the request was successful.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The query result.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The page number of the returned page.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDataSourcesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataSourcesResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataSourcesResponseBody) SetData(v *ListDataSourcesResponseBodyData) *ListDataSourcesResponseBody {
	s.Data = v
	return s
}

func (s *ListDataSourcesResponseBody) SetHttpStatusCode(v int32) *ListDataSourcesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListDataSourcesResponseBody) SetRequestId(v string) *ListDataSourcesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDataSourcesResponseBody) SetSuccess(v bool) *ListDataSourcesResponseBody {
	s.Success = &v
	return s
}

type ListDataSourcesResponseBodyData struct {
	// The ID of the workspace to which the data source belongs.
	DataSources []*ListDataSourcesResponseBodyDataDataSources `json:"DataSources,omitempty" xml:"DataSources,omitempty" type:"Repeated"`
	// The total number of data sources.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The data sources.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The status of the data source. Valid values:
	//
	// *   1: The data source is accessible.
	// *   2: The data source is inaccessible.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDataSourcesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListDataSourcesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListDataSourcesResponseBodyData) SetDataSources(v []*ListDataSourcesResponseBodyDataDataSources) *ListDataSourcesResponseBodyData {
	s.DataSources = v
	return s
}

func (s *ListDataSourcesResponseBodyData) SetPageNumber(v int32) *ListDataSourcesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListDataSourcesResponseBodyData) SetPageSize(v int32) *ListDataSourcesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListDataSourcesResponseBodyData) SetTotalCount(v int32) *ListDataSourcesResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListDataSourcesResponseBodyDataDataSources struct {
	BindingCalcEngineId *int64 `json:"BindingCalcEngineId,omitempty" xml:"BindingCalcEngineId,omitempty"`
	// The description of the data source.
	ConnectStatus *int32 `json:"ConnectStatus,omitempty" xml:"ConnectStatus,omitempty"`
	// The ID of the compute engine instance with which the data source is associated.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// Indicates whether the compute engine instance that is associated with the data source is the default compute engine instance used by data sources of the same type.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The ID of the Alibaba Cloud account that is used to last modify the data source.
	DefaultEngine *bool `json:"DefaultEngine,omitempty" xml:"DefaultEngine,omitempty"`
	// The time when the data source was created. Example: Mar 17, 2021 4:09:32 PM.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The field that is used to sort data sources. Data sources are sorted in descending order based on the value of this parameter.
	EnvType *int32 `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// Indicates whether the data source is a shared data source.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The status of the data source. Valid values:
	//
	// *   1: The data source is accessible.
	// *   2: The data source is inaccessible.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the tenant.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the data source.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The data connection string. The value of this parameter is in the JSON format. Sample connection strings of common data sources:
	//
	// *   MaxCompute
	//
	// <!---->
	//
	//     json
	//     {
	//       "pubEndpoint": "http://service.cn.maxcompute.aliyun.com/api",
	//       "accessId": "xxxxxxx",
	//       "securityToken": null,
	//       "endpoint": "http://service.cn.maxcompute.aliyun-inc.com/api",
	//       "accessKey": "***",
	//       "name": "PRE_PROJECT_A_engine",
	//       "project": "PRE_PROJECT_A",
	//       "vpcEndpoint": "http://service.cn.maxcompute.aliyun-inc.com/api",
	//       "region": "cn-shanghai",
	//       "authType": "2"
	//     }
	//
	// *   mysql
	//
	// <!---->
	//
	//     json
	//     {
	//       "configType": "1",
	//       "database": "mysql_d111b",
	//       "instanceName": "rm-xxxxxx",
	//       "password": "***",
	//       "rdsOwnerId": "12133xxxxxx",
	//       "tag": "rds",
	//       "username": "mysql_db111"
	//     }
	//
	// *   sqlserver
	//
	// <!---->
	//
	//     json
	//     {
	//       "configType": "1",
	//       "jdbcUrl": "jdbc:sqlserver://rm-xxxxx.sqlserver.rds.aliyuncs.com:1433;DatabaseName=sqlserver_db1",
	//       "password": "***",
	//       "tag": "public",
	//       "username": "sqlserver_db111"
	//     }
	//
	// *   oss
	//
	// <!---->
	//
	//     json
	//     {
	//       "accessId": "LTAINbR9Uxxxx",
	//       "accessKey": "***",
	//       "bucket": "bigxxx1223",
	//       "configType": "1",
	//       "endpoint": "http://oss-cn-hangzhou.aliyuncs.com",
	//       "tag": "public"
	//     }
	//
	// *   postgresql
	//
	// <!---->
	//
	//     json
	//     {
	//       "configType": "1",
	//       "database": "cdp_xxx",
	//       "instanceName": "rm-xxxx",
	//       "password": "***",
	//       "rdsOwnerId": "121xxxxx",
	//       "tag": "rds",
	//       "username": "cdp_xxx"
	//     }
	//
	// *   ads
	//
	// <!---->
	//
	//     json
	//     {
	//       "configType": "1",
	//       "password": "***",
	//       "schema": "ads_demo",
	//       "tag": "public",
	//       "url": "ads-xxx-xxxx.cn-hangzhou-1.ads.aliyuncs.com:3029",
	//       "username": "lslslsls"
	//     }
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// The time when the data source was last modified. Example: Mar 17, 2021 4:09:32 PM.
	ProjectId *int32 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The type of the data source. Valid values:
	//
	// *   odps
	// *   mysql
	// *   rds
	// *   oss
	// *   sqlserver
	// *   polardb
	// *   oracle
	// *   mongodb
	// *   emr
	// *   postgresql
	// *   analyticdb_for_mysql
	// *   hybriddb_for_postgresql
	// *   holo
	Sequence *int32 `json:"Sequence,omitempty" xml:"Sequence,omitempty"`
	// The name of the data source.
	Shared *bool `json:"Shared,omitempty" xml:"Shared,omitempty"`
	// The subtype of the data source. This parameter takes effect only if the DataSourceType parameter is set to rds.
	//
	// If the DataSourceType parameter is set to rds, this parameter can be set to mysql, sqlserver, or postgresql.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The environment in which the data source is used. Valid values:
	//
	// *   0: development environment
	// *   1: production environment
	SubType  *string `json:"SubType,omitempty" xml:"SubType,omitempty"`
	TenantId *int64  `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ListDataSourcesResponseBodyDataDataSources) String() string {
	return tea.Prettify(s)
}

func (s ListDataSourcesResponseBodyDataDataSources) GoString() string {
	return s.String()
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetBindingCalcEngineId(v int64) *ListDataSourcesResponseBodyDataDataSources {
	s.BindingCalcEngineId = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetConnectStatus(v int32) *ListDataSourcesResponseBodyDataDataSources {
	s.ConnectStatus = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetContent(v string) *ListDataSourcesResponseBodyDataDataSources {
	s.Content = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetDataSourceType(v string) *ListDataSourcesResponseBodyDataDataSources {
	s.DataSourceType = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetDefaultEngine(v bool) *ListDataSourcesResponseBodyDataDataSources {
	s.DefaultEngine = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetDescription(v string) *ListDataSourcesResponseBodyDataDataSources {
	s.Description = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetEnvType(v int32) *ListDataSourcesResponseBodyDataDataSources {
	s.EnvType = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetGmtCreate(v string) *ListDataSourcesResponseBodyDataDataSources {
	s.GmtCreate = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetGmtModified(v string) *ListDataSourcesResponseBodyDataDataSources {
	s.GmtModified = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetId(v int64) *ListDataSourcesResponseBodyDataDataSources {
	s.Id = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetName(v string) *ListDataSourcesResponseBodyDataDataSources {
	s.Name = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetOperator(v string) *ListDataSourcesResponseBodyDataDataSources {
	s.Operator = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetProjectId(v int32) *ListDataSourcesResponseBodyDataDataSources {
	s.ProjectId = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetSequence(v int32) *ListDataSourcesResponseBodyDataDataSources {
	s.Sequence = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetShared(v bool) *ListDataSourcesResponseBodyDataDataSources {
	s.Shared = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetStatus(v int32) *ListDataSourcesResponseBodyDataDataSources {
	s.Status = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetSubType(v string) *ListDataSourcesResponseBodyDataDataSources {
	s.SubType = &v
	return s
}

func (s *ListDataSourcesResponseBodyDataDataSources) SetTenantId(v int64) *ListDataSourcesResponseBodyDataDataSources {
	s.TenantId = &v
	return s
}

type ListDataSourcesResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDataSourcesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDataSourcesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataSourcesResponse) GoString() string {
	return s.String()
}

func (s *ListDataSourcesResponse) SetHeaders(v map[string]*string) *ListDataSourcesResponse {
	s.Headers = v
	return s
}

func (s *ListDataSourcesResponse) SetStatusCode(v int32) *ListDataSourcesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataSourcesResponse) SetBody(v *ListDataSourcesResponseBody) *ListDataSourcesResponse {
	s.Body = v
	return s
}

type ListDeploymentsRequest struct {
	// The ID of the Alibaba Cloud account used by the user who created the deployment tasks.
	Creator *string `json:"Creator,omitempty" xml:"Creator,omitempty"`
	// The time when the deployment tasks to be queried were created. This value must be a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	EndCreateTime *int64 `json:"EndCreateTime,omitempty" xml:"EndCreateTime,omitempty"`
	// The time when the deployment tasks were run. This value must be a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	EndExecuteTime *int64 `json:"EndExecuteTime,omitempty" xml:"EndExecuteTime,omitempty"`
	// The ID of the Alibaba Cloud account used by the user who runs the deployment tasks.
	Executor *string `json:"Executor,omitempty" xml:"Executor,omitempty"`
	// The keyword that is contained in the names of the deployment tasks. The keyword is used to search for deployment tasks in fuzzy mode.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace ID.
	//
	// You must configure this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace name.
	//
	// You must configure this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
	// The status of the deployment tasks. Valid values:
	//
	// *   0: The deployment tasks are ready.
	// *   1: The deployment tasks are successful.
	// *   2: The deployment tasks fail.
	// *   6: The deployment tasks are rejected.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListDeploymentsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDeploymentsRequest) GoString() string {
	return s.String()
}

func (s *ListDeploymentsRequest) SetCreator(v string) *ListDeploymentsRequest {
	s.Creator = &v
	return s
}

func (s *ListDeploymentsRequest) SetEndCreateTime(v int64) *ListDeploymentsRequest {
	s.EndCreateTime = &v
	return s
}

func (s *ListDeploymentsRequest) SetEndExecuteTime(v int64) *ListDeploymentsRequest {
	s.EndExecuteTime = &v
	return s
}

func (s *ListDeploymentsRequest) SetExecutor(v string) *ListDeploymentsRequest {
	s.Executor = &v
	return s
}

func (s *ListDeploymentsRequest) SetKeyword(v string) *ListDeploymentsRequest {
	s.Keyword = &v
	return s
}

func (s *ListDeploymentsRequest) SetPageNumber(v int32) *ListDeploymentsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListDeploymentsRequest) SetPageSize(v int32) *ListDeploymentsRequest {
	s.PageSize = &v
	return s
}

func (s *ListDeploymentsRequest) SetProjectId(v int64) *ListDeploymentsRequest {
	s.ProjectId = &v
	return s
}

func (s *ListDeploymentsRequest) SetProjectIdentifier(v string) *ListDeploymentsRequest {
	s.ProjectIdentifier = &v
	return s
}

func (s *ListDeploymentsRequest) SetStatus(v int32) *ListDeploymentsRequest {
	s.Status = &v
	return s
}

type ListDeploymentsResponseBody struct {
	// The return results.
	Data *ListDeploymentsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListDeploymentsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDeploymentsResponseBody) GoString() string {
	return s.String()
}

func (s *ListDeploymentsResponseBody) SetData(v *ListDeploymentsResponseBodyData) *ListDeploymentsResponseBody {
	s.Data = v
	return s
}

func (s *ListDeploymentsResponseBody) SetRequestId(v string) *ListDeploymentsResponseBody {
	s.RequestId = &v
	return s
}

type ListDeploymentsResponseBodyData struct {
	// The information about the deployment tasks.
	Deployments []*ListDeploymentsResponseBodyDataDeployments `json:"Deployments,omitempty" xml:"Deployments,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListDeploymentsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListDeploymentsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListDeploymentsResponseBodyData) SetDeployments(v []*ListDeploymentsResponseBodyDataDeployments) *ListDeploymentsResponseBodyData {
	s.Deployments = v
	return s
}

func (s *ListDeploymentsResponseBodyData) SetPageNumber(v int64) *ListDeploymentsResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListDeploymentsResponseBodyData) SetPageSize(v int64) *ListDeploymentsResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListDeploymentsResponseBodyData) SetTotalCount(v int64) *ListDeploymentsResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListDeploymentsResponseBodyDataDeployments struct {
	// The time when the deployment task was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the Alibaba Cloud account used by the user who created the deployment tasks.
	Creator *string `json:"Creator,omitempty" xml:"Creator,omitempty"`
	// The error message returned when the deployment task failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The time when the deployment task was run. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	ExecuteTime *int64 `json:"ExecuteTime,omitempty" xml:"ExecuteTime,omitempty"`
	// The ID of the Alibaba Cloud account used by the user who ran the deployment tasks.
	Executor *string `json:"Executor,omitempty" xml:"Executor,omitempty"`
	// The ID of the deployment task. You can call the [GetDeployment](~~173950~~) operation to query the details of the deployment task based on the ID.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The name of the deployment task.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The status of the deployment tasks. Valid values:
	//
	// *   0: The deployment tasks are ready.
	// *   1: The deployment tasks are successful.
	// *   2: The deployment tasks fail.
	// *   6: The deployment tasks are rejected.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListDeploymentsResponseBodyDataDeployments) String() string {
	return tea.Prettify(s)
}

func (s ListDeploymentsResponseBodyDataDeployments) GoString() string {
	return s.String()
}

func (s *ListDeploymentsResponseBodyDataDeployments) SetCreateTime(v int64) *ListDeploymentsResponseBodyDataDeployments {
	s.CreateTime = &v
	return s
}

func (s *ListDeploymentsResponseBodyDataDeployments) SetCreator(v string) *ListDeploymentsResponseBodyDataDeployments {
	s.Creator = &v
	return s
}

func (s *ListDeploymentsResponseBodyDataDeployments) SetErrorMessage(v string) *ListDeploymentsResponseBodyDataDeployments {
	s.ErrorMessage = &v
	return s
}

func (s *ListDeploymentsResponseBodyDataDeployments) SetExecuteTime(v int64) *ListDeploymentsResponseBodyDataDeployments {
	s.ExecuteTime = &v
	return s
}

func (s *ListDeploymentsResponseBodyDataDeployments) SetExecutor(v string) *ListDeploymentsResponseBodyDataDeployments {
	s.Executor = &v
	return s
}

func (s *ListDeploymentsResponseBodyDataDeployments) SetId(v int64) *ListDeploymentsResponseBodyDataDeployments {
	s.Id = &v
	return s
}

func (s *ListDeploymentsResponseBodyDataDeployments) SetName(v string) *ListDeploymentsResponseBodyDataDeployments {
	s.Name = &v
	return s
}

func (s *ListDeploymentsResponseBodyDataDeployments) SetStatus(v int32) *ListDeploymentsResponseBodyDataDeployments {
	s.Status = &v
	return s
}

type ListDeploymentsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListDeploymentsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListDeploymentsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDeploymentsResponse) GoString() string {
	return s.String()
}

func (s *ListDeploymentsResponse) SetHeaders(v map[string]*string) *ListDeploymentsResponse {
	s.Headers = v
	return s
}

func (s *ListDeploymentsResponse) SetStatusCode(v int32) *ListDeploymentsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDeploymentsResponse) SetBody(v *ListDeploymentsResponseBody) *ListDeploymentsResponse {
	s.Body = v
	return s
}

type ListEnabledExtensionsForProjectRequest struct {
	// The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console?spm=a2c4g.11186623.0.0.6b4d4941azHd2k) and go to the Workspace Management page to obtain the workspace ID.
	EventCode *string `json:"EventCode,omitempty" xml:"EventCode,omitempty"`
	// The ID of the request.
	FileType *string `json:"FileType,omitempty" xml:"FileType,omitempty"`
	// The type of the code for the file.
	//
	// Valid values: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3).
	//
	// You can call the [ListFileType](~~212428~~) operation to query the type of the code for the file.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListEnabledExtensionsForProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEnabledExtensionsForProjectRequest) GoString() string {
	return s.String()
}

func (s *ListEnabledExtensionsForProjectRequest) SetEventCode(v string) *ListEnabledExtensionsForProjectRequest {
	s.EventCode = &v
	return s
}

func (s *ListEnabledExtensionsForProjectRequest) SetFileType(v string) *ListEnabledExtensionsForProjectRequest {
	s.FileType = &v
	return s
}

func (s *ListEnabledExtensionsForProjectRequest) SetProjectId(v int64) *ListEnabledExtensionsForProjectRequest {
	s.ProjectId = &v
	return s
}

type ListEnabledExtensionsForProjectResponseBody struct {
	// The unique code of the extension.
	Extensions []*ListEnabledExtensionsForProjectResponseBodyExtensions `json:"Extensions,omitempty" xml:"Extensions,omitempty" type:"Repeated"`
	// The details of the extension.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListEnabledExtensionsForProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEnabledExtensionsForProjectResponseBody) GoString() string {
	return s.String()
}

func (s *ListEnabledExtensionsForProjectResponseBody) SetExtensions(v []*ListEnabledExtensionsForProjectResponseBodyExtensions) *ListEnabledExtensionsForProjectResponseBody {
	s.Extensions = v
	return s
}

func (s *ListEnabledExtensionsForProjectResponseBody) SetRequestId(v string) *ListEnabledExtensionsForProjectResponseBody {
	s.RequestId = &v
	return s
}

type ListEnabledExtensionsForProjectResponseBodyExtensions struct {
	// The modifier of the extension.
	CreateUser *string `json:"CreateUser,omitempty" xml:"CreateUser,omitempty"`
	// The name of the extension.
	ExtensionCode *string `json:"ExtensionCode,omitempty" xml:"ExtensionCode,omitempty"`
	// The owner ID.
	ExtensionDesc *string `json:"ExtensionDesc,omitempty" xml:"ExtensionDesc,omitempty"`
	// The ID of the tenant.
	ExtensionName *string `json:"ExtensionName,omitempty" xml:"ExtensionName,omitempty"`
	// The description of the extension.
	ModifyUser *string `json:"ModifyUser,omitempty" xml:"ModifyUser,omitempty"`
	// The parameter settings of the extension. For more information, see [Configure extension parameters](~~405354~~).
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The time when the extension was created.
	ParameterSetting *string `json:"ParameterSetting,omitempty" xml:"ParameterSetting,omitempty"`
	// The creator of the extension.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s ListEnabledExtensionsForProjectResponseBodyExtensions) String() string {
	return tea.Prettify(s)
}

func (s ListEnabledExtensionsForProjectResponseBodyExtensions) GoString() string {
	return s.String()
}

func (s *ListEnabledExtensionsForProjectResponseBodyExtensions) SetCreateUser(v string) *ListEnabledExtensionsForProjectResponseBodyExtensions {
	s.CreateUser = &v
	return s
}

func (s *ListEnabledExtensionsForProjectResponseBodyExtensions) SetExtensionCode(v string) *ListEnabledExtensionsForProjectResponseBodyExtensions {
	s.ExtensionCode = &v
	return s
}

func (s *ListEnabledExtensionsForProjectResponseBodyExtensions) SetExtensionDesc(v string) *ListEnabledExtensionsForProjectResponseBodyExtensions {
	s.ExtensionDesc = &v
	return s
}

func (s *ListEnabledExtensionsForProjectResponseBodyExtensions) SetExtensionName(v string) *ListEnabledExtensionsForProjectResponseBodyExtensions {
	s.ExtensionName = &v
	return s
}

func (s *ListEnabledExtensionsForProjectResponseBodyExtensions) SetModifyUser(v string) *ListEnabledExtensionsForProjectResponseBodyExtensions {
	s.ModifyUser = &v
	return s
}

func (s *ListEnabledExtensionsForProjectResponseBodyExtensions) SetOwner(v string) *ListEnabledExtensionsForProjectResponseBodyExtensions {
	s.Owner = &v
	return s
}

func (s *ListEnabledExtensionsForProjectResponseBodyExtensions) SetParameterSetting(v string) *ListEnabledExtensionsForProjectResponseBodyExtensions {
	s.ParameterSetting = &v
	return s
}

func (s *ListEnabledExtensionsForProjectResponseBodyExtensions) SetTenantId(v int64) *ListEnabledExtensionsForProjectResponseBodyExtensions {
	s.TenantId = &v
	return s
}

type ListEnabledExtensionsForProjectResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListEnabledExtensionsForProjectResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListEnabledExtensionsForProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEnabledExtensionsForProjectResponse) GoString() string {
	return s.String()
}

func (s *ListEnabledExtensionsForProjectResponse) SetHeaders(v map[string]*string) *ListEnabledExtensionsForProjectResponse {
	s.Headers = v
	return s
}

func (s *ListEnabledExtensionsForProjectResponse) SetStatusCode(v int32) *ListEnabledExtensionsForProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEnabledExtensionsForProjectResponse) SetBody(v *ListEnabledExtensionsForProjectResponseBody) *ListEnabledExtensionsForProjectResponse {
	s.Body = v
	return s
}

type ListEntitiesByTagsRequest struct {
	EntityType *string          `json:"EntityType,omitempty" xml:"EntityType,omitempty"`
	NextToken  *string          `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	PageSize   *int32           `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Tags       []*UserEntityTag `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListEntitiesByTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEntitiesByTagsRequest) GoString() string {
	return s.String()
}

func (s *ListEntitiesByTagsRequest) SetEntityType(v string) *ListEntitiesByTagsRequest {
	s.EntityType = &v
	return s
}

func (s *ListEntitiesByTagsRequest) SetNextToken(v string) *ListEntitiesByTagsRequest {
	s.NextToken = &v
	return s
}

func (s *ListEntitiesByTagsRequest) SetPageSize(v int32) *ListEntitiesByTagsRequest {
	s.PageSize = &v
	return s
}

func (s *ListEntitiesByTagsRequest) SetTags(v []*UserEntityTag) *ListEntitiesByTagsRequest {
	s.Tags = v
	return s
}

type ListEntitiesByTagsShrinkRequest struct {
	EntityType *string `json:"EntityType,omitempty" xml:"EntityType,omitempty"`
	NextToken  *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	PageSize   *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	TagsShrink *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s ListEntitiesByTagsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEntitiesByTagsShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListEntitiesByTagsShrinkRequest) SetEntityType(v string) *ListEntitiesByTagsShrinkRequest {
	s.EntityType = &v
	return s
}

func (s *ListEntitiesByTagsShrinkRequest) SetNextToken(v string) *ListEntitiesByTagsShrinkRequest {
	s.NextToken = &v
	return s
}

func (s *ListEntitiesByTagsShrinkRequest) SetPageSize(v int32) *ListEntitiesByTagsShrinkRequest {
	s.PageSize = &v
	return s
}

func (s *ListEntitiesByTagsShrinkRequest) SetTagsShrink(v string) *ListEntitiesByTagsShrinkRequest {
	s.TagsShrink = &v
	return s
}

type ListEntitiesByTagsResponseBody struct {
	Data           *ListEntitiesByTagsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorCode      *string                             `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string                             `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32                              `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                               `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListEntitiesByTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEntitiesByTagsResponseBody) GoString() string {
	return s.String()
}

func (s *ListEntitiesByTagsResponseBody) SetData(v *ListEntitiesByTagsResponseBodyData) *ListEntitiesByTagsResponseBody {
	s.Data = v
	return s
}

func (s *ListEntitiesByTagsResponseBody) SetErrorCode(v string) *ListEntitiesByTagsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListEntitiesByTagsResponseBody) SetErrorMessage(v string) *ListEntitiesByTagsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListEntitiesByTagsResponseBody) SetHttpStatusCode(v int32) *ListEntitiesByTagsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListEntitiesByTagsResponseBody) SetRequestId(v string) *ListEntitiesByTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListEntitiesByTagsResponseBody) SetSuccess(v bool) *ListEntitiesByTagsResponseBody {
	s.Success = &v
	return s
}

type ListEntitiesByTagsResponseBodyData struct {
	EntityList []*Entity `json:"EntityList,omitempty" xml:"EntityList,omitempty" type:"Repeated"`
	NextToken  *string   `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s ListEntitiesByTagsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListEntitiesByTagsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListEntitiesByTagsResponseBodyData) SetEntityList(v []*Entity) *ListEntitiesByTagsResponseBodyData {
	s.EntityList = v
	return s
}

func (s *ListEntitiesByTagsResponseBodyData) SetNextToken(v string) *ListEntitiesByTagsResponseBodyData {
	s.NextToken = &v
	return s
}

type ListEntitiesByTagsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListEntitiesByTagsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListEntitiesByTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEntitiesByTagsResponse) GoString() string {
	return s.String()
}

func (s *ListEntitiesByTagsResponse) SetHeaders(v map[string]*string) *ListEntitiesByTagsResponse {
	s.Headers = v
	return s
}

func (s *ListEntitiesByTagsResponse) SetStatusCode(v int32) *ListEntitiesByTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEntitiesByTagsResponse) SetBody(v *ListEntitiesByTagsResponseBody) *ListEntitiesByTagsResponse {
	s.Body = v
	return s
}

type ListEntityTagsRequest struct {
	QualifiedName *string `json:"QualifiedName,omitempty" xml:"QualifiedName,omitempty"`
}

func (s ListEntityTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListEntityTagsRequest) GoString() string {
	return s.String()
}

func (s *ListEntityTagsRequest) SetQualifiedName(v string) *ListEntityTagsRequest {
	s.QualifiedName = &v
	return s
}

type ListEntityTagsResponseBody struct {
	Data           []*UserEntityTag `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	ErrorCode      *string          `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string          `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32           `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string          `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool            `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListEntityTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListEntityTagsResponseBody) GoString() string {
	return s.String()
}

func (s *ListEntityTagsResponseBody) SetData(v []*UserEntityTag) *ListEntityTagsResponseBody {
	s.Data = v
	return s
}

func (s *ListEntityTagsResponseBody) SetErrorCode(v string) *ListEntityTagsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListEntityTagsResponseBody) SetErrorMessage(v string) *ListEntityTagsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListEntityTagsResponseBody) SetHttpStatusCode(v int32) *ListEntityTagsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListEntityTagsResponseBody) SetRequestId(v string) *ListEntityTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListEntityTagsResponseBody) SetSuccess(v bool) *ListEntityTagsResponseBody {
	s.Success = &v
	return s
}

type ListEntityTagsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListEntityTagsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListEntityTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListEntityTagsResponse) GoString() string {
	return s.String()
}

func (s *ListEntityTagsResponse) SetHeaders(v map[string]*string) *ListEntityTagsResponse {
	s.Headers = v
	return s
}

func (s *ListEntityTagsResponse) SetStatusCode(v int32) *ListEntityTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListEntityTagsResponse) SetBody(v *ListEntityTagsResponseBody) *ListEntityTagsResponse {
	s.Body = v
	return s
}

type ListExtensionsRequest struct {
	// The number of entries to return on each page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// Id of the request
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListExtensionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListExtensionsRequest) GoString() string {
	return s.String()
}

func (s *ListExtensionsRequest) SetPageNumber(v int32) *ListExtensionsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListExtensionsRequest) SetPageSize(v int32) *ListExtensionsRequest {
	s.PageSize = &v
	return s
}

type ListExtensionsResponseBody struct {
	// The page number of the returned page.
	PagingInfo *ListExtensionsResponseBodyPagingInfo `json:"PagingInfo,omitempty" xml:"PagingInfo,omitempty" type:"Struct"`
	// The extensions returned on pages.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListExtensionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListExtensionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListExtensionsResponseBody) SetPagingInfo(v *ListExtensionsResponseBodyPagingInfo) *ListExtensionsResponseBody {
	s.PagingInfo = v
	return s
}

func (s *ListExtensionsResponseBody) SetRequestId(v string) *ListExtensionsResponseBody {
	s.RequestId = &v
	return s
}

type ListExtensionsResponseBodyPagingInfo struct {
	// The state of the extension. Valid values:
	//
	// 0: Testing
	//
	// 1: Publishing
	//
	// 3: Disabled
	//
	// 4: Processing
	//
	// 5: Approved
	//
	// 6: Approve Failed
	Extensions []*ListExtensionsResponseBodyPagingInfoExtensions `json:"Extensions,omitempty" xml:"Extensions,omitempty" type:"Repeated"`
	// The number of entries returned per page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The total number of entries returned.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The extensions.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListExtensionsResponseBodyPagingInfo) String() string {
	return tea.Prettify(s)
}

func (s ListExtensionsResponseBodyPagingInfo) GoString() string {
	return s.String()
}

func (s *ListExtensionsResponseBodyPagingInfo) SetExtensions(v []*ListExtensionsResponseBodyPagingInfoExtensions) *ListExtensionsResponseBodyPagingInfo {
	s.Extensions = v
	return s
}

func (s *ListExtensionsResponseBodyPagingInfo) SetPageNumber(v int32) *ListExtensionsResponseBodyPagingInfo {
	s.PageNumber = &v
	return s
}

func (s *ListExtensionsResponseBodyPagingInfo) SetPageSize(v int32) *ListExtensionsResponseBodyPagingInfo {
	s.PageSize = &v
	return s
}

func (s *ListExtensionsResponseBodyPagingInfo) SetTotalCount(v int32) *ListExtensionsResponseBodyPagingInfo {
	s.TotalCount = &v
	return s
}

type ListExtensionsResponseBodyPagingInfoExtensions struct {
	// The name of the event.
	BindEventList []*ListExtensionsResponseBodyPagingInfoExtensionsBindEventList `json:"BindEventList,omitempty" xml:"BindEventList,omitempty" type:"Repeated"`
	// The extension point events.
	ExtensionCode *string `json:"ExtensionCode,omitempty" xml:"ExtensionCode,omitempty"`
	// The name of the extension.
	ExtensionDesc *string `json:"ExtensionDesc,omitempty" xml:"ExtensionDesc,omitempty"`
	// The ID of the RAM user.
	ExtensionName *string `json:"ExtensionName,omitempty" xml:"ExtensionName,omitempty"`
	// The unique code of the extension.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The description of the extension.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListExtensionsResponseBodyPagingInfoExtensions) String() string {
	return tea.Prettify(s)
}

func (s ListExtensionsResponseBodyPagingInfoExtensions) GoString() string {
	return s.String()
}

func (s *ListExtensionsResponseBodyPagingInfoExtensions) SetBindEventList(v []*ListExtensionsResponseBodyPagingInfoExtensionsBindEventList) *ListExtensionsResponseBodyPagingInfoExtensions {
	s.BindEventList = v
	return s
}

func (s *ListExtensionsResponseBodyPagingInfoExtensions) SetExtensionCode(v string) *ListExtensionsResponseBodyPagingInfoExtensions {
	s.ExtensionCode = &v
	return s
}

func (s *ListExtensionsResponseBodyPagingInfoExtensions) SetExtensionDesc(v string) *ListExtensionsResponseBodyPagingInfoExtensions {
	s.ExtensionDesc = &v
	return s
}

func (s *ListExtensionsResponseBodyPagingInfoExtensions) SetExtensionName(v string) *ListExtensionsResponseBodyPagingInfoExtensions {
	s.ExtensionName = &v
	return s
}

func (s *ListExtensionsResponseBodyPagingInfoExtensions) SetOwner(v string) *ListExtensionsResponseBodyPagingInfoExtensions {
	s.Owner = &v
	return s
}

func (s *ListExtensionsResponseBodyPagingInfoExtensions) SetStatus(v int32) *ListExtensionsResponseBodyPagingInfoExtensions {
	s.Status = &v
	return s
}

type ListExtensionsResponseBodyPagingInfoExtensionsBindEventList struct {
	EventCode *string `json:"EventCode,omitempty" xml:"EventCode,omitempty"`
	// The code of the event.
	EventName *string `json:"EventName,omitempty" xml:"EventName,omitempty"`
}

func (s ListExtensionsResponseBodyPagingInfoExtensionsBindEventList) String() string {
	return tea.Prettify(s)
}

func (s ListExtensionsResponseBodyPagingInfoExtensionsBindEventList) GoString() string {
	return s.String()
}

func (s *ListExtensionsResponseBodyPagingInfoExtensionsBindEventList) SetEventCode(v string) *ListExtensionsResponseBodyPagingInfoExtensionsBindEventList {
	s.EventCode = &v
	return s
}

func (s *ListExtensionsResponseBodyPagingInfoExtensionsBindEventList) SetEventName(v string) *ListExtensionsResponseBodyPagingInfoExtensionsBindEventList {
	s.EventName = &v
	return s
}

type ListExtensionsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListExtensionsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListExtensionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListExtensionsResponse) GoString() string {
	return s.String()
}

func (s *ListExtensionsResponse) SetHeaders(v map[string]*string) *ListExtensionsResponse {
	s.Headers = v
	return s
}

func (s *ListExtensionsResponse) SetStatusCode(v int32) *ListExtensionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListExtensionsResponse) SetBody(v *ListExtensionsResponseBody) *ListExtensionsResponse {
	s.Body = v
	return s
}

type ListFileTypeRequest struct {
	// The name of the node type. You can log on to the DataWorks console, go to the DataStudio page, and then view the name of a specific node type on the left side of the page. Take note of the following items when you use this parameter:
	//
	// *   You can view the English or Chinese name of a specific node type, but the language specified by this parameter to present the name must be the same as the language specified by the Locale parameter.
	// *   Fuzzy match is supported.
	// *   If this parameter is not specified, the names of all node types are returned.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The language that you use for the query. Valid values: zh-CN and en-US.
	Locale *string `json:"Locale,omitempty" xml:"Locale,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace ID. You must configure either this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace name.
	//
	// You must configure either the ProjectId or ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s ListFileTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s ListFileTypeRequest) GoString() string {
	return s.String()
}

func (s *ListFileTypeRequest) SetKeyword(v string) *ListFileTypeRequest {
	s.Keyword = &v
	return s
}

func (s *ListFileTypeRequest) SetLocale(v string) *ListFileTypeRequest {
	s.Locale = &v
	return s
}

func (s *ListFileTypeRequest) SetPageNumber(v int32) *ListFileTypeRequest {
	s.PageNumber = &v
	return s
}

func (s *ListFileTypeRequest) SetPageSize(v int32) *ListFileTypeRequest {
	s.PageSize = &v
	return s
}

func (s *ListFileTypeRequest) SetProjectId(v int64) *ListFileTypeRequest {
	s.ProjectId = &v
	return s
}

func (s *ListFileTypeRequest) SetProjectIdentifier(v string) *ListFileTypeRequest {
	s.ProjectIdentifier = &v
	return s
}

type ListFileTypeResponseBody struct {
	// The information of the node types.
	NodeTypeInfoList *ListFileTypeResponseBodyNodeTypeInfoList `json:"NodeTypeInfoList,omitempty" xml:"NodeTypeInfoList,omitempty" type:"Struct"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListFileTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListFileTypeResponseBody) GoString() string {
	return s.String()
}

func (s *ListFileTypeResponseBody) SetNodeTypeInfoList(v *ListFileTypeResponseBodyNodeTypeInfoList) *ListFileTypeResponseBody {
	s.NodeTypeInfoList = v
	return s
}

func (s *ListFileTypeResponseBody) SetRequestId(v string) *ListFileTypeResponseBody {
	s.RequestId = &v
	return s
}

type ListFileTypeResponseBodyNodeTypeInfoList struct {
	// The information of the node type.
	NodeTypeInfo []*ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo `json:"NodeTypeInfo,omitempty" xml:"NodeTypeInfo,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListFileTypeResponseBodyNodeTypeInfoList) String() string {
	return tea.Prettify(s)
}

func (s ListFileTypeResponseBodyNodeTypeInfoList) GoString() string {
	return s.String()
}

func (s *ListFileTypeResponseBodyNodeTypeInfoList) SetNodeTypeInfo(v []*ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo) *ListFileTypeResponseBodyNodeTypeInfoList {
	s.NodeTypeInfo = v
	return s
}

func (s *ListFileTypeResponseBodyNodeTypeInfoList) SetPageNumber(v int32) *ListFileTypeResponseBodyNodeTypeInfoList {
	s.PageNumber = &v
	return s
}

func (s *ListFileTypeResponseBodyNodeTypeInfoList) SetPageSize(v int32) *ListFileTypeResponseBodyNodeTypeInfoList {
	s.PageSize = &v
	return s
}

func (s *ListFileTypeResponseBodyNodeTypeInfoList) SetTotalCount(v int32) *ListFileTypeResponseBodyNodeTypeInfoList {
	s.TotalCount = &v
	return s
}

type ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo struct {
	// The code of the node type.
	//
	// The codes and names of node types have the following mappings:
	//
	// 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3)
	NodeType *int32 `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The name of the node type.
	//
	// The codes and names of node types have the following mappings:
	//
	// 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3)
	NodeTypeName *string `json:"NodeTypeName,omitempty" xml:"NodeTypeName,omitempty"`
}

func (s ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo) String() string {
	return tea.Prettify(s)
}

func (s ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo) GoString() string {
	return s.String()
}

func (s *ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo) SetNodeType(v int32) *ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo {
	s.NodeType = &v
	return s
}

func (s *ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo) SetNodeTypeName(v string) *ListFileTypeResponseBodyNodeTypeInfoListNodeTypeInfo {
	s.NodeTypeName = &v
	return s
}

type ListFileTypeResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListFileTypeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListFileTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s ListFileTypeResponse) GoString() string {
	return s.String()
}

func (s *ListFileTypeResponse) SetHeaders(v map[string]*string) *ListFileTypeResponse {
	s.Headers = v
	return s
}

func (s *ListFileTypeResponse) SetStatusCode(v int32) *ListFileTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *ListFileTypeResponse) SetBody(v *ListFileTypeResponseBody) *ListFileTypeResponse {
	s.Body = v
	return s
}

type ListFileVersionsRequest struct {
	// The ID of the file. You can call the [ListFiles](~~173942~~) operation to query the ID.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value:10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the DataWorks workspace. You can click the Workspace Manage icon in the upper-right corner of the DataStudio page to go to the Workspace Management page and view the workspace ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The unique identifier of the DataWorks workspace. You can click the identifier in the upper-left corner of the DataStudio page to switch to another workspace.
	//
	// You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s ListFileVersionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListFileVersionsRequest) GoString() string {
	return s.String()
}

func (s *ListFileVersionsRequest) SetFileId(v int64) *ListFileVersionsRequest {
	s.FileId = &v
	return s
}

func (s *ListFileVersionsRequest) SetPageNumber(v int32) *ListFileVersionsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListFileVersionsRequest) SetPageSize(v int32) *ListFileVersionsRequest {
	s.PageSize = &v
	return s
}

func (s *ListFileVersionsRequest) SetProjectId(v int64) *ListFileVersionsRequest {
	s.ProjectId = &v
	return s
}

func (s *ListFileVersionsRequest) SetProjectIdentifier(v string) *ListFileVersionsRequest {
	s.ProjectIdentifier = &v
	return s
}

type ListFileVersionsResponseBody struct {
	// The file versions returned.
	Data *ListFileVersionsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListFileVersionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListFileVersionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListFileVersionsResponseBody) SetData(v *ListFileVersionsResponseBodyData) *ListFileVersionsResponseBody {
	s.Data = v
	return s
}

func (s *ListFileVersionsResponseBody) SetErrorCode(v string) *ListFileVersionsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListFileVersionsResponseBody) SetErrorMessage(v string) *ListFileVersionsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListFileVersionsResponseBody) SetHttpStatusCode(v int32) *ListFileVersionsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListFileVersionsResponseBody) SetRequestId(v string) *ListFileVersionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListFileVersionsResponseBody) SetSuccess(v bool) *ListFileVersionsResponseBody {
	s.Success = &v
	return s
}

type ListFileVersionsResponseBodyData struct {
	// The details of the file version.
	FileVersions []*ListFileVersionsResponseBodyDataFileVersions `json:"FileVersions,omitempty" xml:"FileVersions,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListFileVersionsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListFileVersionsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListFileVersionsResponseBodyData) SetFileVersions(v []*ListFileVersionsResponseBodyDataFileVersions) *ListFileVersionsResponseBodyData {
	s.FileVersions = v
	return s
}

func (s *ListFileVersionsResponseBodyData) SetPageNumber(v int32) *ListFileVersionsResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListFileVersionsResponseBodyData) SetPageSize(v int32) *ListFileVersionsResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListFileVersionsResponseBodyData) SetTotalCount(v int32) *ListFileVersionsResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListFileVersionsResponseBodyDataFileVersions struct {
	// The type of the change to the file of the current version. Valid values: CREATE, UPDATE, and DELETE.
	ChangeType *string `json:"ChangeType,omitempty" xml:"ChangeType,omitempty"`
	// The description of the file version.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The time when the file version was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CommitTime *int64 `json:"CommitTime,omitempty" xml:"CommitTime,omitempty"`
	// The ID of the Alibaba Cloud account used to create the file of the current version.
	CommitUser *string `json:"CommitUser,omitempty" xml:"CommitUser,omitempty"`
	// The code in the file of the current version.
	FileContent *string `json:"FileContent,omitempty" xml:"FileContent,omitempty"`
	// The name of the file of the current version.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The basic information about the file of the current version.
	FilePropertyContent *string `json:"FilePropertyContent,omitempty" xml:"FilePropertyContent,omitempty"`
	// The version of the file.
	FileVersion *int32 `json:"FileVersion,omitempty" xml:"FileVersion,omitempty"`
	// Indicates whether the file version is the same as the latest file version in the production environment.
	IsCurrentProd *bool `json:"IsCurrentProd,omitempty" xml:"IsCurrentProd,omitempty"`
	// The scheduling configurations for the node that corresponds to the file of the current version.
	NodeContent *string `json:"NodeContent,omitempty" xml:"NodeContent,omitempty"`
	// The ID of the auto triggered node that corresponds to the file of the current version.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The status of the file of the current version. Valid values: COMMITTING, COMMITTED, CHECK_OK, PACKAGED, DEPLOYING, DEPLOYED, and CANCELLED.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The functional module to which the file belongs. Valid values: NORMAL, MANUAL, MANUAL_BIZ, SKIP, ADHOCQUERY, and COMPONENT. The value SKIP indicates that the node corresponding to the file is run in dry-run mode.
	UseType *string `json:"UseType,omitempty" xml:"UseType,omitempty"`
}

func (s ListFileVersionsResponseBodyDataFileVersions) String() string {
	return tea.Prettify(s)
}

func (s ListFileVersionsResponseBodyDataFileVersions) GoString() string {
	return s.String()
}

func (s *ListFileVersionsResponseBodyDataFileVersions) SetChangeType(v string) *ListFileVersionsResponseBodyDataFileVersions {
	s.ChangeType = &v
	return s
}

func (s *ListFileVersionsResponseBodyDataFileVersions) SetComment(v string) *ListFileVersionsResponseBodyDataFileVersions {
	s.Comment = &v
	return s
}

func (s *ListFileVersionsResponseBodyDataFileVersions) SetCommitTime(v int64) *ListFileVersionsResponseBodyDataFileVersions {
	s.CommitTime = &v
	return s
}

func (s *ListFileVersionsResponseBodyDataFileVersions) SetCommitUser(v string) *ListFileVersionsResponseBodyDataFileVersions {
	s.CommitUser = &v
	return s
}

func (s *ListFileVersionsResponseBodyDataFileVersions) SetFileContent(v string) *ListFileVersionsResponseBodyDataFileVersions {
	s.FileContent = &v
	return s
}

func (s *ListFileVersionsResponseBodyDataFileVersions) SetFileName(v string) *ListFileVersionsResponseBodyDataFileVersions {
	s.FileName = &v
	return s
}

func (s *ListFileVersionsResponseBodyDataFileVersions) SetFilePropertyContent(v string) *ListFileVersionsResponseBodyDataFileVersions {
	s.FilePropertyContent = &v
	return s
}

func (s *ListFileVersionsResponseBodyDataFileVersions) SetFileVersion(v int32) *ListFileVersionsResponseBodyDataFileVersions {
	s.FileVersion = &v
	return s
}

func (s *ListFileVersionsResponseBodyDataFileVersions) SetIsCurrentProd(v bool) *ListFileVersionsResponseBodyDataFileVersions {
	s.IsCurrentProd = &v
	return s
}

func (s *ListFileVersionsResponseBodyDataFileVersions) SetNodeContent(v string) *ListFileVersionsResponseBodyDataFileVersions {
	s.NodeContent = &v
	return s
}

func (s *ListFileVersionsResponseBodyDataFileVersions) SetNodeId(v int64) *ListFileVersionsResponseBodyDataFileVersions {
	s.NodeId = &v
	return s
}

func (s *ListFileVersionsResponseBodyDataFileVersions) SetStatus(v string) *ListFileVersionsResponseBodyDataFileVersions {
	s.Status = &v
	return s
}

func (s *ListFileVersionsResponseBodyDataFileVersions) SetUseType(v string) *ListFileVersionsResponseBodyDataFileVersions {
	s.UseType = &v
	return s
}

type ListFileVersionsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListFileVersionsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListFileVersionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListFileVersionsResponse) GoString() string {
	return s.String()
}

func (s *ListFileVersionsResponse) SetHeaders(v map[string]*string) *ListFileVersionsResponse {
	s.Headers = v
	return s
}

func (s *ListFileVersionsResponse) SetStatusCode(v int32) *ListFileVersionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListFileVersionsResponse) SetBody(v *ListFileVersionsResponseBody) *ListFileVersionsResponse {
	s.Body = v
	return s
}

type ListFilesRequest struct {
	ExactFileName *string `json:"ExactFileName,omitempty" xml:"ExactFileName,omitempty"`
	// The path of the files.
	FileFolderPath *string `json:"FileFolderPath,omitempty" xml:"FileFolderPath,omitempty"`
	FileIdIn       *string `json:"FileIdIn,omitempty" xml:"FileIdIn,omitempty"`
	// The types of the code in the files.
	//
	// Valid values: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 97 (PAI), 98 (node group), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1002 (PAI inner node), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), 1106 (for-each), and 1221 (PyODPS 3).
	FileTypes *string `json:"FileTypes,omitempty" xml:"FileTypes,omitempty"`
	// The keyword in the file names. The keyword is used to perform a fuzzy match. You can specify a keyword to query all files whose names contain the keyword.
	Keyword                *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	NeedAbsoluteFolderPath *bool   `json:"NeedAbsoluteFolderPath,omitempty" xml:"NeedAbsoluteFolderPath,omitempty"`
	NeedContent            *bool   `json:"NeedContent,omitempty" xml:"NeedContent,omitempty"`
	// The ID of the node that is scheduled. You can call the [ListNodes](~~173979~~) operation to query the ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The owner of the files.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace ID.
	//
	// You must configure either the ProjectId or ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace name.
	//
	// You must configure either the ProjectId or ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
	// The module to which the files belong. Valid values:
	//
	// *   NORMAL: The files are used for DataStudio.
	// *   MANUAL: The files are used for manually triggered nodes.
	// *   MANUAL_BIZ: The files are used for manually triggered workflows.
	// *   SKIP: The files are used for dry-run nodes in DataStudio.
	// *   ADHOCQUERY: The files are used for ad hoc queries.
	// *   COMPONENT: The files are used for snippets.
	UseType *string `json:"UseType,omitempty" xml:"UseType,omitempty"`
}

func (s ListFilesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListFilesRequest) GoString() string {
	return s.String()
}

func (s *ListFilesRequest) SetExactFileName(v string) *ListFilesRequest {
	s.ExactFileName = &v
	return s
}

func (s *ListFilesRequest) SetFileFolderPath(v string) *ListFilesRequest {
	s.FileFolderPath = &v
	return s
}

func (s *ListFilesRequest) SetFileIdIn(v string) *ListFilesRequest {
	s.FileIdIn = &v
	return s
}

func (s *ListFilesRequest) SetFileTypes(v string) *ListFilesRequest {
	s.FileTypes = &v
	return s
}

func (s *ListFilesRequest) SetKeyword(v string) *ListFilesRequest {
	s.Keyword = &v
	return s
}

func (s *ListFilesRequest) SetNeedAbsoluteFolderPath(v bool) *ListFilesRequest {
	s.NeedAbsoluteFolderPath = &v
	return s
}

func (s *ListFilesRequest) SetNeedContent(v bool) *ListFilesRequest {
	s.NeedContent = &v
	return s
}

func (s *ListFilesRequest) SetNodeId(v int64) *ListFilesRequest {
	s.NodeId = &v
	return s
}

func (s *ListFilesRequest) SetOwner(v string) *ListFilesRequest {
	s.Owner = &v
	return s
}

func (s *ListFilesRequest) SetPageNumber(v int32) *ListFilesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListFilesRequest) SetPageSize(v int32) *ListFilesRequest {
	s.PageSize = &v
	return s
}

func (s *ListFilesRequest) SetProjectId(v int64) *ListFilesRequest {
	s.ProjectId = &v
	return s
}

func (s *ListFilesRequest) SetProjectIdentifier(v string) *ListFilesRequest {
	s.ProjectIdentifier = &v
	return s
}

func (s *ListFilesRequest) SetUseType(v string) *ListFilesRequest {
	s.UseType = &v
	return s
}

type ListFilesResponseBody struct {
	// The files returned.
	Data *ListFilesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can troubleshoot errors based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListFilesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListFilesResponseBody) GoString() string {
	return s.String()
}

func (s *ListFilesResponseBody) SetData(v *ListFilesResponseBodyData) *ListFilesResponseBody {
	s.Data = v
	return s
}

func (s *ListFilesResponseBody) SetErrorCode(v string) *ListFilesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListFilesResponseBody) SetErrorMessage(v string) *ListFilesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListFilesResponseBody) SetHttpStatusCode(v int32) *ListFilesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListFilesResponseBody) SetRequestId(v string) *ListFilesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListFilesResponseBody) SetSuccess(v bool) *ListFilesResponseBody {
	s.Success = &v
	return s
}

type ListFilesResponseBodyData struct {
	// The details of the files.
	Files []*ListFilesResponseBodyDataFiles `json:"Files,omitempty" xml:"Files,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListFilesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListFilesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListFilesResponseBodyData) SetFiles(v []*ListFilesResponseBodyDataFiles) *ListFilesResponseBodyData {
	s.Files = v
	return s
}

func (s *ListFilesResponseBodyData) SetPageNumber(v int32) *ListFilesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListFilesResponseBodyData) SetPageSize(v int32) *ListFilesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListFilesResponseBodyData) SetTotalCount(v int32) *ListFilesResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListFilesResponseBodyDataFiles struct {
	AbsoluteFolderPath *string `json:"AbsoluteFolderPath,omitempty" xml:"AbsoluteFolderPath,omitempty"`
	// Specifies whether the automatic parsing feature is enabled for the file. Valid values:
	//
	// *   true: The automatic parsing feature is enabled for the file.
	// *   false: The automatic parsing feature is not enabled for the file.
	//
	// This parameter is equivalent to the Analyze Code parameter in the Dependencies section of the Properties panel in the [DataWorks console](https://workbench.data.aliyun.com/console).
	AutoParsing *bool `json:"AutoParsing,omitempty" xml:"AutoParsing,omitempty"`
	// The ID of the workflow to which the file belongs. This parameter is deprecated and replaced by the BusinessId parameter.
	BizId *int64 `json:"BizId,omitempty" xml:"BizId,omitempty"`
	// The ID of the workflow to which the file belongs.
	BusinessId *int64 `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	// Indicates whether the latest code in the file is committed. Valid values: 0 and 1. The value 0 indicates that the latest code in the file is not committed. The value 1 indicates that the latest code in the file is committed.
	CommitStatus *int32 `json:"CommitStatus,omitempty" xml:"CommitStatus,omitempty"`
	// The ID of the compute engine instance that is used to run the node that corresponds to the file.
	ConnectionName *string `json:"ConnectionName,omitempty" xml:"ConnectionName,omitempty"`
	// This parameter is deprecated. You can call the [GetFile](~~173954#doc-api-dataworks-public-GetFile~~) operation to query the details of the file.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The time when the file was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the Alibaba Cloud account that is used to create the file.
	CreateUser *string `json:"CreateUser,omitempty" xml:"CreateUser,omitempty"`
	// The latest version number of the file.
	CurrentVersion *int32 `json:"CurrentVersion,omitempty" xml:"CurrentVersion,omitempty"`
	// The description of the file.
	FileDescription *string `json:"FileDescription,omitempty" xml:"FileDescription,omitempty"`
	// The ID of the folder to which the file belongs.
	FileFolderId *string `json:"FileFolderId,omitempty" xml:"FileFolderId,omitempty"`
	// The ID of the file.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The name of the file.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The type of the code in the file. Valid values: 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3).
	FileType *int32 `json:"FileType,omitempty" xml:"FileType,omitempty"`
	// Indicates whether the file needs to be uploaded to MaxCompute if the file is a MaxCompute resource file.
	//
	// This parameter is returned only if the file is a MaxCompute resource file.
	IsMaxCompute *bool `json:"IsMaxCompute,omitempty" xml:"IsMaxCompute,omitempty"`
	// The time when the file was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	LastEditTime *int64 `json:"LastEditTime,omitempty" xml:"LastEditTime,omitempty"`
	// The ID of the Alibaba Cloud account that is used to last modify the file.
	LastEditUser *string `json:"LastEditUser,omitempty" xml:"LastEditUser,omitempty"`
	// The ID of the auto triggered node that is generated in the scheduling system after the file is committed.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the Alibaba Cloud account used by the file owner.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ID of the node group file to which the current file belongs. This parameter is returned only if the current file is an inner file of the node group file.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The module to which the file belongs. Valid values:
	//
	// *   NORMAL: The file is used for DataStudio.
	// *   MANUAL: The file is used for a manually triggered node.
	// *   MANUAL_BIZ: The file is used for a manually triggered workflow.
	// *   SKIP: The files is used for a dry-run node in DataStudio.
	// *   ADHOCQUERY: The file is used for an ad hoc query.
	// *   COMPONENT: The file is used for a snippet.
	UseType *string `json:"UseType,omitempty" xml:"UseType,omitempty"`
}

func (s ListFilesResponseBodyDataFiles) String() string {
	return tea.Prettify(s)
}

func (s ListFilesResponseBodyDataFiles) GoString() string {
	return s.String()
}

func (s *ListFilesResponseBodyDataFiles) SetAbsoluteFolderPath(v string) *ListFilesResponseBodyDataFiles {
	s.AbsoluteFolderPath = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetAutoParsing(v bool) *ListFilesResponseBodyDataFiles {
	s.AutoParsing = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetBizId(v int64) *ListFilesResponseBodyDataFiles {
	s.BizId = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetBusinessId(v int64) *ListFilesResponseBodyDataFiles {
	s.BusinessId = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetCommitStatus(v int32) *ListFilesResponseBodyDataFiles {
	s.CommitStatus = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetConnectionName(v string) *ListFilesResponseBodyDataFiles {
	s.ConnectionName = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetContent(v string) *ListFilesResponseBodyDataFiles {
	s.Content = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetCreateTime(v int64) *ListFilesResponseBodyDataFiles {
	s.CreateTime = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetCreateUser(v string) *ListFilesResponseBodyDataFiles {
	s.CreateUser = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetCurrentVersion(v int32) *ListFilesResponseBodyDataFiles {
	s.CurrentVersion = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetFileDescription(v string) *ListFilesResponseBodyDataFiles {
	s.FileDescription = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetFileFolderId(v string) *ListFilesResponseBodyDataFiles {
	s.FileFolderId = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetFileId(v int64) *ListFilesResponseBodyDataFiles {
	s.FileId = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetFileName(v string) *ListFilesResponseBodyDataFiles {
	s.FileName = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetFileType(v int32) *ListFilesResponseBodyDataFiles {
	s.FileType = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetIsMaxCompute(v bool) *ListFilesResponseBodyDataFiles {
	s.IsMaxCompute = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetLastEditTime(v int64) *ListFilesResponseBodyDataFiles {
	s.LastEditTime = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetLastEditUser(v string) *ListFilesResponseBodyDataFiles {
	s.LastEditUser = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetNodeId(v int64) *ListFilesResponseBodyDataFiles {
	s.NodeId = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetOwner(v string) *ListFilesResponseBodyDataFiles {
	s.Owner = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetParentId(v int64) *ListFilesResponseBodyDataFiles {
	s.ParentId = &v
	return s
}

func (s *ListFilesResponseBodyDataFiles) SetUseType(v string) *ListFilesResponseBodyDataFiles {
	s.UseType = &v
	return s
}

type ListFilesResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListFilesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListFilesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListFilesResponse) GoString() string {
	return s.String()
}

func (s *ListFilesResponse) SetHeaders(v map[string]*string) *ListFilesResponse {
	s.Headers = v
	return s
}

func (s *ListFilesResponse) SetStatusCode(v int32) *ListFilesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListFilesResponse) SetBody(v *ListFilesResponseBody) *ListFilesResponse {
	s.Body = v
	return s
}

type ListFoldersRequest struct {
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The path of the parent folder.
	ParentFolderPath *string `json:"ParentFolderPath,omitempty" xml:"ParentFolderPath,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID. You must specify either this parameter or ProjectIdentifier to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Settings panel to obtain the name. You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s ListFoldersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListFoldersRequest) GoString() string {
	return s.String()
}

func (s *ListFoldersRequest) SetPageNumber(v int32) *ListFoldersRequest {
	s.PageNumber = &v
	return s
}

func (s *ListFoldersRequest) SetPageSize(v int32) *ListFoldersRequest {
	s.PageSize = &v
	return s
}

func (s *ListFoldersRequest) SetParentFolderPath(v string) *ListFoldersRequest {
	s.ParentFolderPath = &v
	return s
}

func (s *ListFoldersRequest) SetProjectId(v int64) *ListFoldersRequest {
	s.ProjectId = &v
	return s
}

func (s *ListFoldersRequest) SetProjectIdentifier(v string) *ListFoldersRequest {
	s.ProjectIdentifier = &v
	return s
}

type ListFoldersResponseBody struct {
	// The folders returned.
	Data *ListFoldersResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListFoldersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListFoldersResponseBody) GoString() string {
	return s.String()
}

func (s *ListFoldersResponseBody) SetData(v *ListFoldersResponseBodyData) *ListFoldersResponseBody {
	s.Data = v
	return s
}

func (s *ListFoldersResponseBody) SetErrorCode(v string) *ListFoldersResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListFoldersResponseBody) SetErrorMessage(v string) *ListFoldersResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListFoldersResponseBody) SetHttpStatusCode(v int32) *ListFoldersResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListFoldersResponseBody) SetRequestId(v string) *ListFoldersResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListFoldersResponseBody) SetSuccess(v bool) *ListFoldersResponseBody {
	s.Success = &v
	return s
}

type ListFoldersResponseBodyData struct {
	// The details of the folder.
	Folders []*ListFoldersResponseBodyDataFolders `json:"Folders,omitempty" xml:"Folders,omitempty" type:"Repeated"`
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries on the returned page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListFoldersResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListFoldersResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListFoldersResponseBodyData) SetFolders(v []*ListFoldersResponseBodyDataFolders) *ListFoldersResponseBodyData {
	s.Folders = v
	return s
}

func (s *ListFoldersResponseBodyData) SetPageNumber(v int32) *ListFoldersResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListFoldersResponseBodyData) SetPageSize(v int32) *ListFoldersResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListFoldersResponseBodyData) SetTotalCount(v int32) *ListFoldersResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListFoldersResponseBodyDataFolders struct {
	// The ID of the folder.
	FolderId *string `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The path of the folder.
	FolderPath *string `json:"FolderPath,omitempty" xml:"FolderPath,omitempty"`
}

func (s ListFoldersResponseBodyDataFolders) String() string {
	return tea.Prettify(s)
}

func (s ListFoldersResponseBodyDataFolders) GoString() string {
	return s.String()
}

func (s *ListFoldersResponseBodyDataFolders) SetFolderId(v string) *ListFoldersResponseBodyDataFolders {
	s.FolderId = &v
	return s
}

func (s *ListFoldersResponseBodyDataFolders) SetFolderPath(v string) *ListFoldersResponseBodyDataFolders {
	s.FolderPath = &v
	return s
}

type ListFoldersResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListFoldersResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListFoldersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListFoldersResponse) GoString() string {
	return s.String()
}

func (s *ListFoldersResponse) SetHeaders(v map[string]*string) *ListFoldersResponse {
	s.Headers = v
	return s
}

func (s *ListFoldersResponse) SetStatusCode(v int32) *ListFoldersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListFoldersResponse) SetBody(v *ListFoldersResponseBody) *ListFoldersResponse {
	s.Body = v
	return s
}

type ListInnerNodesRequest struct {
	// The ID of the node group to which the inner nodes belong.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	OuterNodeId *int64 `json:"OuterNodeId,omitempty" xml:"OuterNodeId,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the workspace.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of the page to return. Minimum value: 1. Maximum value: 100.
	ProgramType *string `json:"ProgramType,omitempty" xml:"ProgramType,omitempty"`
	// The name of the node to which the inner nodes belong.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
	// The environment in which the node is run. Valid values: DEV and PROD. Default value: PROD.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListInnerNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListInnerNodesRequest) GoString() string {
	return s.String()
}

func (s *ListInnerNodesRequest) SetNodeName(v string) *ListInnerNodesRequest {
	s.NodeName = &v
	return s
}

func (s *ListInnerNodesRequest) SetOuterNodeId(v int64) *ListInnerNodesRequest {
	s.OuterNodeId = &v
	return s
}

func (s *ListInnerNodesRequest) SetPageNumber(v int32) *ListInnerNodesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListInnerNodesRequest) SetPageSize(v int32) *ListInnerNodesRequest {
	s.PageSize = &v
	return s
}

func (s *ListInnerNodesRequest) SetProgramType(v string) *ListInnerNodesRequest {
	s.ProgramType = &v
	return s
}

func (s *ListInnerNodesRequest) SetProjectEnv(v string) *ListInnerNodesRequest {
	s.ProjectEnv = &v
	return s
}

func (s *ListInnerNodesRequest) SetProjectId(v int64) *ListInnerNodesRequest {
	s.ProjectId = &v
	return s
}

type ListInnerNodesResponseBody struct {
	// The page number of the returned page.
	Paging *ListInnerNodesResponseBodyPaging `json:"Paging,omitempty" xml:"Paging,omitempty" type:"Struct"`
	// Indicates whether the request is successful.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The paging information.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListInnerNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListInnerNodesResponseBody) GoString() string {
	return s.String()
}

func (s *ListInnerNodesResponseBody) SetPaging(v *ListInnerNodesResponseBodyPaging) *ListInnerNodesResponseBody {
	s.Paging = v
	return s
}

func (s *ListInnerNodesResponseBody) SetRequestId(v string) *ListInnerNodesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListInnerNodesResponseBody) SetSuccess(v bool) *ListInnerNodesResponseBody {
	s.Success = &v
	return s
}

type ListInnerNodesResponseBodyPaging struct {
	// The scheduling type of the inner node. Valid values:
	//
	// *   NORMAL: The inner node is an auto triggered node.
	// *   MANUAL: The inner node is a manually triggered node. Manually triggered nodes cannot be automatically triggered.
	// *   PAUSE: The inner node is a paused node.
	// *   SKIP: The inner node is a dry-run node. Dry-run nodes are started as scheduled but the scheduling system sets the status of the nodes to succeeded when the scheduling system starts to run the nodes.
	Nodes []*ListInnerNodesResponseBodyPagingNodes `json:"Nodes,omitempty" xml:"Nodes,omitempty" type:"Repeated"`
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The total number of inner nodes returned.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The list of inner nodes.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListInnerNodesResponseBodyPaging) String() string {
	return tea.Prettify(s)
}

func (s ListInnerNodesResponseBodyPaging) GoString() string {
	return s.String()
}

func (s *ListInnerNodesResponseBodyPaging) SetNodes(v []*ListInnerNodesResponseBodyPagingNodes) *ListInnerNodesResponseBodyPaging {
	s.Nodes = v
	return s
}

func (s *ListInnerNodesResponseBodyPaging) SetPageNumber(v int32) *ListInnerNodesResponseBodyPaging {
	s.PageNumber = &v
	return s
}

func (s *ListInnerNodesResponseBodyPaging) SetPageSize(v int32) *ListInnerNodesResponseBodyPaging {
	s.PageSize = &v
	return s
}

func (s *ListInnerNodesResponseBodyPaging) SetTotalCount(v int32) *ListInnerNodesResponseBodyPaging {
	s.TotalCount = &v
	return s
}

type ListInnerNodesResponseBodyPagingNodes struct {
	// The description of the inner node.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The table and partition filter expression in Data Quality that are associated with the inner node.
	BusinessId *int64 `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	// The values of other parameters related to the inner node.
	Connection *string `json:"Connection,omitempty" xml:"Connection,omitempty"`
	// The ID of the inner node.
	CronExpress *string `json:"CronExpress,omitempty" xml:"CronExpress,omitempty"`
	// The name of the inner node.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The cron expression.
	DqcDescription *string `json:"DqcDescription,omitempty" xml:"DqcDescription,omitempty"`
	// The ID of the baseline with which the inner node is associated.
	DqcType *string `json:"DqcType,omitempty" xml:"DqcType,omitempty"`
	NodeId  *int64  `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the resource group.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The connection string.
	OwnerId *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// Indicates whether the node is associated with Data Quality. Valid values: 0 and 1. The value 0 indicates that the node is associated with Data Quality. The value 1 indicates that the node is not associated with Data Quality.
	ParamValues *string `json:"ParamValues,omitempty" xml:"ParamValues,omitempty"`
	// The ID of the owner of the inner node.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The priority of the inner node. Valid values: 1, 3, 5, 7, and 8.
	ProgramType *string `json:"ProgramType,omitempty" xml:"ProgramType,omitempty"`
	// The type of the inner node.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// Indicates whether the inner node can be rerun.
	RepeatInterval *int64 `json:"RepeatInterval,omitempty" xml:"RepeatInterval,omitempty"`
	// The ID of the workspace.
	Repeatability *bool `json:"Repeatability,omitempty" xml:"Repeatability,omitempty"`
	// The ID of the workflow.
	ResGroupName *string `json:"ResGroupName,omitempty" xml:"ResGroupName,omitempty"`
	// The interval at which the inner node is rerun after the inner node fails to be run.
	SchedulerType *string `json:"SchedulerType,omitempty" xml:"SchedulerType,omitempty"`
}

func (s ListInnerNodesResponseBodyPagingNodes) String() string {
	return tea.Prettify(s)
}

func (s ListInnerNodesResponseBodyPagingNodes) GoString() string {
	return s.String()
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetBaselineId(v int64) *ListInnerNodesResponseBodyPagingNodes {
	s.BaselineId = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetBusinessId(v int64) *ListInnerNodesResponseBodyPagingNodes {
	s.BusinessId = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetConnection(v string) *ListInnerNodesResponseBodyPagingNodes {
	s.Connection = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetCronExpress(v string) *ListInnerNodesResponseBodyPagingNodes {
	s.CronExpress = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetDescription(v string) *ListInnerNodesResponseBodyPagingNodes {
	s.Description = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetDqcDescription(v string) *ListInnerNodesResponseBodyPagingNodes {
	s.DqcDescription = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetDqcType(v string) *ListInnerNodesResponseBodyPagingNodes {
	s.DqcType = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetNodeId(v int64) *ListInnerNodesResponseBodyPagingNodes {
	s.NodeId = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetNodeName(v string) *ListInnerNodesResponseBodyPagingNodes {
	s.NodeName = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetOwnerId(v string) *ListInnerNodesResponseBodyPagingNodes {
	s.OwnerId = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetParamValues(v string) *ListInnerNodesResponseBodyPagingNodes {
	s.ParamValues = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetPriority(v int32) *ListInnerNodesResponseBodyPagingNodes {
	s.Priority = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetProgramType(v string) *ListInnerNodesResponseBodyPagingNodes {
	s.ProgramType = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetProjectId(v int64) *ListInnerNodesResponseBodyPagingNodes {
	s.ProjectId = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetRepeatInterval(v int64) *ListInnerNodesResponseBodyPagingNodes {
	s.RepeatInterval = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetRepeatability(v bool) *ListInnerNodesResponseBodyPagingNodes {
	s.Repeatability = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetResGroupName(v string) *ListInnerNodesResponseBodyPagingNodes {
	s.ResGroupName = &v
	return s
}

func (s *ListInnerNodesResponseBodyPagingNodes) SetSchedulerType(v string) *ListInnerNodesResponseBodyPagingNodes {
	s.SchedulerType = &v
	return s
}

type ListInnerNodesResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListInnerNodesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListInnerNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListInnerNodesResponse) GoString() string {
	return s.String()
}

func (s *ListInnerNodesResponse) SetHeaders(v map[string]*string) *ListInnerNodesResponse {
	s.Headers = v
	return s
}

func (s *ListInnerNodesResponse) SetStatusCode(v int32) *ListInnerNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListInnerNodesResponse) SetBody(v *ListInnerNodesResponseBody) *ListInnerNodesResponse {
	s.Body = v
	return s
}

type ListInstanceAmountRequest struct {
	// The beginning of the time range to query, accurate to the day. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	BeginDate *string `json:"BeginDate,omitempty" xml:"BeginDate,omitempty"`
	// The end of the time range to query, accurate to the day. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListInstanceAmountRequest) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceAmountRequest) GoString() string {
	return s.String()
}

func (s *ListInstanceAmountRequest) SetBeginDate(v string) *ListInstanceAmountRequest {
	s.BeginDate = &v
	return s
}

func (s *ListInstanceAmountRequest) SetEndDate(v string) *ListInstanceAmountRequest {
	s.EndDate = &v
	return s
}

func (s *ListInstanceAmountRequest) SetProjectId(v int64) *ListInstanceAmountRequest {
	s.ProjectId = &v
	return s
}

type ListInstanceAmountResponseBody struct {
	// The trend of the number of auto triggered node instances within the specified period of time.
	InstanceCounts []*ListInstanceAmountResponseBodyInstanceCounts `json:"InstanceCounts,omitempty" xml:"InstanceCounts,omitempty" type:"Repeated"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListInstanceAmountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceAmountResponseBody) GoString() string {
	return s.String()
}

func (s *ListInstanceAmountResponseBody) SetInstanceCounts(v []*ListInstanceAmountResponseBodyInstanceCounts) *ListInstanceAmountResponseBody {
	s.InstanceCounts = v
	return s
}

func (s *ListInstanceAmountResponseBody) SetRequestId(v string) *ListInstanceAmountResponseBody {
	s.RequestId = &v
	return s
}

type ListInstanceAmountResponseBodyInstanceCounts struct {
	// The number of auto triggered node instances.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The data timestamp at which the number of auto triggered node instances was obtained. This value is a UNIX timestamp.
	Date *int64 `json:"Date,omitempty" xml:"Date,omitempty"`
}

func (s ListInstanceAmountResponseBodyInstanceCounts) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceAmountResponseBodyInstanceCounts) GoString() string {
	return s.String()
}

func (s *ListInstanceAmountResponseBodyInstanceCounts) SetCount(v int32) *ListInstanceAmountResponseBodyInstanceCounts {
	s.Count = &v
	return s
}

func (s *ListInstanceAmountResponseBodyInstanceCounts) SetDate(v int64) *ListInstanceAmountResponseBodyInstanceCounts {
	s.Date = &v
	return s
}

type ListInstanceAmountResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListInstanceAmountResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListInstanceAmountResponse) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceAmountResponse) GoString() string {
	return s.String()
}

func (s *ListInstanceAmountResponse) SetHeaders(v map[string]*string) *ListInstanceAmountResponse {
	s.Headers = v
	return s
}

func (s *ListInstanceAmountResponse) SetStatusCode(v int32) *ListInstanceAmountResponse {
	s.StatusCode = &v
	return s
}

func (s *ListInstanceAmountResponse) SetBody(v *ListInstanceAmountResponseBody) *ListInstanceAmountResponse {
	s.Body = v
	return s
}

type ListInstanceHistoryRequest struct {
	// The environment of the workspace. Valid values: PROD (production environment) and DEV (development environment).By default, data of instances in the production environment is queried.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s ListInstanceHistoryRequest) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceHistoryRequest) GoString() string {
	return s.String()
}

func (s *ListInstanceHistoryRequest) SetInstanceId(v int64) *ListInstanceHistoryRequest {
	s.InstanceId = &v
	return s
}

func (s *ListInstanceHistoryRequest) SetProjectEnv(v string) *ListInstanceHistoryRequest {
	s.ProjectEnv = &v
	return s
}

type ListInstanceHistoryResponseBody struct {
	// The status of the node that generates the instance. Valid values:
	//
	// *   NOT_RUN: The node is not run.
	// *   WAIT_TIME: The node is waiting for the scheduling time to arrive.
	// *   WAIT_RESOURCE: The node is waiting for resources.
	// *   RUNNING: The node is running.
	// *   CHECKING: Data quality is being checked for the node.
	// *   CHECKING_CONDITION: Branch conditions are being checked for the node.
	// *   FAILURE: The node fails to be run.
	// *   SUCCESS: The node is successfully run.
	Instances []*ListInstanceHistoryResponseBodyInstances `json:"Instances,omitempty" xml:"Instances,omitempty" type:"Repeated"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The instance list.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListInstanceHistoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceHistoryResponseBody) GoString() string {
	return s.String()
}

func (s *ListInstanceHistoryResponseBody) SetInstances(v []*ListInstanceHistoryResponseBodyInstances) *ListInstanceHistoryResponseBody {
	s.Instances = v
	return s
}

func (s *ListInstanceHistoryResponseBody) SetRequestId(v string) *ListInstanceHistoryResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListInstanceHistoryResponseBody) SetSuccess(v bool) *ListInstanceHistoryResponseBody {
	s.Success = &v
	return s
}

type ListInstanceHistoryResponseBodyInstances struct {
	// The time when the running of the node was complete. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	BeginRunningTime *int64 `json:"BeginRunningTime,omitempty" xml:"BeginRunningTime,omitempty"`
	// The data timestamp of the instance. In most cases, the value is one day before the time when the instance was run.
	BeginWaitResTime *int64 `json:"BeginWaitResTime,omitempty" xml:"BeginWaitResTime,omitempty"`
	// The ID of the node that generates the instance.
	BeginWaitTimeTime *int64 `json:"BeginWaitTimeTime,omitempty" xml:"BeginWaitTimeTime,omitempty"`
	// The name of the node.
	Bizdate *int64 `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	// The ID of the workflow.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The time when the instance started to be run. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	CycTime *int64 `json:"CycTime,omitempty" xml:"CycTime,omitempty"`
	// The type of the node. Valid values:
	//
	// *   NORMAL(0): The node is an auto triggered node. The scheduling system regularly runs the node.
	// *   MANUAL(1): The node is a manually triggered node. The scheduling system does not regularly run the node.
	// *   PAUSE(2): The node is a frozen node. The scheduling system regularly runs the node but sets the status of the node to failed when the scheduling system starts to run the node.
	// *   SKIP(3): The node is a dry-run node. The scheduling system regularly runs the node but sets the status of the node to succeeded when the scheduling system starts to run the node.
	// *   SKIP_UNCHOOSE(4): The node is an unselected node in a temporary workflow. This type of node exists only in temporary workflows. The scheduling system sets the status of the node to succeeded when the scheduling system starts to run the node.
	// *   SKIP_CYCLE(5): The node is a node that is scheduled by week or month and is waiting for the scheduling time to arrive. The scheduling system regularly runs the node but sets the status of the node to succeeded when the scheduling system starts to run the node.
	// *   CONDITION_UNCHOOSE(6): The node is not selected by its ancestor branch node and is run as a dry-run node.
	// *   REALTIME_DEPRECATED(7): The node has instances that are generated in real time but deprecated. The scheduling system sets the status of the node to succeeded.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The time when the node was last modified.
	DagType *string `json:"DagType,omitempty" xml:"DagType,omitempty"`
	// The time when the instance was generated.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The error message that is returned for the instance. This parameter is deprecated. You can call the GetInstanceLog operation to query the error information related to the node.
	FinishTime        *int64 `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	InstanceHistoryId *int64 `json:"InstanceHistoryId,omitempty" xml:"InstanceHistoryId,omitempty"`
	// The time when the instance started to wait for resources.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the instance.
	ModifyTime *int64 `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The historical record number of the instance.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The time when the instance started to wait to be scheduled.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The time when the node started to be run. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Indicates whether the instance is associated with a monitoring rule in Data Quality (DQC). Valid values:
	//
	// *   0: The instance is associated with a monitoring rule in Data Quality.
	// *   1: The instance is not associated with a monitoring rule in Data Quality.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s ListInstanceHistoryResponseBodyInstances) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceHistoryResponseBodyInstances) GoString() string {
	return s.String()
}

func (s *ListInstanceHistoryResponseBodyInstances) SetBeginRunningTime(v int64) *ListInstanceHistoryResponseBodyInstances {
	s.BeginRunningTime = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetBeginWaitResTime(v int64) *ListInstanceHistoryResponseBodyInstances {
	s.BeginWaitResTime = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetBeginWaitTimeTime(v int64) *ListInstanceHistoryResponseBodyInstances {
	s.BeginWaitTimeTime = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetBizdate(v int64) *ListInstanceHistoryResponseBodyInstances {
	s.Bizdate = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetCreateTime(v int64) *ListInstanceHistoryResponseBodyInstances {
	s.CreateTime = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetCycTime(v int64) *ListInstanceHistoryResponseBodyInstances {
	s.CycTime = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetDagId(v int64) *ListInstanceHistoryResponseBodyInstances {
	s.DagId = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetDagType(v string) *ListInstanceHistoryResponseBodyInstances {
	s.DagType = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetErrorMessage(v string) *ListInstanceHistoryResponseBodyInstances {
	s.ErrorMessage = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetFinishTime(v int64) *ListInstanceHistoryResponseBodyInstances {
	s.FinishTime = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetInstanceHistoryId(v int64) *ListInstanceHistoryResponseBodyInstances {
	s.InstanceHistoryId = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetInstanceId(v int64) *ListInstanceHistoryResponseBodyInstances {
	s.InstanceId = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetModifyTime(v int64) *ListInstanceHistoryResponseBodyInstances {
	s.ModifyTime = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetNodeId(v int64) *ListInstanceHistoryResponseBodyInstances {
	s.NodeId = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetNodeName(v string) *ListInstanceHistoryResponseBodyInstances {
	s.NodeName = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetStatus(v string) *ListInstanceHistoryResponseBodyInstances {
	s.Status = &v
	return s
}

func (s *ListInstanceHistoryResponseBodyInstances) SetTaskType(v string) *ListInstanceHistoryResponseBodyInstances {
	s.TaskType = &v
	return s
}

type ListInstanceHistoryResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListInstanceHistoryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListInstanceHistoryResponse) String() string {
	return tea.Prettify(s)
}

func (s ListInstanceHistoryResponse) GoString() string {
	return s.String()
}

func (s *ListInstanceHistoryResponse) SetHeaders(v map[string]*string) *ListInstanceHistoryResponse {
	s.Headers = v
	return s
}

func (s *ListInstanceHistoryResponse) SetStatusCode(v int32) *ListInstanceHistoryResponse {
	s.StatusCode = &v
	return s
}

func (s *ListInstanceHistoryResponse) SetBody(v *ListInstanceHistoryResponseBody) *ListInstanceHistoryResponse {
	s.Body = v
	return s
}

type ListInstancesRequest struct {
	// The parameters related to the node.
	BeginBizdate *string `json:"BeginBizdate,omitempty" xml:"BeginBizdate,omitempty"`
	// The ID of the instance.
	BizName *string `json:"BizName,omitempty" xml:"BizName,omitempty"`
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	Bizdate *string `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV. The value PROD indicates the production environment. The value DEV indicates the development environment.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The ID of the workflow.
	EndBizdate *string `json:"EndBizdate,omitempty" xml:"EndBizdate,omitempty"`
	// Indicates whether the instance is associated with a monitoring rule in Data Quality. Valid values:
	//
	// *   0: The instance is associated with a monitoring rule in Data Quality.
	// *   1: The instance is not associated with a monitoring rule in Data Quality.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// Indicates whether the node can be rerun.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	OrderBy  *string `json:"OrderBy,omitempty" xml:"OrderBy,omitempty"`
	// The connection string.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The operation that you want to perform.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the node.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The error code returned.
	ProgramType *string `json:"ProgramType,omitempty" xml:"ProgramType,omitempty"`
	// The time when the node was last modified.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
	// The ID of the baseline.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The time when the instance started to wait to be scheduled.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListInstancesRequest) GoString() string {
	return s.String()
}

func (s *ListInstancesRequest) SetBeginBizdate(v string) *ListInstancesRequest {
	s.BeginBizdate = &v
	return s
}

func (s *ListInstancesRequest) SetBizName(v string) *ListInstancesRequest {
	s.BizName = &v
	return s
}

func (s *ListInstancesRequest) SetBizdate(v string) *ListInstancesRequest {
	s.Bizdate = &v
	return s
}

func (s *ListInstancesRequest) SetDagId(v int64) *ListInstancesRequest {
	s.DagId = &v
	return s
}

func (s *ListInstancesRequest) SetEndBizdate(v string) *ListInstancesRequest {
	s.EndBizdate = &v
	return s
}

func (s *ListInstancesRequest) SetNodeId(v int64) *ListInstancesRequest {
	s.NodeId = &v
	return s
}

func (s *ListInstancesRequest) SetNodeName(v string) *ListInstancesRequest {
	s.NodeName = &v
	return s
}

func (s *ListInstancesRequest) SetOrderBy(v string) *ListInstancesRequest {
	s.OrderBy = &v
	return s
}

func (s *ListInstancesRequest) SetOwner(v string) *ListInstancesRequest {
	s.Owner = &v
	return s
}

func (s *ListInstancesRequest) SetPageNumber(v int32) *ListInstancesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListInstancesRequest) SetPageSize(v int32) *ListInstancesRequest {
	s.PageSize = &v
	return s
}

func (s *ListInstancesRequest) SetProgramType(v string) *ListInstancesRequest {
	s.ProgramType = &v
	return s
}

func (s *ListInstancesRequest) SetProjectEnv(v string) *ListInstancesRequest {
	s.ProjectEnv = &v
	return s
}

func (s *ListInstancesRequest) SetProjectId(v int64) *ListInstancesRequest {
	s.ProjectId = &v
	return s
}

func (s *ListInstancesRequest) SetStatus(v string) *ListInstancesRequest {
	s.Status = &v
	return s
}

type ListInstancesResponseBody struct {
	// The ID of the node. You can call the [ListNodes](~~173979~~) operation to query the ID of the node.
	Data *ListInstancesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The page number of the returned page.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The error message that is returned for the instance.
	//
	// This parameter is deprecated. You can call the [GetInstanceLog](~~173983~~) operation to query the error information related to the node.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The name of the node.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The beginning of the time range to query. Specify the time in the yyyy-MM-dd HH:mm:ss format.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *ListInstancesResponseBody) SetData(v *ListInstancesResponseBodyData) *ListInstancesResponseBody {
	s.Data = v
	return s
}

func (s *ListInstancesResponseBody) SetErrorCode(v string) *ListInstancesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListInstancesResponseBody) SetErrorMessage(v string) *ListInstancesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListInstancesResponseBody) SetHttpStatusCode(v int32) *ListInstancesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListInstancesResponseBody) SetRequestId(v string) *ListInstancesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListInstancesResponseBody) SetSuccess(v bool) *ListInstancesResponseBody {
	s.Success = &v
	return s
}

type ListInstancesResponseBodyData struct {
	// The name of the node. You can call the [ListNodes](~~173979~~) operation to query the name of the node.
	Instances []*ListInstancesResponseBodyDataInstances `json:"Instances,omitempty" xml:"Instances,omitempty" type:"Repeated"`
	// The time when the node was scheduled to run.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The end of the time range to query. Specify the time in the yyyy-MM-dd HH:mm:ss format.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The priority of the instance. Valid values: 1, 3, 5, 7, and 8.
	//
	// A greater value indicates a higher priority. Default value: 1.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListInstancesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListInstancesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListInstancesResponseBodyData) SetInstances(v []*ListInstancesResponseBodyDataInstances) *ListInstancesResponseBodyData {
	s.Instances = v
	return s
}

func (s *ListInstancesResponseBodyData) SetPageNumber(v int32) *ListInstancesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListInstancesResponseBodyData) SetPageSize(v int32) *ListInstancesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListInstancesResponseBodyData) SetTotalCount(v int32) *ListInstancesResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListInstancesResponseBodyDataInstances struct {
	// The type of the workflow. Valid values:
	//
	// *   DAILY: The workflow is used to run auto triggered nodes.
	// *   MANUAL: The workflow is used to run manually triggered nodes.
	// *   SMOKE_TEST: The workflow is used to perform smoke testing.
	// *   SUPPLY_DATA: The workflow is used to backfill data.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The time when the instance started to run.
	BeginRunningTime *int64 `json:"BeginRunningTime,omitempty" xml:"BeginRunningTime,omitempty"`
	// The time when the node stopped running.
	BeginWaitResTime *int64 `json:"BeginWaitResTime,omitempty" xml:"BeginWaitResTime,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	BeginWaitTimeTime *int64 `json:"BeginWaitTimeTime,omitempty" xml:"BeginWaitTimeTime,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	//
	// You cannot specify the sorting method for the instances to be returned by this operation. By default, the instances are sorted in descending order of the time when the instances were created.
	Bizdate *int64 `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	// The ID of the workflow to which the node belongs.
	BusinessId *int64 `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	// The number of times the node can be rerun. The value of this parameter can be empty or an integer that is greater than or equal to 0.
	//
	// *   If the value of this parameter is empty, the number of times that the node can be rerun is not specified.
	// *   If the value of this parameter is 0, the node cannot be rerun.
	// *   If the value of this parameter is a positive integer such as n, the node can be rerun n times. For example, if the value of this parameter is 1, the node can be rerun once. If the value of this parameter is 2, the node can be rerun twice.
	Connection *string `json:"Connection,omitempty" xml:"Connection,omitempty"`
	// The interval at which the node is rerun after the node fails to run. Unit: milliseconds.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the node. You can call the [ListNodes](~~173979~~) operation to query the ID of the node.
	CreateUser *string `json:"CreateUser,omitempty" xml:"CreateUser,omitempty"`
	// The error message returned.
	CycTime *int64 `json:"CycTime,omitempty" xml:"CycTime,omitempty"`
	// The time when the instance started to wait for resources.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The data timestamp of the instance. In most cases, the value is one day before the time when the instance was run.
	DagType *string `json:"DagType,omitempty" xml:"DagType,omitempty"`
	// The operation that you want to perform.
	DqcDescription *string `json:"DqcDescription,omitempty" xml:"DqcDescription,omitempty"`
	// The status of the node. Valid values:
	//
	// *   NOT_RUN: The node is not run.
	// *   WAIT_TIME: The node is waiting for the scheduling time to arrive.
	// *   WAIT_RESOURCE: The node is waiting for resources.
	// *   RUNNING: The node is running.
	// *   CHECKING: Data quality is being checked for the node.
	// *   CHECKING_CONDITION: Branch conditions are being checked for the node.
	// *   FAILURE: The node fails to run.
	// *   SUCCESS: The node is successfully run.
	DqcType *int32 `json:"DqcType,omitempty" xml:"DqcType,omitempty"`
	// The name of the account that is used to run the instance. For example, if an account named Test was used to run the instance to backfill data, the value of this parameter is Test.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the Alibaba Cloud account used by the workspace administrator. You can log on to the Alibaba Cloud Management Console and view the ID on the Security Settings page of the Account Center console.
	FinishTime *int64 `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	// The number of the page to return. Minimum value:1. Maximum value: 100.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The name of the workflow. You can call the [ListBusiness](~~173945~~) operation to query the name of the workflow.
	ModifyTime *int64 `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV. The value PROD indicates the production environment. The value DEV indicates the development environment.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the workflow.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The table and partition filter expression in Data Quality that are associated with the node.
	ParamValues *string `json:"ParamValues,omitempty" xml:"ParamValues,omitempty"`
	// The total number of instances.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of the node. You can call the [ListNodes](~~173979~~) operation to query the type of the node.
	RelatedFlowId *int64 `json:"RelatedFlowId,omitempty" xml:"RelatedFlowId,omitempty"`
	// The scheduling type of the node. Valid values:
	//
	// *   NORMAL(0): The node is an auto triggered node. The scheduling system regularly runs the node.
	//
	// *   MANUAL(1): The node is a manually triggered node. The scheduling system does not regularly run the node.
	//
	// *   PAUSE(2): The node is a frozen node. The scheduling system regularly runs the node but sets the status of the node to failed when the scheduling system starts to run the node.
	//
	// *   SKIP(3): The node is a dry-run node. The scheduling system regularly runs the node but sets the status of the node to succeeded when the scheduling system starts to run the node.
	//
	// *   SKIP_UNCHOOSE(4): The node is an unselected node in a temporary workflow. This type of node exists only in temporary workflows. The scheduling system sets the status of the node to succeeded when the scheduling system starts to run the node.
	//
	// *   SKIP_CYCLE(5): The node is a node that is scheduled by week or month and is waiting for the scheduling time to arrive. The scheduling system regularly runs the node but sets the status of the node to succeeded when the scheduling system starts to run the node.
	//
	// *   CONDITION_UNCHOOSE(6): The node is not selected by its ancestor branch node and is run as a dry-run node.
	//
	//     REALTIME_DEPRECATED(7): The node has instances that are generated in real time but deprecated. The scheduling system sets the status of the node to succeeded.
	RepeatInterval *int64 `json:"RepeatInterval,omitempty" xml:"RepeatInterval,omitempty"`
	// The status of the node. Valid values:
	//
	// *   NOT_RUN: The node is not run.
	// *   WAIT_TIME: The node is waiting for the scheduling time to arrive.
	// *   WAIT_RESOURCE: The node is waiting for resources.
	// *   RUNNING: The node is running.
	// *   CHECKING: Data quality is being checked for the node.
	// *   CHECKING_CONDITION: Branch conditions are being checked for the node.
	// *   FAILURE: The node fails to run.
	// *   SUCCESS: The node is successfully run.
	Repeatability *bool `json:"Repeatability,omitempty" xml:"Repeatability,omitempty"`
	// The data timestamp of the instances that you want to query. Specify the timestamp in the yyyy-MM-dd HH:mm:ss format.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the workspace. You can call the [ListProjects](~~178393~~) operation to query the ID of the workspace.
	TaskRerunTime *int32 `json:"TaskRerunTime,omitempty" xml:"TaskRerunTime,omitempty"`
	// The information about the instances.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s ListInstancesResponseBodyDataInstances) String() string {
	return tea.Prettify(s)
}

func (s ListInstancesResponseBodyDataInstances) GoString() string {
	return s.String()
}

func (s *ListInstancesResponseBodyDataInstances) SetBaselineId(v int64) *ListInstancesResponseBodyDataInstances {
	s.BaselineId = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetBeginRunningTime(v int64) *ListInstancesResponseBodyDataInstances {
	s.BeginRunningTime = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetBeginWaitResTime(v int64) *ListInstancesResponseBodyDataInstances {
	s.BeginWaitResTime = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetBeginWaitTimeTime(v int64) *ListInstancesResponseBodyDataInstances {
	s.BeginWaitTimeTime = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetBizdate(v int64) *ListInstancesResponseBodyDataInstances {
	s.Bizdate = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetBusinessId(v int64) *ListInstancesResponseBodyDataInstances {
	s.BusinessId = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetConnection(v string) *ListInstancesResponseBodyDataInstances {
	s.Connection = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetCreateTime(v int64) *ListInstancesResponseBodyDataInstances {
	s.CreateTime = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetCreateUser(v string) *ListInstancesResponseBodyDataInstances {
	s.CreateUser = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetCycTime(v int64) *ListInstancesResponseBodyDataInstances {
	s.CycTime = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetDagId(v int64) *ListInstancesResponseBodyDataInstances {
	s.DagId = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetDagType(v string) *ListInstancesResponseBodyDataInstances {
	s.DagType = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetDqcDescription(v string) *ListInstancesResponseBodyDataInstances {
	s.DqcDescription = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetDqcType(v int32) *ListInstancesResponseBodyDataInstances {
	s.DqcType = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetErrorMessage(v string) *ListInstancesResponseBodyDataInstances {
	s.ErrorMessage = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetFinishTime(v int64) *ListInstancesResponseBodyDataInstances {
	s.FinishTime = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetInstanceId(v int64) *ListInstancesResponseBodyDataInstances {
	s.InstanceId = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetModifyTime(v int64) *ListInstancesResponseBodyDataInstances {
	s.ModifyTime = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetNodeId(v int64) *ListInstancesResponseBodyDataInstances {
	s.NodeId = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetNodeName(v string) *ListInstancesResponseBodyDataInstances {
	s.NodeName = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetParamValues(v string) *ListInstancesResponseBodyDataInstances {
	s.ParamValues = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetPriority(v int32) *ListInstancesResponseBodyDataInstances {
	s.Priority = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetRelatedFlowId(v int64) *ListInstancesResponseBodyDataInstances {
	s.RelatedFlowId = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetRepeatInterval(v int64) *ListInstancesResponseBodyDataInstances {
	s.RepeatInterval = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetRepeatability(v bool) *ListInstancesResponseBodyDataInstances {
	s.Repeatability = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetStatus(v string) *ListInstancesResponseBodyDataInstances {
	s.Status = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetTaskRerunTime(v int32) *ListInstancesResponseBodyDataInstances {
	s.TaskRerunTime = &v
	return s
}

func (s *ListInstancesResponseBodyDataInstances) SetTaskType(v string) *ListInstancesResponseBodyDataInstances {
	s.TaskType = &v
	return s
}

type ListInstancesResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListInstancesResponse) GoString() string {
	return s.String()
}

func (s *ListInstancesResponse) SetHeaders(v map[string]*string) *ListInstancesResponse {
	s.Headers = v
	return s
}

func (s *ListInstancesResponse) SetStatusCode(v int32) *ListInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListInstancesResponse) SetBody(v *ListInstancesResponseBody) *ListInstancesResponse {
	s.Body = v
	return s
}

type ListLineageRequest struct {
	Direction           *string `json:"Direction,omitempty" xml:"Direction,omitempty"`
	EntityQualifiedName *string `json:"EntityQualifiedName,omitempty" xml:"EntityQualifiedName,omitempty"`
	Keyword             *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	NextToken           *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	PageSize            *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListLineageRequest) String() string {
	return tea.Prettify(s)
}

func (s ListLineageRequest) GoString() string {
	return s.String()
}

func (s *ListLineageRequest) SetDirection(v string) *ListLineageRequest {
	s.Direction = &v
	return s
}

func (s *ListLineageRequest) SetEntityQualifiedName(v string) *ListLineageRequest {
	s.EntityQualifiedName = &v
	return s
}

func (s *ListLineageRequest) SetKeyword(v string) *ListLineageRequest {
	s.Keyword = &v
	return s
}

func (s *ListLineageRequest) SetNextToken(v string) *ListLineageRequest {
	s.NextToken = &v
	return s
}

func (s *ListLineageRequest) SetPageSize(v int32) *ListLineageRequest {
	s.PageSize = &v
	return s
}

type ListLineageResponseBody struct {
	Data           *ListLineageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorCode      *string                      `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string                      `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32                       `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string                      `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                        `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListLineageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListLineageResponseBody) GoString() string {
	return s.String()
}

func (s *ListLineageResponseBody) SetData(v *ListLineageResponseBodyData) *ListLineageResponseBody {
	s.Data = v
	return s
}

func (s *ListLineageResponseBody) SetErrorCode(v string) *ListLineageResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListLineageResponseBody) SetErrorMessage(v string) *ListLineageResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListLineageResponseBody) SetHttpStatusCode(v int32) *ListLineageResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListLineageResponseBody) SetRequestId(v string) *ListLineageResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListLineageResponseBody) SetSuccess(v bool) *ListLineageResponseBody {
	s.Success = &v
	return s
}

type ListLineageResponseBodyData struct {
	DataEntityList []*ListLineageResponseBodyDataDataEntityList `json:"DataEntityList,omitempty" xml:"DataEntityList,omitempty" type:"Repeated"`
	NextToken      *string                                      `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s ListLineageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListLineageResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListLineageResponseBodyData) SetDataEntityList(v []*ListLineageResponseBodyDataDataEntityList) *ListLineageResponseBodyData {
	s.DataEntityList = v
	return s
}

func (s *ListLineageResponseBodyData) SetNextToken(v string) *ListLineageResponseBodyData {
	s.NextToken = &v
	return s
}

type ListLineageResponseBodyDataDataEntityList struct {
	CreateTimestamp *int64                                                   `json:"CreateTimestamp,omitempty" xml:"CreateTimestamp,omitempty"`
	Entity          *Entity                                                  `json:"Entity,omitempty" xml:"Entity,omitempty"`
	RelationList    []*ListLineageResponseBodyDataDataEntityListRelationList `json:"RelationList,omitempty" xml:"RelationList,omitempty" type:"Repeated"`
}

func (s ListLineageResponseBodyDataDataEntityList) String() string {
	return tea.Prettify(s)
}

func (s ListLineageResponseBodyDataDataEntityList) GoString() string {
	return s.String()
}

func (s *ListLineageResponseBodyDataDataEntityList) SetCreateTimestamp(v int64) *ListLineageResponseBodyDataDataEntityList {
	s.CreateTimestamp = &v
	return s
}

func (s *ListLineageResponseBodyDataDataEntityList) SetEntity(v *Entity) *ListLineageResponseBodyDataDataEntityList {
	s.Entity = v
	return s
}

func (s *ListLineageResponseBodyDataDataEntityList) SetRelationList(v []*ListLineageResponseBodyDataDataEntityListRelationList) *ListLineageResponseBodyDataDataEntityList {
	s.RelationList = v
	return s
}

type ListLineageResponseBodyDataDataEntityListRelationList struct {
	Channel    *string `json:"Channel,omitempty" xml:"Channel,omitempty"`
	Datasource *string `json:"Datasource,omitempty" xml:"Datasource,omitempty"`
	Guid       *string `json:"Guid,omitempty" xml:"Guid,omitempty"`
	Type       *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListLineageResponseBodyDataDataEntityListRelationList) String() string {
	return tea.Prettify(s)
}

func (s ListLineageResponseBodyDataDataEntityListRelationList) GoString() string {
	return s.String()
}

func (s *ListLineageResponseBodyDataDataEntityListRelationList) SetChannel(v string) *ListLineageResponseBodyDataDataEntityListRelationList {
	s.Channel = &v
	return s
}

func (s *ListLineageResponseBodyDataDataEntityListRelationList) SetDatasource(v string) *ListLineageResponseBodyDataDataEntityListRelationList {
	s.Datasource = &v
	return s
}

func (s *ListLineageResponseBodyDataDataEntityListRelationList) SetGuid(v string) *ListLineageResponseBodyDataDataEntityListRelationList {
	s.Guid = &v
	return s
}

func (s *ListLineageResponseBodyDataDataEntityListRelationList) SetType(v string) *ListLineageResponseBodyDataDataEntityListRelationList {
	s.Type = &v
	return s
}

type ListLineageResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListLineageResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListLineageResponse) String() string {
	return tea.Prettify(s)
}

func (s ListLineageResponse) GoString() string {
	return s.String()
}

func (s *ListLineageResponse) SetHeaders(v map[string]*string) *ListLineageResponse {
	s.Headers = v
	return s
}

func (s *ListLineageResponse) SetStatusCode(v int32) *ListLineageResponse {
	s.StatusCode = &v
	return s
}

func (s *ListLineageResponse) SetBody(v *ListLineageResponseBody) *ListLineageResponse {
	s.Body = v
	return s
}

type ListManualDagInstancesRequest struct {
	// The ID of the directed acyclic graph (DAG) for the manually triggered workflow. You can call the [RunManualDagNodes](~~212830~~) operation to obtain the ID.
	DagId *string `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV. A value of PROD indicates the production environment. A value of DEV indicates the development environment.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
	// The name of the workspace to which the manually triggered workflow belongs. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to view the name.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s ListManualDagInstancesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListManualDagInstancesRequest) GoString() string {
	return s.String()
}

func (s *ListManualDagInstancesRequest) SetDagId(v string) *ListManualDagInstancesRequest {
	s.DagId = &v
	return s
}

func (s *ListManualDagInstancesRequest) SetProjectEnv(v string) *ListManualDagInstancesRequest {
	s.ProjectEnv = &v
	return s
}

func (s *ListManualDagInstancesRequest) SetProjectName(v string) *ListManualDagInstancesRequest {
	s.ProjectName = &v
	return s
}

type ListManualDagInstancesResponseBody struct {
	// The instances in the manually triggered workflow.
	Instances []*ListManualDagInstancesResponseBodyInstances `json:"Instances,omitempty" xml:"Instances,omitempty" type:"Repeated"`
	// The ID of the request. You can use the ID to search for logs and troubleshoot issues based on the logs.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListManualDagInstancesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListManualDagInstancesResponseBody) GoString() string {
	return s.String()
}

func (s *ListManualDagInstancesResponseBody) SetInstances(v []*ListManualDagInstancesResponseBodyInstances) *ListManualDagInstancesResponseBody {
	s.Instances = v
	return s
}

func (s *ListManualDagInstancesResponseBody) SetRequestId(v string) *ListManualDagInstancesResponseBody {
	s.RequestId = &v
	return s
}

type ListManualDagInstancesResponseBodyInstances struct {
	// The time when the node started to run. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	BeginRunningTime *int64 `json:"BeginRunningTime,omitempty" xml:"BeginRunningTime,omitempty"`
	// The time when the node started to wait for resources. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	BeginWaitResTime *int64 `json:"BeginWaitResTime,omitempty" xml:"BeginWaitResTime,omitempty"`
	// The time when the node started to wait to be scheduled. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	BeginWaitTimeTime *int64 `json:"BeginWaitTimeTime,omitempty" xml:"BeginWaitTimeTime,omitempty"`
	// The data timestamp of the instance. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC. In most cases, the value indicates one day before the time when the node was run.
	BizDate *int64 `json:"BizDate,omitempty" xml:"BizDate,omitempty"`
	// The time when the node was created. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The name of the account used to run the instance. For example, if an account named Test was used to run the instance to backfill data, the value of this parameter is Test.
	CreateUser *string `json:"CreateUser,omitempty" xml:"CreateUser,omitempty"`
	// The time when the node was scheduled to run. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	CycTime *int64 `json:"CycTime,omitempty" xml:"CycTime,omitempty"`
	// The ID of the DAG for the manually triggered workflow.
	DagId *int64 `json:"DagId,omitempty" xml:"DagId,omitempty"`
	// The identifier of the manually triggered workflow.
	DagType *string `json:"DagType,omitempty" xml:"DagType,omitempty"`
	// The time when the node stopped running. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	FinishTime *int64 `json:"FinishTime,omitempty" xml:"FinishTime,omitempty"`
	// The ID of the instance in the manually triggered workflow.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The time when the node was last modified. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	ModifyTime *int64 `json:"ModifyTime,omitempty" xml:"ModifyTime,omitempty"`
	// The ID of the node in the manually triggered workflow.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The parameters related to the instance.
	ParamValues *string `json:"ParamValues,omitempty" xml:"ParamValues,omitempty"`
	// The status of the node. Valid values:
	//
	// *   NOT_RUN: The node is not run.
	// *   WAIT_TIME: The node is waiting for its scheduled time to arrive.
	// *   WAIT_RESOURCE: The node is waiting for resources.
	// *   RUNNING: The node is running.
	// *   CHECKING: Data quality is being checked for the node.
	// *   CHECKING_CONDITION: Branch conditions are being checked for the node.
	// *   FAILURE: The node fails to run.
	// *   SUCCESS: The node is run as expected.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The scheduling type of the node. Valid values:
	//
	// *   NORMAL(0): The node is an auto triggered node. It is run on a regular basis.
	// *   MANUAL(1): The node is a manually triggered node. It is not run on a regular basis.
	// *   PAUSE(2): The node is a frozen node. The scheduling system still runs the node on a regular basis but sets it to Failed when the scheduling system starts to run the node.
	// *   SKIP(3): The node is a dry-run node. The scheduling system still runs the node on a regular basis but sets it to Succeeded when the scheduling system starts to run the node.
	// *   SKIP_UNCHOOSE(4): The node is an unselected node in a temporary workflow. This type of node exists only in temporary workflows. The scheduling system sets the node to Succeeded when the scheduling system starts to run the node.
	// *   SKIP_CYCLE(5): The node is a node that is scheduled by week or month and is waiting for its scheduled time. The scheduling system still runs the node on a regular basis but sets it to Succeeded when the scheduling system starts to run the node.
	// *   CONDITION_UNCHOOSE(6): The node is not selected by its ancestor branch node and is run as a dry-run node.
	// *   REALTIME_DEPRECATED(7): The node has instances generated in real time but deprecated. The scheduling system directly sets the node to Succeeded.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s ListManualDagInstancesResponseBodyInstances) String() string {
	return tea.Prettify(s)
}

func (s ListManualDagInstancesResponseBodyInstances) GoString() string {
	return s.String()
}

func (s *ListManualDagInstancesResponseBodyInstances) SetBeginRunningTime(v int64) *ListManualDagInstancesResponseBodyInstances {
	s.BeginRunningTime = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetBeginWaitResTime(v int64) *ListManualDagInstancesResponseBodyInstances {
	s.BeginWaitResTime = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetBeginWaitTimeTime(v int64) *ListManualDagInstancesResponseBodyInstances {
	s.BeginWaitTimeTime = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetBizDate(v int64) *ListManualDagInstancesResponseBodyInstances {
	s.BizDate = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetCreateTime(v int64) *ListManualDagInstancesResponseBodyInstances {
	s.CreateTime = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetCreateUser(v string) *ListManualDagInstancesResponseBodyInstances {
	s.CreateUser = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetCycTime(v int64) *ListManualDagInstancesResponseBodyInstances {
	s.CycTime = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetDagId(v int64) *ListManualDagInstancesResponseBodyInstances {
	s.DagId = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetDagType(v string) *ListManualDagInstancesResponseBodyInstances {
	s.DagType = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetFinishTime(v int64) *ListManualDagInstancesResponseBodyInstances {
	s.FinishTime = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetInstanceId(v int64) *ListManualDagInstancesResponseBodyInstances {
	s.InstanceId = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetModifyTime(v int64) *ListManualDagInstancesResponseBodyInstances {
	s.ModifyTime = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetNodeId(v int64) *ListManualDagInstancesResponseBodyInstances {
	s.NodeId = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetNodeName(v string) *ListManualDagInstancesResponseBodyInstances {
	s.NodeName = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetParamValues(v string) *ListManualDagInstancesResponseBodyInstances {
	s.ParamValues = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetStatus(v string) *ListManualDagInstancesResponseBodyInstances {
	s.Status = &v
	return s
}

func (s *ListManualDagInstancesResponseBodyInstances) SetTaskType(v string) *ListManualDagInstancesResponseBodyInstances {
	s.TaskType = &v
	return s
}

type ListManualDagInstancesResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListManualDagInstancesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListManualDagInstancesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListManualDagInstancesResponse) GoString() string {
	return s.String()
}

func (s *ListManualDagInstancesResponse) SetHeaders(v map[string]*string) *ListManualDagInstancesResponse {
	s.Headers = v
	return s
}

func (s *ListManualDagInstancesResponse) SetStatusCode(v int32) *ListManualDagInstancesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListManualDagInstancesResponse) SetBody(v *ListManualDagInstancesResponseBody) *ListManualDagInstancesResponse {
	s.Body = v
	return s
}

type ListMetaCollectionEntitiesRequest struct {
	// The type of the entities.
	//
	// For example, if this parameter is set to maxcompute-table, the entity is a MaxCompute table.
	CollectionQualifiedName *string `json:"CollectionQualifiedName,omitempty" xml:"CollectionQualifiedName,omitempty"`
	// The search keyword.
	EntityType *string `json:"EntityType,omitempty" xml:"EntityType,omitempty"`
	// The paging information. This parameter specifies the start point of the query.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The number of entries to return on each page.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The object returned.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListMetaCollectionEntitiesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListMetaCollectionEntitiesRequest) GoString() string {
	return s.String()
}

func (s *ListMetaCollectionEntitiesRequest) SetCollectionQualifiedName(v string) *ListMetaCollectionEntitiesRequest {
	s.CollectionQualifiedName = &v
	return s
}

func (s *ListMetaCollectionEntitiesRequest) SetEntityType(v string) *ListMetaCollectionEntitiesRequest {
	s.EntityType = &v
	return s
}

func (s *ListMetaCollectionEntitiesRequest) SetKeyword(v string) *ListMetaCollectionEntitiesRequest {
	s.Keyword = &v
	return s
}

func (s *ListMetaCollectionEntitiesRequest) SetNextToken(v string) *ListMetaCollectionEntitiesRequest {
	s.NextToken = &v
	return s
}

func (s *ListMetaCollectionEntitiesRequest) SetPageSize(v int32) *ListMetaCollectionEntitiesRequest {
	s.PageSize = &v
	return s
}

type ListMetaCollectionEntitiesResponseBody struct {
	// The token that is used for the next query.
	Data *ListMetaCollectionEntitiesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	ErrorMessage   *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// true: The request was successful.
	//
	// false: The request failed.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The error code returned.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListMetaCollectionEntitiesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListMetaCollectionEntitiesResponseBody) GoString() string {
	return s.String()
}

func (s *ListMetaCollectionEntitiesResponseBody) SetData(v *ListMetaCollectionEntitiesResponseBodyData) *ListMetaCollectionEntitiesResponseBody {
	s.Data = v
	return s
}

func (s *ListMetaCollectionEntitiesResponseBody) SetErrorCode(v string) *ListMetaCollectionEntitiesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListMetaCollectionEntitiesResponseBody) SetErrorMessage(v string) *ListMetaCollectionEntitiesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListMetaCollectionEntitiesResponseBody) SetHttpStatusCode(v int32) *ListMetaCollectionEntitiesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListMetaCollectionEntitiesResponseBody) SetRequestId(v string) *ListMetaCollectionEntitiesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListMetaCollectionEntitiesResponseBody) SetSuccess(v bool) *ListMetaCollectionEntitiesResponseBody {
	s.Success = &v
	return s
}

type ListMetaCollectionEntitiesResponseBodyData struct {
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	EntityList []*Entity `json:"EntityList,omitempty" xml:"EntityList,omitempty" type:"Repeated"`
	// The entities.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s ListMetaCollectionEntitiesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListMetaCollectionEntitiesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListMetaCollectionEntitiesResponseBodyData) SetEntityList(v []*Entity) *ListMetaCollectionEntitiesResponseBodyData {
	s.EntityList = v
	return s
}

func (s *ListMetaCollectionEntitiesResponseBodyData) SetNextToken(v string) *ListMetaCollectionEntitiesResponseBodyData {
	s.NextToken = &v
	return s
}

type ListMetaCollectionEntitiesResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListMetaCollectionEntitiesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListMetaCollectionEntitiesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListMetaCollectionEntitiesResponse) GoString() string {
	return s.String()
}

func (s *ListMetaCollectionEntitiesResponse) SetHeaders(v map[string]*string) *ListMetaCollectionEntitiesResponse {
	s.Headers = v
	return s
}

func (s *ListMetaCollectionEntitiesResponse) SetStatusCode(v int32) *ListMetaCollectionEntitiesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListMetaCollectionEntitiesResponse) SetBody(v *ListMetaCollectionEntitiesResponseBody) *ListMetaCollectionEntitiesResponse {
	s.Body = v
	return s
}

type ListMetaCollectionsRequest struct {
	// The ID of the collection follower.
	Administrator *string `json:"Administrator,omitempty" xml:"Administrator,omitempty"`
	// The ID of the collection creator.
	CollectionType *string `json:"CollectionType,omitempty" xml:"CollectionType,omitempty"`
	// The ID of the collection administrator.
	Creator *string `json:"Creator,omitempty" xml:"Creator,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	Follower *string `json:"Follower,omitempty" xml:"Follower,omitempty"`
	// The name of the sorting field.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// ALBUM: data album
	//
	// ALBUM_CATEGORY: category in a data album
	OrderBy *string `json:"OrderBy,omitempty" xml:"OrderBy,omitempty"`
	// The keyword.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The paging information. This parameter specifies the start point of the query.
	ParentQualifiedName *string `json:"ParentQualifiedName,omitempty" xml:"ParentQualifiedName,omitempty"`
}

func (s ListMetaCollectionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListMetaCollectionsRequest) GoString() string {
	return s.String()
}

func (s *ListMetaCollectionsRequest) SetAdministrator(v string) *ListMetaCollectionsRequest {
	s.Administrator = &v
	return s
}

func (s *ListMetaCollectionsRequest) SetCollectionType(v string) *ListMetaCollectionsRequest {
	s.CollectionType = &v
	return s
}

func (s *ListMetaCollectionsRequest) SetCreator(v string) *ListMetaCollectionsRequest {
	s.Creator = &v
	return s
}

func (s *ListMetaCollectionsRequest) SetFollower(v string) *ListMetaCollectionsRequest {
	s.Follower = &v
	return s
}

func (s *ListMetaCollectionsRequest) SetKeyword(v string) *ListMetaCollectionsRequest {
	s.Keyword = &v
	return s
}

func (s *ListMetaCollectionsRequest) SetNextToken(v string) *ListMetaCollectionsRequest {
	s.NextToken = &v
	return s
}

func (s *ListMetaCollectionsRequest) SetOrderBy(v string) *ListMetaCollectionsRequest {
	s.OrderBy = &v
	return s
}

func (s *ListMetaCollectionsRequest) SetPageSize(v int32) *ListMetaCollectionsRequest {
	s.PageSize = &v
	return s
}

func (s *ListMetaCollectionsRequest) SetParentQualifiedName(v string) *ListMetaCollectionsRequest {
	s.ParentQualifiedName = &v
	return s
}

type ListMetaCollectionsResponseBody struct {
	// The token that is used for the next query.
	Data *ListMetaCollectionsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The HTTP status code returned.
	ErrorMessage   *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The object returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The error code returned.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListMetaCollectionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListMetaCollectionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListMetaCollectionsResponseBody) SetData(v *ListMetaCollectionsResponseBodyData) *ListMetaCollectionsResponseBody {
	s.Data = v
	return s
}

func (s *ListMetaCollectionsResponseBody) SetErrorCode(v string) *ListMetaCollectionsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListMetaCollectionsResponseBody) SetErrorMessage(v string) *ListMetaCollectionsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListMetaCollectionsResponseBody) SetHttpStatusCode(v int32) *ListMetaCollectionsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListMetaCollectionsResponseBody) SetRequestId(v string) *ListMetaCollectionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListMetaCollectionsResponseBody) SetSuccess(v bool) *ListMetaCollectionsResponseBody {
	s.Success = &v
	return s
}

type ListMetaCollectionsResponseBodyData struct {
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	CollectionList []*Collection `json:"CollectionList,omitempty" xml:"CollectionList,omitempty" type:"Repeated"`
	// The collections.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
}

func (s ListMetaCollectionsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListMetaCollectionsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListMetaCollectionsResponseBodyData) SetCollectionList(v []*Collection) *ListMetaCollectionsResponseBodyData {
	s.CollectionList = v
	return s
}

func (s *ListMetaCollectionsResponseBodyData) SetNextToken(v string) *ListMetaCollectionsResponseBodyData {
	s.NextToken = &v
	return s
}

type ListMetaCollectionsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListMetaCollectionsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListMetaCollectionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListMetaCollectionsResponse) GoString() string {
	return s.String()
}

func (s *ListMetaCollectionsResponse) SetHeaders(v map[string]*string) *ListMetaCollectionsResponse {
	s.Headers = v
	return s
}

func (s *ListMetaCollectionsResponse) SetStatusCode(v int32) *ListMetaCollectionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListMetaCollectionsResponse) SetBody(v *ListMetaCollectionsResponseBody) *ListMetaCollectionsResponse {
	s.Body = v
	return s
}

type ListMetaDBRequest struct {
	// The information of the metadatabases.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The ID of the E-MapReduce (EMR) cluster. You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The ID of the request.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of the page to return.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListMetaDBRequest) String() string {
	return tea.Prettify(s)
}

func (s ListMetaDBRequest) GoString() string {
	return s.String()
}

func (s *ListMetaDBRequest) SetClusterId(v string) *ListMetaDBRequest {
	s.ClusterId = &v
	return s
}

func (s *ListMetaDBRequest) SetDataSourceType(v string) *ListMetaDBRequest {
	s.DataSourceType = &v
	return s
}

func (s *ListMetaDBRequest) SetPageNum(v int32) *ListMetaDBRequest {
	s.PageNum = &v
	return s
}

func (s *ListMetaDBRequest) SetPageSize(v int32) *ListMetaDBRequest {
	s.PageSize = &v
	return s
}

func (s *ListMetaDBRequest) SetProjectId(v int64) *ListMetaDBRequest {
	s.ProjectId = &v
	return s
}

type ListMetaDBResponseBody struct {
	// The list of metadatabases.
	DatabaseInfo *ListMetaDBResponseBodyDatabaseInfo `json:"DatabaseInfo,omitempty" xml:"DatabaseInfo,omitempty" type:"Struct"`
	// The total number of the metadatabases.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListMetaDBResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListMetaDBResponseBody) GoString() string {
	return s.String()
}

func (s *ListMetaDBResponseBody) SetDatabaseInfo(v *ListMetaDBResponseBodyDatabaseInfo) *ListMetaDBResponseBody {
	s.DatabaseInfo = v
	return s
}

func (s *ListMetaDBResponseBody) SetRequestId(v string) *ListMetaDBResponseBody {
	s.RequestId = &v
	return s
}

type ListMetaDBResponseBodyDatabaseInfo struct {
	// The timestamp at which the metadatabase was created. You can convert the timestamp to the related date based on the time zone that you use.
	DbList []*ListMetaDBResponseBodyDatabaseInfoDbList `json:"DbList,omitempty" xml:"DbList,omitempty" type:"Repeated"`
	// The type of the metadatabase.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListMetaDBResponseBodyDatabaseInfo) String() string {
	return tea.Prettify(s)
}

func (s ListMetaDBResponseBodyDatabaseInfo) GoString() string {
	return s.String()
}

func (s *ListMetaDBResponseBodyDatabaseInfo) SetDbList(v []*ListMetaDBResponseBodyDatabaseInfoDbList) *ListMetaDBResponseBodyDatabaseInfo {
	s.DbList = v
	return s
}

func (s *ListMetaDBResponseBodyDatabaseInfo) SetTotalCount(v int64) *ListMetaDBResponseBodyDatabaseInfo {
	s.TotalCount = &v
	return s
}

type ListMetaDBResponseBodyDatabaseInfoDbList struct {
	// The timestamp at which the metadatabase was updated.
	CreateTimeStamp *int64  `json:"CreateTimeStamp,omitempty" xml:"CreateTimeStamp,omitempty"`
	Location        *string `json:"Location,omitempty" xml:"Location,omitempty"`
	// The ID of the metadatabase owner.
	ModifiedTimeStamp *int64 `json:"ModifiedTimeStamp,omitempty" xml:"ModifiedTimeStamp,omitempty"`
	// The URL of the metadatabase.
	Name    *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OwnerId *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The universally unique identifier (UUID) of the metadatabase.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The name of the metadatabase.
	UUID *string `json:"UUID,omitempty" xml:"UUID,omitempty"`
}

func (s ListMetaDBResponseBodyDatabaseInfoDbList) String() string {
	return tea.Prettify(s)
}

func (s ListMetaDBResponseBodyDatabaseInfoDbList) GoString() string {
	return s.String()
}

func (s *ListMetaDBResponseBodyDatabaseInfoDbList) SetCreateTimeStamp(v int64) *ListMetaDBResponseBodyDatabaseInfoDbList {
	s.CreateTimeStamp = &v
	return s
}

func (s *ListMetaDBResponseBodyDatabaseInfoDbList) SetLocation(v string) *ListMetaDBResponseBodyDatabaseInfoDbList {
	s.Location = &v
	return s
}

func (s *ListMetaDBResponseBodyDatabaseInfoDbList) SetModifiedTimeStamp(v int64) *ListMetaDBResponseBodyDatabaseInfoDbList {
	s.ModifiedTimeStamp = &v
	return s
}

func (s *ListMetaDBResponseBodyDatabaseInfoDbList) SetName(v string) *ListMetaDBResponseBodyDatabaseInfoDbList {
	s.Name = &v
	return s
}

func (s *ListMetaDBResponseBodyDatabaseInfoDbList) SetOwnerId(v string) *ListMetaDBResponseBodyDatabaseInfoDbList {
	s.OwnerId = &v
	return s
}

func (s *ListMetaDBResponseBodyDatabaseInfoDbList) SetType(v string) *ListMetaDBResponseBodyDatabaseInfoDbList {
	s.Type = &v
	return s
}

func (s *ListMetaDBResponseBodyDatabaseInfoDbList) SetUUID(v string) *ListMetaDBResponseBodyDatabaseInfoDbList {
	s.UUID = &v
	return s
}

type ListMetaDBResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListMetaDBResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListMetaDBResponse) String() string {
	return tea.Prettify(s)
}

func (s ListMetaDBResponse) GoString() string {
	return s.String()
}

func (s *ListMetaDBResponse) SetHeaders(v map[string]*string) *ListMetaDBResponse {
	s.Headers = v
	return s
}

func (s *ListMetaDBResponse) SetStatusCode(v int32) *ListMetaDBResponse {
	s.StatusCode = &v
	return s
}

func (s *ListMetaDBResponse) SetBody(v *ListMetaDBResponseBody) *ListMetaDBResponse {
	s.Body = v
	return s
}

type ListMigrationsRequest struct {
	// The ID of the owner.
	MigrationType *string `json:"MigrationType,omitempty" xml:"MigrationType,omitempty"`
	// The number of the page to return.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The number of entries to return on each page. Maximum value: 100.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the request.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of the migration task. Valid values: IMPORT and EXPORT.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListMigrationsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListMigrationsRequest) GoString() string {
	return s.String()
}

func (s *ListMigrationsRequest) SetMigrationType(v string) *ListMigrationsRequest {
	s.MigrationType = &v
	return s
}

func (s *ListMigrationsRequest) SetOwner(v string) *ListMigrationsRequest {
	s.Owner = &v
	return s
}

func (s *ListMigrationsRequest) SetPageNumber(v int32) *ListMigrationsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListMigrationsRequest) SetPageSize(v int32) *ListMigrationsRequest {
	s.PageSize = &v
	return s
}

func (s *ListMigrationsRequest) SetProjectId(v int64) *ListMigrationsRequest {
	s.ProjectId = &v
	return s
}

type ListMigrationsResponseBody struct {
	// The list of migration tasks.
	Data *ListMigrationsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The data returned.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListMigrationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListMigrationsResponseBody) GoString() string {
	return s.String()
}

func (s *ListMigrationsResponseBody) SetData(v *ListMigrationsResponseBodyData) *ListMigrationsResponseBody {
	s.Data = v
	return s
}

func (s *ListMigrationsResponseBody) SetRequestId(v string) *ListMigrationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListMigrationsResponseBody) SetSuccess(v bool) *ListMigrationsResponseBody {
	s.Success = &v
	return s
}

type ListMigrationsResponseBodyData struct {
	// The ID of the primary key.
	Migrations []*ListMigrationsResponseBodyDataMigrations `json:"Migrations,omitempty" xml:"Migrations,omitempty" type:"Repeated"`
	// The number of entries returned per page. Default value: 10. Maximum value: 50.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The total number of entries returned.
	PageSize   *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListMigrationsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListMigrationsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListMigrationsResponseBodyData) SetMigrations(v []*ListMigrationsResponseBodyDataMigrations) *ListMigrationsResponseBodyData {
	s.Migrations = v
	return s
}

func (s *ListMigrationsResponseBodyData) SetPageNumber(v int32) *ListMigrationsResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListMigrationsResponseBodyData) SetPageSize(v int32) *ListMigrationsResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListMigrationsResponseBodyData) SetTotalCount(v int32) *ListMigrationsResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListMigrationsResponseBodyDataMigrations struct {
	// The time when the migration task was last updated.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The name of the user who created the migration task.
	CreateUser *string `json:"CreateUser,omitempty" xml:"CreateUser,omitempty"`
	// The ID of the user who last updated the migration task.
	CreateUserName *string `json:"CreateUserName,omitempty" xml:"CreateUserName,omitempty"`
	// The page number of the returned page.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The description of the export task.
	DownloadUrl *string `json:"DownloadUrl,omitempty" xml:"DownloadUrl,omitempty"`
	// The name of the migration task.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The URL that is used to download the package of the export task. You can use the URL to download the package of the export task.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The time when the migration task was created.
	MigrationType *string `json:"MigrationType,omitempty" xml:"MigrationType,omitempty"`
	// The type of the import or export package. Valid values:
	//
	// *   DWMA (standard format)
	// *   DATAWORKS_MODEL (standard format)
	// *   DATAWORKS_V2 (Apsara Stack DataWorks V3.6.1 to V3.11)
	// *   DATAWORKS_V3 (Apsara Stack DataWorks V3.12 and later)
	//
	// The DWMA and DATAWORKS_MODEL types are interchangeable.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The type of the migration task.
	//
	// *   IMPORT
	// *   EXPORT
	PackageType *string `json:"PackageType,omitempty" xml:"PackageType,omitempty"`
	// The ID of the tenant.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The error message returned.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The status of the migration task. Valid values:
	//
	// *   INIT: The migration task is in the initial state.
	// *   EDITING: The migration task is being edited.
	// *   RUNNING: The migration task is running.
	// *   FAILURE: The migration task fails to run.
	// *   SUCCESS: The migration task is successfully run.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	// The ID of the user who created the migration task.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
	// The name of the user who last updated the migration task.
	UpdateUser *string `json:"UpdateUser,omitempty" xml:"UpdateUser,omitempty"`
	// The ID of the DataWorks workspace to which the task belongs.
	UpdateUserName *string `json:"UpdateUserName,omitempty" xml:"UpdateUserName,omitempty"`
}

func (s ListMigrationsResponseBodyDataMigrations) String() string {
	return tea.Prettify(s)
}

func (s ListMigrationsResponseBodyDataMigrations) GoString() string {
	return s.String()
}

func (s *ListMigrationsResponseBodyDataMigrations) SetCreateTime(v int64) *ListMigrationsResponseBodyDataMigrations {
	s.CreateTime = &v
	return s
}

func (s *ListMigrationsResponseBodyDataMigrations) SetCreateUser(v string) *ListMigrationsResponseBodyDataMigrations {
	s.CreateUser = &v
	return s
}

func (s *ListMigrationsResponseBodyDataMigrations) SetCreateUserName(v string) *ListMigrationsResponseBodyDataMigrations {
	s.CreateUserName = &v
	return s
}

func (s *ListMigrationsResponseBodyDataMigrations) SetDescription(v string) *ListMigrationsResponseBodyDataMigrations {
	s.Description = &v
	return s
}

func (s *ListMigrationsResponseBodyDataMigrations) SetDownloadUrl(v string) *ListMigrationsResponseBodyDataMigrations {
	s.DownloadUrl = &v
	return s
}

func (s *ListMigrationsResponseBodyDataMigrations) SetId(v int64) *ListMigrationsResponseBodyDataMigrations {
	s.Id = &v
	return s
}

func (s *ListMigrationsResponseBodyDataMigrations) SetMessage(v string) *ListMigrationsResponseBodyDataMigrations {
	s.Message = &v
	return s
}

func (s *ListMigrationsResponseBodyDataMigrations) SetMigrationType(v string) *ListMigrationsResponseBodyDataMigrations {
	s.MigrationType = &v
	return s
}

func (s *ListMigrationsResponseBodyDataMigrations) SetName(v string) *ListMigrationsResponseBodyDataMigrations {
	s.Name = &v
	return s
}

func (s *ListMigrationsResponseBodyDataMigrations) SetPackageType(v string) *ListMigrationsResponseBodyDataMigrations {
	s.PackageType = &v
	return s
}

func (s *ListMigrationsResponseBodyDataMigrations) SetProjectId(v int64) *ListMigrationsResponseBodyDataMigrations {
	s.ProjectId = &v
	return s
}

func (s *ListMigrationsResponseBodyDataMigrations) SetStatus(v string) *ListMigrationsResponseBodyDataMigrations {
	s.Status = &v
	return s
}

func (s *ListMigrationsResponseBodyDataMigrations) SetTenantId(v int64) *ListMigrationsResponseBodyDataMigrations {
	s.TenantId = &v
	return s
}

func (s *ListMigrationsResponseBodyDataMigrations) SetUpdateTime(v int64) *ListMigrationsResponseBodyDataMigrations {
	s.UpdateTime = &v
	return s
}

func (s *ListMigrationsResponseBodyDataMigrations) SetUpdateUser(v string) *ListMigrationsResponseBodyDataMigrations {
	s.UpdateUser = &v
	return s
}

func (s *ListMigrationsResponseBodyDataMigrations) SetUpdateUserName(v string) *ListMigrationsResponseBodyDataMigrations {
	s.UpdateUserName = &v
	return s
}

type ListMigrationsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListMigrationsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListMigrationsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListMigrationsResponse) GoString() string {
	return s.String()
}

func (s *ListMigrationsResponse) SetHeaders(v map[string]*string) *ListMigrationsResponse {
	s.Headers = v
	return s
}

func (s *ListMigrationsResponse) SetStatusCode(v int32) *ListMigrationsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListMigrationsResponse) SetBody(v *ListMigrationsResponseBody) *ListMigrationsResponse {
	s.Body = v
	return s
}

type ListNodeIORequest struct {
	IoType     *string `json:"IoType,omitempty" xml:"IoType,omitempty"`
	NodeId     *int64  `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s ListNodeIORequest) String() string {
	return tea.Prettify(s)
}

func (s ListNodeIORequest) GoString() string {
	return s.String()
}

func (s *ListNodeIORequest) SetIoType(v string) *ListNodeIORequest {
	s.IoType = &v
	return s
}

func (s *ListNodeIORequest) SetNodeId(v int64) *ListNodeIORequest {
	s.NodeId = &v
	return s
}

func (s *ListNodeIORequest) SetProjectEnv(v string) *ListNodeIORequest {
	s.ProjectEnv = &v
	return s
}

type ListNodeIOResponseBody struct {
	Data           []*ListNodeIOResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	ErrorCode      *string                       `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string                       `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32                        `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                         `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListNodeIOResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListNodeIOResponseBody) GoString() string {
	return s.String()
}

func (s *ListNodeIOResponseBody) SetData(v []*ListNodeIOResponseBodyData) *ListNodeIOResponseBody {
	s.Data = v
	return s
}

func (s *ListNodeIOResponseBody) SetErrorCode(v string) *ListNodeIOResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListNodeIOResponseBody) SetErrorMessage(v string) *ListNodeIOResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListNodeIOResponseBody) SetHttpStatusCode(v int32) *ListNodeIOResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListNodeIOResponseBody) SetRequestId(v string) *ListNodeIOResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListNodeIOResponseBody) SetSuccess(v bool) *ListNodeIOResponseBody {
	s.Success = &v
	return s
}

type ListNodeIOResponseBodyData struct {
	Data      *string `json:"Data,omitempty" xml:"Data,omitempty"`
	NodeId    *int64  `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s ListNodeIOResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListNodeIOResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListNodeIOResponseBodyData) SetData(v string) *ListNodeIOResponseBodyData {
	s.Data = &v
	return s
}

func (s *ListNodeIOResponseBodyData) SetNodeId(v int64) *ListNodeIOResponseBodyData {
	s.NodeId = &v
	return s
}

func (s *ListNodeIOResponseBodyData) SetTableName(v string) *ListNodeIOResponseBodyData {
	s.TableName = &v
	return s
}

type ListNodeIOResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListNodeIOResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListNodeIOResponse) String() string {
	return tea.Prettify(s)
}

func (s ListNodeIOResponse) GoString() string {
	return s.String()
}

func (s *ListNodeIOResponse) SetHeaders(v map[string]*string) *ListNodeIOResponse {
	s.Headers = v
	return s
}

func (s *ListNodeIOResponse) SetStatusCode(v int32) *ListNodeIOResponse {
	s.StatusCode = &v
	return s
}

func (s *ListNodeIOResponse) SetBody(v *ListNodeIOResponseBody) *ListNodeIOResponse {
	s.Body = v
	return s
}

type ListNodeInputOrOutputRequest struct {
	// The type of node that you want to query. Valid values:
	//
	// *   input: ancestor nodes
	// *   output: descendant nodes
	IoType *string `json:"IoType,omitempty" xml:"IoType,omitempty"`
	// The ID of the node. You can call the [ListNodes](~~173979~~) operation to query the node ID.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The environment of the workspace. Valid values: DEV and PROD. A value of DEV indicates the development environment. A value of PROD indicates the production environment.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s ListNodeInputOrOutputRequest) String() string {
	return tea.Prettify(s)
}

func (s ListNodeInputOrOutputRequest) GoString() string {
	return s.String()
}

func (s *ListNodeInputOrOutputRequest) SetIoType(v string) *ListNodeInputOrOutputRequest {
	s.IoType = &v
	return s
}

func (s *ListNodeInputOrOutputRequest) SetNodeId(v int64) *ListNodeInputOrOutputRequest {
	s.NodeId = &v
	return s
}

func (s *ListNodeInputOrOutputRequest) SetProjectEnv(v string) *ListNodeInputOrOutputRequest {
	s.ProjectEnv = &v
	return s
}

type ListNodeInputOrOutputResponseBody struct {
	// The ancestor or descendant nodes.
	Data []*ListNodeInputOrOutputResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned if the request fails.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListNodeInputOrOutputResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListNodeInputOrOutputResponseBody) GoString() string {
	return s.String()
}

func (s *ListNodeInputOrOutputResponseBody) SetData(v []*ListNodeInputOrOutputResponseBodyData) *ListNodeInputOrOutputResponseBody {
	s.Data = v
	return s
}

func (s *ListNodeInputOrOutputResponseBody) SetErrorCode(v string) *ListNodeInputOrOutputResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListNodeInputOrOutputResponseBody) SetErrorMessage(v string) *ListNodeInputOrOutputResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListNodeInputOrOutputResponseBody) SetHttpStatusCode(v int32) *ListNodeInputOrOutputResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListNodeInputOrOutputResponseBody) SetRequestId(v string) *ListNodeInputOrOutputResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListNodeInputOrOutputResponseBody) SetSuccess(v bool) *ListNodeInputOrOutputResponseBody {
	s.Success = &v
	return s
}

type ListNodeInputOrOutputResponseBodyData struct {
	// The name of the ancestor or descendant node.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the associated table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s ListNodeInputOrOutputResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListNodeInputOrOutputResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListNodeInputOrOutputResponseBodyData) SetData(v string) *ListNodeInputOrOutputResponseBodyData {
	s.Data = &v
	return s
}

func (s *ListNodeInputOrOutputResponseBodyData) SetNodeId(v int64) *ListNodeInputOrOutputResponseBodyData {
	s.NodeId = &v
	return s
}

func (s *ListNodeInputOrOutputResponseBodyData) SetTableName(v string) *ListNodeInputOrOutputResponseBodyData {
	s.TableName = &v
	return s
}

type ListNodeInputOrOutputResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListNodeInputOrOutputResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListNodeInputOrOutputResponse) String() string {
	return tea.Prettify(s)
}

func (s ListNodeInputOrOutputResponse) GoString() string {
	return s.String()
}

func (s *ListNodeInputOrOutputResponse) SetHeaders(v map[string]*string) *ListNodeInputOrOutputResponse {
	s.Headers = v
	return s
}

func (s *ListNodeInputOrOutputResponse) SetStatusCode(v int32) *ListNodeInputOrOutputResponse {
	s.StatusCode = &v
	return s
}

func (s *ListNodeInputOrOutputResponse) SetBody(v *ListNodeInputOrOutputResponseBody) *ListNodeInputOrOutputResponse {
	s.Body = v
	return s
}

type ListNodesRequest struct {
	// The error code returned.
	BizName *string `json:"BizName,omitempty" xml:"BizName,omitempty"`
	// The ID of the baseline with which the node is associated.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The description of the node.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The ID of the workspace.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The operation that you want to perform. Set the value to **ListNodes**.
	ProgramType *string `json:"ProgramType,omitempty" xml:"ProgramType,omitempty"`
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
	// The ID of the owner.
	ProjectId     *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	SchedulerType *string `json:"SchedulerType,omitempty" xml:"SchedulerType,omitempty"`
}

func (s ListNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListNodesRequest) GoString() string {
	return s.String()
}

func (s *ListNodesRequest) SetBizName(v string) *ListNodesRequest {
	s.BizName = &v
	return s
}

func (s *ListNodesRequest) SetNodeName(v string) *ListNodesRequest {
	s.NodeName = &v
	return s
}

func (s *ListNodesRequest) SetOwner(v string) *ListNodesRequest {
	s.Owner = &v
	return s
}

func (s *ListNodesRequest) SetPageNumber(v int32) *ListNodesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListNodesRequest) SetPageSize(v int32) *ListNodesRequest {
	s.PageSize = &v
	return s
}

func (s *ListNodesRequest) SetProgramType(v string) *ListNodesRequest {
	s.ProgramType = &v
	return s
}

func (s *ListNodesRequest) SetProjectEnv(v string) *ListNodesRequest {
	s.ProjectEnv = &v
	return s
}

func (s *ListNodesRequest) SetProjectId(v int64) *ListNodesRequest {
	s.ProjectId = &v
	return s
}

func (s *ListNodesRequest) SetSchedulerType(v string) *ListNodesRequest {
	s.SchedulerType = &v
	return s
}

type ListNodesResponseBody struct {
	// The ID of the associated workflow.
	Data *ListNodesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The HTTP status code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The page number of the returned page.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The interval at which the node is rerun after the node fails to run.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The list of nodes.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the node can be rerun.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListNodesResponseBody) GoString() string {
	return s.String()
}

func (s *ListNodesResponseBody) SetData(v *ListNodesResponseBodyData) *ListNodesResponseBody {
	s.Data = v
	return s
}

func (s *ListNodesResponseBody) SetErrorCode(v string) *ListNodesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListNodesResponseBody) SetErrorMessage(v string) *ListNodesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListNodesResponseBody) SetHttpStatusCode(v int32) *ListNodesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListNodesResponseBody) SetRequestId(v string) *ListNodesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListNodesResponseBody) SetSuccess(v bool) *ListNodesResponseBody {
	s.Success = &v
	return s
}

type ListNodesResponseBodyData struct {
	// The scheduling type of the node. Valid values:
	//
	// *   NORMAL: indicates that the node is a normal auto triggered node.
	// *   MANUAL: indicates that the node is a manually triggered node.
	// *   PAUSE: indicates that the node is a paused node.
	// *   SKIP: indicates that the node is a dry-run node. Dry-run nodes are started as scheduled but the system sets the status of the nodes to successful when it starts to run them.
	Nodes []*ListNodesResponseBodyDataNodes `json:"Nodes,omitempty" xml:"Nodes,omitempty" type:"Repeated"`
	// The name of the node.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The cron expression returned.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The name of the workflow.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListNodesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListNodesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListNodesResponseBodyData) SetNodes(v []*ListNodesResponseBodyDataNodes) *ListNodesResponseBodyData {
	s.Nodes = v
	return s
}

func (s *ListNodesResponseBodyData) SetPageNumber(v int32) *ListNodesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListNodesResponseBodyData) SetPageSize(v int32) *ListNodesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListNodesResponseBodyData) SetTotalCount(v int32) *ListNodesResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListNodesResponseBodyDataNodes struct {
	// The number of the page to return. Minimum value: 1. Maximum value: 100.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The operation that you want to perform. Set the value to **ListNodes**.
	BusinessId *int64 `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	// The name of the resource group.
	Connection *string `json:"Connection,omitempty" xml:"Connection,omitempty"`
	// The name of the workflow.
	CronExpress *string `json:"CronExpress,omitempty" xml:"CronExpress,omitempty"`
	// The priority for running the node. Valid values: 1, 3, 5, 7, and 8.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the owner.
	DqcDescription *string `json:"DqcDescription,omitempty" xml:"DqcDescription,omitempty"`
	// The connection string.
	DqcType  *int32 `json:"DqcType,omitempty" xml:"DqcType,omitempty"`
	FileType *int32 `json:"FileType,omitempty" xml:"FileType,omitempty"`
	// The types of the nodes. You can call the [ListNodes](~~173979~~) operation to query the type of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The total number of nodes returned.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The additional parameters.
	OwnerId *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The type of the node.
	ParamValues *string `json:"ParamValues,omitempty" xml:"ParamValues,omitempty"`
	// The ID of the owner.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The error message returned.
	ProgramType *string `json:"ProgramType,omitempty" xml:"ProgramType,omitempty"`
	// The information about the nodes.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The table and partition filter expression in Data Quality that are associated with the node.
	RelatedFlowId *int64 `json:"RelatedFlowId,omitempty" xml:"RelatedFlowId,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV.
	RepeatInterval *int64 `json:"RepeatInterval,omitempty" xml:"RepeatInterval,omitempty"`
	// The name of the node.
	Repeatability      *bool   `json:"Repeatability,omitempty" xml:"Repeatability,omitempty"`
	ResGroupIdentifier *string `json:"ResGroupIdentifier,omitempty" xml:"ResGroupIdentifier,omitempty"`
	// The ID of the workflow.
	ResGroupName *string `json:"ResGroupName,omitempty" xml:"ResGroupName,omitempty"`
	// The types of the nodes. You can call the [ListNodes](~~173979~~) operation to query the type of the node.
	SchedulerType *string `json:"SchedulerType,omitempty" xml:"SchedulerType,omitempty"`
}

func (s ListNodesResponseBodyDataNodes) String() string {
	return tea.Prettify(s)
}

func (s ListNodesResponseBodyDataNodes) GoString() string {
	return s.String()
}

func (s *ListNodesResponseBodyDataNodes) SetBaselineId(v int64) *ListNodesResponseBodyDataNodes {
	s.BaselineId = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetBusinessId(v int64) *ListNodesResponseBodyDataNodes {
	s.BusinessId = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetConnection(v string) *ListNodesResponseBodyDataNodes {
	s.Connection = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetCronExpress(v string) *ListNodesResponseBodyDataNodes {
	s.CronExpress = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetDescription(v string) *ListNodesResponseBodyDataNodes {
	s.Description = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetDqcDescription(v string) *ListNodesResponseBodyDataNodes {
	s.DqcDescription = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetDqcType(v int32) *ListNodesResponseBodyDataNodes {
	s.DqcType = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetFileType(v int32) *ListNodesResponseBodyDataNodes {
	s.FileType = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetNodeId(v int64) *ListNodesResponseBodyDataNodes {
	s.NodeId = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetNodeName(v string) *ListNodesResponseBodyDataNodes {
	s.NodeName = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetOwnerId(v string) *ListNodesResponseBodyDataNodes {
	s.OwnerId = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetParamValues(v string) *ListNodesResponseBodyDataNodes {
	s.ParamValues = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetPriority(v int32) *ListNodesResponseBodyDataNodes {
	s.Priority = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetProgramType(v string) *ListNodesResponseBodyDataNodes {
	s.ProgramType = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetProjectId(v int64) *ListNodesResponseBodyDataNodes {
	s.ProjectId = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetRelatedFlowId(v int64) *ListNodesResponseBodyDataNodes {
	s.RelatedFlowId = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetRepeatInterval(v int64) *ListNodesResponseBodyDataNodes {
	s.RepeatInterval = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetRepeatability(v bool) *ListNodesResponseBodyDataNodes {
	s.Repeatability = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetResGroupIdentifier(v string) *ListNodesResponseBodyDataNodes {
	s.ResGroupIdentifier = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetResGroupName(v string) *ListNodesResponseBodyDataNodes {
	s.ResGroupName = &v
	return s
}

func (s *ListNodesResponseBodyDataNodes) SetSchedulerType(v string) *ListNodesResponseBodyDataNodes {
	s.SchedulerType = &v
	return s
}

type ListNodesResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListNodesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListNodesResponse) GoString() string {
	return s.String()
}

func (s *ListNodesResponse) SetHeaders(v map[string]*string) *ListNodesResponse {
	s.Headers = v
	return s
}

func (s *ListNodesResponse) SetStatusCode(v int32) *ListNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListNodesResponse) SetBody(v *ListNodesResponseBody) *ListNodesResponse {
	s.Body = v
	return s
}

type ListNodesByBaselineRequest struct {
	// The ID of the request. You can use the ID to troubleshoot issues.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
}

func (s ListNodesByBaselineRequest) String() string {
	return tea.Prettify(s)
}

func (s ListNodesByBaselineRequest) GoString() string {
	return s.String()
}

func (s *ListNodesByBaselineRequest) SetBaselineId(v int64) *ListNodesByBaselineRequest {
	s.BaselineId = &v
	return s
}

type ListNodesByBaselineResponseBody struct {
	// The name of the node.
	Data []*ListNodesByBaselineResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The nodes in the baseline.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request is successful.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The error message returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error code returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the Alibaba Cloud account used by the node owner.
	Success *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListNodesByBaselineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListNodesByBaselineResponseBody) GoString() string {
	return s.String()
}

func (s *ListNodesByBaselineResponseBody) SetData(v []*ListNodesByBaselineResponseBodyData) *ListNodesByBaselineResponseBody {
	s.Data = v
	return s
}

func (s *ListNodesByBaselineResponseBody) SetErrorCode(v string) *ListNodesByBaselineResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListNodesByBaselineResponseBody) SetErrorMessage(v string) *ListNodesByBaselineResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListNodesByBaselineResponseBody) SetHttpStatusCode(v int32) *ListNodesByBaselineResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListNodesByBaselineResponseBody) SetRequestId(v string) *ListNodesByBaselineResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListNodesByBaselineResponseBody) SetSuccess(v string) *ListNodesByBaselineResponseBody {
	s.Success = &v
	return s
}

type ListNodesByBaselineResponseBodyData struct {
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the workspace to which the node belongs.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The ID of the node.
	Owner     *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	ProjectId *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListNodesByBaselineResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListNodesByBaselineResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListNodesByBaselineResponseBodyData) SetNodeId(v int64) *ListNodesByBaselineResponseBodyData {
	s.NodeId = &v
	return s
}

func (s *ListNodesByBaselineResponseBodyData) SetNodeName(v string) *ListNodesByBaselineResponseBodyData {
	s.NodeName = &v
	return s
}

func (s *ListNodesByBaselineResponseBodyData) SetOwner(v string) *ListNodesByBaselineResponseBodyData {
	s.Owner = &v
	return s
}

func (s *ListNodesByBaselineResponseBodyData) SetProjectId(v int64) *ListNodesByBaselineResponseBodyData {
	s.ProjectId = &v
	return s
}

type ListNodesByBaselineResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListNodesByBaselineResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListNodesByBaselineResponse) String() string {
	return tea.Prettify(s)
}

func (s ListNodesByBaselineResponse) GoString() string {
	return s.String()
}

func (s *ListNodesByBaselineResponse) SetHeaders(v map[string]*string) *ListNodesByBaselineResponse {
	s.Headers = v
	return s
}

func (s *ListNodesByBaselineResponse) SetStatusCode(v int32) *ListNodesByBaselineResponse {
	s.StatusCode = &v
	return s
}

func (s *ListNodesByBaselineResponse) SetBody(v *ListNodesByBaselineResponseBody) *ListNodesByBaselineResponse {
	s.Body = v
	return s
}

type ListNodesByOutputRequest struct {
	// The output name of the node. You can specify multiple output names. In this case, separate them with commas (,).
	Outputs *string `json:"Outputs,omitempty" xml:"Outputs,omitempty"`
	// The environment type. Valid values: PROD and DEV. The value PROD indicates the production environment. The value DEV indicates the development environment.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s ListNodesByOutputRequest) String() string {
	return tea.Prettify(s)
}

func (s ListNodesByOutputRequest) GoString() string {
	return s.String()
}

func (s *ListNodesByOutputRequest) SetOutputs(v string) *ListNodesByOutputRequest {
	s.Outputs = &v
	return s
}

func (s *ListNodesByOutputRequest) SetProjectEnv(v string) *ListNodesByOutputRequest {
	s.ProjectEnv = &v
	return s
}

type ListNodesByOutputResponseBody struct {
	// The nodes returned.
	Data []*ListNodesByOutputResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListNodesByOutputResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListNodesByOutputResponseBody) GoString() string {
	return s.String()
}

func (s *ListNodesByOutputResponseBody) SetData(v []*ListNodesByOutputResponseBodyData) *ListNodesByOutputResponseBody {
	s.Data = v
	return s
}

func (s *ListNodesByOutputResponseBody) SetErrorCode(v string) *ListNodesByOutputResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListNodesByOutputResponseBody) SetErrorMessage(v string) *ListNodesByOutputResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListNodesByOutputResponseBody) SetHttpStatusCode(v int32) *ListNodesByOutputResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListNodesByOutputResponseBody) SetRequestId(v string) *ListNodesByOutputResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListNodesByOutputResponseBody) SetSuccess(v bool) *ListNodesByOutputResponseBody {
	s.Success = &v
	return s
}

type ListNodesByOutputResponseBodyData struct {
	// The information of the nodes returned.
	NodeList []*ListNodesByOutputResponseBodyDataNodeList `json:"NodeList,omitempty" xml:"NodeList,omitempty" type:"Repeated"`
	// The output name of the current node.
	Output *string `json:"Output,omitempty" xml:"Output,omitempty"`
}

func (s ListNodesByOutputResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListNodesByOutputResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListNodesByOutputResponseBodyData) SetNodeList(v []*ListNodesByOutputResponseBodyDataNodeList) *ListNodesByOutputResponseBodyData {
	s.NodeList = v
	return s
}

func (s *ListNodesByOutputResponseBodyData) SetOutput(v string) *ListNodesByOutputResponseBodyData {
	s.Output = &v
	return s
}

type ListNodesByOutputResponseBodyDataNodeList struct {
	// The ID of the baseline.
	BaselineId *int64 `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	// The name of the data source.
	Connection *string `json:"Connection,omitempty" xml:"Connection,omitempty"`
	// The cron expression.
	CronExpress *string `json:"CronExpress,omitempty" xml:"CronExpress,omitempty"`
	// The description of the node.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The table and partition filter expression in Data Quality that are associated with the node.
	DqcDescription *string `json:"DqcDescription,omitempty" xml:"DqcDescription,omitempty"`
	// Indicates whether the node is associated with Data Quality. Valid values: 0 and 1. The value 0 indicates that node is associated with Data Quality, and the value 1 indicates that the node is not associated with Data Quality.
	DqcType *int32 `json:"DqcType,omitempty" xml:"DqcType,omitempty"`
	// The type of the node.
	//
	// Valid values:
	//
	// 6 (Shell node), 10 (ODPS SQL node), 11 (ODPS MR node), 23 (Data Integration node), 24 (ODPS Script node), 99 (zero-load node), 221 (PyODPS 2 node), 225 (ODPS Spark node), 227 (EMR Hive node), 228 (EMR Spark node), 229 (EMR Spark SQL node), 230 (EMR MR node), 239 (OSS object inspection node), 257 (EMR Shell node), 258 (EMR Spark Shell node), 259 (EMR Presto node), 260 (EMR Impala node), 900 (real-time synchronization node), 1089 (cross-tenant collaboration node), 1091 (Hologres development node), 1093 (Hologres SQL node), 1100 (assignment node), and 1221 (PyODPS 3 node).
	FileType *string `json:"FileType,omitempty" xml:"FileType,omitempty"`
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The ID of the node owner.
	OwnerId *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The values of the scheduling parameters configured for the node.
	ParamValues *string `json:"ParamValues,omitempty" xml:"ParamValues,omitempty"`
	// The priority of the node. Valid values: 1, 3, 5, 7, and 8. A large value indicates a high priority. Default value: 1.
	Priority *int32 `json:"Priority,omitempty" xml:"Priority,omitempty"`
	// The type of the node. This parameter is deprecated. For more information about node types, see the valid values of FileType.
	ProgramType *string `json:"ProgramType,omitempty" xml:"ProgramType,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the associated workflow.
	RelatedFlowId *int64 `json:"RelatedFlowId,omitempty" xml:"RelatedFlowId,omitempty"`
	// The interval at which the node is rerun after the node fails to run.
	RepeatInterval *int32 `json:"RepeatInterval,omitempty" xml:"RepeatInterval,omitempty"`
	// Indicates whether the node can be rerun.
	Repeatability *bool `json:"Repeatability,omitempty" xml:"Repeatability,omitempty"`
	// The name of the resource group.
	ResGroupName *string `json:"ResGroupName,omitempty" xml:"ResGroupName,omitempty"`
	// The scheduling type of the node. Valid values:
	//
	// *   NORAMAL: The node is an auto triggered node. The node is scheduled on a regular basis.
	// *   MANUAL: The node is a manually triggered node. The node is not scheduled on a regular basis.
	// *   PAUSE: The node is a frozen node. The system schedules the node on a regular basis but sets it to FAILURE when the system starts to schedule it.
	// *   SKIP: The node is a dry-run node. The system schedules the node on a regular basis but sets it to SUCCESS when the system starts to schedule it.
	SchedulerType *string `json:"SchedulerType,omitempty" xml:"SchedulerType,omitempty"`
}

func (s ListNodesByOutputResponseBodyDataNodeList) String() string {
	return tea.Prettify(s)
}

func (s ListNodesByOutputResponseBodyDataNodeList) GoString() string {
	return s.String()
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetBaselineId(v int64) *ListNodesByOutputResponseBodyDataNodeList {
	s.BaselineId = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetConnection(v string) *ListNodesByOutputResponseBodyDataNodeList {
	s.Connection = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetCronExpress(v string) *ListNodesByOutputResponseBodyDataNodeList {
	s.CronExpress = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetDescription(v string) *ListNodesByOutputResponseBodyDataNodeList {
	s.Description = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetDqcDescription(v string) *ListNodesByOutputResponseBodyDataNodeList {
	s.DqcDescription = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetDqcType(v int32) *ListNodesByOutputResponseBodyDataNodeList {
	s.DqcType = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetFileType(v string) *ListNodesByOutputResponseBodyDataNodeList {
	s.FileType = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetNodeId(v int64) *ListNodesByOutputResponseBodyDataNodeList {
	s.NodeId = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetNodeName(v string) *ListNodesByOutputResponseBodyDataNodeList {
	s.NodeName = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetOwnerId(v string) *ListNodesByOutputResponseBodyDataNodeList {
	s.OwnerId = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetParamValues(v string) *ListNodesByOutputResponseBodyDataNodeList {
	s.ParamValues = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetPriority(v int32) *ListNodesByOutputResponseBodyDataNodeList {
	s.Priority = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetProgramType(v string) *ListNodesByOutputResponseBodyDataNodeList {
	s.ProgramType = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetProjectId(v int64) *ListNodesByOutputResponseBodyDataNodeList {
	s.ProjectId = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetRelatedFlowId(v int64) *ListNodesByOutputResponseBodyDataNodeList {
	s.RelatedFlowId = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetRepeatInterval(v int32) *ListNodesByOutputResponseBodyDataNodeList {
	s.RepeatInterval = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetRepeatability(v bool) *ListNodesByOutputResponseBodyDataNodeList {
	s.Repeatability = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetResGroupName(v string) *ListNodesByOutputResponseBodyDataNodeList {
	s.ResGroupName = &v
	return s
}

func (s *ListNodesByOutputResponseBodyDataNodeList) SetSchedulerType(v string) *ListNodesByOutputResponseBodyDataNodeList {
	s.SchedulerType = &v
	return s
}

type ListNodesByOutputResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListNodesByOutputResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListNodesByOutputResponse) String() string {
	return tea.Prettify(s)
}

func (s ListNodesByOutputResponse) GoString() string {
	return s.String()
}

func (s *ListNodesByOutputResponse) SetHeaders(v map[string]*string) *ListNodesByOutputResponse {
	s.Headers = v
	return s
}

func (s *ListNodesByOutputResponse) SetStatusCode(v int32) *ListNodesByOutputResponse {
	s.StatusCode = &v
	return s
}

func (s *ListNodesByOutputResponse) SetBody(v *ListNodesByOutputResponseBody) *ListNodesByOutputResponse {
	s.Body = v
	return s
}

type ListPermissionApplyOrdersRequest struct {
	// The end time. You can query all permission request orders that have been submitted before the time. The parameter value is a UNIX timestamp. If you do not specify the parameter, all permission request orders that are submitted before the current time are queried.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The type of the compute engine with which the permission request order is associated. The parameter value is odps and cannot be changed. This value indicates that you can request permissions only on fields of tables in MaxCompute compute engine instances.
	EngineType *string `json:"EngineType,omitempty" xml:"EngineType,omitempty"`
	// The status of the permission request order. Valid values:
	//
	// *   1: pending approval
	// *   2: approved and authorized
	// *   3: approved but authorization failed
	// *   4: rejected
	FlowStatus *int32 `json:"FlowStatus,omitempty" xml:"FlowStatus,omitempty"`
	// The name of the MaxCompute project to which the permission request order belongs. If you do not specify the parameter, the permission request orders of all MaxCompute projects are returned.
	MaxComputeProjectName *string `json:"MaxComputeProjectName,omitempty" xml:"MaxComputeProjectName,omitempty"`
	// The type of the permission request order. The parameter value is 1 and cannot be changed. This value indicates ACL-based authorization.
	OrderType *int32 `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	// The number of the page to return. Pages start from page 1. Default value: 1.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The query type of the permission request order. Valid values:
	//
	// *   0: The permission request orders you submitted.
	// *   1: The permission request orders you approved.
	QueryType *int32 `json:"QueryType,omitempty" xml:"QueryType,omitempty"`
	// The start time. You can query all permission request orders that have been submitted after the time. The parameter value is a UNIX timestamp. If you do not specify the parameter, all permission request orders are queried.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	// The name of the table with which the permission request order is associated. If you do not specify the parameter, the permission request orders of all tables are returned.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the DataWorks workspace to which the permission request order belongs. If you do not specify the parameter, the permission request orders of all workspaces are returned. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID.
	WorkspaceId *int32 `json:"WorkspaceId,omitempty" xml:"WorkspaceId,omitempty"`
}

func (s ListPermissionApplyOrdersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListPermissionApplyOrdersRequest) GoString() string {
	return s.String()
}

func (s *ListPermissionApplyOrdersRequest) SetEndTime(v int64) *ListPermissionApplyOrdersRequest {
	s.EndTime = &v
	return s
}

func (s *ListPermissionApplyOrdersRequest) SetEngineType(v string) *ListPermissionApplyOrdersRequest {
	s.EngineType = &v
	return s
}

func (s *ListPermissionApplyOrdersRequest) SetFlowStatus(v int32) *ListPermissionApplyOrdersRequest {
	s.FlowStatus = &v
	return s
}

func (s *ListPermissionApplyOrdersRequest) SetMaxComputeProjectName(v string) *ListPermissionApplyOrdersRequest {
	s.MaxComputeProjectName = &v
	return s
}

func (s *ListPermissionApplyOrdersRequest) SetOrderType(v int32) *ListPermissionApplyOrdersRequest {
	s.OrderType = &v
	return s
}

func (s *ListPermissionApplyOrdersRequest) SetPageNum(v int32) *ListPermissionApplyOrdersRequest {
	s.PageNum = &v
	return s
}

func (s *ListPermissionApplyOrdersRequest) SetPageSize(v int32) *ListPermissionApplyOrdersRequest {
	s.PageSize = &v
	return s
}

func (s *ListPermissionApplyOrdersRequest) SetQueryType(v int32) *ListPermissionApplyOrdersRequest {
	s.QueryType = &v
	return s
}

func (s *ListPermissionApplyOrdersRequest) SetStartTime(v int64) *ListPermissionApplyOrdersRequest {
	s.StartTime = &v
	return s
}

func (s *ListPermissionApplyOrdersRequest) SetTableName(v string) *ListPermissionApplyOrdersRequest {
	s.TableName = &v
	return s
}

func (s *ListPermissionApplyOrdersRequest) SetWorkspaceId(v int32) *ListPermissionApplyOrdersRequest {
	s.WorkspaceId = &v
	return s
}

type ListPermissionApplyOrdersResponseBody struct {
	// The query results returned by page.
	ApplyOrders *ListPermissionApplyOrdersResponseBodyApplyOrders `json:"ApplyOrders,omitempty" xml:"ApplyOrders,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListPermissionApplyOrdersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListPermissionApplyOrdersResponseBody) GoString() string {
	return s.String()
}

func (s *ListPermissionApplyOrdersResponseBody) SetApplyOrders(v *ListPermissionApplyOrdersResponseBodyApplyOrders) *ListPermissionApplyOrdersResponseBody {
	s.ApplyOrders = v
	return s
}

func (s *ListPermissionApplyOrdersResponseBody) SetRequestId(v string) *ListPermissionApplyOrdersResponseBody {
	s.RequestId = &v
	return s
}

type ListPermissionApplyOrdersResponseBodyApplyOrders struct {
	// The list of the permission request orders.
	ApplyOrder []*ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder `json:"ApplyOrder,omitempty" xml:"ApplyOrder,omitempty" type:"Repeated"`
	// The number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of permission request orders returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListPermissionApplyOrdersResponseBodyApplyOrders) String() string {
	return tea.Prettify(s)
}

func (s ListPermissionApplyOrdersResponseBodyApplyOrders) GoString() string {
	return s.String()
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrders) SetApplyOrder(v []*ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder) *ListPermissionApplyOrdersResponseBodyApplyOrders {
	s.ApplyOrder = v
	return s
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrders) SetPageNumber(v int32) *ListPermissionApplyOrdersResponseBodyApplyOrders {
	s.PageNumber = &v
	return s
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrders) SetPageSize(v int32) *ListPermissionApplyOrdersResponseBodyApplyOrders {
	s.PageSize = &v
	return s
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrders) SetTotalCount(v int32) *ListPermissionApplyOrdersResponseBodyApplyOrders {
	s.TotalCount = &v
	return s
}

type ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder struct {
	// The unique ID of the Alibaba Cloud account that was used to submit the permission request order.
	ApplyBaseId *string `json:"ApplyBaseId,omitempty" xml:"ApplyBaseId,omitempty"`
	// The time when the permission request order was submitted. The parameter value is a UNIX timestamp.
	ApplyTimestamp *int64 `json:"ApplyTimestamp,omitempty" xml:"ApplyTimestamp,omitempty"`
	// The content of the permission request order.
	ApproveContent *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent `json:"ApproveContent,omitempty" xml:"ApproveContent,omitempty" type:"Struct"`
	// The ID of the permission request order.
	FlowId *string `json:"FlowId,omitempty" xml:"FlowId,omitempty"`
	// The status of the permission request order. Valid values:
	//
	// *   1: pending approval
	// *   2: approved and authorized
	// *   3: approved but authorization failed
	// *   4: rejected
	FlowStatus *int32 `json:"FlowStatus,omitempty" xml:"FlowStatus,omitempty"`
}

func (s ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder) String() string {
	return tea.Prettify(s)
}

func (s ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder) GoString() string {
	return s.String()
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder) SetApplyBaseId(v string) *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder {
	s.ApplyBaseId = &v
	return s
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder) SetApplyTimestamp(v int64) *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder {
	s.ApplyTimestamp = &v
	return s
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder) SetApproveContent(v *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent) *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder {
	s.ApproveContent = v
	return s
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder) SetFlowId(v string) *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder {
	s.FlowId = &v
	return s
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder) SetFlowStatus(v int32) *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrder {
	s.FlowStatus = &v
	return s
}

type ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent struct {
	// The reason for your request. The administrator determines whether to approve the request based on the reason.
	ApplyReason *string `json:"ApplyReason,omitempty" xml:"ApplyReason,omitempty"`
	// The type of the permission request order. The parameter value is 1 and cannot be changed. This value indicates ACL-based authorization.
	OrderType *int32 `json:"OrderType,omitempty" xml:"OrderType,omitempty"`
	// The content of the object on which you requested permissions.
	ProjectMeta *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta `json:"ProjectMeta,omitempty" xml:"ProjectMeta,omitempty" type:"Struct"`
}

func (s ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent) String() string {
	return tea.Prettify(s)
}

func (s ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent) GoString() string {
	return s.String()
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent) SetApplyReason(v string) *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent {
	s.ApplyReason = &v
	return s
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent) SetOrderType(v int32) *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent {
	s.OrderType = &v
	return s
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent) SetProjectMeta(v *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta) *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContent {
	s.ProjectMeta = v
	return s
}

type ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta struct {
	// The information about the object on which you requested permissions.
	ObjectMetaList []*ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList `json:"ObjectMetaList,omitempty" xml:"ObjectMetaList,omitempty" type:"Repeated"`
	// The name of the DataWorks workspace that was associated with the MaxCompute project in which you requested permissions on a table.
	WorkspaceName *string `json:"WorkspaceName,omitempty" xml:"WorkspaceName,omitempty"`
}

func (s ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta) String() string {
	return tea.Prettify(s)
}

func (s ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta) GoString() string {
	return s.String()
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta) SetObjectMetaList(v []*ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList) *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta {
	s.ObjectMetaList = v
	return s
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta) SetWorkspaceName(v string) *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMeta {
	s.WorkspaceName = &v
	return s
}

type ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList struct {
	// The permission that you wanted to request. If you wanted to request multiple permissions at the same time, separate them with commas (,).
	//
	// You can request only the following permissions: Select, Describe, Drop, Alter, Update, and Download.
	Actions []*string `json:"Actions,omitempty" xml:"Actions,omitempty" type:"Repeated"`
	// The name of the table on which you requested permissions.
	ObjectName *string `json:"ObjectName,omitempty" xml:"ObjectName,omitempty"`
}

func (s ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList) String() string {
	return tea.Prettify(s)
}

func (s ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList) GoString() string {
	return s.String()
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList) SetActions(v []*string) *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList {
	s.Actions = v
	return s
}

func (s *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList) SetObjectName(v string) *ListPermissionApplyOrdersResponseBodyApplyOrdersApplyOrderApproveContentProjectMetaObjectMetaList {
	s.ObjectName = &v
	return s
}

type ListPermissionApplyOrdersResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListPermissionApplyOrdersResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListPermissionApplyOrdersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListPermissionApplyOrdersResponse) GoString() string {
	return s.String()
}

func (s *ListPermissionApplyOrdersResponse) SetHeaders(v map[string]*string) *ListPermissionApplyOrdersResponse {
	s.Headers = v
	return s
}

func (s *ListPermissionApplyOrdersResponse) SetStatusCode(v int32) *ListPermissionApplyOrdersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListPermissionApplyOrdersResponse) SetBody(v *ListPermissionApplyOrdersResponseBody) *ListPermissionApplyOrdersResponse {
	s.Body = v
	return s
}

type ListProgramTypeCountRequest struct {
	// The environment of the workspace, including projects in PROD and DEV.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
	// The ID of the DataWorks workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListProgramTypeCountRequest) String() string {
	return tea.Prettify(s)
}

func (s ListProgramTypeCountRequest) GoString() string {
	return s.String()
}

func (s *ListProgramTypeCountRequest) SetProjectEnv(v string) *ListProgramTypeCountRequest {
	s.ProjectEnv = &v
	return s
}

func (s *ListProgramTypeCountRequest) SetProjectId(v int64) *ListProgramTypeCountRequest {
	s.ProjectId = &v
	return s
}

type ListProgramTypeCountResponseBody struct {
	// The type and number of nodes.
	ProgramTypeAndCounts []*ListProgramTypeCountResponseBodyProgramTypeAndCounts `json:"ProgramTypeAndCounts,omitempty" xml:"ProgramTypeAndCounts,omitempty" type:"Repeated"`
	// The ID of the request, which is used to locate logs and troubleshoot problems.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListProgramTypeCountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListProgramTypeCountResponseBody) GoString() string {
	return s.String()
}

func (s *ListProgramTypeCountResponseBody) SetProgramTypeAndCounts(v []*ListProgramTypeCountResponseBodyProgramTypeAndCounts) *ListProgramTypeCountResponseBody {
	s.ProgramTypeAndCounts = v
	return s
}

func (s *ListProgramTypeCountResponseBody) SetRequestId(v string) *ListProgramTypeCountResponseBody {
	s.RequestId = &v
	return s
}

type ListProgramTypeCountResponseBodyProgramTypeAndCounts struct {
	// The number of nodes.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The type of the node.
	ProgramType *string `json:"ProgramType,omitempty" xml:"ProgramType,omitempty"`
}

func (s ListProgramTypeCountResponseBodyProgramTypeAndCounts) String() string {
	return tea.Prettify(s)
}

func (s ListProgramTypeCountResponseBodyProgramTypeAndCounts) GoString() string {
	return s.String()
}

func (s *ListProgramTypeCountResponseBodyProgramTypeAndCounts) SetCount(v int32) *ListProgramTypeCountResponseBodyProgramTypeAndCounts {
	s.Count = &v
	return s
}

func (s *ListProgramTypeCountResponseBodyProgramTypeAndCounts) SetProgramType(v string) *ListProgramTypeCountResponseBodyProgramTypeAndCounts {
	s.ProgramType = &v
	return s
}

type ListProgramTypeCountResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListProgramTypeCountResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListProgramTypeCountResponse) String() string {
	return tea.Prettify(s)
}

func (s ListProgramTypeCountResponse) GoString() string {
	return s.String()
}

func (s *ListProgramTypeCountResponse) SetHeaders(v map[string]*string) *ListProgramTypeCountResponse {
	s.Headers = v
	return s
}

func (s *ListProgramTypeCountResponse) SetStatusCode(v int32) *ListProgramTypeCountResponse {
	s.StatusCode = &v
	return s
}

func (s *ListProgramTypeCountResponse) SetBody(v *ListProgramTypeCountResponseBody) *ListProgramTypeCountResponse {
	s.Body = v
	return s
}

type ListProjectIdsRequest struct {
	// The ID of the specific Alibaba Cloud account. You can log on to the [DataWorks](https://workbench.data.aliyun.com/console) console and move the pointer over the profile picture in the upper-right corner to view the ID.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s ListProjectIdsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListProjectIdsRequest) GoString() string {
	return s.String()
}

func (s *ListProjectIdsRequest) SetUserId(v string) *ListProjectIdsRequest {
	s.UserId = &v
	return s
}

type ListProjectIdsResponseBody struct {
	// The IDs of the DataWorks workspaces.
	//
	// The IDs of the workspaces on which the specific Alibaba Cloud account has permissions were returned. In this example, a single workspace ID is used.
	ProjectIds []*int64 `json:"ProjectIds,omitempty" xml:"ProjectIds,omitempty" type:"Repeated"`
	// The ID of the request. You can troubleshoot errors based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListProjectIdsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListProjectIdsResponseBody) GoString() string {
	return s.String()
}

func (s *ListProjectIdsResponseBody) SetProjectIds(v []*int64) *ListProjectIdsResponseBody {
	s.ProjectIds = v
	return s
}

func (s *ListProjectIdsResponseBody) SetRequestId(v string) *ListProjectIdsResponseBody {
	s.RequestId = &v
	return s
}

type ListProjectIdsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListProjectIdsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListProjectIdsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListProjectIdsResponse) GoString() string {
	return s.String()
}

func (s *ListProjectIdsResponse) SetHeaders(v map[string]*string) *ListProjectIdsResponse {
	s.Headers = v
	return s
}

func (s *ListProjectIdsResponse) SetStatusCode(v int32) *ListProjectIdsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListProjectIdsResponse) SetBody(v *ListProjectIdsResponseBody) *ListProjectIdsResponse {
	s.Body = v
	return s
}

type ListProjectMembersRequest struct {
	// The ID of the request.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The results that are returned.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListProjectMembersRequest) String() string {
	return tea.Prettify(s)
}

func (s ListProjectMembersRequest) GoString() string {
	return s.String()
}

func (s *ListProjectMembersRequest) SetPageNumber(v int32) *ListProjectMembersRequest {
	s.PageNumber = &v
	return s
}

func (s *ListProjectMembersRequest) SetPageSize(v int32) *ListProjectMembersRequest {
	s.PageSize = &v
	return s
}

func (s *ListProjectMembersRequest) SetProjectId(v int64) *ListProjectMembersRequest {
	s.ProjectId = &v
	return s
}

type ListProjectMembersResponseBody struct {
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	Data *ListProjectMembersResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The page number of the returned page.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListProjectMembersResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListProjectMembersResponseBody) GoString() string {
	return s.String()
}

func (s *ListProjectMembersResponseBody) SetData(v *ListProjectMembersResponseBodyData) *ListProjectMembersResponseBody {
	s.Data = v
	return s
}

func (s *ListProjectMembersResponseBody) SetRequestId(v string) *ListProjectMembersResponseBody {
	s.RequestId = &v
	return s
}

type ListProjectMembersResponseBodyData struct {
	// The total number of entries returned.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The information of members in the DataWorks workspace.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the member.
	ProjectMemberList []*ListProjectMembersResponseBodyDataProjectMemberList `json:"ProjectMemberList,omitempty" xml:"ProjectMemberList,omitempty" type:"Repeated"`
	// The status of the member. Valid values:
	//
	// *   0: NORMAL, which indicates that the member is in a normal state.
	// *   1: FORBIDDEN, which indicates that the member is disabled.
	// *   2: DELETED, which indicates that the member is deleted.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListProjectMembersResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListProjectMembersResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListProjectMembersResponseBodyData) SetPageNumber(v int32) *ListProjectMembersResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListProjectMembersResponseBodyData) SetPageSize(v int32) *ListProjectMembersResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListProjectMembersResponseBodyData) SetProjectMemberList(v []*ListProjectMembersResponseBodyDataProjectMemberList) *ListProjectMembersResponseBodyData {
	s.ProjectMemberList = v
	return s
}

func (s *ListProjectMembersResponseBodyData) SetTotalCount(v int32) *ListProjectMembersResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListProjectMembersResponseBodyDataProjectMemberList struct {
	// The type of the member. Valid values:
	//
	// *   1: USER_ALIYUN, which indicates that the member is an Alibaba Cloud account.
	// *   5: USER_UBACCOUNT, which indicates that the member is a RAM user.
	// *   6: USER_STS_ROLE, which indicates that the member is a RAM role.
	Nick *string `json:"Nick,omitempty" xml:"Nick,omitempty"`
	// The name of the member.
	ProjectMemberId *string `json:"ProjectMemberId,omitempty" xml:"ProjectMemberId,omitempty"`
	// The roles that are assigned to the member.
	ProjectMemberName *string `json:"ProjectMemberName,omitempty" xml:"ProjectMemberName,omitempty"`
	// The ID of the role.
	ProjectMemberType *string `json:"ProjectMemberType,omitempty" xml:"ProjectMemberType,omitempty"`
	// The type of the role. Valid values:
	//
	// *   0: SYSTEM, which indicates that the role is a built-in role.
	// *   2: USER_CUSTOM, which indicates that the role is a custom role.
	ProjectRoleList []*ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList `json:"ProjectRoleList,omitempty" xml:"ProjectRoleList,omitempty" type:"Repeated"`
	// The nickname of the member.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListProjectMembersResponseBodyDataProjectMemberList) String() string {
	return tea.Prettify(s)
}

func (s ListProjectMembersResponseBodyDataProjectMemberList) GoString() string {
	return s.String()
}

func (s *ListProjectMembersResponseBodyDataProjectMemberList) SetNick(v string) *ListProjectMembersResponseBodyDataProjectMemberList {
	s.Nick = &v
	return s
}

func (s *ListProjectMembersResponseBodyDataProjectMemberList) SetProjectMemberId(v string) *ListProjectMembersResponseBodyDataProjectMemberList {
	s.ProjectMemberId = &v
	return s
}

func (s *ListProjectMembersResponseBodyDataProjectMemberList) SetProjectMemberName(v string) *ListProjectMembersResponseBodyDataProjectMemberList {
	s.ProjectMemberName = &v
	return s
}

func (s *ListProjectMembersResponseBodyDataProjectMemberList) SetProjectMemberType(v string) *ListProjectMembersResponseBodyDataProjectMemberList {
	s.ProjectMemberType = &v
	return s
}

func (s *ListProjectMembersResponseBodyDataProjectMemberList) SetProjectRoleList(v []*ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList) *ListProjectMembersResponseBodyDataProjectMemberList {
	s.ProjectRoleList = v
	return s
}

func (s *ListProjectMembersResponseBodyDataProjectMemberList) SetStatus(v string) *ListProjectMembersResponseBodyDataProjectMemberList {
	s.Status = &v
	return s
}

type ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList struct {
	ProjectRoleCode *string `json:"ProjectRoleCode,omitempty" xml:"ProjectRoleCode,omitempty"`
	// The name of the role.
	//
	// DataWorks provides built-in roles and allows you to create custom roles based on your business requirements. For more information about roles, see [Overview of users, roles, and permissions](~~295463~~).
	ProjectRoleId   *int32  `json:"ProjectRoleId,omitempty" xml:"ProjectRoleId,omitempty"`
	ProjectRoleName *string `json:"ProjectRoleName,omitempty" xml:"ProjectRoleName,omitempty"`
	// The code of the role.
	//
	// DataWorks provides built-in roles and allows you to create custom roles based on your business requirements. For more information about roles, see [Overview of users, roles, and permissions](~~295463~~).
	ProjectRoleType *string `json:"ProjectRoleType,omitempty" xml:"ProjectRoleType,omitempty"`
}

func (s ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList) String() string {
	return tea.Prettify(s)
}

func (s ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList) GoString() string {
	return s.String()
}

func (s *ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList) SetProjectRoleCode(v string) *ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList {
	s.ProjectRoleCode = &v
	return s
}

func (s *ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList) SetProjectRoleId(v int32) *ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList {
	s.ProjectRoleId = &v
	return s
}

func (s *ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList) SetProjectRoleName(v string) *ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList {
	s.ProjectRoleName = &v
	return s
}

func (s *ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList) SetProjectRoleType(v string) *ListProjectMembersResponseBodyDataProjectMemberListProjectRoleList {
	s.ProjectRoleType = &v
	return s
}

type ListProjectMembersResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListProjectMembersResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListProjectMembersResponse) String() string {
	return tea.Prettify(s)
}

func (s ListProjectMembersResponse) GoString() string {
	return s.String()
}

func (s *ListProjectMembersResponse) SetHeaders(v map[string]*string) *ListProjectMembersResponse {
	s.Headers = v
	return s
}

func (s *ListProjectMembersResponse) SetStatusCode(v int32) *ListProjectMembersResponse {
	s.StatusCode = &v
	return s
}

func (s *ListProjectMembersResponse) SetBody(v *ListProjectMembersResponseBody) *ListProjectMembersResponse {
	s.Body = v
	return s
}

type ListProjectRolesRequest struct {
	// Dataworks ID of the region where the workspace is located.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListProjectRolesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListProjectRolesRequest) GoString() string {
	return s.String()
}

func (s *ListProjectRolesRequest) SetProjectId(v int64) *ListProjectRolesRequest {
	s.ProjectId = &v
	return s
}

type ListProjectRolesResponseBody struct {
	// The role ID of the workspace.
	ProjectRoleList []*ListProjectRolesResponseBodyProjectRoleList `json:"ProjectRoleList,omitempty" xml:"ProjectRoleList,omitempty" type:"Repeated"`
	// The roles of the workspace.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListProjectRolesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListProjectRolesResponseBody) GoString() string {
	return s.String()
}

func (s *ListProjectRolesResponseBody) SetProjectRoleList(v []*ListProjectRolesResponseBodyProjectRoleList) *ListProjectRolesResponseBody {
	s.ProjectRoleList = v
	return s
}

func (s *ListProjectRolesResponseBody) SetRequestId(v string) *ListProjectRolesResponseBody {
	s.RequestId = &v
	return s
}

type ListProjectRolesResponseBodyProjectRoleList struct {
	ProjectRoleCode *string `json:"ProjectRoleCode,omitempty" xml:"ProjectRoleCode,omitempty"`
	// The role type of the workspace. Valid values:
	ProjectRoleId *int32 `json:"ProjectRoleId,omitempty" xml:"ProjectRoleId,omitempty"`
	// The role Code of the workspace.
	ProjectRoleName *string `json:"ProjectRoleName,omitempty" xml:"ProjectRoleName,omitempty"`
	// The role name of the workspace.
	ProjectRoleType *string `json:"ProjectRoleType,omitempty" xml:"ProjectRoleType,omitempty"`
}

func (s ListProjectRolesResponseBodyProjectRoleList) String() string {
	return tea.Prettify(s)
}

func (s ListProjectRolesResponseBodyProjectRoleList) GoString() string {
	return s.String()
}

func (s *ListProjectRolesResponseBodyProjectRoleList) SetProjectRoleCode(v string) *ListProjectRolesResponseBodyProjectRoleList {
	s.ProjectRoleCode = &v
	return s
}

func (s *ListProjectRolesResponseBodyProjectRoleList) SetProjectRoleId(v int32) *ListProjectRolesResponseBodyProjectRoleList {
	s.ProjectRoleId = &v
	return s
}

func (s *ListProjectRolesResponseBodyProjectRoleList) SetProjectRoleName(v string) *ListProjectRolesResponseBodyProjectRoleList {
	s.ProjectRoleName = &v
	return s
}

func (s *ListProjectRolesResponseBodyProjectRoleList) SetProjectRoleType(v string) *ListProjectRolesResponseBodyProjectRoleList {
	s.ProjectRoleType = &v
	return s
}

type ListProjectRolesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListProjectRolesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListProjectRolesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListProjectRolesResponse) GoString() string {
	return s.String()
}

func (s *ListProjectRolesResponse) SetHeaders(v map[string]*string) *ListProjectRolesResponse {
	s.Headers = v
	return s
}

func (s *ListProjectRolesResponse) SetStatusCode(v int32) *ListProjectRolesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListProjectRolesResponse) SetBody(v *ListProjectRolesResponseBody) *ListProjectRolesResponse {
	s.Body = v
	return s
}

type ListProjectsRequest struct {
	// The ID of the resource group.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The tags.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The tag key.
	ResourceManagerResourceGroupId *string `json:"ResourceManagerResourceGroupId,omitempty" xml:"ResourceManagerResourceGroupId,omitempty"`
	// The tag value.
	Tags []*ListProjectsRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListProjectsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListProjectsRequest) GoString() string {
	return s.String()
}

func (s *ListProjectsRequest) SetPageNumber(v int32) *ListProjectsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListProjectsRequest) SetPageSize(v int32) *ListProjectsRequest {
	s.PageSize = &v
	return s
}

func (s *ListProjectsRequest) SetResourceManagerResourceGroupId(v string) *ListProjectsRequest {
	s.ResourceManagerResourceGroupId = &v
	return s
}

func (s *ListProjectsRequest) SetTags(v []*ListProjectsRequestTags) *ListProjectsRequest {
	s.Tags = v
	return s
}

type ListProjectsRequestTags struct {
	// The ID of the request.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The results that are returned.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListProjectsRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListProjectsRequestTags) GoString() string {
	return s.String()
}

func (s *ListProjectsRequestTags) SetKey(v string) *ListProjectsRequestTags {
	s.Key = &v
	return s
}

func (s *ListProjectsRequestTags) SetValue(v string) *ListProjectsRequestTags {
	s.Value = &v
	return s
}

type ListProjectsShrinkRequest struct {
	// The ID of the resource group.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The tags.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The tag key.
	ResourceManagerResourceGroupId *string `json:"ResourceManagerResourceGroupId,omitempty" xml:"ResourceManagerResourceGroupId,omitempty"`
	// The tag value.
	TagsShrink *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s ListProjectsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListProjectsShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListProjectsShrinkRequest) SetPageNumber(v int32) *ListProjectsShrinkRequest {
	s.PageNumber = &v
	return s
}

func (s *ListProjectsShrinkRequest) SetPageSize(v int32) *ListProjectsShrinkRequest {
	s.PageSize = &v
	return s
}

func (s *ListProjectsShrinkRequest) SetResourceManagerResourceGroupId(v string) *ListProjectsShrinkRequest {
	s.ResourceManagerResourceGroupId = &v
	return s
}

func (s *ListProjectsShrinkRequest) SetTagsShrink(v string) *ListProjectsShrinkRequest {
	s.TagsShrink = &v
	return s
}

type ListProjectsResponseBody struct {
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	PageResult *ListProjectsResponseBodyPageResult `json:"PageResult,omitempty" xml:"PageResult,omitempty" type:"Struct"`
	// The page number of the returned page.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListProjectsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListProjectsResponseBody) GoString() string {
	return s.String()
}

func (s *ListProjectsResponseBody) SetPageResult(v *ListProjectsResponseBodyPageResult) *ListProjectsResponseBody {
	s.PageResult = v
	return s
}

func (s *ListProjectsResponseBody) SetRequestId(v string) *ListProjectsResponseBody {
	s.RequestId = &v
	return s
}

type ListProjectsResponseBodyPageResult struct {
	// The total number of entries returned.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The DataWorks workspaces returned.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The status of the workspace. Valid values:
	//
	// *   0: AVAILABLE, which indicates that the workspace is running as expected.
	// *   1: DELETED, which indicates that the workspace is deleted.
	// *   2: INITIALIZING, which indicates that the workspace is being initialized.
	// *   3: INIT_FAILED, which indicates that the workspace fails to be initialized.
	// *   4: FORBIDDEN, which indicates that the workspace is manually disabled.
	// *   5: DELETING, which indicates that the workspace is being deleted.
	// *   6: DEL_FAILED, which indicates that the workspace fails to be deleted.
	// *   7: FROZEN, which indicates that the workspace is frozen due to overdue payments.
	// *   8: UPDATING, which indicates that the workspace is being updated. After you associate a compute engine with the workspace, the system initializes compute engine and updates the workspace.
	// *   9: UPDATE_FAILED, which indicates that the workspace fails to be updated.
	ProjectList []*ListProjectsResponseBodyPageResultProjectList `json:"ProjectList,omitempty" xml:"ProjectList,omitempty" type:"Repeated"`
	// The status code of the workspace. Valid values:
	//
	// *   AVAILABLE: 0, which indicates that the workspace is running as expected.
	// *   DELETED: 1, which indicates that the workspace is deleted.
	// *   INITIALIZING: 2, which indicates that the workspace is being initialized.
	// *   INIT_FAILED: 3, which indicates that the workspace fails to be initialized.
	// *   FORBIDDEN: 4, which indicates that the workspace is manually disabled.
	// *   DELETING: 5, which indicates that the workspace is being deleted.
	// *   DEL_FAILED: 6, which indicates that the workspace fails to be deleted.
	// *   FROZEN: 7, which indicates that the workspace is frozen due to overdue payments.
	// *   UPDATING: 8, which indicates that the workspace is being updated. After you associate a compute engine with the workspace, the system initializes compute engine and updates the workspace.
	// *   UPDATE_FAILED: 9, which indicates that the workspace fails to be updated.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListProjectsResponseBodyPageResult) String() string {
	return tea.Prettify(s)
}

func (s ListProjectsResponseBodyPageResult) GoString() string {
	return s.String()
}

func (s *ListProjectsResponseBodyPageResult) SetPageNumber(v int32) *ListProjectsResponseBodyPageResult {
	s.PageNumber = &v
	return s
}

func (s *ListProjectsResponseBodyPageResult) SetPageSize(v int32) *ListProjectsResponseBodyPageResult {
	s.PageSize = &v
	return s
}

func (s *ListProjectsResponseBodyPageResult) SetProjectList(v []*ListProjectsResponseBodyPageResultProjectList) *ListProjectsResponseBodyPageResult {
	s.ProjectList = v
	return s
}

func (s *ListProjectsResponseBodyPageResult) SetTotalCount(v int32) *ListProjectsResponseBodyPageResult {
	s.TotalCount = &v
	return s
}

type ListProjectsResponseBodyPageResultProjectList struct {
	// Indicates whether the MaxCompute tables in the workspace are visible to the users within a tenant. Valid values:
	//
	// *   0: invisible
	// *   1: visible
	DisableDevelopment *bool  `json:"DisableDevelopment,omitempty" xml:"DisableDevelopment,omitempty"`
	IsDefault          *int32 `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The ID of the resource group.
	ProjectDescription *string `json:"ProjectDescription,omitempty" xml:"ProjectDescription,omitempty"`
	// The ID of the user used by the workspace owner.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The description of the workspace.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
	// The ID of the workspace.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The tags.
	ProjectOwnerBaseId *string `json:"ProjectOwnerBaseId,omitempty" xml:"ProjectOwnerBaseId,omitempty"`
	// The identifier of the workspace.
	ProjectStatus *int32 `json:"ProjectStatus,omitempty" xml:"ProjectStatus,omitempty"`
	// The name of the workspace.
	ProjectStatusCode *string `json:"ProjectStatusCode,omitempty" xml:"ProjectStatusCode,omitempty"`
	// The tag key.
	ResourceManagerResourceGroupId *string `json:"ResourceManagerResourceGroupId,omitempty" xml:"ResourceManagerResourceGroupId,omitempty"`
	TablePrivacyMode               *int32  `json:"TablePrivacyMode,omitempty" xml:"TablePrivacyMode,omitempty"`
	// The tag value.
	Tags []*ListProjectsResponseBodyPageResultProjectListTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// Indicates whether the workspace is a default workspace. Valid values:
	//
	// *   1: The workspace is a default workspace.
	// *   0: The workspace is not a default workspace.
	UseProxyOdpsAccount *bool `json:"UseProxyOdpsAccount,omitempty" xml:"UseProxyOdpsAccount,omitempty"`
}

func (s ListProjectsResponseBodyPageResultProjectList) String() string {
	return tea.Prettify(s)
}

func (s ListProjectsResponseBodyPageResultProjectList) GoString() string {
	return s.String()
}

func (s *ListProjectsResponseBodyPageResultProjectList) SetDisableDevelopment(v bool) *ListProjectsResponseBodyPageResultProjectList {
	s.DisableDevelopment = &v
	return s
}

func (s *ListProjectsResponseBodyPageResultProjectList) SetIsDefault(v int32) *ListProjectsResponseBodyPageResultProjectList {
	s.IsDefault = &v
	return s
}

func (s *ListProjectsResponseBodyPageResultProjectList) SetProjectDescription(v string) *ListProjectsResponseBodyPageResultProjectList {
	s.ProjectDescription = &v
	return s
}

func (s *ListProjectsResponseBodyPageResultProjectList) SetProjectId(v int64) *ListProjectsResponseBodyPageResultProjectList {
	s.ProjectId = &v
	return s
}

func (s *ListProjectsResponseBodyPageResultProjectList) SetProjectIdentifier(v string) *ListProjectsResponseBodyPageResultProjectList {
	s.ProjectIdentifier = &v
	return s
}

func (s *ListProjectsResponseBodyPageResultProjectList) SetProjectName(v string) *ListProjectsResponseBodyPageResultProjectList {
	s.ProjectName = &v
	return s
}

func (s *ListProjectsResponseBodyPageResultProjectList) SetProjectOwnerBaseId(v string) *ListProjectsResponseBodyPageResultProjectList {
	s.ProjectOwnerBaseId = &v
	return s
}

func (s *ListProjectsResponseBodyPageResultProjectList) SetProjectStatus(v int32) *ListProjectsResponseBodyPageResultProjectList {
	s.ProjectStatus = &v
	return s
}

func (s *ListProjectsResponseBodyPageResultProjectList) SetProjectStatusCode(v string) *ListProjectsResponseBodyPageResultProjectList {
	s.ProjectStatusCode = &v
	return s
}

func (s *ListProjectsResponseBodyPageResultProjectList) SetResourceManagerResourceGroupId(v string) *ListProjectsResponseBodyPageResultProjectList {
	s.ResourceManagerResourceGroupId = &v
	return s
}

func (s *ListProjectsResponseBodyPageResultProjectList) SetTablePrivacyMode(v int32) *ListProjectsResponseBodyPageResultProjectList {
	s.TablePrivacyMode = &v
	return s
}

func (s *ListProjectsResponseBodyPageResultProjectList) SetTags(v []*ListProjectsResponseBodyPageResultProjectListTags) *ListProjectsResponseBodyPageResultProjectList {
	s.Tags = v
	return s
}

func (s *ListProjectsResponseBodyPageResultProjectList) SetUseProxyOdpsAccount(v bool) *ListProjectsResponseBodyPageResultProjectList {
	s.UseProxyOdpsAccount = &v
	return s
}

type ListProjectsResponseBodyPageResultProjectListTags struct {
	// Indicates whether the Development role is disabled. Valid values:
	//
	// *   false: enabled
	// *   true: disabled
	// *   Default value: false
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// Indicates whether a proxy account is used to access the MaxCompute compute engine associated with the workspace.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListProjectsResponseBodyPageResultProjectListTags) String() string {
	return tea.Prettify(s)
}

func (s ListProjectsResponseBodyPageResultProjectListTags) GoString() string {
	return s.String()
}

func (s *ListProjectsResponseBodyPageResultProjectListTags) SetKey(v string) *ListProjectsResponseBodyPageResultProjectListTags {
	s.Key = &v
	return s
}

func (s *ListProjectsResponseBodyPageResultProjectListTags) SetValue(v string) *ListProjectsResponseBodyPageResultProjectListTags {
	s.Value = &v
	return s
}

type ListProjectsResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListProjectsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListProjectsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListProjectsResponse) GoString() string {
	return s.String()
}

func (s *ListProjectsResponse) SetHeaders(v map[string]*string) *ListProjectsResponse {
	s.Headers = v
	return s
}

func (s *ListProjectsResponse) SetStatusCode(v int32) *ListProjectsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListProjectsResponse) SetBody(v *ListProjectsResponseBody) *ListProjectsResponse {
	s.Body = v
	return s
}

type ListQualityResultsByEntityRequest struct {
	// The name of the compute engine instance or data source. You can obtain the name from data source configurations.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	EntityId *int64 `json:"EntityId,omitempty" xml:"EntityId,omitempty"`
	// The error message returned.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The HTTP status code returned.
	PageSize  *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the request.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The number of the page to return.
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
}

func (s ListQualityResultsByEntityRequest) String() string {
	return tea.Prettify(s)
}

func (s ListQualityResultsByEntityRequest) GoString() string {
	return s.String()
}

func (s *ListQualityResultsByEntityRequest) SetEndDate(v string) *ListQualityResultsByEntityRequest {
	s.EndDate = &v
	return s
}

func (s *ListQualityResultsByEntityRequest) SetEntityId(v int64) *ListQualityResultsByEntityRequest {
	s.EntityId = &v
	return s
}

func (s *ListQualityResultsByEntityRequest) SetPageNumber(v int32) *ListQualityResultsByEntityRequest {
	s.PageNumber = &v
	return s
}

func (s *ListQualityResultsByEntityRequest) SetPageSize(v int32) *ListQualityResultsByEntityRequest {
	s.PageSize = &v
	return s
}

func (s *ListQualityResultsByEntityRequest) SetProjectId(v int64) *ListQualityResultsByEntityRequest {
	s.ProjectId = &v
	return s
}

func (s *ListQualityResultsByEntityRequest) SetProjectName(v string) *ListQualityResultsByEntityRequest {
	s.ProjectName = &v
	return s
}

func (s *ListQualityResultsByEntityRequest) SetStartDate(v string) *ListQualityResultsByEntityRequest {
	s.StartDate = &v
	return s
}

type ListQualityResultsByEntityResponseBody struct {
	// The total number of entries returned.
	Data *ListQualityResultsByEntityResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error code returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// Indicates whether the request is successful.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The data structure of the monitoring results returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The page number of the returned page.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListQualityResultsByEntityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListQualityResultsByEntityResponseBody) GoString() string {
	return s.String()
}

func (s *ListQualityResultsByEntityResponseBody) SetData(v *ListQualityResultsByEntityResponseBodyData) *ListQualityResultsByEntityResponseBody {
	s.Data = v
	return s
}

func (s *ListQualityResultsByEntityResponseBody) SetErrorCode(v string) *ListQualityResultsByEntityResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBody) SetErrorMessage(v string) *ListQualityResultsByEntityResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBody) SetHttpStatusCode(v int32) *ListQualityResultsByEntityResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBody) SetRequestId(v string) *ListQualityResultsByEntityResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBody) SetSuccess(v bool) *ListQualityResultsByEntityResponseBody {
	s.Success = &v
	return s
}

type ListQualityResultsByEntityResponseBodyData struct {
	// The monitoring results returned.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The type of the monitoring rule. The type of a monitoring rule indicates the importance of the rule. Valid values:
	//
	// *   1: indicates that the monitoring rule is a strong rule.
	//
	// *   0: indicates that the monitoring rule is a weak rule.
	//
	//     You can specify whether a monitoring rule is a strong rule based on your business requirements. If a strong rule is used and a critical alert is triggered, nodes are blocked.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The field of the rule attribute. This field is the column name of the data source table that is monitored.
	RuleChecks []*ListQualityResultsByEntityResponseBodyDataRuleChecks `json:"RuleChecks,omitempty" xml:"RuleChecks,omitempty" type:"Repeated"`
	// The threshold for a warning alert. The threshold indicates the deviation of the monitoring result from the expected value. You can customize this threshold based on your business requirements.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListQualityResultsByEntityResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListQualityResultsByEntityResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListQualityResultsByEntityResponseBodyData) SetPageNumber(v int32) *ListQualityResultsByEntityResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyData) SetPageSize(v int32) *ListQualityResultsByEntityResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyData) SetRuleChecks(v []*ListQualityResultsByEntityResponseBodyDataRuleChecks) *ListQualityResultsByEntityResponseBodyData {
	s.RuleChecks = v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyData) SetTotalCount(v int64) *ListQualityResultsByEntityResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListQualityResultsByEntityResponseBodyDataRuleChecks struct {
	// The trend of the monitoring result.
	ActualExpression *string `json:"ActualExpression,omitempty" xml:"ActualExpression,omitempty"`
	// Indicates whether the monitoring result is the same as the predicted result. Valid values:
	//
	// *   true: indicates that the monitoring result is the same as the predicted result.
	// *   false: indicates that the monitoring result is different from the predicted result.
	BeginTime *int64 `json:"BeginTime,omitempty" xml:"BeginTime,omitempty"`
	// The partition filter expression.
	BizDate *int64 `json:"BizDate,omitempty" xml:"BizDate,omitempty"`
	// The name of the table that is monitored.
	BlockType *int32 `json:"BlockType,omitempty" xml:"BlockType,omitempty"`
	// The monitoring type. Valid values:
	//
	// *   1: VOLATILITY_CHECK
	// *   2: FIXEDVALUE_CHECK
	CheckResult *int32 `json:"CheckResult,omitempty" xml:"CheckResult,omitempty"`
	// The ID of the monitoring rule.
	CheckResultStatus *int32 `json:"CheckResultStatus,omitempty" xml:"CheckResultStatus,omitempty"`
	// The method used to collect sample data, such as avg, count, sum, min, max, count_distinct, user_defined, table_count, table_size, table_dt_load_count, table_dt_refuseload_count, null_value, null_value/table_count, (table_count-count_distinct)/table_count, or table_count-count_distinct.
	CheckerId *int32 `json:"CheckerId,omitempty" xml:"CheckerId,omitempty"`
	// The comparison operator.
	CheckerName *string `json:"CheckerName,omitempty" xml:"CheckerName,omitempty"`
	// The type of the scheduling cycle. In most cases, the value of this parameter is YMD. This value indicates year, month, and day.
	CheckerType *int32 `json:"CheckerType,omitempty" xml:"CheckerType,omitempty"`
	// The name of the checker.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ID of the checker.
	CriticalThreshold *float32 `json:"CriticalThreshold,omitempty" xml:"CriticalThreshold,omitempty"`
	// The name of the monitoring rule.
	DateType *string `json:"DateType,omitempty" xml:"DateType,omitempty"`
	// The lower limit of the predicted result. The value of this parameter is automatically generated based on the threshold that you specified.
	DiscreteCheck *bool `json:"DiscreteCheck,omitempty" xml:"DiscreteCheck,omitempty"`
	// The ID of the partition filter expression.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the monitoring template.
	EntityId *int64 `json:"EntityId,omitempty" xml:"EntityId,omitempty"`
	// The ID of the primary key.
	ExpectValue *float32 `json:"ExpectValue,omitempty" xml:"ExpectValue,omitempty"`
	// The type of the scheduling system. Only CWF scheduling systems are supported.
	ExternalId *string `json:"ExternalId,omitempty" xml:"ExternalId,omitempty"`
	// The string of the monitoring result.
	ExternalType *string `json:"ExternalType,omitempty" xml:"ExternalType,omitempty"`
	// The partition in the monitored data source table.
	FixedCheck *bool `json:"FixedCheck,omitempty" xml:"FixedCheck,omitempty"`
	// The check value.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether the monitoring is discrete monitoring. Valid values:
	//
	// *   true: indicates that the monitoring is discrete monitoring.
	// *   false: indicates that the monitoring is not discrete monitoring.
	IsPrediction *bool `json:"IsPrediction,omitempty" xml:"IsPrediction,omitempty"`
	// The expected value.
	LowerValue *float32 `json:"LowerValue,omitempty" xml:"LowerValue,omitempty"`
	// The time when the monitoring started.
	MatchExpression *string `json:"MatchExpression,omitempty" xml:"MatchExpression,omitempty"`
	// The filter condition of the monitoring rule.
	MethodName *string `json:"MethodName,omitempty" xml:"MethodName,omitempty"`
	// The ID of the node.
	Op *string `json:"Op,omitempty" xml:"Op,omitempty"`
	// The threshold for a critical alert. The threshold indicates the deviation of the monitoring result from the expected value. You can customize this threshold based on your business requirements. If a strong rule is used and a critical alert is reported, nodes are blocked.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The check result of the monitoring rule. Valid values:
	//
	// *   0: indicates that the data source table is normal.
	// *   1: indicates that a warning alert is reported.
	// *   2: indicates that a critical alert is reported.
	Property *string `json:"Property,omitempty" xml:"Property,omitempty"`
	// The data timestamp. If the monitored business entity is offline data, the value is usually one day before the monitoring is performed.
	ReferenceValue []*ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue `json:"ReferenceValue,omitempty" xml:"ReferenceValue,omitempty" type:"Repeated"`
	// The name of the compute engine instance or data source for which data quality is monitored.
	ResultString *string `json:"ResultString,omitempty" xml:"ResultString,omitempty"`
	// The upper limit of the predicted result. The value of this parameter is automatically generated based on the threshold that you specified.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The time when the monitoring ended.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The current sample value.
	SampleValue []*ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue `json:"SampleValue,omitempty" xml:"SampleValue,omitempty" type:"Repeated"`
	// The name of the monitoring template.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The values of the sample field that are grouped by using the GROUP BY clause. For example, the values of the Gender field are grouped by using the GROUP BY clause. In this case, the values of DiscreteProperty are Male, Female, and null.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The historical sample values.
	TemplateId *int32 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// Indicates whether the monitoring is performed based on a fixed value. Valid values:
	//
	// *   true: indicates that the monitoring is performed based on a fixed value.
	// *   false: indicates that the monitoring is performed based on a non-fixed value.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The data timestamp. If the monitored business entity is offline data, the value is usually one day before the monitoring is performed.
	TimeCost *string `json:"TimeCost,omitempty" xml:"TimeCost,omitempty"`
	// The monitoring result. The value of this parameter is the same as the value of the CheckResultStatus parameter. Valid values:
	//
	// *   0: indicates that the data source table is normal.
	// *   1: indicates that a warning alert is reported.
	// *   2: indicates that a critical alert is reported.
	Trend *string `json:"Trend,omitempty" xml:"Trend,omitempty"`
	// The time that was taken to run the monitoring task. Unit: seconds.
	UpperValue *float32 `json:"UpperValue,omitempty" xml:"UpperValue,omitempty"`
	// The description of the monitoring rule.
	WarningThreshold *float32 `json:"WarningThreshold,omitempty" xml:"WarningThreshold,omitempty"`
	// The ID of the monitoring task.
	WhereCondition *string `json:"WhereCondition,omitempty" xml:"WhereCondition,omitempty"`
}

func (s ListQualityResultsByEntityResponseBodyDataRuleChecks) String() string {
	return tea.Prettify(s)
}

func (s ListQualityResultsByEntityResponseBodyDataRuleChecks) GoString() string {
	return s.String()
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetActualExpression(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.ActualExpression = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetBeginTime(v int64) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.BeginTime = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetBizDate(v int64) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.BizDate = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetBlockType(v int32) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.BlockType = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetCheckResult(v int32) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.CheckResult = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetCheckResultStatus(v int32) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.CheckResultStatus = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetCheckerId(v int32) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.CheckerId = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetCheckerName(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.CheckerName = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetCheckerType(v int32) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.CheckerType = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetComment(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.Comment = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetCriticalThreshold(v float32) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.CriticalThreshold = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetDateType(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.DateType = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetDiscreteCheck(v bool) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.DiscreteCheck = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetEndTime(v int64) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.EndTime = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetEntityId(v int64) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.EntityId = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetExpectValue(v float32) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.ExpectValue = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetExternalId(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.ExternalId = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetExternalType(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.ExternalType = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetFixedCheck(v bool) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.FixedCheck = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetId(v int64) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.Id = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetIsPrediction(v bool) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.IsPrediction = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetLowerValue(v float32) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.LowerValue = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetMatchExpression(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.MatchExpression = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetMethodName(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.MethodName = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetOp(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.Op = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetProjectName(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.ProjectName = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetProperty(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.Property = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetReferenceValue(v []*ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.ReferenceValue = v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetResultString(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.ResultString = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetRuleId(v int64) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.RuleId = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetRuleName(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.RuleName = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetSampleValue(v []*ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.SampleValue = v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetTableName(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.TableName = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetTaskId(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.TaskId = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetTemplateId(v int32) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.TemplateId = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetTemplateName(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.TemplateName = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetTimeCost(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.TimeCost = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetTrend(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.Trend = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetUpperValue(v float32) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.UpperValue = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetWarningThreshold(v float32) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.WarningThreshold = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecks) SetWhereCondition(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecks {
	s.WhereCondition = &v
	return s
}

type ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue struct {
	// The sample values.
	BizDate *string `json:"BizDate,omitempty" xml:"BizDate,omitempty"`
	// The monitoring result.
	DiscreteProperty *string `json:"DiscreteProperty,omitempty" xml:"DiscreteProperty,omitempty"`
	// The values of the sample field that are grouped by using the GROUP BY clause. For example, the values of the Gender field are grouped by using the GROUP BY clause. In this case, the values of DiscreteProperty are Male, Female, and null.
	SingleCheckResult *int32 `json:"SingleCheckResult,omitempty" xml:"SingleCheckResult,omitempty"`
	// The data timestamp. If the monitored business entity is offline data, the value is usually one day before the monitoring is performed.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
	// The threshold.
	Value *float32 `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue) String() string {
	return tea.Prettify(s)
}

func (s ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue) GoString() string {
	return s.String()
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue) SetBizDate(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue {
	s.BizDate = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue) SetDiscreteProperty(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue {
	s.DiscreteProperty = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue) SetSingleCheckResult(v int32) *ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue {
	s.SingleCheckResult = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue) SetThreshold(v float32) *ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue {
	s.Threshold = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue) SetValue(v float32) *ListQualityResultsByEntityResponseBodyDataRuleChecksReferenceValue {
	s.Value = &v
	return s
}

type ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue struct {
	BizDate          *string  `json:"BizDate,omitempty" xml:"BizDate,omitempty"`
	DiscreteProperty *string  `json:"DiscreteProperty,omitempty" xml:"DiscreteProperty,omitempty"`
	Value            *float32 `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue) String() string {
	return tea.Prettify(s)
}

func (s ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue) GoString() string {
	return s.String()
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue) SetBizDate(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue {
	s.BizDate = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue) SetDiscreteProperty(v string) *ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue {
	s.DiscreteProperty = &v
	return s
}

func (s *ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue) SetValue(v float32) *ListQualityResultsByEntityResponseBodyDataRuleChecksSampleValue {
	s.Value = &v
	return s
}

type ListQualityResultsByEntityResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListQualityResultsByEntityResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListQualityResultsByEntityResponse) String() string {
	return tea.Prettify(s)
}

func (s ListQualityResultsByEntityResponse) GoString() string {
	return s.String()
}

func (s *ListQualityResultsByEntityResponse) SetHeaders(v map[string]*string) *ListQualityResultsByEntityResponse {
	s.Headers = v
	return s
}

func (s *ListQualityResultsByEntityResponse) SetStatusCode(v int32) *ListQualityResultsByEntityResponse {
	s.StatusCode = &v
	return s
}

func (s *ListQualityResultsByEntityResponse) SetBody(v *ListQualityResultsByEntityResponseBody) *ListQualityResultsByEntityResponse {
	s.Body = v
	return s
}

type ListQualityResultsByRuleRequest struct {
	// The end of the time range to query. Specify the time in the yyyy-MM-dd HH:mm:ss format.
	//
	// This parameter is used together with the StartDate parameter. The interval between the time specified by this parameter and the time specified by the StartDate parameter cannot exceed 7 days.
	EndDate *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize  *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the compute engine instance or data source for which data quality is monitored.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The ID of the monitoring rule. You can use the ID and information such as a partition filter expression to perform a joint query.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The beginning of the time range to query. Specify the time in the yyyy-MM-dd HH:mm:ss format.
	//
	// This parameter is used together with the EndDate parameter. The interval between the time specified by this parameter and the time specified by the EndDate parameter cannot exceed 7 days.
	StartDate *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
}

func (s ListQualityResultsByRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ListQualityResultsByRuleRequest) GoString() string {
	return s.String()
}

func (s *ListQualityResultsByRuleRequest) SetEndDate(v string) *ListQualityResultsByRuleRequest {
	s.EndDate = &v
	return s
}

func (s *ListQualityResultsByRuleRequest) SetPageNumber(v int32) *ListQualityResultsByRuleRequest {
	s.PageNumber = &v
	return s
}

func (s *ListQualityResultsByRuleRequest) SetPageSize(v int32) *ListQualityResultsByRuleRequest {
	s.PageSize = &v
	return s
}

func (s *ListQualityResultsByRuleRequest) SetProjectId(v int64) *ListQualityResultsByRuleRequest {
	s.ProjectId = &v
	return s
}

func (s *ListQualityResultsByRuleRequest) SetProjectName(v string) *ListQualityResultsByRuleRequest {
	s.ProjectName = &v
	return s
}

func (s *ListQualityResultsByRuleRequest) SetRuleId(v int64) *ListQualityResultsByRuleRequest {
	s.RuleId = &v
	return s
}

func (s *ListQualityResultsByRuleRequest) SetStartDate(v string) *ListQualityResultsByRuleRequest {
	s.StartDate = &v
	return s
}

type ListQualityResultsByRuleResponseBody struct {
	// The data structure of the monitoring results returned.
	Data *ListQualityResultsByRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListQualityResultsByRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListQualityResultsByRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ListQualityResultsByRuleResponseBody) SetData(v *ListQualityResultsByRuleResponseBodyData) *ListQualityResultsByRuleResponseBody {
	s.Data = v
	return s
}

func (s *ListQualityResultsByRuleResponseBody) SetErrorCode(v string) *ListQualityResultsByRuleResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBody) SetErrorMessage(v string) *ListQualityResultsByRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBody) SetHttpStatusCode(v int32) *ListQualityResultsByRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBody) SetRequestId(v string) *ListQualityResultsByRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBody) SetSuccess(v bool) *ListQualityResultsByRuleResponseBody {
	s.Success = &v
	return s
}

type ListQualityResultsByRuleResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The monitoring results returned.
	RuleChecks []*ListQualityResultsByRuleResponseBodyDataRuleChecks `json:"RuleChecks,omitempty" xml:"RuleChecks,omitempty" type:"Repeated"`
	// The total number of entries returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListQualityResultsByRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListQualityResultsByRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListQualityResultsByRuleResponseBodyData) SetPageNumber(v int32) *ListQualityResultsByRuleResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyData) SetPageSize(v int32) *ListQualityResultsByRuleResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyData) SetRuleChecks(v []*ListQualityResultsByRuleResponseBodyDataRuleChecks) *ListQualityResultsByRuleResponseBodyData {
	s.RuleChecks = v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyData) SetTotalCount(v int64) *ListQualityResultsByRuleResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListQualityResultsByRuleResponseBodyDataRuleChecks struct {
	// The partition in the monitored data source table.
	ActualExpression *string `json:"ActualExpression,omitempty" xml:"ActualExpression,omitempty"`
	// The time when the monitoring started.
	BeginTime *int64 `json:"BeginTime,omitempty" xml:"BeginTime,omitempty"`
	// The date on which the business was performed. If the monitored business entity is offline data, the value is usually one day before the monitoring is performed.
	BizDate *int64 `json:"BizDate,omitempty" xml:"BizDate,omitempty"`
	// The type of the monitoring rule. The type of a monitoring rule indicates the importance of the rule. Valid values:
	//
	// *   1: indicates that the monitoring rule is a strong rule.
	//
	// *   0: indicates that the monitoring rule is a weak rule.
	//
	//     You can specify whether a monitoring rule is a strong rule based on your business requirements. If a strong rule is used and a critical alert is reported, nodes are blocked.
	BlockType *int32 `json:"BlockType,omitempty" xml:"BlockType,omitempty"`
	// The monitoring result.
	CheckResult *int32 `json:"CheckResult,omitempty" xml:"CheckResult,omitempty"`
	// The status of the monitoring result.
	CheckResultStatus *int32 `json:"CheckResultStatus,omitempty" xml:"CheckResultStatus,omitempty"`
	// The ID of the checker.
	CheckerId *int32 `json:"CheckerId,omitempty" xml:"CheckerId,omitempty"`
	// The name of the checker.
	CheckerName *string `json:"CheckerName,omitempty" xml:"CheckerName,omitempty"`
	// The type of the checker.
	CheckerType *int32 `json:"CheckerType,omitempty" xml:"CheckerType,omitempty"`
	// The description of the monitoring rule.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The threshold for a critical alert. The threshold indicates the deviation of the monitoring result from the expected value. You can customize this threshold based on your business requirements. If a strong rule is used and a critical alert is reported, nodes are blocked.
	CriticalThreshold *float32 `json:"CriticalThreshold,omitempty" xml:"CriticalThreshold,omitempty"`
	// The type of the scheduling cycle. In most cases, the value of this parameter is YMD. This value indicates year, month, and day.
	DateType *string `json:"DateType,omitempty" xml:"DateType,omitempty"`
	// Indicates whether the monitoring is discrete monitoring. Valid values:
	//
	// *   true: indicates that the monitoring is discrete monitoring.
	// *   false: indicates that the monitoring is not discrete monitoring.
	DiscreteCheck *bool `json:"DiscreteCheck,omitempty" xml:"DiscreteCheck,omitempty"`
	// The time when the monitoring ended.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the partition filter expression.
	EntityId *int64 `json:"EntityId,omitempty" xml:"EntityId,omitempty"`
	// The expected value.
	ExpectValue *float32 `json:"ExpectValue,omitempty" xml:"ExpectValue,omitempty"`
	// The ID of the node.
	ExternalId *string `json:"ExternalId,omitempty" xml:"ExternalId,omitempty"`
	// The type of the scheduling system. Only CWF scheduling systems are supported.
	ExternalType *string `json:"ExternalType,omitempty" xml:"ExternalType,omitempty"`
	// Indicates whether the monitoring is performed based on a fixed value. Valid values:
	//
	// *   true: indicates that the monitoring is performed based on a fixed value.
	// *   false: indicates that the monitoring is performed based on a non-fixed value.
	FixedCheck *bool `json:"FixedCheck,omitempty" xml:"FixedCheck,omitempty"`
	// The ID of the primary key.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// Indicates whether the monitoring result is the same as the predicted result. Valid values:
	//
	// *   true: indicates that the monitoring result is the same as the predicted result.
	// *   false: indicates that the monitoring result is different from the predicted result.
	IsPrediction *bool `json:"IsPrediction,omitempty" xml:"IsPrediction,omitempty"`
	// The lower limit of the predicted result. The value of this parameter is automatically generated based on the threshold that you specified.
	LowerValue *float32 `json:"LowerValue,omitempty" xml:"LowerValue,omitempty"`
	// The partition filter expression.
	MatchExpression *string `json:"MatchExpression,omitempty" xml:"MatchExpression,omitempty"`
	// The method used to collect sample data, such as avg, count, sum, min, max, count_distinct, user_defined, table_count, table_size, table_dt_load_count, table_dt_refuseload_count, null_value, null_value/table_count, (table_count-count_distinct)/table_count, or table_count-count_distinct.
	MethodName *string `json:"MethodName,omitempty" xml:"MethodName,omitempty"`
	// The comparison operator.
	Op   *string `json:"Op,omitempty" xml:"Op,omitempty"`
	Open *bool   `json:"Open,omitempty" xml:"Open,omitempty"`
	// The name of the compute engine instance or data source for which data quality is monitored.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The field of the rule attribute. This field is the column name of the data source table that is monitored.
	Property *string `json:"Property,omitempty" xml:"Property,omitempty"`
	// The historical sample values.
	ReferenceValue []*ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue `json:"ReferenceValue,omitempty" xml:"ReferenceValue,omitempty" type:"Repeated"`
	// The string of the monitoring result.
	ResultString *string `json:"ResultString,omitempty" xml:"ResultString,omitempty"`
	// The ID of the monitoring rule.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The name of the monitoring rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The sample values.
	SampleValue []*ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue `json:"SampleValue,omitempty" xml:"SampleValue,omitempty" type:"Repeated"`
	// The name of the table that is monitored.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the monitoring task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The ID of the monitoring template.
	TemplateId *int32 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The name of the monitoring template.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The time that was taken to run the monitoring task.
	TimeCost *string `json:"TimeCost,omitempty" xml:"TimeCost,omitempty"`
	// The trend of the monitoring result.
	Trend *string `json:"Trend,omitempty" xml:"Trend,omitempty"`
	// The upper limit of the predicted result. The value of this parameter is automatically generated based on the threshold that you specified.
	UpperValue *float32 `json:"UpperValue,omitempty" xml:"UpperValue,omitempty"`
	// The threshold for a warning alert. The threshold indicates the deviation of the monitoring result from the expected value. You can customize this threshold based on your business requirements.
	WarningThreshold *float32 `json:"WarningThreshold,omitempty" xml:"WarningThreshold,omitempty"`
	// The filter condition of the monitoring rule.
	WhereCondition *string `json:"WhereCondition,omitempty" xml:"WhereCondition,omitempty"`
}

func (s ListQualityResultsByRuleResponseBodyDataRuleChecks) String() string {
	return tea.Prettify(s)
}

func (s ListQualityResultsByRuleResponseBodyDataRuleChecks) GoString() string {
	return s.String()
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetActualExpression(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.ActualExpression = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetBeginTime(v int64) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.BeginTime = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetBizDate(v int64) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.BizDate = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetBlockType(v int32) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.BlockType = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetCheckResult(v int32) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.CheckResult = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetCheckResultStatus(v int32) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.CheckResultStatus = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetCheckerId(v int32) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.CheckerId = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetCheckerName(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.CheckerName = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetCheckerType(v int32) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.CheckerType = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetComment(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.Comment = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetCriticalThreshold(v float32) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.CriticalThreshold = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetDateType(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.DateType = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetDiscreteCheck(v bool) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.DiscreteCheck = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetEndTime(v int64) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.EndTime = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetEntityId(v int64) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.EntityId = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetExpectValue(v float32) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.ExpectValue = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetExternalId(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.ExternalId = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetExternalType(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.ExternalType = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetFixedCheck(v bool) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.FixedCheck = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetId(v int64) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.Id = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetIsPrediction(v bool) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.IsPrediction = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetLowerValue(v float32) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.LowerValue = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetMatchExpression(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.MatchExpression = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetMethodName(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.MethodName = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetOp(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.Op = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetOpen(v bool) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.Open = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetProjectName(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.ProjectName = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetProperty(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.Property = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetReferenceValue(v []*ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.ReferenceValue = v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetResultString(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.ResultString = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetRuleId(v int64) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.RuleId = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetRuleName(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.RuleName = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetSampleValue(v []*ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.SampleValue = v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetTableName(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.TableName = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetTaskId(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.TaskId = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetTemplateId(v int32) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.TemplateId = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetTemplateName(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.TemplateName = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetTimeCost(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.TimeCost = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetTrend(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.Trend = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetUpperValue(v float32) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.UpperValue = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetWarningThreshold(v float32) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.WarningThreshold = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecks) SetWhereCondition(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecks {
	s.WhereCondition = &v
	return s
}

type ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue struct {
	// The date on which the business was performed. If the monitored business entity is offline data, the value is usually one day before the monitoring is performed.
	BizDate *string `json:"BizDate,omitempty" xml:"BizDate,omitempty"`
	// The values of the sample field that are grouped by using the GROUP BY clause. For example, the values of the Gender field are grouped by using the GROUP BY clause. In this case, the values of DiscreteProperty are Male, Female, and null.
	DiscreteProperty *string `json:"DiscreteProperty,omitempty" xml:"DiscreteProperty,omitempty"`
	// The string of the monitoring result.
	SingleCheckResult *int32 `json:"SingleCheckResult,omitempty" xml:"SingleCheckResult,omitempty"`
	// The threshold.
	Threshold *float32 `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
	// The sample value.
	Value *float32 `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue) String() string {
	return tea.Prettify(s)
}

func (s ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue) GoString() string {
	return s.String()
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue) SetBizDate(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue {
	s.BizDate = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue) SetDiscreteProperty(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue {
	s.DiscreteProperty = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue) SetSingleCheckResult(v int32) *ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue {
	s.SingleCheckResult = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue) SetThreshold(v float32) *ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue {
	s.Threshold = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue) SetValue(v float32) *ListQualityResultsByRuleResponseBodyDataRuleChecksReferenceValue {
	s.Value = &v
	return s
}

type ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue struct {
	// The date on which the business was performed. If the monitored business entity is offline data, the value is usually one day before the monitoring is performed.
	BizDate *string `json:"BizDate,omitempty" xml:"BizDate,omitempty"`
	// The values of the sample field that are grouped by using the GROUP BY clause. For example, the values of the Gender field are grouped by using the GROUP BY clause. In this case, the values of DiscreteProperty are Male, Female, and null.
	DiscreteProperty *string `json:"DiscreteProperty,omitempty" xml:"DiscreteProperty,omitempty"`
	// The sample value.
	Value *float32 `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue) String() string {
	return tea.Prettify(s)
}

func (s ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue) GoString() string {
	return s.String()
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue) SetBizDate(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue {
	s.BizDate = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue) SetDiscreteProperty(v string) *ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue {
	s.DiscreteProperty = &v
	return s
}

func (s *ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue) SetValue(v float32) *ListQualityResultsByRuleResponseBodyDataRuleChecksSampleValue {
	s.Value = &v
	return s
}

type ListQualityResultsByRuleResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListQualityResultsByRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListQualityResultsByRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ListQualityResultsByRuleResponse) GoString() string {
	return s.String()
}

func (s *ListQualityResultsByRuleResponse) SetHeaders(v map[string]*string) *ListQualityResultsByRuleResponse {
	s.Headers = v
	return s
}

func (s *ListQualityResultsByRuleResponse) SetStatusCode(v int32) *ListQualityResultsByRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ListQualityResultsByRuleResponse) SetBody(v *ListQualityResultsByRuleResponseBody) *ListQualityResultsByRuleResponse {
	s.Body = v
	return s
}

type ListQualityRulesRequest struct {
	// The ID of the partition filter expression. You can call the [GetQualityEntity](~~174003~~) operation to query the ID of the partition filter expression.
	EntityId *int64 `json:"EntityId,omitempty" xml:"EntityId,omitempty"`
	// The number of the page to return.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 20.
	PageSize  *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the compute engine instance or data source. You can obtain the name from data source configurations.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s ListQualityRulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListQualityRulesRequest) GoString() string {
	return s.String()
}

func (s *ListQualityRulesRequest) SetEntityId(v int64) *ListQualityRulesRequest {
	s.EntityId = &v
	return s
}

func (s *ListQualityRulesRequest) SetPageNumber(v int32) *ListQualityRulesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListQualityRulesRequest) SetPageSize(v int32) *ListQualityRulesRequest {
	s.PageSize = &v
	return s
}

func (s *ListQualityRulesRequest) SetProjectId(v int64) *ListQualityRulesRequest {
	s.ProjectId = &v
	return s
}

func (s *ListQualityRulesRequest) SetProjectName(v string) *ListQualityRulesRequest {
	s.ProjectName = &v
	return s
}

type ListQualityRulesResponseBody struct {
	// The list of monitoring rules.
	Data *ListQualityRulesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot errors.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListQualityRulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListQualityRulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListQualityRulesResponseBody) SetData(v *ListQualityRulesResponseBodyData) *ListQualityRulesResponseBody {
	s.Data = v
	return s
}

func (s *ListQualityRulesResponseBody) SetErrorCode(v string) *ListQualityRulesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListQualityRulesResponseBody) SetErrorMessage(v string) *ListQualityRulesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListQualityRulesResponseBody) SetHttpStatusCode(v int32) *ListQualityRulesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListQualityRulesResponseBody) SetRequestId(v string) *ListQualityRulesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListQualityRulesResponseBody) SetSuccess(v bool) *ListQualityRulesResponseBody {
	s.Success = &v
	return s
}

type ListQualityRulesResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The details of the monitoring rules.
	Rules []*ListQualityRulesResponseBodyDataRules `json:"Rules,omitempty" xml:"Rules,omitempty" type:"Repeated"`
	// The total number of returned entries.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListQualityRulesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListQualityRulesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListQualityRulesResponseBodyData) SetPageNumber(v int32) *ListQualityRulesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListQualityRulesResponseBodyData) SetPageSize(v int32) *ListQualityRulesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListQualityRulesResponseBodyData) SetRules(v []*ListQualityRulesResponseBodyDataRules) *ListQualityRulesResponseBodyData {
	s.Rules = v
	return s
}

func (s *ListQualityRulesResponseBodyData) SetTotalCount(v int64) *ListQualityRulesResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListQualityRulesResponseBodyDataRules struct {
	// The strength of the monitoring rule. The strength of a monitoring rule indicates the importance of the rule. Valid values:
	//
	// *   1: The monitoring rule is a strong rule.
	//
	// *   0: The monitoring rule is a weak rule.
	//
	//     You can specify whether a monitoring rule is a strong rule based on your business requirements. If a strong rule is used and a critical alert is reported, nodes are blocked.
	BlockType *int32 `json:"BlockType,omitempty" xml:"BlockType,omitempty"`
	// The ID of the checker.
	CheckerId *int32 `json:"CheckerId,omitempty" xml:"CheckerId,omitempty"`
	// The description of the monitoring rule.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The threshold for a critical alert. The threshold indicates the deviation of the monitoring result from the expected value. You can customize this threshold based on your business requirements. If a strong rule is used and a critical alert is reported, nodes are blocked.
	CriticalThreshold *string `json:"CriticalThreshold,omitempty" xml:"CriticalThreshold,omitempty"`
	// The ID of the partition filter expression.
	EntityId *int64 `json:"EntityId,omitempty" xml:"EntityId,omitempty"`
	// The expected value.
	ExpectValue *string `json:"ExpectValue,omitempty" xml:"ExpectValue,omitempty"`
	// Indicates whether the monitoring is performed based on a fixed value.
	FixCheck *bool `json:"FixCheck,omitempty" xml:"FixCheck,omitempty"`
	// The historical threshold for a critical alert.
	HistoryCriticalThreshold *string `json:"HistoryCriticalThreshold,omitempty" xml:"HistoryCriticalThreshold,omitempty"`
	// The historical threshold for a warning alert.
	HistoryWarningThreshold *string `json:"HistoryWarningThreshold,omitempty" xml:"HistoryWarningThreshold,omitempty"`
	// The ID of the monitoring rule.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The partition filter expression.
	MatchExpression *string `json:"MatchExpression,omitempty" xml:"MatchExpression,omitempty"`
	// The ID of the sampling method of the monitoring rule.
	MethodId *int32 `json:"MethodId,omitempty" xml:"MethodId,omitempty"`
	// The name of the method that is used to collect sample data, such as avg, count, sum, min, max, count_distinct, user_defined, table_count, table_size, table_dt_load_count, table_dt_refuseload_count, null_value, null_value/table_count, (table_count-count_distinct)/table_count, or table_count-count_distinct.
	MethodName *string `json:"MethodName,omitempty" xml:"MethodName,omitempty"`
	// The ID of the Alibaba Cloud account that is used to configure the monitoring rule.
	OnDuty *string `json:"OnDuty,omitempty" xml:"OnDuty,omitempty"`
	// The name of the Alibaba Cloud account that is used to configure the monitoring rule.
	OnDutyAccountName *string `json:"OnDutyAccountName,omitempty" xml:"OnDutyAccountName,omitempty"`
	// The name of the compute engine instance or data source.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The name of the monitored field.
	Property *string `json:"Property,omitempty" xml:"Property,omitempty"`
	// The field that is used to associate with monitoring rules at the frontend. This parameter can be ignored.
	PropertyKey *string `json:"PropertyKey,omitempty" xml:"PropertyKey,omitempty"`
	// The ID of the node that is associated with the partition filter expression.
	RuleCheckerRelationId *int64 `json:"RuleCheckerRelationId,omitempty" xml:"RuleCheckerRelationId,omitempty"`
	// The name of the monitoring rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The type of the monitoring rule. Valid values:
	//
	// *   0: The monitoring rule is created by the system.
	// *   1: The monitoring rule is created by a user.
	// *   2: The monitoring rule is a workspace-level rule.
	RuleType *int32 `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the monitoring template.
	TemplateId *int32 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The name of the monitoring template.
	TemplateName *string `json:"TemplateName,omitempty" xml:"TemplateName,omitempty"`
	// The trend of the monitoring results.
	Trend *string `json:"Trend,omitempty" xml:"Trend,omitempty"`
	// The threshold for a warning alert. The threshold indicates the deviation of the monitoring result from the expected value. You can customize this threshold based on your business requirements.
	WarningThreshold *string `json:"WarningThreshold,omitempty" xml:"WarningThreshold,omitempty"`
}

func (s ListQualityRulesResponseBodyDataRules) String() string {
	return tea.Prettify(s)
}

func (s ListQualityRulesResponseBodyDataRules) GoString() string {
	return s.String()
}

func (s *ListQualityRulesResponseBodyDataRules) SetBlockType(v int32) *ListQualityRulesResponseBodyDataRules {
	s.BlockType = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetCheckerId(v int32) *ListQualityRulesResponseBodyDataRules {
	s.CheckerId = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetComment(v string) *ListQualityRulesResponseBodyDataRules {
	s.Comment = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetCriticalThreshold(v string) *ListQualityRulesResponseBodyDataRules {
	s.CriticalThreshold = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetEntityId(v int64) *ListQualityRulesResponseBodyDataRules {
	s.EntityId = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetExpectValue(v string) *ListQualityRulesResponseBodyDataRules {
	s.ExpectValue = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetFixCheck(v bool) *ListQualityRulesResponseBodyDataRules {
	s.FixCheck = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetHistoryCriticalThreshold(v string) *ListQualityRulesResponseBodyDataRules {
	s.HistoryCriticalThreshold = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetHistoryWarningThreshold(v string) *ListQualityRulesResponseBodyDataRules {
	s.HistoryWarningThreshold = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetId(v int64) *ListQualityRulesResponseBodyDataRules {
	s.Id = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetMatchExpression(v string) *ListQualityRulesResponseBodyDataRules {
	s.MatchExpression = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetMethodId(v int32) *ListQualityRulesResponseBodyDataRules {
	s.MethodId = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetMethodName(v string) *ListQualityRulesResponseBodyDataRules {
	s.MethodName = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetOnDuty(v string) *ListQualityRulesResponseBodyDataRules {
	s.OnDuty = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetOnDutyAccountName(v string) *ListQualityRulesResponseBodyDataRules {
	s.OnDutyAccountName = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetProjectName(v string) *ListQualityRulesResponseBodyDataRules {
	s.ProjectName = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetProperty(v string) *ListQualityRulesResponseBodyDataRules {
	s.Property = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetPropertyKey(v string) *ListQualityRulesResponseBodyDataRules {
	s.PropertyKey = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetRuleCheckerRelationId(v int64) *ListQualityRulesResponseBodyDataRules {
	s.RuleCheckerRelationId = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetRuleName(v string) *ListQualityRulesResponseBodyDataRules {
	s.RuleName = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetRuleType(v int32) *ListQualityRulesResponseBodyDataRules {
	s.RuleType = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetTableName(v string) *ListQualityRulesResponseBodyDataRules {
	s.TableName = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetTemplateId(v int32) *ListQualityRulesResponseBodyDataRules {
	s.TemplateId = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetTemplateName(v string) *ListQualityRulesResponseBodyDataRules {
	s.TemplateName = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetTrend(v string) *ListQualityRulesResponseBodyDataRules {
	s.Trend = &v
	return s
}

func (s *ListQualityRulesResponseBodyDataRules) SetWarningThreshold(v string) *ListQualityRulesResponseBodyDataRules {
	s.WarningThreshold = &v
	return s
}

type ListQualityRulesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListQualityRulesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListQualityRulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListQualityRulesResponse) GoString() string {
	return s.String()
}

func (s *ListQualityRulesResponse) SetHeaders(v map[string]*string) *ListQualityRulesResponse {
	s.Headers = v
	return s
}

func (s *ListQualityRulesResponse) SetStatusCode(v int32) *ListQualityRulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListQualityRulesResponse) SetBody(v *ListQualityRulesResponseBody) *ListQualityRulesResponse {
	s.Body = v
	return s
}

type ListRefDISyncTasksRequest struct {
	// The name of the data source. You can call the [ListDataSources](~~211431~~) operation to query the name of the data source.
	DatasourceName *string `json:"DatasourceName,omitempty" xml:"DatasourceName,omitempty"`
	// The number of the page to return.
	PageNumber *int64 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page.
	PageSize *int64 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The condition used to filter sync nodes. Valid values:
	//
	// *   from: queries the sync nodes that use the data source as the source data source.
	// *   to: queries the sync nodes that use the data source as the destination data source.
	RefType *string `json:"RefType,omitempty" xml:"RefType,omitempty"`
	// The type of the sync node that you want to query. Valid values:
	//
	// *   DI_OFFLINE: batch sync node
	// *   DI_REALTIME: real-time sync node
	//
	// You can specify only one type. The sync solution type is not supported.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s ListRefDISyncTasksRequest) String() string {
	return tea.Prettify(s)
}

func (s ListRefDISyncTasksRequest) GoString() string {
	return s.String()
}

func (s *ListRefDISyncTasksRequest) SetDatasourceName(v string) *ListRefDISyncTasksRequest {
	s.DatasourceName = &v
	return s
}

func (s *ListRefDISyncTasksRequest) SetPageNumber(v int64) *ListRefDISyncTasksRequest {
	s.PageNumber = &v
	return s
}

func (s *ListRefDISyncTasksRequest) SetPageSize(v int64) *ListRefDISyncTasksRequest {
	s.PageSize = &v
	return s
}

func (s *ListRefDISyncTasksRequest) SetProjectId(v int64) *ListRefDISyncTasksRequest {
	s.ProjectId = &v
	return s
}

func (s *ListRefDISyncTasksRequest) SetRefType(v string) *ListRefDISyncTasksRequest {
	s.RefType = &v
	return s
}

func (s *ListRefDISyncTasksRequest) SetTaskType(v string) *ListRefDISyncTasksRequest {
	s.TaskType = &v
	return s
}

type ListRefDISyncTasksResponseBody struct {
	// The data returned for the query.
	Data      *ListRefDISyncTasksResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	RequestId *string                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListRefDISyncTasksResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListRefDISyncTasksResponseBody) GoString() string {
	return s.String()
}

func (s *ListRefDISyncTasksResponseBody) SetData(v *ListRefDISyncTasksResponseBodyData) *ListRefDISyncTasksResponseBody {
	s.Data = v
	return s
}

func (s *ListRefDISyncTasksResponseBody) SetRequestId(v string) *ListRefDISyncTasksResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListRefDISyncTasksResponseBody) SetSuccess(v bool) *ListRefDISyncTasksResponseBody {
	s.Success = &v
	return s
}

type ListRefDISyncTasksResponseBodyData struct {
	// The details of the sync nodes.
	//
	// A data source is usually associated with multiple sync nodes. Therefore, the value of this parameter is an array. The following parameters are the elements in the array. The sample values of these parameters show the details of a sync node.
	DISyncTasks []*ListRefDISyncTasksResponseBodyDataDISyncTasks `json:"DISyncTasks,omitempty" xml:"DISyncTasks,omitempty" type:"Repeated"`
}

func (s ListRefDISyncTasksResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListRefDISyncTasksResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListRefDISyncTasksResponseBodyData) SetDISyncTasks(v []*ListRefDISyncTasksResponseBodyDataDISyncTasks) *ListRefDISyncTasksResponseBodyData {
	s.DISyncTasks = v
	return s
}

type ListRefDISyncTasksResponseBodyDataDISyncTasks struct {
	// The destination data source of the sync node.
	//
	// If the sync node has multiple destination data sources, the return value is a JSON array, such as \\"odps_writer\\", \\"mysql\\".
	//
	// If the RefType parameter is set to to, the sync nodes that use the specified data source as the destination data source are returned. In this case, the value of this parameter indicates the specified data source.
	DiDestinationDatasource *string `json:"DiDestinationDatasource,omitempty" xml:"DiDestinationDatasource,omitempty"`
	// The source data source of the sync node.
	//
	// If the sync node has multiple source data sources, the return value is a JSON array, such as \\"odps_writer\\", \\"mysql\\".
	//
	// If the RefType parameter is set to from, the sync nodes that use the specified data source as the source data source are returned. In this case, the value of this parameter indicates the specified data source.
	DiSourceDatasource *string `json:"DiSourceDatasource,omitempty" xml:"DiSourceDatasource,omitempty"`
	// The ID of the sync node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the sync node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The type of the sync node. Valid values:
	//
	// *   DI_OFFLINE: batch sync node
	// *   DI_REALTIME: real-time sync node
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s ListRefDISyncTasksResponseBodyDataDISyncTasks) String() string {
	return tea.Prettify(s)
}

func (s ListRefDISyncTasksResponseBodyDataDISyncTasks) GoString() string {
	return s.String()
}

func (s *ListRefDISyncTasksResponseBodyDataDISyncTasks) SetDiDestinationDatasource(v string) *ListRefDISyncTasksResponseBodyDataDISyncTasks {
	s.DiDestinationDatasource = &v
	return s
}

func (s *ListRefDISyncTasksResponseBodyDataDISyncTasks) SetDiSourceDatasource(v string) *ListRefDISyncTasksResponseBodyDataDISyncTasks {
	s.DiSourceDatasource = &v
	return s
}

func (s *ListRefDISyncTasksResponseBodyDataDISyncTasks) SetNodeId(v int64) *ListRefDISyncTasksResponseBodyDataDISyncTasks {
	s.NodeId = &v
	return s
}

func (s *ListRefDISyncTasksResponseBodyDataDISyncTasks) SetNodeName(v string) *ListRefDISyncTasksResponseBodyDataDISyncTasks {
	s.NodeName = &v
	return s
}

func (s *ListRefDISyncTasksResponseBodyDataDISyncTasks) SetTaskType(v string) *ListRefDISyncTasksResponseBodyDataDISyncTasks {
	s.TaskType = &v
	return s
}

type ListRefDISyncTasksResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListRefDISyncTasksResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListRefDISyncTasksResponse) String() string {
	return tea.Prettify(s)
}

func (s ListRefDISyncTasksResponse) GoString() string {
	return s.String()
}

func (s *ListRefDISyncTasksResponse) SetHeaders(v map[string]*string) *ListRefDISyncTasksResponse {
	s.Headers = v
	return s
}

func (s *ListRefDISyncTasksResponse) SetStatusCode(v int32) *ListRefDISyncTasksResponse {
	s.StatusCode = &v
	return s
}

func (s *ListRefDISyncTasksResponse) SetBody(v *ListRefDISyncTasksResponseBody) *ListRefDISyncTasksResponse {
	s.Body = v
	return s
}

type ListRemindsRequest struct {
	// The ID of the Alibaba Cloud account that is used to receive alert notifications.
	AlertTarget *string `json:"AlertTarget,omitempty" xml:"AlertTarget,omitempty"`
	// The ID of the Alibaba Cloud account that is used to create the custom alert rules.
	Founder *string `json:"Founder,omitempty" xml:"Founder,omitempty"`
	// The ID of the node to which the custom alert rules are applied. You can use the ID to search for the custom alert rules that are applied to the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The number of the page to return. Valid values: 1 to 30. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The conditions that trigger an alert for the node. Valid values: FINISHED, UNFINISHED, ERROR, CYCLE_UNFINISHED, and TIMEOUT. The value FINISHED indicates that the node finishes running. The value UNFINISHED indicates that the node is still running at the specified point in time. The value ERROR indicates that an error occurs when the node is running. The value CYCLE_UNFINISHED indicates that the node does not finish running in the specified scheduling cycle. The value TIMEOUT indicates that the node times out. You can specify multiple conditions for a custom alert rule. If you specify multiple condition, separate them with commas (,).
	RemindTypes *string `json:"RemindTypes,omitempty" xml:"RemindTypes,omitempty"`
	// The keyword in a rule name that is used to search for the rule. Fuzzy search is supported.
	SearchText *string `json:"SearchText,omitempty" xml:"SearchText,omitempty"`
}

func (s ListRemindsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListRemindsRequest) GoString() string {
	return s.String()
}

func (s *ListRemindsRequest) SetAlertTarget(v string) *ListRemindsRequest {
	s.AlertTarget = &v
	return s
}

func (s *ListRemindsRequest) SetFounder(v string) *ListRemindsRequest {
	s.Founder = &v
	return s
}

func (s *ListRemindsRequest) SetNodeId(v int64) *ListRemindsRequest {
	s.NodeId = &v
	return s
}

func (s *ListRemindsRequest) SetPageNumber(v int32) *ListRemindsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListRemindsRequest) SetPageSize(v int32) *ListRemindsRequest {
	s.PageSize = &v
	return s
}

func (s *ListRemindsRequest) SetRemindTypes(v string) *ListRemindsRequest {
	s.RemindTypes = &v
	return s
}

func (s *ListRemindsRequest) SetSearchText(v string) *ListRemindsRequest {
	s.SearchText = &v
	return s
}

type ListRemindsResponseBody struct {
	// The information about custom alert rules returned.
	Data *ListRemindsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListRemindsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListRemindsResponseBody) GoString() string {
	return s.String()
}

func (s *ListRemindsResponseBody) SetData(v *ListRemindsResponseBodyData) *ListRemindsResponseBody {
	s.Data = v
	return s
}

func (s *ListRemindsResponseBody) SetErrorCode(v string) *ListRemindsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListRemindsResponseBody) SetErrorMessage(v string) *ListRemindsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListRemindsResponseBody) SetHttpStatusCode(v int32) *ListRemindsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListRemindsResponseBody) SetRequestId(v string) *ListRemindsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListRemindsResponseBody) SetSuccess(v bool) *ListRemindsResponseBody {
	s.Success = &v
	return s
}

type ListRemindsResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The custom alert rules returned.
	Reminds []*ListRemindsResponseBodyDataReminds `json:"Reminds,omitempty" xml:"Reminds,omitempty" type:"Repeated"`
	// The total number of custom alert rules returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListRemindsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListRemindsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListRemindsResponseBodyData) SetPageNumber(v int32) *ListRemindsResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListRemindsResponseBodyData) SetPageSize(v int32) *ListRemindsResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListRemindsResponseBodyData) SetReminds(v []*ListRemindsResponseBodyDataReminds) *ListRemindsResponseBodyData {
	s.Reminds = v
	return s
}

func (s *ListRemindsResponseBodyData) SetTotalCount(v int32) *ListRemindsResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListRemindsResponseBodyDataReminds struct {
	// The notification method. Valid values: MAIL, SMS, and PHONE. The value MAIL indicates that the notification is sent by email. The value SMS indicates that the notification is sent by text message. The value PHONE indicates that the notification is sent by call, which is supported only by DataWorks Professional Edition and more advanced editions.
	AlertMethods []*string `json:"AlertMethods,omitempty" xml:"AlertMethods,omitempty" type:"Repeated"`
	// The IDs of the Alibaba Cloud accounts that are used to receive alert notifications.
	AlertTargets []*string `json:"AlertTargets,omitempty" xml:"AlertTargets,omitempty" type:"Repeated"`
	// The alert recipient. Valid values: OWNER and OTHER. The value OWNER indicates the node owner. The value OTHER indicates a specified user.
	AlertUnit *string `json:"AlertUnit,omitempty" xml:"AlertUnit,omitempty"`
	// The IDs of the baselines to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is BASELINE.
	BaselineIds []*int64 `json:"BaselineIds,omitempty" xml:"BaselineIds,omitempty" type:"Repeated"`
	// The IDs of the workflows to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is BIZPROCESS.
	BizProcessIds []*int64 `json:"BizProcessIds,omitempty" xml:"BizProcessIds,omitempty" type:"Repeated"`
	// The end time of the quiet hours. The value is in the hh:mm format. Valid values of hh: 0 to 23. Valid values of mm: 0 to 59.
	DndEnd *string `json:"DndEnd,omitempty" xml:"DndEnd,omitempty"`
	// The start time of the quiet hours. The value is in the hh:mm format. Valid values of hh: 0 to 23. Valid values of mm: 0 to 59.
	DndStart *string `json:"DndStart,omitempty" xml:"DndStart,omitempty"`
	// The ID of the Alibaba Cloud account that is used to create the custom alert rule.
	Founder *string `json:"Founder,omitempty" xml:"Founder,omitempty"`
	// The IDs of the nodes to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is NODE.
	NodeIds []*int64 `json:"NodeIds,omitempty" xml:"NodeIds,omitempty" type:"Repeated"`
	// The IDs of the workspaces to which the custom alert rule is applied. This parameter is returned if the value of the RemindUnit parameter is PROJECT.
	ProjectIds []*int64 `json:"ProjectIds,omitempty" xml:"ProjectIds,omitempty" type:"Repeated"`
	// The ID of the custom alert rule.
	RemindId *int64 `json:"RemindId,omitempty" xml:"RemindId,omitempty"`
	// The name of the custom alert rule.
	RemindName *string `json:"RemindName,omitempty" xml:"RemindName,omitempty"`
	// The conditions that trigger an alert for the node. Valid values: FINISHED, UNFINISHED, ERROR, CYCLE_UNFINISHED, and TIMEOUT. The value FINISHED indicates that the node finishes running. The value UNFINISHED indicates that the node is still running at the specified point in time. The value ERROR indicates that an error occurs when the node is running. The value CYCLE_UNFINISHED indicates that the node does not finish running in the specified scheduling cycle. The value TIMEOUT indicates that the node times out.
	RemindType *string `json:"RemindType,omitempty" xml:"RemindType,omitempty"`
	// The type of the object to which the custom alert rule is applied. Valid values: NODE, BASELINE, PROJECT, and BIZPROCESS. The value NODE indicates that the monitored object is a node. The value BASELINE indicates that the monitored object is a baseline. The value PROJECT indicates that the monitored object is a workspace. The value BIZPROCESS indicates that the monitored object is a workflow.
	RemindUnit *string `json:"RemindUnit,omitempty" xml:"RemindUnit,omitempty"`
	// Indicates whether the custom alert rule is enabled. Valid values: true and false.
	Useflag *bool `json:"Useflag,omitempty" xml:"Useflag,omitempty"`
}

func (s ListRemindsResponseBodyDataReminds) String() string {
	return tea.Prettify(s)
}

func (s ListRemindsResponseBodyDataReminds) GoString() string {
	return s.String()
}

func (s *ListRemindsResponseBodyDataReminds) SetAlertMethods(v []*string) *ListRemindsResponseBodyDataReminds {
	s.AlertMethods = v
	return s
}

func (s *ListRemindsResponseBodyDataReminds) SetAlertTargets(v []*string) *ListRemindsResponseBodyDataReminds {
	s.AlertTargets = v
	return s
}

func (s *ListRemindsResponseBodyDataReminds) SetAlertUnit(v string) *ListRemindsResponseBodyDataReminds {
	s.AlertUnit = &v
	return s
}

func (s *ListRemindsResponseBodyDataReminds) SetBaselineIds(v []*int64) *ListRemindsResponseBodyDataReminds {
	s.BaselineIds = v
	return s
}

func (s *ListRemindsResponseBodyDataReminds) SetBizProcessIds(v []*int64) *ListRemindsResponseBodyDataReminds {
	s.BizProcessIds = v
	return s
}

func (s *ListRemindsResponseBodyDataReminds) SetDndEnd(v string) *ListRemindsResponseBodyDataReminds {
	s.DndEnd = &v
	return s
}

func (s *ListRemindsResponseBodyDataReminds) SetDndStart(v string) *ListRemindsResponseBodyDataReminds {
	s.DndStart = &v
	return s
}

func (s *ListRemindsResponseBodyDataReminds) SetFounder(v string) *ListRemindsResponseBodyDataReminds {
	s.Founder = &v
	return s
}

func (s *ListRemindsResponseBodyDataReminds) SetNodeIds(v []*int64) *ListRemindsResponseBodyDataReminds {
	s.NodeIds = v
	return s
}

func (s *ListRemindsResponseBodyDataReminds) SetProjectIds(v []*int64) *ListRemindsResponseBodyDataReminds {
	s.ProjectIds = v
	return s
}

func (s *ListRemindsResponseBodyDataReminds) SetRemindId(v int64) *ListRemindsResponseBodyDataReminds {
	s.RemindId = &v
	return s
}

func (s *ListRemindsResponseBodyDataReminds) SetRemindName(v string) *ListRemindsResponseBodyDataReminds {
	s.RemindName = &v
	return s
}

func (s *ListRemindsResponseBodyDataReminds) SetRemindType(v string) *ListRemindsResponseBodyDataReminds {
	s.RemindType = &v
	return s
}

func (s *ListRemindsResponseBodyDataReminds) SetRemindUnit(v string) *ListRemindsResponseBodyDataReminds {
	s.RemindUnit = &v
	return s
}

func (s *ListRemindsResponseBodyDataReminds) SetUseflag(v bool) *ListRemindsResponseBodyDataReminds {
	s.Useflag = &v
	return s
}

type ListRemindsResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListRemindsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListRemindsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListRemindsResponse) GoString() string {
	return s.String()
}

func (s *ListRemindsResponse) SetHeaders(v map[string]*string) *ListRemindsResponse {
	s.Headers = v
	return s
}

func (s *ListRemindsResponse) SetStatusCode(v int32) *ListRemindsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListRemindsResponse) SetBody(v *ListRemindsResponseBody) *ListRemindsResponse {
	s.Body = v
	return s
}

type ListResourceGroupsRequest struct {
	// The tags.
	BizExtKey *string `json:"BizExtKey,omitempty" xml:"BizExtKey,omitempty"`
	// The ID of the resource group.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The category of the resource groups. Valid values:
	//
	// *   default: shared resource group
	// *   single: exclusive resource group
	// *   Default value: default
	ResourceGroupType *int32 `json:"ResourceGroupType,omitempty" xml:"ResourceGroupType,omitempty"`
	// The tag key.
	ResourceManagerResourceGroupId *string `json:"ResourceManagerResourceGroupId,omitempty" xml:"ResourceManagerResourceGroupId,omitempty"`
	// The tag value.
	Tags []*ListResourceGroupsRequestTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s ListResourceGroupsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupsRequest) GoString() string {
	return s.String()
}

func (s *ListResourceGroupsRequest) SetBizExtKey(v string) *ListResourceGroupsRequest {
	s.BizExtKey = &v
	return s
}

func (s *ListResourceGroupsRequest) SetKeyword(v string) *ListResourceGroupsRequest {
	s.Keyword = &v
	return s
}

func (s *ListResourceGroupsRequest) SetResourceGroupType(v int32) *ListResourceGroupsRequest {
	s.ResourceGroupType = &v
	return s
}

func (s *ListResourceGroupsRequest) SetResourceManagerResourceGroupId(v string) *ListResourceGroupsRequest {
	s.ResourceManagerResourceGroupId = &v
	return s
}

func (s *ListResourceGroupsRequest) SetTags(v []*ListResourceGroupsRequestTags) *ListResourceGroupsRequest {
	s.Tags = v
	return s
}

type ListResourceGroupsRequestTags struct {
	// The HTTP status code returned.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListResourceGroupsRequestTags) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupsRequestTags) GoString() string {
	return s.String()
}

func (s *ListResourceGroupsRequestTags) SetKey(v string) *ListResourceGroupsRequestTags {
	s.Key = &v
	return s
}

func (s *ListResourceGroupsRequestTags) SetValue(v string) *ListResourceGroupsRequestTags {
	s.Value = &v
	return s
}

type ListResourceGroupsShrinkRequest struct {
	// The tags.
	BizExtKey *string `json:"BizExtKey,omitempty" xml:"BizExtKey,omitempty"`
	// The ID of the resource group.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The category of the resource groups. Valid values:
	//
	// *   default: shared resource group
	// *   single: exclusive resource group
	// *   Default value: default
	ResourceGroupType *int32 `json:"ResourceGroupType,omitempty" xml:"ResourceGroupType,omitempty"`
	// The tag key.
	ResourceManagerResourceGroupId *string `json:"ResourceManagerResourceGroupId,omitempty" xml:"ResourceManagerResourceGroupId,omitempty"`
	// The tag value.
	TagsShrink *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s ListResourceGroupsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupsShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListResourceGroupsShrinkRequest) SetBizExtKey(v string) *ListResourceGroupsShrinkRequest {
	s.BizExtKey = &v
	return s
}

func (s *ListResourceGroupsShrinkRequest) SetKeyword(v string) *ListResourceGroupsShrinkRequest {
	s.Keyword = &v
	return s
}

func (s *ListResourceGroupsShrinkRequest) SetResourceGroupType(v int32) *ListResourceGroupsShrinkRequest {
	s.ResourceGroupType = &v
	return s
}

func (s *ListResourceGroupsShrinkRequest) SetResourceManagerResourceGroupId(v string) *ListResourceGroupsShrinkRequest {
	s.ResourceManagerResourceGroupId = &v
	return s
}

func (s *ListResourceGroupsShrinkRequest) SetTagsShrink(v string) *ListResourceGroupsShrinkRequest {
	s.TagsShrink = &v
	return s
}

type ListResourceGroupsResponseBody struct {
	// The time when the resource group was last updated.
	Data []*ListResourceGroupsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// Indicates whether the request was successful.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The resource groups.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the resource group. Valid values:
	//
	// *   0: The resource group is running or in service.
	// *   1: The resource group has expired and is frozen.
	// *   2: The resource group is released or destroyed.
	// *   3: The resource group is being created or started.
	// *   4: The resource group fails to be created or started.
	// *   5: The resource group is being scaled out or upgraded.
	// *   6: The resource group fails to be scaled out or upgraded.
	// *   7: The resource group is being released or destroyed.
	// *   8: The resource group fails to be released or destroyed.
	// *   9: The operation performed on the resource group times out. All operations may time out. This value is temporarily available only for DataService Studio.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListResourceGroupsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupsResponseBody) GoString() string {
	return s.String()
}

func (s *ListResourceGroupsResponseBody) SetData(v []*ListResourceGroupsResponseBodyData) *ListResourceGroupsResponseBody {
	s.Data = v
	return s
}

func (s *ListResourceGroupsResponseBody) SetHttpStatusCode(v int32) *ListResourceGroupsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListResourceGroupsResponseBody) SetRequestId(v string) *ListResourceGroupsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListResourceGroupsResponseBody) SetSuccess(v bool) *ListResourceGroupsResponseBody {
	s.Success = &v
	return s
}

type ListResourceGroupsResponseBodyData struct {
	// The details of the resource group. The content enclosed in braces {} is the details of the resource group.
	BizExtKey *string `json:"BizExtKey,omitempty" xml:"BizExtKey,omitempty"`
	// The type of the resource group. Valid values:
	//
	// *   0: DataWorks
	// *   2: MaxCompute
	// *   3: PAI
	// *   4: Data Integration
	// *   7: scheduling
	// *   9: DataService Studio
	Cluster *string `json:"Cluster,omitempty" xml:"Cluster,omitempty"`
	// The mode of the resource group. Valid values:
	//
	// *   ISOLATE: exclusive resource group that adopts the subscription billing method
	// *   SHARE: shared resource group that adopts the pay-as-you-go billing method
	// *   DEVELOP: resource group for developers
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The time when the cluster was created. Example: Jul 9, 2018 02:43:37 PM.
	EnableKp *bool `json:"EnableKp,omitempty" xml:"EnableKp,omitempty"`
	// The ID of your Alibaba Cloud resource group.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The category of the resource group. Valid values:
	//
	// *   default: shared resource group
	// *   single: exclusive resource group
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// Indicates whether the UID of an Alibaba Cloud account is used for access. Valid values:
	//
	// *   true: The MaxCompute compute engine uses the UID of the Alibaba Cloud account as the display name of the account for access.
	//
	// *   false: The MaxCompute compute engine uses the name of the Alibaba Cloud account as the display name of the account for access.
	//
	//     The remaining values are useless. This parameter is returned only if the type of the resource group is MaxCompute.
	IsDefault *bool `json:"IsDefault,omitempty" xml:"IsDefault,omitempty"`
	// The sequence number of the resource group. Created resource groups are sorted in ascending order by sequence number.
	Mode *string `json:"Mode,omitempty" xml:"Mode,omitempty"`
	// The ID of the tenant.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The identifier of the resource group.
	ResourceGroupType *string `json:"ResourceGroupType,omitempty" xml:"ResourceGroupType,omitempty"`
	// The tag key.
	ResourceManagerResourceGroupId *string `json:"ResourceManagerResourceGroupId,omitempty" xml:"ResourceManagerResourceGroupId,omitempty"`
	// The name of the resource group.
	Sequence *int32 `json:"Sequence,omitempty" xml:"Sequence,omitempty"`
	// The ID of the resource group.
	Specs map[string]interface{} `json:"Specs,omitempty" xml:"Specs,omitempty"`
	// Indicates whether the resource group is the default resource group. Valid values:
	//
	// *   true: The resource group is the default resource group.
	// *   false: The resource group is not the default resource group.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The tag value.
	Tags []*ListResourceGroupsResponseBodyDataTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
	// The tags.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	// The name of the cluster. This parameter is returned only if the type of the resource group is MaxCompute or PAI.
	UpdateTime *string `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s ListResourceGroupsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListResourceGroupsResponseBodyData) SetBizExtKey(v string) *ListResourceGroupsResponseBodyData {
	s.BizExtKey = &v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetCluster(v string) *ListResourceGroupsResponseBodyData {
	s.Cluster = &v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetCreateTime(v string) *ListResourceGroupsResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetEnableKp(v bool) *ListResourceGroupsResponseBodyData {
	s.EnableKp = &v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetId(v int64) *ListResourceGroupsResponseBodyData {
	s.Id = &v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetIdentifier(v string) *ListResourceGroupsResponseBodyData {
	s.Identifier = &v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetIsDefault(v bool) *ListResourceGroupsResponseBodyData {
	s.IsDefault = &v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetMode(v string) *ListResourceGroupsResponseBodyData {
	s.Mode = &v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetName(v string) *ListResourceGroupsResponseBodyData {
	s.Name = &v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetResourceGroupType(v string) *ListResourceGroupsResponseBodyData {
	s.ResourceGroupType = &v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetResourceManagerResourceGroupId(v string) *ListResourceGroupsResponseBodyData {
	s.ResourceManagerResourceGroupId = &v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetSequence(v int32) *ListResourceGroupsResponseBodyData {
	s.Sequence = &v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetSpecs(v map[string]interface{}) *ListResourceGroupsResponseBodyData {
	s.Specs = v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetStatus(v int32) *ListResourceGroupsResponseBodyData {
	s.Status = &v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetTags(v []*ListResourceGroupsResponseBodyDataTags) *ListResourceGroupsResponseBodyData {
	s.Tags = v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetTenantId(v int64) *ListResourceGroupsResponseBodyData {
	s.TenantId = &v
	return s
}

func (s *ListResourceGroupsResponseBodyData) SetUpdateTime(v string) *ListResourceGroupsResponseBodyData {
	s.UpdateTime = &v
	return s
}

type ListResourceGroupsResponseBodyDataTags struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListResourceGroupsResponseBodyDataTags) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupsResponseBodyDataTags) GoString() string {
	return s.String()
}

func (s *ListResourceGroupsResponseBodyDataTags) SetKey(v string) *ListResourceGroupsResponseBodyDataTags {
	s.Key = &v
	return s
}

func (s *ListResourceGroupsResponseBodyDataTags) SetValue(v string) *ListResourceGroupsResponseBodyDataTags {
	s.Value = &v
	return s
}

type ListResourceGroupsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListResourceGroupsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListResourceGroupsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListResourceGroupsResponse) GoString() string {
	return s.String()
}

func (s *ListResourceGroupsResponse) SetHeaders(v map[string]*string) *ListResourceGroupsResponse {
	s.Headers = v
	return s
}

func (s *ListResourceGroupsResponse) SetStatusCode(v int32) *ListResourceGroupsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListResourceGroupsResponse) SetBody(v *ListResourceGroupsResponseBody) *ListResourceGroupsResponse {
	s.Body = v
	return s
}

type ListShiftPersonnelsRequest struct {
	// The time when the on-duty engineer ends a shift. Set the value to a UNIX timestamp.
	BeginTime *int64 `json:"BeginTime,omitempty" xml:"BeginTime,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time when the on-duty engineer starts a shift. Set the value to a UNIX timestamp.
	ShiftPersonUID *string `json:"ShiftPersonUID,omitempty" xml:"ShiftPersonUID,omitempty"`
	// The type of on-duty engineers that you want to query. Valid values: ALL, PRIMARY, BACKUP, and DESIGNATED_USER.
	ShiftScheduleIdentifier *string `json:"ShiftScheduleIdentifier,omitempty" xml:"ShiftScheduleIdentifier,omitempty"`
	// The ID of your Alibaba Cloud account. You can log on to the DataWorks console and move the pointer over the profile picture in the upper-right corner to obtain the ID.
	UserType *string `json:"UserType,omitempty" xml:"UserType,omitempty"`
}

func (s ListShiftPersonnelsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListShiftPersonnelsRequest) GoString() string {
	return s.String()
}

func (s *ListShiftPersonnelsRequest) SetBeginTime(v int64) *ListShiftPersonnelsRequest {
	s.BeginTime = &v
	return s
}

func (s *ListShiftPersonnelsRequest) SetEndTime(v int64) *ListShiftPersonnelsRequest {
	s.EndTime = &v
	return s
}

func (s *ListShiftPersonnelsRequest) SetShiftPersonUID(v string) *ListShiftPersonnelsRequest {
	s.ShiftPersonUID = &v
	return s
}

func (s *ListShiftPersonnelsRequest) SetShiftScheduleIdentifier(v string) *ListShiftPersonnelsRequest {
	s.ShiftScheduleIdentifier = &v
	return s
}

func (s *ListShiftPersonnelsRequest) SetUserType(v string) *ListShiftPersonnelsRequest {
	s.UserType = &v
	return s
}

type ListShiftPersonnelsResponseBody struct {
	// The page number of the returned page. Minimum value: 1. Maximum value: 100. Default value: 1.
	Paging *ListShiftPersonnelsResponseBodyPaging `json:"Paging,omitempty" xml:"Paging,omitempty" type:"Struct"`
	// The pagination data.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListShiftPersonnelsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListShiftPersonnelsResponseBody) GoString() string {
	return s.String()
}

func (s *ListShiftPersonnelsResponseBody) SetPaging(v *ListShiftPersonnelsResponseBodyPaging) *ListShiftPersonnelsResponseBody {
	s.Paging = v
	return s
}

func (s *ListShiftPersonnelsResponseBody) SetRequestId(v string) *ListShiftPersonnelsResponseBody {
	s.RequestId = &v
	return s
}

type ListShiftPersonnelsResponseBodyPaging struct {
	// The number of entries returned per page. Default value: 10. Maximum value: 100.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The total number of entries returned.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The UID of the on-duty engineer.
	ShiftPersons []*ListShiftPersonnelsResponseBodyPagingShiftPersons `json:"ShiftPersons,omitempty" xml:"ShiftPersons,omitempty" type:"Repeated"`
	// The on-duty engineers in the shift schedule.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListShiftPersonnelsResponseBodyPaging) String() string {
	return tea.Prettify(s)
}

func (s ListShiftPersonnelsResponseBodyPaging) GoString() string {
	return s.String()
}

func (s *ListShiftPersonnelsResponseBodyPaging) SetPageNumber(v int32) *ListShiftPersonnelsResponseBodyPaging {
	s.PageNumber = &v
	return s
}

func (s *ListShiftPersonnelsResponseBodyPaging) SetPageSize(v int32) *ListShiftPersonnelsResponseBodyPaging {
	s.PageSize = &v
	return s
}

func (s *ListShiftPersonnelsResponseBodyPaging) SetShiftPersons(v []*ListShiftPersonnelsResponseBodyPagingShiftPersons) *ListShiftPersonnelsResponseBodyPaging {
	s.ShiftPersons = v
	return s
}

func (s *ListShiftPersonnelsResponseBodyPaging) SetTotalCount(v int32) *ListShiftPersonnelsResponseBodyPaging {
	s.TotalCount = &v
	return s
}

type ListShiftPersonnelsResponseBodyPagingShiftPersons struct {
	// The time when the on-duty engineer ends the shift.
	BeginTime *int64 `json:"BeginTime,omitempty" xml:"BeginTime,omitempty"`
	EndTime   *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The time when the on-duty engineer starts the shift.
	ShiftPersonName *string `json:"ShiftPersonName,omitempty" xml:"ShiftPersonName,omitempty"`
	// The name of the on-duty engineer.
	ShiftPersonUID *string `json:"ShiftPersonUID,omitempty" xml:"ShiftPersonUID,omitempty"`
}

func (s ListShiftPersonnelsResponseBodyPagingShiftPersons) String() string {
	return tea.Prettify(s)
}

func (s ListShiftPersonnelsResponseBodyPagingShiftPersons) GoString() string {
	return s.String()
}

func (s *ListShiftPersonnelsResponseBodyPagingShiftPersons) SetBeginTime(v int64) *ListShiftPersonnelsResponseBodyPagingShiftPersons {
	s.BeginTime = &v
	return s
}

func (s *ListShiftPersonnelsResponseBodyPagingShiftPersons) SetEndTime(v int64) *ListShiftPersonnelsResponseBodyPagingShiftPersons {
	s.EndTime = &v
	return s
}

func (s *ListShiftPersonnelsResponseBodyPagingShiftPersons) SetShiftPersonName(v string) *ListShiftPersonnelsResponseBodyPagingShiftPersons {
	s.ShiftPersonName = &v
	return s
}

func (s *ListShiftPersonnelsResponseBodyPagingShiftPersons) SetShiftPersonUID(v string) *ListShiftPersonnelsResponseBodyPagingShiftPersons {
	s.ShiftPersonUID = &v
	return s
}

type ListShiftPersonnelsResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListShiftPersonnelsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListShiftPersonnelsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListShiftPersonnelsResponse) GoString() string {
	return s.String()
}

func (s *ListShiftPersonnelsResponse) SetHeaders(v map[string]*string) *ListShiftPersonnelsResponse {
	s.Headers = v
	return s
}

func (s *ListShiftPersonnelsResponse) SetStatusCode(v int32) *ListShiftPersonnelsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListShiftPersonnelsResponse) SetBody(v *ListShiftPersonnelsResponseBody) *ListShiftPersonnelsResponse {
	s.Body = v
	return s
}

type ListShiftSchedulesRequest struct {
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of the page to return. Minimum value:1. Maximum value: 100. Default value: 1.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of your Alibaba Cloud account. You can log on to the DataWorks console and move the pointer over the profile picture in the upper-right corner to obtain the ID.
	ShiftScheduleName *string `json:"ShiftScheduleName,omitempty" xml:"ShiftScheduleName,omitempty"`
}

func (s ListShiftSchedulesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListShiftSchedulesRequest) GoString() string {
	return s.String()
}

func (s *ListShiftSchedulesRequest) SetOwner(v string) *ListShiftSchedulesRequest {
	s.Owner = &v
	return s
}

func (s *ListShiftSchedulesRequest) SetPageNumber(v int32) *ListShiftSchedulesRequest {
	s.PageNumber = &v
	return s
}

func (s *ListShiftSchedulesRequest) SetPageSize(v int32) *ListShiftSchedulesRequest {
	s.PageSize = &v
	return s
}

func (s *ListShiftSchedulesRequest) SetShiftScheduleName(v string) *ListShiftSchedulesRequest {
	s.ShiftScheduleName = &v
	return s
}

type ListShiftSchedulesResponseBody struct {
	// The page number of the returned page. Minimum value:1. Maximum value: 100.
	Paging *ListShiftSchedulesResponseBodyPaging `json:"Paging,omitempty" xml:"Paging,omitempty" type:"Struct"`
	// The pagination data.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListShiftSchedulesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListShiftSchedulesResponseBody) GoString() string {
	return s.String()
}

func (s *ListShiftSchedulesResponseBody) SetPaging(v *ListShiftSchedulesResponseBodyPaging) *ListShiftSchedulesResponseBody {
	s.Paging = v
	return s
}

func (s *ListShiftSchedulesResponseBody) SetRequestId(v string) *ListShiftSchedulesResponseBody {
	s.RequestId = &v
	return s
}

type ListShiftSchedulesResponseBodyPaging struct {
	// The number of entries returned per page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The total number of entries returned.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The unique identifier of the shift schedule. You can use the identifier to query the on-duty engineers in the shift schedule.
	ShiftSchedules []*ListShiftSchedulesResponseBodyPagingShiftSchedules `json:"ShiftSchedules,omitempty" xml:"ShiftSchedules,omitempty" type:"Repeated"`
	// The shift schedules.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListShiftSchedulesResponseBodyPaging) String() string {
	return tea.Prettify(s)
}

func (s ListShiftSchedulesResponseBodyPaging) GoString() string {
	return s.String()
}

func (s *ListShiftSchedulesResponseBodyPaging) SetPageNumber(v int32) *ListShiftSchedulesResponseBodyPaging {
	s.PageNumber = &v
	return s
}

func (s *ListShiftSchedulesResponseBodyPaging) SetPageSize(v int32) *ListShiftSchedulesResponseBodyPaging {
	s.PageSize = &v
	return s
}

func (s *ListShiftSchedulesResponseBodyPaging) SetShiftSchedules(v []*ListShiftSchedulesResponseBodyPagingShiftSchedules) *ListShiftSchedulesResponseBodyPaging {
	s.ShiftSchedules = v
	return s
}

func (s *ListShiftSchedulesResponseBodyPaging) SetTotalCount(v int32) *ListShiftSchedulesResponseBodyPaging {
	s.TotalCount = &v
	return s
}

type ListShiftSchedulesResponseBodyPagingShiftSchedules struct {
	// The name of the shift schedule.
	ShiftScheduleIdentifier *string `json:"ShiftScheduleIdentifier,omitempty" xml:"ShiftScheduleIdentifier,omitempty"`
	ShiftScheduleName       *string `json:"ShiftScheduleName,omitempty" xml:"ShiftScheduleName,omitempty"`
}

func (s ListShiftSchedulesResponseBodyPagingShiftSchedules) String() string {
	return tea.Prettify(s)
}

func (s ListShiftSchedulesResponseBodyPagingShiftSchedules) GoString() string {
	return s.String()
}

func (s *ListShiftSchedulesResponseBodyPagingShiftSchedules) SetShiftScheduleIdentifier(v string) *ListShiftSchedulesResponseBodyPagingShiftSchedules {
	s.ShiftScheduleIdentifier = &v
	return s
}

func (s *ListShiftSchedulesResponseBodyPagingShiftSchedules) SetShiftScheduleName(v string) *ListShiftSchedulesResponseBodyPagingShiftSchedules {
	s.ShiftScheduleName = &v
	return s
}

type ListShiftSchedulesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListShiftSchedulesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListShiftSchedulesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListShiftSchedulesResponse) GoString() string {
	return s.String()
}

func (s *ListShiftSchedulesResponse) SetHeaders(v map[string]*string) *ListShiftSchedulesResponse {
	s.Headers = v
	return s
}

func (s *ListShiftSchedulesResponse) SetStatusCode(v int32) *ListShiftSchedulesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListShiftSchedulesResponse) SetBody(v *ListShiftSchedulesResponseBody) *ListShiftSchedulesResponse {
	s.Body = v
	return s
}

type ListSuccessInstanceAmountRequest struct {
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListSuccessInstanceAmountRequest) String() string {
	return tea.Prettify(s)
}

func (s ListSuccessInstanceAmountRequest) GoString() string {
	return s.String()
}

func (s *ListSuccessInstanceAmountRequest) SetProjectId(v int64) *ListSuccessInstanceAmountRequest {
	s.ProjectId = &v
	return s
}

type ListSuccessInstanceAmountResponseBody struct {
	// Indicates the trend of the number of auto triggered node instances that are successfully run every hour on the hour of the current day.
	InstanceStatusTrend *ListSuccessInstanceAmountResponseBodyInstanceStatusTrend `json:"InstanceStatusTrend,omitempty" xml:"InstanceStatusTrend,omitempty" type:"Struct"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s ListSuccessInstanceAmountResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListSuccessInstanceAmountResponseBody) GoString() string {
	return s.String()
}

func (s *ListSuccessInstanceAmountResponseBody) SetInstanceStatusTrend(v *ListSuccessInstanceAmountResponseBodyInstanceStatusTrend) *ListSuccessInstanceAmountResponseBody {
	s.InstanceStatusTrend = v
	return s
}

func (s *ListSuccessInstanceAmountResponseBody) SetRequestId(v string) *ListSuccessInstanceAmountResponseBody {
	s.RequestId = &v
	return s
}

type ListSuccessInstanceAmountResponseBodyInstanceStatusTrend struct {
	// The average trend.
	AvgTrend []*ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend `json:"AvgTrend,omitempty" xml:"AvgTrend,omitempty" type:"Repeated"`
	// The trend of the number of auto triggered node instances that are successfully run on the current day.
	TodayTrend []*ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend `json:"TodayTrend,omitempty" xml:"TodayTrend,omitempty" type:"Repeated"`
	// The trend of the number of auto triggered node instances that are successfully run one day earlier than the current day.
	YesterdayTrend []*ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend `json:"YesterdayTrend,omitempty" xml:"YesterdayTrend,omitempty" type:"Repeated"`
}

func (s ListSuccessInstanceAmountResponseBodyInstanceStatusTrend) String() string {
	return tea.Prettify(s)
}

func (s ListSuccessInstanceAmountResponseBodyInstanceStatusTrend) GoString() string {
	return s.String()
}

func (s *ListSuccessInstanceAmountResponseBodyInstanceStatusTrend) SetAvgTrend(v []*ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend) *ListSuccessInstanceAmountResponseBodyInstanceStatusTrend {
	s.AvgTrend = v
	return s
}

func (s *ListSuccessInstanceAmountResponseBodyInstanceStatusTrend) SetTodayTrend(v []*ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend) *ListSuccessInstanceAmountResponseBodyInstanceStatusTrend {
	s.TodayTrend = v
	return s
}

func (s *ListSuccessInstanceAmountResponseBodyInstanceStatusTrend) SetYesterdayTrend(v []*ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend) *ListSuccessInstanceAmountResponseBodyInstanceStatusTrend {
	s.YesterdayTrend = v
	return s
}

type ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend struct {
	// The number of instances that are successfully run.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The point in time. The value is an exact hour that ranges from 00:00 to 23:00, such as 00:00, 01:00, or 02:00.
	TimePoint *string `json:"TimePoint,omitempty" xml:"TimePoint,omitempty"`
}

func (s ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend) String() string {
	return tea.Prettify(s)
}

func (s ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend) GoString() string {
	return s.String()
}

func (s *ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend) SetCount(v int32) *ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend {
	s.Count = &v
	return s
}

func (s *ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend) SetTimePoint(v string) *ListSuccessInstanceAmountResponseBodyInstanceStatusTrendAvgTrend {
	s.TimePoint = &v
	return s
}

type ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend struct {
	// The number of instances that are successfully run.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The point in time. The value is an exact hour that ranges from 00:00 to 23:00, such as 00:00, 01:00, or 02:00.
	TimePoint *string `json:"TimePoint,omitempty" xml:"TimePoint,omitempty"`
}

func (s ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend) String() string {
	return tea.Prettify(s)
}

func (s ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend) GoString() string {
	return s.String()
}

func (s *ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend) SetCount(v int32) *ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend {
	s.Count = &v
	return s
}

func (s *ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend) SetTimePoint(v string) *ListSuccessInstanceAmountResponseBodyInstanceStatusTrendTodayTrend {
	s.TimePoint = &v
	return s
}

type ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend struct {
	// The number of instances that are successfully run.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The point in time. The value is an exact hour that ranges from 00:00 to 23:00, such as 00:00, 01:00, or 02:00.
	TimePoint *string `json:"TimePoint,omitempty" xml:"TimePoint,omitempty"`
}

func (s ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend) String() string {
	return tea.Prettify(s)
}

func (s ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend) GoString() string {
	return s.String()
}

func (s *ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend) SetCount(v int32) *ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend {
	s.Count = &v
	return s
}

func (s *ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend) SetTimePoint(v string) *ListSuccessInstanceAmountResponseBodyInstanceStatusTrendYesterdayTrend {
	s.TimePoint = &v
	return s
}

type ListSuccessInstanceAmountResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListSuccessInstanceAmountResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListSuccessInstanceAmountResponse) String() string {
	return tea.Prettify(s)
}

func (s ListSuccessInstanceAmountResponse) GoString() string {
	return s.String()
}

func (s *ListSuccessInstanceAmountResponse) SetHeaders(v map[string]*string) *ListSuccessInstanceAmountResponse {
	s.Headers = v
	return s
}

func (s *ListSuccessInstanceAmountResponse) SetStatusCode(v int32) *ListSuccessInstanceAmountResponse {
	s.StatusCode = &v
	return s
}

func (s *ListSuccessInstanceAmountResponse) SetBody(v *ListSuccessInstanceAmountResponseBody) *ListSuccessInstanceAmountResponse {
	s.Body = v
	return s
}

type ListTableLevelRequest struct {
	// The type of the table level. Valid values: 1 and 2. A value of 1 indicates the logical level. A value of 2 indicates the physical level.
	LevelType *int32 `json:"LevelType,omitempty" xml:"LevelType,omitempty"`
	// The number of the page to return. Default value: 1.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console to obtain the ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListTableLevelRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTableLevelRequest) GoString() string {
	return s.String()
}

func (s *ListTableLevelRequest) SetLevelType(v int32) *ListTableLevelRequest {
	s.LevelType = &v
	return s
}

func (s *ListTableLevelRequest) SetPageNum(v int32) *ListTableLevelRequest {
	s.PageNum = &v
	return s
}

func (s *ListTableLevelRequest) SetPageSize(v int32) *ListTableLevelRequest {
	s.PageSize = &v
	return s
}

func (s *ListTableLevelRequest) SetProjectId(v int64) *ListTableLevelRequest {
	s.ProjectId = &v
	return s
}

type ListTableLevelResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The information about the table levels.
	TableLevelInfo *ListTableLevelResponseBodyTableLevelInfo `json:"TableLevelInfo,omitempty" xml:"TableLevelInfo,omitempty" type:"Struct"`
}

func (s ListTableLevelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTableLevelResponseBody) GoString() string {
	return s.String()
}

func (s *ListTableLevelResponseBody) SetErrorCode(v string) *ListTableLevelResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListTableLevelResponseBody) SetErrorMessage(v string) *ListTableLevelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListTableLevelResponseBody) SetHttpStatusCode(v int32) *ListTableLevelResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListTableLevelResponseBody) SetRequestId(v string) *ListTableLevelResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTableLevelResponseBody) SetSuccess(v bool) *ListTableLevelResponseBody {
	s.Success = &v
	return s
}

func (s *ListTableLevelResponseBody) SetTableLevelInfo(v *ListTableLevelResponseBodyTableLevelInfo) *ListTableLevelResponseBody {
	s.TableLevelInfo = v
	return s
}

type ListTableLevelResponseBodyTableLevelInfo struct {
	// The list of table levels.
	LevelList []*ListTableLevelResponseBodyTableLevelInfoLevelList `json:"LevelList,omitempty" xml:"LevelList,omitempty" type:"Repeated"`
	// The total number of table levels returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListTableLevelResponseBodyTableLevelInfo) String() string {
	return tea.Prettify(s)
}

func (s ListTableLevelResponseBodyTableLevelInfo) GoString() string {
	return s.String()
}

func (s *ListTableLevelResponseBodyTableLevelInfo) SetLevelList(v []*ListTableLevelResponseBodyTableLevelInfoLevelList) *ListTableLevelResponseBodyTableLevelInfo {
	s.LevelList = v
	return s
}

func (s *ListTableLevelResponseBodyTableLevelInfo) SetTotalCount(v int64) *ListTableLevelResponseBodyTableLevelInfo {
	s.TotalCount = &v
	return s
}

type ListTableLevelResponseBodyTableLevelInfoLevelList struct {
	// The description of the table level.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the table level.
	LevelId *int64 `json:"LevelId,omitempty" xml:"LevelId,omitempty"`
	// The type of the table level. Valid values: 1 and 2. A value of 1 indicates the logical level. A value of 2 indicates the physical level.
	LevelType *int32 `json:"LevelType,omitempty" xml:"LevelType,omitempty"`
	// The name of the table level.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the DataWorks workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListTableLevelResponseBodyTableLevelInfoLevelList) String() string {
	return tea.Prettify(s)
}

func (s ListTableLevelResponseBodyTableLevelInfoLevelList) GoString() string {
	return s.String()
}

func (s *ListTableLevelResponseBodyTableLevelInfoLevelList) SetDescription(v string) *ListTableLevelResponseBodyTableLevelInfoLevelList {
	s.Description = &v
	return s
}

func (s *ListTableLevelResponseBodyTableLevelInfoLevelList) SetLevelId(v int64) *ListTableLevelResponseBodyTableLevelInfoLevelList {
	s.LevelId = &v
	return s
}

func (s *ListTableLevelResponseBodyTableLevelInfoLevelList) SetLevelType(v int32) *ListTableLevelResponseBodyTableLevelInfoLevelList {
	s.LevelType = &v
	return s
}

func (s *ListTableLevelResponseBodyTableLevelInfoLevelList) SetName(v string) *ListTableLevelResponseBodyTableLevelInfoLevelList {
	s.Name = &v
	return s
}

func (s *ListTableLevelResponseBodyTableLevelInfoLevelList) SetProjectId(v int64) *ListTableLevelResponseBodyTableLevelInfoLevelList {
	s.ProjectId = &v
	return s
}

type ListTableLevelResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListTableLevelResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListTableLevelResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTableLevelResponse) GoString() string {
	return s.String()
}

func (s *ListTableLevelResponse) SetHeaders(v map[string]*string) *ListTableLevelResponse {
	s.Headers = v
	return s
}

func (s *ListTableLevelResponse) SetStatusCode(v int32) *ListTableLevelResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTableLevelResponse) SetBody(v *ListTableLevelResponseBody) *ListTableLevelResponse {
	s.Body = v
	return s
}

type ListTableThemeRequest struct {
	// The number of the page to return.
	PageNum *int32 `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	// The number of entries to return on each page. Default value:10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the parent table folder.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The ID of the DataWorks workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s ListTableThemeRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTableThemeRequest) GoString() string {
	return s.String()
}

func (s *ListTableThemeRequest) SetPageNum(v int32) *ListTableThemeRequest {
	s.PageNum = &v
	return s
}

func (s *ListTableThemeRequest) SetPageSize(v int32) *ListTableThemeRequest {
	s.PageSize = &v
	return s
}

func (s *ListTableThemeRequest) SetParentId(v int64) *ListTableThemeRequest {
	s.ParentId = &v
	return s
}

func (s *ListTableThemeRequest) SetProjectId(v int64) *ListTableThemeRequest {
	s.ProjectId = &v
	return s
}

type ListTableThemeResponseBody struct {
	// The returned data about the level of the table folder.
	Data *ListTableThemeResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListTableThemeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTableThemeResponseBody) GoString() string {
	return s.String()
}

func (s *ListTableThemeResponseBody) SetData(v *ListTableThemeResponseBodyData) *ListTableThemeResponseBody {
	s.Data = v
	return s
}

func (s *ListTableThemeResponseBody) SetErrorCode(v string) *ListTableThemeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListTableThemeResponseBody) SetErrorMessage(v string) *ListTableThemeResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListTableThemeResponseBody) SetHttpStatusCode(v int32) *ListTableThemeResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListTableThemeResponseBody) SetRequestId(v string) *ListTableThemeResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTableThemeResponseBody) SetSuccess(v bool) *ListTableThemeResponseBody {
	s.Success = &v
	return s
}

type ListTableThemeResponseBodyData struct {
	// The list of levels of the table folders.
	ThemeList []*ListTableThemeResponseBodyDataThemeList `json:"ThemeList,omitempty" xml:"ThemeList,omitempty" type:"Repeated"`
	// The total number of table folders.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListTableThemeResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListTableThemeResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListTableThemeResponseBodyData) SetThemeList(v []*ListTableThemeResponseBodyDataThemeList) *ListTableThemeResponseBodyData {
	s.ThemeList = v
	return s
}

func (s *ListTableThemeResponseBodyData) SetTotalCount(v int64) *ListTableThemeResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListTableThemeResponseBodyDataThemeList struct {
	// The time when the level was created.
	CreateTimeStamp *int64 `json:"CreateTimeStamp,omitempty" xml:"CreateTimeStamp,omitempty"`
	// The creator of the level.
	Creator *string `json:"Creator,omitempty" xml:"Creator,omitempty"`
	// The level of the table folder. Valid values: 1 and 2. A value of 1 indicates a table folder of level 1. A value of 2 indicates a table folder of level 2.
	Level *int32 `json:"Level,omitempty" xml:"Level,omitempty"`
	// The name of the level of the table folder.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the parent node.
	ParentId *int64 `json:"ParentId,omitempty" xml:"ParentId,omitempty"`
	// The ID of the DataWorks workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the table folder.
	ThemeId *int64 `json:"ThemeId,omitempty" xml:"ThemeId,omitempty"`
}

func (s ListTableThemeResponseBodyDataThemeList) String() string {
	return tea.Prettify(s)
}

func (s ListTableThemeResponseBodyDataThemeList) GoString() string {
	return s.String()
}

func (s *ListTableThemeResponseBodyDataThemeList) SetCreateTimeStamp(v int64) *ListTableThemeResponseBodyDataThemeList {
	s.CreateTimeStamp = &v
	return s
}

func (s *ListTableThemeResponseBodyDataThemeList) SetCreator(v string) *ListTableThemeResponseBodyDataThemeList {
	s.Creator = &v
	return s
}

func (s *ListTableThemeResponseBodyDataThemeList) SetLevel(v int32) *ListTableThemeResponseBodyDataThemeList {
	s.Level = &v
	return s
}

func (s *ListTableThemeResponseBodyDataThemeList) SetName(v string) *ListTableThemeResponseBodyDataThemeList {
	s.Name = &v
	return s
}

func (s *ListTableThemeResponseBodyDataThemeList) SetParentId(v int64) *ListTableThemeResponseBodyDataThemeList {
	s.ParentId = &v
	return s
}

func (s *ListTableThemeResponseBodyDataThemeList) SetProjectId(v int64) *ListTableThemeResponseBodyDataThemeList {
	s.ProjectId = &v
	return s
}

func (s *ListTableThemeResponseBodyDataThemeList) SetThemeId(v int64) *ListTableThemeResponseBodyDataThemeList {
	s.ThemeId = &v
	return s
}

type ListTableThemeResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListTableThemeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListTableThemeResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTableThemeResponse) GoString() string {
	return s.String()
}

func (s *ListTableThemeResponse) SetHeaders(v map[string]*string) *ListTableThemeResponse {
	s.Headers = v
	return s
}

func (s *ListTableThemeResponse) SetStatusCode(v int32) *ListTableThemeResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTableThemeResponse) SetBody(v *ListTableThemeResponseBody) *ListTableThemeResponse {
	s.Body = v
	return s
}

type ListTopicsRequest struct {
	// The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-dd\"T\"HH:mm:ssZ format. The time must be in UTC.
	BeginTime *string `json:"BeginTime,omitempty" xml:"BeginTime,omitempty"`
	// The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-dd\"T\"HH:mm:ssZ format. The time must be in UTC.
	EndTime *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the node instance that triggers the events. You can configure either this parameter or the NodeId parameter.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the node that triggers the events. You can configure either this parameter or the InstanceId parameter.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the Alibaba Cloud account used by the owner of the events.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The number of the page to return. Valid values: 1 to 30. Default value: 1.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries to return on each page. Default value: 10. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The status of the events. Valid values: IGNORE, NEW, FIXING, and RECOVER. The value IGNORE indicates that the events are ignored. The value NEW indicates that the events are new events. The value FIXING indicates that the events are being processed. The value RECOVER indicates that the events are processed. You can specify multiple states. Separate them with commas (,).
	TopicStatuses *string `json:"TopicStatuses,omitempty" xml:"TopicStatuses,omitempty"`
	// The types of the events. Valid values: SLOW and ERROR. The value SLOW indicates that the running duration of the node in the current scheduling cycle is significantly longer than the average running duration of the node in previous scheduling cycles. The value ERROR indicates that the node fails to run. You can specify multiple types. Separate them with commas (,).
	TopicTypes *string `json:"TopicTypes,omitempty" xml:"TopicTypes,omitempty"`
}

func (s ListTopicsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTopicsRequest) GoString() string {
	return s.String()
}

func (s *ListTopicsRequest) SetBeginTime(v string) *ListTopicsRequest {
	s.BeginTime = &v
	return s
}

func (s *ListTopicsRequest) SetEndTime(v string) *ListTopicsRequest {
	s.EndTime = &v
	return s
}

func (s *ListTopicsRequest) SetInstanceId(v int64) *ListTopicsRequest {
	s.InstanceId = &v
	return s
}

func (s *ListTopicsRequest) SetNodeId(v int64) *ListTopicsRequest {
	s.NodeId = &v
	return s
}

func (s *ListTopicsRequest) SetOwner(v string) *ListTopicsRequest {
	s.Owner = &v
	return s
}

func (s *ListTopicsRequest) SetPageNumber(v int32) *ListTopicsRequest {
	s.PageNumber = &v
	return s
}

func (s *ListTopicsRequest) SetPageSize(v int32) *ListTopicsRequest {
	s.PageSize = &v
	return s
}

func (s *ListTopicsRequest) SetTopicStatuses(v string) *ListTopicsRequest {
	s.TopicStatuses = &v
	return s
}

func (s *ListTopicsRequest) SetTopicTypes(v string) *ListTopicsRequest {
	s.TopicTypes = &v
	return s
}

type ListTopicsResponseBody struct {
	// The information about the events returned.
	Data *ListTopicsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListTopicsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTopicsResponseBody) GoString() string {
	return s.String()
}

func (s *ListTopicsResponseBody) SetData(v *ListTopicsResponseBodyData) *ListTopicsResponseBody {
	s.Data = v
	return s
}

func (s *ListTopicsResponseBody) SetErrorCode(v string) *ListTopicsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ListTopicsResponseBody) SetErrorMessage(v string) *ListTopicsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListTopicsResponseBody) SetHttpStatusCode(v int32) *ListTopicsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ListTopicsResponseBody) SetRequestId(v string) *ListTopicsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTopicsResponseBody) SetSuccess(v bool) *ListTopicsResponseBody {
	s.Success = &v
	return s
}

type ListTopicsResponseBodyData struct {
	// The page number of the returned page.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The events returned.
	Topics []*ListTopicsResponseBodyDataTopics `json:"Topics,omitempty" xml:"Topics,omitempty" type:"Repeated"`
	// The total number of the events returned.
	TotalCount *int32 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s ListTopicsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListTopicsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListTopicsResponseBodyData) SetPageNumber(v int32) *ListTopicsResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *ListTopicsResponseBodyData) SetPageSize(v int32) *ListTopicsResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListTopicsResponseBodyData) SetTopics(v []*ListTopicsResponseBodyDataTopics) *ListTopicsResponseBodyData {
	s.Topics = v
	return s
}

func (s *ListTopicsResponseBodyData) SetTotalCount(v int32) *ListTopicsResponseBodyData {
	s.TotalCount = &v
	return s
}

type ListTopicsResponseBodyDataTopics struct {
	// The timestamp when the event was found.
	AddTime *int64 `json:"AddTime,omitempty" xml:"AddTime,omitempty"`
	// The timestamp when the event was processed.
	FixTime *int64 `json:"FixTime,omitempty" xml:"FixTime,omitempty"`
	// The timestamp when the event occurred. A time difference may exist between the time when the event occurred and the time when the event was found.
	HappenTime *int64 `json:"HappenTime,omitempty" xml:"HappenTime,omitempty"`
	// The ID of the node instance that triggers the event.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the node that triggers the event.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The ID of the Alibaba Cloud account that is used by the node owner.
	NodeOwner *string `json:"NodeOwner,omitempty" xml:"NodeOwner,omitempty"`
	// The ID of the workspace to which the node belongs.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the event.
	TopicId *int64 `json:"TopicId,omitempty" xml:"TopicId,omitempty"`
	// The name of the event.
	TopicName *string `json:"TopicName,omitempty" xml:"TopicName,omitempty"`
	// The status of the event. Valid values: IGNORE, NEW, FIXING, and RECOVER. The value IGNORE indicates that the event is ignored. The value NEW indicates that the event is a new event. The value FIXING indicates that the event is being processed. The value RECOVER indicates that the event is processed.
	TopicStatus *string `json:"TopicStatus,omitempty" xml:"TopicStatus,omitempty"`
	// The type of the event. Valid values: SLOW and ERROR. The value SLOW indicates that the running duration of the node in the current scheduling cycle is significantly longer than the average running duration of the node in previous scheduling cycles. The value ERROR indicates that the node fails to run.
	TopicType *string `json:"TopicType,omitempty" xml:"TopicType,omitempty"`
}

func (s ListTopicsResponseBodyDataTopics) String() string {
	return tea.Prettify(s)
}

func (s ListTopicsResponseBodyDataTopics) GoString() string {
	return s.String()
}

func (s *ListTopicsResponseBodyDataTopics) SetAddTime(v int64) *ListTopicsResponseBodyDataTopics {
	s.AddTime = &v
	return s
}

func (s *ListTopicsResponseBodyDataTopics) SetFixTime(v int64) *ListTopicsResponseBodyDataTopics {
	s.FixTime = &v
	return s
}

func (s *ListTopicsResponseBodyDataTopics) SetHappenTime(v int64) *ListTopicsResponseBodyDataTopics {
	s.HappenTime = &v
	return s
}

func (s *ListTopicsResponseBodyDataTopics) SetInstanceId(v int64) *ListTopicsResponseBodyDataTopics {
	s.InstanceId = &v
	return s
}

func (s *ListTopicsResponseBodyDataTopics) SetNodeId(v int64) *ListTopicsResponseBodyDataTopics {
	s.NodeId = &v
	return s
}

func (s *ListTopicsResponseBodyDataTopics) SetNodeName(v string) *ListTopicsResponseBodyDataTopics {
	s.NodeName = &v
	return s
}

func (s *ListTopicsResponseBodyDataTopics) SetNodeOwner(v string) *ListTopicsResponseBodyDataTopics {
	s.NodeOwner = &v
	return s
}

func (s *ListTopicsResponseBodyDataTopics) SetProjectId(v int64) *ListTopicsResponseBodyDataTopics {
	s.ProjectId = &v
	return s
}

func (s *ListTopicsResponseBodyDataTopics) SetTopicId(v int64) *ListTopicsResponseBodyDataTopics {
	s.TopicId = &v
	return s
}

func (s *ListTopicsResponseBodyDataTopics) SetTopicName(v string) *ListTopicsResponseBodyDataTopics {
	s.TopicName = &v
	return s
}

func (s *ListTopicsResponseBodyDataTopics) SetTopicStatus(v string) *ListTopicsResponseBodyDataTopics {
	s.TopicStatus = &v
	return s
}

func (s *ListTopicsResponseBodyDataTopics) SetTopicType(v string) *ListTopicsResponseBodyDataTopics {
	s.TopicType = &v
	return s
}

type ListTopicsResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ListTopicsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ListTopicsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTopicsResponse) GoString() string {
	return s.String()
}

func (s *ListTopicsResponse) SetHeaders(v map[string]*string) *ListTopicsResponse {
	s.Headers = v
	return s
}

func (s *ListTopicsResponse) SetStatusCode(v int32) *ListTopicsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTopicsResponse) SetBody(v *ListTopicsResponseBody) *ListTopicsResponse {
	s.Body = v
	return s
}

type MountDirectoryRequest struct {
	// The ID of the request. You can use the ID to troubleshoot issues.
	TargetId *string `json:"TargetId,omitempty" xml:"TargetId,omitempty"`
	// The number of directories that are added. Valid values:
	//
	// *   0: No directories are added. The left-side navigation pane may contain the specified directory.
	// *   1: One directory is added.
	TargetType   *string `json:"TargetType,omitempty" xml:"TargetType,omitempty"`
	TargetUserId *string `json:"TargetUserId,omitempty" xml:"TargetUserId,omitempty"`
}

func (s MountDirectoryRequest) String() string {
	return tea.Prettify(s)
}

func (s MountDirectoryRequest) GoString() string {
	return s.String()
}

func (s *MountDirectoryRequest) SetTargetId(v string) *MountDirectoryRequest {
	s.TargetId = &v
	return s
}

func (s *MountDirectoryRequest) SetTargetType(v string) *MountDirectoryRequest {
	s.TargetType = &v
	return s
}

func (s *MountDirectoryRequest) SetTargetUserId(v string) *MountDirectoryRequest {
	s.TargetUserId = &v
	return s
}

type MountDirectoryResponseBody struct {
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Data         *int32  `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode    *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The error message returned if the request failed.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error code returned. The value 200 indicates that the add task is successful.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s MountDirectoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s MountDirectoryResponseBody) GoString() string {
	return s.String()
}

func (s *MountDirectoryResponseBody) SetData(v int32) *MountDirectoryResponseBody {
	s.Data = &v
	return s
}

func (s *MountDirectoryResponseBody) SetErrorCode(v string) *MountDirectoryResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *MountDirectoryResponseBody) SetErrorMessage(v string) *MountDirectoryResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *MountDirectoryResponseBody) SetHttpStatusCode(v int32) *MountDirectoryResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *MountDirectoryResponseBody) SetRequestId(v string) *MountDirectoryResponseBody {
	s.RequestId = &v
	return s
}

func (s *MountDirectoryResponseBody) SetSuccess(v bool) *MountDirectoryResponseBody {
	s.Success = &v
	return s
}

type MountDirectoryResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *MountDirectoryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s MountDirectoryResponse) String() string {
	return tea.Prettify(s)
}

func (s MountDirectoryResponse) GoString() string {
	return s.String()
}

func (s *MountDirectoryResponse) SetHeaders(v map[string]*string) *MountDirectoryResponse {
	s.Headers = v
	return s
}

func (s *MountDirectoryResponse) SetStatusCode(v int32) *MountDirectoryResponse {
	s.StatusCode = &v
	return s
}

func (s *MountDirectoryResponse) SetBody(v *MountDirectoryResponseBody) *MountDirectoryResponse {
	s.Body = v
	return s
}

type OfflineNodeRequest struct {
	// The ID of the DataWorks workspace. You can call the [ListProjects](~~178393~~) operation to obtain the ID.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s OfflineNodeRequest) String() string {
	return tea.Prettify(s)
}

func (s OfflineNodeRequest) GoString() string {
	return s.String()
}

func (s *OfflineNodeRequest) SetNodeId(v int64) *OfflineNodeRequest {
	s.NodeId = &v
	return s
}

func (s *OfflineNodeRequest) SetProjectId(v int64) *OfflineNodeRequest {
	s.ProjectId = &v
	return s
}

type OfflineNodeResponseBody struct {
	// Indicates whether the request is successful.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *string `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s OfflineNodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OfflineNodeResponseBody) GoString() string {
	return s.String()
}

func (s *OfflineNodeResponseBody) SetRequestId(v string) *OfflineNodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *OfflineNodeResponseBody) SetSuccess(v string) *OfflineNodeResponseBody {
	s.Success = &v
	return s
}

type OfflineNodeResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *OfflineNodeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s OfflineNodeResponse) String() string {
	return tea.Prettify(s)
}

func (s OfflineNodeResponse) GoString() string {
	return s.String()
}

func (s *OfflineNodeResponse) SetHeaders(v map[string]*string) *OfflineNodeResponse {
	s.Headers = v
	return s
}

func (s *OfflineNodeResponse) SetStatusCode(v int32) *OfflineNodeResponse {
	s.StatusCode = &v
	return s
}

func (s *OfflineNodeResponse) SetBody(v *OfflineNodeResponseBody) *OfflineNodeResponse {
	s.Body = v
	return s
}

type PublishDataServiceApiRequest struct {
	// The ID of the API. You can call the [ListDataServiceApis](~~174009~~) operation to obtain the ID.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s PublishDataServiceApiRequest) String() string {
	return tea.Prettify(s)
}

func (s PublishDataServiceApiRequest) GoString() string {
	return s.String()
}

func (s *PublishDataServiceApiRequest) SetApiId(v int64) *PublishDataServiceApiRequest {
	s.ApiId = &v
	return s
}

func (s *PublishDataServiceApiRequest) SetProjectId(v int64) *PublishDataServiceApiRequest {
	s.ProjectId = &v
	return s
}

func (s *PublishDataServiceApiRequest) SetTenantId(v int64) *PublishDataServiceApiRequest {
	s.TenantId = &v
	return s
}

type PublishDataServiceApiResponseBody struct {
	// Indicates whether the API is published.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PublishDataServiceApiResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PublishDataServiceApiResponseBody) GoString() string {
	return s.String()
}

func (s *PublishDataServiceApiResponseBody) SetData(v bool) *PublishDataServiceApiResponseBody {
	s.Data = &v
	return s
}

func (s *PublishDataServiceApiResponseBody) SetErrorCode(v string) *PublishDataServiceApiResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *PublishDataServiceApiResponseBody) SetErrorMessage(v string) *PublishDataServiceApiResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *PublishDataServiceApiResponseBody) SetHttpStatusCode(v int32) *PublishDataServiceApiResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *PublishDataServiceApiResponseBody) SetRequestId(v string) *PublishDataServiceApiResponseBody {
	s.RequestId = &v
	return s
}

func (s *PublishDataServiceApiResponseBody) SetSuccess(v bool) *PublishDataServiceApiResponseBody {
	s.Success = &v
	return s
}

type PublishDataServiceApiResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *PublishDataServiceApiResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s PublishDataServiceApiResponse) String() string {
	return tea.Prettify(s)
}

func (s PublishDataServiceApiResponse) GoString() string {
	return s.String()
}

func (s *PublishDataServiceApiResponse) SetHeaders(v map[string]*string) *PublishDataServiceApiResponse {
	s.Headers = v
	return s
}

func (s *PublishDataServiceApiResponse) SetStatusCode(v int32) *PublishDataServiceApiResponse {
	s.StatusCode = &v
	return s
}

func (s *PublishDataServiceApiResponse) SetBody(v *PublishDataServiceApiResponseBody) *PublishDataServiceApiResponse {
	s.Body = v
	return s
}

type QueryDISyncTaskConfigProcessResultRequest struct {
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	AsyncProcessId *int64 `json:"AsyncProcessId,omitempty" xml:"AsyncProcessId,omitempty"`
	// The type of the object that you want to create or update in Data Integration in asynchronous mode. Valid values:
	//
	// *   DI_REALTIME: real-time synchronization node
	//
	// *   DI_SOLUTION: synchronization solution
	//
	//     DataWorks allows you to create or update real-time synchronization nodes and synchronization solutions in Data Integration only in asynchronous mode.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the asynchronous thread. You can call the [GenerateDISyncTaskConfigForCreating](~~383463~~) or [GenerateDISyncTaskConfigForUpdating](~~383464~~) operation to generate the ID.
	//
	// *   The GenerateDISyncTaskConfigForCreating operation is used to generate the ID of the asynchronous thread that is used to create a real-time synchronization node or a synchronization solution in Data Integration.
	// *   The GenerateDISyncTaskConfigForUpdating operation is used to generate the ID of the asynchronous thread that is used to update a real-time synchronization node or a synchronization solution in Data Integration.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s QueryDISyncTaskConfigProcessResultRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDISyncTaskConfigProcessResultRequest) GoString() string {
	return s.String()
}

func (s *QueryDISyncTaskConfigProcessResultRequest) SetAsyncProcessId(v int64) *QueryDISyncTaskConfigProcessResultRequest {
	s.AsyncProcessId = &v
	return s
}

func (s *QueryDISyncTaskConfigProcessResultRequest) SetProjectId(v int64) *QueryDISyncTaskConfigProcessResultRequest {
	s.ProjectId = &v
	return s
}

func (s *QueryDISyncTaskConfigProcessResultRequest) SetTaskType(v string) *QueryDISyncTaskConfigProcessResultRequest {
	s.TaskType = &v
	return s
}

type QueryDISyncTaskConfigProcessResultResponseBody struct {
	// Indicates whether the parameters are obtained. Valid values:
	//
	// *   success: indicates that the parameters are obtained.
	// *   fail: indicates that the parameters fail to be obtained. You can view the reason for the failure and troubleshoot the issue based on the reason.
	Data *QueryDISyncTaskConfigProcessResultResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The information returned for the parameters that are asynchronously generated and used to create or update a real-time synchronization node or a synchronization solution in Data Integration.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDISyncTaskConfigProcessResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDISyncTaskConfigProcessResultResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDISyncTaskConfigProcessResultResponseBody) SetData(v *QueryDISyncTaskConfigProcessResultResponseBodyData) *QueryDISyncTaskConfigProcessResultResponseBody {
	s.Data = v
	return s
}

func (s *QueryDISyncTaskConfigProcessResultResponseBody) SetRequestId(v string) *QueryDISyncTaskConfigProcessResultResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDISyncTaskConfigProcessResultResponseBody) SetSuccess(v bool) *QueryDISyncTaskConfigProcessResultResponseBody {
	s.Success = &v
	return s
}

type QueryDISyncTaskConfigProcessResultResponseBodyData struct {
	// The parameters that are obtained. The parameters are used as the request parameters of the [CreateDISyncTask](~~278725~~) or [UpdateDISyncTask](~~289109~~) operation to create or update a real-time synchronization node or a synchronization solution in Data Integration.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The reason why the parameters fail to be obtained. If the parameters are obtained, the value null is returned.
	Status      *string `json:"Status,omitempty" xml:"Status,omitempty"`
	TaskContent *string `json:"TaskContent,omitempty" xml:"TaskContent,omitempty"`
}

func (s QueryDISyncTaskConfigProcessResultResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDISyncTaskConfigProcessResultResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDISyncTaskConfigProcessResultResponseBodyData) SetMessage(v string) *QueryDISyncTaskConfigProcessResultResponseBodyData {
	s.Message = &v
	return s
}

func (s *QueryDISyncTaskConfigProcessResultResponseBodyData) SetStatus(v string) *QueryDISyncTaskConfigProcessResultResponseBodyData {
	s.Status = &v
	return s
}

func (s *QueryDISyncTaskConfigProcessResultResponseBodyData) SetTaskContent(v string) *QueryDISyncTaskConfigProcessResultResponseBodyData {
	s.TaskContent = &v
	return s
}

type QueryDISyncTaskConfigProcessResultResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *QueryDISyncTaskConfigProcessResultResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s QueryDISyncTaskConfigProcessResultResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDISyncTaskConfigProcessResultResponse) GoString() string {
	return s.String()
}

func (s *QueryDISyncTaskConfigProcessResultResponse) SetHeaders(v map[string]*string) *QueryDISyncTaskConfigProcessResultResponse {
	s.Headers = v
	return s
}

func (s *QueryDISyncTaskConfigProcessResultResponse) SetStatusCode(v int32) *QueryDISyncTaskConfigProcessResultResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDISyncTaskConfigProcessResultResponse) SetBody(v *QueryDISyncTaskConfigProcessResultResponseBody) *QueryDISyncTaskConfigProcessResultResponse {
	s.Body = v
	return s
}

type QueryDefaultTemplateRequest struct {
	TenantId *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s QueryDefaultTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDefaultTemplateRequest) GoString() string {
	return s.String()
}

func (s *QueryDefaultTemplateRequest) SetTenantId(v string) *QueryDefaultTemplateRequest {
	s.TenantId = &v
	return s
}

type QueryDefaultTemplateResponseBody struct {
	Data           interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string     `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32      `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDefaultTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDefaultTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDefaultTemplateResponseBody) SetData(v interface{}) *QueryDefaultTemplateResponseBody {
	s.Data = v
	return s
}

func (s *QueryDefaultTemplateResponseBody) SetErrorCode(v string) *QueryDefaultTemplateResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryDefaultTemplateResponseBody) SetErrorMessage(v string) *QueryDefaultTemplateResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDefaultTemplateResponseBody) SetHttpStatusCode(v int32) *QueryDefaultTemplateResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryDefaultTemplateResponseBody) SetRequestId(v string) *QueryDefaultTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDefaultTemplateResponseBody) SetSuccess(v bool) *QueryDefaultTemplateResponseBody {
	s.Success = &v
	return s
}

type QueryDefaultTemplateResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *QueryDefaultTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s QueryDefaultTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDefaultTemplateResponse) GoString() string {
	return s.String()
}

func (s *QueryDefaultTemplateResponse) SetHeaders(v map[string]*string) *QueryDefaultTemplateResponse {
	s.Headers = v
	return s
}

func (s *QueryDefaultTemplateResponse) SetStatusCode(v int32) *QueryDefaultTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDefaultTemplateResponse) SetBody(v *QueryDefaultTemplateResponseBody) *QueryDefaultTemplateResponse {
	s.Body = v
	return s
}

type QueryPublicModelEngineRequest struct {
	ProjectId *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	Text      *string `json:"Text,omitempty" xml:"Text,omitempty"`
}

func (s QueryPublicModelEngineRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryPublicModelEngineRequest) GoString() string {
	return s.String()
}

func (s *QueryPublicModelEngineRequest) SetProjectId(v string) *QueryPublicModelEngineRequest {
	s.ProjectId = &v
	return s
}

func (s *QueryPublicModelEngineRequest) SetText(v string) *QueryPublicModelEngineRequest {
	s.Text = &v
	return s
}

type QueryPublicModelEngineResponseBody struct {
	RequestId   *string                  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	ReturnValue []map[string]interface{} `json:"ReturnValue,omitempty" xml:"ReturnValue,omitempty" type:"Repeated"`
}

func (s QueryPublicModelEngineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryPublicModelEngineResponseBody) GoString() string {
	return s.String()
}

func (s *QueryPublicModelEngineResponseBody) SetRequestId(v string) *QueryPublicModelEngineResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryPublicModelEngineResponseBody) SetReturnValue(v []map[string]interface{}) *QueryPublicModelEngineResponseBody {
	s.ReturnValue = v
	return s
}

type QueryPublicModelEngineResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *QueryPublicModelEngineResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s QueryPublicModelEngineResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryPublicModelEngineResponse) GoString() string {
	return s.String()
}

func (s *QueryPublicModelEngineResponse) SetHeaders(v map[string]*string) *QueryPublicModelEngineResponse {
	s.Headers = v
	return s
}

func (s *QueryPublicModelEngineResponse) SetStatusCode(v int32) *QueryPublicModelEngineResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryPublicModelEngineResponse) SetBody(v *QueryPublicModelEngineResponseBody) *QueryPublicModelEngineResponse {
	s.Body = v
	return s
}

type QueryRecognizeDataByRuleTypeRequest struct {
	RecognizeRulesType *string `json:"RecognizeRulesType,omitempty" xml:"RecognizeRulesType,omitempty"`
	TenantId           *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s QueryRecognizeDataByRuleTypeRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryRecognizeDataByRuleTypeRequest) GoString() string {
	return s.String()
}

func (s *QueryRecognizeDataByRuleTypeRequest) SetRecognizeRulesType(v string) *QueryRecognizeDataByRuleTypeRequest {
	s.RecognizeRulesType = &v
	return s
}

func (s *QueryRecognizeDataByRuleTypeRequest) SetTenantId(v string) *QueryRecognizeDataByRuleTypeRequest {
	s.TenantId = &v
	return s
}

type QueryRecognizeDataByRuleTypeResponseBody struct {
	Data           interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string     `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32      `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryRecognizeDataByRuleTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryRecognizeDataByRuleTypeResponseBody) GoString() string {
	return s.String()
}

func (s *QueryRecognizeDataByRuleTypeResponseBody) SetData(v interface{}) *QueryRecognizeDataByRuleTypeResponseBody {
	s.Data = v
	return s
}

func (s *QueryRecognizeDataByRuleTypeResponseBody) SetErrorCode(v string) *QueryRecognizeDataByRuleTypeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryRecognizeDataByRuleTypeResponseBody) SetErrorMessage(v string) *QueryRecognizeDataByRuleTypeResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryRecognizeDataByRuleTypeResponseBody) SetHttpStatusCode(v int32) *QueryRecognizeDataByRuleTypeResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryRecognizeDataByRuleTypeResponseBody) SetRequestId(v string) *QueryRecognizeDataByRuleTypeResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryRecognizeDataByRuleTypeResponseBody) SetSuccess(v bool) *QueryRecognizeDataByRuleTypeResponseBody {
	s.Success = &v
	return s
}

type QueryRecognizeDataByRuleTypeResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *QueryRecognizeDataByRuleTypeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s QueryRecognizeDataByRuleTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryRecognizeDataByRuleTypeResponse) GoString() string {
	return s.String()
}

func (s *QueryRecognizeDataByRuleTypeResponse) SetHeaders(v map[string]*string) *QueryRecognizeDataByRuleTypeResponse {
	s.Headers = v
	return s
}

func (s *QueryRecognizeDataByRuleTypeResponse) SetStatusCode(v int32) *QueryRecognizeDataByRuleTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryRecognizeDataByRuleTypeResponse) SetBody(v *QueryRecognizeDataByRuleTypeResponseBody) *QueryRecognizeDataByRuleTypeResponse {
	s.Body = v
	return s
}

type QueryRecognizeRuleDetailRequest struct {
	SensitiveName *string `json:"SensitiveName,omitempty" xml:"SensitiveName,omitempty"`
	TenantId      *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s QueryRecognizeRuleDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryRecognizeRuleDetailRequest) GoString() string {
	return s.String()
}

func (s *QueryRecognizeRuleDetailRequest) SetSensitiveName(v string) *QueryRecognizeRuleDetailRequest {
	s.SensitiveName = &v
	return s
}

func (s *QueryRecognizeRuleDetailRequest) SetTenantId(v string) *QueryRecognizeRuleDetailRequest {
	s.TenantId = &v
	return s
}

type QueryRecognizeRuleDetailResponseBody struct {
	Data           interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string     `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32      `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryRecognizeRuleDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryRecognizeRuleDetailResponseBody) GoString() string {
	return s.String()
}

func (s *QueryRecognizeRuleDetailResponseBody) SetData(v interface{}) *QueryRecognizeRuleDetailResponseBody {
	s.Data = v
	return s
}

func (s *QueryRecognizeRuleDetailResponseBody) SetErrorCode(v string) *QueryRecognizeRuleDetailResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryRecognizeRuleDetailResponseBody) SetErrorMessage(v string) *QueryRecognizeRuleDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryRecognizeRuleDetailResponseBody) SetHttpStatusCode(v int32) *QueryRecognizeRuleDetailResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryRecognizeRuleDetailResponseBody) SetRequestId(v string) *QueryRecognizeRuleDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryRecognizeRuleDetailResponseBody) SetSuccess(v bool) *QueryRecognizeRuleDetailResponseBody {
	s.Success = &v
	return s
}

type QueryRecognizeRuleDetailResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *QueryRecognizeRuleDetailResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s QueryRecognizeRuleDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryRecognizeRuleDetailResponse) GoString() string {
	return s.String()
}

func (s *QueryRecognizeRuleDetailResponse) SetHeaders(v map[string]*string) *QueryRecognizeRuleDetailResponse {
	s.Headers = v
	return s
}

func (s *QueryRecognizeRuleDetailResponse) SetStatusCode(v int32) *QueryRecognizeRuleDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryRecognizeRuleDetailResponse) SetBody(v *QueryRecognizeRuleDetailResponseBody) *QueryRecognizeRuleDetailResponse {
	s.Body = v
	return s
}

type QueryRecognizeRulesTypeResponseBody struct {
	Data           interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string     `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32      `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryRecognizeRulesTypeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryRecognizeRulesTypeResponseBody) GoString() string {
	return s.String()
}

func (s *QueryRecognizeRulesTypeResponseBody) SetData(v interface{}) *QueryRecognizeRulesTypeResponseBody {
	s.Data = v
	return s
}

func (s *QueryRecognizeRulesTypeResponseBody) SetErrorCode(v string) *QueryRecognizeRulesTypeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QueryRecognizeRulesTypeResponseBody) SetErrorMessage(v string) *QueryRecognizeRulesTypeResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryRecognizeRulesTypeResponseBody) SetHttpStatusCode(v int32) *QueryRecognizeRulesTypeResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QueryRecognizeRulesTypeResponseBody) SetRequestId(v string) *QueryRecognizeRulesTypeResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryRecognizeRulesTypeResponseBody) SetSuccess(v bool) *QueryRecognizeRulesTypeResponseBody {
	s.Success = &v
	return s
}

type QueryRecognizeRulesTypeResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *QueryRecognizeRulesTypeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s QueryRecognizeRulesTypeResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryRecognizeRulesTypeResponse) GoString() string {
	return s.String()
}

func (s *QueryRecognizeRulesTypeResponse) SetHeaders(v map[string]*string) *QueryRecognizeRulesTypeResponse {
	s.Headers = v
	return s
}

func (s *QueryRecognizeRulesTypeResponse) SetStatusCode(v int32) *QueryRecognizeRulesTypeResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryRecognizeRulesTypeResponse) SetBody(v *QueryRecognizeRulesTypeResponseBody) *QueryRecognizeRulesTypeResponse {
	s.Body = v
	return s
}

type QuerySensClassificationRequest struct {
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	TenantId   *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s QuerySensClassificationRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySensClassificationRequest) GoString() string {
	return s.String()
}

func (s *QuerySensClassificationRequest) SetTemplateId(v string) *QuerySensClassificationRequest {
	s.TemplateId = &v
	return s
}

func (s *QuerySensClassificationRequest) SetTenantId(v string) *QuerySensClassificationRequest {
	s.TenantId = &v
	return s
}

type QuerySensClassificationResponseBody struct {
	Data           interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string     `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32      `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySensClassificationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySensClassificationResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySensClassificationResponseBody) SetData(v interface{}) *QuerySensClassificationResponseBody {
	s.Data = v
	return s
}

func (s *QuerySensClassificationResponseBody) SetErrorCode(v string) *QuerySensClassificationResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QuerySensClassificationResponseBody) SetErrorMessage(v string) *QuerySensClassificationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySensClassificationResponseBody) SetHttpStatusCode(v int32) *QuerySensClassificationResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QuerySensClassificationResponseBody) SetRequestId(v string) *QuerySensClassificationResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySensClassificationResponseBody) SetSuccess(v bool) *QuerySensClassificationResponseBody {
	s.Success = &v
	return s
}

type QuerySensClassificationResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *QuerySensClassificationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s QuerySensClassificationResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySensClassificationResponse) GoString() string {
	return s.String()
}

func (s *QuerySensClassificationResponse) SetHeaders(v map[string]*string) *QuerySensClassificationResponse {
	s.Headers = v
	return s
}

func (s *QuerySensClassificationResponse) SetStatusCode(v int32) *QuerySensClassificationResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySensClassificationResponse) SetBody(v *QuerySensClassificationResponseBody) *QuerySensClassificationResponse {
	s.Body = v
	return s
}

type QuerySensLevelRequest struct {
	TemplateId *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	TenantId   *string `json:"tenantId,omitempty" xml:"tenantId,omitempty"`
}

func (s QuerySensLevelRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySensLevelRequest) GoString() string {
	return s.String()
}

func (s *QuerySensLevelRequest) SetTemplateId(v string) *QuerySensLevelRequest {
	s.TemplateId = &v
	return s
}

func (s *QuerySensLevelRequest) SetTenantId(v string) *QuerySensLevelRequest {
	s.TenantId = &v
	return s
}

type QuerySensLevelResponseBody struct {
	Data           interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string     `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32      `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySensLevelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySensLevelResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySensLevelResponseBody) SetData(v interface{}) *QuerySensLevelResponseBody {
	s.Data = v
	return s
}

func (s *QuerySensLevelResponseBody) SetErrorCode(v string) *QuerySensLevelResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QuerySensLevelResponseBody) SetErrorMessage(v string) *QuerySensLevelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySensLevelResponseBody) SetHttpStatusCode(v int32) *QuerySensLevelResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QuerySensLevelResponseBody) SetRequestId(v string) *QuerySensLevelResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySensLevelResponseBody) SetSuccess(v bool) *QuerySensLevelResponseBody {
	s.Success = &v
	return s
}

type QuerySensLevelResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *QuerySensLevelResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s QuerySensLevelResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySensLevelResponse) GoString() string {
	return s.String()
}

func (s *QuerySensLevelResponse) SetHeaders(v map[string]*string) *QuerySensLevelResponse {
	s.Headers = v
	return s
}

func (s *QuerySensLevelResponse) SetStatusCode(v int32) *QuerySensLevelResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySensLevelResponse) SetBody(v *QuerySensLevelResponseBody) *QuerySensLevelResponse {
	s.Body = v
	return s
}

type QuerySensNodeInfoRequest struct {
	NodeId        *string `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	PageNo        *int32  `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SensitiveName *string `json:"SensitiveName,omitempty" xml:"SensitiveName,omitempty"`
	TemplateId    *string `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	TenantId      *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	Status        *int32  `json:"status,omitempty" xml:"status,omitempty"`
}

func (s QuerySensNodeInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySensNodeInfoRequest) GoString() string {
	return s.String()
}

func (s *QuerySensNodeInfoRequest) SetNodeId(v string) *QuerySensNodeInfoRequest {
	s.NodeId = &v
	return s
}

func (s *QuerySensNodeInfoRequest) SetPageNo(v int32) *QuerySensNodeInfoRequest {
	s.PageNo = &v
	return s
}

func (s *QuerySensNodeInfoRequest) SetPageSize(v int32) *QuerySensNodeInfoRequest {
	s.PageSize = &v
	return s
}

func (s *QuerySensNodeInfoRequest) SetSensitiveName(v string) *QuerySensNodeInfoRequest {
	s.SensitiveName = &v
	return s
}

func (s *QuerySensNodeInfoRequest) SetTemplateId(v string) *QuerySensNodeInfoRequest {
	s.TemplateId = &v
	return s
}

func (s *QuerySensNodeInfoRequest) SetTenantId(v string) *QuerySensNodeInfoRequest {
	s.TenantId = &v
	return s
}

func (s *QuerySensNodeInfoRequest) SetStatus(v int32) *QuerySensNodeInfoRequest {
	s.Status = &v
	return s
}

type QuerySensNodeInfoResponseBody struct {
	Data           interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string     `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32      `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySensNodeInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySensNodeInfoResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySensNodeInfoResponseBody) SetData(v interface{}) *QuerySensNodeInfoResponseBody {
	s.Data = v
	return s
}

func (s *QuerySensNodeInfoResponseBody) SetErrorCode(v string) *QuerySensNodeInfoResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *QuerySensNodeInfoResponseBody) SetErrorMessage(v string) *QuerySensNodeInfoResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySensNodeInfoResponseBody) SetHttpStatusCode(v int32) *QuerySensNodeInfoResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *QuerySensNodeInfoResponseBody) SetRequestId(v string) *QuerySensNodeInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySensNodeInfoResponseBody) SetSuccess(v bool) *QuerySensNodeInfoResponseBody {
	s.Success = &v
	return s
}

type QuerySensNodeInfoResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *QuerySensNodeInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s QuerySensNodeInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySensNodeInfoResponse) GoString() string {
	return s.String()
}

func (s *QuerySensNodeInfoResponse) SetHeaders(v map[string]*string) *QuerySensNodeInfoResponse {
	s.Headers = v
	return s
}

func (s *QuerySensNodeInfoResponse) SetStatusCode(v int32) *QuerySensNodeInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySensNodeInfoResponse) SetBody(v *QuerySensNodeInfoResponseBody) *QuerySensNodeInfoResponse {
	s.Body = v
	return s
}

type RegisterLineageRelationRequest struct {
	LineageRelationRegisterVO *LineageRelationRegisterVO `json:"LineageRelationRegisterVO,omitempty" xml:"LineageRelationRegisterVO,omitempty"`
}

func (s RegisterLineageRelationRequest) String() string {
	return tea.Prettify(s)
}

func (s RegisterLineageRelationRequest) GoString() string {
	return s.String()
}

func (s *RegisterLineageRelationRequest) SetLineageRelationRegisterVO(v *LineageRelationRegisterVO) *RegisterLineageRelationRequest {
	s.LineageRelationRegisterVO = v
	return s
}

type RegisterLineageRelationShrinkRequest struct {
	LineageRelationRegisterVOShrink *string `json:"LineageRelationRegisterVO,omitempty" xml:"LineageRelationRegisterVO,omitempty"`
}

func (s RegisterLineageRelationShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s RegisterLineageRelationShrinkRequest) GoString() string {
	return s.String()
}

func (s *RegisterLineageRelationShrinkRequest) SetLineageRelationRegisterVOShrink(v string) *RegisterLineageRelationShrinkRequest {
	s.LineageRelationRegisterVOShrink = &v
	return s
}

type RegisterLineageRelationResponseBody struct {
	ErrorCode       *string                                             `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage    *string                                             `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode  *int32                                              `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	LineageRelation *RegisterLineageRelationResponseBodyLineageRelation `json:"LineageRelation,omitempty" xml:"LineageRelation,omitempty" type:"Struct"`
	RequestId       *string                                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success         *bool                                               `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RegisterLineageRelationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RegisterLineageRelationResponseBody) GoString() string {
	return s.String()
}

func (s *RegisterLineageRelationResponseBody) SetErrorCode(v string) *RegisterLineageRelationResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RegisterLineageRelationResponseBody) SetErrorMessage(v string) *RegisterLineageRelationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RegisterLineageRelationResponseBody) SetHttpStatusCode(v int32) *RegisterLineageRelationResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *RegisterLineageRelationResponseBody) SetLineageRelation(v *RegisterLineageRelationResponseBodyLineageRelation) *RegisterLineageRelationResponseBody {
	s.LineageRelation = v
	return s
}

func (s *RegisterLineageRelationResponseBody) SetRequestId(v string) *RegisterLineageRelationResponseBody {
	s.RequestId = &v
	return s
}

func (s *RegisterLineageRelationResponseBody) SetSuccess(v bool) *RegisterLineageRelationResponseBody {
	s.Success = &v
	return s
}

type RegisterLineageRelationResponseBodyLineageRelation struct {
	DestEntityQualifiedName *string `json:"DestEntityQualifiedName,omitempty" xml:"DestEntityQualifiedName,omitempty"`
	RelationshipGuid        *string `json:"RelationshipGuid,omitempty" xml:"RelationshipGuid,omitempty"`
	SrcEntityQualifiedName  *string `json:"SrcEntityQualifiedName,omitempty" xml:"SrcEntityQualifiedName,omitempty"`
}

func (s RegisterLineageRelationResponseBodyLineageRelation) String() string {
	return tea.Prettify(s)
}

func (s RegisterLineageRelationResponseBodyLineageRelation) GoString() string {
	return s.String()
}

func (s *RegisterLineageRelationResponseBodyLineageRelation) SetDestEntityQualifiedName(v string) *RegisterLineageRelationResponseBodyLineageRelation {
	s.DestEntityQualifiedName = &v
	return s
}

func (s *RegisterLineageRelationResponseBodyLineageRelation) SetRelationshipGuid(v string) *RegisterLineageRelationResponseBodyLineageRelation {
	s.RelationshipGuid = &v
	return s
}

func (s *RegisterLineageRelationResponseBodyLineageRelation) SetSrcEntityQualifiedName(v string) *RegisterLineageRelationResponseBodyLineageRelation {
	s.SrcEntityQualifiedName = &v
	return s
}

type RegisterLineageRelationResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RegisterLineageRelationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RegisterLineageRelationResponse) String() string {
	return tea.Prettify(s)
}

func (s RegisterLineageRelationResponse) GoString() string {
	return s.String()
}

func (s *RegisterLineageRelationResponse) SetHeaders(v map[string]*string) *RegisterLineageRelationResponse {
	s.Headers = v
	return s
}

func (s *RegisterLineageRelationResponse) SetStatusCode(v int32) *RegisterLineageRelationResponse {
	s.StatusCode = &v
	return s
}

func (s *RegisterLineageRelationResponse) SetBody(v *RegisterLineageRelationResponseBody) *RegisterLineageRelationResponse {
	s.Body = v
	return s
}

type RemoveEntityTagsRequest struct {
	QualifiedName *string   `json:"QualifiedName,omitempty" xml:"QualifiedName,omitempty"`
	TagKeys       []*string `json:"TagKeys,omitempty" xml:"TagKeys,omitempty" type:"Repeated"`
}

func (s RemoveEntityTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveEntityTagsRequest) GoString() string {
	return s.String()
}

func (s *RemoveEntityTagsRequest) SetQualifiedName(v string) *RemoveEntityTagsRequest {
	s.QualifiedName = &v
	return s
}

func (s *RemoveEntityTagsRequest) SetTagKeys(v []*string) *RemoveEntityTagsRequest {
	s.TagKeys = v
	return s
}

type RemoveEntityTagsShrinkRequest struct {
	QualifiedName *string `json:"QualifiedName,omitempty" xml:"QualifiedName,omitempty"`
	TagKeysShrink *string `json:"TagKeys,omitempty" xml:"TagKeys,omitempty"`
}

func (s RemoveEntityTagsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveEntityTagsShrinkRequest) GoString() string {
	return s.String()
}

func (s *RemoveEntityTagsShrinkRequest) SetQualifiedName(v string) *RemoveEntityTagsShrinkRequest {
	s.QualifiedName = &v
	return s
}

func (s *RemoveEntityTagsShrinkRequest) SetTagKeysShrink(v string) *RemoveEntityTagsShrinkRequest {
	s.TagKeysShrink = &v
	return s
}

type RemoveEntityTagsResponseBody struct {
	Data           *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RemoveEntityTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveEntityTagsResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveEntityTagsResponseBody) SetData(v bool) *RemoveEntityTagsResponseBody {
	s.Data = &v
	return s
}

func (s *RemoveEntityTagsResponseBody) SetErrorCode(v string) *RemoveEntityTagsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RemoveEntityTagsResponseBody) SetErrorMessage(v string) *RemoveEntityTagsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RemoveEntityTagsResponseBody) SetHttpStatusCode(v int32) *RemoveEntityTagsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *RemoveEntityTagsResponseBody) SetRequestId(v string) *RemoveEntityTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *RemoveEntityTagsResponseBody) SetSuccess(v bool) *RemoveEntityTagsResponseBody {
	s.Success = &v
	return s
}

type RemoveEntityTagsResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RemoveEntityTagsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RemoveEntityTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveEntityTagsResponse) GoString() string {
	return s.String()
}

func (s *RemoveEntityTagsResponse) SetHeaders(v map[string]*string) *RemoveEntityTagsResponse {
	s.Headers = v
	return s
}

func (s *RemoveEntityTagsResponse) SetStatusCode(v int32) *RemoveEntityTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveEntityTagsResponse) SetBody(v *RemoveEntityTagsResponseBody) *RemoveEntityTagsResponse {
	s.Body = v
	return s
}

type RemoveProjectMemberFromRoleRequest struct {
	// The ID of the DataWorks workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The role in the DataWorks workspace. You can call the ListProjectRoles operation to query codes of the roles in the workspace.
	//
	// Valid values:
	//
	// *   role_project_owner: workspace owner
	// *   role_project_admin: workspace administrator
	// *   role_project_dev: developer
	// *   role_project_pe: O\&M engineer
	// *   role_project_deploy: deployment expert
	// *   role_project_guest: visitor
	// *   role_project_security: security administrator
	// *   role_project_tester: experiencer
	// *   role_project_erd: model designer
	RoleCode *string `json:"RoleCode,omitempty" xml:"RoleCode,omitempty"`
	// The ID of the user.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s RemoveProjectMemberFromRoleRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveProjectMemberFromRoleRequest) GoString() string {
	return s.String()
}

func (s *RemoveProjectMemberFromRoleRequest) SetProjectId(v int64) *RemoveProjectMemberFromRoleRequest {
	s.ProjectId = &v
	return s
}

func (s *RemoveProjectMemberFromRoleRequest) SetRoleCode(v string) *RemoveProjectMemberFromRoleRequest {
	s.RoleCode = &v
	return s
}

func (s *RemoveProjectMemberFromRoleRequest) SetUserId(v string) *RemoveProjectMemberFromRoleRequest {
	s.UserId = &v
	return s
}

type RemoveProjectMemberFromRoleResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RemoveProjectMemberFromRoleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveProjectMemberFromRoleResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveProjectMemberFromRoleResponseBody) SetRequestId(v string) *RemoveProjectMemberFromRoleResponseBody {
	s.RequestId = &v
	return s
}

type RemoveProjectMemberFromRoleResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RemoveProjectMemberFromRoleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RemoveProjectMemberFromRoleResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveProjectMemberFromRoleResponse) GoString() string {
	return s.String()
}

func (s *RemoveProjectMemberFromRoleResponse) SetHeaders(v map[string]*string) *RemoveProjectMemberFromRoleResponse {
	s.Headers = v
	return s
}

func (s *RemoveProjectMemberFromRoleResponse) SetStatusCode(v int32) *RemoveProjectMemberFromRoleResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveProjectMemberFromRoleResponse) SetBody(v *RemoveProjectMemberFromRoleResponseBody) *RemoveProjectMemberFromRoleResponse {
	s.Body = v
	return s
}

type RestartInstanceRequest struct {
	// The instance ID.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s RestartInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s RestartInstanceRequest) GoString() string {
	return s.String()
}

func (s *RestartInstanceRequest) SetInstanceId(v int64) *RestartInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *RestartInstanceRequest) SetProjectEnv(v string) *RestartInstanceRequest {
	s.ProjectEnv = &v
	return s
}

type RestartInstanceResponseBody struct {
	// The result returned.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request, You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RestartInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RestartInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *RestartInstanceResponseBody) SetData(v bool) *RestartInstanceResponseBody {
	s.Data = &v
	return s
}

func (s *RestartInstanceResponseBody) SetErrorCode(v string) *RestartInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RestartInstanceResponseBody) SetErrorMessage(v string) *RestartInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RestartInstanceResponseBody) SetHttpStatusCode(v int32) *RestartInstanceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *RestartInstanceResponseBody) SetRequestId(v string) *RestartInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *RestartInstanceResponseBody) SetSuccess(v bool) *RestartInstanceResponseBody {
	s.Success = &v
	return s
}

type RestartInstanceResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RestartInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RestartInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s RestartInstanceResponse) GoString() string {
	return s.String()
}

func (s *RestartInstanceResponse) SetHeaders(v map[string]*string) *RestartInstanceResponse {
	s.Headers = v
	return s
}

func (s *RestartInstanceResponse) SetStatusCode(v int32) *RestartInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *RestartInstanceResponse) SetBody(v *RestartInstanceResponseBody) *RestartInstanceResponse {
	s.Body = v
	return s
}

type ResumeInstanceRequest struct {
	// The instance ID.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s ResumeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s ResumeInstanceRequest) GoString() string {
	return s.String()
}

func (s *ResumeInstanceRequest) SetInstanceId(v int64) *ResumeInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *ResumeInstanceRequest) SetProjectEnv(v string) *ResumeInstanceRequest {
	s.ProjectEnv = &v
	return s
}

type ResumeInstanceResponseBody struct {
	// The result returned.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ResumeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResumeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *ResumeInstanceResponseBody) SetData(v bool) *ResumeInstanceResponseBody {
	s.Data = &v
	return s
}

func (s *ResumeInstanceResponseBody) SetErrorCode(v string) *ResumeInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *ResumeInstanceResponseBody) SetErrorMessage(v string) *ResumeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ResumeInstanceResponseBody) SetHttpStatusCode(v int32) *ResumeInstanceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *ResumeInstanceResponseBody) SetRequestId(v string) *ResumeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ResumeInstanceResponseBody) SetSuccess(v bool) *ResumeInstanceResponseBody {
	s.Success = &v
	return s
}

type ResumeInstanceResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ResumeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ResumeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s ResumeInstanceResponse) GoString() string {
	return s.String()
}

func (s *ResumeInstanceResponse) SetHeaders(v map[string]*string) *ResumeInstanceResponse {
	s.Headers = v
	return s
}

func (s *ResumeInstanceResponse) SetStatusCode(v int32) *ResumeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *ResumeInstanceResponse) SetBody(v *ResumeInstanceResponseBody) *ResumeInstanceResponse {
	s.Body = v
	return s
}

type RevokeColumnPermissionRequest struct {
	// The Alibaba Cloud account of the user from whom you want to revoke permissions. Specify this parameter in the format that is the same as the format of the account used to access the MaxCompute project.
	//
	// *   If you want to revoke permissions from an Alibaba Cloud account, specify this parameter in the ALIYUN$+Alibaba Cloud account format.
	// *   If you want to revoke permissions from a Resource Access Management (RAM) user, specify this parameter in the RAM$+RAM user format.
	//
	// You must specify either this parameter or RevokeUserId. If you specify both this parameter and RevokeUserId, the value of RevokeUserId prevails.
	Columns *string `json:"Columns,omitempty" xml:"Columns,omitempty"`
	// The name of the MaxCompute table to which the destination fields belong. You can call the [SearchMetaTables](~~173919~~) operation to query the name.
	MaxComputeProjectName *string `json:"MaxComputeProjectName,omitempty" xml:"MaxComputeProjectName,omitempty"`
	// Indicates whether the permissions on table fields are revoked.
	RevokeUserId *string `json:"RevokeUserId,omitempty" xml:"RevokeUserId,omitempty"`
	// The ID of the Alibaba Cloud account of the user from whom you want to revoke permissions. You can log on to the DataWorks console and go to the Security Settings page to obtain the ID.
	//
	// You must specify either this parameter or RevokeUserName. If you specify both this parameter and RevokeUserName, the value of this parameter prevails.
	RevokeUserName *string `json:"RevokeUserName,omitempty" xml:"RevokeUserName,omitempty"`
	// The fields for which you want to revoke permissions from a user. Separate multiple fields with commas (,).
	//
	// You can revoke the permissions on the fields only in MaxCompute tables.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The name of the MaxCompute project to which the destination fields belong. You can log on to the DataWorks console and go to the Workspace Management page to obtain the name of the MaxCompute project that is associated with the workspace.
	WorkspaceId *int64 `json:"WorkspaceId,omitempty" xml:"WorkspaceId,omitempty"`
}

func (s RevokeColumnPermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s RevokeColumnPermissionRequest) GoString() string {
	return s.String()
}

func (s *RevokeColumnPermissionRequest) SetColumns(v string) *RevokeColumnPermissionRequest {
	s.Columns = &v
	return s
}

func (s *RevokeColumnPermissionRequest) SetMaxComputeProjectName(v string) *RevokeColumnPermissionRequest {
	s.MaxComputeProjectName = &v
	return s
}

func (s *RevokeColumnPermissionRequest) SetRevokeUserId(v string) *RevokeColumnPermissionRequest {
	s.RevokeUserId = &v
	return s
}

func (s *RevokeColumnPermissionRequest) SetRevokeUserName(v string) *RevokeColumnPermissionRequest {
	s.RevokeUserName = &v
	return s
}

func (s *RevokeColumnPermissionRequest) SetTableName(v string) *RevokeColumnPermissionRequest {
	s.TableName = &v
	return s
}

func (s *RevokeColumnPermissionRequest) SetWorkspaceId(v int64) *RevokeColumnPermissionRequest {
	s.WorkspaceId = &v
	return s
}

type RevokeColumnPermissionResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request.
	RevokeSuccess *bool `json:"RevokeSuccess,omitempty" xml:"RevokeSuccess,omitempty"`
}

func (s RevokeColumnPermissionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RevokeColumnPermissionResponseBody) GoString() string {
	return s.String()
}

func (s *RevokeColumnPermissionResponseBody) SetRequestId(v string) *RevokeColumnPermissionResponseBody {
	s.RequestId = &v
	return s
}

func (s *RevokeColumnPermissionResponseBody) SetRevokeSuccess(v bool) *RevokeColumnPermissionResponseBody {
	s.RevokeSuccess = &v
	return s
}

type RevokeColumnPermissionResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RevokeColumnPermissionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RevokeColumnPermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s RevokeColumnPermissionResponse) GoString() string {
	return s.String()
}

func (s *RevokeColumnPermissionResponse) SetHeaders(v map[string]*string) *RevokeColumnPermissionResponse {
	s.Headers = v
	return s
}

func (s *RevokeColumnPermissionResponse) SetStatusCode(v int32) *RevokeColumnPermissionResponse {
	s.StatusCode = &v
	return s
}

func (s *RevokeColumnPermissionResponse) SetBody(v *RevokeColumnPermissionResponseBody) *RevokeColumnPermissionResponse {
	s.Body = v
	return s
}

type RevokeTablePermissionRequest struct {
	// The permissions that you want to revoke. Separate multiple permissions with commas (,).
	//
	// You can revoke only the SELECT, DESCRIBE, and DOWNLOAD permissions on MaxCompute tables.
	Actions *string `json:"Actions,omitempty" xml:"Actions,omitempty"`
	// The name of the MaxCompute project to which the table belongs. You can log on to the DataWorks console and go to the Workspace Management page to obtain the MaxCompute project name.
	MaxComputeProjectName *string `json:"MaxComputeProjectName,omitempty" xml:"MaxComputeProjectName,omitempty"`
	// The ID of the Alibaba Cloud account from which you want to revoke permissions. You can log on to the DataWorks console and go to the Security Settings page to obtain the ID.
	//
	// You must specify either this parameter or RevokeUserName. If you specify both this parameter and RevokeUserName, the value of this parameter prevails.
	RevokeUserId *string `json:"RevokeUserId,omitempty" xml:"RevokeUserId,omitempty"`
	// The Alibaba Cloud account from which you want to revoke permissions. Specify this parameter in the format that is the same as the format of the account used to access the MaxCompute project.
	//
	// *   If you want to revoke permissions from an Alibaba Cloud account, specify this parameter in the ALIYUN$+Alibaba Cloud account format.
	// *   If you want to revoke permissions from a Resource Access Management (RAM) user, specify this parameter in the RAM$+RAM user format.
	//
	// You must specify either this parameter or RevokeUserId. If you specify both this parameter and RevokeUserId, the value of RevokeUserId prevails.
	RevokeUserName *string `json:"RevokeUserName,omitempty" xml:"RevokeUserName,omitempty"`
	// The name of the MaxCompute table. You can call the [SearchMetaTables](~~173919~~) operation to query the table name.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The ID of the DataWorks workspace with which the MaxCompute project is associated. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID.
	WorkspaceId *int64 `json:"WorkspaceId,omitempty" xml:"WorkspaceId,omitempty"`
}

func (s RevokeTablePermissionRequest) String() string {
	return tea.Prettify(s)
}

func (s RevokeTablePermissionRequest) GoString() string {
	return s.String()
}

func (s *RevokeTablePermissionRequest) SetActions(v string) *RevokeTablePermissionRequest {
	s.Actions = &v
	return s
}

func (s *RevokeTablePermissionRequest) SetMaxComputeProjectName(v string) *RevokeTablePermissionRequest {
	s.MaxComputeProjectName = &v
	return s
}

func (s *RevokeTablePermissionRequest) SetRevokeUserId(v string) *RevokeTablePermissionRequest {
	s.RevokeUserId = &v
	return s
}

func (s *RevokeTablePermissionRequest) SetRevokeUserName(v string) *RevokeTablePermissionRequest {
	s.RevokeUserName = &v
	return s
}

func (s *RevokeTablePermissionRequest) SetTableName(v string) *RevokeTablePermissionRequest {
	s.TableName = &v
	return s
}

func (s *RevokeTablePermissionRequest) SetWorkspaceId(v int64) *RevokeTablePermissionRequest {
	s.WorkspaceId = &v
	return s
}

type RevokeTablePermissionResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the permissions on the table are revoked.
	RevokeSuccess *bool `json:"RevokeSuccess,omitempty" xml:"RevokeSuccess,omitempty"`
}

func (s RevokeTablePermissionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RevokeTablePermissionResponseBody) GoString() string {
	return s.String()
}

func (s *RevokeTablePermissionResponseBody) SetRequestId(v string) *RevokeTablePermissionResponseBody {
	s.RequestId = &v
	return s
}

func (s *RevokeTablePermissionResponseBody) SetRevokeSuccess(v bool) *RevokeTablePermissionResponseBody {
	s.RevokeSuccess = &v
	return s
}

type RevokeTablePermissionResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RevokeTablePermissionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RevokeTablePermissionResponse) String() string {
	return tea.Prettify(s)
}

func (s RevokeTablePermissionResponse) GoString() string {
	return s.String()
}

func (s *RevokeTablePermissionResponse) SetHeaders(v map[string]*string) *RevokeTablePermissionResponse {
	s.Headers = v
	return s
}

func (s *RevokeTablePermissionResponse) SetStatusCode(v int32) *RevokeTablePermissionResponse {
	s.StatusCode = &v
	return s
}

func (s *RevokeTablePermissionResponse) SetBody(v *RevokeTablePermissionResponseBody) *RevokeTablePermissionResponse {
	s.Body = v
	return s
}

type RunCycleDagNodesRequest struct {
	AlertNoticeType *string `json:"AlertNoticeType,omitempty" xml:"AlertNoticeType,omitempty"`
	AlertType       *string `json:"AlertType,omitempty" xml:"AlertType,omitempty"`
	// The time when the node started to run. This parameter is required only for auto triggered nodes that are scheduled by hour. Specify the value in the HH:mm:ss format. Valid values: 00:00:00 to 23:59:59.
	BizBeginTime *string `json:"BizBeginTime,omitempty" xml:"BizBeginTime,omitempty"`
	// The time when the node stopped running. This parameter is required only for auto triggered nodes that are scheduled by hour. Specify the value in the HH:mm:ss format. Valid values: 00:00:00 to 23:59:59.
	BizEndTime     *string `json:"BizEndTime,omitempty" xml:"BizEndTime,omitempty"`
	ConcurrentRuns *int32  `json:"ConcurrentRuns,omitempty" xml:"ConcurrentRuns,omitempty"`
	// The data timestamp at which data is no longer backfilled. Specify the value in the yyyy-MM-dd 00:00:00 format.
	EndBizDate *string `json:"EndBizDate,omitempty" xml:"EndBizDate,omitempty"`
	// The IDs of the nodes for which no data needs to be backfilled. The system generates dry-run instances for all these nodes. After these dry-run instances are scheduled, the statuses of these instances are directly set to successful, but the script is not run.
	ExcludeNodeIds *string `json:"ExcludeNodeIds,omitempty" xml:"ExcludeNodeIds,omitempty"`
	// The ID of the node for which you want to backfill data. If you want to backfill data for multiple nodes, separate the IDs of the nodes with commas (,). You can call the [ListNodes](~~173979~~) operation to query the ID.
	IncludeNodeIds *string `json:"IncludeNodeIds,omitempty" xml:"IncludeNodeIds,omitempty"`
	// The name of the workflow.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The parameters that need to be configured for the node. Set this parameter to a JSON string. The key indicates the ID of the node, and the value indicates the actual values of the parameters.
	NodeParams *string `json:"NodeParams,omitempty" xml:"NodeParams,omitempty"`
	// Specifies whether data can be backfilled for multiple nodes at the same time.
	Parallelism *bool `json:"Parallelism,omitempty" xml:"Parallelism,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV. The value PROD indicates the production environment, and the value DEV indicates the development environment.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
	// The ID of the node for which data is first backfilled. You can call the [ListNodes](~~173979~~) operation to query the ID.
	RootNodeId *int64 `json:"RootNodeId,omitempty" xml:"RootNodeId,omitempty"`
	// The data timestamp at which data starts to be backfilled. Specify the value in the yyyy-MM-dd 00:00:00 format.
	StartBizDate *string `json:"StartBizDate,omitempty" xml:"StartBizDate,omitempty"`
	// Specifies whether to immediately run an instance that is scheduled to run in the future. If you set this parameter to true, the instance that is scheduled to run in the future is run immediately. Otherwise, the instance is run as scheduled.
	StartFutureInstanceImmediately *bool `json:"StartFutureInstanceImmediately,omitempty" xml:"StartFutureInstanceImmediately,omitempty"`
}

func (s RunCycleDagNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s RunCycleDagNodesRequest) GoString() string {
	return s.String()
}

func (s *RunCycleDagNodesRequest) SetAlertNoticeType(v string) *RunCycleDagNodesRequest {
	s.AlertNoticeType = &v
	return s
}

func (s *RunCycleDagNodesRequest) SetAlertType(v string) *RunCycleDagNodesRequest {
	s.AlertType = &v
	return s
}

func (s *RunCycleDagNodesRequest) SetBizBeginTime(v string) *RunCycleDagNodesRequest {
	s.BizBeginTime = &v
	return s
}

func (s *RunCycleDagNodesRequest) SetBizEndTime(v string) *RunCycleDagNodesRequest {
	s.BizEndTime = &v
	return s
}

func (s *RunCycleDagNodesRequest) SetConcurrentRuns(v int32) *RunCycleDagNodesRequest {
	s.ConcurrentRuns = &v
	return s
}

func (s *RunCycleDagNodesRequest) SetEndBizDate(v string) *RunCycleDagNodesRequest {
	s.EndBizDate = &v
	return s
}

func (s *RunCycleDagNodesRequest) SetExcludeNodeIds(v string) *RunCycleDagNodesRequest {
	s.ExcludeNodeIds = &v
	return s
}

func (s *RunCycleDagNodesRequest) SetIncludeNodeIds(v string) *RunCycleDagNodesRequest {
	s.IncludeNodeIds = &v
	return s
}

func (s *RunCycleDagNodesRequest) SetName(v string) *RunCycleDagNodesRequest {
	s.Name = &v
	return s
}

func (s *RunCycleDagNodesRequest) SetNodeParams(v string) *RunCycleDagNodesRequest {
	s.NodeParams = &v
	return s
}

func (s *RunCycleDagNodesRequest) SetParallelism(v bool) *RunCycleDagNodesRequest {
	s.Parallelism = &v
	return s
}

func (s *RunCycleDagNodesRequest) SetProjectEnv(v string) *RunCycleDagNodesRequest {
	s.ProjectEnv = &v
	return s
}

func (s *RunCycleDagNodesRequest) SetRootNodeId(v int64) *RunCycleDagNodesRequest {
	s.RootNodeId = &v
	return s
}

func (s *RunCycleDagNodesRequest) SetStartBizDate(v string) *RunCycleDagNodesRequest {
	s.StartBizDate = &v
	return s
}

func (s *RunCycleDagNodesRequest) SetStartFutureInstanceImmediately(v bool) *RunCycleDagNodesRequest {
	s.StartFutureInstanceImmediately = &v
	return s
}

type RunCycleDagNodesResponseBody struct {
	// The IDs of the nodes in the workflow.
	Data []*int64 `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RunCycleDagNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RunCycleDagNodesResponseBody) GoString() string {
	return s.String()
}

func (s *RunCycleDagNodesResponseBody) SetData(v []*int64) *RunCycleDagNodesResponseBody {
	s.Data = v
	return s
}

func (s *RunCycleDagNodesResponseBody) SetErrorCode(v string) *RunCycleDagNodesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RunCycleDagNodesResponseBody) SetErrorMessage(v string) *RunCycleDagNodesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RunCycleDagNodesResponseBody) SetHttpStatusCode(v int32) *RunCycleDagNodesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *RunCycleDagNodesResponseBody) SetRequestId(v string) *RunCycleDagNodesResponseBody {
	s.RequestId = &v
	return s
}

func (s *RunCycleDagNodesResponseBody) SetSuccess(v bool) *RunCycleDagNodesResponseBody {
	s.Success = &v
	return s
}

type RunCycleDagNodesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RunCycleDagNodesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RunCycleDagNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s RunCycleDagNodesResponse) GoString() string {
	return s.String()
}

func (s *RunCycleDagNodesResponse) SetHeaders(v map[string]*string) *RunCycleDagNodesResponse {
	s.Headers = v
	return s
}

func (s *RunCycleDagNodesResponse) SetStatusCode(v int32) *RunCycleDagNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *RunCycleDagNodesResponse) SetBody(v *RunCycleDagNodesResponseBody) *RunCycleDagNodesResponse {
	s.Body = v
	return s
}

type RunManualDagNodesRequest struct {
	// The parameters transmitted between nodes in the manually triggered workflow. The parameters are in the following JSON format: { "\<ID of a node in the manually triggered workflow>": "Scheduling parameter settings of the node, which are in the same format as the Parameters parameter on the Properties tab of the DataStudio page", "\<ID of a node in the manually triggered workflow>": "Scheduling parameter settings of the node, which are in the same format as the Parameters parameter on the Properties tab of the DataStudio page" }.
	BizDate *string `json:"BizDate,omitempty" xml:"BizDate,omitempty"`
	// The IDs of the nodes that you need to run in the manually triggered workflow. Separate multiple node IDs with commas (,). You can call the ListNodes operation to query the node IDs.
	DagParameters *string `json:"DagParameters,omitempty" xml:"DagParameters,omitempty"`
	EndBizDate    *string `json:"EndBizDate,omitempty" xml:"EndBizDate,omitempty"`
	// The ID of the workspace to which the manually triggered workflow belongs.
	ExcludeNodeIds *string `json:"ExcludeNodeIds,omitempty" xml:"ExcludeNodeIds,omitempty"`
	// The data timestamp. The value must be one or more days before the current date. For example, if the current date is November 11, 2020, set the value to 2020-11-10 00:00:00 or earlier. Specify this parameter in the YYYY-MM-DD 00:00:00 format.
	FlowName *string `json:"FlowName,omitempty" xml:"FlowName,omitempty"`
	// The IDs of the nodes that you do not need to run in the manually triggered workflow. The system generates dry-run instances for all these nodes. After the dry-run instances are scheduled, the states of these instances are directly set to successful, but the scripts are not run. Separate multiple node IDs with commas (,).
	IncludeNodeIds *string `json:"IncludeNodeIds,omitempty" xml:"IncludeNodeIds,omitempty"`
	// The parameters of the manually triggered workflow, which are synchronized to all the instances in the directed acyclic graph (DAG) of the workflow. If a workflow parameter specified in DagParameters is referenced as a scheduling parameter of a node, the value of the scheduling parameter is replaced with the value of the workflow parameter.
	NodeParameters *string `json:"NodeParameters,omitempty" xml:"NodeParameters,omitempty"`
	// The name of the workspace to which the manually triggered workflow belongs.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
	// The ID of the DAG for the manually triggered workflow. You can call an operation with this parameter as a request parameter to query the details and statuses of the nodes in this manually triggered workflow.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the manually triggered workflow.
	ProjectName  *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	StartBizDate *string `json:"StartBizDate,omitempty" xml:"StartBizDate,omitempty"`
}

func (s RunManualDagNodesRequest) String() string {
	return tea.Prettify(s)
}

func (s RunManualDagNodesRequest) GoString() string {
	return s.String()
}

func (s *RunManualDagNodesRequest) SetBizDate(v string) *RunManualDagNodesRequest {
	s.BizDate = &v
	return s
}

func (s *RunManualDagNodesRequest) SetDagParameters(v string) *RunManualDagNodesRequest {
	s.DagParameters = &v
	return s
}

func (s *RunManualDagNodesRequest) SetEndBizDate(v string) *RunManualDagNodesRequest {
	s.EndBizDate = &v
	return s
}

func (s *RunManualDagNodesRequest) SetExcludeNodeIds(v string) *RunManualDagNodesRequest {
	s.ExcludeNodeIds = &v
	return s
}

func (s *RunManualDagNodesRequest) SetFlowName(v string) *RunManualDagNodesRequest {
	s.FlowName = &v
	return s
}

func (s *RunManualDagNodesRequest) SetIncludeNodeIds(v string) *RunManualDagNodesRequest {
	s.IncludeNodeIds = &v
	return s
}

func (s *RunManualDagNodesRequest) SetNodeParameters(v string) *RunManualDagNodesRequest {
	s.NodeParameters = &v
	return s
}

func (s *RunManualDagNodesRequest) SetProjectEnv(v string) *RunManualDagNodesRequest {
	s.ProjectEnv = &v
	return s
}

func (s *RunManualDagNodesRequest) SetProjectId(v int64) *RunManualDagNodesRequest {
	s.ProjectId = &v
	return s
}

func (s *RunManualDagNodesRequest) SetProjectName(v string) *RunManualDagNodesRequest {
	s.ProjectName = &v
	return s
}

func (s *RunManualDagNodesRequest) SetStartBizDate(v string) *RunManualDagNodesRequest {
	s.StartBizDate = &v
	return s
}

type RunManualDagNodesResponseBody struct {
	// The ID of the request.
	DagId     *int64  `json:"DagId,omitempty" xml:"DagId,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s RunManualDagNodesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RunManualDagNodesResponseBody) GoString() string {
	return s.String()
}

func (s *RunManualDagNodesResponseBody) SetDagId(v int64) *RunManualDagNodesResponseBody {
	s.DagId = &v
	return s
}

func (s *RunManualDagNodesResponseBody) SetRequestId(v string) *RunManualDagNodesResponseBody {
	s.RequestId = &v
	return s
}

type RunManualDagNodesResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RunManualDagNodesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RunManualDagNodesResponse) String() string {
	return tea.Prettify(s)
}

func (s RunManualDagNodesResponse) GoString() string {
	return s.String()
}

func (s *RunManualDagNodesResponse) SetHeaders(v map[string]*string) *RunManualDagNodesResponse {
	s.Headers = v
	return s
}

func (s *RunManualDagNodesResponse) SetStatusCode(v int32) *RunManualDagNodesResponse {
	s.StatusCode = &v
	return s
}

func (s *RunManualDagNodesResponse) SetBody(v *RunManualDagNodesResponseBody) *RunManualDagNodesResponse {
	s.Body = v
	return s
}

type RunSmokeTestRequest struct {
	// The data timestamp.
	Bizdate *string `json:"Bizdate,omitempty" xml:"Bizdate,omitempty"`
	// The name of the workflow.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the node. You can call the [ListNodes](~~173979~~) operation to query the ID.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The parameters related to the node. Set this parameter to a JSON string. A key in the string indicates a parameter, and a value in the string indicates the value of the related parameter.
	NodeParams *string `json:"NodeParams,omitempty" xml:"NodeParams,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV. The value PROD indicates the production environment, and the value DEV indicates the development environment.
	//
	// A workspace in basic mode does not have a development environment. For more information, see [Basic mode and standard mode](~~85772~~).
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s RunSmokeTestRequest) String() string {
	return tea.Prettify(s)
}

func (s RunSmokeTestRequest) GoString() string {
	return s.String()
}

func (s *RunSmokeTestRequest) SetBizdate(v string) *RunSmokeTestRequest {
	s.Bizdate = &v
	return s
}

func (s *RunSmokeTestRequest) SetName(v string) *RunSmokeTestRequest {
	s.Name = &v
	return s
}

func (s *RunSmokeTestRequest) SetNodeId(v int64) *RunSmokeTestRequest {
	s.NodeId = &v
	return s
}

func (s *RunSmokeTestRequest) SetNodeParams(v string) *RunSmokeTestRequest {
	s.NodeParams = &v
	return s
}

func (s *RunSmokeTestRequest) SetProjectEnv(v string) *RunSmokeTestRequest {
	s.ProjectEnv = &v
	return s
}

type RunSmokeTestResponseBody struct {
	// The ID of the workflow.
	Data *int64 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RunSmokeTestResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RunSmokeTestResponseBody) GoString() string {
	return s.String()
}

func (s *RunSmokeTestResponseBody) SetData(v int64) *RunSmokeTestResponseBody {
	s.Data = &v
	return s
}

func (s *RunSmokeTestResponseBody) SetErrorCode(v string) *RunSmokeTestResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *RunSmokeTestResponseBody) SetErrorMessage(v string) *RunSmokeTestResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RunSmokeTestResponseBody) SetHttpStatusCode(v int32) *RunSmokeTestResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *RunSmokeTestResponseBody) SetRequestId(v string) *RunSmokeTestResponseBody {
	s.RequestId = &v
	return s
}

func (s *RunSmokeTestResponseBody) SetSuccess(v bool) *RunSmokeTestResponseBody {
	s.Success = &v
	return s
}

type RunSmokeTestResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RunSmokeTestResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RunSmokeTestResponse) String() string {
	return tea.Prettify(s)
}

func (s RunSmokeTestResponse) GoString() string {
	return s.String()
}

func (s *RunSmokeTestResponse) SetHeaders(v map[string]*string) *RunSmokeTestResponse {
	s.Headers = v
	return s
}

func (s *RunSmokeTestResponse) SetStatusCode(v int32) *RunSmokeTestResponse {
	s.StatusCode = &v
	return s
}

func (s *RunSmokeTestResponse) SetBody(v *RunSmokeTestResponseBody) *RunSmokeTestResponse {
	s.Body = v
	return s
}

type RunTriggerNodeRequest struct {
	// The ID of the DataWorks workspace to which the manually triggered node belongs. You can call the [ListProjects](~~178393~~) operation to query the ID.
	AppId *int64 `json:"AppId,omitempty" xml:"AppId,omitempty"`
	// The data timestamp of the manually triggered node instance.
	BizDate *int64 `json:"BizDate,omitempty" xml:"BizDate,omitempty"`
	// The scheduled time to run the manually triggered node. Set the value to a 13-digit timestamp in milliseconds.
	CycleTime *int64 `json:"CycleTime,omitempty" xml:"CycleTime,omitempty"`
	// The ID of the manually triggered node. You can call the [ListNodes](~~173979~~) operation to query the ID.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
}

func (s RunTriggerNodeRequest) String() string {
	return tea.Prettify(s)
}

func (s RunTriggerNodeRequest) GoString() string {
	return s.String()
}

func (s *RunTriggerNodeRequest) SetAppId(v int64) *RunTriggerNodeRequest {
	s.AppId = &v
	return s
}

func (s *RunTriggerNodeRequest) SetBizDate(v int64) *RunTriggerNodeRequest {
	s.BizDate = &v
	return s
}

func (s *RunTriggerNodeRequest) SetCycleTime(v int64) *RunTriggerNodeRequest {
	s.CycleTime = &v
	return s
}

func (s *RunTriggerNodeRequest) SetNodeId(v int64) *RunTriggerNodeRequest {
	s.NodeId = &v
	return s
}

type RunTriggerNodeResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RunTriggerNodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RunTriggerNodeResponseBody) GoString() string {
	return s.String()
}

func (s *RunTriggerNodeResponseBody) SetRequestId(v string) *RunTriggerNodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *RunTriggerNodeResponseBody) SetSuccess(v bool) *RunTriggerNodeResponseBody {
	s.Success = &v
	return s
}

type RunTriggerNodeResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *RunTriggerNodeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s RunTriggerNodeResponse) String() string {
	return tea.Prettify(s)
}

func (s RunTriggerNodeResponse) GoString() string {
	return s.String()
}

func (s *RunTriggerNodeResponse) SetHeaders(v map[string]*string) *RunTriggerNodeResponse {
	s.Headers = v
	return s
}

func (s *RunTriggerNodeResponse) SetStatusCode(v int32) *RunTriggerNodeResponse {
	s.StatusCode = &v
	return s
}

func (s *RunTriggerNodeResponse) SetBody(v *RunTriggerNodeResponseBody) *RunTriggerNodeResponse {
	s.Body = v
	return s
}

type SaveDataServiceApiTestResultRequest struct {
	ApiId            *int64  `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	AutoGenerate     *bool   `json:"AutoGenerate,omitempty" xml:"AutoGenerate,omitempty"`
	FailResultSample *string `json:"FailResultSample,omitempty" xml:"FailResultSample,omitempty"`
	ProjectId        *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	ResultSample     *string `json:"ResultSample,omitempty" xml:"ResultSample,omitempty"`
}

func (s SaveDataServiceApiTestResultRequest) String() string {
	return tea.Prettify(s)
}

func (s SaveDataServiceApiTestResultRequest) GoString() string {
	return s.String()
}

func (s *SaveDataServiceApiTestResultRequest) SetApiId(v int64) *SaveDataServiceApiTestResultRequest {
	s.ApiId = &v
	return s
}

func (s *SaveDataServiceApiTestResultRequest) SetAutoGenerate(v bool) *SaveDataServiceApiTestResultRequest {
	s.AutoGenerate = &v
	return s
}

func (s *SaveDataServiceApiTestResultRequest) SetFailResultSample(v string) *SaveDataServiceApiTestResultRequest {
	s.FailResultSample = &v
	return s
}

func (s *SaveDataServiceApiTestResultRequest) SetProjectId(v int64) *SaveDataServiceApiTestResultRequest {
	s.ProjectId = &v
	return s
}

func (s *SaveDataServiceApiTestResultRequest) SetResultSample(v string) *SaveDataServiceApiTestResultRequest {
	s.ResultSample = &v
	return s
}

type SaveDataServiceApiTestResultResponseBody struct {
	Data           *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SaveDataServiceApiTestResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SaveDataServiceApiTestResultResponseBody) GoString() string {
	return s.String()
}

func (s *SaveDataServiceApiTestResultResponseBody) SetData(v bool) *SaveDataServiceApiTestResultResponseBody {
	s.Data = &v
	return s
}

func (s *SaveDataServiceApiTestResultResponseBody) SetHttpStatusCode(v int32) *SaveDataServiceApiTestResultResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *SaveDataServiceApiTestResultResponseBody) SetRequestId(v string) *SaveDataServiceApiTestResultResponseBody {
	s.RequestId = &v
	return s
}

func (s *SaveDataServiceApiTestResultResponseBody) SetSuccess(v bool) *SaveDataServiceApiTestResultResponseBody {
	s.Success = &v
	return s
}

type SaveDataServiceApiTestResultResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SaveDataServiceApiTestResultResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SaveDataServiceApiTestResultResponse) String() string {
	return tea.Prettify(s)
}

func (s SaveDataServiceApiTestResultResponse) GoString() string {
	return s.String()
}

func (s *SaveDataServiceApiTestResultResponse) SetHeaders(v map[string]*string) *SaveDataServiceApiTestResultResponse {
	s.Headers = v
	return s
}

func (s *SaveDataServiceApiTestResultResponse) SetStatusCode(v int32) *SaveDataServiceApiTestResultResponse {
	s.StatusCode = &v
	return s
}

func (s *SaveDataServiceApiTestResultResponse) SetBody(v *SaveDataServiceApiTestResultResponseBody) *SaveDataServiceApiTestResultResponse {
	s.Body = v
	return s
}

type ScanSensitiveDataRequest struct {
	// The data that you want to check.
	Data *string `json:"Data,omitempty" xml:"Data,omitempty"`
}

func (s ScanSensitiveDataRequest) String() string {
	return tea.Prettify(s)
}

func (s ScanSensitiveDataRequest) GoString() string {
	return s.String()
}

func (s *ScanSensitiveDataRequest) SetData(v string) *ScanSensitiveDataRequest {
	s.Data = &v
	return s
}

type ScanSensitiveDataResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The result of the check.
	//
	// sensDatas indicates the rules that are used to check the sensitive data. sensDatas includes the following parameters:
	//
	// *   hitCount: the number of times that the sensitive data hits the rule
	// *   ruleName: the name of the rule
	Sensitives map[string]interface{} `json:"Sensitives,omitempty" xml:"Sensitives,omitempty"`
}

func (s ScanSensitiveDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ScanSensitiveDataResponseBody) GoString() string {
	return s.String()
}

func (s *ScanSensitiveDataResponseBody) SetRequestId(v string) *ScanSensitiveDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *ScanSensitiveDataResponseBody) SetSensitives(v map[string]interface{}) *ScanSensitiveDataResponseBody {
	s.Sensitives = v
	return s
}

type ScanSensitiveDataResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *ScanSensitiveDataResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s ScanSensitiveDataResponse) String() string {
	return tea.Prettify(s)
}

func (s ScanSensitiveDataResponse) GoString() string {
	return s.String()
}

func (s *ScanSensitiveDataResponse) SetHeaders(v map[string]*string) *ScanSensitiveDataResponse {
	s.Headers = v
	return s
}

func (s *ScanSensitiveDataResponse) SetStatusCode(v int32) *ScanSensitiveDataResponse {
	s.StatusCode = &v
	return s
}

func (s *ScanSensitiveDataResponse) SetBody(v *ScanSensitiveDataResponseBody) *ScanSensitiveDataResponse {
	s.Body = v
	return s
}

type SearchMetaTablesRequest struct {
	// The type of the metatables. Valid values: 0 and 1. The value 0 indicates that tables are queried. The value 1 indicates that views are queried. If you do not configure this parameter, all types of metatables are queried.
	AppGuid *string `json:"AppGuid,omitempty" xml:"AppGuid,omitempty"`
	// The schema information of the table. You need to configure this parameter if you enable the table schema in MaxCompute.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The HTTP status code returned.
	DataSourceType *string `json:"DataSourceType,omitempty" xml:"DataSourceType,omitempty"`
	// The type of the data source. Valid values: odps and emr.
	EntityType *int32 `json:"EntityType,omitempty" xml:"EntityType,omitempty"`
	// The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
	//
	// You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID of the EMR cluster.
	Keyword *string `json:"Keyword,omitempty" xml:"Keyword,omitempty"`
	// The GUID of the workspace where the metatables reside.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The keyword based on which metatables are queried. During the query, the system tokenizes the names of metatables and matches the names with the keyword. If no name is matched, an empty result is returned. By default, the system uses underscores (\_) to tokenize the names.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The error message returned.
	Schema *string `json:"Schema,omitempty" xml:"Schema,omitempty"`
}

func (s SearchMetaTablesRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchMetaTablesRequest) GoString() string {
	return s.String()
}

func (s *SearchMetaTablesRequest) SetAppGuid(v string) *SearchMetaTablesRequest {
	s.AppGuid = &v
	return s
}

func (s *SearchMetaTablesRequest) SetClusterId(v string) *SearchMetaTablesRequest {
	s.ClusterId = &v
	return s
}

func (s *SearchMetaTablesRequest) SetDataSourceType(v string) *SearchMetaTablesRequest {
	s.DataSourceType = &v
	return s
}

func (s *SearchMetaTablesRequest) SetEntityType(v int32) *SearchMetaTablesRequest {
	s.EntityType = &v
	return s
}

func (s *SearchMetaTablesRequest) SetKeyword(v string) *SearchMetaTablesRequest {
	s.Keyword = &v
	return s
}

func (s *SearchMetaTablesRequest) SetPageNumber(v int32) *SearchMetaTablesRequest {
	s.PageNumber = &v
	return s
}

func (s *SearchMetaTablesRequest) SetPageSize(v int32) *SearchMetaTablesRequest {
	s.PageSize = &v
	return s
}

func (s *SearchMetaTablesRequest) SetSchema(v string) *SearchMetaTablesRequest {
	s.Schema = &v
	return s
}

type SearchMetaTablesResponseBody struct {
	// The number of entries returned per page.
	Data *SearchMetaTablesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The page number of the returned page.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request is successful.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error code returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The business data returned.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SearchMetaTablesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchMetaTablesResponseBody) GoString() string {
	return s.String()
}

func (s *SearchMetaTablesResponseBody) SetData(v *SearchMetaTablesResponseBodyData) *SearchMetaTablesResponseBody {
	s.Data = v
	return s
}

func (s *SearchMetaTablesResponseBody) SetErrorCode(v string) *SearchMetaTablesResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SearchMetaTablesResponseBody) SetErrorMessage(v string) *SearchMetaTablesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SearchMetaTablesResponseBody) SetHttpStatusCode(v int32) *SearchMetaTablesResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *SearchMetaTablesResponseBody) SetRequestId(v string) *SearchMetaTablesResponseBody {
	s.RequestId = &v
	return s
}

func (s *SearchMetaTablesResponseBody) SetSuccess(v bool) *SearchMetaTablesResponseBody {
	s.Success = &v
	return s
}

type SearchMetaTablesResponseBodyData struct {
	// The name of the metadatabase.
	DataEntityList []*SearchMetaTablesResponseBodyDataDataEntityList `json:"DataEntityList,omitempty" xml:"DataEntityList,omitempty" type:"Repeated"`
	// The total number of metatables.
	PageNumber *int32 `json:"PageNumber,omitempty" xml:"PageNumber,omitempty"`
	// The list of metatables.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The name of the metatable.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s SearchMetaTablesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s SearchMetaTablesResponseBodyData) GoString() string {
	return s.String()
}

func (s *SearchMetaTablesResponseBodyData) SetDataEntityList(v []*SearchMetaTablesResponseBodyDataDataEntityList) *SearchMetaTablesResponseBodyData {
	s.DataEntityList = v
	return s
}

func (s *SearchMetaTablesResponseBodyData) SetPageNumber(v int32) *SearchMetaTablesResponseBodyData {
	s.PageNumber = &v
	return s
}

func (s *SearchMetaTablesResponseBodyData) SetPageSize(v int32) *SearchMetaTablesResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *SearchMetaTablesResponseBodyData) SetTotalCount(v int64) *SearchMetaTablesResponseBodyData {
	s.TotalCount = &v
	return s
}

type SearchMetaTablesResponseBodyDataDataEntityList struct {
	// The ID of the tenant.
	ClusterId *string `json:"ClusterId,omitempty" xml:"ClusterId,omitempty"`
	// The name of the workspace.
	DatabaseName *string `json:"DatabaseName,omitempty" xml:"DatabaseName,omitempty"`
	// The ID of the workspace.
	EntityType *int32 `json:"EntityType,omitempty" xml:"EntityType,omitempty"`
	// The schema information of the table. This parameter is returned only if you enable the table schema in MaxCompute.
	EnvType *int32 `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The type of the environment. Valid values:
	//
	// *   1: production environment
	// *   0: development environment
	OwnerId *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The ID of the Alibaba Cloud account used by the workspace owner.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The GUID of the metatable.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	Schema      *string `json:"Schema,omitempty" xml:"Schema,omitempty"`
	// The ID of the EMR cluster.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The type of the metatable. Valid values:
	//
	// *   0: table
	// *   1: view
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	TenantId  *int64  `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s SearchMetaTablesResponseBodyDataDataEntityList) String() string {
	return tea.Prettify(s)
}

func (s SearchMetaTablesResponseBodyDataDataEntityList) GoString() string {
	return s.String()
}

func (s *SearchMetaTablesResponseBodyDataDataEntityList) SetClusterId(v string) *SearchMetaTablesResponseBodyDataDataEntityList {
	s.ClusterId = &v
	return s
}

func (s *SearchMetaTablesResponseBodyDataDataEntityList) SetDatabaseName(v string) *SearchMetaTablesResponseBodyDataDataEntityList {
	s.DatabaseName = &v
	return s
}

func (s *SearchMetaTablesResponseBodyDataDataEntityList) SetEntityType(v int32) *SearchMetaTablesResponseBodyDataDataEntityList {
	s.EntityType = &v
	return s
}

func (s *SearchMetaTablesResponseBodyDataDataEntityList) SetEnvType(v int32) *SearchMetaTablesResponseBodyDataDataEntityList {
	s.EnvType = &v
	return s
}

func (s *SearchMetaTablesResponseBodyDataDataEntityList) SetOwnerId(v string) *SearchMetaTablesResponseBodyDataDataEntityList {
	s.OwnerId = &v
	return s
}

func (s *SearchMetaTablesResponseBodyDataDataEntityList) SetProjectId(v int64) *SearchMetaTablesResponseBodyDataDataEntityList {
	s.ProjectId = &v
	return s
}

func (s *SearchMetaTablesResponseBodyDataDataEntityList) SetProjectName(v string) *SearchMetaTablesResponseBodyDataDataEntityList {
	s.ProjectName = &v
	return s
}

func (s *SearchMetaTablesResponseBodyDataDataEntityList) SetSchema(v string) *SearchMetaTablesResponseBodyDataDataEntityList {
	s.Schema = &v
	return s
}

func (s *SearchMetaTablesResponseBodyDataDataEntityList) SetTableGuid(v string) *SearchMetaTablesResponseBodyDataDataEntityList {
	s.TableGuid = &v
	return s
}

func (s *SearchMetaTablesResponseBodyDataDataEntityList) SetTableName(v string) *SearchMetaTablesResponseBodyDataDataEntityList {
	s.TableName = &v
	return s
}

func (s *SearchMetaTablesResponseBodyDataDataEntityList) SetTenantId(v int64) *SearchMetaTablesResponseBodyDataDataEntityList {
	s.TenantId = &v
	return s
}

type SearchMetaTablesResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SearchMetaTablesResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SearchMetaTablesResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchMetaTablesResponse) GoString() string {
	return s.String()
}

func (s *SearchMetaTablesResponse) SetHeaders(v map[string]*string) *SearchMetaTablesResponse {
	s.Headers = v
	return s
}

func (s *SearchMetaTablesResponse) SetStatusCode(v int32) *SearchMetaTablesResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchMetaTablesResponse) SetBody(v *SearchMetaTablesResponseBody) *SearchMetaTablesResponse {
	s.Body = v
	return s
}

type SearchNodesByOutputRequest struct {
	Outputs    *string `json:"Outputs,omitempty" xml:"Outputs,omitempty"`
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s SearchNodesByOutputRequest) String() string {
	return tea.Prettify(s)
}

func (s SearchNodesByOutputRequest) GoString() string {
	return s.String()
}

func (s *SearchNodesByOutputRequest) SetOutputs(v string) *SearchNodesByOutputRequest {
	s.Outputs = &v
	return s
}

func (s *SearchNodesByOutputRequest) SetProjectEnv(v string) *SearchNodesByOutputRequest {
	s.ProjectEnv = &v
	return s
}

type SearchNodesByOutputResponseBody struct {
	Data           map[string]interface{} `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string                `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string                `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32                 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                  `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SearchNodesByOutputResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SearchNodesByOutputResponseBody) GoString() string {
	return s.String()
}

func (s *SearchNodesByOutputResponseBody) SetData(v map[string]interface{}) *SearchNodesByOutputResponseBody {
	s.Data = v
	return s
}

func (s *SearchNodesByOutputResponseBody) SetErrorCode(v string) *SearchNodesByOutputResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SearchNodesByOutputResponseBody) SetErrorMessage(v string) *SearchNodesByOutputResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SearchNodesByOutputResponseBody) SetHttpStatusCode(v int32) *SearchNodesByOutputResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *SearchNodesByOutputResponseBody) SetRequestId(v string) *SearchNodesByOutputResponseBody {
	s.RequestId = &v
	return s
}

func (s *SearchNodesByOutputResponseBody) SetSuccess(v bool) *SearchNodesByOutputResponseBody {
	s.Success = &v
	return s
}

type SearchNodesByOutputResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SearchNodesByOutputResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SearchNodesByOutputResponse) String() string {
	return tea.Prettify(s)
}

func (s SearchNodesByOutputResponse) GoString() string {
	return s.String()
}

func (s *SearchNodesByOutputResponse) SetHeaders(v map[string]*string) *SearchNodesByOutputResponse {
	s.Headers = v
	return s
}

func (s *SearchNodesByOutputResponse) SetStatusCode(v int32) *SearchNodesByOutputResponse {
	s.StatusCode = &v
	return s
}

func (s *SearchNodesByOutputResponse) SetBody(v *SearchNodesByOutputResponseBody) *SearchNodesByOutputResponse {
	s.Body = v
	return s
}

type SetDataSourceShareRequest struct {
	// The name of the data source to be shared.
	DatasourceName *string `json:"DatasourceName,omitempty" xml:"DatasourceName,omitempty"`
	// The environment to which the data source belongs. Valid values:
	//
	// *   0: development environment
	// *   1: production environment
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The ID of the DataWorks workspace to which the data source belongs. You can call the [ListProjects](~~178393~~) operation to query the ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The DataWorks workspace to which the data source is to be shared. If you set this parameter, all members of the specified DataWorks workspace can view and use the data source. The value must be a JSON array. Example: {"projectId":1000,"permission":"WRITE","sharedName":"PX_DATAHUB1.shared_name"}.
	//
	// Field description:
	//
	// *   projectId: the ID of the DataWorks workspace to which the data source is to be shared.
	// *   permission: the mode in which the data source is shared. Valid values: READ and WRITE. The value READ indicates that all members of the specified workspace can read data from the data source, but cannot modify the data. The value WRITE indicates that all members of the specified workspace can modify the data in the data source.
	// *   sharedName: the name of the data source to be shared.
	ProjectPermissions *string `json:"ProjectPermissions,omitempty" xml:"ProjectPermissions,omitempty"`
	// The user to whom the data source is to be shared. If you set this parameter, the specified user can view or use the data source. The value must be a JSON array. Example: {"projectId":10000,"users":\[{"userId":"276184575345452131","permission":"WRITE"},"sharedName":"PX_DATAHUB1.shared_name"}].
	//
	// Field description:
	//
	// *   projectId: the ID of the DataWorks workspace. If you set the UserPermissions parameter, the specified user can view or use the data source only in this specified DataWorks workspace.
	// *   userId: the ID of the user to whom the data source is to be shared.
	// *   permission: the mode in which the data source is shared. Valid values: READ and WRITE. The value READ indicates that the specified user can read data from the data source, but cannot modify the data. The value WRITE indicates that the specified user can modify the data in the data source.
	// *   sharedName: the name of the data source to be shared.
	//
	// If the ProjectPermissions and UserPermissions parameters are both left empty, the specified data source is not shared to any DataWorks workspace or user. If neither of the parameters is left empty, both parameters take effect.
	UserPermissions *string `json:"UserPermissions,omitempty" xml:"UserPermissions,omitempty"`
}

func (s SetDataSourceShareRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDataSourceShareRequest) GoString() string {
	return s.String()
}

func (s *SetDataSourceShareRequest) SetDatasourceName(v string) *SetDataSourceShareRequest {
	s.DatasourceName = &v
	return s
}

func (s *SetDataSourceShareRequest) SetEnvType(v string) *SetDataSourceShareRequest {
	s.EnvType = &v
	return s
}

func (s *SetDataSourceShareRequest) SetProjectId(v int64) *SetDataSourceShareRequest {
	s.ProjectId = &v
	return s
}

func (s *SetDataSourceShareRequest) SetProjectPermissions(v string) *SetDataSourceShareRequest {
	s.ProjectPermissions = &v
	return s
}

func (s *SetDataSourceShareRequest) SetUserPermissions(v string) *SetDataSourceShareRequest {
	s.UserPermissions = &v
	return s
}

type SetDataSourceShareResponseBody struct {
	// The information about the sharing operation.
	Data *SetDataSourceShareResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SetDataSourceShareResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDataSourceShareResponseBody) GoString() string {
	return s.String()
}

func (s *SetDataSourceShareResponseBody) SetData(v *SetDataSourceShareResponseBodyData) *SetDataSourceShareResponseBody {
	s.Data = v
	return s
}

func (s *SetDataSourceShareResponseBody) SetRequestId(v string) *SetDataSourceShareResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetDataSourceShareResponseBody) SetSuccess(v bool) *SetDataSourceShareResponseBody {
	s.Success = &v
	return s
}

type SetDataSourceShareResponseBodyData struct {
	// The reason why the data source failed to be shared. If the data source was shared, this parameter is left empty.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Indicates whether the data source was shared. Valid values:
	//
	// *   success: The data source was shared.
	// *   fail: The data source failed to be shared. You can troubleshoot issues based on the Message parameter.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s SetDataSourceShareResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s SetDataSourceShareResponseBodyData) GoString() string {
	return s.String()
}

func (s *SetDataSourceShareResponseBodyData) SetMessage(v string) *SetDataSourceShareResponseBodyData {
	s.Message = &v
	return s
}

func (s *SetDataSourceShareResponseBodyData) SetStatus(v string) *SetDataSourceShareResponseBodyData {
	s.Status = &v
	return s
}

type SetDataSourceShareResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SetDataSourceShareResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SetDataSourceShareResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDataSourceShareResponse) GoString() string {
	return s.String()
}

func (s *SetDataSourceShareResponse) SetHeaders(v map[string]*string) *SetDataSourceShareResponse {
	s.Headers = v
	return s
}

func (s *SetDataSourceShareResponse) SetStatusCode(v int32) *SetDataSourceShareResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDataSourceShareResponse) SetBody(v *SetDataSourceShareResponseBody) *SetDataSourceShareResponse {
	s.Body = v
	return s
}

type SetEntityTagsRequest struct {
	QualifiedName *string          `json:"QualifiedName,omitempty" xml:"QualifiedName,omitempty"`
	Tags          []*UserEntityTag `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s SetEntityTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s SetEntityTagsRequest) GoString() string {
	return s.String()
}

func (s *SetEntityTagsRequest) SetQualifiedName(v string) *SetEntityTagsRequest {
	s.QualifiedName = &v
	return s
}

func (s *SetEntityTagsRequest) SetTags(v []*UserEntityTag) *SetEntityTagsRequest {
	s.Tags = v
	return s
}

type SetEntityTagsShrinkRequest struct {
	QualifiedName *string `json:"QualifiedName,omitempty" xml:"QualifiedName,omitempty"`
	TagsShrink    *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s SetEntityTagsShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s SetEntityTagsShrinkRequest) GoString() string {
	return s.String()
}

func (s *SetEntityTagsShrinkRequest) SetQualifiedName(v string) *SetEntityTagsShrinkRequest {
	s.QualifiedName = &v
	return s
}

func (s *SetEntityTagsShrinkRequest) SetTagsShrink(v string) *SetEntityTagsShrinkRequest {
	s.TagsShrink = &v
	return s
}

type SetEntityTagsResponseBody struct {
	Data           *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SetEntityTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetEntityTagsResponseBody) GoString() string {
	return s.String()
}

func (s *SetEntityTagsResponseBody) SetData(v bool) *SetEntityTagsResponseBody {
	s.Data = &v
	return s
}

func (s *SetEntityTagsResponseBody) SetErrorCode(v string) *SetEntityTagsResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SetEntityTagsResponseBody) SetErrorMessage(v string) *SetEntityTagsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SetEntityTagsResponseBody) SetHttpStatusCode(v int32) *SetEntityTagsResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *SetEntityTagsResponseBody) SetRequestId(v string) *SetEntityTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetEntityTagsResponseBody) SetSuccess(v bool) *SetEntityTagsResponseBody {
	s.Success = &v
	return s
}

type SetEntityTagsResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SetEntityTagsResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SetEntityTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s SetEntityTagsResponse) GoString() string {
	return s.String()
}

func (s *SetEntityTagsResponse) SetHeaders(v map[string]*string) *SetEntityTagsResponse {
	s.Headers = v
	return s
}

func (s *SetEntityTagsResponse) SetStatusCode(v int32) *SetEntityTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *SetEntityTagsResponse) SetBody(v *SetEntityTagsResponseBody) *SetEntityTagsResponse {
	s.Body = v
	return s
}

type SetSuccessInstanceRequest struct {
	// The environment of the workspace. Valid values: PROD and DEV.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The HTTP status code.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s SetSuccessInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s SetSuccessInstanceRequest) GoString() string {
	return s.String()
}

func (s *SetSuccessInstanceRequest) SetInstanceId(v int64) *SetSuccessInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *SetSuccessInstanceRequest) SetProjectEnv(v string) *SetSuccessInstanceRequest {
	s.ProjectEnv = &v
	return s
}

type SetSuccessInstanceResponseBody struct {
	// The error message.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// Indicates whether the request is successful.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The ID of the request.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// Indicates whether result details are returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error code.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SetSuccessInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetSuccessInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *SetSuccessInstanceResponseBody) SetData(v bool) *SetSuccessInstanceResponseBody {
	s.Data = &v
	return s
}

func (s *SetSuccessInstanceResponseBody) SetErrorCode(v string) *SetSuccessInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SetSuccessInstanceResponseBody) SetErrorMessage(v string) *SetSuccessInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SetSuccessInstanceResponseBody) SetHttpStatusCode(v int32) *SetSuccessInstanceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *SetSuccessInstanceResponseBody) SetRequestId(v string) *SetSuccessInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetSuccessInstanceResponseBody) SetSuccess(v bool) *SetSuccessInstanceResponseBody {
	s.Success = &v
	return s
}

type SetSuccessInstanceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SetSuccessInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SetSuccessInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s SetSuccessInstanceResponse) GoString() string {
	return s.String()
}

func (s *SetSuccessInstanceResponse) SetHeaders(v map[string]*string) *SetSuccessInstanceResponse {
	s.Headers = v
	return s
}

func (s *SetSuccessInstanceResponse) SetStatusCode(v int32) *SetSuccessInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *SetSuccessInstanceResponse) SetBody(v *SetSuccessInstanceResponseBody) *SetSuccessInstanceResponse {
	s.Body = v
	return s
}

type StartDIJobRequest struct {
	DIJobId               *int64                                  `json:"DIJobId,omitempty" xml:"DIJobId,omitempty"`
	ForceToRerun          *bool                                   `json:"ForceToRerun,omitempty" xml:"ForceToRerun,omitempty"`
	RealtimeStartSettings *StartDIJobRequestRealtimeStartSettings `json:"RealtimeStartSettings,omitempty" xml:"RealtimeStartSettings,omitempty" type:"Struct"`
}

func (s StartDIJobRequest) String() string {
	return tea.Prettify(s)
}

func (s StartDIJobRequest) GoString() string {
	return s.String()
}

func (s *StartDIJobRequest) SetDIJobId(v int64) *StartDIJobRequest {
	s.DIJobId = &v
	return s
}

func (s *StartDIJobRequest) SetForceToRerun(v bool) *StartDIJobRequest {
	s.ForceToRerun = &v
	return s
}

func (s *StartDIJobRequest) SetRealtimeStartSettings(v *StartDIJobRequestRealtimeStartSettings) *StartDIJobRequest {
	s.RealtimeStartSettings = v
	return s
}

type StartDIJobRequestRealtimeStartSettings struct {
	FailoverSettings *StartDIJobRequestRealtimeStartSettingsFailoverSettings `json:"FailoverSettings,omitempty" xml:"FailoverSettings,omitempty" type:"Struct"`
	StartTime        *int64                                                  `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s StartDIJobRequestRealtimeStartSettings) String() string {
	return tea.Prettify(s)
}

func (s StartDIJobRequestRealtimeStartSettings) GoString() string {
	return s.String()
}

func (s *StartDIJobRequestRealtimeStartSettings) SetFailoverSettings(v *StartDIJobRequestRealtimeStartSettingsFailoverSettings) *StartDIJobRequestRealtimeStartSettings {
	s.FailoverSettings = v
	return s
}

func (s *StartDIJobRequestRealtimeStartSettings) SetStartTime(v int64) *StartDIJobRequestRealtimeStartSettings {
	s.StartTime = &v
	return s
}

type StartDIJobRequestRealtimeStartSettingsFailoverSettings struct {
	Interval   *int64 `json:"Interval,omitempty" xml:"Interval,omitempty"`
	UpperLimit *int64 `json:"UpperLimit,omitempty" xml:"UpperLimit,omitempty"`
}

func (s StartDIJobRequestRealtimeStartSettingsFailoverSettings) String() string {
	return tea.Prettify(s)
}

func (s StartDIJobRequestRealtimeStartSettingsFailoverSettings) GoString() string {
	return s.String()
}

func (s *StartDIJobRequestRealtimeStartSettingsFailoverSettings) SetInterval(v int64) *StartDIJobRequestRealtimeStartSettingsFailoverSettings {
	s.Interval = &v
	return s
}

func (s *StartDIJobRequestRealtimeStartSettingsFailoverSettings) SetUpperLimit(v int64) *StartDIJobRequestRealtimeStartSettingsFailoverSettings {
	s.UpperLimit = &v
	return s
}

type StartDIJobShrinkRequest struct {
	DIJobId                     *int64  `json:"DIJobId,omitempty" xml:"DIJobId,omitempty"`
	ForceToRerun                *bool   `json:"ForceToRerun,omitempty" xml:"ForceToRerun,omitempty"`
	RealtimeStartSettingsShrink *string `json:"RealtimeStartSettings,omitempty" xml:"RealtimeStartSettings,omitempty"`
}

func (s StartDIJobShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s StartDIJobShrinkRequest) GoString() string {
	return s.String()
}

func (s *StartDIJobShrinkRequest) SetDIJobId(v int64) *StartDIJobShrinkRequest {
	s.DIJobId = &v
	return s
}

func (s *StartDIJobShrinkRequest) SetForceToRerun(v bool) *StartDIJobShrinkRequest {
	s.ForceToRerun = &v
	return s
}

func (s *StartDIJobShrinkRequest) SetRealtimeStartSettingsShrink(v string) *StartDIJobShrinkRequest {
	s.RealtimeStartSettingsShrink = &v
	return s
}

type StartDIJobResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StartDIJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartDIJobResponseBody) GoString() string {
	return s.String()
}

func (s *StartDIJobResponseBody) SetRequestId(v string) *StartDIJobResponseBody {
	s.RequestId = &v
	return s
}

type StartDIJobResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StartDIJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StartDIJobResponse) String() string {
	return tea.Prettify(s)
}

func (s StartDIJobResponse) GoString() string {
	return s.String()
}

func (s *StartDIJobResponse) SetHeaders(v map[string]*string) *StartDIJobResponse {
	s.Headers = v
	return s
}

func (s *StartDIJobResponse) SetStatusCode(v int32) *StartDIJobResponse {
	s.StatusCode = &v
	return s
}

func (s *StartDIJobResponse) SetBody(v *StartDIJobResponseBody) *StartDIJobResponse {
	s.Body = v
	return s
}

type StartDISyncInstanceRequest struct {
	// *   If you set the TaskType parameter to DI_REALTIME, the StartParam parameter specifies the startup parameters for the real-time synchronization node. The startup parameters include failover-related parameters, the parameter that specifies the number of dirty data records allowed, and the parameters in the data definition language (DDL) statements.
	// *   If you set the TaskType parameter to DI_SOLUTION, the StartParam parameter does not take effect.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The type of the Data Integration object that you want to start. Valid values:
	//
	// *   DI_REALTIME: real-time synchronization node
	// *   DI_SOLUTION: data synchronization solution
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request succeeded.
	// *   false: The request failed.
	StartParam *string `json:"StartParam,omitempty" xml:"StartParam,omitempty"`
	// *   If you set the TaskType parameter to DI_REALTIME, set the FileId parameter to the ID of the real-time synchronization node that you want to start.
	// *   If you set the TaskType parameter to DI_SOLUTION, set the FileId parameter to the ID of the data synchronization solution that you want to start.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s StartDISyncInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s StartDISyncInstanceRequest) GoString() string {
	return s.String()
}

func (s *StartDISyncInstanceRequest) SetFileId(v int64) *StartDISyncInstanceRequest {
	s.FileId = &v
	return s
}

func (s *StartDISyncInstanceRequest) SetProjectId(v int64) *StartDISyncInstanceRequest {
	s.ProjectId = &v
	return s
}

func (s *StartDISyncInstanceRequest) SetStartParam(v string) *StartDISyncInstanceRequest {
	s.StartParam = &v
	return s
}

func (s *StartDISyncInstanceRequest) SetTaskType(v string) *StartDISyncInstanceRequest {
	s.TaskType = &v
	return s
}

type StartDISyncInstanceResponseBody struct {
	// Indicates whether the real-time synchronization node or the data synchronization solution is started. Valid values:
	//
	// *   success: The real-time synchronization node or the data synchronization solution is started.
	// *   fail: The real-time synchronization node or the data synchronization solution fails to be started. You can troubleshoot the issue based on the provided cause.
	Data *StartDISyncInstanceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The result returned for the start.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s StartDISyncInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartDISyncInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *StartDISyncInstanceResponseBody) SetData(v *StartDISyncInstanceResponseBodyData) *StartDISyncInstanceResponseBody {
	s.Data = v
	return s
}

func (s *StartDISyncInstanceResponseBody) SetRequestId(v string) *StartDISyncInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *StartDISyncInstanceResponseBody) SetSuccess(v bool) *StartDISyncInstanceResponseBody {
	s.Success = &v
	return s
}

type StartDISyncInstanceResponseBodyData struct {
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The reason why the real-time synchronization node or the data synchronization solution fails to be started.
	//
	// If the real-time synchronization node or the data synchronization solution is started, the value null is returned.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s StartDISyncInstanceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s StartDISyncInstanceResponseBodyData) GoString() string {
	return s.String()
}

func (s *StartDISyncInstanceResponseBodyData) SetMessage(v string) *StartDISyncInstanceResponseBodyData {
	s.Message = &v
	return s
}

func (s *StartDISyncInstanceResponseBodyData) SetStatus(v string) *StartDISyncInstanceResponseBodyData {
	s.Status = &v
	return s
}

type StartDISyncInstanceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StartDISyncInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StartDISyncInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s StartDISyncInstanceResponse) GoString() string {
	return s.String()
}

func (s *StartDISyncInstanceResponse) SetHeaders(v map[string]*string) *StartDISyncInstanceResponse {
	s.Headers = v
	return s
}

func (s *StartDISyncInstanceResponse) SetStatusCode(v int32) *StartDISyncInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *StartDISyncInstanceResponse) SetBody(v *StartDISyncInstanceResponseBody) *StartDISyncInstanceResponse {
	s.Body = v
	return s
}

type StartMigrationRequest struct {
	// The ID of the migration package. You can call the [CreateImportMigration](~~206094~~) operation to obtain the ID of the import package and call the [CreateExportMigration](~~349325~~) operation to obtain the ID of the export package.
	MigrationId *int64 `json:"MigrationId,omitempty" xml:"MigrationId,omitempty"`
	// The ID of the workspace. You can go to the Workspace Management page of the DataWorks console to view the ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s StartMigrationRequest) String() string {
	return tea.Prettify(s)
}

func (s StartMigrationRequest) GoString() string {
	return s.String()
}

func (s *StartMigrationRequest) SetMigrationId(v int64) *StartMigrationRequest {
	s.MigrationId = &v
	return s
}

func (s *StartMigrationRequest) SetProjectId(v int64) *StartMigrationRequest {
	s.ProjectId = &v
	return s
}

type StartMigrationResponseBody struct {
	// Indicates whether the migration task is started. Valid values:
	//
	// *   true: The migration task is started.
	// *   false: The migration task fails to be started.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s StartMigrationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartMigrationResponseBody) GoString() string {
	return s.String()
}

func (s *StartMigrationResponseBody) SetData(v bool) *StartMigrationResponseBody {
	s.Data = &v
	return s
}

func (s *StartMigrationResponseBody) SetErrorCode(v string) *StartMigrationResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *StartMigrationResponseBody) SetErrorMessage(v string) *StartMigrationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *StartMigrationResponseBody) SetHttpStatusCode(v int32) *StartMigrationResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *StartMigrationResponseBody) SetRequestId(v string) *StartMigrationResponseBody {
	s.RequestId = &v
	return s
}

func (s *StartMigrationResponseBody) SetSuccess(v bool) *StartMigrationResponseBody {
	s.Success = &v
	return s
}

type StartMigrationResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StartMigrationResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StartMigrationResponse) String() string {
	return tea.Prettify(s)
}

func (s StartMigrationResponse) GoString() string {
	return s.String()
}

func (s *StartMigrationResponse) SetHeaders(v map[string]*string) *StartMigrationResponse {
	s.Headers = v
	return s
}

func (s *StartMigrationResponse) SetStatusCode(v int32) *StartMigrationResponse {
	s.StatusCode = &v
	return s
}

func (s *StartMigrationResponse) SetBody(v *StartMigrationResponseBody) *StartMigrationResponse {
	s.Body = v
	return s
}

type StopDIJobRequest struct {
	DIJobId *int64 `json:"DIJobId,omitempty" xml:"DIJobId,omitempty"`
}

func (s StopDIJobRequest) String() string {
	return tea.Prettify(s)
}

func (s StopDIJobRequest) GoString() string {
	return s.String()
}

func (s *StopDIJobRequest) SetDIJobId(v int64) *StopDIJobRequest {
	s.DIJobId = &v
	return s
}

type StopDIJobResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s StopDIJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopDIJobResponseBody) GoString() string {
	return s.String()
}

func (s *StopDIJobResponseBody) SetRequestId(v string) *StopDIJobResponseBody {
	s.RequestId = &v
	return s
}

type StopDIJobResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StopDIJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StopDIJobResponse) String() string {
	return tea.Prettify(s)
}

func (s StopDIJobResponse) GoString() string {
	return s.String()
}

func (s *StopDIJobResponse) SetHeaders(v map[string]*string) *StopDIJobResponse {
	s.Headers = v
	return s
}

func (s *StopDIJobResponse) SetStatusCode(v int32) *StopDIJobResponse {
	s.StatusCode = &v
	return s
}

func (s *StopDIJobResponse) SetBody(v *StopDIJobResponseBody) *StopDIJobResponse {
	s.Body = v
	return s
}

type StopDISyncInstanceRequest struct {
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The type of the synchronization node that you want to stop. Set the value to DI_REALTIME.
	//
	// DI_REALTIME indicates a real-time synchronization node.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the synchronization node. You can call the [ListFiles](~~173942~~) operation to obtain the ID.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s StopDISyncInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s StopDISyncInstanceRequest) GoString() string {
	return s.String()
}

func (s *StopDISyncInstanceRequest) SetFileId(v int64) *StopDISyncInstanceRequest {
	s.FileId = &v
	return s
}

func (s *StopDISyncInstanceRequest) SetProjectId(v int64) *StopDISyncInstanceRequest {
	s.ProjectId = &v
	return s
}

func (s *StopDISyncInstanceRequest) SetTaskType(v string) *StopDISyncInstanceRequest {
	s.TaskType = &v
	return s
}

type StopDISyncInstanceResponseBody struct {
	// Indicates whether the synchronization node is stopped. Valid values:
	//
	// *   success: The synchronization node is stopped.
	// *   fail: The synchronization node fails to be stopped.
	Data *StopDISyncInstanceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The information returned for the synchronization node.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s StopDISyncInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopDISyncInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *StopDISyncInstanceResponseBody) SetData(v *StopDISyncInstanceResponseBodyData) *StopDISyncInstanceResponseBody {
	s.Data = v
	return s
}

func (s *StopDISyncInstanceResponseBody) SetRequestId(v string) *StopDISyncInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *StopDISyncInstanceResponseBody) SetSuccess(v bool) *StopDISyncInstanceResponseBody {
	s.Success = &v
	return s
}

type StopDISyncInstanceResponseBodyData struct {
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The reason why the synchronization node fails to be stopped.
	//
	// If the synchronization node is stopped, the value null is returned.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s StopDISyncInstanceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s StopDISyncInstanceResponseBodyData) GoString() string {
	return s.String()
}

func (s *StopDISyncInstanceResponseBodyData) SetMessage(v string) *StopDISyncInstanceResponseBodyData {
	s.Message = &v
	return s
}

func (s *StopDISyncInstanceResponseBodyData) SetStatus(v string) *StopDISyncInstanceResponseBodyData {
	s.Status = &v
	return s
}

type StopDISyncInstanceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StopDISyncInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StopDISyncInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s StopDISyncInstanceResponse) GoString() string {
	return s.String()
}

func (s *StopDISyncInstanceResponse) SetHeaders(v map[string]*string) *StopDISyncInstanceResponse {
	s.Headers = v
	return s
}

func (s *StopDISyncInstanceResponse) SetStatusCode(v int32) *StopDISyncInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *StopDISyncInstanceResponse) SetBody(v *StopDISyncInstanceResponseBody) *StopDISyncInstanceResponse {
	s.Body = v
	return s
}

type StopInstanceRequest struct {
	// The ID of the instance. You can call the [ListInstances](~~173982~~) operation to query the ID.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s StopInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s StopInstanceRequest) GoString() string {
	return s.String()
}

func (s *StopInstanceRequest) SetInstanceId(v int64) *StopInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *StopInstanceRequest) SetProjectEnv(v string) *StopInstanceRequest {
	s.ProjectEnv = &v
	return s
}

type StopInstanceResponseBody struct {
	// The result returned.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s StopInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *StopInstanceResponseBody) SetData(v bool) *StopInstanceResponseBody {
	s.Data = &v
	return s
}

func (s *StopInstanceResponseBody) SetErrorCode(v string) *StopInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *StopInstanceResponseBody) SetErrorMessage(v string) *StopInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *StopInstanceResponseBody) SetHttpStatusCode(v int32) *StopInstanceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *StopInstanceResponseBody) SetRequestId(v string) *StopInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *StopInstanceResponseBody) SetSuccess(v bool) *StopInstanceResponseBody {
	s.Success = &v
	return s
}

type StopInstanceResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *StopInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s StopInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s StopInstanceResponse) GoString() string {
	return s.String()
}

func (s *StopInstanceResponse) SetHeaders(v map[string]*string) *StopInstanceResponse {
	s.Headers = v
	return s
}

func (s *StopInstanceResponse) SetStatusCode(v int32) *StopInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *StopInstanceResponse) SetBody(v *StopInstanceResponseBody) *StopInstanceResponse {
	s.Body = v
	return s
}

type SubmitDataServiceApiRequest struct {
	ApiId     *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	TenantId  *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s SubmitDataServiceApiRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitDataServiceApiRequest) GoString() string {
	return s.String()
}

func (s *SubmitDataServiceApiRequest) SetApiId(v int64) *SubmitDataServiceApiRequest {
	s.ApiId = &v
	return s
}

func (s *SubmitDataServiceApiRequest) SetProjectId(v int64) *SubmitDataServiceApiRequest {
	s.ProjectId = &v
	return s
}

func (s *SubmitDataServiceApiRequest) SetTenantId(v int64) *SubmitDataServiceApiRequest {
	s.TenantId = &v
	return s
}

type SubmitDataServiceApiResponseBody struct {
	Data           *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SubmitDataServiceApiResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitDataServiceApiResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitDataServiceApiResponseBody) SetData(v bool) *SubmitDataServiceApiResponseBody {
	s.Data = &v
	return s
}

func (s *SubmitDataServiceApiResponseBody) SetErrorCode(v string) *SubmitDataServiceApiResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SubmitDataServiceApiResponseBody) SetHttpStatusCode(v int32) *SubmitDataServiceApiResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *SubmitDataServiceApiResponseBody) SetRequestId(v string) *SubmitDataServiceApiResponseBody {
	s.RequestId = &v
	return s
}

func (s *SubmitDataServiceApiResponseBody) SetSuccess(v bool) *SubmitDataServiceApiResponseBody {
	s.Success = &v
	return s
}

type SubmitDataServiceApiResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SubmitDataServiceApiResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SubmitDataServiceApiResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitDataServiceApiResponse) GoString() string {
	return s.String()
}

func (s *SubmitDataServiceApiResponse) SetHeaders(v map[string]*string) *SubmitDataServiceApiResponse {
	s.Headers = v
	return s
}

func (s *SubmitDataServiceApiResponse) SetStatusCode(v int32) *SubmitDataServiceApiResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitDataServiceApiResponse) SetBody(v *SubmitDataServiceApiResponseBody) *SubmitDataServiceApiResponse {
	s.Body = v
	return s
}

type SubmitFileRequest struct {
	// Specifies whether to skip the pre-publish check after the file is committed.
	//
	// *   false: indicates that the pre-publish check is not skipped. After the file is committed, the pre-publish check is automatically triggered. The file can be deployed only after the file passes the check.
	// *   true: indicates that the pre-publish check is skipped. After the file is submitted, the pre-publish check process is not triggered. You can directly publish the file.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The description of the commit operation.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace name. You must configure either this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the file. You can call the [ListFiles](~~173942~~) operation to query the ID.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
	// The HTTP status code returned.
	SkipAllDeployFileExtensions *bool `json:"SkipAllDeployFileExtensions,omitempty" xml:"SkipAllDeployFileExtensions,omitempty"`
}

func (s SubmitFileRequest) String() string {
	return tea.Prettify(s)
}

func (s SubmitFileRequest) GoString() string {
	return s.String()
}

func (s *SubmitFileRequest) SetComment(v string) *SubmitFileRequest {
	s.Comment = &v
	return s
}

func (s *SubmitFileRequest) SetFileId(v int64) *SubmitFileRequest {
	s.FileId = &v
	return s
}

func (s *SubmitFileRequest) SetProjectId(v int64) *SubmitFileRequest {
	s.ProjectId = &v
	return s
}

func (s *SubmitFileRequest) SetProjectIdentifier(v string) *SubmitFileRequest {
	s.ProjectIdentifier = &v
	return s
}

func (s *SubmitFileRequest) SetSkipAllDeployFileExtensions(v bool) *SubmitFileRequest {
	s.SkipAllDeployFileExtensions = &v
	return s
}

type SubmitFileResponseBody struct {
	// The ID of the request. You can troubleshoot issues based on the ID.
	Data      *int64  `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request is successful.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the deployment task. The ID is used as the value of a specific request parameter when you call the [GetDeployment](~~173950~~) operation to query the details of the deployment task.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error message returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The error code returned.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SubmitFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubmitFileResponseBody) GoString() string {
	return s.String()
}

func (s *SubmitFileResponseBody) SetData(v int64) *SubmitFileResponseBody {
	s.Data = &v
	return s
}

func (s *SubmitFileResponseBody) SetErrorCode(v string) *SubmitFileResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SubmitFileResponseBody) SetErrorMessage(v string) *SubmitFileResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SubmitFileResponseBody) SetHttpStatusCode(v int32) *SubmitFileResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *SubmitFileResponseBody) SetRequestId(v string) *SubmitFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *SubmitFileResponseBody) SetSuccess(v bool) *SubmitFileResponseBody {
	s.Success = &v
	return s
}

type SubmitFileResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SubmitFileResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SubmitFileResponse) String() string {
	return tea.Prettify(s)
}

func (s SubmitFileResponse) GoString() string {
	return s.String()
}

func (s *SubmitFileResponse) SetHeaders(v map[string]*string) *SubmitFileResponse {
	s.Headers = v
	return s
}

func (s *SubmitFileResponse) SetStatusCode(v int32) *SubmitFileResponse {
	s.StatusCode = &v
	return s
}

func (s *SubmitFileResponse) SetBody(v *SubmitFileResponseBody) *SubmitFileResponse {
	s.Body = v
	return s
}

type SuspendInstanceRequest struct {
	// The instance ID.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The environment of the workspace. Valid values: PROD and DEV.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
}

func (s SuspendInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s SuspendInstanceRequest) GoString() string {
	return s.String()
}

func (s *SuspendInstanceRequest) SetInstanceId(v int64) *SuspendInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *SuspendInstanceRequest) SetProjectEnv(v string) *SuspendInstanceRequest {
	s.ProjectEnv = &v
	return s
}

type SuspendInstanceResponseBody struct {
	// The result returned.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SuspendInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SuspendInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *SuspendInstanceResponseBody) SetData(v bool) *SuspendInstanceResponseBody {
	s.Data = &v
	return s
}

func (s *SuspendInstanceResponseBody) SetErrorCode(v string) *SuspendInstanceResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *SuspendInstanceResponseBody) SetErrorMessage(v string) *SuspendInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SuspendInstanceResponseBody) SetHttpStatusCode(v int32) *SuspendInstanceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *SuspendInstanceResponseBody) SetRequestId(v string) *SuspendInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *SuspendInstanceResponseBody) SetSuccess(v bool) *SuspendInstanceResponseBody {
	s.Success = &v
	return s
}

type SuspendInstanceResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *SuspendInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s SuspendInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s SuspendInstanceResponse) GoString() string {
	return s.String()
}

func (s *SuspendInstanceResponse) SetHeaders(v map[string]*string) *SuspendInstanceResponse {
	s.Headers = v
	return s
}

func (s *SuspendInstanceResponse) SetStatusCode(v int32) *SuspendInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *SuspendInstanceResponse) SetBody(v *SuspendInstanceResponseBody) *SuspendInstanceResponse {
	s.Body = v
	return s
}

type TerminateDISyncInstanceRequest struct {
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The type of the node. A value of DI_REALTIME indicates that the node is a real-time synchronization node.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the real-time synchronization node.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s TerminateDISyncInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s TerminateDISyncInstanceRequest) GoString() string {
	return s.String()
}

func (s *TerminateDISyncInstanceRequest) SetFileId(v int64) *TerminateDISyncInstanceRequest {
	s.FileId = &v
	return s
}

func (s *TerminateDISyncInstanceRequest) SetProjectId(v int64) *TerminateDISyncInstanceRequest {
	s.ProjectId = &v
	return s
}

func (s *TerminateDISyncInstanceRequest) SetTaskType(v string) *TerminateDISyncInstanceRequest {
	s.TaskType = &v
	return s
}

type TerminateDISyncInstanceResponseBody struct {
	// Indicates whether the real-time synchronization node is terminated. Valid values:
	//
	// *   success
	// *   fail
	Data *TerminateDISyncInstanceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The result of the operation.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request. You can query logs and troubleshoot issues based on the ID.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s TerminateDISyncInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TerminateDISyncInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *TerminateDISyncInstanceResponseBody) SetData(v *TerminateDISyncInstanceResponseBodyData) *TerminateDISyncInstanceResponseBody {
	s.Data = v
	return s
}

func (s *TerminateDISyncInstanceResponseBody) SetRequestId(v string) *TerminateDISyncInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *TerminateDISyncInstanceResponseBody) SetSuccess(v bool) *TerminateDISyncInstanceResponseBody {
	s.Success = &v
	return s
}

type TerminateDISyncInstanceResponseBodyData struct {
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The reason why the real-time synchronization node fails to be terminated. If the real-time synchronization node is terminated, this parameter is left empty.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s TerminateDISyncInstanceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s TerminateDISyncInstanceResponseBodyData) GoString() string {
	return s.String()
}

func (s *TerminateDISyncInstanceResponseBodyData) SetMessage(v string) *TerminateDISyncInstanceResponseBodyData {
	s.Message = &v
	return s
}

func (s *TerminateDISyncInstanceResponseBodyData) SetStatus(v string) *TerminateDISyncInstanceResponseBodyData {
	s.Status = &v
	return s
}

type TerminateDISyncInstanceResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *TerminateDISyncInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s TerminateDISyncInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s TerminateDISyncInstanceResponse) GoString() string {
	return s.String()
}

func (s *TerminateDISyncInstanceResponse) SetHeaders(v map[string]*string) *TerminateDISyncInstanceResponse {
	s.Headers = v
	return s
}

func (s *TerminateDISyncInstanceResponse) SetStatusCode(v int32) *TerminateDISyncInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *TerminateDISyncInstanceResponse) SetBody(v *TerminateDISyncInstanceResponseBody) *TerminateDISyncInstanceResponse {
	s.Body = v
	return s
}

type TestDataServiceApiRequest struct {
	// The ID of the DataService Studio API on which the test is performed.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The data of the request body.
	BodyContent *string `json:"BodyContent,omitempty" xml:"BodyContent,omitempty"`
	// The request parameters that are contained in the request body.
	BodyParams []*TestDataServiceApiRequestBodyParams `json:"BodyParams,omitempty" xml:"BodyParams,omitempty" type:"Repeated"`
	// The request parameters that are contained in the request header.
	HeadParams []*TestDataServiceApiRequestHeadParams `json:"HeadParams,omitempty" xml:"HeadParams,omitempty" type:"Repeated"`
	// The request parameters that are contained in the request path.
	PathParams []*TestDataServiceApiRequestPathParams `json:"PathParams,omitempty" xml:"PathParams,omitempty" type:"Repeated"`
	// The request parameters that are contained in the query.
	QueryParam []*TestDataServiceApiRequestQueryParam `json:"QueryParam,omitempty" xml:"QueryParam,omitempty" type:"Repeated"`
}

func (s TestDataServiceApiRequest) String() string {
	return tea.Prettify(s)
}

func (s TestDataServiceApiRequest) GoString() string {
	return s.String()
}

func (s *TestDataServiceApiRequest) SetApiId(v int64) *TestDataServiceApiRequest {
	s.ApiId = &v
	return s
}

func (s *TestDataServiceApiRequest) SetBodyContent(v string) *TestDataServiceApiRequest {
	s.BodyContent = &v
	return s
}

func (s *TestDataServiceApiRequest) SetBodyParams(v []*TestDataServiceApiRequestBodyParams) *TestDataServiceApiRequest {
	s.BodyParams = v
	return s
}

func (s *TestDataServiceApiRequest) SetHeadParams(v []*TestDataServiceApiRequestHeadParams) *TestDataServiceApiRequest {
	s.HeadParams = v
	return s
}

func (s *TestDataServiceApiRequest) SetPathParams(v []*TestDataServiceApiRequestPathParams) *TestDataServiceApiRequest {
	s.PathParams = v
	return s
}

func (s *TestDataServiceApiRequest) SetQueryParam(v []*TestDataServiceApiRequestQueryParam) *TestDataServiceApiRequest {
	s.QueryParam = v
	return s
}

type TestDataServiceApiRequestBodyParams struct {
	// The name of the parameter.
	ParamKey *string `json:"ParamKey,omitempty" xml:"ParamKey,omitempty"`
	// The value of the parameter.
	ParamValue *string `json:"ParamValue,omitempty" xml:"ParamValue,omitempty"`
}

func (s TestDataServiceApiRequestBodyParams) String() string {
	return tea.Prettify(s)
}

func (s TestDataServiceApiRequestBodyParams) GoString() string {
	return s.String()
}

func (s *TestDataServiceApiRequestBodyParams) SetParamKey(v string) *TestDataServiceApiRequestBodyParams {
	s.ParamKey = &v
	return s
}

func (s *TestDataServiceApiRequestBodyParams) SetParamValue(v string) *TestDataServiceApiRequestBodyParams {
	s.ParamValue = &v
	return s
}

type TestDataServiceApiRequestHeadParams struct {
	// The name of the parameter.
	ParamKey *string `json:"ParamKey,omitempty" xml:"ParamKey,omitempty"`
	// The value of the parameter.
	ParamValue *string `json:"ParamValue,omitempty" xml:"ParamValue,omitempty"`
}

func (s TestDataServiceApiRequestHeadParams) String() string {
	return tea.Prettify(s)
}

func (s TestDataServiceApiRequestHeadParams) GoString() string {
	return s.String()
}

func (s *TestDataServiceApiRequestHeadParams) SetParamKey(v string) *TestDataServiceApiRequestHeadParams {
	s.ParamKey = &v
	return s
}

func (s *TestDataServiceApiRequestHeadParams) SetParamValue(v string) *TestDataServiceApiRequestHeadParams {
	s.ParamValue = &v
	return s
}

type TestDataServiceApiRequestPathParams struct {
	// The name of the parameter.
	ParamKey *string `json:"ParamKey,omitempty" xml:"ParamKey,omitempty"`
	// The value of the parameter.
	ParamValue *string `json:"ParamValue,omitempty" xml:"ParamValue,omitempty"`
}

func (s TestDataServiceApiRequestPathParams) String() string {
	return tea.Prettify(s)
}

func (s TestDataServiceApiRequestPathParams) GoString() string {
	return s.String()
}

func (s *TestDataServiceApiRequestPathParams) SetParamKey(v string) *TestDataServiceApiRequestPathParams {
	s.ParamKey = &v
	return s
}

func (s *TestDataServiceApiRequestPathParams) SetParamValue(v string) *TestDataServiceApiRequestPathParams {
	s.ParamValue = &v
	return s
}

type TestDataServiceApiRequestQueryParam struct {
	// The name of the parameter.
	ParamKey *string `json:"ParamKey,omitempty" xml:"ParamKey,omitempty"`
	// The value of the parameter.
	ParamValue *string `json:"ParamValue,omitempty" xml:"ParamValue,omitempty"`
}

func (s TestDataServiceApiRequestQueryParam) String() string {
	return tea.Prettify(s)
}

func (s TestDataServiceApiRequestQueryParam) GoString() string {
	return s.String()
}

func (s *TestDataServiceApiRequestQueryParam) SetParamKey(v string) *TestDataServiceApiRequestQueryParam {
	s.ParamKey = &v
	return s
}

func (s *TestDataServiceApiRequestQueryParam) SetParamValue(v string) *TestDataServiceApiRequestQueryParam {
	s.ParamValue = &v
	return s
}

type TestDataServiceApiResponseBody struct {
	// The information about the test.
	Data *TestDataServiceApiResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TestDataServiceApiResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TestDataServiceApiResponseBody) GoString() string {
	return s.String()
}

func (s *TestDataServiceApiResponseBody) SetData(v *TestDataServiceApiResponseBodyData) *TestDataServiceApiResponseBody {
	s.Data = v
	return s
}

func (s *TestDataServiceApiResponseBody) SetRequestId(v string) *TestDataServiceApiResponseBody {
	s.RequestId = &v
	return s
}

type TestDataServiceApiResponseBodyData struct {
	// The ID of the test.
	TestId *string `json:"TestId,omitempty" xml:"TestId,omitempty"`
}

func (s TestDataServiceApiResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s TestDataServiceApiResponseBodyData) GoString() string {
	return s.String()
}

func (s *TestDataServiceApiResponseBodyData) SetTestId(v string) *TestDataServiceApiResponseBodyData {
	s.TestId = &v
	return s
}

type TestDataServiceApiResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *TestDataServiceApiResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s TestDataServiceApiResponse) String() string {
	return tea.Prettify(s)
}

func (s TestDataServiceApiResponse) GoString() string {
	return s.String()
}

func (s *TestDataServiceApiResponse) SetHeaders(v map[string]*string) *TestDataServiceApiResponse {
	s.Headers = v
	return s
}

func (s *TestDataServiceApiResponse) SetStatusCode(v int32) *TestDataServiceApiResponse {
	s.StatusCode = &v
	return s
}

func (s *TestDataServiceApiResponse) SetBody(v *TestDataServiceApiResponseBody) *TestDataServiceApiResponse {
	s.Body = v
	return s
}

type TestNetworkConnectionRequest struct {
	// The name of the data source.
	DatasourceName *string `json:"DatasourceName,omitempty" xml:"DatasourceName,omitempty"`
	// The environment to which the data source belongs. Valid values:
	//
	// *   0: development environment
	// *   1: production environment
	EnvType *string `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The ID of the DataWorks workspace to which the data source belongs. You can call the [ListProjects](~~178393~~) operation to query the ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The identifier of the resource group. You can call the [ListResourceGroups](~~173913~~) operation to query the identifier of the resource group.
	ResourceGroup *string `json:"ResourceGroup,omitempty" xml:"ResourceGroup,omitempty"`
}

func (s TestNetworkConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s TestNetworkConnectionRequest) GoString() string {
	return s.String()
}

func (s *TestNetworkConnectionRequest) SetDatasourceName(v string) *TestNetworkConnectionRequest {
	s.DatasourceName = &v
	return s
}

func (s *TestNetworkConnectionRequest) SetEnvType(v string) *TestNetworkConnectionRequest {
	s.EnvType = &v
	return s
}

func (s *TestNetworkConnectionRequest) SetProjectId(v int64) *TestNetworkConnectionRequest {
	s.ProjectId = &v
	return s
}

func (s *TestNetworkConnectionRequest) SetResourceGroup(v string) *TestNetworkConnectionRequest {
	s.ResourceGroup = &v
	return s
}

type TestNetworkConnectionResponseBody struct {
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The information about the connectivity test.
	TaskList *TestNetworkConnectionResponseBodyTaskList `json:"TaskList,omitempty" xml:"TaskList,omitempty" type:"Struct"`
}

func (s TestNetworkConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TestNetworkConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *TestNetworkConnectionResponseBody) SetRequestId(v string) *TestNetworkConnectionResponseBody {
	s.RequestId = &v
	return s
}

func (s *TestNetworkConnectionResponseBody) SetSuccess(v bool) *TestNetworkConnectionResponseBody {
	s.Success = &v
	return s
}

func (s *TestNetworkConnectionResponseBody) SetTaskList(v *TestNetworkConnectionResponseBodyTaskList) *TestNetworkConnectionResponseBody {
	s.TaskList = v
	return s
}

type TestNetworkConnectionResponseBodyTaskList struct {
	// The reason why the data source and resource group failed the connectivity test. If data source and the resource group passed the connectivity test, this parameter is left empty.
	ConnectMessage *string `json:"ConnectMessage,omitempty" xml:"ConnectMessage,omitempty"`
	// The result of the connectivity test. Valid values:
	//
	// *   true: The data source and the resource group passed the connectivity test.
	// *   false: The data source and the resource group failed the connectivity test. You can troubleshoot issues based on the ConnectMessage parameter.
	ConnectStatus *bool `json:"ConnectStatus,omitempty" xml:"ConnectStatus,omitempty"`
}

func (s TestNetworkConnectionResponseBodyTaskList) String() string {
	return tea.Prettify(s)
}

func (s TestNetworkConnectionResponseBodyTaskList) GoString() string {
	return s.String()
}

func (s *TestNetworkConnectionResponseBodyTaskList) SetConnectMessage(v string) *TestNetworkConnectionResponseBodyTaskList {
	s.ConnectMessage = &v
	return s
}

func (s *TestNetworkConnectionResponseBodyTaskList) SetConnectStatus(v bool) *TestNetworkConnectionResponseBodyTaskList {
	s.ConnectStatus = &v
	return s
}

type TestNetworkConnectionResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *TestNetworkConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s TestNetworkConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s TestNetworkConnectionResponse) GoString() string {
	return s.String()
}

func (s *TestNetworkConnectionResponse) SetHeaders(v map[string]*string) *TestNetworkConnectionResponse {
	s.Headers = v
	return s
}

func (s *TestNetworkConnectionResponse) SetStatusCode(v int32) *TestNetworkConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *TestNetworkConnectionResponse) SetBody(v *TestNetworkConnectionResponseBody) *TestNetworkConnectionResponse {
	s.Body = v
	return s
}

type TopTenElapsedTimeInstanceRequest struct {
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s TopTenElapsedTimeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s TopTenElapsedTimeInstanceRequest) GoString() string {
	return s.String()
}

func (s *TopTenElapsedTimeInstanceRequest) SetProjectId(v int64) *TopTenElapsedTimeInstanceRequest {
	s.ProjectId = &v
	return s
}

type TopTenElapsedTimeInstanceResponseBody struct {
	// The ranking record of the running durations of the instances.
	InstanceConsumeTimeRank *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank `json:"InstanceConsumeTimeRank,omitempty" xml:"InstanceConsumeTimeRank,omitempty" type:"Struct"`
	// The ID of the request. You can troubleshoot errors based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TopTenElapsedTimeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TopTenElapsedTimeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *TopTenElapsedTimeInstanceResponseBody) SetInstanceConsumeTimeRank(v *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank) *TopTenElapsedTimeInstanceResponseBody {
	s.InstanceConsumeTimeRank = v
	return s
}

func (s *TopTenElapsedTimeInstanceResponseBody) SetRequestId(v string) *TopTenElapsedTimeInstanceResponseBody {
	s.RequestId = &v
	return s
}

type TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank struct {
	// The ranking data of the running durations of the instances.
	ConsumeTimeRank []*TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank `json:"ConsumeTimeRank,omitempty" xml:"ConsumeTimeRank,omitempty" type:"Repeated"`
	// The timestamp at which the ranking of the running durations of the instances was updated.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank) String() string {
	return tea.Prettify(s)
}

func (s TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank) GoString() string {
	return s.String()
}

func (s *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank) SetConsumeTimeRank(v []*TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank) *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank {
	s.ConsumeTimeRank = v
	return s
}

func (s *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank) SetUpdateTime(v int64) *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRank {
	s.UpdateTime = &v
	return s
}

type TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank struct {
	// The data timestamp of the instance.
	BusinessDate *int64 `json:"BusinessDate,omitempty" xml:"BusinessDate,omitempty"`
	// The running duration of the instance. Unit: seconds.
	Consumed *int64 `json:"Consumed,omitempty" xml:"Consumed,omitempty"`
	// The ID of the instance.
	InstanceId *int64 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The ID of the Alibaba Cloud account used by the owner of the node.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The type of the node.
	//
	// Valid values:
	//
	// 6 (Shell), 10 (ODPS SQL), 11 (ODPS MR), 23 (Data Integration), 24 (ODPS Script), 99 (zero load), 221 (PyODPS 2), 225 (ODPS Spark), 227 (EMR Hive), 228 (EMR Spark), 229 (EMR Spark SQL), 230 (EMR MR), 239 (OSS object inspection), 257 (EMR Shell), 258 (EMR Spark Shell), 259 (EMR Presto), 260 (EMR Impala), 900 (real-time synchronization), 1089 (cross-tenant collaboration), 1091 (Hologres development), 1093 (Hologres SQL), 1100 (assignment), and 1221 (PyODPS 3)
	ProgramType *int32 `json:"ProgramType,omitempty" xml:"ProgramType,omitempty"`
}

func (s TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank) String() string {
	return tea.Prettify(s)
}

func (s TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank) GoString() string {
	return s.String()
}

func (s *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank) SetBusinessDate(v int64) *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank {
	s.BusinessDate = &v
	return s
}

func (s *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank) SetConsumed(v int64) *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank {
	s.Consumed = &v
	return s
}

func (s *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank) SetInstanceId(v int64) *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank {
	s.InstanceId = &v
	return s
}

func (s *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank) SetNodeId(v int64) *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank {
	s.NodeId = &v
	return s
}

func (s *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank) SetNodeName(v string) *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank {
	s.NodeName = &v
	return s
}

func (s *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank) SetOwner(v string) *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank {
	s.Owner = &v
	return s
}

func (s *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank) SetProgramType(v int32) *TopTenElapsedTimeInstanceResponseBodyInstanceConsumeTimeRankConsumeTimeRank {
	s.ProgramType = &v
	return s
}

type TopTenElapsedTimeInstanceResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *TopTenElapsedTimeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s TopTenElapsedTimeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s TopTenElapsedTimeInstanceResponse) GoString() string {
	return s.String()
}

func (s *TopTenElapsedTimeInstanceResponse) SetHeaders(v map[string]*string) *TopTenElapsedTimeInstanceResponse {
	s.Headers = v
	return s
}

func (s *TopTenElapsedTimeInstanceResponse) SetStatusCode(v int32) *TopTenElapsedTimeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *TopTenElapsedTimeInstanceResponse) SetBody(v *TopTenElapsedTimeInstanceResponseBody) *TopTenElapsedTimeInstanceResponse {
	s.Body = v
	return s
}

type TopTenErrorTimesInstanceRequest struct {
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s TopTenErrorTimesInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s TopTenErrorTimesInstanceRequest) GoString() string {
	return s.String()
}

func (s *TopTenErrorTimesInstanceRequest) SetProjectId(v int64) *TopTenErrorTimesInstanceRequest {
	s.ProjectId = &v
	return s
}

type TopTenErrorTimesInstanceResponseBody struct {
	// The ranking of nodes on which errors occur.
	InstanceErrorRank *TopTenErrorTimesInstanceResponseBodyInstanceErrorRank `json:"InstanceErrorRank,omitempty" xml:"InstanceErrorRank,omitempty" type:"Struct"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s TopTenErrorTimesInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TopTenErrorTimesInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *TopTenErrorTimesInstanceResponseBody) SetInstanceErrorRank(v *TopTenErrorTimesInstanceResponseBodyInstanceErrorRank) *TopTenErrorTimesInstanceResponseBody {
	s.InstanceErrorRank = v
	return s
}

func (s *TopTenErrorTimesInstanceResponseBody) SetRequestId(v string) *TopTenErrorTimesInstanceResponseBody {
	s.RequestId = &v
	return s
}

type TopTenErrorTimesInstanceResponseBodyInstanceErrorRank struct {
	// The ranking of nodes on which errors occur within the last month.
	ErrorRank []*TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank `json:"ErrorRank,omitempty" xml:"ErrorRank,omitempty" type:"Repeated"`
	// The time when the ranking was updated.
	UpdateTime *int64 `json:"UpdateTime,omitempty" xml:"UpdateTime,omitempty"`
}

func (s TopTenErrorTimesInstanceResponseBodyInstanceErrorRank) String() string {
	return tea.Prettify(s)
}

func (s TopTenErrorTimesInstanceResponseBodyInstanceErrorRank) GoString() string {
	return s.String()
}

func (s *TopTenErrorTimesInstanceResponseBodyInstanceErrorRank) SetErrorRank(v []*TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank) *TopTenErrorTimesInstanceResponseBodyInstanceErrorRank {
	s.ErrorRank = v
	return s
}

func (s *TopTenErrorTimesInstanceResponseBodyInstanceErrorRank) SetUpdateTime(v int64) *TopTenErrorTimesInstanceResponseBodyInstanceErrorRank {
	s.UpdateTime = &v
	return s
}

type TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank struct {
	// The number of errors that occur on the node.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The ID of the node.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The name of the node.
	NodeName *string `json:"NodeName,omitempty" xml:"NodeName,omitempty"`
	// The user identifier (UID) of the Alibaba Cloud account used by the owner of the node.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The type of the node.
	//
	// Valid values:
	//
	// 6 (Shell node), 10 (ODPS SQL node), 11 (ODPS MR node), 23 (Data Integration node), 24 (ODPS Script node), 99 (zero load node), 221 (PyODPS 2 node), 225 (ODPS Spark node), 227 (EMR Hive node), 228 (EMR Spark node), 229 (EMR Spark SQL node), 230 (EMR MR node), 239 (OSS object inspection node), 257 (EMR Shell node), 258 (EMR Spark Shell node), 259 (EMR Presto node), 260 (EMR Impala node), 900 (real-time data synchronization node), 1089 (cross-tenant collaboration node), 1091 (Hologres development node), 1093 (Hologres SQL node), 1100 (assignment node), and 1221 (PyODPS 3 node).
	ProgramType *int32 `json:"ProgramType,omitempty" xml:"ProgramType,omitempty"`
	// The ID of the DataWorks workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank) String() string {
	return tea.Prettify(s)
}

func (s TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank) GoString() string {
	return s.String()
}

func (s *TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank) SetCount(v int32) *TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank {
	s.Count = &v
	return s
}

func (s *TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank) SetNodeId(v int64) *TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank {
	s.NodeId = &v
	return s
}

func (s *TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank) SetNodeName(v string) *TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank {
	s.NodeName = &v
	return s
}

func (s *TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank) SetOwner(v string) *TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank {
	s.Owner = &v
	return s
}

func (s *TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank) SetProgramType(v int32) *TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank {
	s.ProgramType = &v
	return s
}

func (s *TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank) SetProjectId(v int64) *TopTenErrorTimesInstanceResponseBodyInstanceErrorRankErrorRank {
	s.ProjectId = &v
	return s
}

type TopTenErrorTimesInstanceResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *TopTenErrorTimesInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s TopTenErrorTimesInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s TopTenErrorTimesInstanceResponse) GoString() string {
	return s.String()
}

func (s *TopTenErrorTimesInstanceResponse) SetHeaders(v map[string]*string) *TopTenErrorTimesInstanceResponse {
	s.Headers = v
	return s
}

func (s *TopTenErrorTimesInstanceResponse) SetStatusCode(v int32) *TopTenErrorTimesInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *TopTenErrorTimesInstanceResponse) SetBody(v *TopTenErrorTimesInstanceResponseBody) *TopTenErrorTimesInstanceResponse {
	s.Body = v
	return s
}

type UmountDirectoryRequest struct {
	// The HTTP status code returned. The value 200 indicates that the request was successful.
	TargetId *string `json:"TargetId,omitempty" xml:"TargetId,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	TargetType   *string `json:"TargetType,omitempty" xml:"TargetType,omitempty"`
	TargetUserId *string `json:"TargetUserId,omitempty" xml:"TargetUserId,omitempty"`
}

func (s UmountDirectoryRequest) String() string {
	return tea.Prettify(s)
}

func (s UmountDirectoryRequest) GoString() string {
	return s.String()
}

func (s *UmountDirectoryRequest) SetTargetId(v string) *UmountDirectoryRequest {
	s.TargetId = &v
	return s
}

func (s *UmountDirectoryRequest) SetTargetType(v string) *UmountDirectoryRequest {
	s.TargetType = &v
	return s
}

func (s *UmountDirectoryRequest) SetTargetUserId(v string) *UmountDirectoryRequest {
	s.TargetUserId = &v
	return s
}

type UmountDirectoryResponseBody struct {
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Data      *int32  `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error code returned. The value 200 indicates that the remove task is successful.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The error message returned if the request failed.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The number of directories that are removed. Valid values:
	//
	// *   0: No directories are removed. The left-side navigation pane may not contain the specified directory.
	// *   1: One directory is removed.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UmountDirectoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UmountDirectoryResponseBody) GoString() string {
	return s.String()
}

func (s *UmountDirectoryResponseBody) SetData(v int32) *UmountDirectoryResponseBody {
	s.Data = &v
	return s
}

func (s *UmountDirectoryResponseBody) SetErrorCode(v string) *UmountDirectoryResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UmountDirectoryResponseBody) SetErrorMessage(v string) *UmountDirectoryResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UmountDirectoryResponseBody) SetHttpStatusCode(v int32) *UmountDirectoryResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UmountDirectoryResponseBody) SetRequestId(v string) *UmountDirectoryResponseBody {
	s.RequestId = &v
	return s
}

func (s *UmountDirectoryResponseBody) SetSuccess(v bool) *UmountDirectoryResponseBody {
	s.Success = &v
	return s
}

type UmountDirectoryResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UmountDirectoryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UmountDirectoryResponse) String() string {
	return tea.Prettify(s)
}

func (s UmountDirectoryResponse) GoString() string {
	return s.String()
}

func (s *UmountDirectoryResponse) SetHeaders(v map[string]*string) *UmountDirectoryResponse {
	s.Headers = v
	return s
}

func (s *UmountDirectoryResponse) SetStatusCode(v int32) *UmountDirectoryResponse {
	s.StatusCode = &v
	return s
}

func (s *UmountDirectoryResponse) SetBody(v *UmountDirectoryResponseBody) *UmountDirectoryResponse {
	s.Body = v
	return s
}

type UpdateBaselineRequest struct {
	AlertEnabled         *bool                                    `json:"AlertEnabled,omitempty" xml:"AlertEnabled,omitempty"`
	AlertMarginThreshold *int32                                   `json:"AlertMarginThreshold,omitempty" xml:"AlertMarginThreshold,omitempty"`
	AlertSettings        []*UpdateBaselineRequestAlertSettings    `json:"AlertSettings,omitempty" xml:"AlertSettings,omitempty" type:"Repeated"`
	BaselineId           *int64                                   `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	BaselineName         *string                                  `json:"BaselineName,omitempty" xml:"BaselineName,omitempty"`
	BaselineType         *string                                  `json:"BaselineType,omitempty" xml:"BaselineType,omitempty"`
	Enabled              *bool                                    `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	NodeIds              *string                                  `json:"NodeIds,omitempty" xml:"NodeIds,omitempty"`
	OvertimeSettings     []*UpdateBaselineRequestOvertimeSettings `json:"OvertimeSettings,omitempty" xml:"OvertimeSettings,omitempty" type:"Repeated"`
	Owner                *string                                  `json:"Owner,omitempty" xml:"Owner,omitempty"`
	Priority             *int32                                   `json:"Priority,omitempty" xml:"Priority,omitempty"`
	ProjectId            *int64                                   `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	RemoveNodeIds        *string                                  `json:"RemoveNodeIds,omitempty" xml:"RemoveNodeIds,omitempty"`
}

func (s UpdateBaselineRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateBaselineRequest) GoString() string {
	return s.String()
}

func (s *UpdateBaselineRequest) SetAlertEnabled(v bool) *UpdateBaselineRequest {
	s.AlertEnabled = &v
	return s
}

func (s *UpdateBaselineRequest) SetAlertMarginThreshold(v int32) *UpdateBaselineRequest {
	s.AlertMarginThreshold = &v
	return s
}

func (s *UpdateBaselineRequest) SetAlertSettings(v []*UpdateBaselineRequestAlertSettings) *UpdateBaselineRequest {
	s.AlertSettings = v
	return s
}

func (s *UpdateBaselineRequest) SetBaselineId(v int64) *UpdateBaselineRequest {
	s.BaselineId = &v
	return s
}

func (s *UpdateBaselineRequest) SetBaselineName(v string) *UpdateBaselineRequest {
	s.BaselineName = &v
	return s
}

func (s *UpdateBaselineRequest) SetBaselineType(v string) *UpdateBaselineRequest {
	s.BaselineType = &v
	return s
}

func (s *UpdateBaselineRequest) SetEnabled(v bool) *UpdateBaselineRequest {
	s.Enabled = &v
	return s
}

func (s *UpdateBaselineRequest) SetNodeIds(v string) *UpdateBaselineRequest {
	s.NodeIds = &v
	return s
}

func (s *UpdateBaselineRequest) SetOvertimeSettings(v []*UpdateBaselineRequestOvertimeSettings) *UpdateBaselineRequest {
	s.OvertimeSettings = v
	return s
}

func (s *UpdateBaselineRequest) SetOwner(v string) *UpdateBaselineRequest {
	s.Owner = &v
	return s
}

func (s *UpdateBaselineRequest) SetPriority(v int32) *UpdateBaselineRequest {
	s.Priority = &v
	return s
}

func (s *UpdateBaselineRequest) SetProjectId(v int64) *UpdateBaselineRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateBaselineRequest) SetRemoveNodeIds(v string) *UpdateBaselineRequest {
	s.RemoveNodeIds = &v
	return s
}

type UpdateBaselineRequestAlertSettings struct {
	AlertInterval        *int32                                          `json:"AlertInterval,omitempty" xml:"AlertInterval,omitempty"`
	AlertMaximum         *int32                                          `json:"AlertMaximum,omitempty" xml:"AlertMaximum,omitempty"`
	AlertMethods         []*string                                       `json:"AlertMethods,omitempty" xml:"AlertMethods,omitempty" type:"Repeated"`
	AlertRecipient       *string                                         `json:"AlertRecipient,omitempty" xml:"AlertRecipient,omitempty"`
	AlertRecipientType   *string                                         `json:"AlertRecipientType,omitempty" xml:"AlertRecipientType,omitempty"`
	AlertType            *string                                         `json:"AlertType,omitempty" xml:"AlertType,omitempty"`
	BaselineAlertEnabled *bool                                           `json:"BaselineAlertEnabled,omitempty" xml:"BaselineAlertEnabled,omitempty"`
	DingRobots           []*UpdateBaselineRequestAlertSettingsDingRobots `json:"DingRobots,omitempty" xml:"DingRobots,omitempty" type:"Repeated"`
	SilenceEndTime       *string                                         `json:"SilenceEndTime,omitempty" xml:"SilenceEndTime,omitempty"`
	SilenceStartTime     *string                                         `json:"SilenceStartTime,omitempty" xml:"SilenceStartTime,omitempty"`
	TopicTypes           []*string                                       `json:"TopicTypes,omitempty" xml:"TopicTypes,omitempty" type:"Repeated"`
	Webhooks             []*string                                       `json:"Webhooks,omitempty" xml:"Webhooks,omitempty" type:"Repeated"`
}

func (s UpdateBaselineRequestAlertSettings) String() string {
	return tea.Prettify(s)
}

func (s UpdateBaselineRequestAlertSettings) GoString() string {
	return s.String()
}

func (s *UpdateBaselineRequestAlertSettings) SetAlertInterval(v int32) *UpdateBaselineRequestAlertSettings {
	s.AlertInterval = &v
	return s
}

func (s *UpdateBaselineRequestAlertSettings) SetAlertMaximum(v int32) *UpdateBaselineRequestAlertSettings {
	s.AlertMaximum = &v
	return s
}

func (s *UpdateBaselineRequestAlertSettings) SetAlertMethods(v []*string) *UpdateBaselineRequestAlertSettings {
	s.AlertMethods = v
	return s
}

func (s *UpdateBaselineRequestAlertSettings) SetAlertRecipient(v string) *UpdateBaselineRequestAlertSettings {
	s.AlertRecipient = &v
	return s
}

func (s *UpdateBaselineRequestAlertSettings) SetAlertRecipientType(v string) *UpdateBaselineRequestAlertSettings {
	s.AlertRecipientType = &v
	return s
}

func (s *UpdateBaselineRequestAlertSettings) SetAlertType(v string) *UpdateBaselineRequestAlertSettings {
	s.AlertType = &v
	return s
}

func (s *UpdateBaselineRequestAlertSettings) SetBaselineAlertEnabled(v bool) *UpdateBaselineRequestAlertSettings {
	s.BaselineAlertEnabled = &v
	return s
}

func (s *UpdateBaselineRequestAlertSettings) SetDingRobots(v []*UpdateBaselineRequestAlertSettingsDingRobots) *UpdateBaselineRequestAlertSettings {
	s.DingRobots = v
	return s
}

func (s *UpdateBaselineRequestAlertSettings) SetSilenceEndTime(v string) *UpdateBaselineRequestAlertSettings {
	s.SilenceEndTime = &v
	return s
}

func (s *UpdateBaselineRequestAlertSettings) SetSilenceStartTime(v string) *UpdateBaselineRequestAlertSettings {
	s.SilenceStartTime = &v
	return s
}

func (s *UpdateBaselineRequestAlertSettings) SetTopicTypes(v []*string) *UpdateBaselineRequestAlertSettings {
	s.TopicTypes = v
	return s
}

func (s *UpdateBaselineRequestAlertSettings) SetWebhooks(v []*string) *UpdateBaselineRequestAlertSettings {
	s.Webhooks = v
	return s
}

type UpdateBaselineRequestAlertSettingsDingRobots struct {
	AtAll  *bool   `json:"AtAll,omitempty" xml:"AtAll,omitempty"`
	WebUrl *string `json:"WebUrl,omitempty" xml:"WebUrl,omitempty"`
}

func (s UpdateBaselineRequestAlertSettingsDingRobots) String() string {
	return tea.Prettify(s)
}

func (s UpdateBaselineRequestAlertSettingsDingRobots) GoString() string {
	return s.String()
}

func (s *UpdateBaselineRequestAlertSettingsDingRobots) SetAtAll(v bool) *UpdateBaselineRequestAlertSettingsDingRobots {
	s.AtAll = &v
	return s
}

func (s *UpdateBaselineRequestAlertSettingsDingRobots) SetWebUrl(v string) *UpdateBaselineRequestAlertSettingsDingRobots {
	s.WebUrl = &v
	return s
}

type UpdateBaselineRequestOvertimeSettings struct {
	Cycle *int32  `json:"Cycle,omitempty" xml:"Cycle,omitempty"`
	Time  *string `json:"Time,omitempty" xml:"Time,omitempty"`
}

func (s UpdateBaselineRequestOvertimeSettings) String() string {
	return tea.Prettify(s)
}

func (s UpdateBaselineRequestOvertimeSettings) GoString() string {
	return s.String()
}

func (s *UpdateBaselineRequestOvertimeSettings) SetCycle(v int32) *UpdateBaselineRequestOvertimeSettings {
	s.Cycle = &v
	return s
}

func (s *UpdateBaselineRequestOvertimeSettings) SetTime(v string) *UpdateBaselineRequestOvertimeSettings {
	s.Time = &v
	return s
}

type UpdateBaselineShrinkRequest struct {
	AlertEnabled           *bool   `json:"AlertEnabled,omitempty" xml:"AlertEnabled,omitempty"`
	AlertMarginThreshold   *int32  `json:"AlertMarginThreshold,omitempty" xml:"AlertMarginThreshold,omitempty"`
	AlertSettingsShrink    *string `json:"AlertSettings,omitempty" xml:"AlertSettings,omitempty"`
	BaselineId             *int64  `json:"BaselineId,omitempty" xml:"BaselineId,omitempty"`
	BaselineName           *string `json:"BaselineName,omitempty" xml:"BaselineName,omitempty"`
	BaselineType           *string `json:"BaselineType,omitempty" xml:"BaselineType,omitempty"`
	Enabled                *bool   `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	NodeIds                *string `json:"NodeIds,omitempty" xml:"NodeIds,omitempty"`
	OvertimeSettingsShrink *string `json:"OvertimeSettings,omitempty" xml:"OvertimeSettings,omitempty"`
	Owner                  *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	Priority               *int32  `json:"Priority,omitempty" xml:"Priority,omitempty"`
	ProjectId              *int64  `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	RemoveNodeIds          *string `json:"RemoveNodeIds,omitempty" xml:"RemoveNodeIds,omitempty"`
}

func (s UpdateBaselineShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateBaselineShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateBaselineShrinkRequest) SetAlertEnabled(v bool) *UpdateBaselineShrinkRequest {
	s.AlertEnabled = &v
	return s
}

func (s *UpdateBaselineShrinkRequest) SetAlertMarginThreshold(v int32) *UpdateBaselineShrinkRequest {
	s.AlertMarginThreshold = &v
	return s
}

func (s *UpdateBaselineShrinkRequest) SetAlertSettingsShrink(v string) *UpdateBaselineShrinkRequest {
	s.AlertSettingsShrink = &v
	return s
}

func (s *UpdateBaselineShrinkRequest) SetBaselineId(v int64) *UpdateBaselineShrinkRequest {
	s.BaselineId = &v
	return s
}

func (s *UpdateBaselineShrinkRequest) SetBaselineName(v string) *UpdateBaselineShrinkRequest {
	s.BaselineName = &v
	return s
}

func (s *UpdateBaselineShrinkRequest) SetBaselineType(v string) *UpdateBaselineShrinkRequest {
	s.BaselineType = &v
	return s
}

func (s *UpdateBaselineShrinkRequest) SetEnabled(v bool) *UpdateBaselineShrinkRequest {
	s.Enabled = &v
	return s
}

func (s *UpdateBaselineShrinkRequest) SetNodeIds(v string) *UpdateBaselineShrinkRequest {
	s.NodeIds = &v
	return s
}

func (s *UpdateBaselineShrinkRequest) SetOvertimeSettingsShrink(v string) *UpdateBaselineShrinkRequest {
	s.OvertimeSettingsShrink = &v
	return s
}

func (s *UpdateBaselineShrinkRequest) SetOwner(v string) *UpdateBaselineShrinkRequest {
	s.Owner = &v
	return s
}

func (s *UpdateBaselineShrinkRequest) SetPriority(v int32) *UpdateBaselineShrinkRequest {
	s.Priority = &v
	return s
}

func (s *UpdateBaselineShrinkRequest) SetProjectId(v int64) *UpdateBaselineShrinkRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateBaselineShrinkRequest) SetRemoveNodeIds(v string) *UpdateBaselineShrinkRequest {
	s.RemoveNodeIds = &v
	return s
}

type UpdateBaselineResponseBody struct {
	Data           *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode      *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage   *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	HttpStatusCode *int32  `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateBaselineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateBaselineResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateBaselineResponseBody) SetData(v bool) *UpdateBaselineResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateBaselineResponseBody) SetErrorCode(v string) *UpdateBaselineResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateBaselineResponseBody) SetErrorMessage(v string) *UpdateBaselineResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateBaselineResponseBody) SetHttpStatusCode(v int32) *UpdateBaselineResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateBaselineResponseBody) SetRequestId(v string) *UpdateBaselineResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateBaselineResponseBody) SetSuccess(v bool) *UpdateBaselineResponseBody {
	s.Success = &v
	return s
}

type UpdateBaselineResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateBaselineResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateBaselineResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateBaselineResponse) GoString() string {
	return s.String()
}

func (s *UpdateBaselineResponse) SetHeaders(v map[string]*string) *UpdateBaselineResponse {
	s.Headers = v
	return s
}

func (s *UpdateBaselineResponse) SetStatusCode(v int32) *UpdateBaselineResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateBaselineResponse) SetBody(v *UpdateBaselineResponseBody) *UpdateBaselineResponse {
	s.Body = v
	return s
}

type UpdateBusinessRequest struct {
	// The ID of the workflow. You can call the [ListBusiness](~~173945~~) operation to obtain the workflow ID.
	BusinessId *int64 `json:"BusinessId,omitempty" xml:"BusinessId,omitempty"`
	// The name of the workflow. You can call the [ListBusiness](~~173945~~) operation to obtain the workflow name.
	BusinessName *string `json:"BusinessName,omitempty" xml:"BusinessName,omitempty"`
	// The description of the workflow.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The owner of the workflow. You can call the [ListBusiness](~~173945~~) operation to obtain the workflow owner.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace ID. You must configure either this parameter or the ProjectIdentifier parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the workspace name. You must configure either this parameter or ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s UpdateBusinessRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateBusinessRequest) GoString() string {
	return s.String()
}

func (s *UpdateBusinessRequest) SetBusinessId(v int64) *UpdateBusinessRequest {
	s.BusinessId = &v
	return s
}

func (s *UpdateBusinessRequest) SetBusinessName(v string) *UpdateBusinessRequest {
	s.BusinessName = &v
	return s
}

func (s *UpdateBusinessRequest) SetDescription(v string) *UpdateBusinessRequest {
	s.Description = &v
	return s
}

func (s *UpdateBusinessRequest) SetOwner(v string) *UpdateBusinessRequest {
	s.Owner = &v
	return s
}

func (s *UpdateBusinessRequest) SetProjectId(v int64) *UpdateBusinessRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateBusinessRequest) SetProjectIdentifier(v string) *UpdateBusinessRequest {
	s.ProjectIdentifier = &v
	return s
}

type UpdateBusinessResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateBusinessResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateBusinessResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateBusinessResponseBody) SetErrorCode(v string) *UpdateBusinessResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateBusinessResponseBody) SetErrorMessage(v string) *UpdateBusinessResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateBusinessResponseBody) SetHttpStatusCode(v int32) *UpdateBusinessResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateBusinessResponseBody) SetRequestId(v string) *UpdateBusinessResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateBusinessResponseBody) SetSuccess(v bool) *UpdateBusinessResponseBody {
	s.Success = &v
	return s
}

type UpdateBusinessResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateBusinessResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateBusinessResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateBusinessResponse) GoString() string {
	return s.String()
}

func (s *UpdateBusinessResponse) SetHeaders(v map[string]*string) *UpdateBusinessResponse {
	s.Headers = v
	return s
}

func (s *UpdateBusinessResponse) SetStatusCode(v int32) *UpdateBusinessResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateBusinessResponse) SetBody(v *UpdateBusinessResponseBody) *UpdateBusinessResponse {
	s.Body = v
	return s
}

type UpdateConnectionRequest struct {
	// The ID of the data source.
	ConnectionId *int64 `json:"ConnectionId,omitempty" xml:"ConnectionId,omitempty"`
	// Details of the data source.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// Describes the data source.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Environment of the data source.
	EnvType *int32 `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The status of the data source.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateConnectionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateConnectionRequest) GoString() string {
	return s.String()
}

func (s *UpdateConnectionRequest) SetConnectionId(v int64) *UpdateConnectionRequest {
	s.ConnectionId = &v
	return s
}

func (s *UpdateConnectionRequest) SetContent(v string) *UpdateConnectionRequest {
	s.Content = &v
	return s
}

func (s *UpdateConnectionRequest) SetDescription(v string) *UpdateConnectionRequest {
	s.Description = &v
	return s
}

func (s *UpdateConnectionRequest) SetEnvType(v int32) *UpdateConnectionRequest {
	s.EnvType = &v
	return s
}

func (s *UpdateConnectionRequest) SetStatus(v string) *UpdateConnectionRequest {
	s.Status = &v
	return s
}

type UpdateConnectionResponseBody struct {
	// Indicates whether the update is successful.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The HTTP status code.
	HttpStatusCode *string `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. A value of true indicates that the request is successful. A value of false indicates that the request has failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateConnectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateConnectionResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateConnectionResponseBody) SetData(v bool) *UpdateConnectionResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateConnectionResponseBody) SetHttpStatusCode(v string) *UpdateConnectionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateConnectionResponseBody) SetRequestId(v string) *UpdateConnectionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateConnectionResponseBody) SetSuccess(v bool) *UpdateConnectionResponseBody {
	s.Success = &v
	return s
}

type UpdateConnectionResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateConnectionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateConnectionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateConnectionResponse) GoString() string {
	return s.String()
}

func (s *UpdateConnectionResponse) SetHeaders(v map[string]*string) *UpdateConnectionResponse {
	s.Headers = v
	return s
}

func (s *UpdateConnectionResponse) SetStatusCode(v int32) *UpdateConnectionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateConnectionResponse) SetBody(v *UpdateConnectionResponseBody) *UpdateConnectionResponse {
	s.Body = v
	return s
}

type UpdateDIAlarmRuleRequest struct {
	DIAlarmRuleId        *int64                                        `json:"DIAlarmRuleId,omitempty" xml:"DIAlarmRuleId,omitempty"`
	Description          *string                                       `json:"Description,omitempty" xml:"Description,omitempty"`
	Enabled              *bool                                         `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	MetricType           *string                                       `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	NotificationSettings *UpdateDIAlarmRuleRequestNotificationSettings `json:"NotificationSettings,omitempty" xml:"NotificationSettings,omitempty" type:"Struct"`
	TriggerConditions    []*UpdateDIAlarmRuleRequestTriggerConditions  `json:"TriggerConditions,omitempty" xml:"TriggerConditions,omitempty" type:"Repeated"`
}

func (s UpdateDIAlarmRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIAlarmRuleRequest) GoString() string {
	return s.String()
}

func (s *UpdateDIAlarmRuleRequest) SetDIAlarmRuleId(v int64) *UpdateDIAlarmRuleRequest {
	s.DIAlarmRuleId = &v
	return s
}

func (s *UpdateDIAlarmRuleRequest) SetDescription(v string) *UpdateDIAlarmRuleRequest {
	s.Description = &v
	return s
}

func (s *UpdateDIAlarmRuleRequest) SetEnabled(v bool) *UpdateDIAlarmRuleRequest {
	s.Enabled = &v
	return s
}

func (s *UpdateDIAlarmRuleRequest) SetMetricType(v string) *UpdateDIAlarmRuleRequest {
	s.MetricType = &v
	return s
}

func (s *UpdateDIAlarmRuleRequest) SetNotificationSettings(v *UpdateDIAlarmRuleRequestNotificationSettings) *UpdateDIAlarmRuleRequest {
	s.NotificationSettings = v
	return s
}

func (s *UpdateDIAlarmRuleRequest) SetTriggerConditions(v []*UpdateDIAlarmRuleRequestTriggerConditions) *UpdateDIAlarmRuleRequest {
	s.TriggerConditions = v
	return s
}

type UpdateDIAlarmRuleRequestNotificationSettings struct {
	InhibitionInterval    *int32                                                               `json:"InhibitionInterval,omitempty" xml:"InhibitionInterval,omitempty"`
	NotificationChannels  []*UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels  `json:"NotificationChannels,omitempty" xml:"NotificationChannels,omitempty" type:"Repeated"`
	NotificationReceivers []*UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers `json:"NotificationReceivers,omitempty" xml:"NotificationReceivers,omitempty" type:"Repeated"`
}

func (s UpdateDIAlarmRuleRequestNotificationSettings) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIAlarmRuleRequestNotificationSettings) GoString() string {
	return s.String()
}

func (s *UpdateDIAlarmRuleRequestNotificationSettings) SetInhibitionInterval(v int32) *UpdateDIAlarmRuleRequestNotificationSettings {
	s.InhibitionInterval = &v
	return s
}

func (s *UpdateDIAlarmRuleRequestNotificationSettings) SetNotificationChannels(v []*UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels) *UpdateDIAlarmRuleRequestNotificationSettings {
	s.NotificationChannels = v
	return s
}

func (s *UpdateDIAlarmRuleRequestNotificationSettings) SetNotificationReceivers(v []*UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers) *UpdateDIAlarmRuleRequestNotificationSettings {
	s.NotificationReceivers = v
	return s
}

type UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels struct {
	Channels []*string `json:"Channels,omitempty" xml:"Channels,omitempty" type:"Repeated"`
	Severity *string   `json:"Severity,omitempty" xml:"Severity,omitempty"`
}

func (s UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels) GoString() string {
	return s.String()
}

func (s *UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels) SetChannels(v []*string) *UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels {
	s.Channels = v
	return s
}

func (s *UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels) SetSeverity(v string) *UpdateDIAlarmRuleRequestNotificationSettingsNotificationChannels {
	s.Severity = &v
	return s
}

type UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers struct {
	ReceiverType   *string   `json:"ReceiverType,omitempty" xml:"ReceiverType,omitempty"`
	ReceiverValues []*string `json:"ReceiverValues,omitempty" xml:"ReceiverValues,omitempty" type:"Repeated"`
}

func (s UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers) GoString() string {
	return s.String()
}

func (s *UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers) SetReceiverType(v string) *UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers {
	s.ReceiverType = &v
	return s
}

func (s *UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers) SetReceiverValues(v []*string) *UpdateDIAlarmRuleRequestNotificationSettingsNotificationReceivers {
	s.ReceiverValues = v
	return s
}

type UpdateDIAlarmRuleRequestTriggerConditions struct {
	Duration  *int64  `json:"Duration,omitempty" xml:"Duration,omitempty"`
	Severity  *string `json:"Severity,omitempty" xml:"Severity,omitempty"`
	Threshold *int64  `json:"Threshold,omitempty" xml:"Threshold,omitempty"`
}

func (s UpdateDIAlarmRuleRequestTriggerConditions) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIAlarmRuleRequestTriggerConditions) GoString() string {
	return s.String()
}

func (s *UpdateDIAlarmRuleRequestTriggerConditions) SetDuration(v int64) *UpdateDIAlarmRuleRequestTriggerConditions {
	s.Duration = &v
	return s
}

func (s *UpdateDIAlarmRuleRequestTriggerConditions) SetSeverity(v string) *UpdateDIAlarmRuleRequestTriggerConditions {
	s.Severity = &v
	return s
}

func (s *UpdateDIAlarmRuleRequestTriggerConditions) SetThreshold(v int64) *UpdateDIAlarmRuleRequestTriggerConditions {
	s.Threshold = &v
	return s
}

type UpdateDIAlarmRuleShrinkRequest struct {
	DIAlarmRuleId              *int64  `json:"DIAlarmRuleId,omitempty" xml:"DIAlarmRuleId,omitempty"`
	Description                *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Enabled                    *bool   `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	MetricType                 *string `json:"MetricType,omitempty" xml:"MetricType,omitempty"`
	NotificationSettingsShrink *string `json:"NotificationSettings,omitempty" xml:"NotificationSettings,omitempty"`
	TriggerConditionsShrink    *string `json:"TriggerConditions,omitempty" xml:"TriggerConditions,omitempty"`
}

func (s UpdateDIAlarmRuleShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIAlarmRuleShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateDIAlarmRuleShrinkRequest) SetDIAlarmRuleId(v int64) *UpdateDIAlarmRuleShrinkRequest {
	s.DIAlarmRuleId = &v
	return s
}

func (s *UpdateDIAlarmRuleShrinkRequest) SetDescription(v string) *UpdateDIAlarmRuleShrinkRequest {
	s.Description = &v
	return s
}

func (s *UpdateDIAlarmRuleShrinkRequest) SetEnabled(v bool) *UpdateDIAlarmRuleShrinkRequest {
	s.Enabled = &v
	return s
}

func (s *UpdateDIAlarmRuleShrinkRequest) SetMetricType(v string) *UpdateDIAlarmRuleShrinkRequest {
	s.MetricType = &v
	return s
}

func (s *UpdateDIAlarmRuleShrinkRequest) SetNotificationSettingsShrink(v string) *UpdateDIAlarmRuleShrinkRequest {
	s.NotificationSettingsShrink = &v
	return s
}

func (s *UpdateDIAlarmRuleShrinkRequest) SetTriggerConditionsShrink(v string) *UpdateDIAlarmRuleShrinkRequest {
	s.TriggerConditionsShrink = &v
	return s
}

type UpdateDIAlarmRuleResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDIAlarmRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIAlarmRuleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDIAlarmRuleResponseBody) SetRequestId(v string) *UpdateDIAlarmRuleResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDIAlarmRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateDIAlarmRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateDIAlarmRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIAlarmRuleResponse) GoString() string {
	return s.String()
}

func (s *UpdateDIAlarmRuleResponse) SetHeaders(v map[string]*string) *UpdateDIAlarmRuleResponse {
	s.Headers = v
	return s
}

func (s *UpdateDIAlarmRuleResponse) SetStatusCode(v int32) *UpdateDIAlarmRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDIAlarmRuleResponse) SetBody(v *UpdateDIAlarmRuleResponseBody) *UpdateDIAlarmRuleResponse {
	s.Body = v
	return s
}

type UpdateDIJobRequest struct {
	DIJobId             *int64                                   `json:"DIJobId,omitempty" xml:"DIJobId,omitempty"`
	Description         *string                                  `json:"Description,omitempty" xml:"Description,omitempty"`
	JobSettings         *UpdateDIJobRequestJobSettings           `json:"JobSettings,omitempty" xml:"JobSettings,omitempty" type:"Struct"`
	ResourceSettings    *UpdateDIJobRequestResourceSettings      `json:"ResourceSettings,omitempty" xml:"ResourceSettings,omitempty" type:"Struct"`
	TableMappings       []*UpdateDIJobRequestTableMappings       `json:"TableMappings,omitempty" xml:"TableMappings,omitempty" type:"Repeated"`
	TransformationRules []*UpdateDIJobRequestTransformationRules `json:"TransformationRules,omitempty" xml:"TransformationRules,omitempty" type:"Repeated"`
}

func (s UpdateDIJobRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobRequest) GoString() string {
	return s.String()
}

func (s *UpdateDIJobRequest) SetDIJobId(v int64) *UpdateDIJobRequest {
	s.DIJobId = &v
	return s
}

func (s *UpdateDIJobRequest) SetDescription(v string) *UpdateDIJobRequest {
	s.Description = &v
	return s
}

func (s *UpdateDIJobRequest) SetJobSettings(v *UpdateDIJobRequestJobSettings) *UpdateDIJobRequest {
	s.JobSettings = v
	return s
}

func (s *UpdateDIJobRequest) SetResourceSettings(v *UpdateDIJobRequestResourceSettings) *UpdateDIJobRequest {
	s.ResourceSettings = v
	return s
}

func (s *UpdateDIJobRequest) SetTableMappings(v []*UpdateDIJobRequestTableMappings) *UpdateDIJobRequest {
	s.TableMappings = v
	return s
}

func (s *UpdateDIJobRequest) SetTransformationRules(v []*UpdateDIJobRequestTransformationRules) *UpdateDIJobRequest {
	s.TransformationRules = v
	return s
}

type UpdateDIJobRequestJobSettings struct {
	ChannelSettings        *string                                                `json:"ChannelSettings,omitempty" xml:"ChannelSettings,omitempty"`
	ColumnDataTypeSettings []*UpdateDIJobRequestJobSettingsColumnDataTypeSettings `json:"ColumnDataTypeSettings,omitempty" xml:"ColumnDataTypeSettings,omitempty" type:"Repeated"`
	CycleScheduleSettings  *UpdateDIJobRequestJobSettingsCycleScheduleSettings    `json:"CycleScheduleSettings,omitempty" xml:"CycleScheduleSettings,omitempty" type:"Struct"`
	DdlHandlingSettings    []*UpdateDIJobRequestJobSettingsDdlHandlingSettings    `json:"DdlHandlingSettings,omitempty" xml:"DdlHandlingSettings,omitempty" type:"Repeated"`
	RuntimeSettings        []*UpdateDIJobRequestJobSettingsRuntimeSettings        `json:"RuntimeSettings,omitempty" xml:"RuntimeSettings,omitempty" type:"Repeated"`
}

func (s UpdateDIJobRequestJobSettings) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobRequestJobSettings) GoString() string {
	return s.String()
}

func (s *UpdateDIJobRequestJobSettings) SetChannelSettings(v string) *UpdateDIJobRequestJobSettings {
	s.ChannelSettings = &v
	return s
}

func (s *UpdateDIJobRequestJobSettings) SetColumnDataTypeSettings(v []*UpdateDIJobRequestJobSettingsColumnDataTypeSettings) *UpdateDIJobRequestJobSettings {
	s.ColumnDataTypeSettings = v
	return s
}

func (s *UpdateDIJobRequestJobSettings) SetCycleScheduleSettings(v *UpdateDIJobRequestJobSettingsCycleScheduleSettings) *UpdateDIJobRequestJobSettings {
	s.CycleScheduleSettings = v
	return s
}

func (s *UpdateDIJobRequestJobSettings) SetDdlHandlingSettings(v []*UpdateDIJobRequestJobSettingsDdlHandlingSettings) *UpdateDIJobRequestJobSettings {
	s.DdlHandlingSettings = v
	return s
}

func (s *UpdateDIJobRequestJobSettings) SetRuntimeSettings(v []*UpdateDIJobRequestJobSettingsRuntimeSettings) *UpdateDIJobRequestJobSettings {
	s.RuntimeSettings = v
	return s
}

type UpdateDIJobRequestJobSettingsColumnDataTypeSettings struct {
	DestinationDataType *string `json:"DestinationDataType,omitempty" xml:"DestinationDataType,omitempty"`
	SourceDataType      *string `json:"SourceDataType,omitempty" xml:"SourceDataType,omitempty"`
}

func (s UpdateDIJobRequestJobSettingsColumnDataTypeSettings) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobRequestJobSettingsColumnDataTypeSettings) GoString() string {
	return s.String()
}

func (s *UpdateDIJobRequestJobSettingsColumnDataTypeSettings) SetDestinationDataType(v string) *UpdateDIJobRequestJobSettingsColumnDataTypeSettings {
	s.DestinationDataType = &v
	return s
}

func (s *UpdateDIJobRequestJobSettingsColumnDataTypeSettings) SetSourceDataType(v string) *UpdateDIJobRequestJobSettingsColumnDataTypeSettings {
	s.SourceDataType = &v
	return s
}

type UpdateDIJobRequestJobSettingsCycleScheduleSettings struct {
	ScheduleParameters *string `json:"ScheduleParameters,omitempty" xml:"ScheduleParameters,omitempty"`
}

func (s UpdateDIJobRequestJobSettingsCycleScheduleSettings) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobRequestJobSettingsCycleScheduleSettings) GoString() string {
	return s.String()
}

func (s *UpdateDIJobRequestJobSettingsCycleScheduleSettings) SetScheduleParameters(v string) *UpdateDIJobRequestJobSettingsCycleScheduleSettings {
	s.ScheduleParameters = &v
	return s
}

type UpdateDIJobRequestJobSettingsDdlHandlingSettings struct {
	Action *string `json:"Action,omitempty" xml:"Action,omitempty"`
	Type   *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateDIJobRequestJobSettingsDdlHandlingSettings) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobRequestJobSettingsDdlHandlingSettings) GoString() string {
	return s.String()
}

func (s *UpdateDIJobRequestJobSettingsDdlHandlingSettings) SetAction(v string) *UpdateDIJobRequestJobSettingsDdlHandlingSettings {
	s.Action = &v
	return s
}

func (s *UpdateDIJobRequestJobSettingsDdlHandlingSettings) SetType(v string) *UpdateDIJobRequestJobSettingsDdlHandlingSettings {
	s.Type = &v
	return s
}

type UpdateDIJobRequestJobSettingsRuntimeSettings struct {
	Name  *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s UpdateDIJobRequestJobSettingsRuntimeSettings) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobRequestJobSettingsRuntimeSettings) GoString() string {
	return s.String()
}

func (s *UpdateDIJobRequestJobSettingsRuntimeSettings) SetName(v string) *UpdateDIJobRequestJobSettingsRuntimeSettings {
	s.Name = &v
	return s
}

func (s *UpdateDIJobRequestJobSettingsRuntimeSettings) SetValue(v string) *UpdateDIJobRequestJobSettingsRuntimeSettings {
	s.Value = &v
	return s
}

type UpdateDIJobRequestResourceSettings struct {
	OfflineResourceSettings  *UpdateDIJobRequestResourceSettingsOfflineResourceSettings  `json:"OfflineResourceSettings,omitempty" xml:"OfflineResourceSettings,omitempty" type:"Struct"`
	RealtimeResourceSettings *UpdateDIJobRequestResourceSettingsRealtimeResourceSettings `json:"RealtimeResourceSettings,omitempty" xml:"RealtimeResourceSettings,omitempty" type:"Struct"`
}

func (s UpdateDIJobRequestResourceSettings) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobRequestResourceSettings) GoString() string {
	return s.String()
}

func (s *UpdateDIJobRequestResourceSettings) SetOfflineResourceSettings(v *UpdateDIJobRequestResourceSettingsOfflineResourceSettings) *UpdateDIJobRequestResourceSettings {
	s.OfflineResourceSettings = v
	return s
}

func (s *UpdateDIJobRequestResourceSettings) SetRealtimeResourceSettings(v *UpdateDIJobRequestResourceSettingsRealtimeResourceSettings) *UpdateDIJobRequestResourceSettings {
	s.RealtimeResourceSettings = v
	return s
}

type UpdateDIJobRequestResourceSettingsOfflineResourceSettings struct {
	ResourceGroupIdentifier *string `json:"ResourceGroupIdentifier,omitempty" xml:"ResourceGroupIdentifier,omitempty"`
}

func (s UpdateDIJobRequestResourceSettingsOfflineResourceSettings) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobRequestResourceSettingsOfflineResourceSettings) GoString() string {
	return s.String()
}

func (s *UpdateDIJobRequestResourceSettingsOfflineResourceSettings) SetResourceGroupIdentifier(v string) *UpdateDIJobRequestResourceSettingsOfflineResourceSettings {
	s.ResourceGroupIdentifier = &v
	return s
}

type UpdateDIJobRequestResourceSettingsRealtimeResourceSettings struct {
	ResourceGroupIdentifier *string `json:"ResourceGroupIdentifier,omitempty" xml:"ResourceGroupIdentifier,omitempty"`
}

func (s UpdateDIJobRequestResourceSettingsRealtimeResourceSettings) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobRequestResourceSettingsRealtimeResourceSettings) GoString() string {
	return s.String()
}

func (s *UpdateDIJobRequestResourceSettingsRealtimeResourceSettings) SetResourceGroupIdentifier(v string) *UpdateDIJobRequestResourceSettingsRealtimeResourceSettings {
	s.ResourceGroupIdentifier = &v
	return s
}

type UpdateDIJobRequestTableMappings struct {
	SourceObjectSelectionRules []*UpdateDIJobRequestTableMappingsSourceObjectSelectionRules `json:"SourceObjectSelectionRules,omitempty" xml:"SourceObjectSelectionRules,omitempty" type:"Repeated"`
	TransformationRules        []*UpdateDIJobRequestTableMappingsTransformationRules        `json:"TransformationRules,omitempty" xml:"TransformationRules,omitempty" type:"Repeated"`
}

func (s UpdateDIJobRequestTableMappings) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobRequestTableMappings) GoString() string {
	return s.String()
}

func (s *UpdateDIJobRequestTableMappings) SetSourceObjectSelectionRules(v []*UpdateDIJobRequestTableMappingsSourceObjectSelectionRules) *UpdateDIJobRequestTableMappings {
	s.SourceObjectSelectionRules = v
	return s
}

func (s *UpdateDIJobRequestTableMappings) SetTransformationRules(v []*UpdateDIJobRequestTableMappingsTransformationRules) *UpdateDIJobRequestTableMappings {
	s.TransformationRules = v
	return s
}

type UpdateDIJobRequestTableMappingsSourceObjectSelectionRules struct {
	Expression *string `json:"Expression,omitempty" xml:"Expression,omitempty"`
	ObjectType *string `json:"ObjectType,omitempty" xml:"ObjectType,omitempty"`
}

func (s UpdateDIJobRequestTableMappingsSourceObjectSelectionRules) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobRequestTableMappingsSourceObjectSelectionRules) GoString() string {
	return s.String()
}

func (s *UpdateDIJobRequestTableMappingsSourceObjectSelectionRules) SetExpression(v string) *UpdateDIJobRequestTableMappingsSourceObjectSelectionRules {
	s.Expression = &v
	return s
}

func (s *UpdateDIJobRequestTableMappingsSourceObjectSelectionRules) SetObjectType(v string) *UpdateDIJobRequestTableMappingsSourceObjectSelectionRules {
	s.ObjectType = &v
	return s
}

type UpdateDIJobRequestTableMappingsTransformationRules struct {
	RuleActionType *string `json:"RuleActionType,omitempty" xml:"RuleActionType,omitempty"`
	RuleName       *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	RuleTargetType *string `json:"RuleTargetType,omitempty" xml:"RuleTargetType,omitempty"`
}

func (s UpdateDIJobRequestTableMappingsTransformationRules) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobRequestTableMappingsTransformationRules) GoString() string {
	return s.String()
}

func (s *UpdateDIJobRequestTableMappingsTransformationRules) SetRuleActionType(v string) *UpdateDIJobRequestTableMappingsTransformationRules {
	s.RuleActionType = &v
	return s
}

func (s *UpdateDIJobRequestTableMappingsTransformationRules) SetRuleName(v string) *UpdateDIJobRequestTableMappingsTransformationRules {
	s.RuleName = &v
	return s
}

func (s *UpdateDIJobRequestTableMappingsTransformationRules) SetRuleTargetType(v string) *UpdateDIJobRequestTableMappingsTransformationRules {
	s.RuleTargetType = &v
	return s
}

type UpdateDIJobRequestTransformationRules struct {
	RuleActionType *string `json:"RuleActionType,omitempty" xml:"RuleActionType,omitempty"`
	RuleExpression *string `json:"RuleExpression,omitempty" xml:"RuleExpression,omitempty"`
	RuleName       *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	RuleTargetType *string `json:"RuleTargetType,omitempty" xml:"RuleTargetType,omitempty"`
}

func (s UpdateDIJobRequestTransformationRules) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobRequestTransformationRules) GoString() string {
	return s.String()
}

func (s *UpdateDIJobRequestTransformationRules) SetRuleActionType(v string) *UpdateDIJobRequestTransformationRules {
	s.RuleActionType = &v
	return s
}

func (s *UpdateDIJobRequestTransformationRules) SetRuleExpression(v string) *UpdateDIJobRequestTransformationRules {
	s.RuleExpression = &v
	return s
}

func (s *UpdateDIJobRequestTransformationRules) SetRuleName(v string) *UpdateDIJobRequestTransformationRules {
	s.RuleName = &v
	return s
}

func (s *UpdateDIJobRequestTransformationRules) SetRuleTargetType(v string) *UpdateDIJobRequestTransformationRules {
	s.RuleTargetType = &v
	return s
}

type UpdateDIJobShrinkRequest struct {
	DIJobId                   *int64  `json:"DIJobId,omitempty" xml:"DIJobId,omitempty"`
	Description               *string `json:"Description,omitempty" xml:"Description,omitempty"`
	JobSettingsShrink         *string `json:"JobSettings,omitempty" xml:"JobSettings,omitempty"`
	ResourceSettingsShrink    *string `json:"ResourceSettings,omitempty" xml:"ResourceSettings,omitempty"`
	TableMappingsShrink       *string `json:"TableMappings,omitempty" xml:"TableMappings,omitempty"`
	TransformationRulesShrink *string `json:"TransformationRules,omitempty" xml:"TransformationRules,omitempty"`
}

func (s UpdateDIJobShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateDIJobShrinkRequest) SetDIJobId(v int64) *UpdateDIJobShrinkRequest {
	s.DIJobId = &v
	return s
}

func (s *UpdateDIJobShrinkRequest) SetDescription(v string) *UpdateDIJobShrinkRequest {
	s.Description = &v
	return s
}

func (s *UpdateDIJobShrinkRequest) SetJobSettingsShrink(v string) *UpdateDIJobShrinkRequest {
	s.JobSettingsShrink = &v
	return s
}

func (s *UpdateDIJobShrinkRequest) SetResourceSettingsShrink(v string) *UpdateDIJobShrinkRequest {
	s.ResourceSettingsShrink = &v
	return s
}

func (s *UpdateDIJobShrinkRequest) SetTableMappingsShrink(v string) *UpdateDIJobShrinkRequest {
	s.TableMappingsShrink = &v
	return s
}

func (s *UpdateDIJobShrinkRequest) SetTransformationRulesShrink(v string) *UpdateDIJobShrinkRequest {
	s.TransformationRulesShrink = &v
	return s
}

type UpdateDIJobResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateDIJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDIJobResponseBody) SetRequestId(v string) *UpdateDIJobResponseBody {
	s.RequestId = &v
	return s
}

type UpdateDIJobResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateDIJobResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateDIJobResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIJobResponse) GoString() string {
	return s.String()
}

func (s *UpdateDIJobResponse) SetHeaders(v map[string]*string) *UpdateDIJobResponse {
	s.Headers = v
	return s
}

func (s *UpdateDIJobResponse) SetStatusCode(v int32) *UpdateDIJobResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDIJobResponse) SetBody(v *UpdateDIJobResponseBody) *UpdateDIJobResponse {
	s.Body = v
	return s
}

type UpdateDIProjectConfigRequest struct {
	// The type of the sources of the synchronization solutions.
	//
	// Valid values: oracle, mysql, polardb, datahub, drds, and analyticdb_for_mysql.
	//
	// If you do not configure this parameter, DataWorks applies the default global configuration to all sources.
	DestinationType *string `json:"DestinationType,omitempty" xml:"DestinationType,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	ProjectConfig *string `json:"ProjectConfig,omitempty" xml:"ProjectConfig,omitempty"`
	// The type of the destinations of the synchronization solutions. This parameter cannot be left empty.
	//
	// Valid values: analyticdb_for_mysql, odps, elasticsearch, holo, mysql, and polardb.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The new default global configuration of synchronization solutions. The value indicates the processing rules of different types of DDL messages. The value must be in the JSON format. Example:
	//
	// {"RENAMECOLUMN":"WARNING","DROPTABLE":"WARNING","CREATETABLE":"WARNING","MODIFYCOLUMN":"WARNING","TRUNCATETABLE":"WARNING","DROPCOLUMN":"WARNING","ADDCOLUMN":"WARNING","RENAMETABLE":"WARNING"}
	//
	// Field description:
	//
	// *   RENAMECOLUMN: renames a column.
	// *   DROPTABLE: deletes a table.
	// *   CREATETABLE: creates a table.
	// *   MODIFYCOLUMN: changes the data type of a column.
	// *   TRUNCATETABLE: clears a table.
	// *   DROPCOLUMN: deletes a column.
	// *   ADDCOLUMN: creates a column.
	// *   RENAMETABLE: renames a table.
	//
	// DataWorks processes a DDL message of a specific type based on the following rules:
	//
	// *   WARNING: ignores the message and records an alert in real-time synchronization logs. The alert contains information about the situation that the message is ignored because of an execution error.
	// *   IGNORE: discards the message and does not send it to the destination.
	// *   CRITICAL: terminates the real-time synchronization node and sets the node status to Failed.
	// *   NORMAL: sends the message to the destination to process the message. Each destination processes DDL messages based on its own business logic. If DataWorks adopts the NORMAL policy, DataWorks only forwards DDL messages.
	SourceType *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
}

func (s UpdateDIProjectConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIProjectConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateDIProjectConfigRequest) SetDestinationType(v string) *UpdateDIProjectConfigRequest {
	s.DestinationType = &v
	return s
}

func (s *UpdateDIProjectConfigRequest) SetProjectConfig(v string) *UpdateDIProjectConfigRequest {
	s.ProjectConfig = &v
	return s
}

func (s *UpdateDIProjectConfigRequest) SetProjectId(v int64) *UpdateDIProjectConfigRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateDIProjectConfigRequest) SetSourceType(v string) *UpdateDIProjectConfigRequest {
	s.SourceType = &v
	return s
}

type UpdateDIProjectConfigResponseBody struct {
	// Indicates whether the default global configuration of synchronization solutions was modified. Valid values:
	//
	// *   success: The default global configuration of synchronization solutions was modified.
	// *   fail: The default global configuration of synchronization solutions failed to be modified.
	Data *UpdateDIProjectConfigResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The information about the modification.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the request. You can use the ID to locate logs and troubleshoot issues.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateDIProjectConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIProjectConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDIProjectConfigResponseBody) SetData(v *UpdateDIProjectConfigResponseBodyData) *UpdateDIProjectConfigResponseBody {
	s.Data = v
	return s
}

func (s *UpdateDIProjectConfigResponseBody) SetRequestId(v string) *UpdateDIProjectConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateDIProjectConfigResponseBody) SetSuccess(v bool) *UpdateDIProjectConfigResponseBody {
	s.Success = &v
	return s
}

type UpdateDIProjectConfigResponseBodyData struct {
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateDIProjectConfigResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIProjectConfigResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdateDIProjectConfigResponseBodyData) SetStatus(v string) *UpdateDIProjectConfigResponseBodyData {
	s.Status = &v
	return s
}

type UpdateDIProjectConfigResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateDIProjectConfigResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateDIProjectConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDIProjectConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateDIProjectConfigResponse) SetHeaders(v map[string]*string) *UpdateDIProjectConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateDIProjectConfigResponse) SetStatusCode(v int32) *UpdateDIProjectConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDIProjectConfigResponse) SetBody(v *UpdateDIProjectConfigResponseBody) *UpdateDIProjectConfigResponse {
	s.Body = v
	return s
}

type UpdateDISyncTaskRequest struct {
	// The ID of the sync node to be updated. You can call the [ListFiles](~~173942~~) operation to query the ID of the node.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace ID.
	//
	// You must set this parameter to specify the DataWorks workspace in which the node resides.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The updated configuration of the sync node. This operation is equivalent to node update by using the code editor in the DataWorks console. For more information, see [Create a sync node by using the code editor](~~137717~~). You can call the UpdateDISyncTask operation to update only batch sync nodes. If you do not need to update the configuration of the sync node, leave this parameter empty.
	TaskContent *string `json:"TaskContent,omitempty" xml:"TaskContent,omitempty"`
	// The setting that updates the resource group used by the node. The value must be in the JSON format.
	//
	// Only the ResourceGroup field is supported. This field specifies the identifier of the resource group for Data Integration that is used by the node. To query the identifier of the resource group, call the [ListResourceGroup](~~62055~~) operation.
	//
	// If you do not need to update the resource group for the sync node, leave this parameter empty.
	TaskParam *string `json:"TaskParam,omitempty" xml:"TaskParam,omitempty"`
	// The type of the sync node.
	//
	// You can call the UpdateDISyncTask operation to update only batch sync nodes. The value must be DI_OFFLINE.
	TaskType *string `json:"TaskType,omitempty" xml:"TaskType,omitempty"`
}

func (s UpdateDISyncTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDISyncTaskRequest) GoString() string {
	return s.String()
}

func (s *UpdateDISyncTaskRequest) SetFileId(v int64) *UpdateDISyncTaskRequest {
	s.FileId = &v
	return s
}

func (s *UpdateDISyncTaskRequest) SetProjectId(v int64) *UpdateDISyncTaskRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateDISyncTaskRequest) SetTaskContent(v string) *UpdateDISyncTaskRequest {
	s.TaskContent = &v
	return s
}

func (s *UpdateDISyncTaskRequest) SetTaskParam(v string) *UpdateDISyncTaskRequest {
	s.TaskParam = &v
	return s
}

func (s *UpdateDISyncTaskRequest) SetTaskType(v string) *UpdateDISyncTaskRequest {
	s.TaskType = &v
	return s
}

type UpdateDISyncTaskResponseBody struct {
	// The information that indicates whether the sync node was updated.
	Data *UpdateDISyncTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request. You can locate logs and troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateDISyncTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDISyncTaskResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDISyncTaskResponseBody) SetData(v *UpdateDISyncTaskResponseBodyData) *UpdateDISyncTaskResponseBody {
	s.Data = v
	return s
}

func (s *UpdateDISyncTaskResponseBody) SetRequestId(v string) *UpdateDISyncTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateDISyncTaskResponseBody) SetSuccess(v bool) *UpdateDISyncTaskResponseBody {
	s.Success = &v
	return s
}

type UpdateDISyncTaskResponseBodyData struct {
	// The reason why the sync node failed to be updated. If the sync node was updated, this parameter is left empty.
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// Indicates whether the sync node was updated. Valid values:
	//
	// *   success: The sync node was updated.
	// *   fail: The sync node failed to be updated.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateDISyncTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s UpdateDISyncTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *UpdateDISyncTaskResponseBodyData) SetMessage(v string) *UpdateDISyncTaskResponseBodyData {
	s.Message = &v
	return s
}

func (s *UpdateDISyncTaskResponseBodyData) SetStatus(v string) *UpdateDISyncTaskResponseBodyData {
	s.Status = &v
	return s
}

type UpdateDISyncTaskResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateDISyncTaskResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateDISyncTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDISyncTaskResponse) GoString() string {
	return s.String()
}

func (s *UpdateDISyncTaskResponse) SetHeaders(v map[string]*string) *UpdateDISyncTaskResponse {
	s.Headers = v
	return s
}

func (s *UpdateDISyncTaskResponse) SetStatusCode(v int32) *UpdateDISyncTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDISyncTaskResponse) SetBody(v *UpdateDISyncTaskResponseBody) *UpdateDISyncTaskResponse {
	s.Body = v
	return s
}

type UpdateDataServiceApiRequest struct {
	// The description of the API.
	ApiDescription *string `json:"ApiDescription,omitempty" xml:"ApiDescription,omitempty"`
	// The ID of the API.
	ApiId *int64 `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	// The path of the API.
	ApiPath *string `json:"ApiPath,omitempty" xml:"ApiPath,omitempty"`
	// The ID of the workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The protocol used by the API. Valid values: 0 and 1. The value 0 indicates HTTP. The value 1 indicates HTTPS. You can specify multiple protocols. Separate multiple protocols with commas (,).
	Protocols *string `json:"Protocols,omitempty" xml:"Protocols,omitempty"`
	// The details of the API generated by registration. For more information, see the RegistrationDetails parameter returned by the [GetDataServiceApi](~~174013~~) operation.
	RegistrationDetails *string `json:"RegistrationDetails,omitempty" xml:"RegistrationDetails,omitempty"`
	// The request method of the API. Valid values: 0, 1, 2, and 3. The value 0 indicates the GET method. The value 1 indicates the POST method. The value 2 indicates the PUT method. The value 3 indicates the DELETE method. APIs generated in wizard or script mode support the GET and POST methods. APIs generated by registration support the GET, POST, PUT, and DELETE methods.
	RequestMethod   *int32 `json:"RequestMethod,omitempty" xml:"RequestMethod,omitempty"`
	ResourceGroupId *int64 `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The format in which the response of the API request is returned. Valid values: 0 and 1. The value 0 indicates the JSON format. The value 1 indicates the XML format. APIs generated in wizard or script mode support the JSON format. APIs generated by registration support the JSON and XML formats.
	ResponseContentType *int32 `json:"ResponseContentType,omitempty" xml:"ResponseContentType,omitempty"`
	// The details of the API generated in script mode. For more information, see the ScriptDetails parameter returned by the [GetDataServiceApi](~~174013~~) operation.
	ScriptDetails *string `json:"ScriptDetails,omitempty" xml:"ScriptDetails,omitempty"`
	// The ID of the tenant.
	TenantId *int64 `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
	// The timeout period of the API request. Unit: milliseconds. Valid values: (0,30000].
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The scope in which the API is visible. Valid values: 0 and 1. The value 0 indicates that the API is visible within the workspace. The value 1 indicates that the API is visible only to its owner.
	VisibleRange *int32 `json:"VisibleRange,omitempty" xml:"VisibleRange,omitempty"`
	// The details of the API generated in wizard mode. For more information, see the WizardDetails parameter returned by the [GetDataServiceApi](~~174013~~) operation.
	WizardDetails *string `json:"WizardDetails,omitempty" xml:"WizardDetails,omitempty"`
}

func (s UpdateDataServiceApiRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDataServiceApiRequest) GoString() string {
	return s.String()
}

func (s *UpdateDataServiceApiRequest) SetApiDescription(v string) *UpdateDataServiceApiRequest {
	s.ApiDescription = &v
	return s
}

func (s *UpdateDataServiceApiRequest) SetApiId(v int64) *UpdateDataServiceApiRequest {
	s.ApiId = &v
	return s
}

func (s *UpdateDataServiceApiRequest) SetApiPath(v string) *UpdateDataServiceApiRequest {
	s.ApiPath = &v
	return s
}

func (s *UpdateDataServiceApiRequest) SetProjectId(v int64) *UpdateDataServiceApiRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateDataServiceApiRequest) SetProtocols(v string) *UpdateDataServiceApiRequest {
	s.Protocols = &v
	return s
}

func (s *UpdateDataServiceApiRequest) SetRegistrationDetails(v string) *UpdateDataServiceApiRequest {
	s.RegistrationDetails = &v
	return s
}

func (s *UpdateDataServiceApiRequest) SetRequestMethod(v int32) *UpdateDataServiceApiRequest {
	s.RequestMethod = &v
	return s
}

func (s *UpdateDataServiceApiRequest) SetResourceGroupId(v int64) *UpdateDataServiceApiRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *UpdateDataServiceApiRequest) SetResponseContentType(v int32) *UpdateDataServiceApiRequest {
	s.ResponseContentType = &v
	return s
}

func (s *UpdateDataServiceApiRequest) SetScriptDetails(v string) *UpdateDataServiceApiRequest {
	s.ScriptDetails = &v
	return s
}

func (s *UpdateDataServiceApiRequest) SetTenantId(v int64) *UpdateDataServiceApiRequest {
	s.TenantId = &v
	return s
}

func (s *UpdateDataServiceApiRequest) SetTimeout(v int32) *UpdateDataServiceApiRequest {
	s.Timeout = &v
	return s
}

func (s *UpdateDataServiceApiRequest) SetVisibleRange(v int32) *UpdateDataServiceApiRequest {
	s.VisibleRange = &v
	return s
}

func (s *UpdateDataServiceApiRequest) SetWizardDetails(v string) *UpdateDataServiceApiRequest {
	s.WizardDetails = &v
	return s
}

type UpdateDataServiceApiResponseBody struct {
	// Indicates whether the information about the API is updated.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateDataServiceApiResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDataServiceApiResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDataServiceApiResponseBody) SetData(v bool) *UpdateDataServiceApiResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateDataServiceApiResponseBody) SetErrorCode(v string) *UpdateDataServiceApiResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateDataServiceApiResponseBody) SetErrorMessage(v string) *UpdateDataServiceApiResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateDataServiceApiResponseBody) SetHttpStatusCode(v int32) *UpdateDataServiceApiResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateDataServiceApiResponseBody) SetRequestId(v string) *UpdateDataServiceApiResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateDataServiceApiResponseBody) SetSuccess(v bool) *UpdateDataServiceApiResponseBody {
	s.Success = &v
	return s
}

type UpdateDataServiceApiResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateDataServiceApiResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateDataServiceApiResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDataServiceApiResponse) GoString() string {
	return s.String()
}

func (s *UpdateDataServiceApiResponse) SetHeaders(v map[string]*string) *UpdateDataServiceApiResponse {
	s.Headers = v
	return s
}

func (s *UpdateDataServiceApiResponse) SetStatusCode(v int32) *UpdateDataServiceApiResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDataServiceApiResponse) SetBody(v *UpdateDataServiceApiResponseBody) *UpdateDataServiceApiResponse {
	s.Body = v
	return s
}

type UpdateDataSourceRequest struct {
	// The ID of the data source that you want to update. You can call the [ListDataSources](~~211431~~) operation to obtain the ID.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// Indicates whether the data source is updated.
	DataSourceId *int64 `json:"DataSourceId,omitempty" xml:"DataSourceId,omitempty"`
	// The details about the data source that you want to update.
	//
	// You are not allowed to change the type of the data source. For example, you are not allowed to change the data source type from MaxCompute to mysql.
	//
	// Examples of details of some common data sources:
	//
	// *   odps
	//
	// ```
	//
	// {
	//   "accessId": "xssssss",
	//   "accessKey": "xsaxsaxsa",
	//   "authType": 2,
	//   "endpoint": "http://service.odps.aliyun.com/api",
	//   "project": "xsaxsax",
	//   "tag": "public"
	// }
	//
	// ```
	//
	// *   mysql
	//
	// ```
	//
	// {
	//   "database": "xsaxsa",
	//   "instanceName": "rm-xsaxsa",
	//   "password": "xsaxsa",
	//   "rdsOwnerId": "xasxsa",
	//   "regionId": "cn-shanghai",
	//   "tag": "rds",
	//   "username": "xsaxsa"
	// }
	//
	// ```
	//
	// *   rds
	//
	// ```
	//
	// {
	//   "configType": 1,
	//   "tag": "rds",
	//   "database": "xsaxsa",
	//   "username": "xsaxsa",
	//   "password": "xssaxsa$32050",
	//   "instanceName": "rm-xsaxs",
	//   "rdsOwnerId": "11111111"
	// }
	//
	// ```
	//
	// *   oss
	//
	// ```
	//
	// {
	//   "accessId": "sssssxx",
	//   "accessKey": "xsaxaxsaxs",
	//   "bucket": "xsa-xs-xs",
	//   "endpoint": "http://oss-cn-shanghai.aliyuncs.com",
	//   "tag": "public"
	// }
	//
	// ```
	//
	// *   sqlserver
	//
	// ```
	//
	// {
	//   "jdbcUrl": "jdbc:sqlserver://xsaxsa-xsaxsa.database.xxx.cnv:123;DatabaseName=xsxs-xsxs",
	//   "password": "sdasda$fs",
	//   "tag": "public",
	//   "username": "sxaxacdacdd"
	// }
	//
	// ```
	//
	// *   polardb
	//
	// ```
	//
	// {
	//   "clusterId": "pc-sdadsadsa",
	//   "database": "dsadsadsa",
	//   "ownerId": "121212122",
	//   "password": "sdasdafssa",
	//   "region": "cn-shanghai",
	//   "tag": "polardb",
	//   "username": "asdadsads"
	// }
	//
	// ```
	//
	// *   oracle
	//
	// ```
	//
	// {
	//   "jdbcUrl": "jdbc:oracle:saaa:@xxxxx:1521:PROD",
	//   "password": "sxasaxsa",
	//   "tag": "public",
	//   "username": "sasfadfa"
	// }
	//
	// ```
	//
	// *   mongodb
	//
	// ```
	//
	// {
	//   "address": "[\"xsaxxsa.mongodb.rds.aliyuncs.com:3717\"]",
	//   "database": "admin",
	//   "password": "sadsda@",
	//   "tag": "public",
	//   "username": "dsadsadas"
	// }
	//
	// ```
	//
	// *   emr
	//
	// ```
	//
	// {
	//   "accessId": "xsaxsa",
	//   "emrClusterId": "C-dsads",
	//   "emrResourceQueueName": "default",
	//   "emrEndpoint": "emr.aliyuncs.com",
	//   "accessKey": "dsadsad",
	//   "emrUserId": "224833315798889783",
	//   "name": "sasdsadsa",
	//   "emrAccessMode": "simple",
	//   "region": "cn-shanghai",
	//   "authType": "2",
	//   "emrProjectId": "FP-sdadsad"
	// }
	//
	// ```
	//
	// *   postgresql
	//
	// ```
	//
	// {
	//   "jdbcUrl": "jdbc:postgresql://xxxx:1921/ssss",
	//   "password": "sdadsads",
	//   "tag": "public",
	//   "username": "sdsasda"
	// }
	//
	// ```
	//
	// *   analyticdb_for_mysql
	//
	// ```
	//
	// {
	//   "instanceId": "am-sadsada",
	//   "database": "xsxsx",
	//   "username": "xsxsa",
	//   "password": "asdadsa",
	//   "connectionString": "am-xssxsxs.ads.aliyuncs.com:3306"
	// }
	//
	// ```
	//
	// *   hybriddb_for_postgresql
	//
	// ```
	//
	// {
	//   "connectionString": "gp-xsaxsaxa-master.gpdbmaster.rds.aliyuncs.com",
	//   "database": "xsaxsaxas",
	//   "password": "xsaxsaxsa@11",
	//   "instanceId": "gp-xsaxsaxsa",
	//   "port": "541132",
	//   "ownerId": "xsaxsaxsas",
	//   "username": "sadsad"
	// }
	//
	// ```
	//
	// *   holo
	//
	// ```
	//
	// {
	//   "accessId": "xsaxsaxs",
	//   "accessKey": "xsaxsaxsa",
	//   "database": "xsaxsaxsa",
	//   "instanceId": "xsaxa",
	//   "tag": "aliyun"
	// }
	//
	// ```
	//
	// *   kafka
	//
	// ```
	//
	// {
	//   "instanceId": "xsax-cn-xsaxsa",
	//   "regionId": "cn-shanghai",
	//   "tag": "aliyun",
	//   "ownerId": "1212121212112"
	// }
	//
	// ```
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The status of the data source. The parameter is deprecated. Do not use this parameter.
	EnvType *int32 `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The HTTP status code returned.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateDataSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDataSourceRequest) GoString() string {
	return s.String()
}

func (s *UpdateDataSourceRequest) SetContent(v string) *UpdateDataSourceRequest {
	s.Content = &v
	return s
}

func (s *UpdateDataSourceRequest) SetDataSourceId(v int64) *UpdateDataSourceRequest {
	s.DataSourceId = &v
	return s
}

func (s *UpdateDataSourceRequest) SetDescription(v string) *UpdateDataSourceRequest {
	s.Description = &v
	return s
}

func (s *UpdateDataSourceRequest) SetEnvType(v int32) *UpdateDataSourceRequest {
	s.EnvType = &v
	return s
}

func (s *UpdateDataSourceRequest) SetStatus(v string) *UpdateDataSourceRequest {
	s.Status = &v
	return s
}

type UpdateDataSourceResponseBody struct {
	// Indicates whether the request is successful.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The ID of the request.
	HttpStatusCode *string `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateDataSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDataSourceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDataSourceResponseBody) SetData(v bool) *UpdateDataSourceResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateDataSourceResponseBody) SetHttpStatusCode(v string) *UpdateDataSourceResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateDataSourceResponseBody) SetRequestId(v string) *UpdateDataSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateDataSourceResponseBody) SetSuccess(v bool) *UpdateDataSourceResponseBody {
	s.Success = &v
	return s
}

type UpdateDataSourceResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateDataSourceResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateDataSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDataSourceResponse) GoString() string {
	return s.String()
}

func (s *UpdateDataSourceResponse) SetHeaders(v map[string]*string) *UpdateDataSourceResponse {
	s.Headers = v
	return s
}

func (s *UpdateDataSourceResponse) SetStatusCode(v int32) *UpdateDataSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDataSourceResponse) SetBody(v *UpdateDataSourceResponseBody) *UpdateDataSourceResponse {
	s.Body = v
	return s
}

type UpdateFileRequest struct {
	// The advanced configurations of the node.
	//
	// This parameter is valid only for an EMR Spark Streaming node or an EMR Streaming SQL node. This parameter corresponds to the Advanced Settings tab of the node in the [DataWorks console](https://workbench.data.aliyun.com/console).
	//
	// This parameter is configured in the JSON format.
	AdvancedSettings *string `json:"AdvancedSettings,omitempty" xml:"AdvancedSettings,omitempty"`
	// Specifies whether the automatic parsing feature is enabled for the file. Valid values:
	//
	// *   true: The automatic parsing feature is enabled for the file.
	// *   false: The automatic parsing feature is not enabled for the file.
	//
	// This parameter corresponds to the Analyze Code parameter that is displayed after Same Cycle is selected in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	AutoParsing *bool `json:"AutoParsing,omitempty" xml:"AutoParsing,omitempty"`
	// The interval between two consecutive automatic reruns after an error occurs. Unit: milliseconds. Maximum value: 1800000 (30 minutes).
	//
	// This parameter corresponds to the Rerun Interval parameter that is displayed after the Auto Rerun upon Error check box is selected in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	//
	// The interval that you specify in the DataWorks console is measured in minutes. Pay attention to the conversion between the units of time when you call the operation.
	AutoRerunIntervalMillis *int32 `json:"AutoRerunIntervalMillis,omitempty" xml:"AutoRerunIntervalMillis,omitempty"`
	// The number of automatic reruns that are allowed after an error occurs.
	AutoRerunTimes *int32 `json:"AutoRerunTimes,omitempty" xml:"AutoRerunTimes,omitempty"`
	// The name of the connected data source that is used to run the node. You can call the [ListDataSources](~~211431~~) operation to query the available data sources of the workspace.
	ConnectionName *string `json:"ConnectionName,omitempty" xml:"ConnectionName,omitempty"`
	// The code of the file. The code format varies based on the file type. To view the code format for a specific file type, go to Operation Center, right-click a node of the file type, and then select View Code.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The CRON expression that represents the periodic scheduling policy of the node. This parameter corresponds to the Cron Expression parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console). After you configure the Scheduling Cycle and Run At parameters in the DataWorks console, DataWorks automatically generates a value for the Cron Expression parameter.
	//
	// Examples:
	//
	// *   CRON expression for a node that is scheduled to run at 05:30 every day: `00 30 05 * * ?`
	// *   CRON expression for a node that is scheduled to run at the fifteenth minute of each hour: `00 15 * * * ?`
	// *   CRON expression for a node that is scheduled to run every 10 minutes: `00 00/10 * * * ?`
	// *   CRON expression for a node that is scheduled to run every 10 minutes from 08:00 to 17:00 every day: `00 00-59/10 8-23 * * * ?`
	// *   CRON expression for a node that is scheduled to run at 00:20 on the first day of each month: `00 20 00 1 * ?`
	// *   CRON expression for a node that is scheduled to run every three months starting from 00:10 on January 1: `00 10 00 1 1-12/3 ?`
	// *   CRON expression for a node that is scheduled to run at 00:05 every Tuesday and Friday: `00 05 00 * * 2,5`
	//
	// The scheduling system of DataWorks imposes the following limits on CRON expressions:
	//
	// *   A node can be scheduled to run at a minimum interval of 5 minutes.
	// *   A node can be scheduled to run at 00:05 every day at the earliest.
	CronExpress *string `json:"CronExpress,omitempty" xml:"CronExpress,omitempty"`
	// The type of the scheduling cycle of the node that corresponds to the file. Valid values: NOT_DAY and DAY. The value NOT_DAY indicates that the node is scheduled to run by minute or hour. The value DAY indicates that the node is scheduled to run by day, week, or month.
	//
	// This parameter corresponds to the Scheduling Cycle parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	CycleType *string `json:"CycleType,omitempty" xml:"CycleType,omitempty"`
	// The ID of the node on which the node corresponding to the file depends when the DependentType parameter is set to USER_DEFINE. Multiple IDs are separated by commas (,).
	//
	// The value of this parameter corresponds to the ID of the node that you specified after you select Previous Cycle and set Depend On to Other Nodes in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	DependentNodeIdList *string `json:"DependentNodeIdList,omitempty" xml:"DependentNodeIdList,omitempty"`
	// The type of the cross-cycle scheduling dependency of the node that corresponds to the file. Valid values:
	//
	// *   SELF: The instance generated for the node in the current cycle depends on the instance generated for the node in the previous cycle.
	// *   CHILD: The instance generated for the node in the current cycle depends on the instances generated for the descendant nodes at the nearest level of the node in the previous cycle.
	// *   USER_DEFINE: The instance generated for the node in the current cycle depends on the instances generated for one or more specified nodes in the previous cycle.
	// *   NONE: No cross-cycle scheduling dependency type is selected for the node.
	DependentType *string `json:"DependentType,omitempty" xml:"DependentType,omitempty"`
	// The end time of automatic scheduling. Set this parameter to a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	//
	// This parameter corresponds to the end time specified for the Validity Period parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	EndEffectDate *int64 `json:"EndEffectDate,omitempty" xml:"EndEffectDate,omitempty"`
	// The description of the file.
	FileDescription *string `json:"FileDescription,omitempty" xml:"FileDescription,omitempty"`
	// The path of the file.
	FileFolderPath *string `json:"FileFolderPath,omitempty" xml:"FileFolderPath,omitempty"`
	// The ID of the file. You can call the [ListFiles](~~173942~~) operation to obtain the ID.
	FileId *int64 `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The name of the file. You can set the FileName parameter to a new value to change the file name.
	//
	// You can call the [ListFiles](~~173942~~) operation to query the ID of the file whose name you want to change. Then, you can set the FileId parameter to the ID and set the FileName parameter to a new value when you call the [UpdateFile](~~173951~~) operation.
	FileName                        *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	IgnoreParentSkipRunningProperty *bool   `json:"IgnoreParentSkipRunningProperty,omitempty" xml:"IgnoreParentSkipRunningProperty,omitempty"`
	// The output name of the parent file on which the current file depends. If you specify multiple output names, separate them with commas (,).
	//
	// This parameter corresponds to the Output Name parameter under Parent Nodes in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	InputList *string `json:"InputList,omitempty" xml:"InputList,omitempty"`
	// The input parameters of the node. This parameter is configured in the JSON format. For more information about the input parameters, refer to the InputContextParameterList parameter in the Response parameters section of the [GetFile](~~173954~~) operation.
	//
	// This parameter corresponds to the Input Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	InputParameters *string `json:"InputParameters,omitempty" xml:"InputParameters,omitempty"`
	// The output name of the current file.
	//
	// This parameter corresponds to the Output Name parameter in the Dependencies section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	OutputList *string `json:"OutputList,omitempty" xml:"OutputList,omitempty"`
	// The output parameters of the node. This parameter is configured in the JSON format. For more information about the output parameters, refer to the OutputContextParameterList parameter in the Response parameters section of the [GetFile](~~173954~~) operation.
	//
	// This parameter corresponds to the Output Parameters table in the Input and Output Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	OutputParameters *string `json:"OutputParameters,omitempty" xml:"OutputParameters,omitempty"`
	// The ID of the file owner.
	Owner *string `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The scheduling parameters of the node.
	//
	// This parameter corresponds to the Parameters section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console). For more information, see [Configure scheduling parameters](~~137548~~).
	ParaValue *string `json:"ParaValue,omitempty" xml:"ParaValue,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the workspace name.
	//
	// You must configure this parameter or the ProjectId parameter to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
	// Specifies whether the node that corresponds to the file can be rerun. Valid values:
	//
	// *   ALL_ALLOWED: The node can be rerun regardless of whether it is successfully run or fails to run.
	// *   FAILURE_ALLOWED: The node can be rerun only after it fails to run.
	// *   ALL_DENIED: The node cannot be rerun regardless of whether it is successfully run or fails to run.
	//
	// This parameter corresponds to the Rerun parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	RerunMode *string `json:"RerunMode,omitempty" xml:"RerunMode,omitempty"`
	// The identifier of the resource group that is used to run the node. You can call the [ListResourceGroups](~~173913~~) operation to query the available resource groups in the workspace.
	ResourceGroupIdentifier *string `json:"ResourceGroupIdentifier,omitempty" xml:"ResourceGroupIdentifier,omitempty"`
	// The scheduling type of the node. Valid values:
	//
	// *   NORMAL: The node is an auto triggered node.
	// *   MANUAL: The node is a manually triggered node. Manually triggered nodes cannot be automatically triggered. They correspond to the nodes in the Manually Triggered Workflows pane.
	// *   PAUSE: The node is a paused node.
	// *   SKIP: The inner node is a dry-run node. Dry-run nodes are started as scheduled but the scheduling system sets the status of the nodes to succeeded when the scheduling system starts to run the nodes.
	SchedulerType *string `json:"SchedulerType,omitempty" xml:"SchedulerType,omitempty"`
	// The start time of automatic scheduling. Set this parameter to a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	//
	// This parameter corresponds to the Validity Period parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	StartEffectDate *int64 `json:"StartEffectDate,omitempty" xml:"StartEffectDate,omitempty"`
	// Specifies whether to immediately run a node after the node is deployed to the production environment. Valid values:
	//
	// *   true: A node is immediately run after the node is deployed to the production environment.
	// *   false: A node is not immediately run after the node is deployed to the production environment.
	//
	// This parameter is valid only for an EMR Spark Streaming node or an EMR Streaming SQL node. This parameter corresponds to the Start Method parameter in the Schedule section of the Configure tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	StartImmediately *bool `json:"StartImmediately,omitempty" xml:"StartImmediately,omitempty"`
	// Specifies whether to suspend the scheduling of the node. Valid values:
	//
	// *   true: suspends the scheduling of the node.
	// *   false: does not suspend the scheduling of the node.
	//
	// This parameter corresponds to the Recurrence parameter in the Schedule section of the Properties tab in the [DataWorks console](https://workbench.data.aliyun.com/console).
	Stop *bool `json:"Stop,omitempty" xml:"Stop,omitempty"`
}

func (s UpdateFileRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateFileRequest) GoString() string {
	return s.String()
}

func (s *UpdateFileRequest) SetAdvancedSettings(v string) *UpdateFileRequest {
	s.AdvancedSettings = &v
	return s
}

func (s *UpdateFileRequest) SetAutoParsing(v bool) *UpdateFileRequest {
	s.AutoParsing = &v
	return s
}

func (s *UpdateFileRequest) SetAutoRerunIntervalMillis(v int32) *UpdateFileRequest {
	s.AutoRerunIntervalMillis = &v
	return s
}

func (s *UpdateFileRequest) SetAutoRerunTimes(v int32) *UpdateFileRequest {
	s.AutoRerunTimes = &v
	return s
}

func (s *UpdateFileRequest) SetConnectionName(v string) *UpdateFileRequest {
	s.ConnectionName = &v
	return s
}

func (s *UpdateFileRequest) SetContent(v string) *UpdateFileRequest {
	s.Content = &v
	return s
}

func (s *UpdateFileRequest) SetCronExpress(v string) *UpdateFileRequest {
	s.CronExpress = &v
	return s
}

func (s *UpdateFileRequest) SetCycleType(v string) *UpdateFileRequest {
	s.CycleType = &v
	return s
}

func (s *UpdateFileRequest) SetDependentNodeIdList(v string) *UpdateFileRequest {
	s.DependentNodeIdList = &v
	return s
}

func (s *UpdateFileRequest) SetDependentType(v string) *UpdateFileRequest {
	s.DependentType = &v
	return s
}

func (s *UpdateFileRequest) SetEndEffectDate(v int64) *UpdateFileRequest {
	s.EndEffectDate = &v
	return s
}

func (s *UpdateFileRequest) SetFileDescription(v string) *UpdateFileRequest {
	s.FileDescription = &v
	return s
}

func (s *UpdateFileRequest) SetFileFolderPath(v string) *UpdateFileRequest {
	s.FileFolderPath = &v
	return s
}

func (s *UpdateFileRequest) SetFileId(v int64) *UpdateFileRequest {
	s.FileId = &v
	return s
}

func (s *UpdateFileRequest) SetFileName(v string) *UpdateFileRequest {
	s.FileName = &v
	return s
}

func (s *UpdateFileRequest) SetIgnoreParentSkipRunningProperty(v bool) *UpdateFileRequest {
	s.IgnoreParentSkipRunningProperty = &v
	return s
}

func (s *UpdateFileRequest) SetInputList(v string) *UpdateFileRequest {
	s.InputList = &v
	return s
}

func (s *UpdateFileRequest) SetInputParameters(v string) *UpdateFileRequest {
	s.InputParameters = &v
	return s
}

func (s *UpdateFileRequest) SetOutputList(v string) *UpdateFileRequest {
	s.OutputList = &v
	return s
}

func (s *UpdateFileRequest) SetOutputParameters(v string) *UpdateFileRequest {
	s.OutputParameters = &v
	return s
}

func (s *UpdateFileRequest) SetOwner(v string) *UpdateFileRequest {
	s.Owner = &v
	return s
}

func (s *UpdateFileRequest) SetParaValue(v string) *UpdateFileRequest {
	s.ParaValue = &v
	return s
}

func (s *UpdateFileRequest) SetProjectId(v int64) *UpdateFileRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateFileRequest) SetProjectIdentifier(v string) *UpdateFileRequest {
	s.ProjectIdentifier = &v
	return s
}

func (s *UpdateFileRequest) SetRerunMode(v string) *UpdateFileRequest {
	s.RerunMode = &v
	return s
}

func (s *UpdateFileRequest) SetResourceGroupIdentifier(v string) *UpdateFileRequest {
	s.ResourceGroupIdentifier = &v
	return s
}

func (s *UpdateFileRequest) SetSchedulerType(v string) *UpdateFileRequest {
	s.SchedulerType = &v
	return s
}

func (s *UpdateFileRequest) SetStartEffectDate(v int64) *UpdateFileRequest {
	s.StartEffectDate = &v
	return s
}

func (s *UpdateFileRequest) SetStartImmediately(v bool) *UpdateFileRequest {
	s.StartImmediately = &v
	return s
}

func (s *UpdateFileRequest) SetStop(v bool) *UpdateFileRequest {
	s.Stop = &v
	return s
}

type UpdateFileResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateFileResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateFileResponseBody) SetErrorCode(v string) *UpdateFileResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateFileResponseBody) SetErrorMessage(v string) *UpdateFileResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateFileResponseBody) SetHttpStatusCode(v int32) *UpdateFileResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateFileResponseBody) SetRequestId(v string) *UpdateFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateFileResponseBody) SetSuccess(v bool) *UpdateFileResponseBody {
	s.Success = &v
	return s
}

type UpdateFileResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateFileResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateFileResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateFileResponse) GoString() string {
	return s.String()
}

func (s *UpdateFileResponse) SetHeaders(v map[string]*string) *UpdateFileResponse {
	s.Headers = v
	return s
}

func (s *UpdateFileResponse) SetStatusCode(v int32) *UpdateFileResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateFileResponse) SetBody(v *UpdateFileResponseBody) *UpdateFileResponse {
	s.Body = v
	return s
}

type UpdateFolderRequest struct {
	// The ID of the folder. You can call the [ListFolders](~~173955~~) operation to query the ID.
	FolderId *string `json:"FolderId,omitempty" xml:"FolderId,omitempty"`
	// The name of the folder.
	FolderName *string `json:"FolderName,omitempty" xml:"FolderName,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Management page to obtain the ID. You must specify either this parameter or ProjectIdentifier to determine the DataWorks workspace to which the operation is applied.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the DataWorks workspace. You can log on to the DataWorks console and go to the Workspace Settings panel to obtain the name. You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
}

func (s UpdateFolderRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateFolderRequest) GoString() string {
	return s.String()
}

func (s *UpdateFolderRequest) SetFolderId(v string) *UpdateFolderRequest {
	s.FolderId = &v
	return s
}

func (s *UpdateFolderRequest) SetFolderName(v string) *UpdateFolderRequest {
	s.FolderName = &v
	return s
}

func (s *UpdateFolderRequest) SetProjectId(v int64) *UpdateFolderRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateFolderRequest) SetProjectIdentifier(v string) *UpdateFolderRequest {
	s.ProjectIdentifier = &v
	return s
}

type UpdateFolderResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can use the ID to troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateFolderResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateFolderResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateFolderResponseBody) SetErrorCode(v string) *UpdateFolderResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateFolderResponseBody) SetErrorMessage(v string) *UpdateFolderResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateFolderResponseBody) SetHttpStatusCode(v int32) *UpdateFolderResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateFolderResponseBody) SetRequestId(v string) *UpdateFolderResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateFolderResponseBody) SetSuccess(v bool) *UpdateFolderResponseBody {
	s.Success = &v
	return s
}

type UpdateFolderResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateFolderResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateFolderResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateFolderResponse) GoString() string {
	return s.String()
}

func (s *UpdateFolderResponse) SetHeaders(v map[string]*string) *UpdateFolderResponse {
	s.Headers = v
	return s
}

func (s *UpdateFolderResponse) SetStatusCode(v int32) *UpdateFolderResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateFolderResponse) SetBody(v *UpdateFolderResponseBody) *UpdateFolderResponse {
	s.Body = v
	return s
}

type UpdateIDEEventResultRequest struct {
	// The summary information of the check result. The information is displayed in DataStudio. If an alert is reported or the event fails the check, you can troubleshoot errors based on the information.
	CheckResult *string `json:"CheckResult,omitempty" xml:"CheckResult,omitempty"`
	// The ID of the request. You can troubleshoot errors based on the ID.
	CheckResultTip *string `json:"CheckResultTip,omitempty" xml:"CheckResultTip,omitempty"`
	// The check status of the extension point event. Valid values:
	//
	// *   OK: The event passes the check.
	// *   FAIL: The event fails to pass the check. You must check and handle the reported error at the earliest opportunity to ensure that your program is run as expected.
	// *   WARN: The event passes the check, but an alert is reported.
	ExtensionCode *string `json:"ExtensionCode,omitempty" xml:"ExtensionCode,omitempty"`
	// The ID of the extension. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Extensions tab of the Open Platform page to view the ID.
	MessageId *string `json:"MessageId,omitempty" xml:"MessageId,omitempty"`
}

func (s UpdateIDEEventResultRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateIDEEventResultRequest) GoString() string {
	return s.String()
}

func (s *UpdateIDEEventResultRequest) SetCheckResult(v string) *UpdateIDEEventResultRequest {
	s.CheckResult = &v
	return s
}

func (s *UpdateIDEEventResultRequest) SetCheckResultTip(v string) *UpdateIDEEventResultRequest {
	s.CheckResultTip = &v
	return s
}

func (s *UpdateIDEEventResultRequest) SetExtensionCode(v string) *UpdateIDEEventResultRequest {
	s.ExtensionCode = &v
	return s
}

func (s *UpdateIDEEventResultRequest) SetMessageId(v string) *UpdateIDEEventResultRequest {
	s.MessageId = &v
	return s
}

type UpdateIDEEventResultResponseBody struct {
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s UpdateIDEEventResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateIDEEventResultResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateIDEEventResultResponseBody) SetRequestId(v string) *UpdateIDEEventResultResponseBody {
	s.RequestId = &v
	return s
}

type UpdateIDEEventResultResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateIDEEventResultResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateIDEEventResultResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateIDEEventResultResponse) GoString() string {
	return s.String()
}

func (s *UpdateIDEEventResultResponse) SetHeaders(v map[string]*string) *UpdateIDEEventResultResponse {
	s.Headers = v
	return s
}

func (s *UpdateIDEEventResultResponse) SetStatusCode(v int32) *UpdateIDEEventResultResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateIDEEventResultResponse) SetBody(v *UpdateIDEEventResultResponseBody) *UpdateIDEEventResultResponse {
	s.Body = v
	return s
}

type UpdateMetaCategoryRequest struct {
	// The ID of the category.
	CategoryId *int64 `json:"CategoryId,omitempty" xml:"CategoryId,omitempty"`
	// The remarks of the category.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The name of the category.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s UpdateMetaCategoryRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetaCategoryRequest) GoString() string {
	return s.String()
}

func (s *UpdateMetaCategoryRequest) SetCategoryId(v int64) *UpdateMetaCategoryRequest {
	s.CategoryId = &v
	return s
}

func (s *UpdateMetaCategoryRequest) SetComment(v string) *UpdateMetaCategoryRequest {
	s.Comment = &v
	return s
}

func (s *UpdateMetaCategoryRequest) SetName(v string) *UpdateMetaCategoryRequest {
	s.Name = &v
	return s
}

type UpdateMetaCategoryResponseBody struct {
	// Indicates whether the category was updated.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateMetaCategoryResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetaCategoryResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateMetaCategoryResponseBody) SetData(v bool) *UpdateMetaCategoryResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateMetaCategoryResponseBody) SetErrorCode(v string) *UpdateMetaCategoryResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateMetaCategoryResponseBody) SetErrorMessage(v string) *UpdateMetaCategoryResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateMetaCategoryResponseBody) SetHttpStatusCode(v int32) *UpdateMetaCategoryResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateMetaCategoryResponseBody) SetRequestId(v string) *UpdateMetaCategoryResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateMetaCategoryResponseBody) SetSuccess(v bool) *UpdateMetaCategoryResponseBody {
	s.Success = &v
	return s
}

type UpdateMetaCategoryResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateMetaCategoryResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateMetaCategoryResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetaCategoryResponse) GoString() string {
	return s.String()
}

func (s *UpdateMetaCategoryResponse) SetHeaders(v map[string]*string) *UpdateMetaCategoryResponse {
	s.Headers = v
	return s
}

func (s *UpdateMetaCategoryResponse) SetStatusCode(v int32) *UpdateMetaCategoryResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateMetaCategoryResponse) SetBody(v *UpdateMetaCategoryResponseBody) *UpdateMetaCategoryResponse {
	s.Body = v
	return s
}

type UpdateMetaCollectionRequest struct {
	// The ID of the request. You can use the ID to query logs and troubleshoot issues.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The comment of the collection.
	//
	// The comment must be 1 to 64 characters in length.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The name of the collection.
	QualifiedName *string `json:"QualifiedName,omitempty" xml:"QualifiedName,omitempty"`
}

func (s UpdateMetaCollectionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetaCollectionRequest) GoString() string {
	return s.String()
}

func (s *UpdateMetaCollectionRequest) SetComment(v string) *UpdateMetaCollectionRequest {
	s.Comment = &v
	return s
}

func (s *UpdateMetaCollectionRequest) SetName(v string) *UpdateMetaCollectionRequest {
	s.Name = &v
	return s
}

func (s *UpdateMetaCollectionRequest) SetQualifiedName(v string) *UpdateMetaCollectionRequest {
	s.QualifiedName = &v
	return s
}

type UpdateMetaCollectionResponseBody struct {
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error code returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The error message returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The result of the operation. Valid values:
	//
	// true: succeeded
	//
	// false: failed
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The HTTP status code returned.
	Status  *bool `json:"Status,omitempty" xml:"Status,omitempty"`
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateMetaCollectionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetaCollectionResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateMetaCollectionResponseBody) SetErrorCode(v string) *UpdateMetaCollectionResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateMetaCollectionResponseBody) SetErrorMessage(v string) *UpdateMetaCollectionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateMetaCollectionResponseBody) SetHttpStatusCode(v int32) *UpdateMetaCollectionResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateMetaCollectionResponseBody) SetRequestId(v string) *UpdateMetaCollectionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateMetaCollectionResponseBody) SetStatus(v bool) *UpdateMetaCollectionResponseBody {
	s.Status = &v
	return s
}

func (s *UpdateMetaCollectionResponseBody) SetSuccess(v bool) *UpdateMetaCollectionResponseBody {
	s.Success = &v
	return s
}

type UpdateMetaCollectionResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateMetaCollectionResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateMetaCollectionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetaCollectionResponse) GoString() string {
	return s.String()
}

func (s *UpdateMetaCollectionResponse) SetHeaders(v map[string]*string) *UpdateMetaCollectionResponse {
	s.Headers = v
	return s
}

func (s *UpdateMetaCollectionResponse) SetStatusCode(v int32) *UpdateMetaCollectionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateMetaCollectionResponse) SetBody(v *UpdateMetaCollectionResponseBody) *UpdateMetaCollectionResponse {
	s.Body = v
	return s
}

type UpdateMetaTableRequest struct {
	// The names of the labels that you want to add. Separate the labels with commas (,).
	AddedLabels *string `json:"AddedLabels,omitempty" xml:"AddedLabels,omitempty"`
	// The display name of the table.
	Caption *string `json:"Caption,omitempty" xml:"Caption,omitempty"`
	// The ID of the category that you want to associate.
	CategoryId *int64 `json:"CategoryId,omitempty" xml:"CategoryId,omitempty"`
	// The environment of the DataWorks workspace. Valid values: 0 and 1. The value 0 indicates the development environment. The value 1 indicates the production environment.
	EnvType *int32 `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The ID of the new owner. If this parameter is not specified, the owner ID is not updated.
	NewOwnerId *string `json:"NewOwnerId,omitempty" xml:"NewOwnerId,omitempty"`
	// The ID of the DataWorks workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The names of labels that you want to delete. Separate the labels with commas (,).
	RemovedLabels *string `json:"RemovedLabels,omitempty" xml:"RemovedLabels,omitempty"`
	// The schema information of the table. You need to configure this parameter if you enable the table schema in MaxCompute.
	Schema *string `json:"Schema,omitempty" xml:"Schema,omitempty"`
	// The globally unique identifier (GUID) of the table. Specify the GUID in the format of odps.{projectName}.{tableName}.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
	// The name of the table.
	TableName *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
	// The scope in which the table is visible. Valid values: 0, 1, and 2. The value 0 indicates that the table is invisible to all workspace members. The value 1 indicates that the table is visible to all workspace members. The value 2 indicates that the table is visible to workspace members.
	Visibility *int32 `json:"Visibility,omitempty" xml:"Visibility,omitempty"`
}

func (s UpdateMetaTableRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetaTableRequest) GoString() string {
	return s.String()
}

func (s *UpdateMetaTableRequest) SetAddedLabels(v string) *UpdateMetaTableRequest {
	s.AddedLabels = &v
	return s
}

func (s *UpdateMetaTableRequest) SetCaption(v string) *UpdateMetaTableRequest {
	s.Caption = &v
	return s
}

func (s *UpdateMetaTableRequest) SetCategoryId(v int64) *UpdateMetaTableRequest {
	s.CategoryId = &v
	return s
}

func (s *UpdateMetaTableRequest) SetEnvType(v int32) *UpdateMetaTableRequest {
	s.EnvType = &v
	return s
}

func (s *UpdateMetaTableRequest) SetNewOwnerId(v string) *UpdateMetaTableRequest {
	s.NewOwnerId = &v
	return s
}

func (s *UpdateMetaTableRequest) SetProjectId(v int64) *UpdateMetaTableRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateMetaTableRequest) SetRemovedLabels(v string) *UpdateMetaTableRequest {
	s.RemovedLabels = &v
	return s
}

func (s *UpdateMetaTableRequest) SetSchema(v string) *UpdateMetaTableRequest {
	s.Schema = &v
	return s
}

func (s *UpdateMetaTableRequest) SetTableGuid(v string) *UpdateMetaTableRequest {
	s.TableGuid = &v
	return s
}

func (s *UpdateMetaTableRequest) SetTableName(v string) *UpdateMetaTableRequest {
	s.TableName = &v
	return s
}

func (s *UpdateMetaTableRequest) SetVisibility(v int32) *UpdateMetaTableRequest {
	s.Visibility = &v
	return s
}

type UpdateMetaTableResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the metadata information about the table is updated.
	UpdateResult *bool `json:"UpdateResult,omitempty" xml:"UpdateResult,omitempty"`
}

func (s UpdateMetaTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetaTableResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateMetaTableResponseBody) SetRequestId(v string) *UpdateMetaTableResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateMetaTableResponseBody) SetUpdateResult(v bool) *UpdateMetaTableResponseBody {
	s.UpdateResult = &v
	return s
}

type UpdateMetaTableResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateMetaTableResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateMetaTableResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetaTableResponse) GoString() string {
	return s.String()
}

func (s *UpdateMetaTableResponse) SetHeaders(v map[string]*string) *UpdateMetaTableResponse {
	s.Headers = v
	return s
}

func (s *UpdateMetaTableResponse) SetStatusCode(v int32) *UpdateMetaTableResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateMetaTableResponse) SetBody(v *UpdateMetaTableResponseBody) *UpdateMetaTableResponse {
	s.Body = v
	return s
}

type UpdateMetaTableIntroWikiRequest struct {
	// The details of the instructions on how to use the metatable.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The GUID of the metatable. Specify the GUID in the format of odps.{projectName}.{tableName}.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
}

func (s UpdateMetaTableIntroWikiRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetaTableIntroWikiRequest) GoString() string {
	return s.String()
}

func (s *UpdateMetaTableIntroWikiRequest) SetContent(v string) *UpdateMetaTableIntroWikiRequest {
	s.Content = &v
	return s
}

func (s *UpdateMetaTableIntroWikiRequest) SetTableGuid(v string) *UpdateMetaTableIntroWikiRequest {
	s.TableGuid = &v
	return s
}

type UpdateMetaTableIntroWikiResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The updated instructions.
	UpdateResult *bool `json:"UpdateResult,omitempty" xml:"UpdateResult,omitempty"`
}

func (s UpdateMetaTableIntroWikiResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetaTableIntroWikiResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateMetaTableIntroWikiResponseBody) SetRequestId(v string) *UpdateMetaTableIntroWikiResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateMetaTableIntroWikiResponseBody) SetUpdateResult(v bool) *UpdateMetaTableIntroWikiResponseBody {
	s.UpdateResult = &v
	return s
}

type UpdateMetaTableIntroWikiResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateMetaTableIntroWikiResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateMetaTableIntroWikiResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateMetaTableIntroWikiResponse) GoString() string {
	return s.String()
}

func (s *UpdateMetaTableIntroWikiResponse) SetHeaders(v map[string]*string) *UpdateMetaTableIntroWikiResponse {
	s.Headers = v
	return s
}

func (s *UpdateMetaTableIntroWikiResponse) SetStatusCode(v int32) *UpdateMetaTableIntroWikiResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateMetaTableIntroWikiResponse) SetBody(v *UpdateMetaTableIntroWikiResponseBody) *UpdateMetaTableIntroWikiResponse {
	s.Body = v
	return s
}

type UpdateNodeOwnerRequest struct {
	// The ID of the node. You can call the [ListNodes](~~173979~~) operation to query the ID.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The environment where the node runs. Valid values: DEV and PROD. The value DEV indicates the development environment. The value PROD indicates the production environment.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
	// The Alibaba Cloud account ID of the node owner. You can log on to the DataWorks console and move the pointer over the profile picture in the upper-right corner to view the ID.
	UserId *string `json:"UserId,omitempty" xml:"UserId,omitempty"`
}

func (s UpdateNodeOwnerRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateNodeOwnerRequest) GoString() string {
	return s.String()
}

func (s *UpdateNodeOwnerRequest) SetNodeId(v int64) *UpdateNodeOwnerRequest {
	s.NodeId = &v
	return s
}

func (s *UpdateNodeOwnerRequest) SetProjectEnv(v string) *UpdateNodeOwnerRequest {
	s.ProjectEnv = &v
	return s
}

func (s *UpdateNodeOwnerRequest) SetUserId(v string) *UpdateNodeOwnerRequest {
	s.UserId = &v
	return s
}

type UpdateNodeOwnerResponseBody struct {
	// The ID of the request. You can use the ID to obtain logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: indicates that the request is successful.
	// *   false: indicates that the request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateNodeOwnerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateNodeOwnerResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateNodeOwnerResponseBody) SetRequestId(v string) *UpdateNodeOwnerResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateNodeOwnerResponseBody) SetSuccess(v bool) *UpdateNodeOwnerResponseBody {
	s.Success = &v
	return s
}

type UpdateNodeOwnerResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateNodeOwnerResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateNodeOwnerResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateNodeOwnerResponse) GoString() string {
	return s.String()
}

func (s *UpdateNodeOwnerResponse) SetHeaders(v map[string]*string) *UpdateNodeOwnerResponse {
	s.Headers = v
	return s
}

func (s *UpdateNodeOwnerResponse) SetStatusCode(v int32) *UpdateNodeOwnerResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateNodeOwnerResponse) SetBody(v *UpdateNodeOwnerResponseBody) *UpdateNodeOwnerResponse {
	s.Body = v
	return s
}

type UpdateNodeRunModeRequest struct {
	// The ID of the node. You can call the [ListNodes](~~173979~~) operation to query the ID.
	NodeId *int64 `json:"NodeId,omitempty" xml:"NodeId,omitempty"`
	// The environment where the node runs. Valid values: DEV and PROD. The value DEV indicates the development environment. The value PROD indicates the production environment.
	ProjectEnv *string `json:"ProjectEnv,omitempty" xml:"ProjectEnv,omitempty"`
	// The operation that you want to perform on the node. Valid values:
	//
	// *   0: indicates that you want to unfreeze the node.
	// *   2: indicates that you want to freeze the node.
	SchedulerType *int32 `json:"SchedulerType,omitempty" xml:"SchedulerType,omitempty"`
}

func (s UpdateNodeRunModeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateNodeRunModeRequest) GoString() string {
	return s.String()
}

func (s *UpdateNodeRunModeRequest) SetNodeId(v int64) *UpdateNodeRunModeRequest {
	s.NodeId = &v
	return s
}

func (s *UpdateNodeRunModeRequest) SetProjectEnv(v string) *UpdateNodeRunModeRequest {
	s.ProjectEnv = &v
	return s
}

func (s *UpdateNodeRunModeRequest) SetSchedulerType(v int32) *UpdateNodeRunModeRequest {
	s.SchedulerType = &v
	return s
}

type UpdateNodeRunModeResponseBody struct {
	// The ID of the request. You can use the ID to obtain logs and troubleshoot issues.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: indicates that the request is successful.
	// *   false: indicates that the request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateNodeRunModeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateNodeRunModeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateNodeRunModeResponseBody) SetRequestId(v string) *UpdateNodeRunModeResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateNodeRunModeResponseBody) SetSuccess(v bool) *UpdateNodeRunModeResponseBody {
	s.Success = &v
	return s
}

type UpdateNodeRunModeResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateNodeRunModeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateNodeRunModeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateNodeRunModeResponse) GoString() string {
	return s.String()
}

func (s *UpdateNodeRunModeResponse) SetHeaders(v map[string]*string) *UpdateNodeRunModeResponse {
	s.Headers = v
	return s
}

func (s *UpdateNodeRunModeResponse) SetStatusCode(v int32) *UpdateNodeRunModeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateNodeRunModeResponse) SetBody(v *UpdateNodeRunModeResponseBody) *UpdateNodeRunModeResponse {
	s.Body = v
	return s
}

type UpdateQualityFollowerRequest struct {
	// The notification method. Valid values: 1, 2, 4, and 5. 1 indicates that the notification is sent by email. 2 indicates that the notification is sent by email and text message. 4 indicates that the notification is sent by a DingTalk chatbot. 5 indicates that the notification is sent by a DingTalk chatbot to all members in a DingTalk group.
	AlarmMode *int32 `json:"AlarmMode,omitempty" xml:"AlarmMode,omitempty"`
	// The name of the subscriber.
	Follower *string `json:"Follower,omitempty" xml:"Follower,omitempty"`
	// The ID of the subscription relationship.
	FollowerId *int64 `json:"FollowerId,omitempty" xml:"FollowerId,omitempty"`
	ProjectId  *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the computing engine instance or data source.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
}

func (s UpdateQualityFollowerRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateQualityFollowerRequest) GoString() string {
	return s.String()
}

func (s *UpdateQualityFollowerRequest) SetAlarmMode(v int32) *UpdateQualityFollowerRequest {
	s.AlarmMode = &v
	return s
}

func (s *UpdateQualityFollowerRequest) SetFollower(v string) *UpdateQualityFollowerRequest {
	s.Follower = &v
	return s
}

func (s *UpdateQualityFollowerRequest) SetFollowerId(v int64) *UpdateQualityFollowerRequest {
	s.FollowerId = &v
	return s
}

func (s *UpdateQualityFollowerRequest) SetProjectId(v int64) *UpdateQualityFollowerRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateQualityFollowerRequest) SetProjectName(v string) *UpdateQualityFollowerRequest {
	s.ProjectName = &v
	return s
}

type UpdateQualityFollowerResponseBody struct {
	// Indicates whether the subscription relationship is updated.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateQualityFollowerResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateQualityFollowerResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateQualityFollowerResponseBody) SetData(v bool) *UpdateQualityFollowerResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateQualityFollowerResponseBody) SetErrorCode(v string) *UpdateQualityFollowerResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateQualityFollowerResponseBody) SetErrorMessage(v string) *UpdateQualityFollowerResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateQualityFollowerResponseBody) SetHttpStatusCode(v int32) *UpdateQualityFollowerResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateQualityFollowerResponseBody) SetRequestId(v string) *UpdateQualityFollowerResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateQualityFollowerResponseBody) SetSuccess(v bool) *UpdateQualityFollowerResponseBody {
	s.Success = &v
	return s
}

type UpdateQualityFollowerResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateQualityFollowerResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateQualityFollowerResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateQualityFollowerResponse) GoString() string {
	return s.String()
}

func (s *UpdateQualityFollowerResponse) SetHeaders(v map[string]*string) *UpdateQualityFollowerResponse {
	s.Headers = v
	return s
}

func (s *UpdateQualityFollowerResponse) SetStatusCode(v int32) *UpdateQualityFollowerResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateQualityFollowerResponse) SetBody(v *UpdateQualityFollowerResponseBody) *UpdateQualityFollowerResponse {
	s.Body = v
	return s
}

type UpdateQualityRuleRequest struct {
	// The strength of the monitoring rule. The strength of a monitoring rule indicates the importance of the rule. Valid values:
	//
	// *   1: indicates that the monitoring rule is a strong rule.
	//
	// *   0: indicates that the monitoring rule is a weak rule.
	//
	//     You can specify whether a monitoring rule is a strong rule based on your business requirements. If a strong rule is used and a critical alert is triggered, nodes are blocked.
	BlockType *int32 `json:"BlockType,omitempty" xml:"BlockType,omitempty"`
	// The ID of the checker. You can call the [ListQualityRules](~~173995~~) operation to obtain the ID of the checker.
	Checker *int32 `json:"Checker,omitempty" xml:"Checker,omitempty"`
	// The description of the monitoring rule.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The threshold for a critical alert. The threshold indicates the deviation of the monitoring result from the expected value. You can customize this threshold based on your business requirements. If a strong rule is used and an error alert is triggered, nodes are blocked.
	CriticalThreshold *string `json:"CriticalThreshold,omitempty" xml:"CriticalThreshold,omitempty"`
	// The ID of the partition filter expression. You can call the [GetQualityEntity](~~173995~~) operation to obtain the ID of the partition filter expression.
	EntityId *int64 `json:"EntityId,omitempty" xml:"EntityId,omitempty"`
	// The expected value of the monitoring result.
	ExpectValue *string `json:"ExpectValue,omitempty" xml:"ExpectValue,omitempty"`
	// The ID of the monitoring rule. You can call the [ListQualityRules](~~173995~~) operation to obtain the ID of the monitoring rule.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The method that is used to collect sample data, such as avg, count, sum, min, max, count_distinct, user_defined, table_count, table_size, table_dt_load_count, table_dt_refuseload_count, null_value, null_value/table_count, (table_count-count_distinct)/table_count, or table_count-count_distinct.
	MethodName *string `json:"MethodName,omitempty" xml:"MethodName,omitempty"`
	// Specifies whether to enable the monitoring rule in the production environment.
	//
	// *   true: The monitoring rule is triggered when the associated auto triggered node that generates the output data starts to run.
	// *   false: The monitoring rule is not triggered when the associated auto triggered node that generates the output data starts to run.
	OpenSwitch *bool `json:"OpenSwitch,omitempty" xml:"OpenSwitch,omitempty"`
	// The comparison operator, such as >, >=, =, ≠, <, or <=.
	Operator *string `json:"Operator,omitempty" xml:"Operator,omitempty"`
	// Specifies whether the threshold is a dynamic threshold. Valid values:
	//
	// *   0: indicates that the threshold is not a dynamic threshold.
	// *   2: indicates that the threshold is a dynamic threshold.
	PredictType *int32 `json:"PredictType,omitempty" xml:"PredictType,omitempty"`
	ProjectId   *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The name of the compute engine instance or data source. You can log on to the [DataWorks console](https://workbench.data.aliyun.com/console) and go to the Workspace Management page to obtain the name.
	ProjectName *string `json:"ProjectName,omitempty" xml:"ProjectName,omitempty"`
	// The name of the field to be monitored.
	Property *string `json:"Property,omitempty" xml:"Property,omitempty"`
	// The data type of the field.
	PropertyType *string `json:"PropertyType,omitempty" xml:"PropertyType,omitempty"`
	// The name of the monitoring rule.
	RuleName *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	// The type of the monitoring rule. Valid values:
	//
	// *   0: The monitoring rule is created by the system.
	// *   1: The monitoring rule is created by a user.
	// *   2: The monitoring rule is a workspace-level rule.
	RuleType    *int32  `json:"RuleType,omitempty" xml:"RuleType,omitempty"`
	TaskSetting *string `json:"TaskSetting,omitempty" xml:"TaskSetting,omitempty"`
	// The ID of the monitoring template. You can call the [ListQualityRules](~~173995~~) operation to obtain the ID of the monitoring template that is used to create the monitoring rule.
	TemplateId *int32 `json:"TemplateId,omitempty" xml:"TemplateId,omitempty"`
	// The trend of the monitoring result. Valid values:
	//
	// *   up: increasing
	// *   down: decreasing
	// *   abs: absolute value
	Trend *string `json:"Trend,omitempty" xml:"Trend,omitempty"`
	// The threshold for a warning alert. The threshold indicates the deviation of the monitoring result from the expected value. You can customize this threshold based on your business requirements.
	WarningThreshold *string `json:"WarningThreshold,omitempty" xml:"WarningThreshold,omitempty"`
	// The filter condition or custom SQL statement that is used for monitoring.
	WhereCondition *string `json:"WhereCondition,omitempty" xml:"WhereCondition,omitempty"`
}

func (s UpdateQualityRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateQualityRuleRequest) GoString() string {
	return s.String()
}

func (s *UpdateQualityRuleRequest) SetBlockType(v int32) *UpdateQualityRuleRequest {
	s.BlockType = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetChecker(v int32) *UpdateQualityRuleRequest {
	s.Checker = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetComment(v string) *UpdateQualityRuleRequest {
	s.Comment = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetCriticalThreshold(v string) *UpdateQualityRuleRequest {
	s.CriticalThreshold = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetEntityId(v int64) *UpdateQualityRuleRequest {
	s.EntityId = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetExpectValue(v string) *UpdateQualityRuleRequest {
	s.ExpectValue = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetId(v int64) *UpdateQualityRuleRequest {
	s.Id = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetMethodName(v string) *UpdateQualityRuleRequest {
	s.MethodName = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetOpenSwitch(v bool) *UpdateQualityRuleRequest {
	s.OpenSwitch = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetOperator(v string) *UpdateQualityRuleRequest {
	s.Operator = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetPredictType(v int32) *UpdateQualityRuleRequest {
	s.PredictType = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetProjectId(v int64) *UpdateQualityRuleRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetProjectName(v string) *UpdateQualityRuleRequest {
	s.ProjectName = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetProperty(v string) *UpdateQualityRuleRequest {
	s.Property = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetPropertyType(v string) *UpdateQualityRuleRequest {
	s.PropertyType = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetRuleName(v string) *UpdateQualityRuleRequest {
	s.RuleName = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetRuleType(v int32) *UpdateQualityRuleRequest {
	s.RuleType = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetTaskSetting(v string) *UpdateQualityRuleRequest {
	s.TaskSetting = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetTemplateId(v int32) *UpdateQualityRuleRequest {
	s.TemplateId = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetTrend(v string) *UpdateQualityRuleRequest {
	s.Trend = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetWarningThreshold(v string) *UpdateQualityRuleRequest {
	s.WarningThreshold = &v
	return s
}

func (s *UpdateQualityRuleRequest) SetWhereCondition(v string) *UpdateQualityRuleRequest {
	s.WhereCondition = &v
	return s
}

type UpdateQualityRuleResponseBody struct {
	// Indicates whether the monitoring rule is updated.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateQualityRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateQualityRuleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateQualityRuleResponseBody) SetData(v bool) *UpdateQualityRuleResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateQualityRuleResponseBody) SetErrorCode(v string) *UpdateQualityRuleResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateQualityRuleResponseBody) SetErrorMessage(v string) *UpdateQualityRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateQualityRuleResponseBody) SetHttpStatusCode(v int32) *UpdateQualityRuleResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateQualityRuleResponseBody) SetRequestId(v string) *UpdateQualityRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateQualityRuleResponseBody) SetSuccess(v bool) *UpdateQualityRuleResponseBody {
	s.Success = &v
	return s
}

type UpdateQualityRuleResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateQualityRuleResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateQualityRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateQualityRuleResponse) GoString() string {
	return s.String()
}

func (s *UpdateQualityRuleResponse) SetHeaders(v map[string]*string) *UpdateQualityRuleResponse {
	s.Headers = v
	return s
}

func (s *UpdateQualityRuleResponse) SetStatusCode(v int32) *UpdateQualityRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateQualityRuleResponse) SetBody(v *UpdateQualityRuleResponseBody) *UpdateQualityRuleResponse {
	s.Body = v
	return s
}

type UpdateRemindRequest struct {
	// The recipient to whom alert notifications are sent. Valid values: OWNER and OTHER. The value OWNER indicates that alert notifications are sent to the object owner. The value OTHER indicates that alert notifications are sent to a specified user.
	AlertInterval *int32 `json:"AlertInterval,omitempty" xml:"AlertInterval,omitempty"`
	// Specifies whether to enable the alert rule. Valid values:
	//
	// *   true: enables the alert rule.
	// *   false: disables the alert rule.
	AlertMethods *string `json:"AlertMethods,omitempty" xml:"AlertMethods,omitempty"`
	// The webhook URL of the DingTalk chatbot. You can specify multiple webhook URLs. Separate them with commas (,).
	//
	// If this parameter is set to undefined, the specified webhook URLs are cleared.
	AlertTargets *string `json:"AlertTargets,omitempty" xml:"AlertTargets,omitempty"`
	// The value format required by this parameter varies based on the value that you specify for the AlertUnit parameter. Take note of the following items:
	//
	// *   If the AlertUnit parameter is set to OWNER, leave this parameter empty.
	// *   If the AlertUnit parameter is set to OTHER, set this parameter to the unique ID (UID) of the specified user. You can specify multiple IDs. Separate them with commas (,). You can specify a maximum of 10 IDs.
	AlertUnit *string `json:"AlertUnit,omitempty" xml:"AlertUnit,omitempty"`
	// The ID of the workflow to which the custom alert rule is applied.. An alert rule can monitor a maximum of five workflows. Separate multiple IDs with commas (,).
	//
	// This parameter takes effect when you set the RemindUnit parameter to BIZPROCESS.
	BaselineIds *string `json:"BaselineIds,omitempty" xml:"BaselineIds,omitempty"`
	// The maximum number of alerts. Valid values: 1 to 10. Default value: 3.
	BizProcessIds *string `json:"BizProcessIds,omitempty" xml:"BizProcessIds,omitempty"`
	// The notification method. Valid values:
	//
	// *   MAIL: Alert notifications are sent by emails.
	// *   SMS: Alert notifications are sent by text messages.
	// *   PHONE: Alert notifications are sent by phone calls. You can use this notification method only in DataWorks Professional Edition or more advanced editions.
	// *   DINGROBOTS: Alert notifications are sent by DingTalk messages. You can use this notification method only if the RobotUrls parameter is configured.
	// *   WEBHOOKS (WeCom or Lark chatbot): Alert notifications are sent by WeCom or Lark messages. If you want to use this notification method, you must configure the Webhooks parameter.
	//
	// You can specify multiple notification methods. Separate the specified notification methods with commas (,).
	Detail *string `json:"Detail,omitempty" xml:"Detail,omitempty"`
	// The ID of the node to which the custom alert rule is applied.. An alert rule can monitor a maximum of 50 nodes. Separate multiple IDs with commas (,).
	//
	// This parameter takes effect when you set the RemindUnit parameter to NODE.
	DndEnd *string `json:"DndEnd,omitempty" xml:"DndEnd,omitempty"`
	// The details of the conditions that trigger an alert.
	//
	// *   If the RemindType parameter is set to FINISHED, leave this parameter empty.
	//
	// *   If the RemindType parameter is set to UNFINISHED, set this parameter to key-value pairs. Example: {"hour":23,"minu":59}. Valid values of hour: 0 to 47. Valid values of minu: 0 to 59.
	//
	// *   If the RemindType parameter is set to ERROR, leave this parameter empty.
	//
	// *   If the RemindType parameter is set to CYCLE_UNFINISHED, set this parameter to key-value pairs in the JSON format. Example: {"1":"05:50","2":"06:50","3":"07:50","4":"08:50","5":"09:50","6":"10:50","7":"11:50","8":"12:50","9":"13:50","10":"14:50","11":"15:50","12":"16:50","13":"17:50","14":"18:50","15":"19:50","16":"20:50","17":"21:50","18":"22:50","19":"23:50","20":"24:50","21":"25:50"}.
	//
	//     A key in the JSON string indicates the sequence number of a cycle. Valid values of keys: 1 to 288. A value in the JSON string indicates the time in point when a monitored instance times out in the relevant cycle. Values must be in the format of hh:mm. Valid values of hh: 0 to 47. Valid values of mm: 0 to 59.
	//
	// *   If the RemindType parameter is set to TIMEOUT, set this parameter to the timeout period. Unit: seconds. Example: 1800. This indicates that an alert notification is sent if the duration of a monitored instance exceeds 30 minutes.
	MaxAlertTimes *int32 `json:"MaxAlertTimes,omitempty" xml:"MaxAlertTimes,omitempty"`
	// The ID of the workspace to which the custom alert rule is applied.. Only one workspace can be specified for a custom alert rule.
	//
	// This parameter takes effect when you set the RemindUnit parameter to PROJECT.
	NodeIds *string `json:"NodeIds,omitempty" xml:"NodeIds,omitempty"`
	// The condition that triggers the alert rule. Valid values:
	//
	// *   FINISHED: The system monitors an instance when it starts to run and sends an alert notification after the running of the instance is complete.
	// *   UNFINISHED: The system monitors an instance when it starts to run and sends an alert notification if the instance is still running at the specified point in time.
	// *   ERROR: The system monitors an instance when it starts to run and sends an alert notification if an error occurs.
	// *   CYCLE_UNFINISHED: The system sends an alert notification if a monitored instance is still running at the end of the specified cycle. In most cases, you can configure this trigger condition for node instances that are scheduled to run by hour.
	// *   TIMEOUT: The system monitors an instance when it starts to run and sends an alert notification if the instance is still running after the specified period ends. In most cases, you can configure this trigger condition to monitor the duration of node instances.
	//
	// For more information, see [Manage custom alert rules](~~138172~~).
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The end of the period during which no alert notifications are sent. Specify the time in the hh:mm format. Valid values of hh: 0 to 23. Valid values of mm: 0 to 59.
	RemindId *int64 `json:"RemindId,omitempty" xml:"RemindId,omitempty"`
	// The type of the object to which the custom alert rule is applied.. Valid values:
	//
	// *   NODE: node
	// *   BASELINE: baseline
	// *   PROJECT: workspace
	// *   BIZPROCESS: workflow
	RemindName *string `json:"RemindName,omitempty" xml:"RemindName,omitempty"`
	// The intervals at which alert notifications are sent. Unit: seconds. Minimum value: 1200. Default value: 1800.
	RemindType *string `json:"RemindType,omitempty" xml:"RemindType,omitempty"`
	// The ID of the baseline to which the custom alert rule is applied.. An alert rule can monitor a maximum of five baselines. Separate multiple IDs with commas (,).
	//
	// This parameter takes effect when you set the RemindUnit parameter to BASELINE.
	RemindUnit *string `json:"RemindUnit,omitempty" xml:"RemindUnit,omitempty"`
	// The HTTP status code returned.
	RobotUrls *string `json:"RobotUrls,omitempty" xml:"RobotUrls,omitempty"`
	// The webhook URL of the WeCom or Lark chatbot. You can specify multiple webhook URLs. Separate the specified webhook URLs with commas (,). The WEBHOOKS notification method must be specified for alertMethods. If this parameter is set to undefined, the specified webhook URLs are cleared.
	//
	// Only DataWorks Enterprise Edition supports this parameter.
	//
	// The webhook URL-based alerting feature is supported in the following regions: China (Shanghai), China (Chengdu), China (Zhangjiakou), China (Beijing), China (Hangzhou), China (Shenzhen), China (Hong Kong), Germany (Frankfurt), and Singapore.
	UseFlag *bool `json:"UseFlag,omitempty" xml:"UseFlag,omitempty"`
	// Indicates whether the modification to the custom alert rule succeeds.
	Webhooks *string `json:"Webhooks,omitempty" xml:"Webhooks,omitempty"`
}

func (s UpdateRemindRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateRemindRequest) GoString() string {
	return s.String()
}

func (s *UpdateRemindRequest) SetAlertInterval(v int32) *UpdateRemindRequest {
	s.AlertInterval = &v
	return s
}

func (s *UpdateRemindRequest) SetAlertMethods(v string) *UpdateRemindRequest {
	s.AlertMethods = &v
	return s
}

func (s *UpdateRemindRequest) SetAlertTargets(v string) *UpdateRemindRequest {
	s.AlertTargets = &v
	return s
}

func (s *UpdateRemindRequest) SetAlertUnit(v string) *UpdateRemindRequest {
	s.AlertUnit = &v
	return s
}

func (s *UpdateRemindRequest) SetBaselineIds(v string) *UpdateRemindRequest {
	s.BaselineIds = &v
	return s
}

func (s *UpdateRemindRequest) SetBizProcessIds(v string) *UpdateRemindRequest {
	s.BizProcessIds = &v
	return s
}

func (s *UpdateRemindRequest) SetDetail(v string) *UpdateRemindRequest {
	s.Detail = &v
	return s
}

func (s *UpdateRemindRequest) SetDndEnd(v string) *UpdateRemindRequest {
	s.DndEnd = &v
	return s
}

func (s *UpdateRemindRequest) SetMaxAlertTimes(v int32) *UpdateRemindRequest {
	s.MaxAlertTimes = &v
	return s
}

func (s *UpdateRemindRequest) SetNodeIds(v string) *UpdateRemindRequest {
	s.NodeIds = &v
	return s
}

func (s *UpdateRemindRequest) SetProjectId(v int64) *UpdateRemindRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateRemindRequest) SetRemindId(v int64) *UpdateRemindRequest {
	s.RemindId = &v
	return s
}

func (s *UpdateRemindRequest) SetRemindName(v string) *UpdateRemindRequest {
	s.RemindName = &v
	return s
}

func (s *UpdateRemindRequest) SetRemindType(v string) *UpdateRemindRequest {
	s.RemindType = &v
	return s
}

func (s *UpdateRemindRequest) SetRemindUnit(v string) *UpdateRemindRequest {
	s.RemindUnit = &v
	return s
}

func (s *UpdateRemindRequest) SetRobotUrls(v string) *UpdateRemindRequest {
	s.RobotUrls = &v
	return s
}

func (s *UpdateRemindRequest) SetUseFlag(v bool) *UpdateRemindRequest {
	s.UseFlag = &v
	return s
}

func (s *UpdateRemindRequest) SetWebhooks(v string) *UpdateRemindRequest {
	s.Webhooks = &v
	return s
}

type UpdateRemindResponseBody struct {
	// The ID of the request. You can use the ID to troubleshoot issues.
	Data      *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   true: The request was successful.
	// *   false: The request failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The error message returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The error code returned.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateRemindResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateRemindResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateRemindResponseBody) SetData(v bool) *UpdateRemindResponseBody {
	s.Data = &v
	return s
}

func (s *UpdateRemindResponseBody) SetErrorCode(v string) *UpdateRemindResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateRemindResponseBody) SetErrorMessage(v string) *UpdateRemindResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateRemindResponseBody) SetHttpStatusCode(v int32) *UpdateRemindResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateRemindResponseBody) SetRequestId(v string) *UpdateRemindResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateRemindResponseBody) SetSuccess(v bool) *UpdateRemindResponseBody {
	s.Success = &v
	return s
}

type UpdateRemindResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateRemindResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateRemindResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateRemindResponse) GoString() string {
	return s.String()
}

func (s *UpdateRemindResponse) SetHeaders(v map[string]*string) *UpdateRemindResponse {
	s.Headers = v
	return s
}

func (s *UpdateRemindResponse) SetStatusCode(v int32) *UpdateRemindResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateRemindResponse) SetBody(v *UpdateRemindResponseBody) *UpdateRemindResponse {
	s.Body = v
	return s
}

type UpdateTableRequest struct {
	// Specifies whether the table exists. Valid values:
	//
	// *   true: The table exists.
	// *   false: The table does not exist.
	//
	// This parameter is deprecated. Do not use this parameter.
	AppGuid *string `json:"AppGuid,omitempty" xml:"AppGuid,omitempty"`
	// The ID of the logical level.
	CategoryId *int64                       `json:"CategoryId,omitempty" xml:"CategoryId,omitempty"`
	Columns    []*UpdateTableRequestColumns `json:"Columns,omitempty" xml:"Columns,omitempty" type:"Repeated"`
	// The schema information of the table. You need to enter the schema information of the table if you enable the table schema in MaxCompute.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// Specifies whether the table that you want to update is a partitioned table. Valid values: 0 and 1. The value 0 indicates that the table is not a partitioned table. The value 1 indicates that the table is a partitioned table. This parameter is deprecated. Do not use this parameter.
	//
	// The Column.N.isPartitionCol parameter is used instead of the HasPart parameter to specify whether the MaxCompute table is a partitioned table. If the Column.N.isPartitionCol parameter is set to 1, the MaxCompute table is a partitioned table.
	CreateIfNotExists *bool `json:"CreateIfNotExists,omitempty" xml:"CreateIfNotExists,omitempty"`
	// The environment of the DataWorks workspace. Valid values: 0 and 1. The value 0 indicates the development environment. The value 1 indicates the production environment.
	Endpoint *string `json:"Endpoint,omitempty" xml:"Endpoint,omitempty"`
	// The globally unique identifier (GUID) of the MaxCompute project. Specify the GUID in the odps.{projectName} format.
	EnvType *int32 `json:"EnvType,omitempty" xml:"EnvType,omitempty"`
	// The storage location of the external table. This parameter is deprecated. Do not use this parameter.
	ExternalTableType *string `json:"ExternalTableType,omitempty" xml:"ExternalTableType,omitempty"`
	// The comment.
	HasPart *int32 `json:"HasPart,omitempty" xml:"HasPart,omitempty"`
	// The scope in which the table is visible. Valid values: 0, 1, and 2. The value 0 indicates that the table is invisible to all workspace members. The value 1 indicates that the table is visible to all workspace members. The value 2 indicates that the table is visible to workspace members.
	IsView *int32 `json:"IsView,omitempty" xml:"IsView,omitempty"`
	// The ID of the associated category.
	LifeCycle *int32 `json:"LifeCycle,omitempty" xml:"LifeCycle,omitempty"`
	// The ID of the DataWorks workspace. You can log on to the DataWorks console to obtain the ID of the DataWorks workspace.
	Location *string `json:"Location,omitempty" xml:"Location,omitempty"`
	// The ID of the physical level.
	LogicalLevelId *int64  `json:"LogicalLevelId,omitempty" xml:"LogicalLevelId,omitempty"`
	OwnerId        *string `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
	// The type of the external table. Valid values: 0, 1, 2, and 3. The value 0 indicates that the external table is an OSS external table. The value 1 indicates that the external table is a Tablestore external table. The value 2 indicates that the external table is a volume external table. The value 3 indicates that the external table is a MySQL external table. This parameter is deprecated. Do not use this parameter.
	PhysicsLevelId *int64 `json:"PhysicsLevelId,omitempty" xml:"PhysicsLevelId,omitempty"`
	// The name of the MaxCompute table.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The display name of the field.
	Schema *string `json:"Schema,omitempty" xml:"Schema,omitempty"`
	// The endpoint of MaxCompute. If this parameter is left empty, the endpoint of the MaxCompute project is used.
	TableName *string                     `json:"TableName,omitempty" xml:"TableName,omitempty"`
	Themes    []*UpdateTableRequestThemes `json:"Themes,omitempty" xml:"Themes,omitempty" type:"Repeated"`
	// The lifecycle of the table. Unit: days. If this parameter is left empty, the table is permanently stored.
	Visibility *int32 `json:"Visibility,omitempty" xml:"Visibility,omitempty"`
}

func (s UpdateTableRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableRequest) GoString() string {
	return s.String()
}

func (s *UpdateTableRequest) SetAppGuid(v string) *UpdateTableRequest {
	s.AppGuid = &v
	return s
}

func (s *UpdateTableRequest) SetCategoryId(v int64) *UpdateTableRequest {
	s.CategoryId = &v
	return s
}

func (s *UpdateTableRequest) SetColumns(v []*UpdateTableRequestColumns) *UpdateTableRequest {
	s.Columns = v
	return s
}

func (s *UpdateTableRequest) SetComment(v string) *UpdateTableRequest {
	s.Comment = &v
	return s
}

func (s *UpdateTableRequest) SetCreateIfNotExists(v bool) *UpdateTableRequest {
	s.CreateIfNotExists = &v
	return s
}

func (s *UpdateTableRequest) SetEndpoint(v string) *UpdateTableRequest {
	s.Endpoint = &v
	return s
}

func (s *UpdateTableRequest) SetEnvType(v int32) *UpdateTableRequest {
	s.EnvType = &v
	return s
}

func (s *UpdateTableRequest) SetExternalTableType(v string) *UpdateTableRequest {
	s.ExternalTableType = &v
	return s
}

func (s *UpdateTableRequest) SetHasPart(v int32) *UpdateTableRequest {
	s.HasPart = &v
	return s
}

func (s *UpdateTableRequest) SetIsView(v int32) *UpdateTableRequest {
	s.IsView = &v
	return s
}

func (s *UpdateTableRequest) SetLifeCycle(v int32) *UpdateTableRequest {
	s.LifeCycle = &v
	return s
}

func (s *UpdateTableRequest) SetLocation(v string) *UpdateTableRequest {
	s.Location = &v
	return s
}

func (s *UpdateTableRequest) SetLogicalLevelId(v int64) *UpdateTableRequest {
	s.LogicalLevelId = &v
	return s
}

func (s *UpdateTableRequest) SetOwnerId(v string) *UpdateTableRequest {
	s.OwnerId = &v
	return s
}

func (s *UpdateTableRequest) SetPhysicsLevelId(v int64) *UpdateTableRequest {
	s.PhysicsLevelId = &v
	return s
}

func (s *UpdateTableRequest) SetProjectId(v int64) *UpdateTableRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateTableRequest) SetSchema(v string) *UpdateTableRequest {
	s.Schema = &v
	return s
}

func (s *UpdateTableRequest) SetTableName(v string) *UpdateTableRequest {
	s.TableName = &v
	return s
}

func (s *UpdateTableRequest) SetThemes(v []*UpdateTableRequestThemes) *UpdateTableRequest {
	s.Themes = v
	return s
}

func (s *UpdateTableRequest) SetVisibility(v int32) *UpdateTableRequest {
	s.Visibility = &v
	return s
}

type UpdateTableRequestColumns struct {
	// The comment of the field.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The name of the field.
	ColumnNameCn *string `json:"ColumnNameCn,omitempty" xml:"ColumnNameCn,omitempty"`
	// The sequence number of the field. If the field is a partition field, this parameter is not supported.
	ColumnType *string `json:"ColumnType,omitempty" xml:"ColumnType,omitempty"`
	// The type of the field. For more information, see MaxCompute field types.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
	// The ID of the associated topic.
	IsPartitionCol *bool `json:"IsPartitionCol,omitempty" xml:"IsPartitionCol,omitempty"`
	// Specifies whether the field is a partition field. Valid values: 0 and 1. The value 0 indicates that the field is not a partition field. The value 1 indicates that the field is a partition field.
	Length *int32 `json:"Length,omitempty" xml:"Length,omitempty"`
	// The length of the field.
	SeqNumber *int32 `json:"SeqNumber,omitempty" xml:"SeqNumber,omitempty"`
}

func (s UpdateTableRequestColumns) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableRequestColumns) GoString() string {
	return s.String()
}

func (s *UpdateTableRequestColumns) SetColumnName(v string) *UpdateTableRequestColumns {
	s.ColumnName = &v
	return s
}

func (s *UpdateTableRequestColumns) SetColumnNameCn(v string) *UpdateTableRequestColumns {
	s.ColumnNameCn = &v
	return s
}

func (s *UpdateTableRequestColumns) SetColumnType(v string) *UpdateTableRequestColumns {
	s.ColumnType = &v
	return s
}

func (s *UpdateTableRequestColumns) SetComment(v string) *UpdateTableRequestColumns {
	s.Comment = &v
	return s
}

func (s *UpdateTableRequestColumns) SetIsPartitionCol(v bool) *UpdateTableRequestColumns {
	s.IsPartitionCol = &v
	return s
}

func (s *UpdateTableRequestColumns) SetLength(v int32) *UpdateTableRequestColumns {
	s.Length = &v
	return s
}

func (s *UpdateTableRequestColumns) SetSeqNumber(v int32) *UpdateTableRequestColumns {
	s.SeqNumber = &v
	return s
}

type UpdateTableRequestThemes struct {
	// The level that corresponds to the topic ID.
	ThemeId *int64 `json:"ThemeId,omitempty" xml:"ThemeId,omitempty"`
	// The ID of the request.
	ThemeLevel *int32 `json:"ThemeLevel,omitempty" xml:"ThemeLevel,omitempty"`
}

func (s UpdateTableRequestThemes) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableRequestThemes) GoString() string {
	return s.String()
}

func (s *UpdateTableRequestThemes) SetThemeId(v int64) *UpdateTableRequestThemes {
	s.ThemeId = &v
	return s
}

func (s *UpdateTableRequestThemes) SetThemeLevel(v int32) *UpdateTableRequestThemes {
	s.ThemeLevel = &v
	return s
}

type UpdateTableResponseBody struct {
	// The information about the request task.
	//
	// After a request task is submitted, it is divided into multiple subtasks that are run in sequence. After the current subtask is complete, the next subtask starts to run. After all subtasks are complete, the request task is complete. If a request task is aborted due to one of the following issues, address the issue based on the error code and initiate the request task again:
	//
	// *   The request task fails to be submitted.
	// *   After the request task is submitted, a subtask fails to run.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The status of the current subtask. Valid values:
	//
	// *   operating: The subtask is running.
	// *   success: The subtask succeeds.
	// *   failure: The subtask fails to run. For more information about the error details, see the Content parameter.
	TaskInfo *UpdateTableResponseBodyTaskInfo `json:"TaskInfo,omitempty" xml:"TaskInfo,omitempty" type:"Struct"`
}

func (s UpdateTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTableResponseBody) SetRequestId(v string) *UpdateTableResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTableResponseBody) SetTaskInfo(v *UpdateTableResponseBodyTaskInfo) *UpdateTableResponseBody {
	s.TaskInfo = v
	return s
}

type UpdateTableResponseBodyTaskInfo struct {
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the current subtask.
	NextTaskId *string `json:"NextTaskId,omitempty" xml:"NextTaskId,omitempty"`
	// The ID of the subtask that you want to run. If this parameter is left empty, all subtasks are complete. You can call the [GetDDLJobStatus](~~185659~~) operation to query the status of the subtask based on the subtask ID.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// Details about the status of the current subtask.
	//
	// *   If the current subtask succeeds, success is returned.
	// *   If the current subtask fails, the error details are displayed.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s UpdateTableResponseBodyTaskInfo) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableResponseBodyTaskInfo) GoString() string {
	return s.String()
}

func (s *UpdateTableResponseBodyTaskInfo) SetContent(v string) *UpdateTableResponseBodyTaskInfo {
	s.Content = &v
	return s
}

func (s *UpdateTableResponseBodyTaskInfo) SetNextTaskId(v string) *UpdateTableResponseBodyTaskInfo {
	s.NextTaskId = &v
	return s
}

func (s *UpdateTableResponseBodyTaskInfo) SetStatus(v string) *UpdateTableResponseBodyTaskInfo {
	s.Status = &v
	return s
}

func (s *UpdateTableResponseBodyTaskInfo) SetTaskId(v string) *UpdateTableResponseBodyTaskInfo {
	s.TaskId = &v
	return s
}

type UpdateTableResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateTableResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateTableResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableResponse) GoString() string {
	return s.String()
}

func (s *UpdateTableResponse) SetHeaders(v map[string]*string) *UpdateTableResponse {
	s.Headers = v
	return s
}

func (s *UpdateTableResponse) SetStatusCode(v int32) *UpdateTableResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTableResponse) SetBody(v *UpdateTableResponseBody) *UpdateTableResponse {
	s.Body = v
	return s
}

type UpdateTableAddColumnRequest struct {
	Column []*UpdateTableAddColumnRequestColumn `json:"Column,omitempty" xml:"Column,omitempty" type:"Repeated"`
	// The globally unique identifier (GUID) of the MaxCompute table. Specify the GUID in the odps.projectName.tableName format.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
}

func (s UpdateTableAddColumnRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableAddColumnRequest) GoString() string {
	return s.String()
}

func (s *UpdateTableAddColumnRequest) SetColumn(v []*UpdateTableAddColumnRequestColumn) *UpdateTableAddColumnRequest {
	s.Column = v
	return s
}

func (s *UpdateTableAddColumnRequest) SetTableGuid(v string) *UpdateTableAddColumnRequest {
	s.TableGuid = &v
	return s
}

type UpdateTableAddColumnRequestColumn struct {
	// The name of the field.
	ColumnName *string `json:"ColumnName,omitempty" xml:"ColumnName,omitempty"`
	// The display name of the field.
	ColumnNameCn *string `json:"ColumnNameCn,omitempty" xml:"ColumnNameCn,omitempty"`
	// The type of the field. For more information, see MaxCompute field types.
	ColumnType *string `json:"ColumnType,omitempty" xml:"ColumnType,omitempty"`
	// The comment of the field.
	Comment *string `json:"Comment,omitempty" xml:"Comment,omitempty"`
}

func (s UpdateTableAddColumnRequestColumn) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableAddColumnRequestColumn) GoString() string {
	return s.String()
}

func (s *UpdateTableAddColumnRequestColumn) SetColumnName(v string) *UpdateTableAddColumnRequestColumn {
	s.ColumnName = &v
	return s
}

func (s *UpdateTableAddColumnRequestColumn) SetColumnNameCn(v string) *UpdateTableAddColumnRequestColumn {
	s.ColumnNameCn = &v
	return s
}

func (s *UpdateTableAddColumnRequestColumn) SetColumnType(v string) *UpdateTableAddColumnRequestColumn {
	s.ColumnType = &v
	return s
}

func (s *UpdateTableAddColumnRequestColumn) SetComment(v string) *UpdateTableAddColumnRequestColumn {
	s.Comment = &v
	return s
}

type UpdateTableAddColumnResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the request task.
	//
	// After a request task is submitted, it is divided into multiple subtasks that are run in sequence. After the current subtask is complete, the next subtask starts to run. After all subtasks are complete, the request task is complete. If a request task is aborted due to one of the following issues, address the issue based on the error code and initiate the request task again:
	//
	// *   The request task fails to be submitted.
	// *   After the request task is submitted, a subtask fails to run.
	TaskInfo *UpdateTableAddColumnResponseBodyTaskInfo `json:"TaskInfo,omitempty" xml:"TaskInfo,omitempty" type:"Struct"`
}

func (s UpdateTableAddColumnResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableAddColumnResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTableAddColumnResponseBody) SetRequestId(v string) *UpdateTableAddColumnResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTableAddColumnResponseBody) SetTaskInfo(v *UpdateTableAddColumnResponseBodyTaskInfo) *UpdateTableAddColumnResponseBody {
	s.TaskInfo = v
	return s
}

type UpdateTableAddColumnResponseBodyTaskInfo struct {
	// Details about the status of the current subtask. Valid values:
	//
	// *   If the current subtask succeeds, success is returned.
	// *   If the current subtask fails, the error details are displayed.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The ID of the subtask that you want to run. If this parameter is left empty, all subtasks are complete. You can call the [GetDDLJobStatus](~~185659~~) operation to query the status of the subtask based on the subtask ID.
	NextTaskId *string `json:"NextTaskId,omitempty" xml:"NextTaskId,omitempty"`
	// The status of the current subtask. Valid values:
	//
	// *   operating: The subtask is running.
	// *   success: The subtask succeeds.
	// *   failure: The subtask fails to run. For more information about the error details, see the Content parameter.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the current subtask.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s UpdateTableAddColumnResponseBodyTaskInfo) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableAddColumnResponseBodyTaskInfo) GoString() string {
	return s.String()
}

func (s *UpdateTableAddColumnResponseBodyTaskInfo) SetContent(v string) *UpdateTableAddColumnResponseBodyTaskInfo {
	s.Content = &v
	return s
}

func (s *UpdateTableAddColumnResponseBodyTaskInfo) SetNextTaskId(v string) *UpdateTableAddColumnResponseBodyTaskInfo {
	s.NextTaskId = &v
	return s
}

func (s *UpdateTableAddColumnResponseBodyTaskInfo) SetStatus(v string) *UpdateTableAddColumnResponseBodyTaskInfo {
	s.Status = &v
	return s
}

func (s *UpdateTableAddColumnResponseBodyTaskInfo) SetTaskId(v string) *UpdateTableAddColumnResponseBodyTaskInfo {
	s.TaskId = &v
	return s
}

type UpdateTableAddColumnResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateTableAddColumnResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateTableAddColumnResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableAddColumnResponse) GoString() string {
	return s.String()
}

func (s *UpdateTableAddColumnResponse) SetHeaders(v map[string]*string) *UpdateTableAddColumnResponse {
	s.Headers = v
	return s
}

func (s *UpdateTableAddColumnResponse) SetStatusCode(v int32) *UpdateTableAddColumnResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTableAddColumnResponse) SetBody(v *UpdateTableAddColumnResponseBody) *UpdateTableAddColumnResponse {
	s.Body = v
	return s
}

type UpdateTableLevelRequest struct {
	// The description of the table level.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the table level to be updated. You can call the ListTableLevel operation to obtain the ID.
	LevelId *int64 `json:"LevelId,omitempty" xml:"LevelId,omitempty"`
	// The type of the table level. Valid values: 1 and 2. A value of 1 indicates the logical level. A value of 2 indicates the physical level.
	LevelType *int32 `json:"LevelType,omitempty" xml:"LevelType,omitempty"`
	// The name of the table level.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the DataWorks workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s UpdateTableLevelRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableLevelRequest) GoString() string {
	return s.String()
}

func (s *UpdateTableLevelRequest) SetDescription(v string) *UpdateTableLevelRequest {
	s.Description = &v
	return s
}

func (s *UpdateTableLevelRequest) SetLevelId(v int64) *UpdateTableLevelRequest {
	s.LevelId = &v
	return s
}

func (s *UpdateTableLevelRequest) SetLevelType(v int32) *UpdateTableLevelRequest {
	s.LevelType = &v
	return s
}

func (s *UpdateTableLevelRequest) SetName(v string) *UpdateTableLevelRequest {
	s.Name = &v
	return s
}

func (s *UpdateTableLevelRequest) SetProjectId(v int64) *UpdateTableLevelRequest {
	s.ProjectId = &v
	return s
}

type UpdateTableLevelResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// Indicates whether the update result is returned.
	UpdateResult *bool `json:"UpdateResult,omitempty" xml:"UpdateResult,omitempty"`
}

func (s UpdateTableLevelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableLevelResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTableLevelResponseBody) SetErrorCode(v string) *UpdateTableLevelResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTableLevelResponseBody) SetErrorMessage(v string) *UpdateTableLevelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTableLevelResponseBody) SetHttpStatusCode(v int32) *UpdateTableLevelResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateTableLevelResponseBody) SetRequestId(v string) *UpdateTableLevelResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTableLevelResponseBody) SetSuccess(v bool) *UpdateTableLevelResponseBody {
	s.Success = &v
	return s
}

func (s *UpdateTableLevelResponseBody) SetUpdateResult(v bool) *UpdateTableLevelResponseBody {
	s.UpdateResult = &v
	return s
}

type UpdateTableLevelResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateTableLevelResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateTableLevelResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableLevelResponse) GoString() string {
	return s.String()
}

func (s *UpdateTableLevelResponse) SetHeaders(v map[string]*string) *UpdateTableLevelResponse {
	s.Headers = v
	return s
}

func (s *UpdateTableLevelResponse) SetStatusCode(v int32) *UpdateTableLevelResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTableLevelResponse) SetBody(v *UpdateTableLevelResponseBody) *UpdateTableLevelResponse {
	s.Body = v
	return s
}

type UpdateTableModelInfoRequest struct {
	// The ID of the first-level table folder.
	FirstLevelThemeId *int64 `json:"FirstLevelThemeId,omitempty" xml:"FirstLevelThemeId,omitempty"`
	// The ID of the table level.
	LevelId *int64 `json:"LevelId,omitempty" xml:"LevelId,omitempty"`
	// The type of the table level. Valid values: 1 and 2. A value of 1 indicates the logical level. A value of 2 indicates the physical level.
	LevelType *int32 `json:"LevelType,omitempty" xml:"LevelType,omitempty"`
	// The ID of the second-level table folder.
	SecondLevelThemeId *int64 `json:"SecondLevelThemeId,omitempty" xml:"SecondLevelThemeId,omitempty"`
	// The globally unique identifier (GUID) of the table. Specify the GUID in the format of odps.{projectName}.{tableName}.
	TableGuid *string `json:"TableGuid,omitempty" xml:"TableGuid,omitempty"`
}

func (s UpdateTableModelInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableModelInfoRequest) GoString() string {
	return s.String()
}

func (s *UpdateTableModelInfoRequest) SetFirstLevelThemeId(v int64) *UpdateTableModelInfoRequest {
	s.FirstLevelThemeId = &v
	return s
}

func (s *UpdateTableModelInfoRequest) SetLevelId(v int64) *UpdateTableModelInfoRequest {
	s.LevelId = &v
	return s
}

func (s *UpdateTableModelInfoRequest) SetLevelType(v int32) *UpdateTableModelInfoRequest {
	s.LevelType = &v
	return s
}

func (s *UpdateTableModelInfoRequest) SetSecondLevelThemeId(v int64) *UpdateTableModelInfoRequest {
	s.SecondLevelThemeId = &v
	return s
}

func (s *UpdateTableModelInfoRequest) SetTableGuid(v string) *UpdateTableModelInfoRequest {
	s.TableGuid = &v
	return s
}

type UpdateTableModelInfoResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	UpdateResult *bool `json:"UpdateResult,omitempty" xml:"UpdateResult,omitempty"`
}

func (s UpdateTableModelInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableModelInfoResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTableModelInfoResponseBody) SetRequestId(v string) *UpdateTableModelInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTableModelInfoResponseBody) SetUpdateResult(v bool) *UpdateTableModelInfoResponseBody {
	s.UpdateResult = &v
	return s
}

type UpdateTableModelInfoResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateTableModelInfoResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateTableModelInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableModelInfoResponse) GoString() string {
	return s.String()
}

func (s *UpdateTableModelInfoResponse) SetHeaders(v map[string]*string) *UpdateTableModelInfoResponse {
	s.Headers = v
	return s
}

func (s *UpdateTableModelInfoResponse) SetStatusCode(v int32) *UpdateTableModelInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTableModelInfoResponse) SetBody(v *UpdateTableModelInfoResponseBody) *UpdateTableModelInfoResponse {
	s.Body = v
	return s
}

type UpdateTableThemeRequest struct {
	// The name of the table folder.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ID of the DataWorks workspace.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The ID of the table folder.
	ThemeId *int64 `json:"ThemeId,omitempty" xml:"ThemeId,omitempty"`
}

func (s UpdateTableThemeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableThemeRequest) GoString() string {
	return s.String()
}

func (s *UpdateTableThemeRequest) SetName(v string) *UpdateTableThemeRequest {
	s.Name = &v
	return s
}

func (s *UpdateTableThemeRequest) SetProjectId(v int64) *UpdateTableThemeRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateTableThemeRequest) SetThemeId(v int64) *UpdateTableThemeRequest {
	s.ThemeId = &v
	return s
}

type UpdateTableThemeResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful. Valid values:
	//
	// *   true: The request is successful.
	// *   false: The request fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// Indicates whether the update result is returned. Valid values:
	//
	// *   true: The update result is returned.
	// *   false: The update result is not returned.
	UpdateResult *bool `json:"UpdateResult,omitempty" xml:"UpdateResult,omitempty"`
}

func (s UpdateTableThemeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableThemeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTableThemeResponseBody) SetErrorCode(v string) *UpdateTableThemeResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateTableThemeResponseBody) SetErrorMessage(v string) *UpdateTableThemeResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateTableThemeResponseBody) SetHttpStatusCode(v int32) *UpdateTableThemeResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateTableThemeResponseBody) SetRequestId(v string) *UpdateTableThemeResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTableThemeResponseBody) SetSuccess(v bool) *UpdateTableThemeResponseBody {
	s.Success = &v
	return s
}

func (s *UpdateTableThemeResponseBody) SetUpdateResult(v bool) *UpdateTableThemeResponseBody {
	s.UpdateResult = &v
	return s
}

type UpdateTableThemeResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateTableThemeResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateTableThemeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTableThemeResponse) GoString() string {
	return s.String()
}

func (s *UpdateTableThemeResponse) SetHeaders(v map[string]*string) *UpdateTableThemeResponse {
	s.Headers = v
	return s
}

func (s *UpdateTableThemeResponse) SetStatusCode(v int32) *UpdateTableThemeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTableThemeResponse) SetBody(v *UpdateTableThemeResponseBody) *UpdateTableThemeResponse {
	s.Body = v
	return s
}

type UpdateUdfFileRequest struct {
	// The name of the class in which the function is defined. This parameter corresponds to the Class Name parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
	ClassName *string `json:"ClassName,omitempty" xml:"ClassName,omitempty"`
	// The syntax used for calling the function. This parameter corresponds to the Expression Syntax parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
	CmdDescription *string `json:"CmdDescription,omitempty" xml:"CmdDescription,omitempty"`
	// The example for calling the function. This parameter corresponds to the Example parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
	Example *string `json:"Example,omitempty" xml:"Example,omitempty"`
	// The path of the folder in which the function file is stored.
	FileFolderPath *string `json:"FileFolderPath,omitempty" xml:"FileFolderPath,omitempty"`
	// The ID of the file.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The type of the function. Valid values: MATH, AGGREGATE, STRING, DATE, ANALYTIC, and OTHER. This parameter corresponds to the Function Type parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
	FunctionType *string `json:"FunctionType,omitempty" xml:"FunctionType,omitempty"`
	// The description of the input parameters of the function. This parameter corresponds to the Parameter Description parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
	ParameterDescription *string `json:"ParameterDescription,omitempty" xml:"ParameterDescription,omitempty"`
	// The ID of the DataWorks workspace. You can click the Workspace Manage icon in the upper-right corner of the DataStudio page to go to the Workspace Management page and view the workspace ID.
	ProjectId *int64 `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	// The unique identifier of the DataWorks workspace. You can click the identifier in the upper-left corner of the DataStudio page to switch to another workspace.
	//
	// You must specify either this parameter or ProjectId to determine the DataWorks workspace to which the operation is applied.
	ProjectIdentifier *string `json:"ProjectIdentifier,omitempty" xml:"ProjectIdentifier,omitempty"`
	// The names of the resources that are referenced by the function. This parameter corresponds to the Resources parameter in the Register Function section of the configuration tab of the function in the DataWorks console. Separate multiple resource names with commas (,).
	Resources *string `json:"Resources,omitempty" xml:"Resources,omitempty"`
	// The description of the return value of the function. This parameter corresponds to the Return Value parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
	ReturnValue *string `json:"ReturnValue,omitempty" xml:"ReturnValue,omitempty"`
	// The description of the function. This parameter corresponds to the Description parameter in the Register Function section of the configuration tab of the function in the DataWorks console.
	UdfDescription *string `json:"UdfDescription,omitempty" xml:"UdfDescription,omitempty"`
}

func (s UpdateUdfFileRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateUdfFileRequest) GoString() string {
	return s.String()
}

func (s *UpdateUdfFileRequest) SetClassName(v string) *UpdateUdfFileRequest {
	s.ClassName = &v
	return s
}

func (s *UpdateUdfFileRequest) SetCmdDescription(v string) *UpdateUdfFileRequest {
	s.CmdDescription = &v
	return s
}

func (s *UpdateUdfFileRequest) SetExample(v string) *UpdateUdfFileRequest {
	s.Example = &v
	return s
}

func (s *UpdateUdfFileRequest) SetFileFolderPath(v string) *UpdateUdfFileRequest {
	s.FileFolderPath = &v
	return s
}

func (s *UpdateUdfFileRequest) SetFileId(v string) *UpdateUdfFileRequest {
	s.FileId = &v
	return s
}

func (s *UpdateUdfFileRequest) SetFunctionType(v string) *UpdateUdfFileRequest {
	s.FunctionType = &v
	return s
}

func (s *UpdateUdfFileRequest) SetParameterDescription(v string) *UpdateUdfFileRequest {
	s.ParameterDescription = &v
	return s
}

func (s *UpdateUdfFileRequest) SetProjectId(v int64) *UpdateUdfFileRequest {
	s.ProjectId = &v
	return s
}

func (s *UpdateUdfFileRequest) SetProjectIdentifier(v string) *UpdateUdfFileRequest {
	s.ProjectIdentifier = &v
	return s
}

func (s *UpdateUdfFileRequest) SetResources(v string) *UpdateUdfFileRequest {
	s.Resources = &v
	return s
}

func (s *UpdateUdfFileRequest) SetReturnValue(v string) *UpdateUdfFileRequest {
	s.ReturnValue = &v
	return s
}

func (s *UpdateUdfFileRequest) SetUdfDescription(v string) *UpdateUdfFileRequest {
	s.UdfDescription = &v
	return s
}

type UpdateUdfFileResponseBody struct {
	// The error code returned.
	ErrorCode *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	// The error message returned.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The HTTP status code returned.
	HttpStatusCode *int32 `json:"HttpStatusCode,omitempty" xml:"HttpStatusCode,omitempty"`
	// The ID of the request. You can troubleshoot issues based on the ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateUdfFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateUdfFileResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateUdfFileResponseBody) SetErrorCode(v string) *UpdateUdfFileResponseBody {
	s.ErrorCode = &v
	return s
}

func (s *UpdateUdfFileResponseBody) SetErrorMessage(v string) *UpdateUdfFileResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateUdfFileResponseBody) SetHttpStatusCode(v int32) *UpdateUdfFileResponseBody {
	s.HttpStatusCode = &v
	return s
}

func (s *UpdateUdfFileResponseBody) SetRequestId(v string) *UpdateUdfFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateUdfFileResponseBody) SetSuccess(v bool) *UpdateUdfFileResponseBody {
	s.Success = &v
	return s
}

type UpdateUdfFileResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateUdfFileResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateUdfFileResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateUdfFileResponse) GoString() string {
	return s.String()
}

func (s *UpdateUdfFileResponse) SetHeaders(v map[string]*string) *UpdateUdfFileResponse {
	s.Headers = v
	return s
}

func (s *UpdateUdfFileResponse) SetStatusCode(v int32) *UpdateUdfFileResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateUdfFileResponse) SetBody(v *UpdateUdfFileResponseBody) *UpdateUdfFileResponse {
	s.Body = v
	return s
}

type UpdateWorkbenchEventResultRequest struct {
	// The check status of the extension point event. Valid values: OK and Fail. A value of OK indicates that the event passes the check. A value of FAIL indicates that the event fails to pass the check.
	CheckResult *string `json:"CheckResult,omitempty" xml:"CheckResult,omitempty"`
	// The cause of the check failure.
	CheckResultTip *string `json:"CheckResultTip,omitempty" xml:"CheckResultTip,omitempty"`
	// The code of the extension.
	ExtensionCode *string `json:"ExtensionCode,omitempty" xml:"ExtensionCode,omitempty"`
	// The ID of the message received when the related extension point event is triggered after you enable message subscription by using the OpenEvent module.
	MessageId *string `json:"MessageId,omitempty" xml:"MessageId,omitempty"`
}

func (s UpdateWorkbenchEventResultRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateWorkbenchEventResultRequest) GoString() string {
	return s.String()
}

func (s *UpdateWorkbenchEventResultRequest) SetCheckResult(v string) *UpdateWorkbenchEventResultRequest {
	s.CheckResult = &v
	return s
}

func (s *UpdateWorkbenchEventResultRequest) SetCheckResultTip(v string) *UpdateWorkbenchEventResultRequest {
	s.CheckResultTip = &v
	return s
}

func (s *UpdateWorkbenchEventResultRequest) SetExtensionCode(v string) *UpdateWorkbenchEventResultRequest {
	s.ExtensionCode = &v
	return s
}

func (s *UpdateWorkbenchEventResultRequest) SetMessageId(v string) *UpdateWorkbenchEventResultRequest {
	s.MessageId = &v
	return s
}

type UpdateWorkbenchEventResultResponseBody struct {
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateWorkbenchEventResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateWorkbenchEventResultResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateWorkbenchEventResultResponseBody) SetRequestId(v string) *UpdateWorkbenchEventResultResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateWorkbenchEventResultResponseBody) SetSuccess(v bool) *UpdateWorkbenchEventResultResponseBody {
	s.Success = &v
	return s
}

type UpdateWorkbenchEventResultResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty"`
	Body       *UpdateWorkbenchEventResultResponseBody `json:"body,omitempty" xml:"body,omitempty"`
}

func (s UpdateWorkbenchEventResultResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateWorkbenchEventResultResponse) GoString() string {
	return s.String()
}

func (s *UpdateWorkbenchEventResultResponse) SetHeaders(v map[string]*string) *UpdateWorkbenchEventResultResponse {
	s.Headers = v
	return s
}

func (s *UpdateWorkbenchEventResultResponse) SetStatusCode(v int32) *UpdateWorkbenchEventResultResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateWorkbenchEventResultResponse) SetBody(v *UpdateWorkbenchEventResultResponseBody) *UpdateWorkbenchEventResultResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("regional")
	client.EndpointMap = map[string]*string{
		"ap-northeast-1":        tea.String("dataworks.ap-northeast-1.aliyuncs.com"),
		"ap-south-1":            tea.String("dataworks.ap-south-1.aliyuncs.com"),
		"ap-southeast-1":        tea.String("dataworks.ap-southeast-1.aliyuncs.com"),
		"ap-southeast-2":        tea.String("dataworks.ap-southeast-2.aliyuncs.com"),
		"ap-southeast-3":        tea.String("dataworks.ap-southeast-3.aliyuncs.com"),
		"ap-southeast-5":        tea.String("dataworks.ap-southeast-5.aliyuncs.com"),
		"cn-beijing":            tea.String("dataworks.cn-beijing.aliyuncs.com"),
		"cn-chengdu":            tea.String("dataworks.cn-chengdu.aliyuncs.com"),
		"cn-hangzhou":           tea.String("dataworks.cn-hangzhou.aliyuncs.com"),
		"cn-hongkong":           tea.String("dataworks.cn-hongkong.aliyuncs.com"),
		"cn-huhehaote":          tea.String("dataworks.aliyuncs.com"),
		"cn-qingdao":            tea.String("dataworks.aliyuncs.com"),
		"cn-shanghai":           tea.String("dataworks.cn-shanghai.aliyuncs.com"),
		"cn-shenzhen":           tea.String("dataworks.cn-shenzhen.aliyuncs.com"),
		"cn-zhangjiakou":        tea.String("dataworks.aliyuncs.com"),
		"eu-central-1":          tea.String("dataworks.eu-central-1.aliyuncs.com"),
		"eu-west-1":             tea.String("dataworks.eu-west-1.aliyuncs.com"),
		"me-east-1":             tea.String("dataworks.me-east-1.aliyuncs.com"),
		"us-east-1":             tea.String("dataworks.us-east-1.aliyuncs.com"),
		"us-west-1":             tea.String("dataworks.us-west-1.aliyuncs.com"),
		"cn-hangzhou-finance":   tea.String("dataworks.aliyuncs.com"),
		"cn-shenzhen-finance-1": tea.String("dataworks.aliyuncs.com"),
		"cn-shanghai-finance-1": tea.String("dataworks.aliyuncs.com"),
		"cn-north-2-gov-1":      tea.String("dataworks.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("dataworks-public"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AbolishDataServiceApiWithOptions(request *AbolishDataServiceApiRequest, runtime *util.RuntimeOptions) (_result *AbolishDataServiceApiResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiId)) {
		body["ApiId"] = request.ApiId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("AbolishDataServiceApi"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AbolishDataServiceApiResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AbolishDataServiceApi(request *AbolishDataServiceApiRequest) (_result *AbolishDataServiceApiResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AbolishDataServiceApiResponse{}
	_body, _err := client.AbolishDataServiceApiWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddMetaCollectionEntityWithOptions(request *AddMetaCollectionEntityRequest, runtime *util.RuntimeOptions) (_result *AddMetaCollectionEntityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CollectionQualifiedName)) {
		query["CollectionQualifiedName"] = request.CollectionQualifiedName
	}

	if !tea.BoolValue(util.IsUnset(request.EntityQualifiedName)) {
		query["EntityQualifiedName"] = request.EntityQualifiedName
	}

	if !tea.BoolValue(util.IsUnset(request.Remark)) {
		query["Remark"] = request.Remark
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddMetaCollectionEntity"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddMetaCollectionEntityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddMetaCollectionEntity(request *AddMetaCollectionEntityRequest) (_result *AddMetaCollectionEntityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddMetaCollectionEntityResponse{}
	_body, _err := client.AddMetaCollectionEntityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the DataWorks workspace. You can call the [ListProjects](~~178393~~) operation to query the ID.
 *
 * @param request AddProjectMemberToRoleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddProjectMemberToRoleResponse
 */
func (client *Client) AddProjectMemberToRoleWithOptions(request *AddProjectMemberToRoleRequest, runtime *util.RuntimeOptions) (_result *AddProjectMemberToRoleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.RoleCode)) {
		query["RoleCode"] = request.RoleCode
	}

	if !tea.BoolValue(util.IsUnset(request.UserId)) {
		query["UserId"] = request.UserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddProjectMemberToRole"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddProjectMemberToRoleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the DataWorks workspace. You can call the [ListProjects](~~178393~~) operation to query the ID.
 *
 * @param request AddProjectMemberToRoleRequest
 * @return AddProjectMemberToRoleResponse
 */
func (client *Client) AddProjectMemberToRole(request *AddProjectMemberToRoleRequest) (_result *AddProjectMemberToRoleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddProjectMemberToRoleResponse{}
	_body, _err := client.AddProjectMemberToRoleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddRecognizeRuleWithOptions(request *AddRecognizeRuleRequest, runtime *util.RuntimeOptions) (_result *AddRecognizeRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountName)) {
		body["AccountName"] = request.AccountName
	}

	if !tea.BoolValue(util.IsUnset(request.ColExclude)) {
		body["ColExclude"] = request.ColExclude
	}

	if !tea.BoolValue(util.IsUnset(request.ColScan)) {
		body["ColScan"] = request.ColScan
	}

	if !tea.BoolValue(util.IsUnset(request.CommentScan)) {
		body["CommentScan"] = request.CommentScan
	}

	if !tea.BoolValue(util.IsUnset(request.ContentScan)) {
		body["ContentScan"] = request.ContentScan
	}

	if !tea.BoolValue(util.IsUnset(request.HitThreshold)) {
		body["HitThreshold"] = request.HitThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.Level)) {
		body["Level"] = request.Level
	}

	if !tea.BoolValue(util.IsUnset(request.LevelName)) {
		body["LevelName"] = request.LevelName
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.NodeParent)) {
		body["NodeParent"] = request.NodeParent
	}

	if !tea.BoolValue(util.IsUnset(request.OperationType)) {
		body["OperationType"] = request.OperationType
	}

	if !tea.BoolValue(util.IsUnset(request.RecognizeRules)) {
		body["RecognizeRules"] = request.RecognizeRules
	}

	if !tea.BoolValue(util.IsUnset(request.RecognizeRulesType)) {
		body["RecognizeRulesType"] = request.RecognizeRulesType
	}

	if !tea.BoolValue(util.IsUnset(request.SensitiveDescription)) {
		body["SensitiveDescription"] = request.SensitiveDescription
	}

	if !tea.BoolValue(util.IsUnset(request.SensitiveName)) {
		body["SensitiveName"] = request.SensitiveName
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		body["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		body["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("AddRecognizeRule"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddRecognizeRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddRecognizeRule(request *AddRecognizeRuleRequest) (_result *AddRecognizeRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddRecognizeRuleResponse{}
	_body, _err := client.AddRecognizeRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddToMetaCategoryWithOptions(request *AddToMetaCategoryRequest, runtime *util.RuntimeOptions) (_result *AddToMetaCategoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CategoryId)) {
		query["CategoryId"] = request.CategoryId
	}

	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddToMetaCategory"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddToMetaCategoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddToMetaCategory(request *AddToMetaCategoryRequest) (_result *AddToMetaCategoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddToMetaCategoryResponse{}
	_body, _err := client.AddToMetaCategoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ApprovePermissionApplyOrderWithOptions(request *ApprovePermissionApplyOrderRequest, runtime *util.RuntimeOptions) (_result *ApprovePermissionApplyOrderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApproveAction)) {
		query["ApproveAction"] = request.ApproveAction
	}

	if !tea.BoolValue(util.IsUnset(request.ApproveComment)) {
		query["ApproveComment"] = request.ApproveComment
	}

	if !tea.BoolValue(util.IsUnset(request.FlowId)) {
		query["FlowId"] = request.FlowId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ApprovePermissionApplyOrder"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ApprovePermissionApplyOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ApprovePermissionApplyOrder(request *ApprovePermissionApplyOrderRequest) (_result *ApprovePermissionApplyOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ApprovePermissionApplyOrderResponse{}
	_body, _err := client.ApprovePermissionApplyOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CallbackExtensionWithOptions(request *CallbackExtensionRequest, runtime *util.RuntimeOptions) (_result *CallbackExtensionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CheckMessage)) {
		body["CheckMessage"] = request.CheckMessage
	}

	if !tea.BoolValue(util.IsUnset(request.CheckResult)) {
		body["CheckResult"] = request.CheckResult
	}

	if !tea.BoolValue(util.IsUnset(request.ExtensionCode)) {
		body["ExtensionCode"] = request.ExtensionCode
	}

	if !tea.BoolValue(util.IsUnset(request.MessageId)) {
		body["MessageId"] = request.MessageId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CallbackExtension"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CallbackExtensionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CallbackExtension(request *CallbackExtensionRequest) (_result *CallbackExtensionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CallbackExtensionResponse{}
	_body, _err := client.CallbackExtensionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ChangeResourceManagerResourceGroupWithOptions(request *ChangeResourceManagerResourceGroupRequest, runtime *util.RuntimeOptions) (_result *ChangeResourceManagerResourceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceManagerResourceGroupId)) {
		query["ResourceManagerResourceGroupId"] = request.ResourceManagerResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceType)) {
		query["ResourceType"] = request.ResourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ChangeResourceManagerResourceGroup"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ChangeResourceManagerResourceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ChangeResourceManagerResourceGroup(request *ChangeResourceManagerResourceGroupRequest) (_result *ChangeResourceManagerResourceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ChangeResourceManagerResourceGroupResponse{}
	_body, _err := client.ChangeResourceManagerResourceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CheckFileDeploymentWithOptions(request *CheckFileDeploymentRequest, runtime *util.RuntimeOptions) (_result *CheckFileDeploymentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CheckDetailUrl)) {
		body["CheckDetailUrl"] = request.CheckDetailUrl
	}

	if !tea.BoolValue(util.IsUnset(request.CheckerInstanceId)) {
		body["CheckerInstanceId"] = request.CheckerInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		body["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckFileDeployment"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckFileDeploymentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CheckFileDeployment(request *CheckFileDeploymentRequest) (_result *CheckFileDeploymentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckFileDeploymentResponse{}
	_body, _err := client.CheckFileDeploymentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CheckMetaPartitionWithOptions(request *CheckMetaPartitionRequest, runtime *util.RuntimeOptions) (_result *CheckMetaPartitionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.DataSourceType)) {
		query["DataSourceType"] = request.DataSourceType
	}

	if !tea.BoolValue(util.IsUnset(request.DatabaseName)) {
		query["DatabaseName"] = request.DatabaseName
	}

	if !tea.BoolValue(util.IsUnset(request.Partition)) {
		query["Partition"] = request.Partition
	}

	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckMetaPartition"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckMetaPartitionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CheckMetaPartition(request *CheckMetaPartitionRequest) (_result *CheckMetaPartitionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckMetaPartitionResponse{}
	_body, _err := client.CheckMetaPartitionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CheckMetaTableWithOptions(request *CheckMetaTableRequest, runtime *util.RuntimeOptions) (_result *CheckMetaTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.DataSourceType)) {
		query["DataSourceType"] = request.DataSourceType
	}

	if !tea.BoolValue(util.IsUnset(request.DatabaseName)) {
		query["DatabaseName"] = request.DatabaseName
	}

	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckMetaTable"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckMetaTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CheckMetaTable(request *CheckMetaTableRequest) (_result *CheckMetaTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckMetaTableResponse{}
	_body, _err := client.CheckMetaTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateBaselineWithOptions(request *CreateBaselineRequest, runtime *util.RuntimeOptions) (_result *CreateBaselineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertMarginThreshold)) {
		body["AlertMarginThreshold"] = request.AlertMarginThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.BaselineName)) {
		body["BaselineName"] = request.BaselineName
	}

	if !tea.BoolValue(util.IsUnset(request.BaselineType)) {
		body["BaselineType"] = request.BaselineType
	}

	if !tea.BoolValue(util.IsUnset(request.NodeIds)) {
		body["NodeIds"] = request.NodeIds
	}

	if !tea.BoolValue(util.IsUnset(request.OvertimeSettings)) {
		body["OvertimeSettings"] = request.OvertimeSettings
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		body["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateBaseline"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateBaselineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateBaseline(request *CreateBaselineRequest) (_result *CreateBaselineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateBaselineResponse{}
	_body, _err := client.CreateBaselineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateBusinessWithOptions(request *CreateBusinessRequest, runtime *util.RuntimeOptions) (_result *CreateBusinessResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BusinessName)) {
		body["BusinessName"] = request.BusinessName
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.UseType)) {
		body["UseType"] = request.UseType
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateBusiness"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateBusinessResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateBusiness(request *CreateBusinessRequest) (_result *CreateBusinessResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateBusinessResponse{}
	_body, _err := client.CreateBusinessWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request CreateConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConnectionResponse
 */
// Deprecated
func (client *Client) CreateConnectionWithOptions(request *CreateConnectionRequest, runtime *util.RuntimeOptions) (_result *CreateConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConnectionType)) {
		query["ConnectionType"] = request.ConnectionType
	}

	if !tea.BoolValue(util.IsUnset(request.Content)) {
		query["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.SubType)) {
		query["SubType"] = request.SubType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateConnection"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request CreateConnectionRequest
 * @return CreateConnectionResponse
 */
// Deprecated
func (client *Client) CreateConnection(request *CreateConnectionRequest) (_result *CreateConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateConnectionResponse{}
	_body, _err := client.CreateConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDIAlarmRuleWithOptions(tmpReq *CreateDIAlarmRuleRequest, runtime *util.RuntimeOptions) (_result *CreateDIAlarmRuleResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateDIAlarmRuleShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.NotificationSettings)) {
		request.NotificationSettingsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.NotificationSettings, tea.String("NotificationSettings"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.TriggerConditions)) {
		request.TriggerConditionsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.TriggerConditions, tea.String("TriggerConditions"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DIJobId)) {
		body["DIJobId"] = request.DIJobId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Enabled)) {
		body["Enabled"] = request.Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.MetricType)) {
		body["MetricType"] = request.MetricType
	}

	if !tea.BoolValue(util.IsUnset(request.NotificationSettingsShrink)) {
		body["NotificationSettings"] = request.NotificationSettingsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.TriggerConditionsShrink)) {
		body["TriggerConditions"] = request.TriggerConditionsShrink
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDIAlarmRule"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDIAlarmRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDIAlarmRule(request *CreateDIAlarmRuleRequest) (_result *CreateDIAlarmRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDIAlarmRuleResponse{}
	_body, _err := client.CreateDIAlarmRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDIJobWithOptions(tmpReq *CreateDIJobRequest, runtime *util.RuntimeOptions) (_result *CreateDIJobResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateDIJobShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.DestinationDataSourceSettings)) {
		request.DestinationDataSourceSettingsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.DestinationDataSourceSettings, tea.String("DestinationDataSourceSettings"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.JobSettings)) {
		request.JobSettingsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.JobSettings, tea.String("JobSettings"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.ResourceSettings)) {
		request.ResourceSettingsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ResourceSettings, tea.String("ResourceSettings"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.SourceDataSourceSettings)) {
		request.SourceDataSourceSettingsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.SourceDataSourceSettings, tea.String("SourceDataSourceSettings"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.TableMappings)) {
		request.TableMappingsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.TableMappings, tea.String("TableMappings"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.TransformationRules)) {
		request.TransformationRulesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.TransformationRules, tea.String("TransformationRules"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.SystemDebug)) {
		query["SystemDebug"] = request.SystemDebug
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationDataSourceSettingsShrink)) {
		body["DestinationDataSourceSettings"] = request.DestinationDataSourceSettingsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationDataSourceType)) {
		body["DestinationDataSourceType"] = request.DestinationDataSourceType
	}

	if !tea.BoolValue(util.IsUnset(request.JobName)) {
		body["JobName"] = request.JobName
	}

	if !tea.BoolValue(util.IsUnset(request.JobSettingsShrink)) {
		body["JobSettings"] = request.JobSettingsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.MigrationType)) {
		body["MigrationType"] = request.MigrationType
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceSettingsShrink)) {
		body["ResourceSettings"] = request.ResourceSettingsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.SourceDataSourceSettingsShrink)) {
		body["SourceDataSourceSettings"] = request.SourceDataSourceSettingsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.SourceDataSourceType)) {
		body["SourceDataSourceType"] = request.SourceDataSourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TableMappingsShrink)) {
		body["TableMappings"] = request.TableMappingsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.TransformationRulesShrink)) {
		body["TransformationRules"] = request.TransformationRulesShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDIJob"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDIJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDIJob(request *CreateDIJobRequest) (_result *CreateDIJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDIJobResponse{}
	_body, _err := client.CreateDIJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * DataWorks allows you to use only the CreateDISyncTask operation to create a batch synchronization node in Data Integration. To create a real-time synchronization node or a synchronization solution, you must first call the [GenerateDISyncTaskConfigForCreating](~~383463~~) operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](~~383465~~) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the CreateDISyncTask operation and use the parameters as request parameters to create a real-time synchronization node or a synchronization solution in Data Integration.
 *
 * @param request CreateDISyncTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDISyncTaskResponse
 */
func (client *Client) CreateDISyncTaskWithOptions(request *CreateDISyncTaskRequest, runtime *util.RuntimeOptions) (_result *CreateDISyncTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskContent)) {
		query["TaskContent"] = request.TaskContent
	}

	if !tea.BoolValue(util.IsUnset(request.TaskName)) {
		query["TaskName"] = request.TaskName
	}

	if !tea.BoolValue(util.IsUnset(request.TaskParam)) {
		query["TaskParam"] = request.TaskParam
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDISyncTask"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDISyncTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * DataWorks allows you to use only the CreateDISyncTask operation to create a batch synchronization node in Data Integration. To create a real-time synchronization node or a synchronization solution, you must first call the [GenerateDISyncTaskConfigForCreating](~~383463~~) operation to generate the ID of an asynchronous thread and call the [QueryDISyncTaskConfigProcessResult](~~383465~~) operation to obtain the asynchronously generated parameters based on the ID. Then, you can call the CreateDISyncTask operation and use the parameters as request parameters to create a real-time synchronization node or a synchronization solution in Data Integration.
 *
 * @param request CreateDISyncTaskRequest
 * @return CreateDISyncTaskResponse
 */
func (client *Client) CreateDISyncTask(request *CreateDISyncTaskRequest) (_result *CreateDISyncTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDISyncTaskResponse{}
	_body, _err := client.CreateDISyncTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request CreateDagComplementRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDagComplementResponse
 */
// Deprecated
func (client *Client) CreateDagComplementWithOptions(request *CreateDagComplementRequest, runtime *util.RuntimeOptions) (_result *CreateDagComplementResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BizBeginTime)) {
		body["BizBeginTime"] = request.BizBeginTime
	}

	if !tea.BoolValue(util.IsUnset(request.BizEndTime)) {
		body["BizEndTime"] = request.BizEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.EndBizDate)) {
		body["EndBizDate"] = request.EndBizDate
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeNodeIds)) {
		body["ExcludeNodeIds"] = request.ExcludeNodeIds
	}

	if !tea.BoolValue(util.IsUnset(request.IncludeNodeIds)) {
		body["IncludeNodeIds"] = request.IncludeNodeIds
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NodeParams)) {
		body["NodeParams"] = request.NodeParams
	}

	if !tea.BoolValue(util.IsUnset(request.Parallelism)) {
		body["Parallelism"] = request.Parallelism
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	if !tea.BoolValue(util.IsUnset(request.RootNodeId)) {
		body["RootNodeId"] = request.RootNodeId
	}

	if !tea.BoolValue(util.IsUnset(request.StartBizDate)) {
		body["StartBizDate"] = request.StartBizDate
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDagComplement"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDagComplementResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request CreateDagComplementRequest
 * @return CreateDagComplementResponse
 */
// Deprecated
func (client *Client) CreateDagComplement(request *CreateDagComplementRequest) (_result *CreateDagComplementResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDagComplementResponse{}
	_body, _err := client.CreateDagComplementWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request CreateDagTestRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDagTestResponse
 */
// Deprecated
func (client *Client) CreateDagTestWithOptions(request *CreateDagTestRequest, runtime *util.RuntimeOptions) (_result *CreateDagTestResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bizdate)) {
		body["Bizdate"] = request.Bizdate
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.NodeParams)) {
		body["NodeParams"] = request.NodeParams
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDagTest"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDagTestResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request CreateDagTestRequest
 * @return CreateDagTestResponse
 */
// Deprecated
func (client *Client) CreateDagTest(request *CreateDagTestRequest) (_result *CreateDagTestResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDagTestResponse{}
	_body, _err := client.CreateDagTestWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDataServiceApiWithOptions(request *CreateDataServiceApiRequest, runtime *util.RuntimeOptions) (_result *CreateDataServiceApiResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiDescription)) {
		body["ApiDescription"] = request.ApiDescription
	}

	if !tea.BoolValue(util.IsUnset(request.ApiMode)) {
		body["ApiMode"] = request.ApiMode
	}

	if !tea.BoolValue(util.IsUnset(request.ApiName)) {
		body["ApiName"] = request.ApiName
	}

	if !tea.BoolValue(util.IsUnset(request.ApiPath)) {
		body["ApiPath"] = request.ApiPath
	}

	if !tea.BoolValue(util.IsUnset(request.FolderId)) {
		body["FolderId"] = request.FolderId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		body["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.Protocols)) {
		body["Protocols"] = request.Protocols
	}

	if !tea.BoolValue(util.IsUnset(request.RegistrationDetails)) {
		body["RegistrationDetails"] = request.RegistrationDetails
	}

	if !tea.BoolValue(util.IsUnset(request.RequestContentType)) {
		body["RequestContentType"] = request.RequestContentType
	}

	if !tea.BoolValue(util.IsUnset(request.RequestMethod)) {
		body["RequestMethod"] = request.RequestMethod
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		body["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResponseContentType)) {
		body["ResponseContentType"] = request.ResponseContentType
	}

	if !tea.BoolValue(util.IsUnset(request.ScriptDetails)) {
		body["ScriptDetails"] = request.ScriptDetails
	}

	if !tea.BoolValue(util.IsUnset(request.SqlMode)) {
		body["SqlMode"] = request.SqlMode
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		body["Timeout"] = request.Timeout
	}

	if !tea.BoolValue(util.IsUnset(request.VisibleRange)) {
		body["VisibleRange"] = request.VisibleRange
	}

	if !tea.BoolValue(util.IsUnset(request.WizardDetails)) {
		body["WizardDetails"] = request.WizardDetails
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDataServiceApi"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDataServiceApiResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDataServiceApi(request *CreateDataServiceApiRequest) (_result *CreateDataServiceApiResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDataServiceApiResponse{}
	_body, _err := client.CreateDataServiceApiWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDataServiceApiAuthorityWithOptions(request *CreateDataServiceApiAuthorityRequest, runtime *util.RuntimeOptions) (_result *CreateDataServiceApiAuthorityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiId)) {
		body["ApiId"] = request.ApiId
	}

	if !tea.BoolValue(util.IsUnset(request.AuthorizedProjectId)) {
		body["AuthorizedProjectId"] = request.AuthorizedProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		body["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDataServiceApiAuthority"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDataServiceApiAuthorityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDataServiceApiAuthority(request *CreateDataServiceApiAuthorityRequest) (_result *CreateDataServiceApiAuthorityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDataServiceApiAuthorityResponse{}
	_body, _err := client.CreateDataServiceApiAuthorityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDataServiceFolderWithOptions(request *CreateDataServiceFolderRequest, runtime *util.RuntimeOptions) (_result *CreateDataServiceFolderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FolderName)) {
		body["FolderName"] = request.FolderName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		body["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ParentId)) {
		body["ParentId"] = request.ParentId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDataServiceFolder"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDataServiceFolderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDataServiceFolder(request *CreateDataServiceFolderRequest) (_result *CreateDataServiceFolderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDataServiceFolderResponse{}
	_body, _err := client.CreateDataServiceFolderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDataServiceGroupWithOptions(request *CreateDataServiceGroupRequest, runtime *util.RuntimeOptions) (_result *CreateDataServiceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiGatewayGroupId)) {
		body["ApiGatewayGroupId"] = request.ApiGatewayGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		body["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDataServiceGroup"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDataServiceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDataServiceGroup(request *CreateDataServiceGroupRequest) (_result *CreateDataServiceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDataServiceGroupResponse{}
	_body, _err := client.CreateDataServiceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDataSourceWithOptions(request *CreateDataSourceRequest, runtime *util.RuntimeOptions) (_result *CreateDataSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Content)) {
		query["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.DataSourceType)) {
		query["DataSourceType"] = request.DataSourceType
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.SubType)) {
		query["SubType"] = request.SubType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDataSource"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDataSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDataSource(request *CreateDataSourceRequest) (_result *CreateDataSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDataSourceResponse{}
	_body, _err := client.CreateDataSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateExportMigrationWithOptions(request *CreateExportMigrationRequest, runtime *util.RuntimeOptions) (_result *CreateExportMigrationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.ExportMode)) {
		body["ExportMode"] = request.ExportMode
	}

	if !tea.BoolValue(util.IsUnset(request.ExportObjectStatus)) {
		body["ExportObjectStatus"] = request.ExportObjectStatus
	}

	if !tea.BoolValue(util.IsUnset(request.IncrementalSince)) {
		body["IncrementalSince"] = request.IncrementalSince
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateExportMigration"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateExportMigrationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateExportMigration(request *CreateExportMigrationRequest) (_result *CreateExportMigrationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateExportMigrationResponse{}
	_body, _err := client.CreateExportMigrationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateFileWithOptions(request *CreateFileRequest, runtime *util.RuntimeOptions) (_result *CreateFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdvancedSettings)) {
		body["AdvancedSettings"] = request.AdvancedSettings
	}

	if !tea.BoolValue(util.IsUnset(request.AutoParsing)) {
		body["AutoParsing"] = request.AutoParsing
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRerunIntervalMillis)) {
		body["AutoRerunIntervalMillis"] = request.AutoRerunIntervalMillis
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRerunTimes)) {
		body["AutoRerunTimes"] = request.AutoRerunTimes
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionName)) {
		body["ConnectionName"] = request.ConnectionName
	}

	if !tea.BoolValue(util.IsUnset(request.Content)) {
		body["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.CreateFolderIfNotExists)) {
		body["CreateFolderIfNotExists"] = request.CreateFolderIfNotExists
	}

	if !tea.BoolValue(util.IsUnset(request.CronExpress)) {
		body["CronExpress"] = request.CronExpress
	}

	if !tea.BoolValue(util.IsUnset(request.CycleType)) {
		body["CycleType"] = request.CycleType
	}

	if !tea.BoolValue(util.IsUnset(request.DependentNodeIdList)) {
		body["DependentNodeIdList"] = request.DependentNodeIdList
	}

	if !tea.BoolValue(util.IsUnset(request.DependentType)) {
		body["DependentType"] = request.DependentType
	}

	if !tea.BoolValue(util.IsUnset(request.EndEffectDate)) {
		body["EndEffectDate"] = request.EndEffectDate
	}

	if !tea.BoolValue(util.IsUnset(request.FileDescription)) {
		body["FileDescription"] = request.FileDescription
	}

	if !tea.BoolValue(util.IsUnset(request.FileFolderPath)) {
		body["FileFolderPath"] = request.FileFolderPath
	}

	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		body["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.FileType)) {
		body["FileType"] = request.FileType
	}

	if !tea.BoolValue(util.IsUnset(request.IgnoreParentSkipRunningProperty)) {
		body["IgnoreParentSkipRunningProperty"] = request.IgnoreParentSkipRunningProperty
	}

	if !tea.BoolValue(util.IsUnset(request.InputList)) {
		body["InputList"] = request.InputList
	}

	if !tea.BoolValue(util.IsUnset(request.InputParameters)) {
		body["InputParameters"] = request.InputParameters
	}

	if !tea.BoolValue(util.IsUnset(request.OutputParameters)) {
		body["OutputParameters"] = request.OutputParameters
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.ParaValue)) {
		body["ParaValue"] = request.ParaValue
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.RerunMode)) {
		body["RerunMode"] = request.RerunMode
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		body["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupIdentifier)) {
		body["ResourceGroupIdentifier"] = request.ResourceGroupIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.SchedulerType)) {
		body["SchedulerType"] = request.SchedulerType
	}

	if !tea.BoolValue(util.IsUnset(request.StartEffectDate)) {
		body["StartEffectDate"] = request.StartEffectDate
	}

	if !tea.BoolValue(util.IsUnset(request.StartImmediately)) {
		body["StartImmediately"] = request.StartImmediately
	}

	if !tea.BoolValue(util.IsUnset(request.Stop)) {
		body["Stop"] = request.Stop
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateFile"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateFile(request *CreateFileRequest) (_result *CreateFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateFileResponse{}
	_body, _err := client.CreateFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateFolderWithOptions(request *CreateFolderRequest, runtime *util.RuntimeOptions) (_result *CreateFolderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FolderPath)) {
		body["FolderPath"] = request.FolderPath
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateFolder"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateFolderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateFolder(request *CreateFolderRequest) (_result *CreateFolderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateFolderResponse{}
	_body, _err := client.CreateFolderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The import package must be uploaded. Example of the upload method:
 * Config config = new Config();
 * config.setAccessKeyId(accessId);
 * config.setAccessKeySecret(accessKey);
 * config.setEndpoint(popEndpoint);
 * config.setRegionId(regionId);
 * Client client = new Client(config);
 * CreateImportMigrationAdvanceRequest request = new CreateImportMigrationAdvanceRequest();
 * request.setName("test_migration_api\\_" + System.currentTimeMillis());
 * request.setProjectId(123456L);
 * request.setPackageType("DATAWORKS_MODEL");
 * request.setPackageFileObject(new FileInputStream("/home/admin/Downloads/test.zip"));
 * RuntimeOptions runtime = new RuntimeOptions();
 * CreateImportMigrationResponse response = client.createImportMigrationAdvance(request, runtime);
 * ...
 *
 * @param request CreateImportMigrationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateImportMigrationResponse
 */
func (client *Client) CreateImportMigrationWithOptions(request *CreateImportMigrationRequest, runtime *util.RuntimeOptions) (_result *CreateImportMigrationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CalculateEngineMap)) {
		body["CalculateEngineMap"] = request.CalculateEngineMap
	}

	if !tea.BoolValue(util.IsUnset(request.CommitRule)) {
		body["CommitRule"] = request.CommitRule
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PackageFile)) {
		body["PackageFile"] = request.PackageFile
	}

	if !tea.BoolValue(util.IsUnset(request.PackageType)) {
		body["PackageType"] = request.PackageType
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupMap)) {
		body["ResourceGroupMap"] = request.ResourceGroupMap
	}

	if !tea.BoolValue(util.IsUnset(request.WorkspaceMap)) {
		body["WorkspaceMap"] = request.WorkspaceMap
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateImportMigration"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateImportMigrationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The import package must be uploaded. Example of the upload method:
 * Config config = new Config();
 * config.setAccessKeyId(accessId);
 * config.setAccessKeySecret(accessKey);
 * config.setEndpoint(popEndpoint);
 * config.setRegionId(regionId);
 * Client client = new Client(config);
 * CreateImportMigrationAdvanceRequest request = new CreateImportMigrationAdvanceRequest();
 * request.setName("test_migration_api\\_" + System.currentTimeMillis());
 * request.setProjectId(123456L);
 * request.setPackageType("DATAWORKS_MODEL");
 * request.setPackageFileObject(new FileInputStream("/home/admin/Downloads/test.zip"));
 * RuntimeOptions runtime = new RuntimeOptions();
 * CreateImportMigrationResponse response = client.createImportMigrationAdvance(request, runtime);
 * ...
 *
 * @param request CreateImportMigrationRequest
 * @return CreateImportMigrationResponse
 */
func (client *Client) CreateImportMigration(request *CreateImportMigrationRequest) (_result *CreateImportMigrationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateImportMigrationResponse{}
	_body, _err := client.CreateImportMigrationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateImportMigrationAdvance(request *CreateImportMigrationAdvanceRequest, runtime *util.RuntimeOptions) (_result *CreateImportMigrationResponse, _err error) {
	// Step 0: init client
	accessKeyId, _err := client.Credential.GetAccessKeyId()
	if _err != nil {
		return _result, _err
	}

	accessKeySecret, _err := client.Credential.GetAccessKeySecret()
	if _err != nil {
		return _result, _err
	}

	securityToken, _err := client.Credential.GetSecurityToken()
	if _err != nil {
		return _result, _err
	}

	credentialType := client.Credential.GetType()
	openPlatformEndpoint := client.OpenPlatformEndpoint
	if tea.BoolValue(util.IsUnset(openPlatformEndpoint)) {
		openPlatformEndpoint = tea.String("openplatform.aliyuncs.com")
	}

	if tea.BoolValue(util.IsUnset(credentialType)) {
		credentialType = tea.String("access_key")
	}

	authConfig := &openapi.Config{
		AccessKeyId:     accessKeyId,
		AccessKeySecret: accessKeySecret,
		SecurityToken:   securityToken,
		Type:            credentialType,
		Endpoint:        openPlatformEndpoint,
		Protocol:        client.Protocol,
		RegionId:        client.RegionId,
	}
	authClient, _err := openplatform.NewClient(authConfig)
	if _err != nil {
		return _result, _err
	}

	authRequest := &openplatform.AuthorizeFileUploadRequest{
		Product:  tea.String("dataworks-public"),
		RegionId: client.RegionId,
	}
	authResponse := &openplatform.AuthorizeFileUploadResponse{}
	ossConfig := &oss.Config{
		AccessKeySecret: accessKeySecret,
		Type:            tea.String("access_key"),
		Protocol:        client.Protocol,
		RegionId:        client.RegionId,
	}
	var ossClient *oss.Client
	fileObj := &fileform.FileField{}
	ossHeader := &oss.PostObjectRequestHeader{}
	uploadRequest := &oss.PostObjectRequest{}
	ossRuntime := &ossutil.RuntimeOptions{}
	openapiutil.Convert(runtime, ossRuntime)
	createImportMigrationReq := &CreateImportMigrationRequest{}
	openapiutil.Convert(request, createImportMigrationReq)
	if !tea.BoolValue(util.IsUnset(request.PackageFileObject)) {
		authResponse, _err = authClient.AuthorizeFileUploadWithOptions(authRequest, runtime)
		if _err != nil {
			return _result, _err
		}

		ossConfig.AccessKeyId = authResponse.Body.AccessKeyId
		ossConfig.Endpoint = openapiutil.GetEndpoint(authResponse.Body.Endpoint, authResponse.Body.UseAccelerate, client.EndpointType)
		ossClient, _err = oss.NewClient(ossConfig)
		if _err != nil {
			return _result, _err
		}

		fileObj = &fileform.FileField{
			Filename:    authResponse.Body.ObjectKey,
			Content:     request.PackageFileObject,
			ContentType: tea.String(""),
		}
		ossHeader = &oss.PostObjectRequestHeader{
			AccessKeyId:         authResponse.Body.AccessKeyId,
			Policy:              authResponse.Body.EncodedPolicy,
			Signature:           authResponse.Body.Signature,
			Key:                 authResponse.Body.ObjectKey,
			File:                fileObj,
			SuccessActionStatus: tea.String("201"),
		}
		uploadRequest = &oss.PostObjectRequest{
			BucketName: authResponse.Body.Bucket,
			Header:     ossHeader,
		}
		_, _err = ossClient.PostObject(uploadRequest, ossRuntime)
		if _err != nil {
			return _result, _err
		}
		createImportMigrationReq.PackageFile = tea.String("http://" + tea.StringValue(authResponse.Body.Bucket) + "." + tea.StringValue(authResponse.Body.Endpoint) + "/" + tea.StringValue(authResponse.Body.ObjectKey))
	}

	createImportMigrationResp, _err := client.CreateImportMigrationWithOptions(createImportMigrationReq, runtime)
	if _err != nil {
		return _result, _err
	}

	_result = createImportMigrationResp
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request CreateManualDagRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateManualDagResponse
 */
// Deprecated
func (client *Client) CreateManualDagWithOptions(request *CreateManualDagRequest, runtime *util.RuntimeOptions) (_result *CreateManualDagResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BizDate)) {
		body["BizDate"] = request.BizDate
	}

	if !tea.BoolValue(util.IsUnset(request.DagParameters)) {
		body["DagParameters"] = request.DagParameters
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeNodeIds)) {
		body["ExcludeNodeIds"] = request.ExcludeNodeIds
	}

	if !tea.BoolValue(util.IsUnset(request.FlowName)) {
		body["FlowName"] = request.FlowName
	}

	if !tea.BoolValue(util.IsUnset(request.IncludeNodeIds)) {
		body["IncludeNodeIds"] = request.IncludeNodeIds
	}

	if !tea.BoolValue(util.IsUnset(request.NodeParameters)) {
		body["NodeParameters"] = request.NodeParameters
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateManualDag"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateManualDagResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request CreateManualDagRequest
 * @return CreateManualDagResponse
 */
// Deprecated
func (client *Client) CreateManualDag(request *CreateManualDagRequest) (_result *CreateManualDagResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateManualDagResponse{}
	_body, _err := client.CreateManualDagWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateMetaCategoryWithOptions(request *CreateMetaCategoryRequest, runtime *util.RuntimeOptions) (_result *CreateMetaCategoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		body["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ParentId)) {
		body["ParentId"] = request.ParentId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateMetaCategory"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateMetaCategoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateMetaCategory(request *CreateMetaCategoryRequest) (_result *CreateMetaCategoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateMetaCategoryResponse{}
	_body, _err := client.CreateMetaCategoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * A category must belong to a data album.
 * You can create a category in a data album only after you create the data album. You can set the value of the parentQualifiedName parameter to the unique identifier of the data album to create the category.
 *
 * @param request CreateMetaCollectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMetaCollectionResponse
 */
func (client *Client) CreateMetaCollectionWithOptions(request *CreateMetaCollectionRequest, runtime *util.RuntimeOptions) (_result *CreateMetaCollectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CollectionType)) {
		query["CollectionType"] = request.CollectionType
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ParentQualifiedName)) {
		query["ParentQualifiedName"] = request.ParentQualifiedName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateMetaCollection"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateMetaCollectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * A category must belong to a data album.
 * You can create a category in a data album only after you create the data album. You can set the value of the parentQualifiedName parameter to the unique identifier of the data album to create the category.
 *
 * @param request CreateMetaCollectionRequest
 * @return CreateMetaCollectionResponse
 */
func (client *Client) CreateMetaCollection(request *CreateMetaCollectionRequest) (_result *CreateMetaCollectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateMetaCollectionResponse{}
	_body, _err := client.CreateMetaCollectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreatePermissionApplyOrderWithOptions(request *CreatePermissionApplyOrderRequest, runtime *util.RuntimeOptions) (_result *CreatePermissionApplyOrderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApplyObject)) {
		query["ApplyObject"] = request.ApplyObject
	}

	if !tea.BoolValue(util.IsUnset(request.ApplyReason)) {
		query["ApplyReason"] = request.ApplyReason
	}

	if !tea.BoolValue(util.IsUnset(request.ApplyUserIds)) {
		query["ApplyUserIds"] = request.ApplyUserIds
	}

	if !tea.BoolValue(util.IsUnset(request.Deadline)) {
		query["Deadline"] = request.Deadline
	}

	if !tea.BoolValue(util.IsUnset(request.EngineType)) {
		query["EngineType"] = request.EngineType
	}

	if !tea.BoolValue(util.IsUnset(request.MaxComputeProjectName)) {
		query["MaxComputeProjectName"] = request.MaxComputeProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.OrderType)) {
		query["OrderType"] = request.OrderType
	}

	if !tea.BoolValue(util.IsUnset(request.WorkspaceId)) {
		query["WorkspaceId"] = request.WorkspaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreatePermissionApplyOrder"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreatePermissionApplyOrderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreatePermissionApplyOrder(request *CreatePermissionApplyOrderRequest) (_result *CreatePermissionApplyOrderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreatePermissionApplyOrderResponse{}
	_body, _err := client.CreatePermissionApplyOrderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateProjectWithOptions(tmpReq *CreateProjectRequest, runtime *util.RuntimeOptions) (_result *CreateProjectResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateProjectShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Tags)) {
		request.TagsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tags, tea.String("Tags"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.DisableDevelopment)) {
		query["DisableDevelopment"] = request.DisableDevelopment
	}

	if !tea.BoolValue(util.IsUnset(request.IsAllowDownload)) {
		query["IsAllowDownload"] = request.IsAllowDownload
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectDescription)) {
		query["ProjectDescription"] = request.ProjectDescription
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		query["ProjectIdentifier"] = request.ProjectIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectMode)) {
		query["ProjectMode"] = request.ProjectMode
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		query["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceManagerResourceGroupId)) {
		query["ResourceManagerResourceGroupId"] = request.ResourceManagerResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TagsShrink)) {
		query["Tags"] = request.TagsShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateProject"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateProjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateProject(request *CreateProjectRequest) (_result *CreateProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateProjectResponse{}
	_body, _err := client.CreateProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateProjectMemberWithOptions(request *CreateProjectMemberRequest, runtime *util.RuntimeOptions) (_result *CreateProjectMemberResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.RoleCode)) {
		query["RoleCode"] = request.RoleCode
	}

	if !tea.BoolValue(util.IsUnset(request.UserId)) {
		query["UserId"] = request.UserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateProjectMember"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateProjectMemberResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateProjectMember(request *CreateProjectMemberRequest) (_result *CreateProjectMemberResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateProjectMemberResponse{}
	_body, _err := client.CreateProjectMemberWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateQualityEntityWithOptions(request *CreateQualityEntityRequest, runtime *util.RuntimeOptions) (_result *CreateQualityEntityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EntityLevel)) {
		body["EntityLevel"] = request.EntityLevel
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		body["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.MatchExpression)) {
		body["MatchExpression"] = request.MatchExpression
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		body["TableName"] = request.TableName
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateQualityEntity"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateQualityEntityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateQualityEntity(request *CreateQualityEntityRequest) (_result *CreateQualityEntityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateQualityEntityResponse{}
	_body, _err := client.CreateQualityEntityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateQualityFollowerWithOptions(request *CreateQualityFollowerRequest, runtime *util.RuntimeOptions) (_result *CreateQualityFollowerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmMode)) {
		body["AlarmMode"] = request.AlarmMode
	}

	if !tea.BoolValue(util.IsUnset(request.EntityId)) {
		body["EntityId"] = request.EntityId
	}

	if !tea.BoolValue(util.IsUnset(request.Follower)) {
		body["Follower"] = request.Follower
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateQualityFollower"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateQualityFollowerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateQualityFollower(request *CreateQualityFollowerRequest) (_result *CreateQualityFollowerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateQualityFollowerResponse{}
	_body, _err := client.CreateQualityFollowerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateQualityRelativeNodeWithOptions(request *CreateQualityRelativeNodeRequest, runtime *util.RuntimeOptions) (_result *CreateQualityRelativeNodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		body["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.MatchExpression)) {
		body["MatchExpression"] = request.MatchExpression
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		body["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.TargetNodeProjectId)) {
		body["TargetNodeProjectId"] = request.TargetNodeProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetNodeProjectName)) {
		body["TargetNodeProjectName"] = request.TargetNodeProjectName
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateQualityRelativeNode"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateQualityRelativeNodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateQualityRelativeNode(request *CreateQualityRelativeNodeRequest) (_result *CreateQualityRelativeNodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateQualityRelativeNodeResponse{}
	_body, _err := client.CreateQualityRelativeNodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateQualityRuleWithOptions(request *CreateQualityRuleRequest, runtime *util.RuntimeOptions) (_result *CreateQualityRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BlockType)) {
		body["BlockType"] = request.BlockType
	}

	if !tea.BoolValue(util.IsUnset(request.Checker)) {
		body["Checker"] = request.Checker
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		body["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.CriticalThreshold)) {
		body["CriticalThreshold"] = request.CriticalThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.EntityId)) {
		body["EntityId"] = request.EntityId
	}

	if !tea.BoolValue(util.IsUnset(request.ExpectValue)) {
		body["ExpectValue"] = request.ExpectValue
	}

	if !tea.BoolValue(util.IsUnset(request.MethodName)) {
		body["MethodName"] = request.MethodName
	}

	if !tea.BoolValue(util.IsUnset(request.Operator)) {
		body["Operator"] = request.Operator
	}

	if !tea.BoolValue(util.IsUnset(request.PredictType)) {
		body["PredictType"] = request.PredictType
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.Property)) {
		body["Property"] = request.Property
	}

	if !tea.BoolValue(util.IsUnset(request.PropertyType)) {
		body["PropertyType"] = request.PropertyType
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		body["RuleName"] = request.RuleName
	}

	if !tea.BoolValue(util.IsUnset(request.RuleType)) {
		body["RuleType"] = request.RuleType
	}

	if !tea.BoolValue(util.IsUnset(request.TaskSetting)) {
		body["TaskSetting"] = request.TaskSetting
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		body["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.Trend)) {
		body["Trend"] = request.Trend
	}

	if !tea.BoolValue(util.IsUnset(request.WarningThreshold)) {
		body["WarningThreshold"] = request.WarningThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.WhereCondition)) {
		body["WhereCondition"] = request.WhereCondition
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateQualityRule"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateQualityRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateQualityRule(request *CreateQualityRuleRequest) (_result *CreateQualityRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateQualityRuleResponse{}
	_body, _err := client.CreateQualityRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateRemindWithOptions(request *CreateRemindRequest, runtime *util.RuntimeOptions) (_result *CreateRemindResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertInterval)) {
		body["AlertInterval"] = request.AlertInterval
	}

	if !tea.BoolValue(util.IsUnset(request.AlertMethods)) {
		body["AlertMethods"] = request.AlertMethods
	}

	if !tea.BoolValue(util.IsUnset(request.AlertTargets)) {
		body["AlertTargets"] = request.AlertTargets
	}

	if !tea.BoolValue(util.IsUnset(request.AlertUnit)) {
		body["AlertUnit"] = request.AlertUnit
	}

	if !tea.BoolValue(util.IsUnset(request.BaselineIds)) {
		body["BaselineIds"] = request.BaselineIds
	}

	if !tea.BoolValue(util.IsUnset(request.BizProcessIds)) {
		body["BizProcessIds"] = request.BizProcessIds
	}

	if !tea.BoolValue(util.IsUnset(request.Detail)) {
		body["Detail"] = request.Detail
	}

	if !tea.BoolValue(util.IsUnset(request.DndEnd)) {
		body["DndEnd"] = request.DndEnd
	}

	if !tea.BoolValue(util.IsUnset(request.MaxAlertTimes)) {
		body["MaxAlertTimes"] = request.MaxAlertTimes
	}

	if !tea.BoolValue(util.IsUnset(request.NodeIds)) {
		body["NodeIds"] = request.NodeIds
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.RemindName)) {
		body["RemindName"] = request.RemindName
	}

	if !tea.BoolValue(util.IsUnset(request.RemindType)) {
		body["RemindType"] = request.RemindType
	}

	if !tea.BoolValue(util.IsUnset(request.RemindUnit)) {
		body["RemindUnit"] = request.RemindUnit
	}

	if !tea.BoolValue(util.IsUnset(request.RobotUrls)) {
		body["RobotUrls"] = request.RobotUrls
	}

	if !tea.BoolValue(util.IsUnset(request.Webhooks)) {
		body["Webhooks"] = request.Webhooks
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateRemind"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateRemindResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateRemind(request *CreateRemindRequest) (_result *CreateRemindResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateRemindResponse{}
	_body, _err := client.CreateRemindWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateResourceFileWithOptions(request *CreateResourceFileRequest, runtime *util.RuntimeOptions) (_result *CreateResourceFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Content)) {
		body["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.FileDescription)) {
		body["FileDescription"] = request.FileDescription
	}

	if !tea.BoolValue(util.IsUnset(request.FileFolderPath)) {
		body["FileFolderPath"] = request.FileFolderPath
	}

	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		body["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.FileType)) {
		body["FileType"] = request.FileType
	}

	if !tea.BoolValue(util.IsUnset(request.OriginResourceName)) {
		body["OriginResourceName"] = request.OriginResourceName
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.RegisterToCalcEngine)) {
		body["RegisterToCalcEngine"] = request.RegisterToCalcEngine
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceFile)) {
		body["ResourceFile"] = request.ResourceFile
	}

	if !tea.BoolValue(util.IsUnset(request.StorageURL)) {
		body["StorageURL"] = request.StorageURL
	}

	if !tea.BoolValue(util.IsUnset(request.UploadMode)) {
		body["UploadMode"] = request.UploadMode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateResourceFile"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateResourceFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateResourceFile(request *CreateResourceFileRequest) (_result *CreateResourceFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateResourceFileResponse{}
	_body, _err := client.CreateResourceFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateResourceFileAdvance(request *CreateResourceFileAdvanceRequest, runtime *util.RuntimeOptions) (_result *CreateResourceFileResponse, _err error) {
	// Step 0: init client
	accessKeyId, _err := client.Credential.GetAccessKeyId()
	if _err != nil {
		return _result, _err
	}

	accessKeySecret, _err := client.Credential.GetAccessKeySecret()
	if _err != nil {
		return _result, _err
	}

	securityToken, _err := client.Credential.GetSecurityToken()
	if _err != nil {
		return _result, _err
	}

	credentialType := client.Credential.GetType()
	openPlatformEndpoint := client.OpenPlatformEndpoint
	if tea.BoolValue(util.IsUnset(openPlatformEndpoint)) {
		openPlatformEndpoint = tea.String("openplatform.aliyuncs.com")
	}

	if tea.BoolValue(util.IsUnset(credentialType)) {
		credentialType = tea.String("access_key")
	}

	authConfig := &openapi.Config{
		AccessKeyId:     accessKeyId,
		AccessKeySecret: accessKeySecret,
		SecurityToken:   securityToken,
		Type:            credentialType,
		Endpoint:        openPlatformEndpoint,
		Protocol:        client.Protocol,
		RegionId:        client.RegionId,
	}
	authClient, _err := openplatform.NewClient(authConfig)
	if _err != nil {
		return _result, _err
	}

	authRequest := &openplatform.AuthorizeFileUploadRequest{
		Product:  tea.String("dataworks-public"),
		RegionId: client.RegionId,
	}
	authResponse := &openplatform.AuthorizeFileUploadResponse{}
	ossConfig := &oss.Config{
		AccessKeySecret: accessKeySecret,
		Type:            tea.String("access_key"),
		Protocol:        client.Protocol,
		RegionId:        client.RegionId,
	}
	var ossClient *oss.Client
	fileObj := &fileform.FileField{}
	ossHeader := &oss.PostObjectRequestHeader{}
	uploadRequest := &oss.PostObjectRequest{}
	ossRuntime := &ossutil.RuntimeOptions{}
	openapiutil.Convert(runtime, ossRuntime)
	createResourceFileReq := &CreateResourceFileRequest{}
	openapiutil.Convert(request, createResourceFileReq)
	if !tea.BoolValue(util.IsUnset(request.ResourceFileObject)) {
		authResponse, _err = authClient.AuthorizeFileUploadWithOptions(authRequest, runtime)
		if _err != nil {
			return _result, _err
		}

		ossConfig.AccessKeyId = authResponse.Body.AccessKeyId
		ossConfig.Endpoint = openapiutil.GetEndpoint(authResponse.Body.Endpoint, authResponse.Body.UseAccelerate, client.EndpointType)
		ossClient, _err = oss.NewClient(ossConfig)
		if _err != nil {
			return _result, _err
		}

		fileObj = &fileform.FileField{
			Filename:    authResponse.Body.ObjectKey,
			Content:     request.ResourceFileObject,
			ContentType: tea.String(""),
		}
		ossHeader = &oss.PostObjectRequestHeader{
			AccessKeyId:         authResponse.Body.AccessKeyId,
			Policy:              authResponse.Body.EncodedPolicy,
			Signature:           authResponse.Body.Signature,
			Key:                 authResponse.Body.ObjectKey,
			File:                fileObj,
			SuccessActionStatus: tea.String("201"),
		}
		uploadRequest = &oss.PostObjectRequest{
			BucketName: authResponse.Body.Bucket,
			Header:     ossHeader,
		}
		_, _err = ossClient.PostObject(uploadRequest, ossRuntime)
		if _err != nil {
			return _result, _err
		}
		createResourceFileReq.ResourceFile = tea.String("http://" + tea.StringValue(authResponse.Body.Bucket) + "." + tea.StringValue(authResponse.Body.Endpoint) + "/" + tea.StringValue(authResponse.Body.ObjectKey))
	}

	createResourceFileResp, _err := client.CreateResourceFileWithOptions(createResourceFileReq, runtime)
	if _err != nil {
		return _result, _err
	}

	_result = createResourceFileResp
	return _result, _err
}

func (client *Client) CreateTableWithOptions(request *CreateTableRequest, runtime *util.RuntimeOptions) (_result *CreateTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppGuid)) {
		query["AppGuid"] = request.AppGuid
	}

	if !tea.BoolValue(util.IsUnset(request.CategoryId)) {
		query["CategoryId"] = request.CategoryId
	}

	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.ExternalTableType)) {
		query["ExternalTableType"] = request.ExternalTableType
	}

	if !tea.BoolValue(util.IsUnset(request.HasPart)) {
		query["HasPart"] = request.HasPart
	}

	if !tea.BoolValue(util.IsUnset(request.IsView)) {
		query["IsView"] = request.IsView
	}

	if !tea.BoolValue(util.IsUnset(request.LifeCycle)) {
		query["LifeCycle"] = request.LifeCycle
	}

	if !tea.BoolValue(util.IsUnset(request.Location)) {
		query["Location"] = request.Location
	}

	if !tea.BoolValue(util.IsUnset(request.LogicalLevelId)) {
		query["LogicalLevelId"] = request.LogicalLevelId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PhysicsLevelId)) {
		query["PhysicsLevelId"] = request.PhysicsLevelId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.Schema)) {
		query["Schema"] = request.Schema
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.Visibility)) {
		query["Visibility"] = request.Visibility
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Columns)) {
		body["Columns"] = request.Columns
	}

	if !tea.BoolValue(util.IsUnset(request.Endpoint)) {
		body["Endpoint"] = request.Endpoint
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		body["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.Themes)) {
		body["Themes"] = request.Themes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTable"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateTable(request *CreateTableRequest) (_result *CreateTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTableResponse{}
	_body, _err := client.CreateTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateTableLevelWithOptions(request *CreateTableLevelRequest, runtime *util.RuntimeOptions) (_result *CreateTableLevelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.LevelType)) {
		query["LevelType"] = request.LevelType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTableLevel"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTableLevelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateTableLevel(request *CreateTableLevelRequest) (_result *CreateTableLevelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTableLevelResponse{}
	_body, _err := client.CreateTableLevelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateTableThemeWithOptions(request *CreateTableThemeRequest, runtime *util.RuntimeOptions) (_result *CreateTableThemeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Level)) {
		query["Level"] = request.Level
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ParentId)) {
		query["ParentId"] = request.ParentId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTableTheme"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTableThemeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateTableTheme(request *CreateTableThemeRequest) (_result *CreateTableThemeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTableThemeResponse{}
	_body, _err := client.CreateTableThemeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateUdfFileWithOptions(request *CreateUdfFileRequest, runtime *util.RuntimeOptions) (_result *CreateUdfFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClassName)) {
		body["ClassName"] = request.ClassName
	}

	if !tea.BoolValue(util.IsUnset(request.CmdDescription)) {
		body["CmdDescription"] = request.CmdDescription
	}

	if !tea.BoolValue(util.IsUnset(request.CreateFolderIfNotExists)) {
		body["CreateFolderIfNotExists"] = request.CreateFolderIfNotExists
	}

	if !tea.BoolValue(util.IsUnset(request.Example)) {
		body["Example"] = request.Example
	}

	if !tea.BoolValue(util.IsUnset(request.FileFolderPath)) {
		body["FileFolderPath"] = request.FileFolderPath
	}

	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		body["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionType)) {
		body["FunctionType"] = request.FunctionType
	}

	if !tea.BoolValue(util.IsUnset(request.ParameterDescription)) {
		body["ParameterDescription"] = request.ParameterDescription
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.Resources)) {
		body["Resources"] = request.Resources
	}

	if !tea.BoolValue(util.IsUnset(request.ReturnValue)) {
		body["ReturnValue"] = request.ReturnValue
	}

	if !tea.BoolValue(util.IsUnset(request.UdfDescription)) {
		body["UdfDescription"] = request.UdfDescription
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateUdfFile"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateUdfFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateUdfFile(request *CreateUdfFileRequest) (_result *CreateUdfFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateUdfFileResponse{}
	_body, _err := client.CreateUdfFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteBaselineWithOptions(request *DeleteBaselineRequest, runtime *util.RuntimeOptions) (_result *DeleteBaselineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BaselineId)) {
		body["BaselineId"] = request.BaselineId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteBaseline"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteBaselineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteBaseline(request *DeleteBaselineRequest) (_result *DeleteBaselineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteBaselineResponse{}
	_body, _err := client.DeleteBaselineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteBusinessWithOptions(request *DeleteBusinessRequest, runtime *util.RuntimeOptions) (_result *DeleteBusinessResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BusinessId)) {
		body["BusinessId"] = request.BusinessId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteBusiness"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteBusinessResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteBusiness(request *DeleteBusinessRequest) (_result *DeleteBusinessResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteBusinessResponse{}
	_body, _err := client.DeleteBusinessWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DeleteConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConnectionResponse
 */
// Deprecated
func (client *Client) DeleteConnectionWithOptions(request *DeleteConnectionRequest, runtime *util.RuntimeOptions) (_result *DeleteConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConnectionId)) {
		query["ConnectionId"] = request.ConnectionId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteConnection"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request DeleteConnectionRequest
 * @return DeleteConnectionResponse
 */
// Deprecated
func (client *Client) DeleteConnection(request *DeleteConnectionRequest) (_result *DeleteConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteConnectionResponse{}
	_body, _err := client.DeleteConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDIAlarmRuleWithOptions(request *DeleteDIAlarmRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteDIAlarmRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DIAlarmRuleId)) {
		body["DIAlarmRuleId"] = request.DIAlarmRuleId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDIAlarmRule"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDIAlarmRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDIAlarmRule(request *DeleteDIAlarmRuleRequest) (_result *DeleteDIAlarmRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDIAlarmRuleResponse{}
	_body, _err := client.DeleteDIAlarmRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDIJobWithOptions(request *DeleteDIJobRequest, runtime *util.RuntimeOptions) (_result *DeleteDIJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DIJobId)) {
		body["DIJobId"] = request.DIJobId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDIJob"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDIJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDIJob(request *DeleteDIJobRequest) (_result *DeleteDIJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDIJobResponse{}
	_body, _err := client.DeleteDIJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDISyncTaskWithOptions(request *DeleteDISyncTaskRequest, runtime *util.RuntimeOptions) (_result *DeleteDISyncTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDISyncTask"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDISyncTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDISyncTask(request *DeleteDISyncTaskRequest) (_result *DeleteDISyncTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDISyncTaskResponse{}
	_body, _err := client.DeleteDISyncTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDataServiceApiWithOptions(request *DeleteDataServiceApiRequest, runtime *util.RuntimeOptions) (_result *DeleteDataServiceApiResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiId)) {
		body["ApiId"] = request.ApiId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDataServiceApi"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDataServiceApiResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDataServiceApi(request *DeleteDataServiceApiRequest) (_result *DeleteDataServiceApiResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDataServiceApiResponse{}
	_body, _err := client.DeleteDataServiceApiWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDataServiceApiAuthorityWithOptions(request *DeleteDataServiceApiAuthorityRequest, runtime *util.RuntimeOptions) (_result *DeleteDataServiceApiAuthorityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiId)) {
		body["ApiId"] = request.ApiId
	}

	if !tea.BoolValue(util.IsUnset(request.AuthorizedProjectId)) {
		body["AuthorizedProjectId"] = request.AuthorizedProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDataServiceApiAuthority"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDataServiceApiAuthorityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDataServiceApiAuthority(request *DeleteDataServiceApiAuthorityRequest) (_result *DeleteDataServiceApiAuthorityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDataServiceApiAuthorityResponse{}
	_body, _err := client.DeleteDataServiceApiAuthorityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDataSourceWithOptions(request *DeleteDataSourceRequest, runtime *util.RuntimeOptions) (_result *DeleteDataSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataSourceId)) {
		query["DataSourceId"] = request.DataSourceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDataSource"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDataSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDataSource(request *DeleteDataSourceRequest) (_result *DeleteDataSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDataSourceResponse{}
	_body, _err := client.DeleteDataSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteFileWithOptions(request *DeleteFileRequest, runtime *util.RuntimeOptions) (_result *DeleteFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		body["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteFile"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteFile(request *DeleteFileRequest) (_result *DeleteFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteFileResponse{}
	_body, _err := client.DeleteFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteFolderWithOptions(request *DeleteFolderRequest, runtime *util.RuntimeOptions) (_result *DeleteFolderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FolderId)) {
		body["FolderId"] = request.FolderId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteFolder"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteFolderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteFolder(request *DeleteFolderRequest) (_result *DeleteFolderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteFolderResponse{}
	_body, _err := client.DeleteFolderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteFromMetaCategoryWithOptions(request *DeleteFromMetaCategoryRequest, runtime *util.RuntimeOptions) (_result *DeleteFromMetaCategoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CategoryId)) {
		query["CategoryId"] = request.CategoryId
	}

	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteFromMetaCategory"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteFromMetaCategoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteFromMetaCategory(request *DeleteFromMetaCategoryRequest) (_result *DeleteFromMetaCategoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteFromMetaCategoryResponse{}
	_body, _err := client.DeleteFromMetaCategoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteLineageRelationWithOptions(request *DeleteLineageRelationRequest, runtime *util.RuntimeOptions) (_result *DeleteLineageRelationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DestEntityQualifiedName)) {
		query["DestEntityQualifiedName"] = request.DestEntityQualifiedName
	}

	if !tea.BoolValue(util.IsUnset(request.RelationshipGuid)) {
		query["RelationshipGuid"] = request.RelationshipGuid
	}

	if !tea.BoolValue(util.IsUnset(request.SrcEntityQualifiedName)) {
		query["SrcEntityQualifiedName"] = request.SrcEntityQualifiedName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteLineageRelation"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteLineageRelationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteLineageRelation(request *DeleteLineageRelationRequest) (_result *DeleteLineageRelationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteLineageRelationResponse{}
	_body, _err := client.DeleteLineageRelationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteMetaCategoryWithOptions(request *DeleteMetaCategoryRequest, runtime *util.RuntimeOptions) (_result *DeleteMetaCategoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteMetaCategory"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteMetaCategoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteMetaCategory(request *DeleteMetaCategoryRequest) (_result *DeleteMetaCategoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteMetaCategoryResponse{}
	_body, _err := client.DeleteMetaCategoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteMetaCollectionWithOptions(request *DeleteMetaCollectionRequest, runtime *util.RuntimeOptions) (_result *DeleteMetaCollectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.QualifiedName)) {
		query["QualifiedName"] = request.QualifiedName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteMetaCollection"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteMetaCollectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteMetaCollection(request *DeleteMetaCollectionRequest) (_result *DeleteMetaCollectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteMetaCollectionResponse{}
	_body, _err := client.DeleteMetaCollectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteMetaCollectionEntityWithOptions(request *DeleteMetaCollectionEntityRequest, runtime *util.RuntimeOptions) (_result *DeleteMetaCollectionEntityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CollectionQualifiedName)) {
		query["CollectionQualifiedName"] = request.CollectionQualifiedName
	}

	if !tea.BoolValue(util.IsUnset(request.EntityQualifiedName)) {
		query["EntityQualifiedName"] = request.EntityQualifiedName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteMetaCollectionEntity"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteMetaCollectionEntityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteMetaCollectionEntity(request *DeleteMetaCollectionEntityRequest) (_result *DeleteMetaCollectionEntityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteMetaCollectionEntityResponse{}
	_body, _err := client.DeleteMetaCollectionEntityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteProjectMemberWithOptions(request *DeleteProjectMemberRequest, runtime *util.RuntimeOptions) (_result *DeleteProjectMemberResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.UserId)) {
		query["UserId"] = request.UserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteProjectMember"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteProjectMemberResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteProjectMember(request *DeleteProjectMemberRequest) (_result *DeleteProjectMemberResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteProjectMemberResponse{}
	_body, _err := client.DeleteProjectMemberWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteQualityEntityWithOptions(request *DeleteQualityEntityRequest, runtime *util.RuntimeOptions) (_result *DeleteQualityEntityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EntityId)) {
		body["EntityId"] = request.EntityId
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		body["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteQualityEntity"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteQualityEntityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteQualityEntity(request *DeleteQualityEntityRequest) (_result *DeleteQualityEntityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteQualityEntityResponse{}
	_body, _err := client.DeleteQualityEntityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In Data Quality, you must configure monitoring rules based on a partition filter expression. Data Quality uses these rules to detect changes in source data and dirty data generated during the process of extract, transformation, load (ETL). Thereby, Data Quality automatically blocks the nodes that involve dirty data to stop dirty data from spreading downstream. This prevents nodes from producing unexpected dirty data that affects normal use and business decisions. You can go to the Manage Subscriptions page to add subscribers for a partition filter expression. When the monitoring rule described by the partition filter expression is triggered, the subscribers can receive notifications and troubleshoot errors in a timely manner. For more information, see [Configure monitoring rules for MaxCompute](~~73690~~).
 *
 * @param request DeleteQualityFollowerRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteQualityFollowerResponse
 */
func (client *Client) DeleteQualityFollowerWithOptions(request *DeleteQualityFollowerRequest, runtime *util.RuntimeOptions) (_result *DeleteQualityFollowerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FollowerId)) {
		body["FollowerId"] = request.FollowerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteQualityFollower"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteQualityFollowerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In Data Quality, you must configure monitoring rules based on a partition filter expression. Data Quality uses these rules to detect changes in source data and dirty data generated during the process of extract, transformation, load (ETL). Thereby, Data Quality automatically blocks the nodes that involve dirty data to stop dirty data from spreading downstream. This prevents nodes from producing unexpected dirty data that affects normal use and business decisions. You can go to the Manage Subscriptions page to add subscribers for a partition filter expression. When the monitoring rule described by the partition filter expression is triggered, the subscribers can receive notifications and troubleshoot errors in a timely manner. For more information, see [Configure monitoring rules for MaxCompute](~~73690~~).
 *
 * @param request DeleteQualityFollowerRequest
 * @return DeleteQualityFollowerResponse
 */
func (client *Client) DeleteQualityFollower(request *DeleteQualityFollowerRequest) (_result *DeleteQualityFollowerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteQualityFollowerResponse{}
	_body, _err := client.DeleteQualityFollowerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteQualityRelativeNodeWithOptions(request *DeleteQualityRelativeNodeRequest, runtime *util.RuntimeOptions) (_result *DeleteQualityRelativeNodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		body["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.MatchExpression)) {
		body["MatchExpression"] = request.MatchExpression
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		body["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.TargetNodeProjectId)) {
		body["TargetNodeProjectId"] = request.TargetNodeProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetNodeProjectName)) {
		body["TargetNodeProjectName"] = request.TargetNodeProjectName
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteQualityRelativeNode"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteQualityRelativeNodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteQualityRelativeNode(request *DeleteQualityRelativeNodeRequest) (_result *DeleteQualityRelativeNodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteQualityRelativeNodeResponse{}
	_body, _err := client.DeleteQualityRelativeNodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteQualityRuleWithOptions(request *DeleteQualityRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteQualityRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		body["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteQualityRule"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteQualityRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteQualityRule(request *DeleteQualityRuleRequest) (_result *DeleteQualityRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteQualityRuleResponse{}
	_body, _err := client.DeleteQualityRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteRecognizeRuleWithOptions(request *DeleteRecognizeRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteRecognizeRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.SensitiveId)) {
		body["SensitiveId"] = request.SensitiveId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRecognizeRule"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRecognizeRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteRecognizeRule(request *DeleteRecognizeRuleRequest) (_result *DeleteRecognizeRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRecognizeRuleResponse{}
	_body, _err := client.DeleteRecognizeRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteRemindWithOptions(request *DeleteRemindRequest, runtime *util.RuntimeOptions) (_result *DeleteRemindResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RemindId)) {
		body["RemindId"] = request.RemindId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRemind"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRemindResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteRemind(request *DeleteRemindRequest) (_result *DeleteRemindResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRemindResponse{}
	_body, _err := client.DeleteRemindWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteTableWithOptions(request *DeleteTableRequest, runtime *util.RuntimeOptions) (_result *DeleteTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppGuid)) {
		query["AppGuid"] = request.AppGuid
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.Schema)) {
		query["Schema"] = request.Schema
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTable"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteTable(request *DeleteTableRequest) (_result *DeleteTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTableResponse{}
	_body, _err := client.DeleteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteTableLevelWithOptions(request *DeleteTableLevelRequest, runtime *util.RuntimeOptions) (_result *DeleteTableLevelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LevelId)) {
		query["LevelId"] = request.LevelId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTableLevel"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTableLevelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteTableLevel(request *DeleteTableLevelRequest) (_result *DeleteTableLevelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTableLevelResponse{}
	_body, _err := client.DeleteTableLevelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteTableThemeWithOptions(request *DeleteTableThemeRequest, runtime *util.RuntimeOptions) (_result *DeleteTableThemeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ThemeId)) {
		query["ThemeId"] = request.ThemeId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTableTheme"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTableThemeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteTableTheme(request *DeleteTableThemeRequest) (_result *DeleteTableThemeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTableThemeResponse{}
	_body, _err := client.DeleteTableThemeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeployDISyncTaskWithOptions(request *DeployDISyncTaskRequest, runtime *util.RuntimeOptions) (_result *DeployDISyncTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeployDISyncTask"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeployDISyncTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeployDISyncTask(request *DeployDISyncTaskRequest) (_result *DeployDISyncTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeployDISyncTaskResponse{}
	_body, _err := client.DeployDISyncTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeployFileWithOptions(request *DeployFileRequest, runtime *util.RuntimeOptions) (_result *DeployFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		body["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		body["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeployFile"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeployFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeployFile(request *DeployFileRequest) (_result *DeployFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeployFileResponse{}
	_body, _err := client.DeployFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DesensitizeDataWithOptions(request *DesensitizeDataRequest, runtime *util.RuntimeOptions) (_result *DesensitizeDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DesensitizeData"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DesensitizeDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DesensitizeData(request *DesensitizeDataRequest) (_result *DesensitizeDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DesensitizeDataResponse{}
	_body, _err := client.DesensitizeDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DsgQuerySensResultWithOptions(request *DsgQuerySensResultRequest, runtime *util.RuntimeOptions) (_result *DsgQuerySensResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Col)) {
		body["Col"] = request.Col
	}

	if !tea.BoolValue(util.IsUnset(request.DbType)) {
		body["DbType"] = request.DbType
	}

	if !tea.BoolValue(util.IsUnset(request.Level)) {
		body["Level"] = request.Level
	}

	if !tea.BoolValue(util.IsUnset(request.NodeName)) {
		body["NodeName"] = request.NodeName
	}

	if !tea.BoolValue(util.IsUnset(request.Order)) {
		body["Order"] = request.Order
	}

	if !tea.BoolValue(util.IsUnset(request.OrderField)) {
		body["OrderField"] = request.OrderField
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		body["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.SchemaName)) {
		body["SchemaName"] = request.SchemaName
	}

	if !tea.BoolValue(util.IsUnset(request.SensStatus)) {
		body["SensStatus"] = request.SensStatus
	}

	if !tea.BoolValue(util.IsUnset(request.SensitiveId)) {
		body["SensitiveId"] = request.SensitiveId
	}

	if !tea.BoolValue(util.IsUnset(request.SensitiveName)) {
		body["SensitiveName"] = request.SensitiveName
	}

	if !tea.BoolValue(util.IsUnset(request.Table)) {
		body["Table"] = request.Table
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DsgQuerySensResult"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DsgQuerySensResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DsgQuerySensResult(request *DsgQuerySensResultRequest) (_result *DsgQuerySensResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DsgQuerySensResultResponse{}
	_body, _err := client.DsgQuerySensResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DsgRunSensIdentifyWithOptions(tmpReq *DsgRunSensIdentifyRequest, runtime *util.RuntimeOptions) (_result *DsgRunSensIdentifyResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &DsgRunSensIdentifyShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.EsMetaParams)) {
		request.EsMetaParamsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.EsMetaParams, tea.String("EsMetaParams"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EsMetaParamsShrink)) {
		body["EsMetaParams"] = request.EsMetaParamsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DsgRunSensIdentify"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DsgRunSensIdentifyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DsgRunSensIdentify(request *DsgRunSensIdentifyRequest) (_result *DsgRunSensIdentifyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DsgRunSensIdentifyResponse{}
	_body, _err := client.DsgRunSensIdentifyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DsgStopSensIdentifyWithOptions(request *DsgStopSensIdentifyRequest, runtime *util.RuntimeOptions) (_result *DsgStopSensIdentifyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		body["JobId"] = request.JobId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DsgStopSensIdentify"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DsgStopSensIdentifyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DsgStopSensIdentify(request *DsgStopSensIdentifyRequest) (_result *DsgStopSensIdentifyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DsgStopSensIdentifyResponse{}
	_body, _err := client.DsgStopSensIdentifyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EditRecognizeRuleWithOptions(request *EditRecognizeRuleRequest, runtime *util.RuntimeOptions) (_result *EditRecognizeRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AccountName)) {
		body["AccountName"] = request.AccountName
	}

	if !tea.BoolValue(util.IsUnset(request.ColExclude)) {
		body["ColExclude"] = request.ColExclude
	}

	if !tea.BoolValue(util.IsUnset(request.ColScan)) {
		body["ColScan"] = request.ColScan
	}

	if !tea.BoolValue(util.IsUnset(request.CommentScan)) {
		body["CommentScan"] = request.CommentScan
	}

	if !tea.BoolValue(util.IsUnset(request.ContentScan)) {
		body["ContentScan"] = request.ContentScan
	}

	if !tea.BoolValue(util.IsUnset(request.HitThreshold)) {
		body["HitThreshold"] = request.HitThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.LevelName)) {
		body["LevelName"] = request.LevelName
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.NodeParent)) {
		body["NodeParent"] = request.NodeParent
	}

	if !tea.BoolValue(util.IsUnset(request.OperationType)) {
		body["OperationType"] = request.OperationType
	}

	if !tea.BoolValue(util.IsUnset(request.RecognizeRules)) {
		body["RecognizeRules"] = request.RecognizeRules
	}

	if !tea.BoolValue(util.IsUnset(request.RecognizeRulesType)) {
		body["RecognizeRulesType"] = request.RecognizeRulesType
	}

	if !tea.BoolValue(util.IsUnset(request.SensitiveDescription)) {
		body["SensitiveDescription"] = request.SensitiveDescription
	}

	if !tea.BoolValue(util.IsUnset(request.SensitiveId)) {
		body["SensitiveId"] = request.SensitiveId
	}

	if !tea.BoolValue(util.IsUnset(request.SensitiveName)) {
		body["SensitiveName"] = request.SensitiveName
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		body["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		body["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	if !tea.BoolValue(util.IsUnset(request.Level)) {
		body["level"] = request.Level
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("EditRecognizeRule"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EditRecognizeRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EditRecognizeRule(request *EditRecognizeRuleRequest) (_result *EditRecognizeRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EditRecognizeRuleResponse{}
	_body, _err := client.EditRecognizeRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EstablishRelationTableToBusinessWithOptions(request *EstablishRelationTableToBusinessRequest, runtime *util.RuntimeOptions) (_result *EstablishRelationTableToBusinessResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BusinessId)) {
		body["BusinessId"] = request.BusinessId
	}

	if !tea.BoolValue(util.IsUnset(request.FolderId)) {
		body["FolderId"] = request.FolderId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		body["TableGuid"] = request.TableGuid
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("EstablishRelationTableToBusiness"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EstablishRelationTableToBusinessResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EstablishRelationTableToBusiness(request *EstablishRelationTableToBusinessRequest) (_result *EstablishRelationTableToBusinessResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EstablishRelationTableToBusinessResponse{}
	_body, _err := client.EstablishRelationTableToBusinessWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ExportDataSourcesWithOptions(request *ExportDataSourcesRequest, runtime *util.RuntimeOptions) (_result *ExportDataSourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ExportDataSources"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ExportDataSourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ExportDataSources(request *ExportDataSourcesRequest) (_result *ExportDataSourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ExportDataSourcesResponse{}
	_body, _err := client.ExportDataSourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform.
 *
 * @param request GenerateDISyncTaskConfigForCreatingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateDISyncTaskConfigForCreatingResponse
 */
func (client *Client) GenerateDISyncTaskConfigForCreatingWithOptions(request *GenerateDISyncTaskConfigForCreatingRequest, runtime *util.RuntimeOptions) (_result *GenerateDISyncTaskConfigForCreatingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskParam)) {
		query["TaskParam"] = request.TaskParam
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GenerateDISyncTaskConfigForCreating"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GenerateDISyncTaskConfigForCreatingResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform.
 *
 * @param request GenerateDISyncTaskConfigForCreatingRequest
 * @return GenerateDISyncTaskConfigForCreatingResponse
 */
func (client *Client) GenerateDISyncTaskConfigForCreating(request *GenerateDISyncTaskConfigForCreatingRequest) (_result *GenerateDISyncTaskConfigForCreatingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GenerateDISyncTaskConfigForCreatingResponse{}
	_body, _err := client.GenerateDISyncTaskConfigForCreatingWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform.
 *
 * @param request GenerateDISyncTaskConfigForUpdatingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateDISyncTaskConfigForUpdatingResponse
 */
func (client *Client) GenerateDISyncTaskConfigForUpdatingWithOptions(request *GenerateDISyncTaskConfigForUpdatingRequest, runtime *util.RuntimeOptions) (_result *GenerateDISyncTaskConfigForUpdatingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientToken)) {
		query["ClientToken"] = request.ClientToken
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskParam)) {
		query["TaskParam"] = request.TaskParam
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GenerateDISyncTaskConfigForUpdating"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GenerateDISyncTaskConfigForUpdatingResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform.
 *
 * @param request GenerateDISyncTaskConfigForUpdatingRequest
 * @return GenerateDISyncTaskConfigForUpdatingResponse
 */
func (client *Client) GenerateDISyncTaskConfigForUpdating(request *GenerateDISyncTaskConfigForUpdatingRequest) (_result *GenerateDISyncTaskConfigForUpdatingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GenerateDISyncTaskConfigForUpdatingResponse{}
	_body, _err := client.GenerateDISyncTaskConfigForUpdatingWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetAlertMessageWithOptions(request *GetAlertMessageRequest, runtime *util.RuntimeOptions) (_result *GetAlertMessageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertId)) {
		body["AlertId"] = request.AlertId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetAlertMessage"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetAlertMessageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetAlertMessage(request *GetAlertMessageRequest) (_result *GetAlertMessageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetAlertMessageResponse{}
	_body, _err := client.GetAlertMessageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetBaselineWithOptions(request *GetBaselineRequest, runtime *util.RuntimeOptions) (_result *GetBaselineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BaselineId)) {
		body["BaselineId"] = request.BaselineId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetBaseline"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetBaselineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetBaseline(request *GetBaselineRequest) (_result *GetBaselineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetBaselineResponse{}
	_body, _err := client.GetBaselineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetBaselineConfigWithOptions(request *GetBaselineConfigRequest, runtime *util.RuntimeOptions) (_result *GetBaselineConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BaselineId)) {
		body["BaselineId"] = request.BaselineId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetBaselineConfig"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetBaselineConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetBaselineConfig(request *GetBaselineConfigRequest) (_result *GetBaselineConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetBaselineConfigResponse{}
	_body, _err := client.GetBaselineConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetBaselineKeyPathWithOptions(request *GetBaselineKeyPathRequest, runtime *util.RuntimeOptions) (_result *GetBaselineKeyPathResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BaselineId)) {
		body["BaselineId"] = request.BaselineId
	}

	if !tea.BoolValue(util.IsUnset(request.Bizdate)) {
		body["Bizdate"] = request.Bizdate
	}

	if !tea.BoolValue(util.IsUnset(request.InGroupId)) {
		body["InGroupId"] = request.InGroupId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetBaselineKeyPath"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetBaselineKeyPathResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetBaselineKeyPath(request *GetBaselineKeyPathRequest) (_result *GetBaselineKeyPathResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetBaselineKeyPathResponse{}
	_body, _err := client.GetBaselineKeyPathWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetBaselineStatusWithOptions(request *GetBaselineStatusRequest, runtime *util.RuntimeOptions) (_result *GetBaselineStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BaselineId)) {
		body["BaselineId"] = request.BaselineId
	}

	if !tea.BoolValue(util.IsUnset(request.Bizdate)) {
		body["Bizdate"] = request.Bizdate
	}

	if !tea.BoolValue(util.IsUnset(request.InGroupId)) {
		body["InGroupId"] = request.InGroupId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetBaselineStatus"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetBaselineStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetBaselineStatus(request *GetBaselineStatusRequest) (_result *GetBaselineStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetBaselineStatusResponse{}
	_body, _err := client.GetBaselineStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetBusinessWithOptions(request *GetBusinessRequest, runtime *util.RuntimeOptions) (_result *GetBusinessResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BusinessId)) {
		body["BusinessId"] = request.BusinessId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetBusiness"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetBusinessResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetBusiness(request *GetBusinessRequest) (_result *GetBusinessResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetBusinessResponse{}
	_body, _err := client.GetBusinessWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDDLJobStatusWithOptions(request *GetDDLJobStatusRequest, runtime *util.RuntimeOptions) (_result *GetDDLJobStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDDLJobStatus"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDDLJobStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDDLJobStatus(request *GetDDLJobStatusRequest) (_result *GetDDLJobStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDDLJobStatusResponse{}
	_body, _err := client.GetDDLJobStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDIAlarmRuleWithOptions(request *GetDIAlarmRuleRequest, runtime *util.RuntimeOptions) (_result *GetDIAlarmRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DIAlarmRuleId)) {
		body["DIAlarmRuleId"] = request.DIAlarmRuleId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDIAlarmRule"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDIAlarmRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDIAlarmRule(request *GetDIAlarmRuleRequest) (_result *GetDIAlarmRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDIAlarmRuleResponse{}
	_body, _err := client.GetDIAlarmRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDIJobWithOptions(request *GetDIJobRequest, runtime *util.RuntimeOptions) (_result *GetDIJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DIJobId)) {
		body["DIJobId"] = request.DIJobId
	}

	if !tea.BoolValue(util.IsUnset(request.WithDetails)) {
		body["WithDetails"] = request.WithDetails
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDIJob"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDIJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDIJob(request *GetDIJobRequest) (_result *GetDIJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDIJobResponse{}
	_body, _err := client.GetDIJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDISyncInstanceInfoWithOptions(request *GetDISyncInstanceInfoRequest, runtime *util.RuntimeOptions) (_result *GetDISyncInstanceInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDISyncInstanceInfo"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDISyncInstanceInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDISyncInstanceInfo(request *GetDISyncInstanceInfoRequest) (_result *GetDISyncInstanceInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDISyncInstanceInfoResponse{}
	_body, _err := client.GetDISyncInstanceInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDISyncTaskWithOptions(request *GetDISyncTaskRequest, runtime *util.RuntimeOptions) (_result *GetDISyncTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDISyncTask"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDISyncTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDISyncTask(request *GetDISyncTaskRequest) (_result *GetDISyncTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDISyncTaskResponse{}
	_body, _err := client.GetDISyncTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Supported DAG types:
 * *   MANUAL: the DAG for a manually triggered workflow.
 * *   SMOKE_TEST: the DAG for a smoke testing workflow.
 * *   SUPPLY_DATA: the DAG for a data backfill instance.
 * *   BUSINESS_PROCESS_DAG: the DAG for a one-time workflow.
 * Supported DAG states:
 * *   CREATED: The DAG is created.
 * *   RUNNING: The DAG is running.
 * *   FAILURE: The DAG fails to run.
 * *   SUCCESS: The DAG successfully runs.
 *
 * @param request GetDagRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDagResponse
 */
func (client *Client) GetDagWithOptions(request *GetDagRequest, runtime *util.RuntimeOptions) (_result *GetDagResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		body["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDag"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDagResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Supported DAG types:
 * *   MANUAL: the DAG for a manually triggered workflow.
 * *   SMOKE_TEST: the DAG for a smoke testing workflow.
 * *   SUPPLY_DATA: the DAG for a data backfill instance.
 * *   BUSINESS_PROCESS_DAG: the DAG for a one-time workflow.
 * Supported DAG states:
 * *   CREATED: The DAG is created.
 * *   RUNNING: The DAG is running.
 * *   FAILURE: The DAG fails to run.
 * *   SUCCESS: The DAG successfully runs.
 *
 * @param request GetDagRequest
 * @return GetDagResponse
 */
func (client *Client) GetDag(request *GetDagRequest) (_result *GetDagResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDagResponse{}
	_body, _err := client.GetDagWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataServiceApiWithOptions(request *GetDataServiceApiRequest, runtime *util.RuntimeOptions) (_result *GetDataServiceApiResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiId)) {
		body["ApiId"] = request.ApiId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataServiceApi"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataServiceApiResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataServiceApi(request *GetDataServiceApiRequest) (_result *GetDataServiceApiResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataServiceApiResponse{}
	_body, _err := client.GetDataServiceApiWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataServiceApiTestWithOptions(request *GetDataServiceApiTestRequest, runtime *util.RuntimeOptions) (_result *GetDataServiceApiTestResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataServiceApiTest"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataServiceApiTestResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataServiceApiTest(request *GetDataServiceApiTestRequest) (_result *GetDataServiceApiTestResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataServiceApiTestResponse{}
	_body, _err := client.GetDataServiceApiTestWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataServiceApplicationWithOptions(request *GetDataServiceApplicationRequest, runtime *util.RuntimeOptions) (_result *GetDataServiceApplicationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApplicationId)) {
		body["ApplicationId"] = request.ApplicationId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataServiceApplication"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataServiceApplicationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataServiceApplication(request *GetDataServiceApplicationRequest) (_result *GetDataServiceApplicationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataServiceApplicationResponse{}
	_body, _err := client.GetDataServiceApplicationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataServiceFolderWithOptions(request *GetDataServiceFolderRequest, runtime *util.RuntimeOptions) (_result *GetDataServiceFolderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FolderId)) {
		body["FolderId"] = request.FolderId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataServiceFolder"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataServiceFolderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataServiceFolder(request *GetDataServiceFolderRequest) (_result *GetDataServiceFolderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataServiceFolderResponse{}
	_body, _err := client.GetDataServiceFolderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataServiceGroupWithOptions(request *GetDataServiceGroupRequest, runtime *util.RuntimeOptions) (_result *GetDataServiceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		body["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataServiceGroup"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataServiceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataServiceGroup(request *GetDataServiceGroupRequest) (_result *GetDataServiceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataServiceGroupResponse{}
	_body, _err := client.GetDataServiceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataServicePublishedApiWithOptions(request *GetDataServicePublishedApiRequest, runtime *util.RuntimeOptions) (_result *GetDataServicePublishedApiResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiId)) {
		body["ApiId"] = request.ApiId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataServicePublishedApi"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataServicePublishedApiResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataServicePublishedApi(request *GetDataServicePublishedApiRequest) (_result *GetDataServicePublishedApiResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataServicePublishedApiResponse{}
	_body, _err := client.GetDataServicePublishedApiWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataSourceMetaWithOptions(request *GetDataSourceMetaRequest, runtime *util.RuntimeOptions) (_result *GetDataSourceMetaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DatasourceName)) {
		query["DatasourceName"] = request.DatasourceName
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataSourceMeta"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataSourceMetaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataSourceMeta(request *GetDataSourceMetaRequest) (_result *GetDataSourceMetaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataSourceMetaResponse{}
	_body, _err := client.GetDataSourceMetaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDeploymentWithOptions(request *GetDeploymentRequest, runtime *util.RuntimeOptions) (_result *GetDeploymentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeploymentId)) {
		body["DeploymentId"] = request.DeploymentId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDeployment"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDeploymentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDeployment(request *GetDeploymentRequest) (_result *GetDeploymentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDeploymentResponse{}
	_body, _err := client.GetDeploymentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetExtensionWithOptions(request *GetExtensionRequest, runtime *util.RuntimeOptions) (_result *GetExtensionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ExtensionCode)) {
		query["ExtensionCode"] = request.ExtensionCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetExtension"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetExtensionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetExtension(request *GetExtensionRequest) (_result *GetExtensionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetExtensionResponse{}
	_body, _err := client.GetExtensionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetFileWithOptions(request *GetFileRequest, runtime *util.RuntimeOptions) (_result *GetFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		body["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetFile"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetFile(request *GetFileRequest) (_result *GetFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetFileResponse{}
	_body, _err := client.GetFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetFileTypeStatisticWithOptions(request *GetFileTypeStatisticRequest, runtime *util.RuntimeOptions) (_result *GetFileTypeStatisticResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetFileTypeStatistic"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetFileTypeStatisticResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetFileTypeStatistic(request *GetFileTypeStatisticRequest) (_result *GetFileTypeStatisticResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetFileTypeStatisticResponse{}
	_body, _err := client.GetFileTypeStatisticWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetFileVersionWithOptions(request *GetFileVersionRequest, runtime *util.RuntimeOptions) (_result *GetFileVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		body["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.FileVersion)) {
		body["FileVersion"] = request.FileVersion
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetFileVersion"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetFileVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetFileVersion(request *GetFileVersionRequest) (_result *GetFileVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetFileVersionResponse{}
	_body, _err := client.GetFileVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetFolderWithOptions(request *GetFolderRequest, runtime *util.RuntimeOptions) (_result *GetFolderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FolderId)) {
		body["FolderId"] = request.FolderId
	}

	if !tea.BoolValue(util.IsUnset(request.FolderPath)) {
		body["FolderPath"] = request.FolderPath
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetFolder"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetFolderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetFolder(request *GetFolderRequest) (_result *GetFolderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetFolderResponse{}
	_body, _err := client.GetFolderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetIDEEventDetailWithOptions(request *GetIDEEventDetailRequest, runtime *util.RuntimeOptions) (_result *GetIDEEventDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MessageId)) {
		body["MessageId"] = request.MessageId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetIDEEventDetail"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetIDEEventDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetIDEEventDetail(request *GetIDEEventDetailRequest) (_result *GetIDEEventDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetIDEEventDetailResponse{}
	_body, _err := client.GetIDEEventDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetInstanceWithOptions(request *GetInstanceRequest, runtime *util.RuntimeOptions) (_result *GetInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		body["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetInstance"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetInstance(request *GetInstanceRequest) (_result *GetInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetInstanceResponse{}
	_body, _err := client.GetInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetInstanceConsumeTimeRankRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceConsumeTimeRankResponse
 */
// Deprecated
func (client *Client) GetInstanceConsumeTimeRankWithOptions(request *GetInstanceConsumeTimeRankRequest, runtime *util.RuntimeOptions) (_result *GetInstanceConsumeTimeRankResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bizdate)) {
		body["Bizdate"] = request.Bizdate
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetInstanceConsumeTimeRank"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetInstanceConsumeTimeRankResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetInstanceConsumeTimeRankRequest
 * @return GetInstanceConsumeTimeRankResponse
 */
// Deprecated
func (client *Client) GetInstanceConsumeTimeRank(request *GetInstanceConsumeTimeRankRequest) (_result *GetInstanceConsumeTimeRankResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetInstanceConsumeTimeRankResponse{}
	_body, _err := client.GetInstanceConsumeTimeRankWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetInstanceCountTrendRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceCountTrendResponse
 */
// Deprecated
func (client *Client) GetInstanceCountTrendWithOptions(request *GetInstanceCountTrendRequest, runtime *util.RuntimeOptions) (_result *GetInstanceCountTrendResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BeginDate)) {
		body["BeginDate"] = request.BeginDate
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		body["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetInstanceCountTrend"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetInstanceCountTrendResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetInstanceCountTrendRequest
 * @return GetInstanceCountTrendResponse
 */
// Deprecated
func (client *Client) GetInstanceCountTrend(request *GetInstanceCountTrendRequest) (_result *GetInstanceCountTrendResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetInstanceCountTrendResponse{}
	_body, _err := client.GetInstanceCountTrendWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetInstanceErrorRankRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceErrorRankResponse
 */
// Deprecated
func (client *Client) GetInstanceErrorRankWithOptions(request *GetInstanceErrorRankRequest, runtime *util.RuntimeOptions) (_result *GetInstanceErrorRankResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetInstanceErrorRank"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetInstanceErrorRankResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetInstanceErrorRankRequest
 * @return GetInstanceErrorRankResponse
 */
// Deprecated
func (client *Client) GetInstanceErrorRank(request *GetInstanceErrorRankRequest) (_result *GetInstanceErrorRankResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetInstanceErrorRankResponse{}
	_body, _err := client.GetInstanceErrorRankWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You may not obtain the instance logs that were generated more than seven days ago.
 *
 * @param request GetInstanceLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceLogResponse
 */
func (client *Client) GetInstanceLogWithOptions(request *GetInstanceLogRequest, runtime *util.RuntimeOptions) (_result *GetInstanceLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceHistoryId)) {
		body["InstanceHistoryId"] = request.InstanceHistoryId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		body["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetInstanceLog"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetInstanceLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You may not obtain the instance logs that were generated more than seven days ago.
 *
 * @param request GetInstanceLogRequest
 * @return GetInstanceLogResponse
 */
func (client *Client) GetInstanceLog(request *GetInstanceLogRequest) (_result *GetInstanceLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetInstanceLogResponse{}
	_body, _err := client.GetInstanceLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetInstanceStatusCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetInstanceStatusCountResponse
 */
// Deprecated
func (client *Client) GetInstanceStatusCountWithOptions(request *GetInstanceStatusCountRequest, runtime *util.RuntimeOptions) (_result *GetInstanceStatusCountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BizDate)) {
		body["BizDate"] = request.BizDate
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetInstanceStatusCount"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetInstanceStatusCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetInstanceStatusCountRequest
 * @return GetInstanceStatusCountResponse
 */
// Deprecated
func (client *Client) GetInstanceStatusCount(request *GetInstanceStatusCountRequest) (_result *GetInstanceStatusCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetInstanceStatusCountResponse{}
	_body, _err := client.GetInstanceStatusCountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetInstanceStatusStatisticWithOptions(request *GetInstanceStatusStatisticRequest, runtime *util.RuntimeOptions) (_result *GetInstanceStatusStatisticResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BizDate)) {
		body["BizDate"] = request.BizDate
	}

	if !tea.BoolValue(util.IsUnset(request.DagType)) {
		body["DagType"] = request.DagType
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.SchedulerPeriod)) {
		body["SchedulerPeriod"] = request.SchedulerPeriod
	}

	if !tea.BoolValue(util.IsUnset(request.SchedulerType)) {
		body["SchedulerType"] = request.SchedulerType
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetInstanceStatusStatistic"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetInstanceStatusStatisticResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetInstanceStatusStatistic(request *GetInstanceStatusStatisticRequest) (_result *GetInstanceStatusStatisticResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetInstanceStatusStatisticResponse{}
	_body, _err := client.GetInstanceStatusStatisticWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetManualDagInstancesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetManualDagInstancesResponse
 */
// Deprecated
func (client *Client) GetManualDagInstancesWithOptions(request *GetManualDagInstancesRequest, runtime *util.RuntimeOptions) (_result *GetManualDagInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		body["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetManualDagInstances"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetManualDagInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetManualDagInstancesRequest
 * @return GetManualDagInstancesResponse
 */
// Deprecated
func (client *Client) GetManualDagInstances(request *GetManualDagInstancesRequest) (_result *GetManualDagInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetManualDagInstancesResponse{}
	_body, _err := client.GetManualDagInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMetaCategoryWithOptions(request *GetMetaCategoryRequest, runtime *util.RuntimeOptions) (_result *GetMetaCategoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ParentCategoryId)) {
		query["ParentCategoryId"] = request.ParentCategoryId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaCategory"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaCategoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMetaCategory(request *GetMetaCategoryRequest) (_result *GetMetaCategoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaCategoryResponse{}
	_body, _err := client.GetMetaCategoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMetaCollectionDetailWithOptions(request *GetMetaCollectionDetailRequest, runtime *util.RuntimeOptions) (_result *GetMetaCollectionDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.QualifiedName)) {
		query["QualifiedName"] = request.QualifiedName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaCollectionDetail"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaCollectionDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMetaCollectionDetail(request *GetMetaCollectionDetailRequest) (_result *GetMetaCollectionDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaCollectionDetailResponse{}
	_body, _err := client.GetMetaCollectionDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMetaColumnLineageWithOptions(request *GetMetaColumnLineageRequest, runtime *util.RuntimeOptions) (_result *GetMetaColumnLineageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.ColumnGuid)) {
		query["ColumnGuid"] = request.ColumnGuid
	}

	if !tea.BoolValue(util.IsUnset(request.ColumnName)) {
		query["ColumnName"] = request.ColumnName
	}

	if !tea.BoolValue(util.IsUnset(request.DataSourceType)) {
		query["DataSourceType"] = request.DataSourceType
	}

	if !tea.BoolValue(util.IsUnset(request.DatabaseName)) {
		query["DatabaseName"] = request.DatabaseName
	}

	if !tea.BoolValue(util.IsUnset(request.Direction)) {
		query["Direction"] = request.Direction
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaColumnLineage"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaColumnLineageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMetaColumnLineage(request *GetMetaColumnLineageRequest) (_result *GetMetaColumnLineageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaColumnLineageResponse{}
	_body, _err := client.GetMetaColumnLineageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
 * You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID of the EMR cluster.
 *
 * @param request GetMetaDBInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaDBInfoResponse
 */
func (client *Client) GetMetaDBInfoWithOptions(request *GetMetaDBInfoRequest, runtime *util.RuntimeOptions) (_result *GetMetaDBInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaDBInfo"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaDBInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The ID of the EMR cluster. This parameter is required only if you set the DataSourceType parameter to emr.
 * You can log on to the [EMR console](https://emr.console.aliyun.com/?spm=a2c4g.11186623.0.0.965cc5c2GeiHet#/cn-hangzhou) to obtain the ID of the EMR cluster.
 *
 * @param request GetMetaDBInfoRequest
 * @return GetMetaDBInfoResponse
 */
func (client *Client) GetMetaDBInfo(request *GetMetaDBInfoRequest) (_result *GetMetaDBInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaDBInfoResponse{}
	_body, _err := client.GetMetaDBInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMetaDBTableListWithOptions(request *GetMetaDBTableListRequest, runtime *util.RuntimeOptions) (_result *GetMetaDBTableListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppGuid)) {
		query["AppGuid"] = request.AppGuid
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.DataSourceType)) {
		query["DataSourceType"] = request.DataSourceType
	}

	if !tea.BoolValue(util.IsUnset(request.DatabaseName)) {
		query["DatabaseName"] = request.DatabaseName
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaDBTableList"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaDBTableListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMetaDBTableList(request *GetMetaDBTableListRequest) (_result *GetMetaDBTableListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaDBTableListResponse{}
	_body, _err := client.GetMetaDBTableListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ****
 *
 * @param request GetMetaTableBasicInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaTableBasicInfoResponse
 */
func (client *Client) GetMetaTableBasicInfoWithOptions(request *GetMetaTableBasicInfoRequest, runtime *util.RuntimeOptions) (_result *GetMetaTableBasicInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaTableBasicInfo"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaTableBasicInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ****
 *
 * @param request GetMetaTableBasicInfoRequest
 * @return GetMetaTableBasicInfoResponse
 */
func (client *Client) GetMetaTableBasicInfo(request *GetMetaTableBasicInfoRequest) (_result *GetMetaTableBasicInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaTableBasicInfoResponse{}
	_body, _err := client.GetMetaTableBasicInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMetaTableChangeLogWithOptions(request *GetMetaTableChangeLogRequest, runtime *util.RuntimeOptions) (_result *GetMetaTableChangeLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChangeType)) {
		body["ChangeType"] = request.ChangeType
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		body["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.ObjectType)) {
		body["ObjectType"] = request.ObjectType
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		body["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		body["TableGuid"] = request.TableGuid
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaTableChangeLog"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaTableChangeLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMetaTableChangeLog(request *GetMetaTableChangeLogRequest) (_result *GetMetaTableChangeLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaTableChangeLogResponse{}
	_body, _err := client.GetMetaTableChangeLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMetaTableColumnWithOptions(request *GetMetaTableColumnRequest, runtime *util.RuntimeOptions) (_result *GetMetaTableColumnResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaTableColumn"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaTableColumnResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMetaTableColumn(request *GetMetaTableColumnRequest) (_result *GetMetaTableColumnResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaTableColumnResponse{}
	_body, _err := client.GetMetaTableColumnWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMetaTableFullInfoWithOptions(request *GetMetaTableFullInfoRequest, runtime *util.RuntimeOptions) (_result *GetMetaTableFullInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaTableFullInfo"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaTableFullInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMetaTableFullInfo(request *GetMetaTableFullInfoRequest) (_result *GetMetaTableFullInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaTableFullInfoResponse{}
	_body, _err := client.GetMetaTableFullInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMetaTableIntroWikiWithOptions(request *GetMetaTableIntroWikiRequest, runtime *util.RuntimeOptions) (_result *GetMetaTableIntroWikiResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	if !tea.BoolValue(util.IsUnset(request.WikiVersion)) {
		query["WikiVersion"] = request.WikiVersion
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaTableIntroWiki"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaTableIntroWikiResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMetaTableIntroWiki(request *GetMetaTableIntroWikiRequest) (_result *GetMetaTableIntroWikiResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaTableIntroWikiResponse{}
	_body, _err := client.GetMetaTableIntroWikiWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMetaTableLineageWithOptions(request *GetMetaTableLineageRequest, runtime *util.RuntimeOptions) (_result *GetMetaTableLineageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.DataSourceType)) {
		query["DataSourceType"] = request.DataSourceType
	}

	if !tea.BoolValue(util.IsUnset(request.DatabaseName)) {
		query["DatabaseName"] = request.DatabaseName
	}

	if !tea.BoolValue(util.IsUnset(request.Direction)) {
		query["Direction"] = request.Direction
	}

	if !tea.BoolValue(util.IsUnset(request.NextPrimaryKey)) {
		query["NextPrimaryKey"] = request.NextPrimaryKey
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaTableLineage"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaTableLineageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMetaTableLineage(request *GetMetaTableLineageRequest) (_result *GetMetaTableLineageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaTableLineageResponse{}
	_body, _err := client.GetMetaTableLineageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMetaTableListByCategoryWithOptions(request *GetMetaTableListByCategoryRequest, runtime *util.RuntimeOptions) (_result *GetMetaTableListByCategoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaTableListByCategory"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaTableListByCategoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMetaTableListByCategory(request *GetMetaTableListByCategoryRequest) (_result *GetMetaTableListByCategoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaTableListByCategoryResponse{}
	_body, _err := client.GetMetaTableListByCategoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMetaTableOutputWithOptions(request *GetMetaTableOutputRequest, runtime *util.RuntimeOptions) (_result *GetMetaTableOutputResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		query["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		query["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaTableOutput"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaTableOutputResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMetaTableOutput(request *GetMetaTableOutputRequest) (_result *GetMetaTableOutputResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaTableOutputResponse{}
	_body, _err := client.GetMetaTableOutputWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **GetMetaTablePartition**.
 *
 * @param tmpReq GetMetaTablePartitionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMetaTablePartitionResponse
 */
func (client *Client) GetMetaTablePartitionWithOptions(tmpReq *GetMetaTablePartitionRequest, runtime *util.RuntimeOptions) (_result *GetMetaTablePartitionResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &GetMetaTablePartitionShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.SortCriterion)) {
		request.SortCriterionShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.SortCriterion, tea.String("SortCriterion"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.DataSourceType)) {
		query["DataSourceType"] = request.DataSourceType
	}

	if !tea.BoolValue(util.IsUnset(request.DatabaseName)) {
		query["DatabaseName"] = request.DatabaseName
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SortCriterionShrink)) {
		query["SortCriterion"] = request.SortCriterionShrink
	}

	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaTablePartition"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaTablePartitionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **GetMetaTablePartition**.
 *
 * @param request GetMetaTablePartitionRequest
 * @return GetMetaTablePartitionResponse
 */
func (client *Client) GetMetaTablePartition(request *GetMetaTablePartitionRequest) (_result *GetMetaTablePartitionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaTablePartitionResponse{}
	_body, _err := client.GetMetaTablePartitionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMetaTableProducingTasksWithOptions(request *GetMetaTableProducingTasksRequest, runtime *util.RuntimeOptions) (_result *GetMetaTableProducingTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.DataSourceType)) {
		query["DataSourceType"] = request.DataSourceType
	}

	if !tea.BoolValue(util.IsUnset(request.DbName)) {
		query["DbName"] = request.DbName
	}

	if !tea.BoolValue(util.IsUnset(request.SchemaName)) {
		query["SchemaName"] = request.SchemaName
	}

	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaTableProducingTasks"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaTableProducingTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMetaTableProducingTasks(request *GetMetaTableProducingTasksRequest) (_result *GetMetaTableProducingTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaTableProducingTasksResponse{}
	_body, _err := client.GetMetaTableProducingTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMetaTableThemeLevelWithOptions(request *GetMetaTableThemeLevelRequest, runtime *util.RuntimeOptions) (_result *GetMetaTableThemeLevelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMetaTableThemeLevel"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMetaTableThemeLevelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMetaTableThemeLevel(request *GetMetaTableThemeLevelRequest) (_result *GetMetaTableThemeLevelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMetaTableThemeLevelResponse{}
	_body, _err := client.GetMetaTableThemeLevelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMigrationProcessWithOptions(request *GetMigrationProcessRequest, runtime *util.RuntimeOptions) (_result *GetMigrationProcessResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MigrationId)) {
		body["MigrationId"] = request.MigrationId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMigrationProcess"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMigrationProcessResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMigrationProcess(request *GetMigrationProcessRequest) (_result *GetMigrationProcessResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMigrationProcessResponse{}
	_body, _err := client.GetMigrationProcessWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetMigrationSummaryWithOptions(request *GetMigrationSummaryRequest, runtime *util.RuntimeOptions) (_result *GetMigrationSummaryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MigrationId)) {
		body["MigrationId"] = request.MigrationId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetMigrationSummary"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetMigrationSummaryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetMigrationSummary(request *GetMigrationSummaryRequest) (_result *GetMigrationSummaryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetMigrationSummaryResponse{}
	_body, _err := client.GetMigrationSummaryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetNodeWithOptions(request *GetNodeRequest, runtime *util.RuntimeOptions) (_result *GetNodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetNode"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetNodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetNode(request *GetNodeRequest) (_result *GetNodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetNodeResponse{}
	_body, _err := client.GetNodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetNodeChildrenWithOptions(request *GetNodeChildrenRequest, runtime *util.RuntimeOptions) (_result *GetNodeChildrenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetNodeChildren"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetNodeChildrenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetNodeChildren(request *GetNodeChildrenRequest) (_result *GetNodeChildrenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetNodeChildrenResponse{}
	_body, _err := client.GetNodeChildrenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetNodeCodeWithOptions(request *GetNodeCodeRequest, runtime *util.RuntimeOptions) (_result *GetNodeCodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetNodeCode"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetNodeCodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetNodeCode(request *GetNodeCodeRequest) (_result *GetNodeCodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetNodeCodeResponse{}
	_body, _err := client.GetNodeCodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetNodeOnBaselineRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNodeOnBaselineResponse
 */
// Deprecated
func (client *Client) GetNodeOnBaselineWithOptions(request *GetNodeOnBaselineRequest, runtime *util.RuntimeOptions) (_result *GetNodeOnBaselineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BaselineId)) {
		body["BaselineId"] = request.BaselineId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetNodeOnBaseline"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetNodeOnBaselineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetNodeOnBaselineRequest
 * @return GetNodeOnBaselineResponse
 */
// Deprecated
func (client *Client) GetNodeOnBaseline(request *GetNodeOnBaselineRequest) (_result *GetNodeOnBaselineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetNodeOnBaselineResponse{}
	_body, _err := client.GetNodeOnBaselineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetNodeParentsWithOptions(request *GetNodeParentsRequest, runtime *util.RuntimeOptions) (_result *GetNodeParentsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetNodeParents"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetNodeParentsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetNodeParents(request *GetNodeParentsRequest) (_result *GetNodeParentsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetNodeParentsResponse{}
	_body, _err := client.GetNodeParentsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetNodeTypeListInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetNodeTypeListInfoResponse
 */
// Deprecated
func (client *Client) GetNodeTypeListInfoWithOptions(request *GetNodeTypeListInfoRequest, runtime *util.RuntimeOptions) (_result *GetNodeTypeListInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		body["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.Locale)) {
		body["Locale"] = request.Locale
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetNodeTypeListInfo"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetNodeTypeListInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetNodeTypeListInfoRequest
 * @return GetNodeTypeListInfoResponse
 */
// Deprecated
func (client *Client) GetNodeTypeListInfo(request *GetNodeTypeListInfoRequest) (_result *GetNodeTypeListInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetNodeTypeListInfoResponse{}
	_body, _err := client.GetNodeTypeListInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetOpRiskDataWithOptions(request *GetOpRiskDataRequest, runtime *util.RuntimeOptions) (_result *GetOpRiskDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetOpRiskData"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOpRiskDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetOpRiskData(request *GetOpRiskDataRequest) (_result *GetOpRiskDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetOpRiskDataResponse{}
	_body, _err := client.GetOpRiskDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetOpSensitiveDataWithOptions(request *GetOpSensitiveDataRequest, runtime *util.RuntimeOptions) (_result *GetOpSensitiveDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetOpSensitiveData"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOpSensitiveDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetOpSensitiveData(request *GetOpSensitiveDataRequest) (_result *GetOpSensitiveDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetOpSensitiveDataResponse{}
	_body, _err := client.GetOpSensitiveDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetOptionValueForProjectWithOptions(request *GetOptionValueForProjectRequest, runtime *util.RuntimeOptions) (_result *GetOptionValueForProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ExtensionCode)) {
		body["ExtensionCode"] = request.ExtensionCode
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetOptionValueForProject"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetOptionValueForProjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetOptionValueForProject(request *GetOptionValueForProjectRequest) (_result *GetOptionValueForProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetOptionValueForProjectResponse{}
	_body, _err := client.GetOptionValueForProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetPermissionApplyOrderDetailWithOptions(request *GetPermissionApplyOrderDetailRequest, runtime *util.RuntimeOptions) (_result *GetPermissionApplyOrderDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FlowId)) {
		query["FlowId"] = request.FlowId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetPermissionApplyOrderDetail"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetPermissionApplyOrderDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetPermissionApplyOrderDetail(request *GetPermissionApplyOrderDetailRequest) (_result *GetPermissionApplyOrderDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetPermissionApplyOrderDetailResponse{}
	_body, _err := client.GetPermissionApplyOrderDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetProjectWithOptions(request *GetProjectRequest, runtime *util.RuntimeOptions) (_result *GetProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		query["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetProject"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetProjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetProject(request *GetProjectRequest) (_result *GetProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetProjectResponse{}
	_body, _err := client.GetProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetProjectDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetProjectDetailResponse
 */
// Deprecated
func (client *Client) GetProjectDetailWithOptions(request *GetProjectDetailRequest, runtime *util.RuntimeOptions) (_result *GetProjectDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetProjectDetail"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetProjectDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetProjectDetailRequest
 * @return GetProjectDetailResponse
 */
// Deprecated
func (client *Client) GetProjectDetail(request *GetProjectDetailRequest) (_result *GetProjectDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetProjectDetailResponse{}
	_body, _err := client.GetProjectDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetQualityEntityWithOptions(request *GetQualityEntityRequest, runtime *util.RuntimeOptions) (_result *GetQualityEntityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		body["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.MatchExpression)) {
		body["MatchExpression"] = request.MatchExpression
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		body["TableName"] = request.TableName
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetQualityEntity"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetQualityEntityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetQualityEntity(request *GetQualityEntityRequest) (_result *GetQualityEntityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetQualityEntityResponse{}
	_body, _err := client.GetQualityEntityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetQualityFollowerWithOptions(request *GetQualityFollowerRequest, runtime *util.RuntimeOptions) (_result *GetQualityFollowerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EntityId)) {
		body["EntityId"] = request.EntityId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetQualityFollower"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetQualityFollowerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetQualityFollower(request *GetQualityFollowerRequest) (_result *GetQualityFollowerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetQualityFollowerResponse{}
	_body, _err := client.GetQualityFollowerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetQualityRuleWithOptions(request *GetQualityRuleRequest, runtime *util.RuntimeOptions) (_result *GetQualityRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		body["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetQualityRule"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetQualityRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetQualityRule(request *GetQualityRuleRequest) (_result *GetQualityRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetQualityRuleResponse{}
	_body, _err := client.GetQualityRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetRemindWithOptions(request *GetRemindRequest, runtime *util.RuntimeOptions) (_result *GetRemindResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RemindId)) {
		body["RemindId"] = request.RemindId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetRemind"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetRemindResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetRemind(request *GetRemindRequest) (_result *GetRemindResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetRemindResponse{}
	_body, _err := client.GetRemindWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetSensitiveDataWithOptions(request *GetSensitiveDataRequest, runtime *util.RuntimeOptions) (_result *GetSensitiveDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSensitiveData"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSensitiveDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetSensitiveData(request *GetSensitiveDataRequest) (_result *GetSensitiveDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSensitiveDataResponse{}
	_body, _err := client.GetSensitiveDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetSuccessInstanceTrendRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSuccessInstanceTrendResponse
 */
// Deprecated
func (client *Client) GetSuccessInstanceTrendWithOptions(request *GetSuccessInstanceTrendRequest, runtime *util.RuntimeOptions) (_result *GetSuccessInstanceTrendResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSuccessInstanceTrend"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSuccessInstanceTrendResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request GetSuccessInstanceTrendRequest
 * @return GetSuccessInstanceTrendResponse
 */
// Deprecated
func (client *Client) GetSuccessInstanceTrend(request *GetSuccessInstanceTrendRequest) (_result *GetSuccessInstanceTrendResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSuccessInstanceTrendResponse{}
	_body, _err := client.GetSuccessInstanceTrendWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ****
 *
 * @param request GetTopicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTopicResponse
 */
func (client *Client) GetTopicWithOptions(request *GetTopicRequest, runtime *util.RuntimeOptions) (_result *GetTopicResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TopicId)) {
		body["TopicId"] = request.TopicId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTopic"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTopicResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ****
 *
 * @param request GetTopicRequest
 * @return GetTopicResponse
 */
func (client *Client) GetTopic(request *GetTopicRequest) (_result *GetTopicResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTopicResponse{}
	_body, _err := client.GetTopicWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetTopicInfluenceWithOptions(request *GetTopicInfluenceRequest, runtime *util.RuntimeOptions) (_result *GetTopicInfluenceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TopicId)) {
		body["TopicId"] = request.TopicId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetTopicInfluence"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetTopicInfluenceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetTopicInfluence(request *GetTopicInfluenceRequest) (_result *GetTopicInfluenceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetTopicInfluenceResponse{}
	_body, _err := client.GetTopicInfluenceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can import self-managed data sources or data sources that are exported from other Dataworks workspaces to a specified DataWorks workspace.
 * *   To import a self-managed data source to DataWorks, the data source type must be supported by DataWorks. For more information about the types of data sources supported by DataWorks, see [Supported data stores](~~181656~~).
 * *   For more information about how to export data sources from DataWorks workspaces to on-premises devices, see [ExportDataSources](~~279570~~).
 *
 * @param request ImportDataSourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportDataSourcesResponse
 */
func (client *Client) ImportDataSourcesWithOptions(request *ImportDataSourcesRequest, runtime *util.RuntimeOptions) (_result *ImportDataSourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataSources)) {
		query["DataSources"] = request.DataSources
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ImportDataSources"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ImportDataSourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can import self-managed data sources or data sources that are exported from other Dataworks workspaces to a specified DataWorks workspace.
 * *   To import a self-managed data source to DataWorks, the data source type must be supported by DataWorks. For more information about the types of data sources supported by DataWorks, see [Supported data stores](~~181656~~).
 * *   For more information about how to export data sources from DataWorks workspaces to on-premises devices, see [ExportDataSources](~~279570~~).
 *
 * @param request ImportDataSourcesRequest
 * @return ImportDataSourcesResponse
 */
func (client *Client) ImportDataSources(request *ImportDataSourcesRequest) (_result *ImportDataSourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ImportDataSourcesResponse{}
	_body, _err := client.ImportDataSourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAlertMessagesWithOptions(request *ListAlertMessagesRequest, runtime *util.RuntimeOptions) (_result *ListAlertMessagesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertMethods)) {
		body["AlertMethods"] = request.AlertMethods
	}

	if !tea.BoolValue(util.IsUnset(request.AlertRuleTypes)) {
		body["AlertRuleTypes"] = request.AlertRuleTypes
	}

	if !tea.BoolValue(util.IsUnset(request.AlertUser)) {
		body["AlertUser"] = request.AlertUser
	}

	if !tea.BoolValue(util.IsUnset(request.BaselineId)) {
		body["BaselineId"] = request.BaselineId
	}

	if !tea.BoolValue(util.IsUnset(request.BeginTime)) {
		body["BeginTime"] = request.BeginTime
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		body["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RemindId)) {
		body["RemindId"] = request.RemindId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAlertMessages"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAlertMessagesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAlertMessages(request *ListAlertMessagesRequest) (_result *ListAlertMessagesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAlertMessagesResponse{}
	_body, _err := client.ListAlertMessagesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListBaselineConfigsWithOptions(request *ListBaselineConfigsRequest, runtime *util.RuntimeOptions) (_result *ListBaselineConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BaselineTypes)) {
		body["BaselineTypes"] = request.BaselineTypes
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		body["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.SearchText)) {
		body["SearchText"] = request.SearchText
	}

	if !tea.BoolValue(util.IsUnset(request.Useflag)) {
		body["Useflag"] = request.Useflag
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListBaselineConfigs"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListBaselineConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListBaselineConfigs(request *ListBaselineConfigsRequest) (_result *ListBaselineConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListBaselineConfigsResponse{}
	_body, _err := client.ListBaselineConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListBaselineStatusesWithOptions(request *ListBaselineStatusesRequest, runtime *util.RuntimeOptions) (_result *ListBaselineStatusesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BaselineTypes)) {
		body["BaselineTypes"] = request.BaselineTypes
	}

	if !tea.BoolValue(util.IsUnset(request.Bizdate)) {
		body["Bizdate"] = request.Bizdate
	}

	if !tea.BoolValue(util.IsUnset(request.FinishStatus)) {
		body["FinishStatus"] = request.FinishStatus
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		body["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.SearchText)) {
		body["SearchText"] = request.SearchText
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		body["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TopicId)) {
		body["TopicId"] = request.TopicId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListBaselineStatuses"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListBaselineStatusesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListBaselineStatuses(request *ListBaselineStatusesRequest) (_result *ListBaselineStatusesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListBaselineStatusesResponse{}
	_body, _err := client.ListBaselineStatusesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListBaselinesWithOptions(request *ListBaselinesRequest, runtime *util.RuntimeOptions) (_result *ListBaselinesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BaselineTypes)) {
		body["BaselineTypes"] = request.BaselineTypes
	}

	if !tea.BoolValue(util.IsUnset(request.Enable)) {
		body["Enable"] = request.Enable
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		body["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.SearchText)) {
		body["SearchText"] = request.SearchText
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListBaselines"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListBaselinesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListBaselines(request *ListBaselinesRequest) (_result *ListBaselinesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListBaselinesResponse{}
	_body, _err := client.ListBaselinesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListBusinessWithOptions(request *ListBusinessRequest, runtime *util.RuntimeOptions) (_result *ListBusinessResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		body["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListBusiness"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListBusinessResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListBusiness(request *ListBusinessRequest) (_result *ListBusinessResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListBusinessResponse{}
	_body, _err := client.ListBusinessWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListCalcEnginesWithOptions(request *ListCalcEnginesRequest, runtime *util.RuntimeOptions) (_result *ListCalcEnginesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CalcEngineType)) {
		query["CalcEngineType"] = request.CalcEngineType
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListCalcEngines"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListCalcEnginesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListCalcEngines(request *ListCalcEnginesRequest) (_result *ListCalcEnginesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListCalcEnginesResponse{}
	_body, _err := client.ListCalcEnginesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request ListConnectionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListConnectionsResponse
 */
// Deprecated
func (client *Client) ListConnectionsWithOptions(request *ListConnectionsRequest, runtime *util.RuntimeOptions) (_result *ListConnectionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListConnections"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListConnectionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request ListConnectionsRequest
 * @return ListConnectionsResponse
 */
// Deprecated
func (client *Client) ListConnections(request *ListConnectionsRequest) (_result *ListConnectionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListConnectionsResponse{}
	_body, _err := client.ListConnectionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDIAlarmRulesWithOptions(request *ListDIAlarmRulesRequest, runtime *util.RuntimeOptions) (_result *ListDIAlarmRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DIJobId)) {
		body["DIJobId"] = request.DIJobId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDIAlarmRules"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDIAlarmRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDIAlarmRules(request *ListDIAlarmRulesRequest) (_result *ListDIAlarmRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDIAlarmRulesResponse{}
	_body, _err := client.ListDIAlarmRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDIJobsWithOptions(request *ListDIJobsRequest, runtime *util.RuntimeOptions) (_result *ListDIJobsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DestinationDataSourceType)) {
		body["DestinationDataSourceType"] = request.DestinationDataSourceType
	}

	if !tea.BoolValue(util.IsUnset(request.JobName)) {
		body["JobName"] = request.JobName
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceDataSourceType)) {
		body["SourceDataSourceType"] = request.SourceDataSourceType
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDIJobs"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDIJobsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDIJobs(request *ListDIJobsRequest) (_result *ListDIJobsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDIJobsResponse{}
	_body, _err := client.ListDIJobsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * DataWorks allows you to set the default global configuration for only the processing rules of DDL messages in sync solutions. After you configure the **processing rules of DDL messages** in sync solutions, the configuration is set as the default global configuration and applies to all real-time sync nodes. You can also modify the **processing rules of DDL messages** based on your business requirements. For more information, see [Sync solutions](~~199008~~).
 *
 * @param request ListDIProjectConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDIProjectConfigResponse
 */
func (client *Client) ListDIProjectConfigWithOptions(request *ListDIProjectConfigRequest, runtime *util.RuntimeOptions) (_result *ListDIProjectConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DestinationType)) {
		query["DestinationType"] = request.DestinationType
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		query["SourceType"] = request.SourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDIProjectConfig"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDIProjectConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * DataWorks allows you to set the default global configuration for only the processing rules of DDL messages in sync solutions. After you configure the **processing rules of DDL messages** in sync solutions, the configuration is set as the default global configuration and applies to all real-time sync nodes. You can also modify the **processing rules of DDL messages** based on your business requirements. For more information, see [Sync solutions](~~199008~~).
 *
 * @param request ListDIProjectConfigRequest
 * @return ListDIProjectConfigResponse
 */
func (client *Client) ListDIProjectConfig(request *ListDIProjectConfigRequest) (_result *ListDIProjectConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDIProjectConfigResponse{}
	_body, _err := client.ListDIProjectConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **ListDags**.
 *
 * @param request ListDagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDagsResponse
 */
func (client *Client) ListDagsWithOptions(request *ListDagsRequest, runtime *util.RuntimeOptions) (_result *ListDagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OpSeq)) {
		body["OpSeq"] = request.OpSeq
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDags"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **ListDags**.
 *
 * @param request ListDagsRequest
 * @return ListDagsResponse
 */
func (client *Client) ListDags(request *ListDagsRequest) (_result *ListDagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDagsResponse{}
	_body, _err := client.ListDagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDataServiceApiAuthoritiesWithOptions(request *ListDataServiceApiAuthoritiesRequest, runtime *util.RuntimeOptions) (_result *ListDataServiceApiAuthoritiesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiNameKeyword)) {
		body["ApiNameKeyword"] = request.ApiNameKeyword
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataServiceApiAuthorities"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataServiceApiAuthoritiesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDataServiceApiAuthorities(request *ListDataServiceApiAuthoritiesRequest) (_result *ListDataServiceApiAuthoritiesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDataServiceApiAuthoritiesResponse{}
	_body, _err := client.ListDataServiceApiAuthoritiesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDataServiceApiTestWithOptions(request *ListDataServiceApiTestRequest, runtime *util.RuntimeOptions) (_result *ListDataServiceApiTestResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataServiceApiTest"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataServiceApiTestResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDataServiceApiTest(request *ListDataServiceApiTestRequest) (_result *ListDataServiceApiTestResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDataServiceApiTestResponse{}
	_body, _err := client.ListDataServiceApiTestWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDataServiceApisWithOptions(request *ListDataServiceApisRequest, runtime *util.RuntimeOptions) (_result *ListDataServiceApisResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiNameKeyword)) {
		body["ApiNameKeyword"] = request.ApiNameKeyword
	}

	if !tea.BoolValue(util.IsUnset(request.ApiPathKeyword)) {
		body["ApiPathKeyword"] = request.ApiPathKeyword
	}

	if !tea.BoolValue(util.IsUnset(request.CreatorId)) {
		body["CreatorId"] = request.CreatorId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataServiceApis"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataServiceApisResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDataServiceApis(request *ListDataServiceApisRequest) (_result *ListDataServiceApisResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDataServiceApisResponse{}
	_body, _err := client.ListDataServiceApisWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDataServiceApplicationsWithOptions(request *ListDataServiceApplicationsRequest, runtime *util.RuntimeOptions) (_result *ListDataServiceApplicationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdList)) {
		body["ProjectIdList"] = request.ProjectIdList
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataServiceApplications"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataServiceApplicationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDataServiceApplications(request *ListDataServiceApplicationsRequest) (_result *ListDataServiceApplicationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDataServiceApplicationsResponse{}
	_body, _err := client.ListDataServiceApplicationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDataServiceAuthorizedApisWithOptions(request *ListDataServiceAuthorizedApisRequest, runtime *util.RuntimeOptions) (_result *ListDataServiceAuthorizedApisResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiNameKeyword)) {
		body["ApiNameKeyword"] = request.ApiNameKeyword
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataServiceAuthorizedApis"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataServiceAuthorizedApisResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDataServiceAuthorizedApis(request *ListDataServiceAuthorizedApisRequest) (_result *ListDataServiceAuthorizedApisResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDataServiceAuthorizedApisResponse{}
	_body, _err := client.ListDataServiceAuthorizedApisWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDataServiceFoldersWithOptions(request *ListDataServiceFoldersRequest, runtime *util.RuntimeOptions) (_result *ListDataServiceFoldersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FolderNameKeyword)) {
		body["FolderNameKeyword"] = request.FolderNameKeyword
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		body["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataServiceFolders"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataServiceFoldersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDataServiceFolders(request *ListDataServiceFoldersRequest) (_result *ListDataServiceFoldersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDataServiceFoldersResponse{}
	_body, _err := client.ListDataServiceFoldersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDataServiceGroupsWithOptions(request *ListDataServiceGroupsRequest, runtime *util.RuntimeOptions) (_result *ListDataServiceGroupsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupNameKeyword)) {
		body["GroupNameKeyword"] = request.GroupNameKeyword
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataServiceGroups"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataServiceGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDataServiceGroups(request *ListDataServiceGroupsRequest) (_result *ListDataServiceGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDataServiceGroupsResponse{}
	_body, _err := client.ListDataServiceGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDataServicePublishedApisWithOptions(request *ListDataServicePublishedApisRequest, runtime *util.RuntimeOptions) (_result *ListDataServicePublishedApisResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiNameKeyword)) {
		body["ApiNameKeyword"] = request.ApiNameKeyword
	}

	if !tea.BoolValue(util.IsUnset(request.ApiPathKeyword)) {
		body["ApiPathKeyword"] = request.ApiPathKeyword
	}

	if !tea.BoolValue(util.IsUnset(request.CreatorId)) {
		body["CreatorId"] = request.CreatorId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataServicePublishedApis"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataServicePublishedApisResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDataServicePublishedApis(request *ListDataServicePublishedApisRequest) (_result *ListDataServicePublishedApisResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDataServicePublishedApisResponse{}
	_body, _err := client.ListDataServicePublishedApisWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDataSourcesWithOptions(request *ListDataSourcesRequest, runtime *util.RuntimeOptions) (_result *ListDataSourcesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataSources"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataSourcesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDataSources(request *ListDataSourcesRequest) (_result *ListDataSourcesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDataSourcesResponse{}
	_body, _err := client.ListDataSourcesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDeploymentsWithOptions(request *ListDeploymentsRequest, runtime *util.RuntimeOptions) (_result *ListDeploymentsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Creator)) {
		body["Creator"] = request.Creator
	}

	if !tea.BoolValue(util.IsUnset(request.EndCreateTime)) {
		body["EndCreateTime"] = request.EndCreateTime
	}

	if !tea.BoolValue(util.IsUnset(request.EndExecuteTime)) {
		body["EndExecuteTime"] = request.EndExecuteTime
	}

	if !tea.BoolValue(util.IsUnset(request.Executor)) {
		body["Executor"] = request.Executor
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		body["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		body["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDeployments"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDeploymentsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDeployments(request *ListDeploymentsRequest) (_result *ListDeploymentsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDeploymentsResponse{}
	_body, _err := client.ListDeploymentsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEnabledExtensionsForProjectWithOptions(request *ListEnabledExtensionsForProjectRequest, runtime *util.RuntimeOptions) (_result *ListEnabledExtensionsForProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EventCode)) {
		body["EventCode"] = request.EventCode
	}

	if !tea.BoolValue(util.IsUnset(request.FileType)) {
		body["FileType"] = request.FileType
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEnabledExtensionsForProject"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEnabledExtensionsForProjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEnabledExtensionsForProject(request *ListEnabledExtensionsForProjectRequest) (_result *ListEnabledExtensionsForProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEnabledExtensionsForProjectResponse{}
	_body, _err := client.ListEnabledExtensionsForProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEntitiesByTagsWithOptions(tmpReq *ListEntitiesByTagsRequest, runtime *util.RuntimeOptions) (_result *ListEntitiesByTagsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListEntitiesByTagsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Tags)) {
		request.TagsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tags, tea.String("Tags"), tea.String("json"))
	}

	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEntitiesByTags"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEntitiesByTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEntitiesByTags(request *ListEntitiesByTagsRequest) (_result *ListEntitiesByTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEntitiesByTagsResponse{}
	_body, _err := client.ListEntitiesByTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListEntityTagsWithOptions(request *ListEntityTagsRequest, runtime *util.RuntimeOptions) (_result *ListEntityTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListEntityTags"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListEntityTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListEntityTags(request *ListEntityTagsRequest) (_result *ListEntityTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListEntityTagsResponse{}
	_body, _err := client.ListEntityTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListExtensionsWithOptions(request *ListExtensionsRequest, runtime *util.RuntimeOptions) (_result *ListExtensionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListExtensions"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListExtensionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListExtensions(request *ListExtensionsRequest) (_result *ListExtensionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListExtensionsResponse{}
	_body, _err := client.ListExtensionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListFileTypeWithOptions(request *ListFileTypeRequest, runtime *util.RuntimeOptions) (_result *ListFileTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		body["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.Locale)) {
		body["Locale"] = request.Locale
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListFileType"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListFileTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListFileType(request *ListFileTypeRequest) (_result *ListFileTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListFileTypeResponse{}
	_body, _err := client.ListFileTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListFileVersionsWithOptions(request *ListFileVersionsRequest, runtime *util.RuntimeOptions) (_result *ListFileVersionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		body["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListFileVersions"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListFileVersionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListFileVersions(request *ListFileVersionsRequest) (_result *ListFileVersionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListFileVersionsResponse{}
	_body, _err := client.ListFileVersionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListFilesWithOptions(request *ListFilesRequest, runtime *util.RuntimeOptions) (_result *ListFilesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ExactFileName)) {
		body["ExactFileName"] = request.ExactFileName
	}

	if !tea.BoolValue(util.IsUnset(request.FileFolderPath)) {
		body["FileFolderPath"] = request.FileFolderPath
	}

	if !tea.BoolValue(util.IsUnset(request.FileIdIn)) {
		body["FileIdIn"] = request.FileIdIn
	}

	if !tea.BoolValue(util.IsUnset(request.FileTypes)) {
		body["FileTypes"] = request.FileTypes
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		body["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.NeedAbsoluteFolderPath)) {
		body["NeedAbsoluteFolderPath"] = request.NeedAbsoluteFolderPath
	}

	if !tea.BoolValue(util.IsUnset(request.NeedContent)) {
		body["NeedContent"] = request.NeedContent
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.UseType)) {
		body["UseType"] = request.UseType
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListFiles"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListFilesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListFiles(request *ListFilesRequest) (_result *ListFilesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListFilesResponse{}
	_body, _err := client.ListFilesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListFoldersWithOptions(request *ListFoldersRequest, runtime *util.RuntimeOptions) (_result *ListFoldersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ParentFolderPath)) {
		body["ParentFolderPath"] = request.ParentFolderPath
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListFolders"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListFoldersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListFolders(request *ListFoldersRequest) (_result *ListFoldersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListFoldersResponse{}
	_body, _err := client.ListFoldersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListInnerNodesWithOptions(request *ListInnerNodesRequest, runtime *util.RuntimeOptions) (_result *ListInnerNodesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeName)) {
		body["NodeName"] = request.NodeName
	}

	if !tea.BoolValue(util.IsUnset(request.OuterNodeId)) {
		body["OuterNodeId"] = request.OuterNodeId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProgramType)) {
		body["ProgramType"] = request.ProgramType
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListInnerNodes"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListInnerNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListInnerNodes(request *ListInnerNodesRequest) (_result *ListInnerNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListInnerNodesResponse{}
	_body, _err := client.ListInnerNodesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListInstanceAmountWithOptions(request *ListInstanceAmountRequest, runtime *util.RuntimeOptions) (_result *ListInstanceAmountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BeginDate)) {
		body["BeginDate"] = request.BeginDate
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		body["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListInstanceAmount"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListInstanceAmountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListInstanceAmount(request *ListInstanceAmountRequest) (_result *ListInstanceAmountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListInstanceAmountResponse{}
	_body, _err := client.ListInstanceAmountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListInstanceHistoryWithOptions(request *ListInstanceHistoryRequest, runtime *util.RuntimeOptions) (_result *ListInstanceHistoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		body["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListInstanceHistory"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListInstanceHistoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListInstanceHistory(request *ListInstanceHistoryRequest) (_result *ListInstanceHistoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListInstanceHistoryResponse{}
	_body, _err := client.ListInstanceHistoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListInstancesWithOptions(request *ListInstancesRequest, runtime *util.RuntimeOptions) (_result *ListInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BeginBizdate)) {
		body["BeginBizdate"] = request.BeginBizdate
	}

	if !tea.BoolValue(util.IsUnset(request.BizName)) {
		body["BizName"] = request.BizName
	}

	if !tea.BoolValue(util.IsUnset(request.Bizdate)) {
		body["Bizdate"] = request.Bizdate
	}

	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		body["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.EndBizdate)) {
		body["EndBizdate"] = request.EndBizdate
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.NodeName)) {
		body["NodeName"] = request.NodeName
	}

	if !tea.BoolValue(util.IsUnset(request.OrderBy)) {
		body["OrderBy"] = request.OrderBy
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProgramType)) {
		body["ProgramType"] = request.ProgramType
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		body["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListInstances"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListInstances(request *ListInstancesRequest) (_result *ListInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListInstancesResponse{}
	_body, _err := client.ListInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListLineageWithOptions(request *ListLineageRequest, runtime *util.RuntimeOptions) (_result *ListLineageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Direction)) {
		query["Direction"] = request.Direction
	}

	if !tea.BoolValue(util.IsUnset(request.EntityQualifiedName)) {
		query["EntityQualifiedName"] = request.EntityQualifiedName
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListLineage"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListLineageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListLineage(request *ListLineageRequest) (_result *ListLineageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListLineageResponse{}
	_body, _err := client.ListLineageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListManualDagInstancesWithOptions(request *ListManualDagInstancesRequest, runtime *util.RuntimeOptions) (_result *ListManualDagInstancesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DagId)) {
		body["DagId"] = request.DagId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListManualDagInstances"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListManualDagInstancesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListManualDagInstances(request *ListManualDagInstancesRequest) (_result *ListManualDagInstancesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListManualDagInstancesResponse{}
	_body, _err := client.ListManualDagInstancesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListMetaCollectionEntitiesWithOptions(request *ListMetaCollectionEntitiesRequest, runtime *util.RuntimeOptions) (_result *ListMetaCollectionEntitiesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CollectionQualifiedName)) {
		query["CollectionQualifiedName"] = request.CollectionQualifiedName
	}

	if !tea.BoolValue(util.IsUnset(request.EntityType)) {
		query["EntityType"] = request.EntityType
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListMetaCollectionEntities"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListMetaCollectionEntitiesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListMetaCollectionEntities(request *ListMetaCollectionEntitiesRequest) (_result *ListMetaCollectionEntitiesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListMetaCollectionEntitiesResponse{}
	_body, _err := client.ListMetaCollectionEntitiesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can configure only one of the Creator, Administrator, and Follower parameters.
 *
 * @param request ListMetaCollectionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListMetaCollectionsResponse
 */
func (client *Client) ListMetaCollectionsWithOptions(request *ListMetaCollectionsRequest, runtime *util.RuntimeOptions) (_result *ListMetaCollectionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Administrator)) {
		query["Administrator"] = request.Administrator
	}

	if !tea.BoolValue(util.IsUnset(request.CollectionType)) {
		query["CollectionType"] = request.CollectionType
	}

	if !tea.BoolValue(util.IsUnset(request.Creator)) {
		query["Creator"] = request.Creator
	}

	if !tea.BoolValue(util.IsUnset(request.Follower)) {
		query["Follower"] = request.Follower
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.OrderBy)) {
		query["OrderBy"] = request.OrderBy
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ParentQualifiedName)) {
		query["ParentQualifiedName"] = request.ParentQualifiedName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListMetaCollections"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListMetaCollectionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can configure only one of the Creator, Administrator, and Follower parameters.
 *
 * @param request ListMetaCollectionsRequest
 * @return ListMetaCollectionsResponse
 */
func (client *Client) ListMetaCollections(request *ListMetaCollectionsRequest) (_result *ListMetaCollectionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListMetaCollectionsResponse{}
	_body, _err := client.ListMetaCollectionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListMetaDBWithOptions(request *ListMetaDBRequest, runtime *util.RuntimeOptions) (_result *ListMetaDBResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListMetaDB"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListMetaDBResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListMetaDB(request *ListMetaDBRequest) (_result *ListMetaDBResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListMetaDBResponse{}
	_body, _err := client.ListMetaDBWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListMigrationsWithOptions(request *ListMigrationsRequest, runtime *util.RuntimeOptions) (_result *ListMigrationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MigrationType)) {
		body["MigrationType"] = request.MigrationType
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListMigrations"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListMigrationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListMigrations(request *ListMigrationsRequest) (_result *ListMigrationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListMigrationsResponse{}
	_body, _err := client.ListMigrationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request ListNodeIORequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNodeIOResponse
 */
// Deprecated
func (client *Client) ListNodeIOWithOptions(request *ListNodeIORequest, runtime *util.RuntimeOptions) (_result *ListNodeIOResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IoType)) {
		body["IoType"] = request.IoType
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListNodeIO"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListNodeIOResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request ListNodeIORequest
 * @return ListNodeIOResponse
 */
// Deprecated
func (client *Client) ListNodeIO(request *ListNodeIORequest) (_result *ListNodeIOResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListNodeIOResponse{}
	_body, _err := client.ListNodeIOWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListNodeInputOrOutputWithOptions(request *ListNodeInputOrOutputRequest, runtime *util.RuntimeOptions) (_result *ListNodeInputOrOutputResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IoType)) {
		body["IoType"] = request.IoType
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListNodeInputOrOutput"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListNodeInputOrOutputResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListNodeInputOrOutput(request *ListNodeInputOrOutputRequest) (_result *ListNodeInputOrOutputResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListNodeInputOrOutputResponse{}
	_body, _err := client.ListNodeInputOrOutputWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListNodesWithOptions(request *ListNodesRequest, runtime *util.RuntimeOptions) (_result *ListNodesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BizName)) {
		body["BizName"] = request.BizName
	}

	if !tea.BoolValue(util.IsUnset(request.NodeName)) {
		body["NodeName"] = request.NodeName
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProgramType)) {
		body["ProgramType"] = request.ProgramType
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.SchedulerType)) {
		body["SchedulerType"] = request.SchedulerType
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListNodes"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListNodes(request *ListNodesRequest) (_result *ListNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListNodesResponse{}
	_body, _err := client.ListNodesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListNodesByBaselineWithOptions(request *ListNodesByBaselineRequest, runtime *util.RuntimeOptions) (_result *ListNodesByBaselineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BaselineId)) {
		body["BaselineId"] = request.BaselineId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListNodesByBaseline"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListNodesByBaselineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListNodesByBaseline(request *ListNodesByBaselineRequest) (_result *ListNodesByBaselineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListNodesByBaselineResponse{}
	_body, _err := client.ListNodesByBaselineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListNodesByOutputWithOptions(request *ListNodesByOutputRequest, runtime *util.RuntimeOptions) (_result *ListNodesByOutputResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Outputs)) {
		body["Outputs"] = request.Outputs
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListNodesByOutput"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListNodesByOutputResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListNodesByOutput(request *ListNodesByOutputRequest) (_result *ListNodesByOutputResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListNodesByOutputResponse{}
	_body, _err := client.ListNodesByOutputWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListPermissionApplyOrdersWithOptions(request *ListPermissionApplyOrdersRequest, runtime *util.RuntimeOptions) (_result *ListPermissionApplyOrdersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.EngineType)) {
		query["EngineType"] = request.EngineType
	}

	if !tea.BoolValue(util.IsUnset(request.FlowStatus)) {
		query["FlowStatus"] = request.FlowStatus
	}

	if !tea.BoolValue(util.IsUnset(request.MaxComputeProjectName)) {
		query["MaxComputeProjectName"] = request.MaxComputeProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.OrderType)) {
		query["OrderType"] = request.OrderType
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.QueryType)) {
		query["QueryType"] = request.QueryType
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.WorkspaceId)) {
		query["WorkspaceId"] = request.WorkspaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListPermissionApplyOrders"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListPermissionApplyOrdersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListPermissionApplyOrders(request *ListPermissionApplyOrdersRequest) (_result *ListPermissionApplyOrdersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListPermissionApplyOrdersResponse{}
	_body, _err := client.ListPermissionApplyOrdersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request ListProgramTypeCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProgramTypeCountResponse
 */
// Deprecated
func (client *Client) ListProgramTypeCountWithOptions(request *ListProgramTypeCountRequest, runtime *util.RuntimeOptions) (_result *ListProgramTypeCountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListProgramTypeCount"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListProgramTypeCountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request ListProgramTypeCountRequest
 * @return ListProgramTypeCountResponse
 */
// Deprecated
func (client *Client) ListProgramTypeCount(request *ListProgramTypeCountRequest) (_result *ListProgramTypeCountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListProgramTypeCountResponse{}
	_body, _err := client.ListProgramTypeCountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * For example, an Alibaba Cloud account can assume the developer, O&M engineer, or workspace administrator role in a workspace. For more information, see [Manage members and roles](~~136941~~).
 *
 * @param request ListProjectIdsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProjectIdsResponse
 */
func (client *Client) ListProjectIdsWithOptions(request *ListProjectIdsRequest, runtime *util.RuntimeOptions) (_result *ListProjectIdsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.UserId)) {
		query["UserId"] = request.UserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListProjectIds"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListProjectIdsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * For example, an Alibaba Cloud account can assume the developer, O&M engineer, or workspace administrator role in a workspace. For more information, see [Manage members and roles](~~136941~~).
 *
 * @param request ListProjectIdsRequest
 * @return ListProjectIdsResponse
 */
func (client *Client) ListProjectIds(request *ListProjectIdsRequest) (_result *ListProjectIdsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListProjectIdsResponse{}
	_body, _err := client.ListProjectIdsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListProjectMembersWithOptions(request *ListProjectMembersRequest, runtime *util.RuntimeOptions) (_result *ListProjectMembersResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListProjectMembers"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListProjectMembersResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListProjectMembers(request *ListProjectMembersRequest) (_result *ListProjectMembersResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListProjectMembersResponse{}
	_body, _err := client.ListProjectMembersWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListProjectRolesWithOptions(request *ListProjectRolesRequest, runtime *util.RuntimeOptions) (_result *ListProjectRolesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListProjectRoles"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListProjectRolesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListProjectRoles(request *ListProjectRolesRequest) (_result *ListProjectRolesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListProjectRolesResponse{}
	_body, _err := client.ListProjectRolesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListProjectsWithOptions(tmpReq *ListProjectsRequest, runtime *util.RuntimeOptions) (_result *ListProjectsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListProjectsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Tags)) {
		request.TagsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tags, tea.String("Tags"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceManagerResourceGroupId)) {
		query["ResourceManagerResourceGroupId"] = request.ResourceManagerResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TagsShrink)) {
		query["Tags"] = request.TagsShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListProjects"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListProjectsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListProjects(request *ListProjectsRequest) (_result *ListProjectsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListProjectsResponse{}
	_body, _err := client.ListProjectsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ****
 *
 * @param request ListQualityResultsByEntityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQualityResultsByEntityResponse
 */
func (client *Client) ListQualityResultsByEntityWithOptions(request *ListQualityResultsByEntityRequest, runtime *util.RuntimeOptions) (_result *ListQualityResultsByEntityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		body["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.EntityId)) {
		body["EntityId"] = request.EntityId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		body["StartDate"] = request.StartDate
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListQualityResultsByEntity"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListQualityResultsByEntityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ****
 *
 * @param request ListQualityResultsByEntityRequest
 * @return ListQualityResultsByEntityResponse
 */
func (client *Client) ListQualityResultsByEntity(request *ListQualityResultsByEntityRequest) (_result *ListQualityResultsByEntityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListQualityResultsByEntityResponse{}
	_body, _err := client.ListQualityResultsByEntityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListQualityResultsByRuleWithOptions(request *ListQualityResultsByRuleRequest, runtime *util.RuntimeOptions) (_result *ListQualityResultsByRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		body["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		body["RuleId"] = request.RuleId
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		body["StartDate"] = request.StartDate
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListQualityResultsByRule"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListQualityResultsByRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListQualityResultsByRule(request *ListQualityResultsByRuleRequest) (_result *ListQualityResultsByRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListQualityResultsByRuleResponse{}
	_body, _err := client.ListQualityResultsByRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListQualityRulesWithOptions(request *ListQualityRulesRequest, runtime *util.RuntimeOptions) (_result *ListQualityRulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EntityId)) {
		body["EntityId"] = request.EntityId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListQualityRules"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListQualityRulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListQualityRules(request *ListQualityRulesRequest) (_result *ListQualityRulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListQualityRulesResponse{}
	_body, _err := client.ListQualityRulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListRefDISyncTasksWithOptions(request *ListRefDISyncTasksRequest, runtime *util.RuntimeOptions) (_result *ListRefDISyncTasksResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DatasourceName)) {
		query["DatasourceName"] = request.DatasourceName
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.RefType)) {
		query["RefType"] = request.RefType
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListRefDISyncTasks"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListRefDISyncTasksResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListRefDISyncTasks(request *ListRefDISyncTasksRequest) (_result *ListRefDISyncTasksResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListRefDISyncTasksResponse{}
	_body, _err := client.ListRefDISyncTasksWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListRemindsWithOptions(request *ListRemindsRequest, runtime *util.RuntimeOptions) (_result *ListRemindsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertTarget)) {
		body["AlertTarget"] = request.AlertTarget
	}

	if !tea.BoolValue(util.IsUnset(request.Founder)) {
		body["Founder"] = request.Founder
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RemindTypes)) {
		body["RemindTypes"] = request.RemindTypes
	}

	if !tea.BoolValue(util.IsUnset(request.SearchText)) {
		body["SearchText"] = request.SearchText
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListReminds"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListRemindsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListReminds(request *ListRemindsRequest) (_result *ListRemindsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListRemindsResponse{}
	_body, _err := client.ListRemindsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListResourceGroupsWithOptions(tmpReq *ListResourceGroupsRequest, runtime *util.RuntimeOptions) (_result *ListResourceGroupsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListResourceGroupsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Tags)) {
		request.TagsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tags, tea.String("Tags"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BizExtKey)) {
		query["BizExtKey"] = request.BizExtKey
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupType)) {
		query["ResourceGroupType"] = request.ResourceGroupType
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceManagerResourceGroupId)) {
		query["ResourceManagerResourceGroupId"] = request.ResourceManagerResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TagsShrink)) {
		query["Tags"] = request.TagsShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListResourceGroups"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListResourceGroupsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListResourceGroups(request *ListResourceGroupsRequest) (_result *ListResourceGroupsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListResourceGroupsResponse{}
	_body, _err := client.ListResourceGroupsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListShiftPersonnelsWithOptions(request *ListShiftPersonnelsRequest, runtime *util.RuntimeOptions) (_result *ListShiftPersonnelsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BeginTime)) {
		body["BeginTime"] = request.BeginTime
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		body["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ShiftPersonUID)) {
		body["ShiftPersonUID"] = request.ShiftPersonUID
	}

	if !tea.BoolValue(util.IsUnset(request.ShiftScheduleIdentifier)) {
		body["ShiftScheduleIdentifier"] = request.ShiftScheduleIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.UserType)) {
		body["UserType"] = request.UserType
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListShiftPersonnels"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListShiftPersonnelsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListShiftPersonnels(request *ListShiftPersonnelsRequest) (_result *ListShiftPersonnelsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListShiftPersonnelsResponse{}
	_body, _err := client.ListShiftPersonnelsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListShiftSchedulesWithOptions(request *ListShiftSchedulesRequest, runtime *util.RuntimeOptions) (_result *ListShiftSchedulesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ShiftScheduleName)) {
		body["ShiftScheduleName"] = request.ShiftScheduleName
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListShiftSchedules"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListShiftSchedulesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListShiftSchedules(request *ListShiftSchedulesRequest) (_result *ListShiftSchedulesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListShiftSchedulesResponse{}
	_body, _err := client.ListShiftSchedulesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListSuccessInstanceAmountWithOptions(request *ListSuccessInstanceAmountRequest, runtime *util.RuntimeOptions) (_result *ListSuccessInstanceAmountResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListSuccessInstanceAmount"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListSuccessInstanceAmountResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListSuccessInstanceAmount(request *ListSuccessInstanceAmountRequest) (_result *ListSuccessInstanceAmountResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListSuccessInstanceAmountResponse{}
	_body, _err := client.ListSuccessInstanceAmountWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTableLevelWithOptions(request *ListTableLevelRequest, runtime *util.RuntimeOptions) (_result *ListTableLevelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTableLevel"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTableLevelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTableLevel(request *ListTableLevelRequest) (_result *ListTableLevelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTableLevelResponse{}
	_body, _err := client.ListTableLevelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTableThemeWithOptions(request *ListTableThemeRequest, runtime *util.RuntimeOptions) (_result *ListTableThemeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTableTheme"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTableThemeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTableTheme(request *ListTableThemeRequest) (_result *ListTableThemeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTableThemeResponse{}
	_body, _err := client.ListTableThemeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTopicsWithOptions(request *ListTopicsRequest, runtime *util.RuntimeOptions) (_result *ListTopicsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BeginTime)) {
		body["BeginTime"] = request.BeginTime
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		body["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		body["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		body["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.TopicStatuses)) {
		body["TopicStatuses"] = request.TopicStatuses
	}

	if !tea.BoolValue(util.IsUnset(request.TopicTypes)) {
		body["TopicTypes"] = request.TopicTypes
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTopics"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTopicsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTopics(request *ListTopicsRequest) (_result *ListTopicsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTopicsResponse{}
	_body, _err := client.ListTopicsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) MountDirectoryWithOptions(request *MountDirectoryRequest, runtime *util.RuntimeOptions) (_result *MountDirectoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TargetId)) {
		body["TargetId"] = request.TargetId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetType)) {
		body["TargetType"] = request.TargetType
	}

	if !tea.BoolValue(util.IsUnset(request.TargetUserId)) {
		body["TargetUserId"] = request.TargetUserId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("MountDirectory"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &MountDirectoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) MountDirectory(request *MountDirectoryRequest) (_result *MountDirectoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &MountDirectoryResponse{}
	_body, _err := client.MountDirectoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) OfflineNodeWithOptions(request *OfflineNodeRequest, runtime *util.RuntimeOptions) (_result *OfflineNodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("OfflineNode"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OfflineNodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) OfflineNode(request *OfflineNodeRequest) (_result *OfflineNodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OfflineNodeResponse{}
	_body, _err := client.OfflineNodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PublishDataServiceApiWithOptions(request *PublishDataServiceApiRequest, runtime *util.RuntimeOptions) (_result *PublishDataServiceApiResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiId)) {
		body["ApiId"] = request.ApiId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("PublishDataServiceApi"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PublishDataServiceApiResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PublishDataServiceApi(request *PublishDataServiceApiRequest) (_result *PublishDataServiceApiResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PublishDataServiceApiResponse{}
	_body, _err := client.PublishDataServiceApiWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform.
 *
 * @param request QueryDISyncTaskConfigProcessResultRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDISyncTaskConfigProcessResultResponse
 */
func (client *Client) QueryDISyncTaskConfigProcessResultWithOptions(request *QueryDISyncTaskConfigProcessResultRequest, runtime *util.RuntimeOptions) (_result *QueryDISyncTaskConfigProcessResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AsyncProcessId)) {
		query["AsyncProcessId"] = request.AsyncProcessId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDISyncTaskConfigProcessResult"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDISyncTaskConfigProcessResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform.
 *
 * @param request QueryDISyncTaskConfigProcessResultRequest
 * @return QueryDISyncTaskConfigProcessResultResponse
 */
func (client *Client) QueryDISyncTaskConfigProcessResult(request *QueryDISyncTaskConfigProcessResultRequest) (_result *QueryDISyncTaskConfigProcessResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDISyncTaskConfigProcessResultResponse{}
	_body, _err := client.QueryDISyncTaskConfigProcessResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryDefaultTemplateWithOptions(request *QueryDefaultTemplateRequest, runtime *util.RuntimeOptions) (_result *QueryDefaultTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDefaultTemplate"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDefaultTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryDefaultTemplate(request *QueryDefaultTemplateRequest) (_result *QueryDefaultTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDefaultTemplateResponse{}
	_body, _err := client.QueryDefaultTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryPublicModelEngineWithOptions(request *QueryPublicModelEngineRequest, runtime *util.RuntimeOptions) (_result *QueryPublicModelEngineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.Text)) {
		body["Text"] = request.Text
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryPublicModelEngine"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryPublicModelEngineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryPublicModelEngine(request *QueryPublicModelEngineRequest) (_result *QueryPublicModelEngineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryPublicModelEngineResponse{}
	_body, _err := client.QueryPublicModelEngineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryRecognizeDataByRuleTypeWithOptions(request *QueryRecognizeDataByRuleTypeRequest, runtime *util.RuntimeOptions) (_result *QueryRecognizeDataByRuleTypeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RecognizeRulesType)) {
		body["RecognizeRulesType"] = request.RecognizeRulesType
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryRecognizeDataByRuleType"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryRecognizeDataByRuleTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryRecognizeDataByRuleType(request *QueryRecognizeDataByRuleTypeRequest) (_result *QueryRecognizeDataByRuleTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryRecognizeDataByRuleTypeResponse{}
	_body, _err := client.QueryRecognizeDataByRuleTypeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryRecognizeRuleDetailWithOptions(request *QueryRecognizeRuleDetailRequest, runtime *util.RuntimeOptions) (_result *QueryRecognizeRuleDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.SensitiveName)) {
		body["SensitiveName"] = request.SensitiveName
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryRecognizeRuleDetail"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryRecognizeRuleDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryRecognizeRuleDetail(request *QueryRecognizeRuleDetailRequest) (_result *QueryRecognizeRuleDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryRecognizeRuleDetailResponse{}
	_body, _err := client.QueryRecognizeRuleDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryRecognizeRulesTypeWithOptions(runtime *util.RuntimeOptions) (_result *QueryRecognizeRulesTypeResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("QueryRecognizeRulesType"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryRecognizeRulesTypeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryRecognizeRulesType() (_result *QueryRecognizeRulesTypeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryRecognizeRulesTypeResponse{}
	_body, _err := client.QueryRecognizeRulesTypeWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySensClassificationWithOptions(request *QuerySensClassificationRequest, runtime *util.RuntimeOptions) (_result *QuerySensClassificationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		body["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySensClassification"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySensClassificationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySensClassification(request *QuerySensClassificationRequest) (_result *QuerySensClassificationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySensClassificationResponse{}
	_body, _err := client.QuerySensClassificationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySensLevelWithOptions(request *QuerySensLevelRequest, runtime *util.RuntimeOptions) (_result *QuerySensLevelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		body["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["tenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySensLevel"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySensLevelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySensLevel(request *QuerySensLevelRequest) (_result *QuerySensLevelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySensLevelResponse{}
	_body, _err := client.QuerySensLevelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySensNodeInfoWithOptions(request *QuerySensNodeInfoRequest, runtime *util.RuntimeOptions) (_result *QuerySensNodeInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		body["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SensitiveName)) {
		body["SensitiveName"] = request.SensitiveName
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		body["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		body["status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySensNodeInfo"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySensNodeInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySensNodeInfo(request *QuerySensNodeInfoRequest) (_result *QuerySensNodeInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySensNodeInfoResponse{}
	_body, _err := client.QuerySensNodeInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RegisterLineageRelationWithOptions(tmpReq *RegisterLineageRelationRequest, runtime *util.RuntimeOptions) (_result *RegisterLineageRelationResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &RegisterLineageRelationShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.LineageRelationRegisterVO)) {
		request.LineageRelationRegisterVOShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.LineageRelationRegisterVO, tea.String("LineageRelationRegisterVO"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LineageRelationRegisterVOShrink)) {
		body["LineageRelationRegisterVO"] = request.LineageRelationRegisterVOShrink
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("RegisterLineageRelation"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RegisterLineageRelationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RegisterLineageRelation(request *RegisterLineageRelationRequest) (_result *RegisterLineageRelationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RegisterLineageRelationResponse{}
	_body, _err := client.RegisterLineageRelationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveEntityTagsWithOptions(tmpReq *RemoveEntityTagsRequest, runtime *util.RuntimeOptions) (_result *RemoveEntityTagsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &RemoveEntityTagsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.TagKeys)) {
		request.TagKeysShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.TagKeys, tea.String("TagKeys"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.QualifiedName)) {
		query["QualifiedName"] = request.QualifiedName
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TagKeysShrink)) {
		body["TagKeys"] = request.TagKeysShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveEntityTags"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveEntityTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveEntityTags(request *RemoveEntityTagsRequest) (_result *RemoveEntityTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveEntityTagsResponse{}
	_body, _err := client.RemoveEntityTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RemoveProjectMemberFromRoleWithOptions(request *RemoveProjectMemberFromRoleRequest, runtime *util.RuntimeOptions) (_result *RemoveProjectMemberFromRoleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.RoleCode)) {
		query["RoleCode"] = request.RoleCode
	}

	if !tea.BoolValue(util.IsUnset(request.UserId)) {
		query["UserId"] = request.UserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveProjectMemberFromRole"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveProjectMemberFromRoleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RemoveProjectMemberFromRole(request *RemoveProjectMemberFromRoleRequest) (_result *RemoveProjectMemberFromRoleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveProjectMemberFromRoleResponse{}
	_body, _err := client.RemoveProjectMemberFromRoleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RestartInstanceWithOptions(request *RestartInstanceRequest, runtime *util.RuntimeOptions) (_result *RestartInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		body["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("RestartInstance"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RestartInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RestartInstance(request *RestartInstanceRequest) (_result *RestartInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RestartInstanceResponse{}
	_body, _err := client.RestartInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ResumeInstanceWithOptions(request *ResumeInstanceRequest, runtime *util.RuntimeOptions) (_result *ResumeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		body["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ResumeInstance"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ResumeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ResumeInstance(request *ResumeInstanceRequest) (_result *ResumeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ResumeInstanceResponse{}
	_body, _err := client.ResumeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RevokeColumnPermissionWithOptions(request *RevokeColumnPermissionRequest, runtime *util.RuntimeOptions) (_result *RevokeColumnPermissionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Columns)) {
		query["Columns"] = request.Columns
	}

	if !tea.BoolValue(util.IsUnset(request.MaxComputeProjectName)) {
		query["MaxComputeProjectName"] = request.MaxComputeProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.RevokeUserId)) {
		query["RevokeUserId"] = request.RevokeUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RevokeUserName)) {
		query["RevokeUserName"] = request.RevokeUserName
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.WorkspaceId)) {
		query["WorkspaceId"] = request.WorkspaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RevokeColumnPermission"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RevokeColumnPermissionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RevokeColumnPermission(request *RevokeColumnPermissionRequest) (_result *RevokeColumnPermissionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RevokeColumnPermissionResponse{}
	_body, _err := client.RevokeColumnPermissionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RevokeTablePermissionWithOptions(request *RevokeTablePermissionRequest, runtime *util.RuntimeOptions) (_result *RevokeTablePermissionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Actions)) {
		query["Actions"] = request.Actions
	}

	if !tea.BoolValue(util.IsUnset(request.MaxComputeProjectName)) {
		query["MaxComputeProjectName"] = request.MaxComputeProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.RevokeUserId)) {
		query["RevokeUserId"] = request.RevokeUserId
	}

	if !tea.BoolValue(util.IsUnset(request.RevokeUserName)) {
		query["RevokeUserName"] = request.RevokeUserName
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.WorkspaceId)) {
		query["WorkspaceId"] = request.WorkspaceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RevokeTablePermission"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RevokeTablePermissionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RevokeTablePermission(request *RevokeTablePermissionRequest) (_result *RevokeTablePermissionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RevokeTablePermissionResponse{}
	_body, _err := client.RevokeTablePermissionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * For more information about data backfill, see [Backfill data](~~137937~~).
 *
 * @param request RunCycleDagNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RunCycleDagNodesResponse
 */
func (client *Client) RunCycleDagNodesWithOptions(request *RunCycleDagNodesRequest, runtime *util.RuntimeOptions) (_result *RunCycleDagNodesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertNoticeType)) {
		body["AlertNoticeType"] = request.AlertNoticeType
	}

	if !tea.BoolValue(util.IsUnset(request.AlertType)) {
		body["AlertType"] = request.AlertType
	}

	if !tea.BoolValue(util.IsUnset(request.BizBeginTime)) {
		body["BizBeginTime"] = request.BizBeginTime
	}

	if !tea.BoolValue(util.IsUnset(request.BizEndTime)) {
		body["BizEndTime"] = request.BizEndTime
	}

	if !tea.BoolValue(util.IsUnset(request.ConcurrentRuns)) {
		body["ConcurrentRuns"] = request.ConcurrentRuns
	}

	if !tea.BoolValue(util.IsUnset(request.EndBizDate)) {
		body["EndBizDate"] = request.EndBizDate
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeNodeIds)) {
		body["ExcludeNodeIds"] = request.ExcludeNodeIds
	}

	if !tea.BoolValue(util.IsUnset(request.IncludeNodeIds)) {
		body["IncludeNodeIds"] = request.IncludeNodeIds
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NodeParams)) {
		body["NodeParams"] = request.NodeParams
	}

	if !tea.BoolValue(util.IsUnset(request.Parallelism)) {
		body["Parallelism"] = request.Parallelism
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	if !tea.BoolValue(util.IsUnset(request.RootNodeId)) {
		body["RootNodeId"] = request.RootNodeId
	}

	if !tea.BoolValue(util.IsUnset(request.StartBizDate)) {
		body["StartBizDate"] = request.StartBizDate
	}

	if !tea.BoolValue(util.IsUnset(request.StartFutureInstanceImmediately)) {
		body["StartFutureInstanceImmediately"] = request.StartFutureInstanceImmediately
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("RunCycleDagNodes"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RunCycleDagNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * For more information about data backfill, see [Backfill data](~~137937~~).
 *
 * @param request RunCycleDagNodesRequest
 * @return RunCycleDagNodesResponse
 */
func (client *Client) RunCycleDagNodes(request *RunCycleDagNodesRequest) (_result *RunCycleDagNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RunCycleDagNodesResponse{}
	_body, _err := client.RunCycleDagNodesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RunManualDagNodesWithOptions(request *RunManualDagNodesRequest, runtime *util.RuntimeOptions) (_result *RunManualDagNodesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BizDate)) {
		body["BizDate"] = request.BizDate
	}

	if !tea.BoolValue(util.IsUnset(request.DagParameters)) {
		body["DagParameters"] = request.DagParameters
	}

	if !tea.BoolValue(util.IsUnset(request.EndBizDate)) {
		body["EndBizDate"] = request.EndBizDate
	}

	if !tea.BoolValue(util.IsUnset(request.ExcludeNodeIds)) {
		body["ExcludeNodeIds"] = request.ExcludeNodeIds
	}

	if !tea.BoolValue(util.IsUnset(request.FlowName)) {
		body["FlowName"] = request.FlowName
	}

	if !tea.BoolValue(util.IsUnset(request.IncludeNodeIds)) {
		body["IncludeNodeIds"] = request.IncludeNodeIds
	}

	if !tea.BoolValue(util.IsUnset(request.NodeParameters)) {
		body["NodeParameters"] = request.NodeParameters
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.StartBizDate)) {
		body["StartBizDate"] = request.StartBizDate
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("RunManualDagNodes"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RunManualDagNodesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RunManualDagNodes(request *RunManualDagNodesRequest) (_result *RunManualDagNodesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RunManualDagNodesResponse{}
	_body, _err := client.RunManualDagNodesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RunSmokeTestWithOptions(request *RunSmokeTestRequest, runtime *util.RuntimeOptions) (_result *RunSmokeTestResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Bizdate)) {
		body["Bizdate"] = request.Bizdate
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.NodeParams)) {
		body["NodeParams"] = request.NodeParams
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("RunSmokeTest"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RunSmokeTestResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RunSmokeTest(request *RunSmokeTestRequest) (_result *RunSmokeTestResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RunSmokeTestResponse{}
	_body, _err := client.RunSmokeTestWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RunTriggerNodeWithOptions(request *RunTriggerNodeRequest, runtime *util.RuntimeOptions) (_result *RunTriggerNodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		body["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.BizDate)) {
		body["BizDate"] = request.BizDate
	}

	if !tea.BoolValue(util.IsUnset(request.CycleTime)) {
		body["CycleTime"] = request.CycleTime
	}

	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("RunTriggerNode"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RunTriggerNodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RunTriggerNode(request *RunTriggerNodeRequest) (_result *RunTriggerNodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RunTriggerNodeResponse{}
	_body, _err := client.RunTriggerNodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SaveDataServiceApiTestResultWithOptions(request *SaveDataServiceApiTestResultRequest, runtime *util.RuntimeOptions) (_result *SaveDataServiceApiTestResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiId)) {
		body["ApiId"] = request.ApiId
	}

	if !tea.BoolValue(util.IsUnset(request.AutoGenerate)) {
		body["AutoGenerate"] = request.AutoGenerate
	}

	if !tea.BoolValue(util.IsUnset(request.FailResultSample)) {
		body["FailResultSample"] = request.FailResultSample
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResultSample)) {
		body["ResultSample"] = request.ResultSample
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("SaveDataServiceApiTestResult"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SaveDataServiceApiTestResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SaveDataServiceApiTestResult(request *SaveDataServiceApiTestResultRequest) (_result *SaveDataServiceApiTestResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SaveDataServiceApiTestResultResponse{}
	_body, _err := client.SaveDataServiceApiTestResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ScanSensitiveDataWithOptions(request *ScanSensitiveDataRequest, runtime *util.RuntimeOptions) (_result *ScanSensitiveDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ScanSensitiveData"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ScanSensitiveDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ScanSensitiveData(request *ScanSensitiveDataRequest) (_result *ScanSensitiveDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ScanSensitiveDataResponse{}
	_body, _err := client.ScanSensitiveDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **SearchMetaTables**.
 *
 * @param request SearchMetaTablesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchMetaTablesResponse
 */
func (client *Client) SearchMetaTablesWithOptions(request *SearchMetaTablesRequest, runtime *util.RuntimeOptions) (_result *SearchMetaTablesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppGuid)) {
		query["AppGuid"] = request.AppGuid
	}

	if !tea.BoolValue(util.IsUnset(request.ClusterId)) {
		query["ClusterId"] = request.ClusterId
	}

	if !tea.BoolValue(util.IsUnset(request.DataSourceType)) {
		query["DataSourceType"] = request.DataSourceType
	}

	if !tea.BoolValue(util.IsUnset(request.EntityType)) {
		query["EntityType"] = request.EntityType
	}

	if !tea.BoolValue(util.IsUnset(request.Keyword)) {
		query["Keyword"] = request.Keyword
	}

	if !tea.BoolValue(util.IsUnset(request.PageNumber)) {
		query["PageNumber"] = request.PageNumber
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Schema)) {
		query["Schema"] = request.Schema
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchMetaTables"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchMetaTablesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **SearchMetaTables**.
 *
 * @param request SearchMetaTablesRequest
 * @return SearchMetaTablesResponse
 */
func (client *Client) SearchMetaTables(request *SearchMetaTablesRequest) (_result *SearchMetaTablesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchMetaTablesResponse{}
	_body, _err := client.SearchMetaTablesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request SearchNodesByOutputRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SearchNodesByOutputResponse
 */
// Deprecated
func (client *Client) SearchNodesByOutputWithOptions(request *SearchNodesByOutputRequest, runtime *util.RuntimeOptions) (_result *SearchNodesByOutputResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Outputs)) {
		body["Outputs"] = request.Outputs
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("SearchNodesByOutput"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SearchNodesByOutputResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request SearchNodesByOutputRequest
 * @return SearchNodesByOutputResponse
 */
// Deprecated
func (client *Client) SearchNodesByOutput(request *SearchNodesByOutputRequest) (_result *SearchNodesByOutputResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SearchNodesByOutputResponse{}
	_body, _err := client.SearchNodesByOutputWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request SetDataSourceShareRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDataSourceShareResponse
 */
// Deprecated
func (client *Client) SetDataSourceShareWithOptions(request *SetDataSourceShareRequest, runtime *util.RuntimeOptions) (_result *SetDataSourceShareResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DatasourceName)) {
		query["DatasourceName"] = request.DatasourceName
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectPermissions)) {
		query["ProjectPermissions"] = request.ProjectPermissions
	}

	if !tea.BoolValue(util.IsUnset(request.UserPermissions)) {
		query["UserPermissions"] = request.UserPermissions
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDataSourceShare"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDataSourceShareResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request SetDataSourceShareRequest
 * @return SetDataSourceShareResponse
 */
// Deprecated
func (client *Client) SetDataSourceShare(request *SetDataSourceShareRequest) (_result *SetDataSourceShareResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDataSourceShareResponse{}
	_body, _err := client.SetDataSourceShareWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetEntityTagsWithOptions(tmpReq *SetEntityTagsRequest, runtime *util.RuntimeOptions) (_result *SetEntityTagsResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &SetEntityTagsShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Tags)) {
		request.TagsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Tags, tea.String("Tags"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.QualifiedName)) {
		query["QualifiedName"] = request.QualifiedName
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TagsShrink)) {
		body["Tags"] = request.TagsShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("SetEntityTags"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetEntityTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetEntityTags(request *SetEntityTagsRequest) (_result *SetEntityTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetEntityTagsResponse{}
	_body, _err := client.SetEntityTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetSuccessInstanceWithOptions(request *SetSuccessInstanceRequest, runtime *util.RuntimeOptions) (_result *SetSuccessInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		body["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("SetSuccessInstance"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetSuccessInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetSuccessInstance(request *SetSuccessInstanceRequest) (_result *SetSuccessInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetSuccessInstanceResponse{}
	_body, _err := client.SetSuccessInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StartDIJobWithOptions(tmpReq *StartDIJobRequest, runtime *util.RuntimeOptions) (_result *StartDIJobResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &StartDIJobShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.RealtimeStartSettings)) {
		request.RealtimeStartSettingsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RealtimeStartSettings, tea.String("RealtimeStartSettings"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DIJobId)) {
		body["DIJobId"] = request.DIJobId
	}

	if !tea.BoolValue(util.IsUnset(request.ForceToRerun)) {
		body["ForceToRerun"] = request.ForceToRerun
	}

	if !tea.BoolValue(util.IsUnset(request.RealtimeStartSettingsShrink)) {
		body["RealtimeStartSettings"] = request.RealtimeStartSettingsShrink
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("StartDIJob"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartDIJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StartDIJob(request *StartDIJobRequest) (_result *StartDIJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartDIJobResponse{}
	_body, _err := client.StartDIJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StartDISyncInstanceWithOptions(request *StartDISyncInstanceRequest, runtime *util.RuntimeOptions) (_result *StartDISyncInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.StartParam)) {
		query["StartParam"] = request.StartParam
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartDISyncInstance"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartDISyncInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StartDISyncInstance(request *StartDISyncInstanceRequest) (_result *StartDISyncInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartDISyncInstanceResponse{}
	_body, _err := client.StartDISyncInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StartMigrationWithOptions(request *StartMigrationRequest, runtime *util.RuntimeOptions) (_result *StartMigrationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MigrationId)) {
		body["MigrationId"] = request.MigrationId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("StartMigration"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartMigrationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StartMigration(request *StartMigrationRequest) (_result *StartMigrationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartMigrationResponse{}
	_body, _err := client.StartMigrationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StopDIJobWithOptions(request *StopDIJobRequest, runtime *util.RuntimeOptions) (_result *StopDIJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DIJobId)) {
		body["DIJobId"] = request.DIJobId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("StopDIJob"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopDIJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StopDIJob(request *StopDIJobRequest) (_result *StopDIJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopDIJobResponse{}
	_body, _err := client.StopDIJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StopDISyncInstanceWithOptions(request *StopDISyncInstanceRequest, runtime *util.RuntimeOptions) (_result *StopDISyncInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopDISyncInstance"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopDISyncInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StopDISyncInstance(request *StopDISyncInstanceRequest) (_result *StopDISyncInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopDISyncInstanceResponse{}
	_body, _err := client.StopDISyncInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StopInstanceWithOptions(request *StopInstanceRequest, runtime *util.RuntimeOptions) (_result *StopInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		body["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("StopInstance"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StopInstance(request *StopInstanceRequest) (_result *StopInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopInstanceResponse{}
	_body, _err := client.StopInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SubmitDataServiceApiWithOptions(request *SubmitDataServiceApiRequest, runtime *util.RuntimeOptions) (_result *SubmitDataServiceApiResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiId)) {
		body["ApiId"] = request.ApiId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitDataServiceApi"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubmitDataServiceApiResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SubmitDataServiceApi(request *SubmitDataServiceApiRequest) (_result *SubmitDataServiceApiResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitDataServiceApiResponse{}
	_body, _err := client.SubmitDataServiceApiWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SubmitFileWithOptions(request *SubmitFileRequest, runtime *util.RuntimeOptions) (_result *SubmitFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		body["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		body["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.SkipAllDeployFileExtensions)) {
		body["SkipAllDeployFileExtensions"] = request.SkipAllDeployFileExtensions
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("SubmitFile"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubmitFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SubmitFile(request *SubmitFileRequest) (_result *SubmitFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubmitFileResponse{}
	_body, _err := client.SubmitFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SuspendInstanceWithOptions(request *SuspendInstanceRequest, runtime *util.RuntimeOptions) (_result *SuspendInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		body["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("SuspendInstance"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SuspendInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SuspendInstance(request *SuspendInstanceRequest) (_result *SuspendInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SuspendInstanceResponse{}
	_body, _err := client.SuspendInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TerminateDISyncInstanceWithOptions(request *TerminateDISyncInstanceRequest, runtime *util.RuntimeOptions) (_result *TerminateDISyncInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TerminateDISyncInstance"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TerminateDISyncInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TerminateDISyncInstance(request *TerminateDISyncInstanceRequest) (_result *TerminateDISyncInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TerminateDISyncInstanceResponse{}
	_body, _err := client.TerminateDISyncInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TestDataServiceApiWithOptions(request *TestDataServiceApiRequest, runtime *util.RuntimeOptions) (_result *TestDataServiceApiResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiId)) {
		query["ApiId"] = request.ApiId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BodyContent)) {
		body["BodyContent"] = request.BodyContent
	}

	if !tea.BoolValue(util.IsUnset(request.BodyParams)) {
		body["BodyParams"] = request.BodyParams
	}

	if !tea.BoolValue(util.IsUnset(request.HeadParams)) {
		body["HeadParams"] = request.HeadParams
	}

	if !tea.BoolValue(util.IsUnset(request.PathParams)) {
		body["PathParams"] = request.PathParams
	}

	if !tea.BoolValue(util.IsUnset(request.QueryParam)) {
		body["QueryParam"] = request.QueryParam
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("TestDataServiceApi"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TestDataServiceApiResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TestDataServiceApi(request *TestDataServiceApiRequest) (_result *TestDataServiceApiResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TestDataServiceApiResponse{}
	_body, _err := client.TestDataServiceApiWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TestNetworkConnectionWithOptions(request *TestNetworkConnectionRequest, runtime *util.RuntimeOptions) (_result *TestNetworkConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DatasourceName)) {
		query["DatasourceName"] = request.DatasourceName
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroup)) {
		query["ResourceGroup"] = request.ResourceGroup
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TestNetworkConnection"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TestNetworkConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TestNetworkConnection(request *TestNetworkConnectionRequest) (_result *TestNetworkConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TestNetworkConnectionResponse{}
	_body, _err := client.TestNetworkConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TopTenElapsedTimeInstanceWithOptions(request *TopTenElapsedTimeInstanceRequest, runtime *util.RuntimeOptions) (_result *TopTenElapsedTimeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("TopTenElapsedTimeInstance"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TopTenElapsedTimeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TopTenElapsedTimeInstance(request *TopTenElapsedTimeInstanceRequest) (_result *TopTenElapsedTimeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TopTenElapsedTimeInstanceResponse{}
	_body, _err := client.TopTenElapsedTimeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TopTenErrorTimesInstanceWithOptions(request *TopTenErrorTimesInstanceRequest, runtime *util.RuntimeOptions) (_result *TopTenErrorTimesInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("TopTenErrorTimesInstance"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TopTenErrorTimesInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TopTenErrorTimesInstance(request *TopTenErrorTimesInstanceRequest) (_result *TopTenErrorTimesInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TopTenErrorTimesInstanceResponse{}
	_body, _err := client.TopTenErrorTimesInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UmountDirectoryWithOptions(request *UmountDirectoryRequest, runtime *util.RuntimeOptions) (_result *UmountDirectoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TargetId)) {
		body["TargetId"] = request.TargetId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetType)) {
		body["TargetType"] = request.TargetType
	}

	if !tea.BoolValue(util.IsUnset(request.TargetUserId)) {
		body["TargetUserId"] = request.TargetUserId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UmountDirectory"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UmountDirectoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UmountDirectory(request *UmountDirectoryRequest) (_result *UmountDirectoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UmountDirectoryResponse{}
	_body, _err := client.UmountDirectoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateBaselineWithOptions(tmpReq *UpdateBaselineRequest, runtime *util.RuntimeOptions) (_result *UpdateBaselineResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateBaselineShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.AlertSettings)) {
		request.AlertSettingsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.AlertSettings, tea.String("AlertSettings"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.OvertimeSettings)) {
		request.OvertimeSettingsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.OvertimeSettings, tea.String("OvertimeSettings"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertEnabled)) {
		body["AlertEnabled"] = request.AlertEnabled
	}

	if !tea.BoolValue(util.IsUnset(request.AlertMarginThreshold)) {
		body["AlertMarginThreshold"] = request.AlertMarginThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.AlertSettingsShrink)) {
		body["AlertSettings"] = request.AlertSettingsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.BaselineId)) {
		body["BaselineId"] = request.BaselineId
	}

	if !tea.BoolValue(util.IsUnset(request.BaselineName)) {
		body["BaselineName"] = request.BaselineName
	}

	if !tea.BoolValue(util.IsUnset(request.BaselineType)) {
		body["BaselineType"] = request.BaselineType
	}

	if !tea.BoolValue(util.IsUnset(request.Enabled)) {
		body["Enabled"] = request.Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.NodeIds)) {
		body["NodeIds"] = request.NodeIds
	}

	if !tea.BoolValue(util.IsUnset(request.OvertimeSettingsShrink)) {
		body["OvertimeSettings"] = request.OvertimeSettingsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.Priority)) {
		body["Priority"] = request.Priority
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.RemoveNodeIds)) {
		body["RemoveNodeIds"] = request.RemoveNodeIds
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateBaseline"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateBaselineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateBaseline(request *UpdateBaselineRequest) (_result *UpdateBaselineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateBaselineResponse{}
	_body, _err := client.UpdateBaselineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateBusinessWithOptions(request *UpdateBusinessRequest, runtime *util.RuntimeOptions) (_result *UpdateBusinessResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BusinessId)) {
		body["BusinessId"] = request.BusinessId
	}

	if !tea.BoolValue(util.IsUnset(request.BusinessName)) {
		body["BusinessName"] = request.BusinessName
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateBusiness"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateBusinessResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateBusiness(request *UpdateBusinessRequest) (_result *UpdateBusinessResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateBusinessResponse{}
	_body, _err := client.UpdateBusinessWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request UpdateConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateConnectionResponse
 */
// Deprecated
func (client *Client) UpdateConnectionWithOptions(request *UpdateConnectionRequest, runtime *util.RuntimeOptions) (_result *UpdateConnectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConnectionId)) {
		query["ConnectionId"] = request.ConnectionId
	}

	if !tea.BoolValue(util.IsUnset(request.Content)) {
		query["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateConnection"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateConnectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * @deprecated
 *
 * @param request UpdateConnectionRequest
 * @return UpdateConnectionResponse
 */
// Deprecated
func (client *Client) UpdateConnection(request *UpdateConnectionRequest) (_result *UpdateConnectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateConnectionResponse{}
	_body, _err := client.UpdateConnectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDIAlarmRuleWithOptions(tmpReq *UpdateDIAlarmRuleRequest, runtime *util.RuntimeOptions) (_result *UpdateDIAlarmRuleResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateDIAlarmRuleShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.NotificationSettings)) {
		request.NotificationSettingsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.NotificationSettings, tea.String("NotificationSettings"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.TriggerConditions)) {
		request.TriggerConditionsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.TriggerConditions, tea.String("TriggerConditions"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DIAlarmRuleId)) {
		body["DIAlarmRuleId"] = request.DIAlarmRuleId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Enabled)) {
		body["Enabled"] = request.Enabled
	}

	if !tea.BoolValue(util.IsUnset(request.MetricType)) {
		body["MetricType"] = request.MetricType
	}

	if !tea.BoolValue(util.IsUnset(request.NotificationSettingsShrink)) {
		body["NotificationSettings"] = request.NotificationSettingsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.TriggerConditionsShrink)) {
		body["TriggerConditions"] = request.TriggerConditionsShrink
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDIAlarmRule"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDIAlarmRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDIAlarmRule(request *UpdateDIAlarmRuleRequest) (_result *UpdateDIAlarmRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDIAlarmRuleResponse{}
	_body, _err := client.UpdateDIAlarmRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDIJobWithOptions(tmpReq *UpdateDIJobRequest, runtime *util.RuntimeOptions) (_result *UpdateDIJobResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateDIJobShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.JobSettings)) {
		request.JobSettingsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.JobSettings, tea.String("JobSettings"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.ResourceSettings)) {
		request.ResourceSettingsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.ResourceSettings, tea.String("ResourceSettings"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.TableMappings)) {
		request.TableMappingsShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.TableMappings, tea.String("TableMappings"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.TransformationRules)) {
		request.TransformationRulesShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.TransformationRules, tea.String("TransformationRules"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DIJobId)) {
		body["DIJobId"] = request.DIJobId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.JobSettingsShrink)) {
		body["JobSettings"] = request.JobSettingsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceSettingsShrink)) {
		body["ResourceSettings"] = request.ResourceSettingsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.TableMappingsShrink)) {
		body["TableMappings"] = request.TableMappingsShrink
	}

	if !tea.BoolValue(util.IsUnset(request.TransformationRulesShrink)) {
		body["TransformationRules"] = request.TransformationRulesShrink
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDIJob"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDIJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDIJob(request *UpdateDIJobRequest) (_result *UpdateDIJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDIJobResponse{}
	_body, _err := client.UpdateDIJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **UpdateDIProjectConfig**.
 *
 * @param request UpdateDIProjectConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDIProjectConfigResponse
 */
func (client *Client) UpdateDIProjectConfigWithOptions(request *UpdateDIProjectConfigRequest, runtime *util.RuntimeOptions) (_result *UpdateDIProjectConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DestinationType)) {
		query["DestinationType"] = request.DestinationType
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectConfig)) {
		query["ProjectConfig"] = request.ProjectConfig
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		query["SourceType"] = request.SourceType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDIProjectConfig"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDIProjectConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The operation that you want to perform. Set the value to **UpdateDIProjectConfig**.
 *
 * @param request UpdateDIProjectConfigRequest
 * @return UpdateDIProjectConfigResponse
 */
func (client *Client) UpdateDIProjectConfig(request *UpdateDIProjectConfigRequest) (_result *UpdateDIProjectConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDIProjectConfigResponse{}
	_body, _err := client.UpdateDIProjectConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDISyncTaskWithOptions(request *UpdateDISyncTaskRequest, runtime *util.RuntimeOptions) (_result *UpdateDISyncTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskContent)) {
		query["TaskContent"] = request.TaskContent
	}

	if !tea.BoolValue(util.IsUnset(request.TaskParam)) {
		query["TaskParam"] = request.TaskParam
	}

	if !tea.BoolValue(util.IsUnset(request.TaskType)) {
		query["TaskType"] = request.TaskType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDISyncTask"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDISyncTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDISyncTask(request *UpdateDISyncTaskRequest) (_result *UpdateDISyncTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDISyncTaskResponse{}
	_body, _err := client.UpdateDISyncTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDataServiceApiWithOptions(request *UpdateDataServiceApiRequest, runtime *util.RuntimeOptions) (_result *UpdateDataServiceApiResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiDescription)) {
		body["ApiDescription"] = request.ApiDescription
	}

	if !tea.BoolValue(util.IsUnset(request.ApiId)) {
		body["ApiId"] = request.ApiId
	}

	if !tea.BoolValue(util.IsUnset(request.ApiPath)) {
		body["ApiPath"] = request.ApiPath
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.Protocols)) {
		body["Protocols"] = request.Protocols
	}

	if !tea.BoolValue(util.IsUnset(request.RegistrationDetails)) {
		body["RegistrationDetails"] = request.RegistrationDetails
	}

	if !tea.BoolValue(util.IsUnset(request.RequestMethod)) {
		body["RequestMethod"] = request.RequestMethod
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		body["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ResponseContentType)) {
		body["ResponseContentType"] = request.ResponseContentType
	}

	if !tea.BoolValue(util.IsUnset(request.ScriptDetails)) {
		body["ScriptDetails"] = request.ScriptDetails
	}

	if !tea.BoolValue(util.IsUnset(request.TenantId)) {
		body["TenantId"] = request.TenantId
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		body["Timeout"] = request.Timeout
	}

	if !tea.BoolValue(util.IsUnset(request.VisibleRange)) {
		body["VisibleRange"] = request.VisibleRange
	}

	if !tea.BoolValue(util.IsUnset(request.WizardDetails)) {
		body["WizardDetails"] = request.WizardDetails
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDataServiceApi"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDataServiceApiResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDataServiceApi(request *UpdateDataServiceApiRequest) (_result *UpdateDataServiceApiResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDataServiceApiResponse{}
	_body, _err := client.UpdateDataServiceApiWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDataSourceWithOptions(request *UpdateDataSourceRequest, runtime *util.RuntimeOptions) (_result *UpdateDataSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Content)) {
		query["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.DataSourceId)) {
		query["DataSourceId"] = request.DataSourceId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDataSource"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("PUT"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDataSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDataSource(request *UpdateDataSourceRequest) (_result *UpdateDataSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDataSourceResponse{}
	_body, _err := client.UpdateDataSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you debug or call this operation, you must specify new values for the specified parameters to ensure that the values are different from the original configurations of the file. For example, if the original value of a parameter is A, you must change the value of this parameter to B before you commit the node. If you set the parameter to A, an exception that indicates invalid data occurs.
 *
 * @param request UpdateFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateFileResponse
 */
func (client *Client) UpdateFileWithOptions(request *UpdateFileRequest, runtime *util.RuntimeOptions) (_result *UpdateFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AdvancedSettings)) {
		body["AdvancedSettings"] = request.AdvancedSettings
	}

	if !tea.BoolValue(util.IsUnset(request.AutoParsing)) {
		body["AutoParsing"] = request.AutoParsing
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRerunIntervalMillis)) {
		body["AutoRerunIntervalMillis"] = request.AutoRerunIntervalMillis
	}

	if !tea.BoolValue(util.IsUnset(request.AutoRerunTimes)) {
		body["AutoRerunTimes"] = request.AutoRerunTimes
	}

	if !tea.BoolValue(util.IsUnset(request.ConnectionName)) {
		body["ConnectionName"] = request.ConnectionName
	}

	if !tea.BoolValue(util.IsUnset(request.Content)) {
		body["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.CronExpress)) {
		body["CronExpress"] = request.CronExpress
	}

	if !tea.BoolValue(util.IsUnset(request.CycleType)) {
		body["CycleType"] = request.CycleType
	}

	if !tea.BoolValue(util.IsUnset(request.DependentNodeIdList)) {
		body["DependentNodeIdList"] = request.DependentNodeIdList
	}

	if !tea.BoolValue(util.IsUnset(request.DependentType)) {
		body["DependentType"] = request.DependentType
	}

	if !tea.BoolValue(util.IsUnset(request.EndEffectDate)) {
		body["EndEffectDate"] = request.EndEffectDate
	}

	if !tea.BoolValue(util.IsUnset(request.FileDescription)) {
		body["FileDescription"] = request.FileDescription
	}

	if !tea.BoolValue(util.IsUnset(request.FileFolderPath)) {
		body["FileFolderPath"] = request.FileFolderPath
	}

	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		body["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		body["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.IgnoreParentSkipRunningProperty)) {
		body["IgnoreParentSkipRunningProperty"] = request.IgnoreParentSkipRunningProperty
	}

	if !tea.BoolValue(util.IsUnset(request.InputList)) {
		body["InputList"] = request.InputList
	}

	if !tea.BoolValue(util.IsUnset(request.InputParameters)) {
		body["InputParameters"] = request.InputParameters
	}

	if !tea.BoolValue(util.IsUnset(request.OutputList)) {
		body["OutputList"] = request.OutputList
	}

	if !tea.BoolValue(util.IsUnset(request.OutputParameters)) {
		body["OutputParameters"] = request.OutputParameters
	}

	if !tea.BoolValue(util.IsUnset(request.Owner)) {
		body["Owner"] = request.Owner
	}

	if !tea.BoolValue(util.IsUnset(request.ParaValue)) {
		body["ParaValue"] = request.ParaValue
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.RerunMode)) {
		body["RerunMode"] = request.RerunMode
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupIdentifier)) {
		body["ResourceGroupIdentifier"] = request.ResourceGroupIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.SchedulerType)) {
		body["SchedulerType"] = request.SchedulerType
	}

	if !tea.BoolValue(util.IsUnset(request.StartEffectDate)) {
		body["StartEffectDate"] = request.StartEffectDate
	}

	if !tea.BoolValue(util.IsUnset(request.StartImmediately)) {
		body["StartImmediately"] = request.StartImmediately
	}

	if !tea.BoolValue(util.IsUnset(request.Stop)) {
		body["Stop"] = request.Stop
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateFile"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you debug or call this operation, you must specify new values for the specified parameters to ensure that the values are different from the original configurations of the file. For example, if the original value of a parameter is A, you must change the value of this parameter to B before you commit the node. If you set the parameter to A, an exception that indicates invalid data occurs.
 *
 * @param request UpdateFileRequest
 * @return UpdateFileResponse
 */
func (client *Client) UpdateFile(request *UpdateFileRequest) (_result *UpdateFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateFileResponse{}
	_body, _err := client.UpdateFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateFolderWithOptions(request *UpdateFolderRequest, runtime *util.RuntimeOptions) (_result *UpdateFolderResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FolderId)) {
		body["FolderId"] = request.FolderId
	}

	if !tea.BoolValue(util.IsUnset(request.FolderName)) {
		body["FolderName"] = request.FolderName
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateFolder"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateFolderResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateFolder(request *UpdateFolderRequest) (_result *UpdateFolderResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateFolderResponse{}
	_body, _err := client.UpdateFolderWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateIDEEventResultWithOptions(request *UpdateIDEEventResultRequest, runtime *util.RuntimeOptions) (_result *UpdateIDEEventResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CheckResult)) {
		body["CheckResult"] = request.CheckResult
	}

	if !tea.BoolValue(util.IsUnset(request.CheckResultTip)) {
		body["CheckResultTip"] = request.CheckResultTip
	}

	if !tea.BoolValue(util.IsUnset(request.ExtensionCode)) {
		body["ExtensionCode"] = request.ExtensionCode
	}

	if !tea.BoolValue(util.IsUnset(request.MessageId)) {
		body["MessageId"] = request.MessageId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateIDEEventResult"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateIDEEventResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateIDEEventResult(request *UpdateIDEEventResultRequest) (_result *UpdateIDEEventResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateIDEEventResultResponse{}
	_body, _err := client.UpdateIDEEventResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateMetaCategoryWithOptions(request *UpdateMetaCategoryRequest, runtime *util.RuntimeOptions) (_result *UpdateMetaCategoryResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CategoryId)) {
		body["CategoryId"] = request.CategoryId
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		body["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMetaCategory"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateMetaCategoryResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateMetaCategory(request *UpdateMetaCategoryRequest) (_result *UpdateMetaCategoryResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateMetaCategoryResponse{}
	_body, _err := client.UpdateMetaCategoryWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You must configure at least one of the Name and Comment parameters when you update a collection.
 *
 * @param request UpdateMetaCollectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateMetaCollectionResponse
 */
func (client *Client) UpdateMetaCollectionWithOptions(request *UpdateMetaCollectionRequest, runtime *util.RuntimeOptions) (_result *UpdateMetaCollectionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.QualifiedName)) {
		query["QualifiedName"] = request.QualifiedName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMetaCollection"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateMetaCollectionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You must configure at least one of the Name and Comment parameters when you update a collection.
 *
 * @param request UpdateMetaCollectionRequest
 * @return UpdateMetaCollectionResponse
 */
func (client *Client) UpdateMetaCollection(request *UpdateMetaCollectionRequest) (_result *UpdateMetaCollectionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateMetaCollectionResponse{}
	_body, _err := client.UpdateMetaCollectionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateMetaTableWithOptions(request *UpdateMetaTableRequest, runtime *util.RuntimeOptions) (_result *UpdateMetaTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Caption)) {
		query["Caption"] = request.Caption
	}

	if !tea.BoolValue(util.IsUnset(request.CategoryId)) {
		query["CategoryId"] = request.CategoryId
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		query["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.NewOwnerId)) {
		query["NewOwnerId"] = request.NewOwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.Schema)) {
		query["Schema"] = request.Schema
	}

	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.Visibility)) {
		query["Visibility"] = request.Visibility
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AddedLabels)) {
		body["AddedLabels"] = request.AddedLabels
	}

	if !tea.BoolValue(util.IsUnset(request.RemovedLabels)) {
		body["RemovedLabels"] = request.RemovedLabels
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMetaTable"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateMetaTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateMetaTable(request *UpdateMetaTableRequest) (_result *UpdateMetaTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateMetaTableResponse{}
	_body, _err := client.UpdateMetaTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateMetaTableIntroWikiWithOptions(request *UpdateMetaTableIntroWikiRequest, runtime *util.RuntimeOptions) (_result *UpdateMetaTableIntroWikiResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Content)) {
		body["Content"] = request.Content
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateMetaTableIntroWiki"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateMetaTableIntroWikiResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateMetaTableIntroWiki(request *UpdateMetaTableIntroWikiRequest) (_result *UpdateMetaTableIntroWikiResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateMetaTableIntroWikiResponse{}
	_body, _err := client.UpdateMetaTableIntroWikiWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateNodeOwnerWithOptions(request *UpdateNodeOwnerRequest, runtime *util.RuntimeOptions) (_result *UpdateNodeOwnerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	if !tea.BoolValue(util.IsUnset(request.UserId)) {
		body["UserId"] = request.UserId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateNodeOwner"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateNodeOwnerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateNodeOwner(request *UpdateNodeOwnerRequest) (_result *UpdateNodeOwnerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateNodeOwnerResponse{}
	_body, _err := client.UpdateNodeOwnerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateNodeRunModeWithOptions(request *UpdateNodeRunModeRequest, runtime *util.RuntimeOptions) (_result *UpdateNodeRunModeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.NodeId)) {
		body["NodeId"] = request.NodeId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectEnv)) {
		body["ProjectEnv"] = request.ProjectEnv
	}

	if !tea.BoolValue(util.IsUnset(request.SchedulerType)) {
		body["SchedulerType"] = request.SchedulerType
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateNodeRunMode"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateNodeRunModeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateNodeRunMode(request *UpdateNodeRunModeRequest) (_result *UpdateNodeRunModeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateNodeRunModeResponse{}
	_body, _err := client.UpdateNodeRunModeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateQualityFollowerWithOptions(request *UpdateQualityFollowerRequest, runtime *util.RuntimeOptions) (_result *UpdateQualityFollowerResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlarmMode)) {
		body["AlarmMode"] = request.AlarmMode
	}

	if !tea.BoolValue(util.IsUnset(request.Follower)) {
		body["Follower"] = request.Follower
	}

	if !tea.BoolValue(util.IsUnset(request.FollowerId)) {
		body["FollowerId"] = request.FollowerId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateQualityFollower"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateQualityFollowerResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateQualityFollower(request *UpdateQualityFollowerRequest) (_result *UpdateQualityFollowerResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateQualityFollowerResponse{}
	_body, _err := client.UpdateQualityFollowerWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateQualityRuleWithOptions(request *UpdateQualityRuleRequest, runtime *util.RuntimeOptions) (_result *UpdateQualityRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BlockType)) {
		body["BlockType"] = request.BlockType
	}

	if !tea.BoolValue(util.IsUnset(request.Checker)) {
		body["Checker"] = request.Checker
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		body["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.CriticalThreshold)) {
		body["CriticalThreshold"] = request.CriticalThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.EntityId)) {
		body["EntityId"] = request.EntityId
	}

	if !tea.BoolValue(util.IsUnset(request.ExpectValue)) {
		body["ExpectValue"] = request.ExpectValue
	}

	if !tea.BoolValue(util.IsUnset(request.Id)) {
		body["Id"] = request.Id
	}

	if !tea.BoolValue(util.IsUnset(request.MethodName)) {
		body["MethodName"] = request.MethodName
	}

	if !tea.BoolValue(util.IsUnset(request.OpenSwitch)) {
		body["OpenSwitch"] = request.OpenSwitch
	}

	if !tea.BoolValue(util.IsUnset(request.Operator)) {
		body["Operator"] = request.Operator
	}

	if !tea.BoolValue(util.IsUnset(request.PredictType)) {
		body["PredictType"] = request.PredictType
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectName)) {
		body["ProjectName"] = request.ProjectName
	}

	if !tea.BoolValue(util.IsUnset(request.Property)) {
		body["Property"] = request.Property
	}

	if !tea.BoolValue(util.IsUnset(request.PropertyType)) {
		body["PropertyType"] = request.PropertyType
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		body["RuleName"] = request.RuleName
	}

	if !tea.BoolValue(util.IsUnset(request.RuleType)) {
		body["RuleType"] = request.RuleType
	}

	if !tea.BoolValue(util.IsUnset(request.TaskSetting)) {
		body["TaskSetting"] = request.TaskSetting
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateId)) {
		body["TemplateId"] = request.TemplateId
	}

	if !tea.BoolValue(util.IsUnset(request.Trend)) {
		body["Trend"] = request.Trend
	}

	if !tea.BoolValue(util.IsUnset(request.WarningThreshold)) {
		body["WarningThreshold"] = request.WarningThreshold
	}

	if !tea.BoolValue(util.IsUnset(request.WhereCondition)) {
		body["WhereCondition"] = request.WhereCondition
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateQualityRule"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateQualityRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateQualityRule(request *UpdateQualityRuleRequest) (_result *UpdateQualityRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateQualityRuleResponse{}
	_body, _err := client.UpdateQualityRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateRemindWithOptions(request *UpdateRemindRequest, runtime *util.RuntimeOptions) (_result *UpdateRemindResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AlertInterval)) {
		body["AlertInterval"] = request.AlertInterval
	}

	if !tea.BoolValue(util.IsUnset(request.AlertMethods)) {
		body["AlertMethods"] = request.AlertMethods
	}

	if !tea.BoolValue(util.IsUnset(request.AlertTargets)) {
		body["AlertTargets"] = request.AlertTargets
	}

	if !tea.BoolValue(util.IsUnset(request.AlertUnit)) {
		body["AlertUnit"] = request.AlertUnit
	}

	if !tea.BoolValue(util.IsUnset(request.BaselineIds)) {
		body["BaselineIds"] = request.BaselineIds
	}

	if !tea.BoolValue(util.IsUnset(request.BizProcessIds)) {
		body["BizProcessIds"] = request.BizProcessIds
	}

	if !tea.BoolValue(util.IsUnset(request.Detail)) {
		body["Detail"] = request.Detail
	}

	if !tea.BoolValue(util.IsUnset(request.DndEnd)) {
		body["DndEnd"] = request.DndEnd
	}

	if !tea.BoolValue(util.IsUnset(request.MaxAlertTimes)) {
		body["MaxAlertTimes"] = request.MaxAlertTimes
	}

	if !tea.BoolValue(util.IsUnset(request.NodeIds)) {
		body["NodeIds"] = request.NodeIds
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.RemindId)) {
		body["RemindId"] = request.RemindId
	}

	if !tea.BoolValue(util.IsUnset(request.RemindName)) {
		body["RemindName"] = request.RemindName
	}

	if !tea.BoolValue(util.IsUnset(request.RemindType)) {
		body["RemindType"] = request.RemindType
	}

	if !tea.BoolValue(util.IsUnset(request.RemindUnit)) {
		body["RemindUnit"] = request.RemindUnit
	}

	if !tea.BoolValue(util.IsUnset(request.RobotUrls)) {
		body["RobotUrls"] = request.RobotUrls
	}

	if !tea.BoolValue(util.IsUnset(request.UseFlag)) {
		body["UseFlag"] = request.UseFlag
	}

	if !tea.BoolValue(util.IsUnset(request.Webhooks)) {
		body["Webhooks"] = request.Webhooks
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateRemind"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateRemindResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateRemind(request *UpdateRemindRequest) (_result *UpdateRemindResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateRemindResponse{}
	_body, _err := client.UpdateRemindWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTableWithOptions(request *UpdateTableRequest, runtime *util.RuntimeOptions) (_result *UpdateTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppGuid)) {
		query["AppGuid"] = request.AppGuid
	}

	if !tea.BoolValue(util.IsUnset(request.CategoryId)) {
		query["CategoryId"] = request.CategoryId
	}

	if !tea.BoolValue(util.IsUnset(request.Comment)) {
		query["Comment"] = request.Comment
	}

	if !tea.BoolValue(util.IsUnset(request.CreateIfNotExists)) {
		query["CreateIfNotExists"] = request.CreateIfNotExists
	}

	if !tea.BoolValue(util.IsUnset(request.ExternalTableType)) {
		query["ExternalTableType"] = request.ExternalTableType
	}

	if !tea.BoolValue(util.IsUnset(request.HasPart)) {
		query["HasPart"] = request.HasPart
	}

	if !tea.BoolValue(util.IsUnset(request.IsView)) {
		query["IsView"] = request.IsView
	}

	if !tea.BoolValue(util.IsUnset(request.LifeCycle)) {
		query["LifeCycle"] = request.LifeCycle
	}

	if !tea.BoolValue(util.IsUnset(request.Location)) {
		query["Location"] = request.Location
	}

	if !tea.BoolValue(util.IsUnset(request.LogicalLevelId)) {
		query["LogicalLevelId"] = request.LogicalLevelId
	}

	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	if !tea.BoolValue(util.IsUnset(request.PhysicsLevelId)) {
		query["PhysicsLevelId"] = request.PhysicsLevelId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.Schema)) {
		query["Schema"] = request.Schema
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	if !tea.BoolValue(util.IsUnset(request.Visibility)) {
		query["Visibility"] = request.Visibility
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Columns)) {
		body["Columns"] = request.Columns
	}

	if !tea.BoolValue(util.IsUnset(request.Endpoint)) {
		body["Endpoint"] = request.Endpoint
	}

	if !tea.BoolValue(util.IsUnset(request.EnvType)) {
		body["EnvType"] = request.EnvType
	}

	if !tea.BoolValue(util.IsUnset(request.Themes)) {
		body["Themes"] = request.Themes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTable"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTable(request *UpdateTableRequest) (_result *UpdateTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTableResponse{}
	_body, _err := client.UpdateTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTableAddColumnWithOptions(request *UpdateTableAddColumnRequest, runtime *util.RuntimeOptions) (_result *UpdateTableAddColumnResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Column)) {
		body["Column"] = request.Column
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTableAddColumn"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTableAddColumnResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTableAddColumn(request *UpdateTableAddColumnRequest) (_result *UpdateTableAddColumnResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTableAddColumnResponse{}
	_body, _err := client.UpdateTableAddColumnWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTableLevelWithOptions(request *UpdateTableLevelRequest, runtime *util.RuntimeOptions) (_result *UpdateTableLevelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.LevelId)) {
		query["LevelId"] = request.LevelId
	}

	if !tea.BoolValue(util.IsUnset(request.LevelType)) {
		query["LevelType"] = request.LevelType
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTableLevel"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTableLevelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTableLevel(request *UpdateTableLevelRequest) (_result *UpdateTableLevelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTableLevelResponse{}
	_body, _err := client.UpdateTableLevelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTableModelInfoWithOptions(request *UpdateTableModelInfoRequest, runtime *util.RuntimeOptions) (_result *UpdateTableModelInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FirstLevelThemeId)) {
		query["FirstLevelThemeId"] = request.FirstLevelThemeId
	}

	if !tea.BoolValue(util.IsUnset(request.LevelId)) {
		query["LevelId"] = request.LevelId
	}

	if !tea.BoolValue(util.IsUnset(request.LevelType)) {
		query["LevelType"] = request.LevelType
	}

	if !tea.BoolValue(util.IsUnset(request.SecondLevelThemeId)) {
		query["SecondLevelThemeId"] = request.SecondLevelThemeId
	}

	if !tea.BoolValue(util.IsUnset(request.TableGuid)) {
		query["TableGuid"] = request.TableGuid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTableModelInfo"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTableModelInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTableModelInfo(request *UpdateTableModelInfoRequest) (_result *UpdateTableModelInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTableModelInfoResponse{}
	_body, _err := client.UpdateTableModelInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateTableThemeWithOptions(request *UpdateTableThemeRequest, runtime *util.RuntimeOptions) (_result *UpdateTableThemeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		query["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ThemeId)) {
		query["ThemeId"] = request.ThemeId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTableTheme"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTableThemeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateTableTheme(request *UpdateTableThemeRequest) (_result *UpdateTableThemeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTableThemeResponse{}
	_body, _err := client.UpdateTableThemeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateUdfFileWithOptions(request *UpdateUdfFileRequest, runtime *util.RuntimeOptions) (_result *UpdateUdfFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClassName)) {
		body["ClassName"] = request.ClassName
	}

	if !tea.BoolValue(util.IsUnset(request.CmdDescription)) {
		body["CmdDescription"] = request.CmdDescription
	}

	if !tea.BoolValue(util.IsUnset(request.Example)) {
		body["Example"] = request.Example
	}

	if !tea.BoolValue(util.IsUnset(request.FileFolderPath)) {
		body["FileFolderPath"] = request.FileFolderPath
	}

	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		body["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionType)) {
		body["FunctionType"] = request.FunctionType
	}

	if !tea.BoolValue(util.IsUnset(request.ParameterDescription)) {
		body["ParameterDescription"] = request.ParameterDescription
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectIdentifier)) {
		body["ProjectIdentifier"] = request.ProjectIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.Resources)) {
		body["Resources"] = request.Resources
	}

	if !tea.BoolValue(util.IsUnset(request.ReturnValue)) {
		body["ReturnValue"] = request.ReturnValue
	}

	if !tea.BoolValue(util.IsUnset(request.UdfDescription)) {
		body["UdfDescription"] = request.UdfDescription
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateUdfFile"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateUdfFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateUdfFile(request *UpdateUdfFileRequest) (_result *UpdateUdfFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateUdfFileResponse{}
	_body, _err := client.UpdateUdfFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateWorkbenchEventResultWithOptions(request *UpdateWorkbenchEventResultRequest, runtime *util.RuntimeOptions) (_result *UpdateWorkbenchEventResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CheckResult)) {
		query["CheckResult"] = request.CheckResult
	}

	if !tea.BoolValue(util.IsUnset(request.CheckResultTip)) {
		query["CheckResultTip"] = request.CheckResultTip
	}

	if !tea.BoolValue(util.IsUnset(request.ExtensionCode)) {
		query["ExtensionCode"] = request.ExtensionCode
	}

	if !tea.BoolValue(util.IsUnset(request.MessageId)) {
		query["MessageId"] = request.MessageId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateWorkbenchEventResult"),
		Version:     tea.String("2020-05-18"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateWorkbenchEventResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateWorkbenchEventResult(request *UpdateWorkbenchEventResultRequest) (_result *UpdateWorkbenchEventResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateWorkbenchEventResultResponse{}
	_body, _err := client.UpdateWorkbenchEventResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
