// This file is auto-generated, don't edit it. Thanks.
/**
 *
 */
package client

import (
	openapi "github.com/alibabacloud-go/darabonba-openapi/v2/client"
	endpointutil "github.com/alibabacloud-go/endpoint-util/service"
	openapiutil "github.com/alibabacloud-go/openapi-util/service"
	util "github.com/alibabacloud-go/tea-utils/v2/service"
	"github.com/alibabacloud-go/tea/tea"
)

type AddDataForApiSourceRequest struct {
	ApiId         *string `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	Content       *string `json:"Content,omitempty" xml:"Content,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s AddDataForApiSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s AddDataForApiSourceRequest) GoString() string {
	return s.String()
}

func (s *AddDataForApiSourceRequest) SetApiId(v string) *AddDataForApiSourceRequest {
	s.ApiId = &v
	return s
}

func (s *AddDataForApiSourceRequest) SetContent(v string) *AddDataForApiSourceRequest {
	s.Content = &v
	return s
}

func (s *AddDataForApiSourceRequest) SetIotInstanceId(v string) *AddDataForApiSourceRequest {
	s.IotInstanceId = &v
	return s
}

type AddDataForApiSourceResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *int64  `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddDataForApiSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddDataForApiSourceResponseBody) GoString() string {
	return s.String()
}

func (s *AddDataForApiSourceResponseBody) SetCode(v string) *AddDataForApiSourceResponseBody {
	s.Code = &v
	return s
}

func (s *AddDataForApiSourceResponseBody) SetData(v int64) *AddDataForApiSourceResponseBody {
	s.Data = &v
	return s
}

func (s *AddDataForApiSourceResponseBody) SetErrorMessage(v string) *AddDataForApiSourceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AddDataForApiSourceResponseBody) SetRequestId(v string) *AddDataForApiSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddDataForApiSourceResponseBody) SetSuccess(v bool) *AddDataForApiSourceResponseBody {
	s.Success = &v
	return s
}

type AddDataForApiSourceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddDataForApiSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddDataForApiSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s AddDataForApiSourceResponse) GoString() string {
	return s.String()
}

func (s *AddDataForApiSourceResponse) SetHeaders(v map[string]*string) *AddDataForApiSourceResponse {
	s.Headers = v
	return s
}

func (s *AddDataForApiSourceResponse) SetStatusCode(v int32) *AddDataForApiSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *AddDataForApiSourceResponse) SetBody(v *AddDataForApiSourceResponseBody) *AddDataForApiSourceResponse {
	s.Body = v
	return s
}

type AddDeviceToSharePromotionRequest struct {
	DeviceSimpleInfoList     []*AddDeviceToSharePromotionRequestDeviceSimpleInfoList `json:"DeviceSimpleInfoList,omitempty" xml:"DeviceSimpleInfoList,omitempty" type:"Repeated"`
	IotInstanceId            *string                                                 `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	SharePromotionActivityId *string                                                 `json:"SharePromotionActivityId,omitempty" xml:"SharePromotionActivityId,omitempty"`
	ShareTaskCode            *string                                                 `json:"ShareTaskCode,omitempty" xml:"ShareTaskCode,omitempty"`
}

func (s AddDeviceToSharePromotionRequest) String() string {
	return tea.Prettify(s)
}

func (s AddDeviceToSharePromotionRequest) GoString() string {
	return s.String()
}

func (s *AddDeviceToSharePromotionRequest) SetDeviceSimpleInfoList(v []*AddDeviceToSharePromotionRequestDeviceSimpleInfoList) *AddDeviceToSharePromotionRequest {
	s.DeviceSimpleInfoList = v
	return s
}

func (s *AddDeviceToSharePromotionRequest) SetIotInstanceId(v string) *AddDeviceToSharePromotionRequest {
	s.IotInstanceId = &v
	return s
}

func (s *AddDeviceToSharePromotionRequest) SetSharePromotionActivityId(v string) *AddDeviceToSharePromotionRequest {
	s.SharePromotionActivityId = &v
	return s
}

func (s *AddDeviceToSharePromotionRequest) SetShareTaskCode(v string) *AddDeviceToSharePromotionRequest {
	s.ShareTaskCode = &v
	return s
}

type AddDeviceToSharePromotionRequestDeviceSimpleInfoList struct {
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s AddDeviceToSharePromotionRequestDeviceSimpleInfoList) String() string {
	return tea.Prettify(s)
}

func (s AddDeviceToSharePromotionRequestDeviceSimpleInfoList) GoString() string {
	return s.String()
}

func (s *AddDeviceToSharePromotionRequestDeviceSimpleInfoList) SetDeviceName(v string) *AddDeviceToSharePromotionRequestDeviceSimpleInfoList {
	s.DeviceName = &v
	return s
}

func (s *AddDeviceToSharePromotionRequestDeviceSimpleInfoList) SetProductKey(v string) *AddDeviceToSharePromotionRequestDeviceSimpleInfoList {
	s.ProductKey = &v
	return s
}

type AddDeviceToSharePromotionResponseBody struct {
	Code         *string                                    `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *AddDeviceToSharePromotionResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                    `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                      `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddDeviceToSharePromotionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddDeviceToSharePromotionResponseBody) GoString() string {
	return s.String()
}

func (s *AddDeviceToSharePromotionResponseBody) SetCode(v string) *AddDeviceToSharePromotionResponseBody {
	s.Code = &v
	return s
}

func (s *AddDeviceToSharePromotionResponseBody) SetData(v *AddDeviceToSharePromotionResponseBodyData) *AddDeviceToSharePromotionResponseBody {
	s.Data = v
	return s
}

func (s *AddDeviceToSharePromotionResponseBody) SetErrorMessage(v string) *AddDeviceToSharePromotionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AddDeviceToSharePromotionResponseBody) SetRequestId(v string) *AddDeviceToSharePromotionResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddDeviceToSharePromotionResponseBody) SetSuccess(v bool) *AddDeviceToSharePromotionResponseBody {
	s.Success = &v
	return s
}

type AddDeviceToSharePromotionResponseBodyData struct {
	FailDeviceSimpleInfoList *AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList `json:"FailDeviceSimpleInfoList,omitempty" xml:"FailDeviceSimpleInfoList,omitempty" type:"Struct"`
}

func (s AddDeviceToSharePromotionResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AddDeviceToSharePromotionResponseBodyData) GoString() string {
	return s.String()
}

func (s *AddDeviceToSharePromotionResponseBodyData) SetFailDeviceSimpleInfoList(v *AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList) *AddDeviceToSharePromotionResponseBodyData {
	s.FailDeviceSimpleInfoList = v
	return s
}

type AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList struct {
	Item []*AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem `json:"item,omitempty" xml:"item,omitempty" type:"Repeated"`
}

func (s AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList) String() string {
	return tea.Prettify(s)
}

func (s AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList) GoString() string {
	return s.String()
}

func (s *AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList) SetItem(v []*AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem) *AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoList {
	s.Item = v
	return s
}

type AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem struct {
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	FailCode   *int32  `json:"FailCode,omitempty" xml:"FailCode,omitempty"`
	FailReason *string `json:"FailReason,omitempty" xml:"FailReason,omitempty"`
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem) String() string {
	return tea.Prettify(s)
}

func (s AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem) GoString() string {
	return s.String()
}

func (s *AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem) SetDeviceName(v string) *AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem {
	s.DeviceName = &v
	return s
}

func (s *AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem) SetFailCode(v int32) *AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem {
	s.FailCode = &v
	return s
}

func (s *AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem) SetFailReason(v string) *AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem {
	s.FailReason = &v
	return s
}

func (s *AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem) SetProductKey(v string) *AddDeviceToSharePromotionResponseBodyDataFailDeviceSimpleInfoListItem {
	s.ProductKey = &v
	return s
}

type AddDeviceToSharePromotionResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddDeviceToSharePromotionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddDeviceToSharePromotionResponse) String() string {
	return tea.Prettify(s)
}

func (s AddDeviceToSharePromotionResponse) GoString() string {
	return s.String()
}

func (s *AddDeviceToSharePromotionResponse) SetHeaders(v map[string]*string) *AddDeviceToSharePromotionResponse {
	s.Headers = v
	return s
}

func (s *AddDeviceToSharePromotionResponse) SetStatusCode(v int32) *AddDeviceToSharePromotionResponse {
	s.StatusCode = &v
	return s
}

func (s *AddDeviceToSharePromotionResponse) SetBody(v *AddDeviceToSharePromotionResponseBody) *AddDeviceToSharePromotionResponse {
	s.Body = v
	return s
}

type AddShareTaskDeviceRequest struct {
	IotIdList     []*string `json:"IotIdList,omitempty" xml:"IotIdList,omitempty" type:"Repeated"`
	IotInstanceId *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string   `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	ShareTaskId   *string   `json:"ShareTaskId,omitempty" xml:"ShareTaskId,omitempty"`
}

func (s AddShareTaskDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s AddShareTaskDeviceRequest) GoString() string {
	return s.String()
}

func (s *AddShareTaskDeviceRequest) SetIotIdList(v []*string) *AddShareTaskDeviceRequest {
	s.IotIdList = v
	return s
}

func (s *AddShareTaskDeviceRequest) SetIotInstanceId(v string) *AddShareTaskDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *AddShareTaskDeviceRequest) SetProductKey(v string) *AddShareTaskDeviceRequest {
	s.ProductKey = &v
	return s
}

func (s *AddShareTaskDeviceRequest) SetShareTaskId(v string) *AddShareTaskDeviceRequest {
	s.ShareTaskId = &v
	return s
}

type AddShareTaskDeviceResponseBody struct {
	Code         *string                             `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *AddShareTaskDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                             `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                               `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AddShareTaskDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AddShareTaskDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *AddShareTaskDeviceResponseBody) SetCode(v string) *AddShareTaskDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *AddShareTaskDeviceResponseBody) SetData(v *AddShareTaskDeviceResponseBodyData) *AddShareTaskDeviceResponseBody {
	s.Data = v
	return s
}

func (s *AddShareTaskDeviceResponseBody) SetErrorMessage(v string) *AddShareTaskDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AddShareTaskDeviceResponseBody) SetRequestId(v string) *AddShareTaskDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *AddShareTaskDeviceResponseBody) SetSuccess(v bool) *AddShareTaskDeviceResponseBody {
	s.Success = &v
	return s
}

type AddShareTaskDeviceResponseBodyData struct {
	FailSum             *int32  `json:"FailSum,omitempty" xml:"FailSum,omitempty"`
	FailedResultCsvFile *string `json:"FailedResultCsvFile,omitempty" xml:"FailedResultCsvFile,omitempty"`
	Progress            *int32  `json:"Progress,omitempty" xml:"Progress,omitempty"`
	ProgressId          *string `json:"ProgressId,omitempty" xml:"ProgressId,omitempty"`
	SuccessSum          *int32  `json:"SuccessSum,omitempty" xml:"SuccessSum,omitempty"`
}

func (s AddShareTaskDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s AddShareTaskDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *AddShareTaskDeviceResponseBodyData) SetFailSum(v int32) *AddShareTaskDeviceResponseBodyData {
	s.FailSum = &v
	return s
}

func (s *AddShareTaskDeviceResponseBodyData) SetFailedResultCsvFile(v string) *AddShareTaskDeviceResponseBodyData {
	s.FailedResultCsvFile = &v
	return s
}

func (s *AddShareTaskDeviceResponseBodyData) SetProgress(v int32) *AddShareTaskDeviceResponseBodyData {
	s.Progress = &v
	return s
}

func (s *AddShareTaskDeviceResponseBodyData) SetProgressId(v string) *AddShareTaskDeviceResponseBodyData {
	s.ProgressId = &v
	return s
}

func (s *AddShareTaskDeviceResponseBodyData) SetSuccessSum(v int32) *AddShareTaskDeviceResponseBodyData {
	s.SuccessSum = &v
	return s
}

type AddShareTaskDeviceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AddShareTaskDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AddShareTaskDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s AddShareTaskDeviceResponse) GoString() string {
	return s.String()
}

func (s *AddShareTaskDeviceResponse) SetHeaders(v map[string]*string) *AddShareTaskDeviceResponse {
	s.Headers = v
	return s
}

func (s *AddShareTaskDeviceResponse) SetStatusCode(v int32) *AddShareTaskDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *AddShareTaskDeviceResponse) SetBody(v *AddShareTaskDeviceResponseBody) *AddShareTaskDeviceResponse {
	s.Body = v
	return s
}

type AsyncRRpcRequest struct {
	DeviceName     *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	ExtInfo        *string `json:"ExtInfo,omitempty" xml:"ExtInfo,omitempty"`
	IotInstanceId  *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	MessageContent *string `json:"MessageContent,omitempty" xml:"MessageContent,omitempty"`
	ProductKey     *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	TopicFullName  *string `json:"TopicFullName,omitempty" xml:"TopicFullName,omitempty"`
}

func (s AsyncRRpcRequest) String() string {
	return tea.Prettify(s)
}

func (s AsyncRRpcRequest) GoString() string {
	return s.String()
}

func (s *AsyncRRpcRequest) SetDeviceName(v string) *AsyncRRpcRequest {
	s.DeviceName = &v
	return s
}

func (s *AsyncRRpcRequest) SetExtInfo(v string) *AsyncRRpcRequest {
	s.ExtInfo = &v
	return s
}

func (s *AsyncRRpcRequest) SetIotInstanceId(v string) *AsyncRRpcRequest {
	s.IotInstanceId = &v
	return s
}

func (s *AsyncRRpcRequest) SetMessageContent(v string) *AsyncRRpcRequest {
	s.MessageContent = &v
	return s
}

func (s *AsyncRRpcRequest) SetProductKey(v string) *AsyncRRpcRequest {
	s.ProductKey = &v
	return s
}

func (s *AsyncRRpcRequest) SetTopicFullName(v string) *AsyncRRpcRequest {
	s.TopicFullName = &v
	return s
}

type AsyncRRpcResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	MessageId    *int64  `json:"MessageId,omitempty" xml:"MessageId,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AsyncRRpcResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AsyncRRpcResponseBody) GoString() string {
	return s.String()
}

func (s *AsyncRRpcResponseBody) SetCode(v string) *AsyncRRpcResponseBody {
	s.Code = &v
	return s
}

func (s *AsyncRRpcResponseBody) SetErrorMessage(v string) *AsyncRRpcResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AsyncRRpcResponseBody) SetMessageId(v int64) *AsyncRRpcResponseBody {
	s.MessageId = &v
	return s
}

func (s *AsyncRRpcResponseBody) SetRequestId(v string) *AsyncRRpcResponseBody {
	s.RequestId = &v
	return s
}

func (s *AsyncRRpcResponseBody) SetSuccess(v bool) *AsyncRRpcResponseBody {
	s.Success = &v
	return s
}

type AsyncRRpcResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AsyncRRpcResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AsyncRRpcResponse) String() string {
	return tea.Prettify(s)
}

func (s AsyncRRpcResponse) GoString() string {
	return s.String()
}

func (s *AsyncRRpcResponse) SetHeaders(v map[string]*string) *AsyncRRpcResponse {
	s.Headers = v
	return s
}

func (s *AsyncRRpcResponse) SetStatusCode(v int32) *AsyncRRpcResponse {
	s.StatusCode = &v
	return s
}

func (s *AsyncRRpcResponse) SetBody(v *AsyncRRpcResponseBody) *AsyncRRpcResponse {
	s.Body = v
	return s
}

type AttachDestinationRequest struct {
	DestinationId *int64  `json:"DestinationId,omitempty" xml:"DestinationId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	IsFailover    *bool   `json:"IsFailover,omitempty" xml:"IsFailover,omitempty"`
	ParserId      *int64  `json:"ParserId,omitempty" xml:"ParserId,omitempty"`
}

func (s AttachDestinationRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachDestinationRequest) GoString() string {
	return s.String()
}

func (s *AttachDestinationRequest) SetDestinationId(v int64) *AttachDestinationRequest {
	s.DestinationId = &v
	return s
}

func (s *AttachDestinationRequest) SetIotInstanceId(v string) *AttachDestinationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *AttachDestinationRequest) SetIsFailover(v bool) *AttachDestinationRequest {
	s.IsFailover = &v
	return s
}

func (s *AttachDestinationRequest) SetParserId(v int64) *AttachDestinationRequest {
	s.ParserId = &v
	return s
}

type AttachDestinationResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AttachDestinationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachDestinationResponseBody) GoString() string {
	return s.String()
}

func (s *AttachDestinationResponseBody) SetCode(v string) *AttachDestinationResponseBody {
	s.Code = &v
	return s
}

func (s *AttachDestinationResponseBody) SetErrorMessage(v string) *AttachDestinationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AttachDestinationResponseBody) SetRequestId(v string) *AttachDestinationResponseBody {
	s.RequestId = &v
	return s
}

func (s *AttachDestinationResponseBody) SetSuccess(v bool) *AttachDestinationResponseBody {
	s.Success = &v
	return s
}

type AttachDestinationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachDestinationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachDestinationResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachDestinationResponse) GoString() string {
	return s.String()
}

func (s *AttachDestinationResponse) SetHeaders(v map[string]*string) *AttachDestinationResponse {
	s.Headers = v
	return s
}

func (s *AttachDestinationResponse) SetStatusCode(v int32) *AttachDestinationResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachDestinationResponse) SetBody(v *AttachDestinationResponseBody) *AttachDestinationResponse {
	s.Body = v
	return s
}

type AttachParserDataSourceRequest struct {
	DataSourceId  *int64  `json:"DataSourceId,omitempty" xml:"DataSourceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ParserId      *int64  `json:"ParserId,omitempty" xml:"ParserId,omitempty"`
}

func (s AttachParserDataSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s AttachParserDataSourceRequest) GoString() string {
	return s.String()
}

func (s *AttachParserDataSourceRequest) SetDataSourceId(v int64) *AttachParserDataSourceRequest {
	s.DataSourceId = &v
	return s
}

func (s *AttachParserDataSourceRequest) SetIotInstanceId(v string) *AttachParserDataSourceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *AttachParserDataSourceRequest) SetParserId(v int64) *AttachParserDataSourceRequest {
	s.ParserId = &v
	return s
}

type AttachParserDataSourceResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s AttachParserDataSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s AttachParserDataSourceResponseBody) GoString() string {
	return s.String()
}

func (s *AttachParserDataSourceResponseBody) SetCode(v string) *AttachParserDataSourceResponseBody {
	s.Code = &v
	return s
}

func (s *AttachParserDataSourceResponseBody) SetErrorMessage(v string) *AttachParserDataSourceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *AttachParserDataSourceResponseBody) SetRequestId(v string) *AttachParserDataSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *AttachParserDataSourceResponseBody) SetSuccess(v bool) *AttachParserDataSourceResponseBody {
	s.Success = &v
	return s
}

type AttachParserDataSourceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *AttachParserDataSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s AttachParserDataSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s AttachParserDataSourceResponse) GoString() string {
	return s.String()
}

func (s *AttachParserDataSourceResponse) SetHeaders(v map[string]*string) *AttachParserDataSourceResponse {
	s.Headers = v
	return s
}

func (s *AttachParserDataSourceResponse) SetStatusCode(v int32) *AttachParserDataSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *AttachParserDataSourceResponse) SetBody(v *AttachParserDataSourceResponseBody) *AttachParserDataSourceResponse {
	s.Body = v
	return s
}

type BatchAddDataForApiSourceRequest struct {
	ApiId         *string `json:"ApiId,omitempty" xml:"ApiId,omitempty"`
	ContentList   *string `json:"ContentList,omitempty" xml:"ContentList,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchAddDataForApiSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchAddDataForApiSourceRequest) GoString() string {
	return s.String()
}

func (s *BatchAddDataForApiSourceRequest) SetApiId(v string) *BatchAddDataForApiSourceRequest {
	s.ApiId = &v
	return s
}

func (s *BatchAddDataForApiSourceRequest) SetContentList(v string) *BatchAddDataForApiSourceRequest {
	s.ContentList = &v
	return s
}

func (s *BatchAddDataForApiSourceRequest) SetIotInstanceId(v string) *BatchAddDataForApiSourceRequest {
	s.IotInstanceId = &v
	return s
}

type BatchAddDataForApiSourceResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchAddDataForApiSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchAddDataForApiSourceResponseBody) GoString() string {
	return s.String()
}

func (s *BatchAddDataForApiSourceResponseBody) SetCode(v string) *BatchAddDataForApiSourceResponseBody {
	s.Code = &v
	return s
}

func (s *BatchAddDataForApiSourceResponseBody) SetErrorMessage(v string) *BatchAddDataForApiSourceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchAddDataForApiSourceResponseBody) SetRequestId(v string) *BatchAddDataForApiSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchAddDataForApiSourceResponseBody) SetSuccess(v bool) *BatchAddDataForApiSourceResponseBody {
	s.Success = &v
	return s
}

type BatchAddDataForApiSourceResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchAddDataForApiSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchAddDataForApiSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchAddDataForApiSourceResponse) GoString() string {
	return s.String()
}

func (s *BatchAddDataForApiSourceResponse) SetHeaders(v map[string]*string) *BatchAddDataForApiSourceResponse {
	s.Headers = v
	return s
}

func (s *BatchAddDataForApiSourceResponse) SetStatusCode(v int32) *BatchAddDataForApiSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchAddDataForApiSourceResponse) SetBody(v *BatchAddDataForApiSourceResponseBody) *BatchAddDataForApiSourceResponse {
	s.Body = v
	return s
}

type BatchAddDeviceGroupRelationsRequest struct {
	Device []*BatchAddDeviceGroupRelationsRequestDevice `json:"Device,omitempty" xml:"Device,omitempty" type:"Repeated"`
	// The ProductKeys of the products to which the devices belong. You can specify a maximum of 200 ProductKeys.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the group. The ID is the globally unique identifier (GUID) for the group.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchAddDeviceGroupRelationsRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchAddDeviceGroupRelationsRequest) GoString() string {
	return s.String()
}

func (s *BatchAddDeviceGroupRelationsRequest) SetDevice(v []*BatchAddDeviceGroupRelationsRequestDevice) *BatchAddDeviceGroupRelationsRequest {
	s.Device = v
	return s
}

func (s *BatchAddDeviceGroupRelationsRequest) SetGroupId(v string) *BatchAddDeviceGroupRelationsRequest {
	s.GroupId = &v
	return s
}

func (s *BatchAddDeviceGroupRelationsRequest) SetIotInstanceId(v string) *BatchAddDeviceGroupRelationsRequest {
	s.IotInstanceId = &v
	return s
}

type BatchAddDeviceGroupRelationsRequestDevice struct {
	// The error message returned if the call fails.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The names of the devices to be added. You can specify a maximum of 200 devices.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BatchAddDeviceGroupRelationsRequestDevice) String() string {
	return tea.Prettify(s)
}

func (s BatchAddDeviceGroupRelationsRequestDevice) GoString() string {
	return s.String()
}

func (s *BatchAddDeviceGroupRelationsRequestDevice) SetDeviceName(v string) *BatchAddDeviceGroupRelationsRequestDevice {
	s.DeviceName = &v
	return s
}

func (s *BatchAddDeviceGroupRelationsRequestDevice) SetProductKey(v string) *BatchAddDeviceGroupRelationsRequestDevice {
	s.ProductKey = &v
	return s
}

type BatchAddDeviceGroupRelationsResponseBody struct {
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	AlreadyRelatedGroupDeviceCount *int32 `json:"AlreadyRelatedGroupDeviceCount,omitempty" xml:"AlreadyRelatedGroupDeviceCount,omitempty"`
	// The number of valid devices that you specified.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the request.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The number of devices that exist in the group.
	ExceedTenGroupDeviceCount *int32 `json:"ExceedTenGroupDeviceCount,omitempty" xml:"ExceedTenGroupDeviceCount,omitempty"`
	// The number of the specified devices that are added to 10 or more groups. You can add a device to a maximum of 10 groups.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Success                 *bool  `json:"Success,omitempty" xml:"Success,omitempty"`
	SuccessAddedDeviceCount *int32 `json:"SuccessAddedDeviceCount,omitempty" xml:"SuccessAddedDeviceCount,omitempty"`
	// The number of devices that are added to the group.
	ValidDeviceCount *int32 `json:"ValidDeviceCount,omitempty" xml:"ValidDeviceCount,omitempty"`
}

func (s BatchAddDeviceGroupRelationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchAddDeviceGroupRelationsResponseBody) GoString() string {
	return s.String()
}

func (s *BatchAddDeviceGroupRelationsResponseBody) SetAlreadyRelatedGroupDeviceCount(v int32) *BatchAddDeviceGroupRelationsResponseBody {
	s.AlreadyRelatedGroupDeviceCount = &v
	return s
}

func (s *BatchAddDeviceGroupRelationsResponseBody) SetCode(v string) *BatchAddDeviceGroupRelationsResponseBody {
	s.Code = &v
	return s
}

func (s *BatchAddDeviceGroupRelationsResponseBody) SetErrorMessage(v string) *BatchAddDeviceGroupRelationsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchAddDeviceGroupRelationsResponseBody) SetExceedTenGroupDeviceCount(v int32) *BatchAddDeviceGroupRelationsResponseBody {
	s.ExceedTenGroupDeviceCount = &v
	return s
}

func (s *BatchAddDeviceGroupRelationsResponseBody) SetRequestId(v string) *BatchAddDeviceGroupRelationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchAddDeviceGroupRelationsResponseBody) SetSuccess(v bool) *BatchAddDeviceGroupRelationsResponseBody {
	s.Success = &v
	return s
}

func (s *BatchAddDeviceGroupRelationsResponseBody) SetSuccessAddedDeviceCount(v int32) *BatchAddDeviceGroupRelationsResponseBody {
	s.SuccessAddedDeviceCount = &v
	return s
}

func (s *BatchAddDeviceGroupRelationsResponseBody) SetValidDeviceCount(v int32) *BatchAddDeviceGroupRelationsResponseBody {
	s.ValidDeviceCount = &v
	return s
}

type BatchAddDeviceGroupRelationsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchAddDeviceGroupRelationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchAddDeviceGroupRelationsResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchAddDeviceGroupRelationsResponse) GoString() string {
	return s.String()
}

func (s *BatchAddDeviceGroupRelationsResponse) SetHeaders(v map[string]*string) *BatchAddDeviceGroupRelationsResponse {
	s.Headers = v
	return s
}

func (s *BatchAddDeviceGroupRelationsResponse) SetStatusCode(v int32) *BatchAddDeviceGroupRelationsResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchAddDeviceGroupRelationsResponse) SetBody(v *BatchAddDeviceGroupRelationsResponseBody) *BatchAddDeviceGroupRelationsResponse {
	s.Body = v
	return s
}

type BatchAddThingTopoRequest struct {
	// The name of the gateway.
	GwDeviceName *string `json:"GwDeviceName,omitempty" xml:"GwDeviceName,omitempty"`
	// The key of the product to which the gateway belongs.
	GwProductKey *string `json:"GwProductKey,omitempty" xml:"GwProductKey,omitempty"`
	// The ID of the instance. On the **Overview** page in the IoT Platform console, you can view the ID of the instance.
	//
	// >*   If your instance has an ID, you must specify this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or instance ID appears in the IoT Platform console, ignore this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string                                `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	TopoAddItem   []*BatchAddThingTopoRequestTopoAddItem `json:"TopoAddItem,omitempty" xml:"TopoAddItem,omitempty" type:"Repeated"`
}

func (s BatchAddThingTopoRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchAddThingTopoRequest) GoString() string {
	return s.String()
}

func (s *BatchAddThingTopoRequest) SetGwDeviceName(v string) *BatchAddThingTopoRequest {
	s.GwDeviceName = &v
	return s
}

func (s *BatchAddThingTopoRequest) SetGwProductKey(v string) *BatchAddThingTopoRequest {
	s.GwProductKey = &v
	return s
}

func (s *BatchAddThingTopoRequest) SetIotInstanceId(v string) *BatchAddThingTopoRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchAddThingTopoRequest) SetTopoAddItem(v []*BatchAddThingTopoRequestTopoAddItem) *BatchAddThingTopoRequest {
	s.TopoAddItem = v
	return s
}

type BatchAddThingTopoRequestTopoAddItem struct {
	// The client ID of the sub-device. The ID can be the serial number (SN) or media access control (MAC) address of the device. This parameter is optional.
	//
	// > If this parameter is included in the value of the **TopoAddItem.N.Sign** parameter, you must specify this parameter.
	ClientId *string `json:"ClientId,omitempty" xml:"ClientId,omitempty"`
	// The name of each sub-device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The key of the product to which the sub-device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The signature of the sub-device.
	//
	// Set the Sign parameter to the result of the **SignMethod(deviceSecret,content)** function.
	//
	// To obtain the **content** parameter, sort all sub-device parameters that are submitted to the server, except the Sign and SignMethod parameters, in alphabetical order. Then, concatenate the parameters and values in sequence. No concatenation symbol is required to separate these parameters and values.
	//
	// For example, you want to specify the following parameters for a sub-device: **ClientId=868575026974305, DeviceName=868575026974305, ProductKey=a1PB5fp1234, SignMethod=hmacmd5, timestamp=1646277090411, and deviceSecret=1234**. In this case, the signature function is `hmacmd5(1234, clientId868575026974305deviceName868575026974305productKeya1PB5fp1234timestamp1646277090411)`, and the calculation result is `3BA0DFA4C477B40C007D84D30D6466CC`.
	//
	// >  In the preceding example, **ClientId** indicates the client ID of the sub-device. You can specify a custom client ID.
	//
	// For more information about how to calculate the signature value, see [How do I obtain MQTT parameters for authentication?](~~292635~~). The signature value is the calculated value of the passwd parameter.
	Sign *string `json:"Sign,omitempty" xml:"Sign,omitempty"`
	// The signature algorithm. Valid values: **hmacSha1**, **hmacSha256**, **hmacMd5**, and **Sha256**. The value is not case-sensitive.
	SignMethod *string `json:"SignMethod,omitempty" xml:"SignMethod,omitempty"`
	// The timestamp in UTC. This parameter is optional.
	//
	// > If this parameter is included in the value of the **TopoAddItem.N.Sign** parameter, you must specify this parameter.
	Timestamp *string `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s BatchAddThingTopoRequestTopoAddItem) String() string {
	return tea.Prettify(s)
}

func (s BatchAddThingTopoRequestTopoAddItem) GoString() string {
	return s.String()
}

func (s *BatchAddThingTopoRequestTopoAddItem) SetClientId(v string) *BatchAddThingTopoRequestTopoAddItem {
	s.ClientId = &v
	return s
}

func (s *BatchAddThingTopoRequestTopoAddItem) SetDeviceName(v string) *BatchAddThingTopoRequestTopoAddItem {
	s.DeviceName = &v
	return s
}

func (s *BatchAddThingTopoRequestTopoAddItem) SetProductKey(v string) *BatchAddThingTopoRequestTopoAddItem {
	s.ProductKey = &v
	return s
}

func (s *BatchAddThingTopoRequestTopoAddItem) SetSign(v string) *BatchAddThingTopoRequestTopoAddItem {
	s.Sign = &v
	return s
}

func (s *BatchAddThingTopoRequestTopoAddItem) SetSignMethod(v string) *BatchAddThingTopoRequestTopoAddItem {
	s.SignMethod = &v
	return s
}

func (s *BatchAddThingTopoRequestTopoAddItem) SetTimestamp(v string) *BatchAddThingTopoRequestTopoAddItem {
	s.Timestamp = &v
	return s
}

type BatchAddThingTopoResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchAddThingTopoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchAddThingTopoResponseBody) GoString() string {
	return s.String()
}

func (s *BatchAddThingTopoResponseBody) SetCode(v string) *BatchAddThingTopoResponseBody {
	s.Code = &v
	return s
}

func (s *BatchAddThingTopoResponseBody) SetErrorMessage(v string) *BatchAddThingTopoResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchAddThingTopoResponseBody) SetRequestId(v string) *BatchAddThingTopoResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchAddThingTopoResponseBody) SetSuccess(v bool) *BatchAddThingTopoResponseBody {
	s.Success = &v
	return s
}

type BatchAddThingTopoResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchAddThingTopoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchAddThingTopoResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchAddThingTopoResponse) GoString() string {
	return s.String()
}

func (s *BatchAddThingTopoResponse) SetHeaders(v map[string]*string) *BatchAddThingTopoResponse {
	s.Headers = v
	return s
}

func (s *BatchAddThingTopoResponse) SetStatusCode(v int32) *BatchAddThingTopoResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchAddThingTopoResponse) SetBody(v *BatchAddThingTopoResponseBody) *BatchAddThingTopoResponse {
	s.Body = v
	return s
}

type BatchBindDeviceToEdgeInstanceWithDriverRequest struct {
	// The IDs of the devices.
	//
	// You can call the [QueryDevice](~~69905~~) operation to query detailed information about all devices that belong to the current Alibaba Cloud account and obtain the required device IDs.
	//
	// >  You can specify a maximum of 20 device IDs when you call the BatchBindDeviceToEdgeInstanceWithDriver operation.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver that you want to configure and obtain the driver ID.
	//
	// You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
	InstanceId *string   `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotIds     []*string `json:"IotIds,omitempty" xml:"IotIds,omitempty" type:"Repeated"`
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance to which you want to bind multiple devices and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchBindDeviceToEdgeInstanceWithDriverRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchBindDeviceToEdgeInstanceWithDriverRequest) GoString() string {
	return s.String()
}

func (s *BatchBindDeviceToEdgeInstanceWithDriverRequest) SetDriverId(v string) *BatchBindDeviceToEdgeInstanceWithDriverRequest {
	s.DriverId = &v
	return s
}

func (s *BatchBindDeviceToEdgeInstanceWithDriverRequest) SetInstanceId(v string) *BatchBindDeviceToEdgeInstanceWithDriverRequest {
	s.InstanceId = &v
	return s
}

func (s *BatchBindDeviceToEdgeInstanceWithDriverRequest) SetIotIds(v []*string) *BatchBindDeviceToEdgeInstanceWithDriverRequest {
	s.IotIds = v
	return s
}

func (s *BatchBindDeviceToEdgeInstanceWithDriverRequest) SetIotInstanceId(v string) *BatchBindDeviceToEdgeInstanceWithDriverRequest {
	s.IotInstanceId = &v
	return s
}

type BatchBindDeviceToEdgeInstanceWithDriverResponseBody struct {
	// The error message that is returned if the call failed.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the request.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchBindDeviceToEdgeInstanceWithDriverResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchBindDeviceToEdgeInstanceWithDriverResponseBody) GoString() string {
	return s.String()
}

func (s *BatchBindDeviceToEdgeInstanceWithDriverResponseBody) SetCode(v string) *BatchBindDeviceToEdgeInstanceWithDriverResponseBody {
	s.Code = &v
	return s
}

func (s *BatchBindDeviceToEdgeInstanceWithDriverResponseBody) SetErrorMessage(v string) *BatchBindDeviceToEdgeInstanceWithDriverResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchBindDeviceToEdgeInstanceWithDriverResponseBody) SetRequestId(v string) *BatchBindDeviceToEdgeInstanceWithDriverResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchBindDeviceToEdgeInstanceWithDriverResponseBody) SetSuccess(v bool) *BatchBindDeviceToEdgeInstanceWithDriverResponseBody {
	s.Success = &v
	return s
}

type BatchBindDeviceToEdgeInstanceWithDriverResponse struct {
	Headers    map[string]*string                                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchBindDeviceToEdgeInstanceWithDriverResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchBindDeviceToEdgeInstanceWithDriverResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchBindDeviceToEdgeInstanceWithDriverResponse) GoString() string {
	return s.String()
}

func (s *BatchBindDeviceToEdgeInstanceWithDriverResponse) SetHeaders(v map[string]*string) *BatchBindDeviceToEdgeInstanceWithDriverResponse {
	s.Headers = v
	return s
}

func (s *BatchBindDeviceToEdgeInstanceWithDriverResponse) SetStatusCode(v int32) *BatchBindDeviceToEdgeInstanceWithDriverResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchBindDeviceToEdgeInstanceWithDriverResponse) SetBody(v *BatchBindDeviceToEdgeInstanceWithDriverResponseBody) *BatchBindDeviceToEdgeInstanceWithDriverResponse {
	s.Body = v
	return s
}

type BatchBindDevicesIntoProjectRequest struct {
	Devices       []*BatchBindDevicesIntoProjectRequestDevices `json:"Devices,omitempty" xml:"Devices,omitempty" type:"Repeated"`
	IotInstanceId *string                                      `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProjectId     *string                                      `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s BatchBindDevicesIntoProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchBindDevicesIntoProjectRequest) GoString() string {
	return s.String()
}

func (s *BatchBindDevicesIntoProjectRequest) SetDevices(v []*BatchBindDevicesIntoProjectRequestDevices) *BatchBindDevicesIntoProjectRequest {
	s.Devices = v
	return s
}

func (s *BatchBindDevicesIntoProjectRequest) SetIotInstanceId(v string) *BatchBindDevicesIntoProjectRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchBindDevicesIntoProjectRequest) SetProjectId(v string) *BatchBindDevicesIntoProjectRequest {
	s.ProjectId = &v
	return s
}

type BatchBindDevicesIntoProjectRequestDevices struct {
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BatchBindDevicesIntoProjectRequestDevices) String() string {
	return tea.Prettify(s)
}

func (s BatchBindDevicesIntoProjectRequestDevices) GoString() string {
	return s.String()
}

func (s *BatchBindDevicesIntoProjectRequestDevices) SetDeviceName(v string) *BatchBindDevicesIntoProjectRequestDevices {
	s.DeviceName = &v
	return s
}

func (s *BatchBindDevicesIntoProjectRequestDevices) SetProductKey(v string) *BatchBindDevicesIntoProjectRequestDevices {
	s.ProductKey = &v
	return s
}

type BatchBindDevicesIntoProjectResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchBindDevicesIntoProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchBindDevicesIntoProjectResponseBody) GoString() string {
	return s.String()
}

func (s *BatchBindDevicesIntoProjectResponseBody) SetCode(v string) *BatchBindDevicesIntoProjectResponseBody {
	s.Code = &v
	return s
}

func (s *BatchBindDevicesIntoProjectResponseBody) SetData(v bool) *BatchBindDevicesIntoProjectResponseBody {
	s.Data = &v
	return s
}

func (s *BatchBindDevicesIntoProjectResponseBody) SetErrorMessage(v string) *BatchBindDevicesIntoProjectResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchBindDevicesIntoProjectResponseBody) SetRequestId(v string) *BatchBindDevicesIntoProjectResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchBindDevicesIntoProjectResponseBody) SetSuccess(v bool) *BatchBindDevicesIntoProjectResponseBody {
	s.Success = &v
	return s
}

type BatchBindDevicesIntoProjectResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchBindDevicesIntoProjectResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchBindDevicesIntoProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchBindDevicesIntoProjectResponse) GoString() string {
	return s.String()
}

func (s *BatchBindDevicesIntoProjectResponse) SetHeaders(v map[string]*string) *BatchBindDevicesIntoProjectResponse {
	s.Headers = v
	return s
}

func (s *BatchBindDevicesIntoProjectResponse) SetStatusCode(v int32) *BatchBindDevicesIntoProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchBindDevicesIntoProjectResponse) SetBody(v *BatchBindDevicesIntoProjectResponseBody) *BatchBindDevicesIntoProjectResponse {
	s.Body = v
	return s
}

type BatchBindProductsIntoProjectRequest struct {
	IotInstanceId *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKeys   []*string `json:"ProductKeys,omitempty" xml:"ProductKeys,omitempty" type:"Repeated"`
	ProjectId     *string   `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s BatchBindProductsIntoProjectRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchBindProductsIntoProjectRequest) GoString() string {
	return s.String()
}

func (s *BatchBindProductsIntoProjectRequest) SetIotInstanceId(v string) *BatchBindProductsIntoProjectRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchBindProductsIntoProjectRequest) SetProductKeys(v []*string) *BatchBindProductsIntoProjectRequest {
	s.ProductKeys = v
	return s
}

func (s *BatchBindProductsIntoProjectRequest) SetProjectId(v string) *BatchBindProductsIntoProjectRequest {
	s.ProjectId = &v
	return s
}

type BatchBindProductsIntoProjectResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchBindProductsIntoProjectResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchBindProductsIntoProjectResponseBody) GoString() string {
	return s.String()
}

func (s *BatchBindProductsIntoProjectResponseBody) SetCode(v string) *BatchBindProductsIntoProjectResponseBody {
	s.Code = &v
	return s
}

func (s *BatchBindProductsIntoProjectResponseBody) SetData(v bool) *BatchBindProductsIntoProjectResponseBody {
	s.Data = &v
	return s
}

func (s *BatchBindProductsIntoProjectResponseBody) SetErrorMessage(v string) *BatchBindProductsIntoProjectResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchBindProductsIntoProjectResponseBody) SetRequestId(v string) *BatchBindProductsIntoProjectResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchBindProductsIntoProjectResponseBody) SetSuccess(v bool) *BatchBindProductsIntoProjectResponseBody {
	s.Success = &v
	return s
}

type BatchBindProductsIntoProjectResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchBindProductsIntoProjectResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchBindProductsIntoProjectResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchBindProductsIntoProjectResponse) GoString() string {
	return s.String()
}

func (s *BatchBindProductsIntoProjectResponse) SetHeaders(v map[string]*string) *BatchBindProductsIntoProjectResponse {
	s.Headers = v
	return s
}

func (s *BatchBindProductsIntoProjectResponse) SetStatusCode(v int32) *BatchBindProductsIntoProjectResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchBindProductsIntoProjectResponse) SetBody(v *BatchBindProductsIntoProjectResponseBody) *BatchBindProductsIntoProjectResponse {
	s.Body = v
	return s
}

type BatchCheckDeviceNamesRequest struct {
	DeviceName     []*string                                     `json:"DeviceName,omitempty" xml:"DeviceName,omitempty" type:"Repeated"`
	DeviceNameList []*BatchCheckDeviceNamesRequestDeviceNameList `json:"DeviceNameList,omitempty" xml:"DeviceNameList,omitempty" type:"Repeated"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the devices belong.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BatchCheckDeviceNamesRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckDeviceNamesRequest) GoString() string {
	return s.String()
}

func (s *BatchCheckDeviceNamesRequest) SetDeviceName(v []*string) *BatchCheckDeviceNamesRequest {
	s.DeviceName = v
	return s
}

func (s *BatchCheckDeviceNamesRequest) SetDeviceNameList(v []*BatchCheckDeviceNamesRequestDeviceNameList) *BatchCheckDeviceNamesRequest {
	s.DeviceNameList = v
	return s
}

func (s *BatchCheckDeviceNamesRequest) SetIotInstanceId(v string) *BatchCheckDeviceNamesRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchCheckDeviceNamesRequest) SetProductKey(v string) *BatchCheckDeviceNamesRequest {
	s.ProductKey = &v
	return s
}

type BatchCheckDeviceNamesRequestDeviceNameList struct {
	DeviceName     *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	DeviceNickname *string `json:"DeviceNickname,omitempty" xml:"DeviceNickname,omitempty"`
}

func (s BatchCheckDeviceNamesRequestDeviceNameList) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckDeviceNamesRequestDeviceNameList) GoString() string {
	return s.String()
}

func (s *BatchCheckDeviceNamesRequestDeviceNameList) SetDeviceName(v string) *BatchCheckDeviceNamesRequestDeviceNameList {
	s.DeviceName = &v
	return s
}

func (s *BatchCheckDeviceNamesRequestDeviceNameList) SetDeviceNickname(v string) *BatchCheckDeviceNamesRequestDeviceNameList {
	s.DeviceNickname = &v
	return s
}

type BatchCheckDeviceNamesResponseBody struct {
	// The returned data.
	Code *string                                `json:"Code,omitempty" xml:"Code,omitempty"`
	Data *BatchCheckDeviceNamesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The application ID (ApplyId) returned if the call is successful. When you call the [BatchRegisterDeviceWithApplyId](~~69514~~) operation to register the devices, this parameter is required.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The list of invalid device aliases returned if the call fails.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The list of invalid DeviceNames returned if the call fails.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchCheckDeviceNamesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckDeviceNamesResponseBody) GoString() string {
	return s.String()
}

func (s *BatchCheckDeviceNamesResponseBody) SetCode(v string) *BatchCheckDeviceNamesResponseBody {
	s.Code = &v
	return s
}

func (s *BatchCheckDeviceNamesResponseBody) SetData(v *BatchCheckDeviceNamesResponseBodyData) *BatchCheckDeviceNamesResponseBody {
	s.Data = v
	return s
}

func (s *BatchCheckDeviceNamesResponseBody) SetErrorMessage(v string) *BatchCheckDeviceNamesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchCheckDeviceNamesResponseBody) SetRequestId(v string) *BatchCheckDeviceNamesResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchCheckDeviceNamesResponseBody) SetSuccess(v bool) *BatchCheckDeviceNamesResponseBody {
	s.Success = &v
	return s
}

type BatchCheckDeviceNamesResponseBodyData struct {
	ApplyId                   *int64                                                          `json:"ApplyId,omitempty" xml:"ApplyId,omitempty"`
	InvalidDetailList         *BatchCheckDeviceNamesResponseBodyDataInvalidDetailList         `json:"InvalidDetailList,omitempty" xml:"InvalidDetailList,omitempty" type:"Struct"`
	InvalidDeviceNameList     *BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList     `json:"InvalidDeviceNameList,omitempty" xml:"InvalidDeviceNameList,omitempty" type:"Struct"`
	InvalidDeviceNicknameList *BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList `json:"InvalidDeviceNicknameList,omitempty" xml:"InvalidDeviceNicknameList,omitempty" type:"Struct"`
	RepeatedDeviceNameList    *BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList    `json:"RepeatedDeviceNameList,omitempty" xml:"RepeatedDeviceNameList,omitempty" type:"Struct"`
}

func (s BatchCheckDeviceNamesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckDeviceNamesResponseBodyData) GoString() string {
	return s.String()
}

func (s *BatchCheckDeviceNamesResponseBodyData) SetApplyId(v int64) *BatchCheckDeviceNamesResponseBodyData {
	s.ApplyId = &v
	return s
}

func (s *BatchCheckDeviceNamesResponseBodyData) SetInvalidDetailList(v *BatchCheckDeviceNamesResponseBodyDataInvalidDetailList) *BatchCheckDeviceNamesResponseBodyData {
	s.InvalidDetailList = v
	return s
}

func (s *BatchCheckDeviceNamesResponseBodyData) SetInvalidDeviceNameList(v *BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList) *BatchCheckDeviceNamesResponseBodyData {
	s.InvalidDeviceNameList = v
	return s
}

func (s *BatchCheckDeviceNamesResponseBodyData) SetInvalidDeviceNicknameList(v *BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList) *BatchCheckDeviceNamesResponseBodyData {
	s.InvalidDeviceNicknameList = v
	return s
}

func (s *BatchCheckDeviceNamesResponseBodyData) SetRepeatedDeviceNameList(v *BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList) *BatchCheckDeviceNamesResponseBodyData {
	s.RepeatedDeviceNameList = v
	return s
}

type BatchCheckDeviceNamesResponseBodyDataInvalidDetailList struct {
	InvalidDetailList []*BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList `json:"InvalidDetailList,omitempty" xml:"InvalidDetailList,omitempty" type:"Repeated"`
}

func (s BatchCheckDeviceNamesResponseBodyDataInvalidDetailList) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckDeviceNamesResponseBodyDataInvalidDetailList) GoString() string {
	return s.String()
}

func (s *BatchCheckDeviceNamesResponseBodyDataInvalidDetailList) SetInvalidDetailList(v []*BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList) *BatchCheckDeviceNamesResponseBodyDataInvalidDetailList {
	s.InvalidDetailList = v
	return s
}

type BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList struct {
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	ErrorMsg   *string `json:"ErrorMsg,omitempty" xml:"ErrorMsg,omitempty"`
	NickName   *string `json:"NickName,omitempty" xml:"NickName,omitempty"`
}

func (s BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList) GoString() string {
	return s.String()
}

func (s *BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList) SetDeviceName(v string) *BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList {
	s.DeviceName = &v
	return s
}

func (s *BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList) SetErrorMsg(v string) *BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList {
	s.ErrorMsg = &v
	return s
}

func (s *BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList) SetNickName(v string) *BatchCheckDeviceNamesResponseBodyDataInvalidDetailListInvalidDetailList {
	s.NickName = &v
	return s
}

type BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList struct {
	InvalidDeviceName []*string `json:"InvalidDeviceName,omitempty" xml:"InvalidDeviceName,omitempty" type:"Repeated"`
}

func (s BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList) GoString() string {
	return s.String()
}

func (s *BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList) SetInvalidDeviceName(v []*string) *BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNameList {
	s.InvalidDeviceName = v
	return s
}

type BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList struct {
	InvalidDeviceNickname []*string `json:"InvalidDeviceNickname,omitempty" xml:"InvalidDeviceNickname,omitempty" type:"Repeated"`
}

func (s BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList) GoString() string {
	return s.String()
}

func (s *BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList) SetInvalidDeviceNickname(v []*string) *BatchCheckDeviceNamesResponseBodyDataInvalidDeviceNicknameList {
	s.InvalidDeviceNickname = v
	return s
}

type BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList struct {
	RepeatDevieNameList []*string `json:"RepeatDevieNameList,omitempty" xml:"RepeatDevieNameList,omitempty" type:"Repeated"`
}

func (s BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList) GoString() string {
	return s.String()
}

func (s *BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList) SetRepeatDevieNameList(v []*string) *BatchCheckDeviceNamesResponseBodyDataRepeatedDeviceNameList {
	s.RepeatDevieNameList = v
	return s
}

type BatchCheckDeviceNamesResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchCheckDeviceNamesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchCheckDeviceNamesResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckDeviceNamesResponse) GoString() string {
	return s.String()
}

func (s *BatchCheckDeviceNamesResponse) SetHeaders(v map[string]*string) *BatchCheckDeviceNamesResponse {
	s.Headers = v
	return s
}

func (s *BatchCheckDeviceNamesResponse) SetStatusCode(v int32) *BatchCheckDeviceNamesResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchCheckDeviceNamesResponse) SetBody(v *BatchCheckDeviceNamesResponseBody) *BatchCheckDeviceNamesResponse {
	s.Body = v
	return s
}

type BatchCheckImportDeviceRequest struct {
	DeviceList []*BatchCheckImportDeviceRequestDeviceList `json:"DeviceList,omitempty" xml:"DeviceList,omitempty" type:"Repeated"`
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
	//
	// For more information, see the [Overview](~~356505~~) topic of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the gateway product to which the devices belong.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BatchCheckImportDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckImportDeviceRequest) GoString() string {
	return s.String()
}

func (s *BatchCheckImportDeviceRequest) SetDeviceList(v []*BatchCheckImportDeviceRequestDeviceList) *BatchCheckImportDeviceRequest {
	s.DeviceList = v
	return s
}

func (s *BatchCheckImportDeviceRequest) SetIotInstanceId(v string) *BatchCheckImportDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchCheckImportDeviceRequest) SetProductKey(v string) *BatchCheckImportDeviceRequest {
	s.ProductKey = &v
	return s
}

type BatchCheckImportDeviceRequestDeviceList struct {
	DeviceName   *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	DeviceSecret *string `json:"DeviceSecret,omitempty" xml:"DeviceSecret,omitempty"`
	Sn           *string `json:"Sn,omitempty" xml:"Sn,omitempty"`
}

func (s BatchCheckImportDeviceRequestDeviceList) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckImportDeviceRequestDeviceList) GoString() string {
	return s.String()
}

func (s *BatchCheckImportDeviceRequestDeviceList) SetDeviceName(v string) *BatchCheckImportDeviceRequestDeviceList {
	s.DeviceName = &v
	return s
}

func (s *BatchCheckImportDeviceRequestDeviceList) SetDeviceSecret(v string) *BatchCheckImportDeviceRequestDeviceList {
	s.DeviceSecret = &v
	return s
}

func (s *BatchCheckImportDeviceRequestDeviceList) SetSn(v string) *BatchCheckImportDeviceRequestDeviceList {
	s.Sn = &v
	return s
}

type BatchCheckImportDeviceResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the request succeeds. The data includes the information about devices that failed to be verified.
	Data *BatchCheckImportDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchCheckImportDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckImportDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *BatchCheckImportDeviceResponseBody) SetCode(v string) *BatchCheckImportDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *BatchCheckImportDeviceResponseBody) SetData(v *BatchCheckImportDeviceResponseBodyData) *BatchCheckImportDeviceResponseBody {
	s.Data = v
	return s
}

func (s *BatchCheckImportDeviceResponseBody) SetErrorMessage(v string) *BatchCheckImportDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchCheckImportDeviceResponseBody) SetRequestId(v string) *BatchCheckImportDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchCheckImportDeviceResponseBody) SetSuccess(v bool) *BatchCheckImportDeviceResponseBody {
	s.Success = &v
	return s
}

type BatchCheckImportDeviceResponseBodyData struct {
	InvalidDetailList       []*BatchCheckImportDeviceResponseBodyDataInvalidDetailList `json:"InvalidDetailList,omitempty" xml:"InvalidDetailList,omitempty" type:"Repeated"`
	InvalidDeviceNameList   []*string                                                  `json:"InvalidDeviceNameList,omitempty" xml:"InvalidDeviceNameList,omitempty" type:"Repeated"`
	InvalidDeviceSecretList []*string                                                  `json:"InvalidDeviceSecretList,omitempty" xml:"InvalidDeviceSecretList,omitempty" type:"Repeated"`
	InvalidSnList           []*string                                                  `json:"InvalidSnList,omitempty" xml:"InvalidSnList,omitempty" type:"Repeated"`
	RepeatedDeviceNameList  []*string                                                  `json:"RepeatedDeviceNameList,omitempty" xml:"RepeatedDeviceNameList,omitempty" type:"Repeated"`
}

func (s BatchCheckImportDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckImportDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *BatchCheckImportDeviceResponseBodyData) SetInvalidDetailList(v []*BatchCheckImportDeviceResponseBodyDataInvalidDetailList) *BatchCheckImportDeviceResponseBodyData {
	s.InvalidDetailList = v
	return s
}

func (s *BatchCheckImportDeviceResponseBodyData) SetInvalidDeviceNameList(v []*string) *BatchCheckImportDeviceResponseBodyData {
	s.InvalidDeviceNameList = v
	return s
}

func (s *BatchCheckImportDeviceResponseBodyData) SetInvalidDeviceSecretList(v []*string) *BatchCheckImportDeviceResponseBodyData {
	s.InvalidDeviceSecretList = v
	return s
}

func (s *BatchCheckImportDeviceResponseBodyData) SetInvalidSnList(v []*string) *BatchCheckImportDeviceResponseBodyData {
	s.InvalidSnList = v
	return s
}

func (s *BatchCheckImportDeviceResponseBodyData) SetRepeatedDeviceNameList(v []*string) *BatchCheckImportDeviceResponseBodyData {
	s.RepeatedDeviceNameList = v
	return s
}

type BatchCheckImportDeviceResponseBodyDataInvalidDetailList struct {
	DeviceName   *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	DeviceSecret *string `json:"DeviceSecret,omitempty" xml:"DeviceSecret,omitempty"`
	ErrorMsg     *string `json:"ErrorMsg,omitempty" xml:"ErrorMsg,omitempty"`
	Sn           *string `json:"Sn,omitempty" xml:"Sn,omitempty"`
}

func (s BatchCheckImportDeviceResponseBodyDataInvalidDetailList) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckImportDeviceResponseBodyDataInvalidDetailList) GoString() string {
	return s.String()
}

func (s *BatchCheckImportDeviceResponseBodyDataInvalidDetailList) SetDeviceName(v string) *BatchCheckImportDeviceResponseBodyDataInvalidDetailList {
	s.DeviceName = &v
	return s
}

func (s *BatchCheckImportDeviceResponseBodyDataInvalidDetailList) SetDeviceSecret(v string) *BatchCheckImportDeviceResponseBodyDataInvalidDetailList {
	s.DeviceSecret = &v
	return s
}

func (s *BatchCheckImportDeviceResponseBodyDataInvalidDetailList) SetErrorMsg(v string) *BatchCheckImportDeviceResponseBodyDataInvalidDetailList {
	s.ErrorMsg = &v
	return s
}

func (s *BatchCheckImportDeviceResponseBodyDataInvalidDetailList) SetSn(v string) *BatchCheckImportDeviceResponseBodyDataInvalidDetailList {
	s.Sn = &v
	return s
}

type BatchCheckImportDeviceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchCheckImportDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchCheckImportDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckImportDeviceResponse) GoString() string {
	return s.String()
}

func (s *BatchCheckImportDeviceResponse) SetHeaders(v map[string]*string) *BatchCheckImportDeviceResponse {
	s.Headers = v
	return s
}

func (s *BatchCheckImportDeviceResponse) SetStatusCode(v int32) *BatchCheckImportDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchCheckImportDeviceResponse) SetBody(v *BatchCheckImportDeviceResponseBody) *BatchCheckImportDeviceResponse {
	s.Body = v
	return s
}

type BatchCheckVehicleDeviceRequest struct {
	DeviceList []*BatchCheckVehicleDeviceRequestDeviceList `json:"DeviceList,omitempty" xml:"DeviceList,omitempty" type:"Repeated"`
	// BatchCheckVehicleDevice
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BatchCheckVehicleDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckVehicleDeviceRequest) GoString() string {
	return s.String()
}

func (s *BatchCheckVehicleDeviceRequest) SetDeviceList(v []*BatchCheckVehicleDeviceRequestDeviceList) *BatchCheckVehicleDeviceRequest {
	s.DeviceList = v
	return s
}

func (s *BatchCheckVehicleDeviceRequest) SetIotInstanceId(v string) *BatchCheckVehicleDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchCheckVehicleDeviceRequest) SetProductKey(v string) *BatchCheckVehicleDeviceRequest {
	s.ProductKey = &v
	return s
}

type BatchCheckVehicleDeviceRequestDeviceList struct {
	DeviceId     *string `json:"DeviceId,omitempty" xml:"DeviceId,omitempty"`
	DeviceModel  *string `json:"DeviceModel,omitempty" xml:"DeviceModel,omitempty"`
	DeviceName   *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	Manufacturer *string `json:"Manufacturer,omitempty" xml:"Manufacturer,omitempty"`
}

func (s BatchCheckVehicleDeviceRequestDeviceList) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckVehicleDeviceRequestDeviceList) GoString() string {
	return s.String()
}

func (s *BatchCheckVehicleDeviceRequestDeviceList) SetDeviceId(v string) *BatchCheckVehicleDeviceRequestDeviceList {
	s.DeviceId = &v
	return s
}

func (s *BatchCheckVehicleDeviceRequestDeviceList) SetDeviceModel(v string) *BatchCheckVehicleDeviceRequestDeviceList {
	s.DeviceModel = &v
	return s
}

func (s *BatchCheckVehicleDeviceRequestDeviceList) SetDeviceName(v string) *BatchCheckVehicleDeviceRequestDeviceList {
	s.DeviceName = &v
	return s
}

func (s *BatchCheckVehicleDeviceRequestDeviceList) SetManufacturer(v string) *BatchCheckVehicleDeviceRequestDeviceList {
	s.Manufacturer = &v
	return s
}

type BatchCheckVehicleDeviceResponseBody struct {
	Code         *string                                  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *BatchCheckVehicleDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                  `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                    `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchCheckVehicleDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckVehicleDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *BatchCheckVehicleDeviceResponseBody) SetCode(v string) *BatchCheckVehicleDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *BatchCheckVehicleDeviceResponseBody) SetData(v *BatchCheckVehicleDeviceResponseBodyData) *BatchCheckVehicleDeviceResponseBody {
	s.Data = v
	return s
}

func (s *BatchCheckVehicleDeviceResponseBody) SetErrorMessage(v string) *BatchCheckVehicleDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchCheckVehicleDeviceResponseBody) SetRequestId(v string) *BatchCheckVehicleDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchCheckVehicleDeviceResponseBody) SetSuccess(v bool) *BatchCheckVehicleDeviceResponseBody {
	s.Success = &v
	return s
}

type BatchCheckVehicleDeviceResponseBodyData struct {
	InvalidDetailList       []*BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList `json:"InvalidDetailList,omitempty" xml:"InvalidDetailList,omitempty" type:"Repeated"`
	InvalidDeviceIdList     []*string                                                   `json:"InvalidDeviceIdList,omitempty" xml:"InvalidDeviceIdList,omitempty" type:"Repeated"`
	InvalidDeviceModelList  []*string                                                   `json:"InvalidDeviceModelList,omitempty" xml:"InvalidDeviceModelList,omitempty" type:"Repeated"`
	InvalidDeviceNameList   []*string                                                   `json:"InvalidDeviceNameList,omitempty" xml:"InvalidDeviceNameList,omitempty" type:"Repeated"`
	InvalidManufacturerList []*string                                                   `json:"InvalidManufacturerList,omitempty" xml:"InvalidManufacturerList,omitempty" type:"Repeated"`
	RepeatedDeviceIdList    []*string                                                   `json:"RepeatedDeviceIdList,omitempty" xml:"RepeatedDeviceIdList,omitempty" type:"Repeated"`
	RepeatedDeviceNameList  []*string                                                   `json:"RepeatedDeviceNameList,omitempty" xml:"RepeatedDeviceNameList,omitempty" type:"Repeated"`
}

func (s BatchCheckVehicleDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckVehicleDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *BatchCheckVehicleDeviceResponseBodyData) SetInvalidDetailList(v []*BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList) *BatchCheckVehicleDeviceResponseBodyData {
	s.InvalidDetailList = v
	return s
}

func (s *BatchCheckVehicleDeviceResponseBodyData) SetInvalidDeviceIdList(v []*string) *BatchCheckVehicleDeviceResponseBodyData {
	s.InvalidDeviceIdList = v
	return s
}

func (s *BatchCheckVehicleDeviceResponseBodyData) SetInvalidDeviceModelList(v []*string) *BatchCheckVehicleDeviceResponseBodyData {
	s.InvalidDeviceModelList = v
	return s
}

func (s *BatchCheckVehicleDeviceResponseBodyData) SetInvalidDeviceNameList(v []*string) *BatchCheckVehicleDeviceResponseBodyData {
	s.InvalidDeviceNameList = v
	return s
}

func (s *BatchCheckVehicleDeviceResponseBodyData) SetInvalidManufacturerList(v []*string) *BatchCheckVehicleDeviceResponseBodyData {
	s.InvalidManufacturerList = v
	return s
}

func (s *BatchCheckVehicleDeviceResponseBodyData) SetRepeatedDeviceIdList(v []*string) *BatchCheckVehicleDeviceResponseBodyData {
	s.RepeatedDeviceIdList = v
	return s
}

func (s *BatchCheckVehicleDeviceResponseBodyData) SetRepeatedDeviceNameList(v []*string) *BatchCheckVehicleDeviceResponseBodyData {
	s.RepeatedDeviceNameList = v
	return s
}

type BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList struct {
	DeviceId     *string `json:"DeviceId,omitempty" xml:"DeviceId,omitempty"`
	DeviceModel  *string `json:"DeviceModel,omitempty" xml:"DeviceModel,omitempty"`
	DeviceName   *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	ErrorMsg     *string `json:"ErrorMsg,omitempty" xml:"ErrorMsg,omitempty"`
	Manufacturer *string `json:"Manufacturer,omitempty" xml:"Manufacturer,omitempty"`
}

func (s BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList) GoString() string {
	return s.String()
}

func (s *BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList) SetDeviceId(v string) *BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList {
	s.DeviceId = &v
	return s
}

func (s *BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList) SetDeviceModel(v string) *BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList {
	s.DeviceModel = &v
	return s
}

func (s *BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList) SetDeviceName(v string) *BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList {
	s.DeviceName = &v
	return s
}

func (s *BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList) SetErrorMsg(v string) *BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList {
	s.ErrorMsg = &v
	return s
}

func (s *BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList) SetManufacturer(v string) *BatchCheckVehicleDeviceResponseBodyDataInvalidDetailList {
	s.Manufacturer = &v
	return s
}

type BatchCheckVehicleDeviceResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchCheckVehicleDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchCheckVehicleDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchCheckVehicleDeviceResponse) GoString() string {
	return s.String()
}

func (s *BatchCheckVehicleDeviceResponse) SetHeaders(v map[string]*string) *BatchCheckVehicleDeviceResponse {
	s.Headers = v
	return s
}

func (s *BatchCheckVehicleDeviceResponse) SetStatusCode(v int32) *BatchCheckVehicleDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchCheckVehicleDeviceResponse) SetBody(v *BatchCheckVehicleDeviceResponseBody) *BatchCheckVehicleDeviceResponse {
	s.Body = v
	return s
}

type BatchClearEdgeInstanceDeviceConfigRequest struct {
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to manage and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string   `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotIds     []*string `json:"IotIds,omitempty" xml:"IotIds,omitempty" type:"Repeated"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchClearEdgeInstanceDeviceConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchClearEdgeInstanceDeviceConfigRequest) GoString() string {
	return s.String()
}

func (s *BatchClearEdgeInstanceDeviceConfigRequest) SetInstanceId(v string) *BatchClearEdgeInstanceDeviceConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *BatchClearEdgeInstanceDeviceConfigRequest) SetIotIds(v []*string) *BatchClearEdgeInstanceDeviceConfigRequest {
	s.IotIds = v
	return s
}

func (s *BatchClearEdgeInstanceDeviceConfigRequest) SetIotInstanceId(v string) *BatchClearEdgeInstanceDeviceConfigRequest {
	s.IotInstanceId = &v
	return s
}

type BatchClearEdgeInstanceDeviceConfigResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchClearEdgeInstanceDeviceConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchClearEdgeInstanceDeviceConfigResponseBody) GoString() string {
	return s.String()
}

func (s *BatchClearEdgeInstanceDeviceConfigResponseBody) SetCode(v string) *BatchClearEdgeInstanceDeviceConfigResponseBody {
	s.Code = &v
	return s
}

func (s *BatchClearEdgeInstanceDeviceConfigResponseBody) SetErrorMessage(v string) *BatchClearEdgeInstanceDeviceConfigResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchClearEdgeInstanceDeviceConfigResponseBody) SetRequestId(v string) *BatchClearEdgeInstanceDeviceConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchClearEdgeInstanceDeviceConfigResponseBody) SetSuccess(v bool) *BatchClearEdgeInstanceDeviceConfigResponseBody {
	s.Success = &v
	return s
}

type BatchClearEdgeInstanceDeviceConfigResponse struct {
	Headers    map[string]*string                              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchClearEdgeInstanceDeviceConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchClearEdgeInstanceDeviceConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchClearEdgeInstanceDeviceConfigResponse) GoString() string {
	return s.String()
}

func (s *BatchClearEdgeInstanceDeviceConfigResponse) SetHeaders(v map[string]*string) *BatchClearEdgeInstanceDeviceConfigResponse {
	s.Headers = v
	return s
}

func (s *BatchClearEdgeInstanceDeviceConfigResponse) SetStatusCode(v int32) *BatchClearEdgeInstanceDeviceConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchClearEdgeInstanceDeviceConfigResponse) SetBody(v *BatchClearEdgeInstanceDeviceConfigResponseBody) *BatchClearEdgeInstanceDeviceConfigResponse {
	s.Body = v
	return s
}

type BatchCreateSoundCodeLabelRequest struct {
	Description   *string `json:"Description,omitempty" xml:"Description,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ScheduleCode  *string `json:"ScheduleCode,omitempty" xml:"ScheduleCode,omitempty"`
	Total         *int32  `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s BatchCreateSoundCodeLabelRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchCreateSoundCodeLabelRequest) GoString() string {
	return s.String()
}

func (s *BatchCreateSoundCodeLabelRequest) SetDescription(v string) *BatchCreateSoundCodeLabelRequest {
	s.Description = &v
	return s
}

func (s *BatchCreateSoundCodeLabelRequest) SetIotInstanceId(v string) *BatchCreateSoundCodeLabelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchCreateSoundCodeLabelRequest) SetScheduleCode(v string) *BatchCreateSoundCodeLabelRequest {
	s.ScheduleCode = &v
	return s
}

func (s *BatchCreateSoundCodeLabelRequest) SetTotal(v int32) *BatchCreateSoundCodeLabelRequest {
	s.Total = &v
	return s
}

type BatchCreateSoundCodeLabelResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchCreateSoundCodeLabelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchCreateSoundCodeLabelResponseBody) GoString() string {
	return s.String()
}

func (s *BatchCreateSoundCodeLabelResponseBody) SetCode(v string) *BatchCreateSoundCodeLabelResponseBody {
	s.Code = &v
	return s
}

func (s *BatchCreateSoundCodeLabelResponseBody) SetData(v string) *BatchCreateSoundCodeLabelResponseBody {
	s.Data = &v
	return s
}

func (s *BatchCreateSoundCodeLabelResponseBody) SetErrorMessage(v string) *BatchCreateSoundCodeLabelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchCreateSoundCodeLabelResponseBody) SetRequestId(v string) *BatchCreateSoundCodeLabelResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchCreateSoundCodeLabelResponseBody) SetSuccess(v bool) *BatchCreateSoundCodeLabelResponseBody {
	s.Success = &v
	return s
}

type BatchCreateSoundCodeLabelResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchCreateSoundCodeLabelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchCreateSoundCodeLabelResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchCreateSoundCodeLabelResponse) GoString() string {
	return s.String()
}

func (s *BatchCreateSoundCodeLabelResponse) SetHeaders(v map[string]*string) *BatchCreateSoundCodeLabelResponse {
	s.Headers = v
	return s
}

func (s *BatchCreateSoundCodeLabelResponse) SetStatusCode(v int32) *BatchCreateSoundCodeLabelResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchCreateSoundCodeLabelResponse) SetBody(v *BatchCreateSoundCodeLabelResponseBody) *BatchCreateSoundCodeLabelResponse {
	s.Body = v
	return s
}

type BatchCreateSoundCodeLabelWithLabelsRequest struct {
	Description   *string   `json:"Description,omitempty" xml:"Description,omitempty"`
	IotInstanceId *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Labels        []*string `json:"Labels,omitempty" xml:"Labels,omitempty" type:"Repeated"`
	ScheduleCode  *string   `json:"ScheduleCode,omitempty" xml:"ScheduleCode,omitempty"`
}

func (s BatchCreateSoundCodeLabelWithLabelsRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchCreateSoundCodeLabelWithLabelsRequest) GoString() string {
	return s.String()
}

func (s *BatchCreateSoundCodeLabelWithLabelsRequest) SetDescription(v string) *BatchCreateSoundCodeLabelWithLabelsRequest {
	s.Description = &v
	return s
}

func (s *BatchCreateSoundCodeLabelWithLabelsRequest) SetIotInstanceId(v string) *BatchCreateSoundCodeLabelWithLabelsRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchCreateSoundCodeLabelWithLabelsRequest) SetLabels(v []*string) *BatchCreateSoundCodeLabelWithLabelsRequest {
	s.Labels = v
	return s
}

func (s *BatchCreateSoundCodeLabelWithLabelsRequest) SetScheduleCode(v string) *BatchCreateSoundCodeLabelWithLabelsRequest {
	s.ScheduleCode = &v
	return s
}

type BatchCreateSoundCodeLabelWithLabelsResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchCreateSoundCodeLabelWithLabelsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchCreateSoundCodeLabelWithLabelsResponseBody) GoString() string {
	return s.String()
}

func (s *BatchCreateSoundCodeLabelWithLabelsResponseBody) SetCode(v string) *BatchCreateSoundCodeLabelWithLabelsResponseBody {
	s.Code = &v
	return s
}

func (s *BatchCreateSoundCodeLabelWithLabelsResponseBody) SetData(v string) *BatchCreateSoundCodeLabelWithLabelsResponseBody {
	s.Data = &v
	return s
}

func (s *BatchCreateSoundCodeLabelWithLabelsResponseBody) SetErrorMessage(v string) *BatchCreateSoundCodeLabelWithLabelsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchCreateSoundCodeLabelWithLabelsResponseBody) SetRequestId(v string) *BatchCreateSoundCodeLabelWithLabelsResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchCreateSoundCodeLabelWithLabelsResponseBody) SetSuccess(v bool) *BatchCreateSoundCodeLabelWithLabelsResponseBody {
	s.Success = &v
	return s
}

type BatchCreateSoundCodeLabelWithLabelsResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchCreateSoundCodeLabelWithLabelsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchCreateSoundCodeLabelWithLabelsResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchCreateSoundCodeLabelWithLabelsResponse) GoString() string {
	return s.String()
}

func (s *BatchCreateSoundCodeLabelWithLabelsResponse) SetHeaders(v map[string]*string) *BatchCreateSoundCodeLabelWithLabelsResponse {
	s.Headers = v
	return s
}

func (s *BatchCreateSoundCodeLabelWithLabelsResponse) SetStatusCode(v int32) *BatchCreateSoundCodeLabelWithLabelsResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchCreateSoundCodeLabelWithLabelsResponse) SetBody(v *BatchCreateSoundCodeLabelWithLabelsResponseBody) *BatchCreateSoundCodeLabelWithLabelsResponse {
	s.Body = v
	return s
}

type BatchDeleteDeviceGroupRelationsRequest struct {
	Device []*BatchDeleteDeviceGroupRelationsRequestDevice `json:"Device,omitempty" xml:"Device,omitempty" type:"Repeated"`
	// The ID of the group. The ID is the globally unique identifier (GUID) for the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchDeleteDeviceGroupRelationsRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteDeviceGroupRelationsRequest) GoString() string {
	return s.String()
}

func (s *BatchDeleteDeviceGroupRelationsRequest) SetDevice(v []*BatchDeleteDeviceGroupRelationsRequestDevice) *BatchDeleteDeviceGroupRelationsRequest {
	s.Device = v
	return s
}

func (s *BatchDeleteDeviceGroupRelationsRequest) SetGroupId(v string) *BatchDeleteDeviceGroupRelationsRequest {
	s.GroupId = &v
	return s
}

func (s *BatchDeleteDeviceGroupRelationsRequest) SetIotInstanceId(v string) *BatchDeleteDeviceGroupRelationsRequest {
	s.IotInstanceId = &v
	return s
}

type BatchDeleteDeviceGroupRelationsRequestDevice struct {
	// The names of the devices to be removed. You can specify a maximum of 200 devices.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ProductKeys of the products to which the devices belong. You can specify a maximum of 200 ProductKeys.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BatchDeleteDeviceGroupRelationsRequestDevice) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteDeviceGroupRelationsRequestDevice) GoString() string {
	return s.String()
}

func (s *BatchDeleteDeviceGroupRelationsRequestDevice) SetDeviceName(v string) *BatchDeleteDeviceGroupRelationsRequestDevice {
	s.DeviceName = &v
	return s
}

func (s *BatchDeleteDeviceGroupRelationsRequestDevice) SetProductKey(v string) *BatchDeleteDeviceGroupRelationsRequestDevice {
	s.ProductKey = &v
	return s
}

type BatchDeleteDeviceGroupRelationsResponseBody struct {
	// The number of devices that exist in the group.
	AlreadyRelatedGroupDeviceCount *int32 `json:"AlreadyRelatedGroupDeviceCount,omitempty" xml:"AlreadyRelatedGroupDeviceCount,omitempty"`
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The number of devices that are removed from the group.
	SuccessDeviceCount *int32 `json:"SuccessDeviceCount,omitempty" xml:"SuccessDeviceCount,omitempty"`
	// The number of valid devices that you specified.
	ValidDeviceCount *int32 `json:"ValidDeviceCount,omitempty" xml:"ValidDeviceCount,omitempty"`
}

func (s BatchDeleteDeviceGroupRelationsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteDeviceGroupRelationsResponseBody) GoString() string {
	return s.String()
}

func (s *BatchDeleteDeviceGroupRelationsResponseBody) SetAlreadyRelatedGroupDeviceCount(v int32) *BatchDeleteDeviceGroupRelationsResponseBody {
	s.AlreadyRelatedGroupDeviceCount = &v
	return s
}

func (s *BatchDeleteDeviceGroupRelationsResponseBody) SetCode(v string) *BatchDeleteDeviceGroupRelationsResponseBody {
	s.Code = &v
	return s
}

func (s *BatchDeleteDeviceGroupRelationsResponseBody) SetErrorMessage(v string) *BatchDeleteDeviceGroupRelationsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchDeleteDeviceGroupRelationsResponseBody) SetRequestId(v string) *BatchDeleteDeviceGroupRelationsResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchDeleteDeviceGroupRelationsResponseBody) SetSuccess(v bool) *BatchDeleteDeviceGroupRelationsResponseBody {
	s.Success = &v
	return s
}

func (s *BatchDeleteDeviceGroupRelationsResponseBody) SetSuccessDeviceCount(v int32) *BatchDeleteDeviceGroupRelationsResponseBody {
	s.SuccessDeviceCount = &v
	return s
}

func (s *BatchDeleteDeviceGroupRelationsResponseBody) SetValidDeviceCount(v int32) *BatchDeleteDeviceGroupRelationsResponseBody {
	s.ValidDeviceCount = &v
	return s
}

type BatchDeleteDeviceGroupRelationsResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchDeleteDeviceGroupRelationsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchDeleteDeviceGroupRelationsResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteDeviceGroupRelationsResponse) GoString() string {
	return s.String()
}

func (s *BatchDeleteDeviceGroupRelationsResponse) SetHeaders(v map[string]*string) *BatchDeleteDeviceGroupRelationsResponse {
	s.Headers = v
	return s
}

func (s *BatchDeleteDeviceGroupRelationsResponse) SetStatusCode(v int32) *BatchDeleteDeviceGroupRelationsResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchDeleteDeviceGroupRelationsResponse) SetBody(v *BatchDeleteDeviceGroupRelationsResponseBody) *BatchDeleteDeviceGroupRelationsResponse {
	s.Body = v
	return s
}

type BatchDeleteEdgeInstanceChannelRequest struct {
	ChannelIds    []*string `json:"ChannelIds,omitempty" xml:"ChannelIds,omitempty" type:"Repeated"`
	DriverId      *string   `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	InstanceId    *string   `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchDeleteEdgeInstanceChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteEdgeInstanceChannelRequest) GoString() string {
	return s.String()
}

func (s *BatchDeleteEdgeInstanceChannelRequest) SetChannelIds(v []*string) *BatchDeleteEdgeInstanceChannelRequest {
	s.ChannelIds = v
	return s
}

func (s *BatchDeleteEdgeInstanceChannelRequest) SetDriverId(v string) *BatchDeleteEdgeInstanceChannelRequest {
	s.DriverId = &v
	return s
}

func (s *BatchDeleteEdgeInstanceChannelRequest) SetInstanceId(v string) *BatchDeleteEdgeInstanceChannelRequest {
	s.InstanceId = &v
	return s
}

func (s *BatchDeleteEdgeInstanceChannelRequest) SetIotInstanceId(v string) *BatchDeleteEdgeInstanceChannelRequest {
	s.IotInstanceId = &v
	return s
}

type BatchDeleteEdgeInstanceChannelResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchDeleteEdgeInstanceChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteEdgeInstanceChannelResponseBody) GoString() string {
	return s.String()
}

func (s *BatchDeleteEdgeInstanceChannelResponseBody) SetCode(v string) *BatchDeleteEdgeInstanceChannelResponseBody {
	s.Code = &v
	return s
}

func (s *BatchDeleteEdgeInstanceChannelResponseBody) SetErrorMessage(v string) *BatchDeleteEdgeInstanceChannelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchDeleteEdgeInstanceChannelResponseBody) SetRequestId(v string) *BatchDeleteEdgeInstanceChannelResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchDeleteEdgeInstanceChannelResponseBody) SetSuccess(v bool) *BatchDeleteEdgeInstanceChannelResponseBody {
	s.Success = &v
	return s
}

type BatchDeleteEdgeInstanceChannelResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchDeleteEdgeInstanceChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchDeleteEdgeInstanceChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchDeleteEdgeInstanceChannelResponse) GoString() string {
	return s.String()
}

func (s *BatchDeleteEdgeInstanceChannelResponse) SetHeaders(v map[string]*string) *BatchDeleteEdgeInstanceChannelResponse {
	s.Headers = v
	return s
}

func (s *BatchDeleteEdgeInstanceChannelResponse) SetStatusCode(v int32) *BatchDeleteEdgeInstanceChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchDeleteEdgeInstanceChannelResponse) SetBody(v *BatchDeleteEdgeInstanceChannelResponseBody) *BatchDeleteEdgeInstanceChannelResponse {
	s.Body = v
	return s
}

type BatchGetDeviceBindStatusRequest struct {
	IotIds        []*string `json:"IotIds,omitempty" xml:"IotIds,omitempty" type:"Repeated"`
	IotInstanceId *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchGetDeviceBindStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchGetDeviceBindStatusRequest) GoString() string {
	return s.String()
}

func (s *BatchGetDeviceBindStatusRequest) SetIotIds(v []*string) *BatchGetDeviceBindStatusRequest {
	s.IotIds = v
	return s
}

func (s *BatchGetDeviceBindStatusRequest) SetIotInstanceId(v string) *BatchGetDeviceBindStatusRequest {
	s.IotInstanceId = &v
	return s
}

type BatchGetDeviceBindStatusResponseBody struct {
	Code         *string                                     `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         []*BatchGetDeviceBindStatusResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	ErrorMessage *string                                     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchGetDeviceBindStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchGetDeviceBindStatusResponseBody) GoString() string {
	return s.String()
}

func (s *BatchGetDeviceBindStatusResponseBody) SetCode(v string) *BatchGetDeviceBindStatusResponseBody {
	s.Code = &v
	return s
}

func (s *BatchGetDeviceBindStatusResponseBody) SetData(v []*BatchGetDeviceBindStatusResponseBodyData) *BatchGetDeviceBindStatusResponseBody {
	s.Data = v
	return s
}

func (s *BatchGetDeviceBindStatusResponseBody) SetErrorMessage(v string) *BatchGetDeviceBindStatusResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchGetDeviceBindStatusResponseBody) SetRequestId(v string) *BatchGetDeviceBindStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchGetDeviceBindStatusResponseBody) SetSuccess(v bool) *BatchGetDeviceBindStatusResponseBody {
	s.Success = &v
	return s
}

type BatchGetDeviceBindStatusResponseBodyData struct {
	BindStatus *int32 `json:"BindStatus,omitempty" xml:"BindStatus,omitempty"`
	// 实例ID。
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotId      *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
}

func (s BatchGetDeviceBindStatusResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s BatchGetDeviceBindStatusResponseBodyData) GoString() string {
	return s.String()
}

func (s *BatchGetDeviceBindStatusResponseBodyData) SetBindStatus(v int32) *BatchGetDeviceBindStatusResponseBodyData {
	s.BindStatus = &v
	return s
}

func (s *BatchGetDeviceBindStatusResponseBodyData) SetInstanceId(v string) *BatchGetDeviceBindStatusResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *BatchGetDeviceBindStatusResponseBodyData) SetIotId(v string) *BatchGetDeviceBindStatusResponseBodyData {
	s.IotId = &v
	return s
}

type BatchGetDeviceBindStatusResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchGetDeviceBindStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchGetDeviceBindStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchGetDeviceBindStatusResponse) GoString() string {
	return s.String()
}

func (s *BatchGetDeviceBindStatusResponse) SetHeaders(v map[string]*string) *BatchGetDeviceBindStatusResponse {
	s.Headers = v
	return s
}

func (s *BatchGetDeviceBindStatusResponse) SetStatusCode(v int32) *BatchGetDeviceBindStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchGetDeviceBindStatusResponse) SetBody(v *BatchGetDeviceBindStatusResponseBody) *BatchGetDeviceBindStatusResponse {
	s.Body = v
	return s
}

type BatchGetDeviceStateRequest struct {
	DeviceName []*string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty" type:"Repeated"`
	IotId      []*string `json:"IotId,omitempty" xml:"IotId,omitempty" type:"Repeated"`
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
	//
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	//
	// > If you configure this parameter, you must also specify a value for the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BatchGetDeviceStateRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchGetDeviceStateRequest) GoString() string {
	return s.String()
}

func (s *BatchGetDeviceStateRequest) SetDeviceName(v []*string) *BatchGetDeviceStateRequest {
	s.DeviceName = v
	return s
}

func (s *BatchGetDeviceStateRequest) SetIotId(v []*string) *BatchGetDeviceStateRequest {
	s.IotId = v
	return s
}

func (s *BatchGetDeviceStateRequest) SetIotInstanceId(v string) *BatchGetDeviceStateRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchGetDeviceStateRequest) SetProductKey(v string) *BatchGetDeviceStateRequest {
	s.ProductKey = &v
	return s
}

type BatchGetDeviceStateResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The device status information returned if the call is successful. For more information, see the following parameters that are included in the DeviceStatus parameter.
	DeviceStatusList *BatchGetDeviceStateResponseBodyDeviceStatusList `json:"DeviceStatusList,omitempty" xml:"DeviceStatusList,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchGetDeviceStateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchGetDeviceStateResponseBody) GoString() string {
	return s.String()
}

func (s *BatchGetDeviceStateResponseBody) SetCode(v string) *BatchGetDeviceStateResponseBody {
	s.Code = &v
	return s
}

func (s *BatchGetDeviceStateResponseBody) SetDeviceStatusList(v *BatchGetDeviceStateResponseBodyDeviceStatusList) *BatchGetDeviceStateResponseBody {
	s.DeviceStatusList = v
	return s
}

func (s *BatchGetDeviceStateResponseBody) SetErrorMessage(v string) *BatchGetDeviceStateResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchGetDeviceStateResponseBody) SetRequestId(v string) *BatchGetDeviceStateResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchGetDeviceStateResponseBody) SetSuccess(v bool) *BatchGetDeviceStateResponseBody {
	s.Success = &v
	return s
}

type BatchGetDeviceStateResponseBodyDeviceStatusList struct {
	DeviceStatus []*BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus `json:"DeviceStatus,omitempty" xml:"DeviceStatus,omitempty" type:"Repeated"`
}

func (s BatchGetDeviceStateResponseBodyDeviceStatusList) String() string {
	return tea.Prettify(s)
}

func (s BatchGetDeviceStateResponseBodyDeviceStatusList) GoString() string {
	return s.String()
}

func (s *BatchGetDeviceStateResponseBodyDeviceStatusList) SetDeviceStatus(v []*BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus) *BatchGetDeviceStateResponseBodyDeviceStatusList {
	s.DeviceStatus = v
	return s
}

type BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus struct {
	// The IP address of the device.
	AsAddress *string `json:"AsAddress,omitempty" xml:"AsAddress,omitempty"`
	// The ID of the device (expired).
	//
	// >  This parameter is no longer supported. Do not use this parameter to identify a device. You can use the value of the **IotId**** parameter or a combination of the values of the ****ProductKey** and DeviceName parameters to identify a device.
	DeviceId *string `json:"DeviceId,omitempty" xml:"DeviceId,omitempty"`
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The last time when the device was online.
	LastOnlineTime *string `json:"LastOnlineTime,omitempty" xml:"LastOnlineTime,omitempty"`
	// The status of the device. Valid values: Valid values:
	//
	// *   **ONLINE**: The device is online.
	// *   **OFFLINE**: The device is offline.
	// *   **UNACTIVE**: The device is not activated.
	// *   **DISABLE**: The device is disabled.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus) String() string {
	return tea.Prettify(s)
}

func (s BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus) GoString() string {
	return s.String()
}

func (s *BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus) SetAsAddress(v string) *BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus {
	s.AsAddress = &v
	return s
}

func (s *BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus) SetDeviceId(v string) *BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus {
	s.DeviceId = &v
	return s
}

func (s *BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus) SetDeviceName(v string) *BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus {
	s.DeviceName = &v
	return s
}

func (s *BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus) SetIotId(v string) *BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus {
	s.IotId = &v
	return s
}

func (s *BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus) SetLastOnlineTime(v string) *BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus {
	s.LastOnlineTime = &v
	return s
}

func (s *BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus) SetStatus(v string) *BatchGetDeviceStateResponseBodyDeviceStatusListDeviceStatus {
	s.Status = &v
	return s
}

type BatchGetDeviceStateResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchGetDeviceStateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchGetDeviceStateResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchGetDeviceStateResponse) GoString() string {
	return s.String()
}

func (s *BatchGetDeviceStateResponse) SetHeaders(v map[string]*string) *BatchGetDeviceStateResponse {
	s.Headers = v
	return s
}

func (s *BatchGetDeviceStateResponse) SetStatusCode(v int32) *BatchGetDeviceStateResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchGetDeviceStateResponse) SetBody(v *BatchGetDeviceStateResponseBody) *BatchGetDeviceStateResponse {
	s.Body = v
	return s
}

type BatchGetEdgeDriverRequest struct {
	DriverIds []*string `json:"DriverIds,omitempty" xml:"DriverIds,omitempty" type:"Repeated"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for public instances. However, this parameter is required for the instances that you have purchased.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchGetEdgeDriverRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeDriverRequest) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeDriverRequest) SetDriverIds(v []*string) *BatchGetEdgeDriverRequest {
	s.DriverIds = v
	return s
}

func (s *BatchGetEdgeDriverRequest) SetIotInstanceId(v string) *BatchGetEdgeDriverRequest {
	s.IotInstanceId = &v
	return s
}

type BatchGetEdgeDriverResponseBody struct {
	// The error code. Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about each driver.
	DriverList []*BatchGetEdgeDriverResponseBodyDriverList `json:"DriverList,omitempty" xml:"DriverList,omitempty" type:"Repeated"`
	// The error message returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. true indicates that the call was successful. false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchGetEdgeDriverResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeDriverResponseBody) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeDriverResponseBody) SetCode(v string) *BatchGetEdgeDriverResponseBody {
	s.Code = &v
	return s
}

func (s *BatchGetEdgeDriverResponseBody) SetDriverList(v []*BatchGetEdgeDriverResponseBodyDriverList) *BatchGetEdgeDriverResponseBody {
	s.DriverList = v
	return s
}

func (s *BatchGetEdgeDriverResponseBody) SetErrorMessage(v string) *BatchGetEdgeDriverResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchGetEdgeDriverResponseBody) SetRequestId(v string) *BatchGetEdgeDriverResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchGetEdgeDriverResponseBody) SetSuccess(v bool) *BatchGetEdgeDriverResponseBody {
	s.Success = &v
	return s
}

type BatchGetEdgeDriverResponseBodyDriverList struct {
	// The CPU architecture that the driver supports. Valid values:
	//
	// *   ARMv7
	// *   ARMv7-HF
	// *   AArch64
	// *   x86-64
	// *   x86
	CpuArch *string `json:"CpuArch,omitempty" xml:"CpuArch,omitempty"`
	// The ID of the driver.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The name of the driver.
	DriverName *string `json:"DriverName,omitempty" xml:"DriverName,omitempty"`
	// The communications protocol that the driver uses. Valid values:
	//
	// *   modbus: Modbus protocol
	// *   opc-ua: OPC UA protocol
	// *   customize: custom protocol
	DriverProtocol *string `json:"DriverProtocol,omitempty" xml:"DriverProtocol,omitempty"`
	// The time when the driver was created. The time is displayed in UTC.
	GmtCreateTimestamp *int64 `json:"GmtCreateTimestamp,omitempty" xml:"GmtCreateTimestamp,omitempty"`
	// The time when the driver was last modified. The time is displayed in UTC.
	GmtModifiedTimestamp *int64 `json:"GmtModifiedTimestamp,omitempty" xml:"GmtModifiedTimestamp,omitempty"`
	// Indicates whether the driver is a built-in driver.
	//
	// *   true: indicates that the driver is a built-in driver, that is, the driver code is pre-configured on the gateway device.
	// *   false: indicates that the driver is not a built-in driver.
	IsBuiltIn *bool `json:"IsBuiltIn,omitempty" xml:"IsBuiltIn,omitempty"`
	// The language in which the driver is programmed. Valid values:
	//
	// *   nodejs8: Node.js v8
	// *   python3: Python v3.5
	// *   c: C
	Runtime *string `json:"Runtime,omitempty" xml:"Runtime,omitempty"`
	// The type of the driver. Valid values:
	//
	// *   0: official driver
	// *   1: custom driver
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s BatchGetEdgeDriverResponseBodyDriverList) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeDriverResponseBodyDriverList) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeDriverResponseBodyDriverList) SetCpuArch(v string) *BatchGetEdgeDriverResponseBodyDriverList {
	s.CpuArch = &v
	return s
}

func (s *BatchGetEdgeDriverResponseBodyDriverList) SetDriverId(v string) *BatchGetEdgeDriverResponseBodyDriverList {
	s.DriverId = &v
	return s
}

func (s *BatchGetEdgeDriverResponseBodyDriverList) SetDriverName(v string) *BatchGetEdgeDriverResponseBodyDriverList {
	s.DriverName = &v
	return s
}

func (s *BatchGetEdgeDriverResponseBodyDriverList) SetDriverProtocol(v string) *BatchGetEdgeDriverResponseBodyDriverList {
	s.DriverProtocol = &v
	return s
}

func (s *BatchGetEdgeDriverResponseBodyDriverList) SetGmtCreateTimestamp(v int64) *BatchGetEdgeDriverResponseBodyDriverList {
	s.GmtCreateTimestamp = &v
	return s
}

func (s *BatchGetEdgeDriverResponseBodyDriverList) SetGmtModifiedTimestamp(v int64) *BatchGetEdgeDriverResponseBodyDriverList {
	s.GmtModifiedTimestamp = &v
	return s
}

func (s *BatchGetEdgeDriverResponseBodyDriverList) SetIsBuiltIn(v bool) *BatchGetEdgeDriverResponseBodyDriverList {
	s.IsBuiltIn = &v
	return s
}

func (s *BatchGetEdgeDriverResponseBodyDriverList) SetRuntime(v string) *BatchGetEdgeDriverResponseBodyDriverList {
	s.Runtime = &v
	return s
}

func (s *BatchGetEdgeDriverResponseBodyDriverList) SetType(v int32) *BatchGetEdgeDriverResponseBodyDriverList {
	s.Type = &v
	return s
}

type BatchGetEdgeDriverResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchGetEdgeDriverResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchGetEdgeDriverResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeDriverResponse) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeDriverResponse) SetHeaders(v map[string]*string) *BatchGetEdgeDriverResponse {
	s.Headers = v
	return s
}

func (s *BatchGetEdgeDriverResponse) SetStatusCode(v int32) *BatchGetEdgeDriverResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchGetEdgeDriverResponse) SetBody(v *BatchGetEdgeDriverResponseBody) *BatchGetEdgeDriverResponse {
	s.Body = v
	return s
}

type BatchGetEdgeInstanceChannelRequest struct {
	ChannelIds    []*string `json:"ChannelIds,omitempty" xml:"ChannelIds,omitempty" type:"Repeated"`
	DriverId      *string   `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	InstanceId    *string   `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchGetEdgeInstanceChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceChannelRequest) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceChannelRequest) SetChannelIds(v []*string) *BatchGetEdgeInstanceChannelRequest {
	s.ChannelIds = v
	return s
}

func (s *BatchGetEdgeInstanceChannelRequest) SetDriverId(v string) *BatchGetEdgeInstanceChannelRequest {
	s.DriverId = &v
	return s
}

func (s *BatchGetEdgeInstanceChannelRequest) SetInstanceId(v string) *BatchGetEdgeInstanceChannelRequest {
	s.InstanceId = &v
	return s
}

func (s *BatchGetEdgeInstanceChannelRequest) SetIotInstanceId(v string) *BatchGetEdgeInstanceChannelRequest {
	s.IotInstanceId = &v
	return s
}

type BatchGetEdgeInstanceChannelResponseBody struct {
	Code         *string                                      `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *BatchGetEdgeInstanceChannelResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                      `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                      `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                        `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchGetEdgeInstanceChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceChannelResponseBody) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceChannelResponseBody) SetCode(v string) *BatchGetEdgeInstanceChannelResponseBody {
	s.Code = &v
	return s
}

func (s *BatchGetEdgeInstanceChannelResponseBody) SetData(v *BatchGetEdgeInstanceChannelResponseBodyData) *BatchGetEdgeInstanceChannelResponseBody {
	s.Data = v
	return s
}

func (s *BatchGetEdgeInstanceChannelResponseBody) SetErrorMessage(v string) *BatchGetEdgeInstanceChannelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchGetEdgeInstanceChannelResponseBody) SetRequestId(v string) *BatchGetEdgeInstanceChannelResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchGetEdgeInstanceChannelResponseBody) SetSuccess(v bool) *BatchGetEdgeInstanceChannelResponseBody {
	s.Success = &v
	return s
}

type BatchGetEdgeInstanceChannelResponseBodyData struct {
	Channel []*BatchGetEdgeInstanceChannelResponseBodyDataChannel `json:"Channel,omitempty" xml:"Channel,omitempty" type:"Repeated"`
}

func (s BatchGetEdgeInstanceChannelResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceChannelResponseBodyData) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceChannelResponseBodyData) SetChannel(v []*BatchGetEdgeInstanceChannelResponseBodyDataChannel) *BatchGetEdgeInstanceChannelResponseBodyData {
	s.Channel = v
	return s
}

type BatchGetEdgeInstanceChannelResponseBodyDataChannel struct {
	ChannelId   *string                                                       `json:"ChannelId,omitempty" xml:"ChannelId,omitempty"`
	ChannelName *string                                                       `json:"ChannelName,omitempty" xml:"ChannelName,omitempty"`
	ConfigList  *BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList `json:"ConfigList,omitempty" xml:"ConfigList,omitempty" type:"Struct"`
}

func (s BatchGetEdgeInstanceChannelResponseBodyDataChannel) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceChannelResponseBodyDataChannel) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceChannelResponseBodyDataChannel) SetChannelId(v string) *BatchGetEdgeInstanceChannelResponseBodyDataChannel {
	s.ChannelId = &v
	return s
}

func (s *BatchGetEdgeInstanceChannelResponseBodyDataChannel) SetChannelName(v string) *BatchGetEdgeInstanceChannelResponseBodyDataChannel {
	s.ChannelName = &v
	return s
}

func (s *BatchGetEdgeInstanceChannelResponseBodyDataChannel) SetConfigList(v *BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList) *BatchGetEdgeInstanceChannelResponseBodyDataChannel {
	s.ConfigList = v
	return s
}

type BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList struct {
	Config []*BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig `json:"Config,omitempty" xml:"Config,omitempty" type:"Repeated"`
}

func (s BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList) SetConfig(v []*BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig) *BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigList {
	s.Config = v
	return s
}

type BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig struct {
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	Content  *string `json:"Content,omitempty" xml:"Content,omitempty"`
	Format   *string `json:"Format,omitempty" xml:"Format,omitempty"`
	Key      *string `json:"Key,omitempty" xml:"Key,omitempty"`
}

func (s BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig) SetConfigId(v string) *BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig {
	s.ConfigId = &v
	return s
}

func (s *BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig) SetContent(v string) *BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig {
	s.Content = &v
	return s
}

func (s *BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig) SetFormat(v string) *BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig {
	s.Format = &v
	return s
}

func (s *BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig) SetKey(v string) *BatchGetEdgeInstanceChannelResponseBodyDataChannelConfigListConfig {
	s.Key = &v
	return s
}

type BatchGetEdgeInstanceChannelResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchGetEdgeInstanceChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchGetEdgeInstanceChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceChannelResponse) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceChannelResponse) SetHeaders(v map[string]*string) *BatchGetEdgeInstanceChannelResponse {
	s.Headers = v
	return s
}

func (s *BatchGetEdgeInstanceChannelResponse) SetStatusCode(v int32) *BatchGetEdgeInstanceChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchGetEdgeInstanceChannelResponse) SetBody(v *BatchGetEdgeInstanceChannelResponseBody) *BatchGetEdgeInstanceChannelResponse {
	s.Body = v
	return s
}

type BatchGetEdgeInstanceDeviceChannelRequest struct {
	DriverId      *string   `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	InstanceId    *string   `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotIds        []*string `json:"IotIds,omitempty" xml:"IotIds,omitempty" type:"Repeated"`
	IotInstanceId *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchGetEdgeInstanceDeviceChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDeviceChannelRequest) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDeviceChannelRequest) SetDriverId(v string) *BatchGetEdgeInstanceDeviceChannelRequest {
	s.DriverId = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceChannelRequest) SetInstanceId(v string) *BatchGetEdgeInstanceDeviceChannelRequest {
	s.InstanceId = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceChannelRequest) SetIotIds(v []*string) *BatchGetEdgeInstanceDeviceChannelRequest {
	s.IotIds = v
	return s
}

func (s *BatchGetEdgeInstanceDeviceChannelRequest) SetIotInstanceId(v string) *BatchGetEdgeInstanceDeviceChannelRequest {
	s.IotInstanceId = &v
	return s
}

type BatchGetEdgeInstanceDeviceChannelResponseBody struct {
	Code              *string                                                           `json:"Code,omitempty" xml:"Code,omitempty"`
	DeviceChannelList []*BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList `json:"DeviceChannelList,omitempty" xml:"DeviceChannelList,omitempty" type:"Repeated"`
	ErrorMessage      *string                                                           `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId         *string                                                           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success           *bool                                                             `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchGetEdgeInstanceDeviceChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDeviceChannelResponseBody) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDeviceChannelResponseBody) SetCode(v string) *BatchGetEdgeInstanceDeviceChannelResponseBody {
	s.Code = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceChannelResponseBody) SetDeviceChannelList(v []*BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList) *BatchGetEdgeInstanceDeviceChannelResponseBody {
	s.DeviceChannelList = v
	return s
}

func (s *BatchGetEdgeInstanceDeviceChannelResponseBody) SetErrorMessage(v string) *BatchGetEdgeInstanceDeviceChannelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceChannelResponseBody) SetRequestId(v string) *BatchGetEdgeInstanceDeviceChannelResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceChannelResponseBody) SetSuccess(v bool) *BatchGetEdgeInstanceDeviceChannelResponseBody {
	s.Success = &v
	return s
}

type BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList struct {
	ChannelId   *string `json:"ChannelId,omitempty" xml:"ChannelId,omitempty"`
	ChannelName *string `json:"ChannelName,omitempty" xml:"ChannelName,omitempty"`
	IotId       *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
}

func (s BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList) SetChannelId(v string) *BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList {
	s.ChannelId = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList) SetChannelName(v string) *BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList {
	s.ChannelName = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList) SetIotId(v string) *BatchGetEdgeInstanceDeviceChannelResponseBodyDeviceChannelList {
	s.IotId = &v
	return s
}

type BatchGetEdgeInstanceDeviceChannelResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchGetEdgeInstanceDeviceChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchGetEdgeInstanceDeviceChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDeviceChannelResponse) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDeviceChannelResponse) SetHeaders(v map[string]*string) *BatchGetEdgeInstanceDeviceChannelResponse {
	s.Headers = v
	return s
}

func (s *BatchGetEdgeInstanceDeviceChannelResponse) SetStatusCode(v int32) *BatchGetEdgeInstanceDeviceChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceChannelResponse) SetBody(v *BatchGetEdgeInstanceDeviceChannelResponseBody) *BatchGetEdgeInstanceDeviceChannelResponse {
	s.Body = v
	return s
}

type BatchGetEdgeInstanceDeviceConfigRequest struct {
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to query and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string   `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotIds     []*string `json:"IotIds,omitempty" xml:"IotIds,omitempty" type:"Repeated"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchGetEdgeInstanceDeviceConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDeviceConfigRequest) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDeviceConfigRequest) SetInstanceId(v string) *BatchGetEdgeInstanceDeviceConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceConfigRequest) SetIotIds(v []*string) *BatchGetEdgeInstanceDeviceConfigRequest {
	s.IotIds = v
	return s
}

func (s *BatchGetEdgeInstanceDeviceConfigRequest) SetIotInstanceId(v string) *BatchGetEdgeInstanceDeviceConfigRequest {
	s.IotInstanceId = &v
	return s
}

type BatchGetEdgeInstanceDeviceConfigResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The device configuration information that is returned if the call was successful.
	DeviceConfigList []*BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList `json:"DeviceConfigList,omitempty" xml:"DeviceConfigList,omitempty" type:"Repeated"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchGetEdgeInstanceDeviceConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDeviceConfigResponseBody) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDeviceConfigResponseBody) SetCode(v string) *BatchGetEdgeInstanceDeviceConfigResponseBody {
	s.Code = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceConfigResponseBody) SetDeviceConfigList(v []*BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList) *BatchGetEdgeInstanceDeviceConfigResponseBody {
	s.DeviceConfigList = v
	return s
}

func (s *BatchGetEdgeInstanceDeviceConfigResponseBody) SetErrorMessage(v string) *BatchGetEdgeInstanceDeviceConfigResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceConfigResponseBody) SetRequestId(v string) *BatchGetEdgeInstanceDeviceConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceConfigResponseBody) SetSuccess(v bool) *BatchGetEdgeInstanceDeviceConfigResponseBody {
	s.Success = &v
	return s
}

type BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList struct {
	// The configuration information of the device.
	Config *BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig `json:"Config,omitempty" xml:"Config,omitempty" type:"Struct"`
	// The ID of the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
}

func (s BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList) SetConfig(v *BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig) *BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList {
	s.Config = v
	return s
}

func (s *BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList) SetIotId(v string) *BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigList {
	s.IotId = &v
	return s
}

type BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig struct {
	// The configuration content or the Object Storage Service (OSS) path of the configuration file.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The format of the configuration. Valid values: KV (key-value pair), JSON (JSON string), and FILE (configuration file).
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
}

func (s BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig) SetContent(v string) *BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig {
	s.Content = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig) SetFormat(v string) *BatchGetEdgeInstanceDeviceConfigResponseBodyDeviceConfigListConfig {
	s.Format = &v
	return s
}

type BatchGetEdgeInstanceDeviceConfigResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchGetEdgeInstanceDeviceConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchGetEdgeInstanceDeviceConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDeviceConfigResponse) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDeviceConfigResponse) SetHeaders(v map[string]*string) *BatchGetEdgeInstanceDeviceConfigResponse {
	s.Headers = v
	return s
}

func (s *BatchGetEdgeInstanceDeviceConfigResponse) SetStatusCode(v int32) *BatchGetEdgeInstanceDeviceConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceConfigResponse) SetBody(v *BatchGetEdgeInstanceDeviceConfigResponseBody) *BatchGetEdgeInstanceDeviceConfigResponse {
	s.Body = v
	return s
}

type BatchGetEdgeInstanceDeviceDriverRequest struct {
	InstanceId    *string   `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotIds        []*string `json:"IotIds,omitempty" xml:"IotIds,omitempty" type:"Repeated"`
	IotInstanceId *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchGetEdgeInstanceDeviceDriverRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDeviceDriverRequest) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDeviceDriverRequest) SetInstanceId(v string) *BatchGetEdgeInstanceDeviceDriverRequest {
	s.InstanceId = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceDriverRequest) SetIotIds(v []*string) *BatchGetEdgeInstanceDeviceDriverRequest {
	s.IotIds = v
	return s
}

func (s *BatchGetEdgeInstanceDeviceDriverRequest) SetIotInstanceId(v string) *BatchGetEdgeInstanceDeviceDriverRequest {
	s.IotInstanceId = &v
	return s
}

type BatchGetEdgeInstanceDeviceDriverResponseBody struct {
	Code             *string                                                         `json:"Code,omitempty" xml:"Code,omitempty"`
	DeviceDriverList []*BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList `json:"DeviceDriverList,omitempty" xml:"DeviceDriverList,omitempty" type:"Repeated"`
	ErrorMessage     *string                                                         `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId        *string                                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success          *bool                                                           `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchGetEdgeInstanceDeviceDriverResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDeviceDriverResponseBody) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDeviceDriverResponseBody) SetCode(v string) *BatchGetEdgeInstanceDeviceDriverResponseBody {
	s.Code = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceDriverResponseBody) SetDeviceDriverList(v []*BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList) *BatchGetEdgeInstanceDeviceDriverResponseBody {
	s.DeviceDriverList = v
	return s
}

func (s *BatchGetEdgeInstanceDeviceDriverResponseBody) SetErrorMessage(v string) *BatchGetEdgeInstanceDeviceDriverResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceDriverResponseBody) SetRequestId(v string) *BatchGetEdgeInstanceDeviceDriverResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceDriverResponseBody) SetSuccess(v bool) *BatchGetEdgeInstanceDeviceDriverResponseBody {
	s.Success = &v
	return s
}

type BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList struct {
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	IotId    *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
}

func (s BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList) SetDriverId(v string) *BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList {
	s.DriverId = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList) SetIotId(v string) *BatchGetEdgeInstanceDeviceDriverResponseBodyDeviceDriverList {
	s.IotId = &v
	return s
}

type BatchGetEdgeInstanceDeviceDriverResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchGetEdgeInstanceDeviceDriverResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchGetEdgeInstanceDeviceDriverResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDeviceDriverResponse) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDeviceDriverResponse) SetHeaders(v map[string]*string) *BatchGetEdgeInstanceDeviceDriverResponse {
	s.Headers = v
	return s
}

func (s *BatchGetEdgeInstanceDeviceDriverResponse) SetStatusCode(v int32) *BatchGetEdgeInstanceDeviceDriverResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchGetEdgeInstanceDeviceDriverResponse) SetBody(v *BatchGetEdgeInstanceDeviceDriverResponseBody) *BatchGetEdgeInstanceDeviceDriverResponse {
	s.Body = v
	return s
}

type BatchGetEdgeInstanceDriverConfigsRequest struct {
	DriverIds []*string `json:"DriverIds,omitempty" xml:"DriverIds,omitempty" type:"Repeated"`
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that uses the drivers and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchGetEdgeInstanceDriverConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDriverConfigsRequest) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDriverConfigsRequest) SetDriverIds(v []*string) *BatchGetEdgeInstanceDriverConfigsRequest {
	s.DriverIds = v
	return s
}

func (s *BatchGetEdgeInstanceDriverConfigsRequest) SetInstanceId(v string) *BatchGetEdgeInstanceDriverConfigsRequest {
	s.InstanceId = &v
	return s
}

func (s *BatchGetEdgeInstanceDriverConfigsRequest) SetIotInstanceId(v string) *BatchGetEdgeInstanceDriverConfigsRequest {
	s.IotInstanceId = &v
	return s
}

type BatchGetEdgeInstanceDriverConfigsResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned if the call was successful.
	DriverConfigList []*BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList `json:"DriverConfigList,omitempty" xml:"DriverConfigList,omitempty" type:"Repeated"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchGetEdgeInstanceDriverConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDriverConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDriverConfigsResponseBody) SetCode(v string) *BatchGetEdgeInstanceDriverConfigsResponseBody {
	s.Code = &v
	return s
}

func (s *BatchGetEdgeInstanceDriverConfigsResponseBody) SetDriverConfigList(v []*BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList) *BatchGetEdgeInstanceDriverConfigsResponseBody {
	s.DriverConfigList = v
	return s
}

func (s *BatchGetEdgeInstanceDriverConfigsResponseBody) SetErrorMessage(v string) *BatchGetEdgeInstanceDriverConfigsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchGetEdgeInstanceDriverConfigsResponseBody) SetRequestId(v string) *BatchGetEdgeInstanceDriverConfigsResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchGetEdgeInstanceDriverConfigsResponseBody) SetSuccess(v bool) *BatchGetEdgeInstanceDriverConfigsResponseBody {
	s.Success = &v
	return s
}

type BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList struct {
	// The configuration information of the driver.
	ConfigList []*BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList `json:"ConfigList,omitempty" xml:"ConfigList,omitempty" type:"Repeated"`
	// The ID of the driver.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
}

func (s BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList) SetConfigList(v []*BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList) *BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList {
	s.ConfigList = v
	return s
}

func (s *BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList) SetDriverId(v string) *BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigList {
	s.DriverId = &v
	return s
}

type BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList struct {
	// The ID of the configuration.
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	// The configuration content or the Object Storage Service (OSS) path of the configuration file.
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	// The format of the configuration. Valid values: KV (key-value pair), JSON (JSON string), and FILE (configuration file).
	Format *string `json:"Format,omitempty" xml:"Format,omitempty"`
	// The key of the configuration. If multiple configurations are available, keywords can be used to identify the configurations.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
}

func (s BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList) SetConfigId(v string) *BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList {
	s.ConfigId = &v
	return s
}

func (s *BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList) SetContent(v string) *BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList {
	s.Content = &v
	return s
}

func (s *BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList) SetFormat(v string) *BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList {
	s.Format = &v
	return s
}

func (s *BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList) SetKey(v string) *BatchGetEdgeInstanceDriverConfigsResponseBodyDriverConfigListConfigList {
	s.Key = &v
	return s
}

type BatchGetEdgeInstanceDriverConfigsResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchGetEdgeInstanceDriverConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchGetEdgeInstanceDriverConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchGetEdgeInstanceDriverConfigsResponse) GoString() string {
	return s.String()
}

func (s *BatchGetEdgeInstanceDriverConfigsResponse) SetHeaders(v map[string]*string) *BatchGetEdgeInstanceDriverConfigsResponse {
	s.Headers = v
	return s
}

func (s *BatchGetEdgeInstanceDriverConfigsResponse) SetStatusCode(v int32) *BatchGetEdgeInstanceDriverConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchGetEdgeInstanceDriverConfigsResponse) SetBody(v *BatchGetEdgeInstanceDriverConfigsResponseBody) *BatchGetEdgeInstanceDriverConfigsResponse {
	s.Body = v
	return s
}

type BatchGrayMigrationDeviceRequest struct {
	DeviceNames []*string `json:"DeviceNames,omitempty" xml:"DeviceNames,omitempty" type:"Repeated"`
	ProductKey  *string   `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BatchGrayMigrationDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchGrayMigrationDeviceRequest) GoString() string {
	return s.String()
}

func (s *BatchGrayMigrationDeviceRequest) SetDeviceNames(v []*string) *BatchGrayMigrationDeviceRequest {
	s.DeviceNames = v
	return s
}

func (s *BatchGrayMigrationDeviceRequest) SetProductKey(v string) *BatchGrayMigrationDeviceRequest {
	s.ProductKey = &v
	return s
}

type BatchGrayMigrationDeviceResponseBody struct {
	Code         *string                                   `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *BatchGrayMigrationDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                   `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                     `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchGrayMigrationDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchGrayMigrationDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *BatchGrayMigrationDeviceResponseBody) SetCode(v string) *BatchGrayMigrationDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *BatchGrayMigrationDeviceResponseBody) SetData(v *BatchGrayMigrationDeviceResponseBodyData) *BatchGrayMigrationDeviceResponseBody {
	s.Data = v
	return s
}

func (s *BatchGrayMigrationDeviceResponseBody) SetErrorMessage(v string) *BatchGrayMigrationDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchGrayMigrationDeviceResponseBody) SetRequestId(v string) *BatchGrayMigrationDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchGrayMigrationDeviceResponseBody) SetSuccess(v bool) *BatchGrayMigrationDeviceResponseBody {
	s.Success = &v
	return s
}

type BatchGrayMigrationDeviceResponseBodyData struct {
	Details *BatchGrayMigrationDeviceResponseBodyDataDetails `json:"Details,omitempty" xml:"Details,omitempty" type:"Struct"`
}

func (s BatchGrayMigrationDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s BatchGrayMigrationDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *BatchGrayMigrationDeviceResponseBodyData) SetDetails(v *BatchGrayMigrationDeviceResponseBodyDataDetails) *BatchGrayMigrationDeviceResponseBodyData {
	s.Details = v
	return s
}

type BatchGrayMigrationDeviceResponseBodyDataDetails struct {
	Item []*BatchGrayMigrationDeviceResponseBodyDataDetailsItem `json:"item,omitempty" xml:"item,omitempty" type:"Repeated"`
}

func (s BatchGrayMigrationDeviceResponseBodyDataDetails) String() string {
	return tea.Prettify(s)
}

func (s BatchGrayMigrationDeviceResponseBodyDataDetails) GoString() string {
	return s.String()
}

func (s *BatchGrayMigrationDeviceResponseBodyDataDetails) SetItem(v []*BatchGrayMigrationDeviceResponseBodyDataDetailsItem) *BatchGrayMigrationDeviceResponseBodyDataDetails {
	s.Item = v
	return s
}

type BatchGrayMigrationDeviceResponseBodyDataDetailsItem struct {
	Code       *int32  `json:"Code,omitempty" xml:"Code,omitempty"`
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	Message    *string `json:"Message,omitempty" xml:"Message,omitempty"`
	Status     *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s BatchGrayMigrationDeviceResponseBodyDataDetailsItem) String() string {
	return tea.Prettify(s)
}

func (s BatchGrayMigrationDeviceResponseBodyDataDetailsItem) GoString() string {
	return s.String()
}

func (s *BatchGrayMigrationDeviceResponseBodyDataDetailsItem) SetCode(v int32) *BatchGrayMigrationDeviceResponseBodyDataDetailsItem {
	s.Code = &v
	return s
}

func (s *BatchGrayMigrationDeviceResponseBodyDataDetailsItem) SetDeviceName(v string) *BatchGrayMigrationDeviceResponseBodyDataDetailsItem {
	s.DeviceName = &v
	return s
}

func (s *BatchGrayMigrationDeviceResponseBodyDataDetailsItem) SetMessage(v string) *BatchGrayMigrationDeviceResponseBodyDataDetailsItem {
	s.Message = &v
	return s
}

func (s *BatchGrayMigrationDeviceResponseBodyDataDetailsItem) SetStatus(v string) *BatchGrayMigrationDeviceResponseBodyDataDetailsItem {
	s.Status = &v
	return s
}

type BatchGrayMigrationDeviceResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchGrayMigrationDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchGrayMigrationDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchGrayMigrationDeviceResponse) GoString() string {
	return s.String()
}

func (s *BatchGrayMigrationDeviceResponse) SetHeaders(v map[string]*string) *BatchGrayMigrationDeviceResponse {
	s.Headers = v
	return s
}

func (s *BatchGrayMigrationDeviceResponse) SetStatusCode(v int32) *BatchGrayMigrationDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchGrayMigrationDeviceResponse) SetBody(v *BatchGrayMigrationDeviceResponseBody) *BatchGrayMigrationDeviceResponse {
	s.Body = v
	return s
}

type BatchImportDeviceRequest struct {
	DeviceList []*BatchImportDeviceRequestDeviceList `json:"DeviceList,omitempty" xml:"DeviceList,omitempty" type:"Repeated"`
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
	//
	// For more information, see the [Overview](~~356505~~) topic of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the gateway product to which the devices belong.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BatchImportDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchImportDeviceRequest) GoString() string {
	return s.String()
}

func (s *BatchImportDeviceRequest) SetDeviceList(v []*BatchImportDeviceRequestDeviceList) *BatchImportDeviceRequest {
	s.DeviceList = v
	return s
}

func (s *BatchImportDeviceRequest) SetIotInstanceId(v string) *BatchImportDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchImportDeviceRequest) SetProductKey(v string) *BatchImportDeviceRequest {
	s.ProductKey = &v
	return s
}

type BatchImportDeviceRequestDeviceList struct {
	DeviceName   *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	DeviceSecret *string `json:"DeviceSecret,omitempty" xml:"DeviceSecret,omitempty"`
	Sn           *string `json:"Sn,omitempty" xml:"Sn,omitempty"`
}

func (s BatchImportDeviceRequestDeviceList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportDeviceRequestDeviceList) GoString() string {
	return s.String()
}

func (s *BatchImportDeviceRequestDeviceList) SetDeviceName(v string) *BatchImportDeviceRequestDeviceList {
	s.DeviceName = &v
	return s
}

func (s *BatchImportDeviceRequestDeviceList) SetDeviceSecret(v string) *BatchImportDeviceRequestDeviceList {
	s.DeviceSecret = &v
	return s
}

func (s *BatchImportDeviceRequestDeviceList) SetSn(v string) *BatchImportDeviceRequestDeviceList {
	s.Sn = &v
	return s
}

type BatchImportDeviceResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *BatchImportDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchImportDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchImportDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *BatchImportDeviceResponseBody) SetCode(v string) *BatchImportDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *BatchImportDeviceResponseBody) SetData(v *BatchImportDeviceResponseBodyData) *BatchImportDeviceResponseBody {
	s.Data = v
	return s
}

func (s *BatchImportDeviceResponseBody) SetErrorMessage(v string) *BatchImportDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchImportDeviceResponseBody) SetRequestId(v string) *BatchImportDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchImportDeviceResponseBody) SetSuccess(v bool) *BatchImportDeviceResponseBody {
	s.Success = &v
	return s
}

type BatchImportDeviceResponseBodyData struct {
	// The application ID returned if the request is successful.
	ApplyId                 *int64                                                    `json:"ApplyId,omitempty" xml:"ApplyId,omitempty"`
	InvalidDetailList       *BatchImportDeviceResponseBodyDataInvalidDetailList       `json:"InvalidDetailList,omitempty" xml:"InvalidDetailList,omitempty" type:"Struct"`
	InvalidDeviceNameList   *BatchImportDeviceResponseBodyDataInvalidDeviceNameList   `json:"InvalidDeviceNameList,omitempty" xml:"InvalidDeviceNameList,omitempty" type:"Struct"`
	InvalidDeviceSecretList *BatchImportDeviceResponseBodyDataInvalidDeviceSecretList `json:"InvalidDeviceSecretList,omitempty" xml:"InvalidDeviceSecretList,omitempty" type:"Struct"`
	InvalidSnList           *BatchImportDeviceResponseBodyDataInvalidSnList           `json:"InvalidSnList,omitempty" xml:"InvalidSnList,omitempty" type:"Struct"`
	RepeatedDeviceNameList  *BatchImportDeviceResponseBodyDataRepeatedDeviceNameList  `json:"RepeatedDeviceNameList,omitempty" xml:"RepeatedDeviceNameList,omitempty" type:"Struct"`
}

func (s BatchImportDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s BatchImportDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *BatchImportDeviceResponseBodyData) SetApplyId(v int64) *BatchImportDeviceResponseBodyData {
	s.ApplyId = &v
	return s
}

func (s *BatchImportDeviceResponseBodyData) SetInvalidDetailList(v *BatchImportDeviceResponseBodyDataInvalidDetailList) *BatchImportDeviceResponseBodyData {
	s.InvalidDetailList = v
	return s
}

func (s *BatchImportDeviceResponseBodyData) SetInvalidDeviceNameList(v *BatchImportDeviceResponseBodyDataInvalidDeviceNameList) *BatchImportDeviceResponseBodyData {
	s.InvalidDeviceNameList = v
	return s
}

func (s *BatchImportDeviceResponseBodyData) SetInvalidDeviceSecretList(v *BatchImportDeviceResponseBodyDataInvalidDeviceSecretList) *BatchImportDeviceResponseBodyData {
	s.InvalidDeviceSecretList = v
	return s
}

func (s *BatchImportDeviceResponseBodyData) SetInvalidSnList(v *BatchImportDeviceResponseBodyDataInvalidSnList) *BatchImportDeviceResponseBodyData {
	s.InvalidSnList = v
	return s
}

func (s *BatchImportDeviceResponseBodyData) SetRepeatedDeviceNameList(v *BatchImportDeviceResponseBodyDataRepeatedDeviceNameList) *BatchImportDeviceResponseBodyData {
	s.RepeatedDeviceNameList = v
	return s
}

type BatchImportDeviceResponseBodyDataInvalidDetailList struct {
	InvalidDetailList []*BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList `json:"InvalidDetailList,omitempty" xml:"InvalidDetailList,omitempty" type:"Repeated"`
}

func (s BatchImportDeviceResponseBodyDataInvalidDetailList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportDeviceResponseBodyDataInvalidDetailList) GoString() string {
	return s.String()
}

func (s *BatchImportDeviceResponseBodyDataInvalidDetailList) SetInvalidDetailList(v []*BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList) *BatchImportDeviceResponseBodyDataInvalidDetailList {
	s.InvalidDetailList = v
	return s
}

type BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList struct {
	DeviceName   *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	DeviceSecret *string `json:"DeviceSecret,omitempty" xml:"DeviceSecret,omitempty"`
	ErrorMsg     *string `json:"ErrorMsg,omitempty" xml:"ErrorMsg,omitempty"`
	Sn           *string `json:"Sn,omitempty" xml:"Sn,omitempty"`
}

func (s BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList) GoString() string {
	return s.String()
}

func (s *BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList) SetDeviceName(v string) *BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList {
	s.DeviceName = &v
	return s
}

func (s *BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList) SetDeviceSecret(v string) *BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList {
	s.DeviceSecret = &v
	return s
}

func (s *BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList) SetErrorMsg(v string) *BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList {
	s.ErrorMsg = &v
	return s
}

func (s *BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList) SetSn(v string) *BatchImportDeviceResponseBodyDataInvalidDetailListInvalidDetailList {
	s.Sn = &v
	return s
}

type BatchImportDeviceResponseBodyDataInvalidDeviceNameList struct {
	InvalidDeviceName []*string `json:"invalidDeviceName,omitempty" xml:"invalidDeviceName,omitempty" type:"Repeated"`
}

func (s BatchImportDeviceResponseBodyDataInvalidDeviceNameList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportDeviceResponseBodyDataInvalidDeviceNameList) GoString() string {
	return s.String()
}

func (s *BatchImportDeviceResponseBodyDataInvalidDeviceNameList) SetInvalidDeviceName(v []*string) *BatchImportDeviceResponseBodyDataInvalidDeviceNameList {
	s.InvalidDeviceName = v
	return s
}

type BatchImportDeviceResponseBodyDataInvalidDeviceSecretList struct {
	InvalidDeviceSecret []*string `json:"invalidDeviceSecret,omitempty" xml:"invalidDeviceSecret,omitempty" type:"Repeated"`
}

func (s BatchImportDeviceResponseBodyDataInvalidDeviceSecretList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportDeviceResponseBodyDataInvalidDeviceSecretList) GoString() string {
	return s.String()
}

func (s *BatchImportDeviceResponseBodyDataInvalidDeviceSecretList) SetInvalidDeviceSecret(v []*string) *BatchImportDeviceResponseBodyDataInvalidDeviceSecretList {
	s.InvalidDeviceSecret = v
	return s
}

type BatchImportDeviceResponseBodyDataInvalidSnList struct {
	InvalidSn []*string `json:"invalidSn,omitempty" xml:"invalidSn,omitempty" type:"Repeated"`
}

func (s BatchImportDeviceResponseBodyDataInvalidSnList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportDeviceResponseBodyDataInvalidSnList) GoString() string {
	return s.String()
}

func (s *BatchImportDeviceResponseBodyDataInvalidSnList) SetInvalidSn(v []*string) *BatchImportDeviceResponseBodyDataInvalidSnList {
	s.InvalidSn = v
	return s
}

type BatchImportDeviceResponseBodyDataRepeatedDeviceNameList struct {
	RepeatedDeviceName []*string `json:"repeatedDeviceName,omitempty" xml:"repeatedDeviceName,omitempty" type:"Repeated"`
}

func (s BatchImportDeviceResponseBodyDataRepeatedDeviceNameList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportDeviceResponseBodyDataRepeatedDeviceNameList) GoString() string {
	return s.String()
}

func (s *BatchImportDeviceResponseBodyDataRepeatedDeviceNameList) SetRepeatedDeviceName(v []*string) *BatchImportDeviceResponseBodyDataRepeatedDeviceNameList {
	s.RepeatedDeviceName = v
	return s
}

type BatchImportDeviceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchImportDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchImportDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchImportDeviceResponse) GoString() string {
	return s.String()
}

func (s *BatchImportDeviceResponse) SetHeaders(v map[string]*string) *BatchImportDeviceResponse {
	s.Headers = v
	return s
}

func (s *BatchImportDeviceResponse) SetStatusCode(v int32) *BatchImportDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchImportDeviceResponse) SetBody(v *BatchImportDeviceResponseBody) *BatchImportDeviceResponse {
	s.Body = v
	return s
}

type BatchImportVehicleDeviceRequest struct {
	DeviceList []*BatchImportVehicleDeviceRequestDeviceList `json:"DeviceList,omitempty" xml:"DeviceList,omitempty" type:"Repeated"`
	// BatchImportVehicleDevice
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BatchImportVehicleDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchImportVehicleDeviceRequest) GoString() string {
	return s.String()
}

func (s *BatchImportVehicleDeviceRequest) SetDeviceList(v []*BatchImportVehicleDeviceRequestDeviceList) *BatchImportVehicleDeviceRequest {
	s.DeviceList = v
	return s
}

func (s *BatchImportVehicleDeviceRequest) SetIotInstanceId(v string) *BatchImportVehicleDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchImportVehicleDeviceRequest) SetProductKey(v string) *BatchImportVehicleDeviceRequest {
	s.ProductKey = &v
	return s
}

type BatchImportVehicleDeviceRequestDeviceList struct {
	DeviceId     *string `json:"DeviceId,omitempty" xml:"DeviceId,omitempty"`
	DeviceModel  *string `json:"DeviceModel,omitempty" xml:"DeviceModel,omitempty"`
	DeviceName   *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	Manufacturer *string `json:"Manufacturer,omitempty" xml:"Manufacturer,omitempty"`
}

func (s BatchImportVehicleDeviceRequestDeviceList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportVehicleDeviceRequestDeviceList) GoString() string {
	return s.String()
}

func (s *BatchImportVehicleDeviceRequestDeviceList) SetDeviceId(v string) *BatchImportVehicleDeviceRequestDeviceList {
	s.DeviceId = &v
	return s
}

func (s *BatchImportVehicleDeviceRequestDeviceList) SetDeviceModel(v string) *BatchImportVehicleDeviceRequestDeviceList {
	s.DeviceModel = &v
	return s
}

func (s *BatchImportVehicleDeviceRequestDeviceList) SetDeviceName(v string) *BatchImportVehicleDeviceRequestDeviceList {
	s.DeviceName = &v
	return s
}

func (s *BatchImportVehicleDeviceRequestDeviceList) SetManufacturer(v string) *BatchImportVehicleDeviceRequestDeviceList {
	s.Manufacturer = &v
	return s
}

type BatchImportVehicleDeviceResponseBody struct {
	Code         *string                                   `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *BatchImportVehicleDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                   `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                     `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchImportVehicleDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchImportVehicleDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *BatchImportVehicleDeviceResponseBody) SetCode(v string) *BatchImportVehicleDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *BatchImportVehicleDeviceResponseBody) SetData(v *BatchImportVehicleDeviceResponseBodyData) *BatchImportVehicleDeviceResponseBody {
	s.Data = v
	return s
}

func (s *BatchImportVehicleDeviceResponseBody) SetErrorMessage(v string) *BatchImportVehicleDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchImportVehicleDeviceResponseBody) SetRequestId(v string) *BatchImportVehicleDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchImportVehicleDeviceResponseBody) SetSuccess(v bool) *BatchImportVehicleDeviceResponseBody {
	s.Success = &v
	return s
}

type BatchImportVehicleDeviceResponseBodyData struct {
	ApplyId                 *int64                                                           `json:"ApplyId,omitempty" xml:"ApplyId,omitempty"`
	InvalidDetailList       *BatchImportVehicleDeviceResponseBodyDataInvalidDetailList       `json:"InvalidDetailList,omitempty" xml:"InvalidDetailList,omitempty" type:"Struct"`
	InvalidDeviceIdList     *BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList     `json:"InvalidDeviceIdList,omitempty" xml:"InvalidDeviceIdList,omitempty" type:"Struct"`
	InvalidDeviceModelList  *BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList  `json:"InvalidDeviceModelList,omitempty" xml:"InvalidDeviceModelList,omitempty" type:"Struct"`
	InvalidDeviceNameList   *BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList   `json:"InvalidDeviceNameList,omitempty" xml:"InvalidDeviceNameList,omitempty" type:"Struct"`
	InvalidManufacturerList *BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList `json:"InvalidManufacturerList,omitempty" xml:"InvalidManufacturerList,omitempty" type:"Struct"`
	RepeatedDeviceIdList    *BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList    `json:"RepeatedDeviceIdList,omitempty" xml:"RepeatedDeviceIdList,omitempty" type:"Struct"`
	RepeatedDeviceNameList  *BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList  `json:"RepeatedDeviceNameList,omitempty" xml:"RepeatedDeviceNameList,omitempty" type:"Struct"`
}

func (s BatchImportVehicleDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s BatchImportVehicleDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *BatchImportVehicleDeviceResponseBodyData) SetApplyId(v int64) *BatchImportVehicleDeviceResponseBodyData {
	s.ApplyId = &v
	return s
}

func (s *BatchImportVehicleDeviceResponseBodyData) SetInvalidDetailList(v *BatchImportVehicleDeviceResponseBodyDataInvalidDetailList) *BatchImportVehicleDeviceResponseBodyData {
	s.InvalidDetailList = v
	return s
}

func (s *BatchImportVehicleDeviceResponseBodyData) SetInvalidDeviceIdList(v *BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList) *BatchImportVehicleDeviceResponseBodyData {
	s.InvalidDeviceIdList = v
	return s
}

func (s *BatchImportVehicleDeviceResponseBodyData) SetInvalidDeviceModelList(v *BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList) *BatchImportVehicleDeviceResponseBodyData {
	s.InvalidDeviceModelList = v
	return s
}

func (s *BatchImportVehicleDeviceResponseBodyData) SetInvalidDeviceNameList(v *BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList) *BatchImportVehicleDeviceResponseBodyData {
	s.InvalidDeviceNameList = v
	return s
}

func (s *BatchImportVehicleDeviceResponseBodyData) SetInvalidManufacturerList(v *BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList) *BatchImportVehicleDeviceResponseBodyData {
	s.InvalidManufacturerList = v
	return s
}

func (s *BatchImportVehicleDeviceResponseBodyData) SetRepeatedDeviceIdList(v *BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList) *BatchImportVehicleDeviceResponseBodyData {
	s.RepeatedDeviceIdList = v
	return s
}

func (s *BatchImportVehicleDeviceResponseBodyData) SetRepeatedDeviceNameList(v *BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList) *BatchImportVehicleDeviceResponseBodyData {
	s.RepeatedDeviceNameList = v
	return s
}

type BatchImportVehicleDeviceResponseBodyDataInvalidDetailList struct {
	InvalidDetailList []*BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList `json:"InvalidDetailList,omitempty" xml:"InvalidDetailList,omitempty" type:"Repeated"`
}

func (s BatchImportVehicleDeviceResponseBodyDataInvalidDetailList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportVehicleDeviceResponseBodyDataInvalidDetailList) GoString() string {
	return s.String()
}

func (s *BatchImportVehicleDeviceResponseBodyDataInvalidDetailList) SetInvalidDetailList(v []*BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList) *BatchImportVehicleDeviceResponseBodyDataInvalidDetailList {
	s.InvalidDetailList = v
	return s
}

type BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList struct {
	DeviceId     *string `json:"DeviceId,omitempty" xml:"DeviceId,omitempty"`
	DeviceModel  *string `json:"DeviceModel,omitempty" xml:"DeviceModel,omitempty"`
	DeviceName   *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	ErrorMsg     *string `json:"ErrorMsg,omitempty" xml:"ErrorMsg,omitempty"`
	Manufacturer *string `json:"Manufacturer,omitempty" xml:"Manufacturer,omitempty"`
}

func (s BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList) GoString() string {
	return s.String()
}

func (s *BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList) SetDeviceId(v string) *BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList {
	s.DeviceId = &v
	return s
}

func (s *BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList) SetDeviceModel(v string) *BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList {
	s.DeviceModel = &v
	return s
}

func (s *BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList) SetDeviceName(v string) *BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList {
	s.DeviceName = &v
	return s
}

func (s *BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList) SetErrorMsg(v string) *BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList {
	s.ErrorMsg = &v
	return s
}

func (s *BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList) SetManufacturer(v string) *BatchImportVehicleDeviceResponseBodyDataInvalidDetailListInvalidDetailList {
	s.Manufacturer = &v
	return s
}

type BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList struct {
	InvalidDeviceIdList []*string `json:"invalidDeviceIdList,omitempty" xml:"invalidDeviceIdList,omitempty" type:"Repeated"`
}

func (s BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList) GoString() string {
	return s.String()
}

func (s *BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList) SetInvalidDeviceIdList(v []*string) *BatchImportVehicleDeviceResponseBodyDataInvalidDeviceIdList {
	s.InvalidDeviceIdList = v
	return s
}

type BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList struct {
	InvalidDeviceModelList []*string `json:"invalidDeviceModelList,omitempty" xml:"invalidDeviceModelList,omitempty" type:"Repeated"`
}

func (s BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList) GoString() string {
	return s.String()
}

func (s *BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList) SetInvalidDeviceModelList(v []*string) *BatchImportVehicleDeviceResponseBodyDataInvalidDeviceModelList {
	s.InvalidDeviceModelList = v
	return s
}

type BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList struct {
	InvalidDeviceNameList []*string `json:"InvalidDeviceNameList,omitempty" xml:"InvalidDeviceNameList,omitempty" type:"Repeated"`
}

func (s BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList) GoString() string {
	return s.String()
}

func (s *BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList) SetInvalidDeviceNameList(v []*string) *BatchImportVehicleDeviceResponseBodyDataInvalidDeviceNameList {
	s.InvalidDeviceNameList = v
	return s
}

type BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList struct {
	InvalidManufacturerList []*string `json:"invalidManufacturerList,omitempty" xml:"invalidManufacturerList,omitempty" type:"Repeated"`
}

func (s BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList) GoString() string {
	return s.String()
}

func (s *BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList) SetInvalidManufacturerList(v []*string) *BatchImportVehicleDeviceResponseBodyDataInvalidManufacturerList {
	s.InvalidManufacturerList = v
	return s
}

type BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList struct {
	RepeatedDeviceIdList []*string `json:"repeatedDeviceIdList,omitempty" xml:"repeatedDeviceIdList,omitempty" type:"Repeated"`
}

func (s BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList) GoString() string {
	return s.String()
}

func (s *BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList) SetRepeatedDeviceIdList(v []*string) *BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceIdList {
	s.RepeatedDeviceIdList = v
	return s
}

type BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList struct {
	RepeatedDeviceNameList []*string `json:"RepeatedDeviceNameList,omitempty" xml:"RepeatedDeviceNameList,omitempty" type:"Repeated"`
}

func (s BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList) String() string {
	return tea.Prettify(s)
}

func (s BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList) GoString() string {
	return s.String()
}

func (s *BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList) SetRepeatedDeviceNameList(v []*string) *BatchImportVehicleDeviceResponseBodyDataRepeatedDeviceNameList {
	s.RepeatedDeviceNameList = v
	return s
}

type BatchImportVehicleDeviceResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchImportVehicleDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchImportVehicleDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchImportVehicleDeviceResponse) GoString() string {
	return s.String()
}

func (s *BatchImportVehicleDeviceResponse) SetHeaders(v map[string]*string) *BatchImportVehicleDeviceResponse {
	s.Headers = v
	return s
}

func (s *BatchImportVehicleDeviceResponse) SetStatusCode(v int32) *BatchImportVehicleDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchImportVehicleDeviceResponse) SetBody(v *BatchImportVehicleDeviceResponseBody) *BatchImportVehicleDeviceResponse {
	s.Body = v
	return s
}

type BatchPubRequest struct {
	DeviceName []*string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty" type:"Repeated"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The body of the message to be published. The maximum size of a message is 256 KB.
	//
	// To generate a message body, you must convert the raw message into binary data and perform Base64 encoding.
	MessageContent *string `json:"MessageContent,omitempty" xml:"MessageContent,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The quality of service (QoS) level of the message. Valid values:
	//
	// *   **0**: The message is published at most once.
	// *   **1**: The message is published at least once.
	//
	// Default value: **0**.
	//
	// >  IoT Platform stores QoS 1 messages for up to 7 days. IoT Platform does not store QoS 0 messages.
	Qos *int32 `json:"Qos,omitempty" xml:"Qos,omitempty"`
	// The suffix of the custom topic.
	//
	// A custom topic is in the following format: `/${productKey}/${deviceName}/user/${TopicShortName}`. ${TopicShortName} specifies the suffix.
	//
	// >  You must specify the Subscribe permission, or Publish and Subscribe permissions for the topic. Make sure that all devices subscribe to the topic.
	//
	// You can use the following methods to view custom topics:
	//
	// *   On the **Topic Categories** tab of the Product Details page, view the custom topics of the product.
	// *   On the **Topic List** tab of the Device Details page, view the custom topics to which the device has subscribed.
	// *   Call the [QueryProductTopic](~~69647~~) operation to query the custom topics of the product.
	TopicShortName *string `json:"TopicShortName,omitempty" xml:"TopicShortName,omitempty"`
}

func (s BatchPubRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchPubRequest) GoString() string {
	return s.String()
}

func (s *BatchPubRequest) SetDeviceName(v []*string) *BatchPubRequest {
	s.DeviceName = v
	return s
}

func (s *BatchPubRequest) SetIotInstanceId(v string) *BatchPubRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchPubRequest) SetMessageContent(v string) *BatchPubRequest {
	s.MessageContent = &v
	return s
}

func (s *BatchPubRequest) SetProductKey(v string) *BatchPubRequest {
	s.ProductKey = &v
	return s
}

func (s *BatchPubRequest) SetQos(v int32) *BatchPubRequest {
	s.Qos = &v
	return s
}

func (s *BatchPubRequest) SetTopicShortName(v string) *BatchPubRequest {
	s.TopicShortName = &v
	return s
}

type BatchPubResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchPubResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchPubResponseBody) GoString() string {
	return s.String()
}

func (s *BatchPubResponseBody) SetCode(v string) *BatchPubResponseBody {
	s.Code = &v
	return s
}

func (s *BatchPubResponseBody) SetErrorMessage(v string) *BatchPubResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchPubResponseBody) SetRequestId(v string) *BatchPubResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchPubResponseBody) SetSuccess(v bool) *BatchPubResponseBody {
	s.Success = &v
	return s
}

type BatchPubResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchPubResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchPubResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchPubResponse) GoString() string {
	return s.String()
}

func (s *BatchPubResponse) SetHeaders(v map[string]*string) *BatchPubResponse {
	s.Headers = v
	return s
}

func (s *BatchPubResponse) SetStatusCode(v int32) *BatchPubResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchPubResponse) SetBody(v *BatchPubResponseBody) *BatchPubResponse {
	s.Body = v
	return s
}

type BatchQueryDeviceDetailRequest struct {
	DeviceName []*string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty" type:"Repeated"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product to which the devices specified by the **DeviceName.N** parameter belong.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BatchQueryDeviceDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchQueryDeviceDetailRequest) GoString() string {
	return s.String()
}

func (s *BatchQueryDeviceDetailRequest) SetDeviceName(v []*string) *BatchQueryDeviceDetailRequest {
	s.DeviceName = v
	return s
}

func (s *BatchQueryDeviceDetailRequest) SetIotInstanceId(v string) *BatchQueryDeviceDetailRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchQueryDeviceDetailRequest) SetProductKey(v string) *BatchQueryDeviceDetailRequest {
	s.ProductKey = &v
	return s
}

type BatchQueryDeviceDetailResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The device details returned if the call is successful.
	Data *BatchQueryDeviceDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchQueryDeviceDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchQueryDeviceDetailResponseBody) GoString() string {
	return s.String()
}

func (s *BatchQueryDeviceDetailResponseBody) SetCode(v string) *BatchQueryDeviceDetailResponseBody {
	s.Code = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBody) SetData(v *BatchQueryDeviceDetailResponseBodyData) *BatchQueryDeviceDetailResponseBody {
	s.Data = v
	return s
}

func (s *BatchQueryDeviceDetailResponseBody) SetErrorMessage(v string) *BatchQueryDeviceDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBody) SetRequestId(v string) *BatchQueryDeviceDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBody) SetSuccess(v bool) *BatchQueryDeviceDetailResponseBody {
	s.Success = &v
	return s
}

type BatchQueryDeviceDetailResponseBodyData struct {
	Data []*BatchQueryDeviceDetailResponseBodyDataData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
}

func (s BatchQueryDeviceDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s BatchQueryDeviceDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *BatchQueryDeviceDetailResponseBodyData) SetData(v []*BatchQueryDeviceDetailResponseBodyDataData) *BatchQueryDeviceDetailResponseBodyData {
	s.Data = v
	return s
}

type BatchQueryDeviceDetailResponseBodyDataData struct {
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The DeviceSecret of the device.
	DeviceSecret *string `json:"DeviceSecret,omitempty" xml:"DeviceSecret,omitempty"`
	// The firmware version number of the device.
	FirmwareVersion *string `json:"FirmwareVersion,omitempty" xml:"FirmwareVersion,omitempty"`
	// The activation time of the device. The time is displayed in UTC.
	GmtActive *string `json:"GmtActive,omitempty" xml:"GmtActive,omitempty"`
	// The creation time of the device. The time is displayed in UTC.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The unique ID of the device. The device ID is issued by IoT Platform.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The alias of the device.
	Nickname *string `json:"Nickname,omitempty" xml:"Nickname,omitempty"`
	// The type of the node. Valid values:
	//
	// *   **0**: device. Sub-devices cannot be mounted on a gateway. A device can connect to IoT Platform directly or as a sub-device of a gateway.
	// *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain the topological relationships with sub-devices, and synchronize the topological relationships to IoT Platform.
	NodeType *int32 `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The name of the product to which the device belongs.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
	// The ID of the region where the device resides. The region is the same as the region where IoT Platform resides. You can view the region in the IoT Platform console.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The status of the device. Valid values:
	//
	// *   **ONLINE**: The device is online.
	// *   **OFFLINE**: The device is offline.
	// *   **UNACTIVE**: The device is not activated.
	// *   **DISABLE**: The device is disabled.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The activation time of the device. The time is displayed in UTC.
	UtcActive *string `json:"UtcActive,omitempty" xml:"UtcActive,omitempty"`
	// The creation time of the device. The time is displayed in UTC.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
}

func (s BatchQueryDeviceDetailResponseBodyDataData) String() string {
	return tea.Prettify(s)
}

func (s BatchQueryDeviceDetailResponseBodyDataData) GoString() string {
	return s.String()
}

func (s *BatchQueryDeviceDetailResponseBodyDataData) SetDeviceName(v string) *BatchQueryDeviceDetailResponseBodyDataData {
	s.DeviceName = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBodyDataData) SetDeviceSecret(v string) *BatchQueryDeviceDetailResponseBodyDataData {
	s.DeviceSecret = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBodyDataData) SetFirmwareVersion(v string) *BatchQueryDeviceDetailResponseBodyDataData {
	s.FirmwareVersion = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBodyDataData) SetGmtActive(v string) *BatchQueryDeviceDetailResponseBodyDataData {
	s.GmtActive = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBodyDataData) SetGmtCreate(v string) *BatchQueryDeviceDetailResponseBodyDataData {
	s.GmtCreate = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBodyDataData) SetIotId(v string) *BatchQueryDeviceDetailResponseBodyDataData {
	s.IotId = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBodyDataData) SetNickname(v string) *BatchQueryDeviceDetailResponseBodyDataData {
	s.Nickname = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBodyDataData) SetNodeType(v int32) *BatchQueryDeviceDetailResponseBodyDataData {
	s.NodeType = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBodyDataData) SetProductKey(v string) *BatchQueryDeviceDetailResponseBodyDataData {
	s.ProductKey = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBodyDataData) SetProductName(v string) *BatchQueryDeviceDetailResponseBodyDataData {
	s.ProductName = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBodyDataData) SetRegion(v string) *BatchQueryDeviceDetailResponseBodyDataData {
	s.Region = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBodyDataData) SetStatus(v string) *BatchQueryDeviceDetailResponseBodyDataData {
	s.Status = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBodyDataData) SetUtcActive(v string) *BatchQueryDeviceDetailResponseBodyDataData {
	s.UtcActive = &v
	return s
}

func (s *BatchQueryDeviceDetailResponseBodyDataData) SetUtcCreate(v string) *BatchQueryDeviceDetailResponseBodyDataData {
	s.UtcCreate = &v
	return s
}

type BatchQueryDeviceDetailResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchQueryDeviceDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchQueryDeviceDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchQueryDeviceDetailResponse) GoString() string {
	return s.String()
}

func (s *BatchQueryDeviceDetailResponse) SetHeaders(v map[string]*string) *BatchQueryDeviceDetailResponse {
	s.Headers = v
	return s
}

func (s *BatchQueryDeviceDetailResponse) SetStatusCode(v int32) *BatchQueryDeviceDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchQueryDeviceDetailResponse) SetBody(v *BatchQueryDeviceDetailResponseBody) *BatchQueryDeviceDetailResponse {
	s.Body = v
	return s
}

type BatchRegisterDeviceRequest struct {
	// The number of devices to be registered.
	//
	// >  You can register up to 10,000 devices in a single call.
	Count *int32 `json:"Count,omitempty" xml:"Count,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the devices belong.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BatchRegisterDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchRegisterDeviceRequest) GoString() string {
	return s.String()
}

func (s *BatchRegisterDeviceRequest) SetCount(v int32) *BatchRegisterDeviceRequest {
	s.Count = &v
	return s
}

func (s *BatchRegisterDeviceRequest) SetIotInstanceId(v string) *BatchRegisterDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchRegisterDeviceRequest) SetProductKey(v string) *BatchRegisterDeviceRequest {
	s.ProductKey = &v
	return s
}

type BatchRegisterDeviceResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call is successful.
	Data *BatchRegisterDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchRegisterDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchRegisterDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *BatchRegisterDeviceResponseBody) SetCode(v string) *BatchRegisterDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *BatchRegisterDeviceResponseBody) SetData(v *BatchRegisterDeviceResponseBodyData) *BatchRegisterDeviceResponseBody {
	s.Data = v
	return s
}

func (s *BatchRegisterDeviceResponseBody) SetErrorMessage(v string) *BatchRegisterDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchRegisterDeviceResponseBody) SetRequestId(v string) *BatchRegisterDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchRegisterDeviceResponseBody) SetSuccess(v bool) *BatchRegisterDeviceResponseBody {
	s.Success = &v
	return s
}

type BatchRegisterDeviceResponseBodyData struct {
	// The application ID (ApplyId) returned for the request if the call is successful.
	ApplyId *int64 `json:"ApplyId,omitempty" xml:"ApplyId,omitempty"`
}

func (s BatchRegisterDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s BatchRegisterDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *BatchRegisterDeviceResponseBodyData) SetApplyId(v int64) *BatchRegisterDeviceResponseBodyData {
	s.ApplyId = &v
	return s
}

type BatchRegisterDeviceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchRegisterDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchRegisterDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchRegisterDeviceResponse) GoString() string {
	return s.String()
}

func (s *BatchRegisterDeviceResponse) SetHeaders(v map[string]*string) *BatchRegisterDeviceResponse {
	s.Headers = v
	return s
}

func (s *BatchRegisterDeviceResponse) SetStatusCode(v int32) *BatchRegisterDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchRegisterDeviceResponse) SetBody(v *BatchRegisterDeviceResponseBody) *BatchRegisterDeviceResponse {
	s.Body = v
	return s
}

type BatchRegisterDeviceWithApplyIdRequest struct {
	// The ID of the application. The application ID is returned by the [BatchCheckDeviceNames](~~69482~~) operation.
	ApplyId *int64 `json:"ApplyId,omitempty" xml:"ApplyId,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BatchRegisterDeviceWithApplyIdRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchRegisterDeviceWithApplyIdRequest) GoString() string {
	return s.String()
}

func (s *BatchRegisterDeviceWithApplyIdRequest) SetApplyId(v int64) *BatchRegisterDeviceWithApplyIdRequest {
	s.ApplyId = &v
	return s
}

func (s *BatchRegisterDeviceWithApplyIdRequest) SetIotInstanceId(v string) *BatchRegisterDeviceWithApplyIdRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchRegisterDeviceWithApplyIdRequest) SetProductKey(v string) *BatchRegisterDeviceWithApplyIdRequest {
	s.ProductKey = &v
	return s
}

type BatchRegisterDeviceWithApplyIdResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call succeeds. For more information, see the following parameters.
	Data *BatchRegisterDeviceWithApplyIdResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchRegisterDeviceWithApplyIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchRegisterDeviceWithApplyIdResponseBody) GoString() string {
	return s.String()
}

func (s *BatchRegisterDeviceWithApplyIdResponseBody) SetCode(v string) *BatchRegisterDeviceWithApplyIdResponseBody {
	s.Code = &v
	return s
}

func (s *BatchRegisterDeviceWithApplyIdResponseBody) SetData(v *BatchRegisterDeviceWithApplyIdResponseBodyData) *BatchRegisterDeviceWithApplyIdResponseBody {
	s.Data = v
	return s
}

func (s *BatchRegisterDeviceWithApplyIdResponseBody) SetErrorMessage(v string) *BatchRegisterDeviceWithApplyIdResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchRegisterDeviceWithApplyIdResponseBody) SetRequestId(v string) *BatchRegisterDeviceWithApplyIdResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchRegisterDeviceWithApplyIdResponseBody) SetSuccess(v bool) *BatchRegisterDeviceWithApplyIdResponseBody {
	s.Success = &v
	return s
}

type BatchRegisterDeviceWithApplyIdResponseBodyData struct {
	// The application ID.
	ApplyId *int64 `json:"ApplyId,omitempty" xml:"ApplyId,omitempty"`
}

func (s BatchRegisterDeviceWithApplyIdResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s BatchRegisterDeviceWithApplyIdResponseBodyData) GoString() string {
	return s.String()
}

func (s *BatchRegisterDeviceWithApplyIdResponseBodyData) SetApplyId(v int64) *BatchRegisterDeviceWithApplyIdResponseBodyData {
	s.ApplyId = &v
	return s
}

type BatchRegisterDeviceWithApplyIdResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchRegisterDeviceWithApplyIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchRegisterDeviceWithApplyIdResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchRegisterDeviceWithApplyIdResponse) GoString() string {
	return s.String()
}

func (s *BatchRegisterDeviceWithApplyIdResponse) SetHeaders(v map[string]*string) *BatchRegisterDeviceWithApplyIdResponse {
	s.Headers = v
	return s
}

func (s *BatchRegisterDeviceWithApplyIdResponse) SetStatusCode(v int32) *BatchRegisterDeviceWithApplyIdResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchRegisterDeviceWithApplyIdResponse) SetBody(v *BatchRegisterDeviceWithApplyIdResponseBody) *BatchRegisterDeviceWithApplyIdResponse {
	s.Body = v
	return s
}

type BatchSetEdgeInstanceDeviceChannelRequest struct {
	ChannelId     *string   `json:"ChannelId,omitempty" xml:"ChannelId,omitempty"`
	DriverId      *string   `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	InstanceId    *string   `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotIds        []*string `json:"IotIds,omitempty" xml:"IotIds,omitempty" type:"Repeated"`
	IotInstanceId *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchSetEdgeInstanceDeviceChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchSetEdgeInstanceDeviceChannelRequest) GoString() string {
	return s.String()
}

func (s *BatchSetEdgeInstanceDeviceChannelRequest) SetChannelId(v string) *BatchSetEdgeInstanceDeviceChannelRequest {
	s.ChannelId = &v
	return s
}

func (s *BatchSetEdgeInstanceDeviceChannelRequest) SetDriverId(v string) *BatchSetEdgeInstanceDeviceChannelRequest {
	s.DriverId = &v
	return s
}

func (s *BatchSetEdgeInstanceDeviceChannelRequest) SetInstanceId(v string) *BatchSetEdgeInstanceDeviceChannelRequest {
	s.InstanceId = &v
	return s
}

func (s *BatchSetEdgeInstanceDeviceChannelRequest) SetIotIds(v []*string) *BatchSetEdgeInstanceDeviceChannelRequest {
	s.IotIds = v
	return s
}

func (s *BatchSetEdgeInstanceDeviceChannelRequest) SetIotInstanceId(v string) *BatchSetEdgeInstanceDeviceChannelRequest {
	s.IotInstanceId = &v
	return s
}

type BatchSetEdgeInstanceDeviceChannelResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchSetEdgeInstanceDeviceChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchSetEdgeInstanceDeviceChannelResponseBody) GoString() string {
	return s.String()
}

func (s *BatchSetEdgeInstanceDeviceChannelResponseBody) SetCode(v string) *BatchSetEdgeInstanceDeviceChannelResponseBody {
	s.Code = &v
	return s
}

func (s *BatchSetEdgeInstanceDeviceChannelResponseBody) SetErrorMessage(v string) *BatchSetEdgeInstanceDeviceChannelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchSetEdgeInstanceDeviceChannelResponseBody) SetRequestId(v string) *BatchSetEdgeInstanceDeviceChannelResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchSetEdgeInstanceDeviceChannelResponseBody) SetSuccess(v bool) *BatchSetEdgeInstanceDeviceChannelResponseBody {
	s.Success = &v
	return s
}

type BatchSetEdgeInstanceDeviceChannelResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchSetEdgeInstanceDeviceChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchSetEdgeInstanceDeviceChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchSetEdgeInstanceDeviceChannelResponse) GoString() string {
	return s.String()
}

func (s *BatchSetEdgeInstanceDeviceChannelResponse) SetHeaders(v map[string]*string) *BatchSetEdgeInstanceDeviceChannelResponse {
	s.Headers = v
	return s
}

func (s *BatchSetEdgeInstanceDeviceChannelResponse) SetStatusCode(v int32) *BatchSetEdgeInstanceDeviceChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchSetEdgeInstanceDeviceChannelResponse) SetBody(v *BatchSetEdgeInstanceDeviceChannelResponseBody) *BatchSetEdgeInstanceDeviceChannelResponse {
	s.Body = v
	return s
}

type BatchSetEdgeInstanceDeviceConfigRequest struct {
	DeviceConfigs []*BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs `json:"DeviceConfigs,omitempty" xml:"DeviceConfigs,omitempty" type:"Repeated"`
	InstanceId    *string                                                 `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string                                                 `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchSetEdgeInstanceDeviceConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchSetEdgeInstanceDeviceConfigRequest) GoString() string {
	return s.String()
}

func (s *BatchSetEdgeInstanceDeviceConfigRequest) SetDeviceConfigs(v []*BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs) *BatchSetEdgeInstanceDeviceConfigRequest {
	s.DeviceConfigs = v
	return s
}

func (s *BatchSetEdgeInstanceDeviceConfigRequest) SetInstanceId(v string) *BatchSetEdgeInstanceDeviceConfigRequest {
	s.InstanceId = &v
	return s
}

func (s *BatchSetEdgeInstanceDeviceConfigRequest) SetIotInstanceId(v string) *BatchSetEdgeInstanceDeviceConfigRequest {
	s.IotInstanceId = &v
	return s
}

type BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs struct {
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	IotId   *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
}

func (s BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs) String() string {
	return tea.Prettify(s)
}

func (s BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs) GoString() string {
	return s.String()
}

func (s *BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs) SetContent(v string) *BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs {
	s.Content = &v
	return s
}

func (s *BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs) SetIotId(v string) *BatchSetEdgeInstanceDeviceConfigRequestDeviceConfigs {
	s.IotId = &v
	return s
}

type BatchSetEdgeInstanceDeviceConfigResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchSetEdgeInstanceDeviceConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchSetEdgeInstanceDeviceConfigResponseBody) GoString() string {
	return s.String()
}

func (s *BatchSetEdgeInstanceDeviceConfigResponseBody) SetCode(v string) *BatchSetEdgeInstanceDeviceConfigResponseBody {
	s.Code = &v
	return s
}

func (s *BatchSetEdgeInstanceDeviceConfigResponseBody) SetErrorMessage(v string) *BatchSetEdgeInstanceDeviceConfigResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchSetEdgeInstanceDeviceConfigResponseBody) SetRequestId(v string) *BatchSetEdgeInstanceDeviceConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchSetEdgeInstanceDeviceConfigResponseBody) SetSuccess(v bool) *BatchSetEdgeInstanceDeviceConfigResponseBody {
	s.Success = &v
	return s
}

type BatchSetEdgeInstanceDeviceConfigResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchSetEdgeInstanceDeviceConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchSetEdgeInstanceDeviceConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchSetEdgeInstanceDeviceConfigResponse) GoString() string {
	return s.String()
}

func (s *BatchSetEdgeInstanceDeviceConfigResponse) SetHeaders(v map[string]*string) *BatchSetEdgeInstanceDeviceConfigResponse {
	s.Headers = v
	return s
}

func (s *BatchSetEdgeInstanceDeviceConfigResponse) SetStatusCode(v int32) *BatchSetEdgeInstanceDeviceConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchSetEdgeInstanceDeviceConfigResponse) SetBody(v *BatchSetEdgeInstanceDeviceConfigResponseBody) *BatchSetEdgeInstanceDeviceConfigResponse {
	s.Body = v
	return s
}

type BatchUnbindDeviceFromEdgeInstanceRequest struct {
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance from which you want to unbind multiple devices and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string   `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotIds     []*string `json:"IotIds,omitempty" xml:"IotIds,omitempty" type:"Repeated"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchUnbindDeviceFromEdgeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchUnbindDeviceFromEdgeInstanceRequest) GoString() string {
	return s.String()
}

func (s *BatchUnbindDeviceFromEdgeInstanceRequest) SetInstanceId(v string) *BatchUnbindDeviceFromEdgeInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *BatchUnbindDeviceFromEdgeInstanceRequest) SetIotIds(v []*string) *BatchUnbindDeviceFromEdgeInstanceRequest {
	s.IotIds = v
	return s
}

func (s *BatchUnbindDeviceFromEdgeInstanceRequest) SetIotInstanceId(v string) *BatchUnbindDeviceFromEdgeInstanceRequest {
	s.IotInstanceId = &v
	return s
}

type BatchUnbindDeviceFromEdgeInstanceResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchUnbindDeviceFromEdgeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchUnbindDeviceFromEdgeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *BatchUnbindDeviceFromEdgeInstanceResponseBody) SetCode(v string) *BatchUnbindDeviceFromEdgeInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *BatchUnbindDeviceFromEdgeInstanceResponseBody) SetErrorMessage(v string) *BatchUnbindDeviceFromEdgeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchUnbindDeviceFromEdgeInstanceResponseBody) SetRequestId(v string) *BatchUnbindDeviceFromEdgeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchUnbindDeviceFromEdgeInstanceResponseBody) SetSuccess(v bool) *BatchUnbindDeviceFromEdgeInstanceResponseBody {
	s.Success = &v
	return s
}

type BatchUnbindDeviceFromEdgeInstanceResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchUnbindDeviceFromEdgeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchUnbindDeviceFromEdgeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchUnbindDeviceFromEdgeInstanceResponse) GoString() string {
	return s.String()
}

func (s *BatchUnbindDeviceFromEdgeInstanceResponse) SetHeaders(v map[string]*string) *BatchUnbindDeviceFromEdgeInstanceResponse {
	s.Headers = v
	return s
}

func (s *BatchUnbindDeviceFromEdgeInstanceResponse) SetStatusCode(v int32) *BatchUnbindDeviceFromEdgeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchUnbindDeviceFromEdgeInstanceResponse) SetBody(v *BatchUnbindDeviceFromEdgeInstanceResponseBody) *BatchUnbindDeviceFromEdgeInstanceResponse {
	s.Body = v
	return s
}

type BatchUnbindProjectDevicesRequest struct {
	Devices       []*BatchUnbindProjectDevicesRequestDevices `json:"Devices,omitempty" xml:"Devices,omitempty" type:"Repeated"`
	IotInstanceId *string                                    `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProjectId     *string                                    `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s BatchUnbindProjectDevicesRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchUnbindProjectDevicesRequest) GoString() string {
	return s.String()
}

func (s *BatchUnbindProjectDevicesRequest) SetDevices(v []*BatchUnbindProjectDevicesRequestDevices) *BatchUnbindProjectDevicesRequest {
	s.Devices = v
	return s
}

func (s *BatchUnbindProjectDevicesRequest) SetIotInstanceId(v string) *BatchUnbindProjectDevicesRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchUnbindProjectDevicesRequest) SetProjectId(v string) *BatchUnbindProjectDevicesRequest {
	s.ProjectId = &v
	return s
}

type BatchUnbindProjectDevicesRequestDevices struct {
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BatchUnbindProjectDevicesRequestDevices) String() string {
	return tea.Prettify(s)
}

func (s BatchUnbindProjectDevicesRequestDevices) GoString() string {
	return s.String()
}

func (s *BatchUnbindProjectDevicesRequestDevices) SetDeviceName(v string) *BatchUnbindProjectDevicesRequestDevices {
	s.DeviceName = &v
	return s
}

func (s *BatchUnbindProjectDevicesRequestDevices) SetProductKey(v string) *BatchUnbindProjectDevicesRequestDevices {
	s.ProductKey = &v
	return s
}

type BatchUnbindProjectDevicesResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchUnbindProjectDevicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchUnbindProjectDevicesResponseBody) GoString() string {
	return s.String()
}

func (s *BatchUnbindProjectDevicesResponseBody) SetCode(v string) *BatchUnbindProjectDevicesResponseBody {
	s.Code = &v
	return s
}

func (s *BatchUnbindProjectDevicesResponseBody) SetData(v bool) *BatchUnbindProjectDevicesResponseBody {
	s.Data = &v
	return s
}

func (s *BatchUnbindProjectDevicesResponseBody) SetErrorMessage(v string) *BatchUnbindProjectDevicesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchUnbindProjectDevicesResponseBody) SetRequestId(v string) *BatchUnbindProjectDevicesResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchUnbindProjectDevicesResponseBody) SetSuccess(v bool) *BatchUnbindProjectDevicesResponseBody {
	s.Success = &v
	return s
}

type BatchUnbindProjectDevicesResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchUnbindProjectDevicesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchUnbindProjectDevicesResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchUnbindProjectDevicesResponse) GoString() string {
	return s.String()
}

func (s *BatchUnbindProjectDevicesResponse) SetHeaders(v map[string]*string) *BatchUnbindProjectDevicesResponse {
	s.Headers = v
	return s
}

func (s *BatchUnbindProjectDevicesResponse) SetStatusCode(v int32) *BatchUnbindProjectDevicesResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchUnbindProjectDevicesResponse) SetBody(v *BatchUnbindProjectDevicesResponseBody) *BatchUnbindProjectDevicesResponse {
	s.Body = v
	return s
}

type BatchUnbindProjectProductsRequest struct {
	IotInstanceId *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKeys   []*string `json:"ProductKeys,omitempty" xml:"ProductKeys,omitempty" type:"Repeated"`
	ProjectId     *string   `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s BatchUnbindProjectProductsRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchUnbindProjectProductsRequest) GoString() string {
	return s.String()
}

func (s *BatchUnbindProjectProductsRequest) SetIotInstanceId(v string) *BatchUnbindProjectProductsRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BatchUnbindProjectProductsRequest) SetProductKeys(v []*string) *BatchUnbindProjectProductsRequest {
	s.ProductKeys = v
	return s
}

func (s *BatchUnbindProjectProductsRequest) SetProjectId(v string) *BatchUnbindProjectProductsRequest {
	s.ProjectId = &v
	return s
}

type BatchUnbindProjectProductsResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchUnbindProjectProductsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchUnbindProjectProductsResponseBody) GoString() string {
	return s.String()
}

func (s *BatchUnbindProjectProductsResponseBody) SetCode(v string) *BatchUnbindProjectProductsResponseBody {
	s.Code = &v
	return s
}

func (s *BatchUnbindProjectProductsResponseBody) SetData(v bool) *BatchUnbindProjectProductsResponseBody {
	s.Data = &v
	return s
}

func (s *BatchUnbindProjectProductsResponseBody) SetErrorMessage(v string) *BatchUnbindProjectProductsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchUnbindProjectProductsResponseBody) SetRequestId(v string) *BatchUnbindProjectProductsResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchUnbindProjectProductsResponseBody) SetSuccess(v bool) *BatchUnbindProjectProductsResponseBody {
	s.Success = &v
	return s
}

type BatchUnbindProjectProductsResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchUnbindProjectProductsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchUnbindProjectProductsResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchUnbindProjectProductsResponse) GoString() string {
	return s.String()
}

func (s *BatchUnbindProjectProductsResponse) SetHeaders(v map[string]*string) *BatchUnbindProjectProductsResponse {
	s.Headers = v
	return s
}

func (s *BatchUnbindProjectProductsResponse) SetStatusCode(v int32) *BatchUnbindProjectProductsResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchUnbindProjectProductsResponse) SetBody(v *BatchUnbindProjectProductsResponseBody) *BatchUnbindProjectProductsResponse {
	s.Body = v
	return s
}

type BatchUpdateDeviceNicknameRequest struct {
	DeviceNicknameInfo []*BatchUpdateDeviceNicknameRequestDeviceNicknameInfo `json:"DeviceNicknameInfo,omitempty" xml:"DeviceNicknameInfo,omitempty" type:"Repeated"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BatchUpdateDeviceNicknameRequest) String() string {
	return tea.Prettify(s)
}

func (s BatchUpdateDeviceNicknameRequest) GoString() string {
	return s.String()
}

func (s *BatchUpdateDeviceNicknameRequest) SetDeviceNicknameInfo(v []*BatchUpdateDeviceNicknameRequestDeviceNicknameInfo) *BatchUpdateDeviceNicknameRequest {
	s.DeviceNicknameInfo = v
	return s
}

func (s *BatchUpdateDeviceNicknameRequest) SetIotInstanceId(v string) *BatchUpdateDeviceNicknameRequest {
	s.IotInstanceId = &v
	return s
}

type BatchUpdateDeviceNicknameRequestDeviceNicknameInfo struct {
	// The DeviceName of the device.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device.
	//
	// >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The new alias of the device. The alias must be 4 to 32 characters in length, and can contain letters, digits, and underscores (\_). Each Chinese character is counted as two characters.
	//
	// >  If you do not specify this parameter, the original alias of the device will be deleted.
	Nickname *string `json:"Nickname,omitempty" xml:"Nickname,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BatchUpdateDeviceNicknameRequestDeviceNicknameInfo) String() string {
	return tea.Prettify(s)
}

func (s BatchUpdateDeviceNicknameRequestDeviceNicknameInfo) GoString() string {
	return s.String()
}

func (s *BatchUpdateDeviceNicknameRequestDeviceNicknameInfo) SetDeviceName(v string) *BatchUpdateDeviceNicknameRequestDeviceNicknameInfo {
	s.DeviceName = &v
	return s
}

func (s *BatchUpdateDeviceNicknameRequestDeviceNicknameInfo) SetIotId(v string) *BatchUpdateDeviceNicknameRequestDeviceNicknameInfo {
	s.IotId = &v
	return s
}

func (s *BatchUpdateDeviceNicknameRequestDeviceNicknameInfo) SetNickname(v string) *BatchUpdateDeviceNicknameRequestDeviceNicknameInfo {
	s.Nickname = &v
	return s
}

func (s *BatchUpdateDeviceNicknameRequestDeviceNicknameInfo) SetProductKey(v string) *BatchUpdateDeviceNicknameRequestDeviceNicknameInfo {
	s.ProductKey = &v
	return s
}

type BatchUpdateDeviceNicknameResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BatchUpdateDeviceNicknameResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BatchUpdateDeviceNicknameResponseBody) GoString() string {
	return s.String()
}

func (s *BatchUpdateDeviceNicknameResponseBody) SetCode(v string) *BatchUpdateDeviceNicknameResponseBody {
	s.Code = &v
	return s
}

func (s *BatchUpdateDeviceNicknameResponseBody) SetErrorMessage(v string) *BatchUpdateDeviceNicknameResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BatchUpdateDeviceNicknameResponseBody) SetRequestId(v string) *BatchUpdateDeviceNicknameResponseBody {
	s.RequestId = &v
	return s
}

func (s *BatchUpdateDeviceNicknameResponseBody) SetSuccess(v bool) *BatchUpdateDeviceNicknameResponseBody {
	s.Success = &v
	return s
}

type BatchUpdateDeviceNicknameResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BatchUpdateDeviceNicknameResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BatchUpdateDeviceNicknameResponse) String() string {
	return tea.Prettify(s)
}

func (s BatchUpdateDeviceNicknameResponse) GoString() string {
	return s.String()
}

func (s *BatchUpdateDeviceNicknameResponse) SetHeaders(v map[string]*string) *BatchUpdateDeviceNicknameResponse {
	s.Headers = v
	return s
}

func (s *BatchUpdateDeviceNicknameResponse) SetStatusCode(v int32) *BatchUpdateDeviceNicknameResponse {
	s.StatusCode = &v
	return s
}

func (s *BatchUpdateDeviceNicknameResponse) SetBody(v *BatchUpdateDeviceNicknameResponseBody) *BatchUpdateDeviceNicknameResponse {
	s.Body = v
	return s
}

type BindApplicationToEdgeInstanceRequest struct {
	ApplicationId      *string `json:"ApplicationId,omitempty" xml:"ApplicationId,omitempty"`
	ApplicationVersion *string `json:"ApplicationVersion,omitempty" xml:"ApplicationVersion,omitempty"`
	InstanceId         *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId      *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s BindApplicationToEdgeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s BindApplicationToEdgeInstanceRequest) GoString() string {
	return s.String()
}

func (s *BindApplicationToEdgeInstanceRequest) SetApplicationId(v string) *BindApplicationToEdgeInstanceRequest {
	s.ApplicationId = &v
	return s
}

func (s *BindApplicationToEdgeInstanceRequest) SetApplicationVersion(v string) *BindApplicationToEdgeInstanceRequest {
	s.ApplicationVersion = &v
	return s
}

func (s *BindApplicationToEdgeInstanceRequest) SetInstanceId(v string) *BindApplicationToEdgeInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *BindApplicationToEdgeInstanceRequest) SetIotInstanceId(v string) *BindApplicationToEdgeInstanceRequest {
	s.IotInstanceId = &v
	return s
}

type BindApplicationToEdgeInstanceResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BindApplicationToEdgeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BindApplicationToEdgeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *BindApplicationToEdgeInstanceResponseBody) SetCode(v string) *BindApplicationToEdgeInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *BindApplicationToEdgeInstanceResponseBody) SetErrorMessage(v string) *BindApplicationToEdgeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BindApplicationToEdgeInstanceResponseBody) SetRequestId(v string) *BindApplicationToEdgeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *BindApplicationToEdgeInstanceResponseBody) SetSuccess(v bool) *BindApplicationToEdgeInstanceResponseBody {
	s.Success = &v
	return s
}

type BindApplicationToEdgeInstanceResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BindApplicationToEdgeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BindApplicationToEdgeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s BindApplicationToEdgeInstanceResponse) GoString() string {
	return s.String()
}

func (s *BindApplicationToEdgeInstanceResponse) SetHeaders(v map[string]*string) *BindApplicationToEdgeInstanceResponse {
	s.Headers = v
	return s
}

func (s *BindApplicationToEdgeInstanceResponse) SetStatusCode(v int32) *BindApplicationToEdgeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *BindApplicationToEdgeInstanceResponse) SetBody(v *BindApplicationToEdgeInstanceResponseBody) *BindApplicationToEdgeInstanceResponse {
	s.Body = v
	return s
}

type BindDriverToEdgeInstanceRequest struct {
	// The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver that you want to bind and obtain the driver ID.
	//
	// You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The version number of the driver. By default, if you do not specify this parameter, the latest version of the driver is used.
	DriverVersion *string `json:"DriverVersion,omitempty" xml:"DriverVersion,omitempty"`
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance to which you want to bind a driver and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the order.
	//
	// >  This parameter is required if you use a third-party driver that is purchased from the IoT marketplace. If an official or self-developed driver is used, you do not need to specify this parameter.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
}

func (s BindDriverToEdgeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s BindDriverToEdgeInstanceRequest) GoString() string {
	return s.String()
}

func (s *BindDriverToEdgeInstanceRequest) SetDriverId(v string) *BindDriverToEdgeInstanceRequest {
	s.DriverId = &v
	return s
}

func (s *BindDriverToEdgeInstanceRequest) SetDriverVersion(v string) *BindDriverToEdgeInstanceRequest {
	s.DriverVersion = &v
	return s
}

func (s *BindDriverToEdgeInstanceRequest) SetInstanceId(v string) *BindDriverToEdgeInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *BindDriverToEdgeInstanceRequest) SetIotInstanceId(v string) *BindDriverToEdgeInstanceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BindDriverToEdgeInstanceRequest) SetOrderId(v string) *BindDriverToEdgeInstanceRequest {
	s.OrderId = &v
	return s
}

type BindDriverToEdgeInstanceResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BindDriverToEdgeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BindDriverToEdgeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *BindDriverToEdgeInstanceResponseBody) SetCode(v string) *BindDriverToEdgeInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *BindDriverToEdgeInstanceResponseBody) SetErrorMessage(v string) *BindDriverToEdgeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BindDriverToEdgeInstanceResponseBody) SetRequestId(v string) *BindDriverToEdgeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *BindDriverToEdgeInstanceResponseBody) SetSuccess(v bool) *BindDriverToEdgeInstanceResponseBody {
	s.Success = &v
	return s
}

type BindDriverToEdgeInstanceResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BindDriverToEdgeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BindDriverToEdgeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s BindDriverToEdgeInstanceResponse) GoString() string {
	return s.String()
}

func (s *BindDriverToEdgeInstanceResponse) SetHeaders(v map[string]*string) *BindDriverToEdgeInstanceResponse {
	s.Headers = v
	return s
}

func (s *BindDriverToEdgeInstanceResponse) SetStatusCode(v int32) *BindDriverToEdgeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *BindDriverToEdgeInstanceResponse) SetBody(v *BindDriverToEdgeInstanceResponseBody) *BindDriverToEdgeInstanceResponse {
	s.Body = v
	return s
}

type BindGatewayToEdgeInstanceRequest struct {
	// The name of the gateway.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance to which you want to bind a gateway and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the gateway in IoT Platform. This parameter corresponds to the combination of the **ProductKey** and **DeviceName** parameters.
	//
	// >  If you specify this parameter, you do not need to specify the **ProductKey** or **DeviceName** parameter. If you use the **IotId** parameter and the combination of the **ProductKey** and **DeviceName** parameters, only the **IotId** parameter takes effect.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The key that uniquely identifies the product to which the gateway belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BindGatewayToEdgeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s BindGatewayToEdgeInstanceRequest) GoString() string {
	return s.String()
}

func (s *BindGatewayToEdgeInstanceRequest) SetDeviceName(v string) *BindGatewayToEdgeInstanceRequest {
	s.DeviceName = &v
	return s
}

func (s *BindGatewayToEdgeInstanceRequest) SetInstanceId(v string) *BindGatewayToEdgeInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *BindGatewayToEdgeInstanceRequest) SetIotId(v string) *BindGatewayToEdgeInstanceRequest {
	s.IotId = &v
	return s
}

func (s *BindGatewayToEdgeInstanceRequest) SetIotInstanceId(v string) *BindGatewayToEdgeInstanceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BindGatewayToEdgeInstanceRequest) SetProductKey(v string) *BindGatewayToEdgeInstanceRequest {
	s.ProductKey = &v
	return s
}

type BindGatewayToEdgeInstanceResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BindGatewayToEdgeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BindGatewayToEdgeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *BindGatewayToEdgeInstanceResponseBody) SetCode(v string) *BindGatewayToEdgeInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *BindGatewayToEdgeInstanceResponseBody) SetErrorMessage(v string) *BindGatewayToEdgeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BindGatewayToEdgeInstanceResponseBody) SetRequestId(v string) *BindGatewayToEdgeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *BindGatewayToEdgeInstanceResponseBody) SetSuccess(v bool) *BindGatewayToEdgeInstanceResponseBody {
	s.Success = &v
	return s
}

type BindGatewayToEdgeInstanceResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BindGatewayToEdgeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BindGatewayToEdgeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s BindGatewayToEdgeInstanceResponse) GoString() string {
	return s.String()
}

func (s *BindGatewayToEdgeInstanceResponse) SetHeaders(v map[string]*string) *BindGatewayToEdgeInstanceResponse {
	s.Headers = v
	return s
}

func (s *BindGatewayToEdgeInstanceResponse) SetStatusCode(v int32) *BindGatewayToEdgeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *BindGatewayToEdgeInstanceResponse) SetBody(v *BindGatewayToEdgeInstanceResponseBody) *BindGatewayToEdgeInstanceResponse {
	s.Body = v
	return s
}

type BindLicenseDeviceRequest struct {
	DeviceNameList []*string `json:"DeviceNameList,omitempty" xml:"DeviceNameList,omitempty" type:"Repeated"`
	IotIdList      []*string `json:"IotIdList,omitempty" xml:"IotIdList,omitempty" type:"Repeated"`
	// The ID of the Enterprise Edition instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The license type that specifies the audio and video specifications. Valid values: **480P** and **720P**.
	LicenseCode *string `json:"LicenseCode,omitempty" xml:"LicenseCode,omitempty"`
	// The **ProductKey** of the product to which the devices belong.
	//
	// You can go to the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products of the instance.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BindLicenseDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s BindLicenseDeviceRequest) GoString() string {
	return s.String()
}

func (s *BindLicenseDeviceRequest) SetDeviceNameList(v []*string) *BindLicenseDeviceRequest {
	s.DeviceNameList = v
	return s
}

func (s *BindLicenseDeviceRequest) SetIotIdList(v []*string) *BindLicenseDeviceRequest {
	s.IotIdList = v
	return s
}

func (s *BindLicenseDeviceRequest) SetIotInstanceId(v string) *BindLicenseDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BindLicenseDeviceRequest) SetLicenseCode(v string) *BindLicenseDeviceRequest {
	s.LicenseCode = &v
	return s
}

func (s *BindLicenseDeviceRequest) SetProductKey(v string) *BindLicenseDeviceRequest {
	s.ProductKey = &v
	return s
}

type BindLicenseDeviceResponseBody struct {
	// The error code returned if the request fails. For more information, see the "Error codes" section in this topic.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the batch binding operation.
	Data *BindLicenseDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BindLicenseDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BindLicenseDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *BindLicenseDeviceResponseBody) SetCode(v string) *BindLicenseDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *BindLicenseDeviceResponseBody) SetData(v *BindLicenseDeviceResponseBodyData) *BindLicenseDeviceResponseBody {
	s.Data = v
	return s
}

func (s *BindLicenseDeviceResponseBody) SetErrorMessage(v string) *BindLicenseDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BindLicenseDeviceResponseBody) SetRequestId(v string) *BindLicenseDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *BindLicenseDeviceResponseBody) SetSuccess(v bool) *BindLicenseDeviceResponseBody {
	s.Success = &v
	return s
}

type BindLicenseDeviceResponseBodyData struct {
	// The unique ID that can be used to query the progress of the batch binding operation.
	CheckProgressId *string `json:"CheckProgressId,omitempty" xml:"CheckProgressId,omitempty"`
	// The number of devices that failed to be bound to the license.
	FailSum *int64 `json:"FailSum,omitempty" xml:"FailSum,omitempty"`
	// The progress of the batch binding operation. The progress is a percentage. Valid values: 1 to 100.
	Progress *int32 `json:"Progress,omitempty" xml:"Progress,omitempty"`
	// The URL of the file that contains unbound devices. The devices failed to be bound to the license.
	ResultCsvFile *string `json:"ResultCsvFile,omitempty" xml:"ResultCsvFile,omitempty"`
	// The number of devices to which the license is successfully bound.
	SuccessSum *int64 `json:"SuccessSum,omitempty" xml:"SuccessSum,omitempty"`
}

func (s BindLicenseDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s BindLicenseDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *BindLicenseDeviceResponseBodyData) SetCheckProgressId(v string) *BindLicenseDeviceResponseBodyData {
	s.CheckProgressId = &v
	return s
}

func (s *BindLicenseDeviceResponseBodyData) SetFailSum(v int64) *BindLicenseDeviceResponseBodyData {
	s.FailSum = &v
	return s
}

func (s *BindLicenseDeviceResponseBodyData) SetProgress(v int32) *BindLicenseDeviceResponseBodyData {
	s.Progress = &v
	return s
}

func (s *BindLicenseDeviceResponseBodyData) SetResultCsvFile(v string) *BindLicenseDeviceResponseBodyData {
	s.ResultCsvFile = &v
	return s
}

func (s *BindLicenseDeviceResponseBodyData) SetSuccessSum(v int64) *BindLicenseDeviceResponseBodyData {
	s.SuccessSum = &v
	return s
}

type BindLicenseDeviceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BindLicenseDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BindLicenseDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s BindLicenseDeviceResponse) GoString() string {
	return s.String()
}

func (s *BindLicenseDeviceResponse) SetHeaders(v map[string]*string) *BindLicenseDeviceResponse {
	s.Headers = v
	return s
}

func (s *BindLicenseDeviceResponse) SetStatusCode(v int32) *BindLicenseDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *BindLicenseDeviceResponse) SetBody(v *BindLicenseDeviceResponseBody) *BindLicenseDeviceResponse {
	s.Body = v
	return s
}

type BindLicenseProductRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	LicenseCode   *string `json:"LicenseCode,omitempty" xml:"LicenseCode,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s BindLicenseProductRequest) String() string {
	return tea.Prettify(s)
}

func (s BindLicenseProductRequest) GoString() string {
	return s.String()
}

func (s *BindLicenseProductRequest) SetIotInstanceId(v string) *BindLicenseProductRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BindLicenseProductRequest) SetLicenseCode(v string) *BindLicenseProductRequest {
	s.LicenseCode = &v
	return s
}

func (s *BindLicenseProductRequest) SetProductKey(v string) *BindLicenseProductRequest {
	s.ProductKey = &v
	return s
}

type BindLicenseProductResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BindLicenseProductResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BindLicenseProductResponseBody) GoString() string {
	return s.String()
}

func (s *BindLicenseProductResponseBody) SetCode(v string) *BindLicenseProductResponseBody {
	s.Code = &v
	return s
}

func (s *BindLicenseProductResponseBody) SetData(v bool) *BindLicenseProductResponseBody {
	s.Data = &v
	return s
}

func (s *BindLicenseProductResponseBody) SetErrorMessage(v string) *BindLicenseProductResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BindLicenseProductResponseBody) SetRequestId(v string) *BindLicenseProductResponseBody {
	s.RequestId = &v
	return s
}

func (s *BindLicenseProductResponseBody) SetSuccess(v bool) *BindLicenseProductResponseBody {
	s.Success = &v
	return s
}

type BindLicenseProductResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BindLicenseProductResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BindLicenseProductResponse) String() string {
	return tea.Prettify(s)
}

func (s BindLicenseProductResponse) GoString() string {
	return s.String()
}

func (s *BindLicenseProductResponse) SetHeaders(v map[string]*string) *BindLicenseProductResponse {
	s.Headers = v
	return s
}

func (s *BindLicenseProductResponse) SetStatusCode(v int32) *BindLicenseProductResponse {
	s.StatusCode = &v
	return s
}

func (s *BindLicenseProductResponse) SetBody(v *BindLicenseProductResponseBody) *BindLicenseProductResponse {
	s.Body = v
	return s
}

type BindRoleToEdgeInstanceRequest struct {
	InstanceId    *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	RoleArn       *string `json:"RoleArn,omitempty" xml:"RoleArn,omitempty"`
	RoleName      *string `json:"RoleName,omitempty" xml:"RoleName,omitempty"`
}

func (s BindRoleToEdgeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s BindRoleToEdgeInstanceRequest) GoString() string {
	return s.String()
}

func (s *BindRoleToEdgeInstanceRequest) SetInstanceId(v string) *BindRoleToEdgeInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *BindRoleToEdgeInstanceRequest) SetIotInstanceId(v string) *BindRoleToEdgeInstanceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BindRoleToEdgeInstanceRequest) SetRoleArn(v string) *BindRoleToEdgeInstanceRequest {
	s.RoleArn = &v
	return s
}

func (s *BindRoleToEdgeInstanceRequest) SetRoleName(v string) *BindRoleToEdgeInstanceRequest {
	s.RoleName = &v
	return s
}

type BindRoleToEdgeInstanceResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BindRoleToEdgeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BindRoleToEdgeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *BindRoleToEdgeInstanceResponseBody) SetCode(v string) *BindRoleToEdgeInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *BindRoleToEdgeInstanceResponseBody) SetErrorMessage(v string) *BindRoleToEdgeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BindRoleToEdgeInstanceResponseBody) SetRequestId(v string) *BindRoleToEdgeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *BindRoleToEdgeInstanceResponseBody) SetSuccess(v bool) *BindRoleToEdgeInstanceResponseBody {
	s.Success = &v
	return s
}

type BindRoleToEdgeInstanceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BindRoleToEdgeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BindRoleToEdgeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s BindRoleToEdgeInstanceResponse) GoString() string {
	return s.String()
}

func (s *BindRoleToEdgeInstanceResponse) SetHeaders(v map[string]*string) *BindRoleToEdgeInstanceResponse {
	s.Headers = v
	return s
}

func (s *BindRoleToEdgeInstanceResponse) SetStatusCode(v int32) *BindRoleToEdgeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *BindRoleToEdgeInstanceResponse) SetBody(v *BindRoleToEdgeInstanceResponseBody) *BindRoleToEdgeInstanceResponse {
	s.Body = v
	return s
}

type BindSceneRuleToEdgeInstanceRequest struct {
	InstanceId    *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	RuleId        *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s BindSceneRuleToEdgeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s BindSceneRuleToEdgeInstanceRequest) GoString() string {
	return s.String()
}

func (s *BindSceneRuleToEdgeInstanceRequest) SetInstanceId(v string) *BindSceneRuleToEdgeInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *BindSceneRuleToEdgeInstanceRequest) SetIotInstanceId(v string) *BindSceneRuleToEdgeInstanceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *BindSceneRuleToEdgeInstanceRequest) SetRuleId(v string) *BindSceneRuleToEdgeInstanceRequest {
	s.RuleId = &v
	return s
}

type BindSceneRuleToEdgeInstanceResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s BindSceneRuleToEdgeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s BindSceneRuleToEdgeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *BindSceneRuleToEdgeInstanceResponseBody) SetCode(v string) *BindSceneRuleToEdgeInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *BindSceneRuleToEdgeInstanceResponseBody) SetErrorMessage(v string) *BindSceneRuleToEdgeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *BindSceneRuleToEdgeInstanceResponseBody) SetRequestId(v string) *BindSceneRuleToEdgeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *BindSceneRuleToEdgeInstanceResponseBody) SetSuccess(v bool) *BindSceneRuleToEdgeInstanceResponseBody {
	s.Success = &v
	return s
}

type BindSceneRuleToEdgeInstanceResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *BindSceneRuleToEdgeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s BindSceneRuleToEdgeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s BindSceneRuleToEdgeInstanceResponse) GoString() string {
	return s.String()
}

func (s *BindSceneRuleToEdgeInstanceResponse) SetHeaders(v map[string]*string) *BindSceneRuleToEdgeInstanceResponse {
	s.Headers = v
	return s
}

func (s *BindSceneRuleToEdgeInstanceResponse) SetStatusCode(v int32) *BindSceneRuleToEdgeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *BindSceneRuleToEdgeInstanceResponse) SetBody(v *BindSceneRuleToEdgeInstanceResponseBody) *BindSceneRuleToEdgeInstanceResponse {
	s.Body = v
	return s
}

type CancelJobRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	JobId         *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s CancelJobRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelJobRequest) GoString() string {
	return s.String()
}

func (s *CancelJobRequest) SetIotInstanceId(v string) *CancelJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CancelJobRequest) SetJobId(v string) *CancelJobRequest {
	s.JobId = &v
	return s
}

type CancelJobResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CancelJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelJobResponseBody) GoString() string {
	return s.String()
}

func (s *CancelJobResponseBody) SetCode(v string) *CancelJobResponseBody {
	s.Code = &v
	return s
}

func (s *CancelJobResponseBody) SetErrorMessage(v string) *CancelJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CancelJobResponseBody) SetRequestId(v string) *CancelJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelJobResponseBody) SetSuccess(v bool) *CancelJobResponseBody {
	s.Success = &v
	return s
}

type CancelJobResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CancelJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CancelJobResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelJobResponse) GoString() string {
	return s.String()
}

func (s *CancelJobResponse) SetHeaders(v map[string]*string) *CancelJobResponse {
	s.Headers = v
	return s
}

func (s *CancelJobResponse) SetStatusCode(v int32) *CancelJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelJobResponse) SetBody(v *CancelJobResponseBody) *CancelJobResponse {
	s.Body = v
	return s
}

type CancelOTAStrategyByJobRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the update batch.
	//
	// After you call the [CreateOTADynamicUpgradeJob](~~147887~~) operation to create an update batch, the **JobId** parameter is returned. You can also view the batch ID on the **Firmware Details** page of the IoT Platform console.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s CancelOTAStrategyByJobRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelOTAStrategyByJobRequest) GoString() string {
	return s.String()
}

func (s *CancelOTAStrategyByJobRequest) SetIotInstanceId(v string) *CancelOTAStrategyByJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CancelOTAStrategyByJobRequest) SetJobId(v string) *CancelOTAStrategyByJobRequest {
	s.JobId = &v
	return s
}

type CancelOTAStrategyByJobResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CancelOTAStrategyByJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelOTAStrategyByJobResponseBody) GoString() string {
	return s.String()
}

func (s *CancelOTAStrategyByJobResponseBody) SetCode(v string) *CancelOTAStrategyByJobResponseBody {
	s.Code = &v
	return s
}

func (s *CancelOTAStrategyByJobResponseBody) SetErrorMessage(v string) *CancelOTAStrategyByJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CancelOTAStrategyByJobResponseBody) SetRequestId(v string) *CancelOTAStrategyByJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelOTAStrategyByJobResponseBody) SetSuccess(v bool) *CancelOTAStrategyByJobResponseBody {
	s.Success = &v
	return s
}

type CancelOTAStrategyByJobResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CancelOTAStrategyByJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CancelOTAStrategyByJobResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelOTAStrategyByJobResponse) GoString() string {
	return s.String()
}

func (s *CancelOTAStrategyByJobResponse) SetHeaders(v map[string]*string) *CancelOTAStrategyByJobResponse {
	s.Headers = v
	return s
}

func (s *CancelOTAStrategyByJobResponse) SetStatusCode(v int32) *CancelOTAStrategyByJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelOTAStrategyByJobResponse) SetBody(v *CancelOTAStrategyByJobResponseBody) *CancelOTAStrategyByJobResponse {
	s.Body = v
	return s
}

type CancelOTATaskByDeviceRequest struct {
	DeviceName []*string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty" type:"Repeated"`
	// The unique ID of the OTA update package.
	//
	// An update package ID is returned after you call the [CreateOTAFirmware](~~147311~~) operation to create the update package.
	//
	// You can call the [ListOTAFirmware](~~147450~~) operation and view the update package ID in the response.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the update batch. If you configure this parameter, only the device update tasks in the specified update batch are deleted.
	//
	// After you call the [CreateOTAVerifyJob](~~147480~~), [CreateOTAStaticUpgradeJob](~~147496~~), or [CreateOTADynamicUpgradeJob](~~147887~~) operation to create a device update task, you can obtain the value of the **JobId** parameter. You can also view the batch ID on the **Firmware Details** page in the IoT Platform console.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s CancelOTATaskByDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelOTATaskByDeviceRequest) GoString() string {
	return s.String()
}

func (s *CancelOTATaskByDeviceRequest) SetDeviceName(v []*string) *CancelOTATaskByDeviceRequest {
	s.DeviceName = v
	return s
}

func (s *CancelOTATaskByDeviceRequest) SetFirmwareId(v string) *CancelOTATaskByDeviceRequest {
	s.FirmwareId = &v
	return s
}

func (s *CancelOTATaskByDeviceRequest) SetIotInstanceId(v string) *CancelOTATaskByDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CancelOTATaskByDeviceRequest) SetJobId(v string) *CancelOTATaskByDeviceRequest {
	s.JobId = &v
	return s
}

func (s *CancelOTATaskByDeviceRequest) SetProductKey(v string) *CancelOTATaskByDeviceRequest {
	s.ProductKey = &v
	return s
}

type CancelOTATaskByDeviceResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CancelOTATaskByDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelOTATaskByDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *CancelOTATaskByDeviceResponseBody) SetCode(v string) *CancelOTATaskByDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *CancelOTATaskByDeviceResponseBody) SetErrorMessage(v string) *CancelOTATaskByDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CancelOTATaskByDeviceResponseBody) SetRequestId(v string) *CancelOTATaskByDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelOTATaskByDeviceResponseBody) SetSuccess(v bool) *CancelOTATaskByDeviceResponseBody {
	s.Success = &v
	return s
}

type CancelOTATaskByDeviceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CancelOTATaskByDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CancelOTATaskByDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelOTATaskByDeviceResponse) GoString() string {
	return s.String()
}

func (s *CancelOTATaskByDeviceResponse) SetHeaders(v map[string]*string) *CancelOTATaskByDeviceResponse {
	s.Headers = v
	return s
}

func (s *CancelOTATaskByDeviceResponse) SetStatusCode(v int32) *CancelOTATaskByDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelOTATaskByDeviceResponse) SetBody(v *CancelOTATaskByDeviceResponseBody) *CancelOTATaskByDeviceResponse {
	s.Body = v
	return s
}

type CancelOTATaskByJobRequest struct {
	// Specifies whether to cancel the update tasks that are in the **IN_PROGRESS** state in an update batch. Default value: false. Valid values:
	//
	// *   **true**: cancel the update tasks that are in the IN_PROGRESS state.
	// *   **false**: do not cancel the update tasks that are in the IN_PROGRESS state.
	CancelInProgressTask *bool `json:"CancelInProgressTask,omitempty" xml:"CancelInProgressTask,omitempty"`
	// Specifies whether to cancel the update tasks that are in the **NOTIFIED** state in an update batch. Default value: false. Valid values:
	//
	// *   **true**: cancel the update tasks that are in the NOTIFIED state.
	// *   **false**: do not cancel the update tasks that are in the NOTIFIED state.
	CancelNotifiedTask *bool `json:"CancelNotifiedTask,omitempty" xml:"CancelNotifiedTask,omitempty"`
	// Specifies whether to cancel the update tasks that are in the **QUEUED** state in an update batch. Default value: false. Valid values:
	//
	// *   **true**: cancel the update tasks that are in the NOTIFIED state.
	// *   **false**: do not cancel the update tasks that are in the NOTIFIED state.
	//
	// > If you set this parameter to **true** and specify the **CancelUnconfirmedTask** parameter, only the update tasks that are in the QUEUED state are canceled. If you do not specify the **CancelUnconfirmedTask** parameter, the update tasks that are in the QUEUED or CONFIRM state are canceled.
	CancelQueuedTask *bool `json:"CancelQueuedTask,omitempty" xml:"CancelQueuedTask,omitempty"`
	// Specifies whether to cancel update tasks of a scheduled update batch. If you specify the **ScheduleTime** parameter when you call the [CreateOTAStaticUpgradeJob](~~147496~~) operation, a scheduled update batch is created. Default value: false. Valid values:
	//
	// *   **true**: cancel update tasks of a scheduled update batch.
	// *   **false**: do not cancel update tasks of a scheduled update batch.
	CancelScheduledTask *bool `json:"CancelScheduledTask,omitempty" xml:"CancelScheduledTask,omitempty"`
	// Specifies whether to cancel the update tasks that are in the **CONFIRM** state in an update batch. Default value: false. Valid values:
	//
	// *   **true**: cancel the update tasks that are in the CONFIRM state.
	// *   **false**: do not cancel the update tasks that are in the CONFIRM state.
	//
	// This parameter is empty by default.
	//
	// > If you do not specify this parameter and set the **CancelQueuedTask** parameter to **true**, the update tasks that are in the CONFIRM state are canceled. If you set the **CancelQueuedTask** parameter to **false**, the update tasks that are in the CONFIRM state are not canceled.
	CancelUnconfirmedTask *bool `json:"CancelUnconfirmedTask,omitempty" xml:"CancelUnconfirmedTask,omitempty"`
	// The ID of the instance. You can obtain the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify this parameter. Otherwise, the call fails.
	// >*   If the **Overview** page or an instance ID is not displayed in the IoT Platform console, ignore this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the update batch.
	//
	// Use the value that is returned for the **JobId** parameter contained in the response of the [CreateOTAStaticUpgradeJob](~~147496~~) or [CreateOTADynamicUpgradeJob](~~147887~~) operation. You can also obtain the batch ID on the **Firmware Details** page of the IoT Platform console.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s CancelOTATaskByJobRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelOTATaskByJobRequest) GoString() string {
	return s.String()
}

func (s *CancelOTATaskByJobRequest) SetCancelInProgressTask(v bool) *CancelOTATaskByJobRequest {
	s.CancelInProgressTask = &v
	return s
}

func (s *CancelOTATaskByJobRequest) SetCancelNotifiedTask(v bool) *CancelOTATaskByJobRequest {
	s.CancelNotifiedTask = &v
	return s
}

func (s *CancelOTATaskByJobRequest) SetCancelQueuedTask(v bool) *CancelOTATaskByJobRequest {
	s.CancelQueuedTask = &v
	return s
}

func (s *CancelOTATaskByJobRequest) SetCancelScheduledTask(v bool) *CancelOTATaskByJobRequest {
	s.CancelScheduledTask = &v
	return s
}

func (s *CancelOTATaskByJobRequest) SetCancelUnconfirmedTask(v bool) *CancelOTATaskByJobRequest {
	s.CancelUnconfirmedTask = &v
	return s
}

func (s *CancelOTATaskByJobRequest) SetIotInstanceId(v string) *CancelOTATaskByJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CancelOTATaskByJobRequest) SetJobId(v string) *CancelOTATaskByJobRequest {
	s.JobId = &v
	return s
}

type CancelOTATaskByJobResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CancelOTATaskByJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelOTATaskByJobResponseBody) GoString() string {
	return s.String()
}

func (s *CancelOTATaskByJobResponseBody) SetCode(v string) *CancelOTATaskByJobResponseBody {
	s.Code = &v
	return s
}

func (s *CancelOTATaskByJobResponseBody) SetErrorMessage(v string) *CancelOTATaskByJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CancelOTATaskByJobResponseBody) SetRequestId(v string) *CancelOTATaskByJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelOTATaskByJobResponseBody) SetSuccess(v bool) *CancelOTATaskByJobResponseBody {
	s.Success = &v
	return s
}

type CancelOTATaskByJobResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CancelOTATaskByJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CancelOTATaskByJobResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelOTATaskByJobResponse) GoString() string {
	return s.String()
}

func (s *CancelOTATaskByJobResponse) SetHeaders(v map[string]*string) *CancelOTATaskByJobResponse {
	s.Headers = v
	return s
}

func (s *CancelOTATaskByJobResponse) SetStatusCode(v int32) *CancelOTATaskByJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelOTATaskByJobResponse) SetBody(v *CancelOTATaskByJobResponseBody) *CancelOTATaskByJobResponse {
	s.Body = v
	return s
}

type CancelReleaseProductRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to be unpublished.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s CancelReleaseProductRequest) String() string {
	return tea.Prettify(s)
}

func (s CancelReleaseProductRequest) GoString() string {
	return s.String()
}

func (s *CancelReleaseProductRequest) SetIotInstanceId(v string) *CancelReleaseProductRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CancelReleaseProductRequest) SetProductKey(v string) *CancelReleaseProductRequest {
	s.ProductKey = &v
	return s
}

type CancelReleaseProductResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CancelReleaseProductResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CancelReleaseProductResponseBody) GoString() string {
	return s.String()
}

func (s *CancelReleaseProductResponseBody) SetCode(v string) *CancelReleaseProductResponseBody {
	s.Code = &v
	return s
}

func (s *CancelReleaseProductResponseBody) SetErrorMessage(v string) *CancelReleaseProductResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CancelReleaseProductResponseBody) SetRequestId(v string) *CancelReleaseProductResponseBody {
	s.RequestId = &v
	return s
}

func (s *CancelReleaseProductResponseBody) SetSuccess(v bool) *CancelReleaseProductResponseBody {
	s.Success = &v
	return s
}

type CancelReleaseProductResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CancelReleaseProductResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CancelReleaseProductResponse) String() string {
	return tea.Prettify(s)
}

func (s CancelReleaseProductResponse) GoString() string {
	return s.String()
}

func (s *CancelReleaseProductResponse) SetHeaders(v map[string]*string) *CancelReleaseProductResponse {
	s.Headers = v
	return s
}

func (s *CancelReleaseProductResponse) SetStatusCode(v int32) *CancelReleaseProductResponse {
	s.StatusCode = &v
	return s
}

func (s *CancelReleaseProductResponse) SetBody(v *CancelReleaseProductResponseBody) *CancelReleaseProductResponse {
	s.Body = v
	return s
}

type CheckBindLicenseDeviceProgressRequest struct {
	CheckProgressId *string `json:"CheckProgressId,omitempty" xml:"CheckProgressId,omitempty"`
	IotInstanceId   *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	LicenseCode     *string `json:"LicenseCode,omitempty" xml:"LicenseCode,omitempty"`
	ProductKey      *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s CheckBindLicenseDeviceProgressRequest) String() string {
	return tea.Prettify(s)
}

func (s CheckBindLicenseDeviceProgressRequest) GoString() string {
	return s.String()
}

func (s *CheckBindLicenseDeviceProgressRequest) SetCheckProgressId(v string) *CheckBindLicenseDeviceProgressRequest {
	s.CheckProgressId = &v
	return s
}

func (s *CheckBindLicenseDeviceProgressRequest) SetIotInstanceId(v string) *CheckBindLicenseDeviceProgressRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CheckBindLicenseDeviceProgressRequest) SetLicenseCode(v string) *CheckBindLicenseDeviceProgressRequest {
	s.LicenseCode = &v
	return s
}

func (s *CheckBindLicenseDeviceProgressRequest) SetProductKey(v string) *CheckBindLicenseDeviceProgressRequest {
	s.ProductKey = &v
	return s
}

type CheckBindLicenseDeviceProgressResponseBody struct {
	Code         *string                                         `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *CheckBindLicenseDeviceProgressResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                         `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                           `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CheckBindLicenseDeviceProgressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CheckBindLicenseDeviceProgressResponseBody) GoString() string {
	return s.String()
}

func (s *CheckBindLicenseDeviceProgressResponseBody) SetCode(v string) *CheckBindLicenseDeviceProgressResponseBody {
	s.Code = &v
	return s
}

func (s *CheckBindLicenseDeviceProgressResponseBody) SetData(v *CheckBindLicenseDeviceProgressResponseBodyData) *CheckBindLicenseDeviceProgressResponseBody {
	s.Data = v
	return s
}

func (s *CheckBindLicenseDeviceProgressResponseBody) SetErrorMessage(v string) *CheckBindLicenseDeviceProgressResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CheckBindLicenseDeviceProgressResponseBody) SetRequestId(v string) *CheckBindLicenseDeviceProgressResponseBody {
	s.RequestId = &v
	return s
}

func (s *CheckBindLicenseDeviceProgressResponseBody) SetSuccess(v bool) *CheckBindLicenseDeviceProgressResponseBody {
	s.Success = &v
	return s
}

type CheckBindLicenseDeviceProgressResponseBodyData struct {
	FailSum       *int64  `json:"FailSum,omitempty" xml:"FailSum,omitempty"`
	Progress      *int32  `json:"Progress,omitempty" xml:"Progress,omitempty"`
	ResultCsvFile *string `json:"ResultCsvFile,omitempty" xml:"ResultCsvFile,omitempty"`
	SuccessSum    *int64  `json:"SuccessSum,omitempty" xml:"SuccessSum,omitempty"`
}

func (s CheckBindLicenseDeviceProgressResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CheckBindLicenseDeviceProgressResponseBodyData) GoString() string {
	return s.String()
}

func (s *CheckBindLicenseDeviceProgressResponseBodyData) SetFailSum(v int64) *CheckBindLicenseDeviceProgressResponseBodyData {
	s.FailSum = &v
	return s
}

func (s *CheckBindLicenseDeviceProgressResponseBodyData) SetProgress(v int32) *CheckBindLicenseDeviceProgressResponseBodyData {
	s.Progress = &v
	return s
}

func (s *CheckBindLicenseDeviceProgressResponseBodyData) SetResultCsvFile(v string) *CheckBindLicenseDeviceProgressResponseBodyData {
	s.ResultCsvFile = &v
	return s
}

func (s *CheckBindLicenseDeviceProgressResponseBodyData) SetSuccessSum(v int64) *CheckBindLicenseDeviceProgressResponseBodyData {
	s.SuccessSum = &v
	return s
}

type CheckBindLicenseDeviceProgressResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CheckBindLicenseDeviceProgressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CheckBindLicenseDeviceProgressResponse) String() string {
	return tea.Prettify(s)
}

func (s CheckBindLicenseDeviceProgressResponse) GoString() string {
	return s.String()
}

func (s *CheckBindLicenseDeviceProgressResponse) SetHeaders(v map[string]*string) *CheckBindLicenseDeviceProgressResponse {
	s.Headers = v
	return s
}

func (s *CheckBindLicenseDeviceProgressResponse) SetStatusCode(v int32) *CheckBindLicenseDeviceProgressResponse {
	s.StatusCode = &v
	return s
}

func (s *CheckBindLicenseDeviceProgressResponse) SetBody(v *CheckBindLicenseDeviceProgressResponseBody) *CheckBindLicenseDeviceProgressResponse {
	s.Body = v
	return s
}

type ClearDeviceDesiredPropertyRequest struct {
	// The DeviceName of the device.
	//
	// >  If you specify a value for this parameter, you must configure the **ProductKey** parameter.
	DeviceName *string   `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	Identifies []*string `json:"Identifies,omitempty" xml:"Identifies,omitempty" type:"Repeated"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// >  The IotId parameter specifies a globally unique identifier (GUID) for the device. The value of the **IotId** parameter is equivalent to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for the IotId parameter, you do not need to configure the **ProductKey** or **DeviceName** parameter. If you specify values for the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	//
	// >  If you specify a value for this parameter, you must configure the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s ClearDeviceDesiredPropertyRequest) String() string {
	return tea.Prettify(s)
}

func (s ClearDeviceDesiredPropertyRequest) GoString() string {
	return s.String()
}

func (s *ClearDeviceDesiredPropertyRequest) SetDeviceName(v string) *ClearDeviceDesiredPropertyRequest {
	s.DeviceName = &v
	return s
}

func (s *ClearDeviceDesiredPropertyRequest) SetIdentifies(v []*string) *ClearDeviceDesiredPropertyRequest {
	s.Identifies = v
	return s
}

func (s *ClearDeviceDesiredPropertyRequest) SetIotId(v string) *ClearDeviceDesiredPropertyRequest {
	s.IotId = &v
	return s
}

func (s *ClearDeviceDesiredPropertyRequest) SetIotInstanceId(v string) *ClearDeviceDesiredPropertyRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ClearDeviceDesiredPropertyRequest) SetProductKey(v string) *ClearDeviceDesiredPropertyRequest {
	s.ProductKey = &v
	return s
}

type ClearDeviceDesiredPropertyResponseBody struct {
	// The error code returned if the call fails. For more information, see the "**Error codes**" section of this topic.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call is successful.
	Data *ClearDeviceDesiredPropertyResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ClearDeviceDesiredPropertyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ClearDeviceDesiredPropertyResponseBody) GoString() string {
	return s.String()
}

func (s *ClearDeviceDesiredPropertyResponseBody) SetCode(v string) *ClearDeviceDesiredPropertyResponseBody {
	s.Code = &v
	return s
}

func (s *ClearDeviceDesiredPropertyResponseBody) SetData(v *ClearDeviceDesiredPropertyResponseBodyData) *ClearDeviceDesiredPropertyResponseBody {
	s.Data = v
	return s
}

func (s *ClearDeviceDesiredPropertyResponseBody) SetErrorMessage(v string) *ClearDeviceDesiredPropertyResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ClearDeviceDesiredPropertyResponseBody) SetRequestId(v string) *ClearDeviceDesiredPropertyResponseBody {
	s.RequestId = &v
	return s
}

func (s *ClearDeviceDesiredPropertyResponseBody) SetSuccess(v bool) *ClearDeviceDesiredPropertyResponseBody {
	s.Success = &v
	return s
}

type ClearDeviceDesiredPropertyResponseBodyData struct {
	// The latest version of the desired values of the properties after you call this operation to delete the specified desired property values.
	Versions *string `json:"Versions,omitempty" xml:"Versions,omitempty"`
}

func (s ClearDeviceDesiredPropertyResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ClearDeviceDesiredPropertyResponseBodyData) GoString() string {
	return s.String()
}

func (s *ClearDeviceDesiredPropertyResponseBodyData) SetVersions(v string) *ClearDeviceDesiredPropertyResponseBodyData {
	s.Versions = &v
	return s
}

type ClearDeviceDesiredPropertyResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ClearDeviceDesiredPropertyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ClearDeviceDesiredPropertyResponse) String() string {
	return tea.Prettify(s)
}

func (s ClearDeviceDesiredPropertyResponse) GoString() string {
	return s.String()
}

func (s *ClearDeviceDesiredPropertyResponse) SetHeaders(v map[string]*string) *ClearDeviceDesiredPropertyResponse {
	s.Headers = v
	return s
}

func (s *ClearDeviceDesiredPropertyResponse) SetStatusCode(v int32) *ClearDeviceDesiredPropertyResponse {
	s.StatusCode = &v
	return s
}

func (s *ClearDeviceDesiredPropertyResponse) SetBody(v *ClearDeviceDesiredPropertyResponseBody) *ClearDeviceDesiredPropertyResponse {
	s.Body = v
	return s
}

type ClearEdgeInstanceDriverConfigsRequest struct {
	// The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver whose configurations you want to delete and obtain the driver ID.
	//
	// You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that uses the driver and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// This parameter is not required for the public instance but required for your purchased instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s ClearEdgeInstanceDriverConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s ClearEdgeInstanceDriverConfigsRequest) GoString() string {
	return s.String()
}

func (s *ClearEdgeInstanceDriverConfigsRequest) SetDriverId(v string) *ClearEdgeInstanceDriverConfigsRequest {
	s.DriverId = &v
	return s
}

func (s *ClearEdgeInstanceDriverConfigsRequest) SetInstanceId(v string) *ClearEdgeInstanceDriverConfigsRequest {
	s.InstanceId = &v
	return s
}

func (s *ClearEdgeInstanceDriverConfigsRequest) SetIotInstanceId(v string) *ClearEdgeInstanceDriverConfigsRequest {
	s.IotInstanceId = &v
	return s
}

type ClearEdgeInstanceDriverConfigsResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ClearEdgeInstanceDriverConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ClearEdgeInstanceDriverConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *ClearEdgeInstanceDriverConfigsResponseBody) SetCode(v string) *ClearEdgeInstanceDriverConfigsResponseBody {
	s.Code = &v
	return s
}

func (s *ClearEdgeInstanceDriverConfigsResponseBody) SetErrorMessage(v string) *ClearEdgeInstanceDriverConfigsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ClearEdgeInstanceDriverConfigsResponseBody) SetRequestId(v string) *ClearEdgeInstanceDriverConfigsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ClearEdgeInstanceDriverConfigsResponseBody) SetSuccess(v bool) *ClearEdgeInstanceDriverConfigsResponseBody {
	s.Success = &v
	return s
}

type ClearEdgeInstanceDriverConfigsResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ClearEdgeInstanceDriverConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ClearEdgeInstanceDriverConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s ClearEdgeInstanceDriverConfigsResponse) GoString() string {
	return s.String()
}

func (s *ClearEdgeInstanceDriverConfigsResponse) SetHeaders(v map[string]*string) *ClearEdgeInstanceDriverConfigsResponse {
	s.Headers = v
	return s
}

func (s *ClearEdgeInstanceDriverConfigsResponse) SetStatusCode(v int32) *ClearEdgeInstanceDriverConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *ClearEdgeInstanceDriverConfigsResponse) SetBody(v *ClearEdgeInstanceDriverConfigsResponseBody) *ClearEdgeInstanceDriverConfigsResponse {
	s.Body = v
	return s
}

type CloseDeviceTunnelRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	TunnelId      *string `json:"TunnelId,omitempty" xml:"TunnelId,omitempty"`
}

func (s CloseDeviceTunnelRequest) String() string {
	return tea.Prettify(s)
}

func (s CloseDeviceTunnelRequest) GoString() string {
	return s.String()
}

func (s *CloseDeviceTunnelRequest) SetIotInstanceId(v string) *CloseDeviceTunnelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CloseDeviceTunnelRequest) SetTunnelId(v string) *CloseDeviceTunnelRequest {
	s.TunnelId = &v
	return s
}

type CloseDeviceTunnelResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CloseDeviceTunnelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CloseDeviceTunnelResponseBody) GoString() string {
	return s.String()
}

func (s *CloseDeviceTunnelResponseBody) SetCode(v string) *CloseDeviceTunnelResponseBody {
	s.Code = &v
	return s
}

func (s *CloseDeviceTunnelResponseBody) SetErrorMessage(v string) *CloseDeviceTunnelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CloseDeviceTunnelResponseBody) SetRequestId(v string) *CloseDeviceTunnelResponseBody {
	s.RequestId = &v
	return s
}

func (s *CloseDeviceTunnelResponseBody) SetSuccess(v bool) *CloseDeviceTunnelResponseBody {
	s.Success = &v
	return s
}

type CloseDeviceTunnelResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CloseDeviceTunnelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CloseDeviceTunnelResponse) String() string {
	return tea.Prettify(s)
}

func (s CloseDeviceTunnelResponse) GoString() string {
	return s.String()
}

func (s *CloseDeviceTunnelResponse) SetHeaders(v map[string]*string) *CloseDeviceTunnelResponse {
	s.Headers = v
	return s
}

func (s *CloseDeviceTunnelResponse) SetStatusCode(v int32) *CloseDeviceTunnelResponse {
	s.StatusCode = &v
	return s
}

func (s *CloseDeviceTunnelResponse) SetBody(v *CloseDeviceTunnelResponseBody) *CloseDeviceTunnelResponse {
	s.Body = v
	return s
}

type CloseEdgeInstanceDeploymentRequest struct {
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance for which you want to stop deployment tasks and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s CloseEdgeInstanceDeploymentRequest) String() string {
	return tea.Prettify(s)
}

func (s CloseEdgeInstanceDeploymentRequest) GoString() string {
	return s.String()
}

func (s *CloseEdgeInstanceDeploymentRequest) SetInstanceId(v string) *CloseEdgeInstanceDeploymentRequest {
	s.InstanceId = &v
	return s
}

func (s *CloseEdgeInstanceDeploymentRequest) SetIotInstanceId(v string) *CloseEdgeInstanceDeploymentRequest {
	s.IotInstanceId = &v
	return s
}

type CloseEdgeInstanceDeploymentResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CloseEdgeInstanceDeploymentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CloseEdgeInstanceDeploymentResponseBody) GoString() string {
	return s.String()
}

func (s *CloseEdgeInstanceDeploymentResponseBody) SetCode(v string) *CloseEdgeInstanceDeploymentResponseBody {
	s.Code = &v
	return s
}

func (s *CloseEdgeInstanceDeploymentResponseBody) SetErrorMessage(v string) *CloseEdgeInstanceDeploymentResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CloseEdgeInstanceDeploymentResponseBody) SetRequestId(v string) *CloseEdgeInstanceDeploymentResponseBody {
	s.RequestId = &v
	return s
}

func (s *CloseEdgeInstanceDeploymentResponseBody) SetSuccess(v bool) *CloseEdgeInstanceDeploymentResponseBody {
	s.Success = &v
	return s
}

type CloseEdgeInstanceDeploymentResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CloseEdgeInstanceDeploymentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CloseEdgeInstanceDeploymentResponse) String() string {
	return tea.Prettify(s)
}

func (s CloseEdgeInstanceDeploymentResponse) GoString() string {
	return s.String()
}

func (s *CloseEdgeInstanceDeploymentResponse) SetHeaders(v map[string]*string) *CloseEdgeInstanceDeploymentResponse {
	s.Headers = v
	return s
}

func (s *CloseEdgeInstanceDeploymentResponse) SetStatusCode(v int32) *CloseEdgeInstanceDeploymentResponse {
	s.StatusCode = &v
	return s
}

func (s *CloseEdgeInstanceDeploymentResponse) SetBody(v *CloseEdgeInstanceDeploymentResponseBody) *CloseEdgeInstanceDeploymentResponse {
	s.Body = v
	return s
}

type ConfirmOTATaskRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	TaskId        []*string `json:"TaskId,omitempty" xml:"TaskId,omitempty" type:"Repeated"`
}

func (s ConfirmOTATaskRequest) String() string {
	return tea.Prettify(s)
}

func (s ConfirmOTATaskRequest) GoString() string {
	return s.String()
}

func (s *ConfirmOTATaskRequest) SetIotInstanceId(v string) *ConfirmOTATaskRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ConfirmOTATaskRequest) SetTaskId(v []*string) *ConfirmOTATaskRequest {
	s.TaskId = v
	return s
}

type ConfirmOTATaskResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ConfirmOTATaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ConfirmOTATaskResponseBody) GoString() string {
	return s.String()
}

func (s *ConfirmOTATaskResponseBody) SetCode(v string) *ConfirmOTATaskResponseBody {
	s.Code = &v
	return s
}

func (s *ConfirmOTATaskResponseBody) SetErrorMessage(v string) *ConfirmOTATaskResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ConfirmOTATaskResponseBody) SetRequestId(v string) *ConfirmOTATaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *ConfirmOTATaskResponseBody) SetSuccess(v bool) *ConfirmOTATaskResponseBody {
	s.Success = &v
	return s
}

type ConfirmOTATaskResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ConfirmOTATaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ConfirmOTATaskResponse) String() string {
	return tea.Prettify(s)
}

func (s ConfirmOTATaskResponse) GoString() string {
	return s.String()
}

func (s *ConfirmOTATaskResponse) SetHeaders(v map[string]*string) *ConfirmOTATaskResponse {
	s.Headers = v
	return s
}

func (s *ConfirmOTATaskResponse) SetStatusCode(v int32) *ConfirmOTATaskResponse {
	s.StatusCode = &v
	return s
}

func (s *ConfirmOTATaskResponse) SetBody(v *ConfirmOTATaskResponseBody) *ConfirmOTATaskResponse {
	s.Body = v
	return s
}

type CopyThingModelRequest struct {
	// The ID of the instance. On the **Overview** page in the IoT Platform console, you can view the ID of the instance.
	//
	// >*   If your instance has an ID, you must specify this parameter. Otherwise, the call fails.
	// >*   If the **Overview** page or instance ID is not displayed in the IoT Platform console, ignore this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the resource group.
	//
	// >  You do not need to configure this parameter.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The version of the TSL model that you want to copy.
	//
	// You can call the [ListThingModelVersion](~~150318~~) operation to view the TSL model versions of a product.
	SourceModelVersion *string `json:"SourceModelVersion,omitempty" xml:"SourceModelVersion,omitempty"`
	// The ProductKey of the source product.
	//
	// You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
	SourceProductKey *string `json:"SourceProductKey,omitempty" xml:"SourceProductKey,omitempty"`
	// The ProductKey of the destination product.
	//
	// You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
	TargetProductKey *string `json:"TargetProductKey,omitempty" xml:"TargetProductKey,omitempty"`
}

func (s CopyThingModelRequest) String() string {
	return tea.Prettify(s)
}

func (s CopyThingModelRequest) GoString() string {
	return s.String()
}

func (s *CopyThingModelRequest) SetIotInstanceId(v string) *CopyThingModelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CopyThingModelRequest) SetResourceGroupId(v string) *CopyThingModelRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CopyThingModelRequest) SetSourceModelVersion(v string) *CopyThingModelRequest {
	s.SourceModelVersion = &v
	return s
}

func (s *CopyThingModelRequest) SetSourceProductKey(v string) *CopyThingModelRequest {
	s.SourceProductKey = &v
	return s
}

func (s *CopyThingModelRequest) SetTargetProductKey(v string) *CopyThingModelRequest {
	s.TargetProductKey = &v
	return s
}

type CopyThingModelResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CopyThingModelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CopyThingModelResponseBody) GoString() string {
	return s.String()
}

func (s *CopyThingModelResponseBody) SetCode(v string) *CopyThingModelResponseBody {
	s.Code = &v
	return s
}

func (s *CopyThingModelResponseBody) SetErrorMessage(v string) *CopyThingModelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CopyThingModelResponseBody) SetRequestId(v string) *CopyThingModelResponseBody {
	s.RequestId = &v
	return s
}

func (s *CopyThingModelResponseBody) SetSuccess(v bool) *CopyThingModelResponseBody {
	s.Success = &v
	return s
}

type CopyThingModelResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CopyThingModelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CopyThingModelResponse) String() string {
	return tea.Prettify(s)
}

func (s CopyThingModelResponse) GoString() string {
	return s.String()
}

func (s *CopyThingModelResponse) SetHeaders(v map[string]*string) *CopyThingModelResponse {
	s.Headers = v
	return s
}

func (s *CopyThingModelResponse) SetStatusCode(v int32) *CopyThingModelResponse {
	s.StatusCode = &v
	return s
}

func (s *CopyThingModelResponse) SetBody(v *CopyThingModelResponseBody) *CopyThingModelResponse {
	s.Body = v
	return s
}

type CountSpeechBroadcastHourRequest struct {
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
	//
	// For more information, see the [Overview](~~356505~~) topic of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The end time of the hour in which you want to query the number of broadcasted speeches. Example: 2020090919, which indicates 19:00 on September 9, 2020.
	QueryDateTimeHour *string `json:"QueryDateTimeHour,omitempty" xml:"QueryDateTimeHour,omitempty"`
	// The code that is used to share the speeches.
	//
	// You can obtain the **code** on the **Shared Corpus Management** page of **Speech Sending Voice Broadcasting Service**.
	ShareTaskCode *string `json:"ShareTaskCode,omitempty" xml:"ShareTaskCode,omitempty"`
}

func (s CountSpeechBroadcastHourRequest) String() string {
	return tea.Prettify(s)
}

func (s CountSpeechBroadcastHourRequest) GoString() string {
	return s.String()
}

func (s *CountSpeechBroadcastHourRequest) SetIotInstanceId(v string) *CountSpeechBroadcastHourRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CountSpeechBroadcastHourRequest) SetQueryDateTimeHour(v string) *CountSpeechBroadcastHourRequest {
	s.QueryDateTimeHour = &v
	return s
}

func (s *CountSpeechBroadcastHourRequest) SetShareTaskCode(v string) *CountSpeechBroadcastHourRequest {
	s.ShareTaskCode = &v
	return s
}

type CountSpeechBroadcastHourResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The number of shared speeches that were broadcasted in the specific hour.
	Data *int32 `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CountSpeechBroadcastHourResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CountSpeechBroadcastHourResponseBody) GoString() string {
	return s.String()
}

func (s *CountSpeechBroadcastHourResponseBody) SetCode(v string) *CountSpeechBroadcastHourResponseBody {
	s.Code = &v
	return s
}

func (s *CountSpeechBroadcastHourResponseBody) SetData(v int32) *CountSpeechBroadcastHourResponseBody {
	s.Data = &v
	return s
}

func (s *CountSpeechBroadcastHourResponseBody) SetErrorMessage(v string) *CountSpeechBroadcastHourResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CountSpeechBroadcastHourResponseBody) SetRequestId(v string) *CountSpeechBroadcastHourResponseBody {
	s.RequestId = &v
	return s
}

func (s *CountSpeechBroadcastHourResponseBody) SetSuccess(v bool) *CountSpeechBroadcastHourResponseBody {
	s.Success = &v
	return s
}

type CountSpeechBroadcastHourResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CountSpeechBroadcastHourResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CountSpeechBroadcastHourResponse) String() string {
	return tea.Prettify(s)
}

func (s CountSpeechBroadcastHourResponse) GoString() string {
	return s.String()
}

func (s *CountSpeechBroadcastHourResponse) SetHeaders(v map[string]*string) *CountSpeechBroadcastHourResponse {
	s.Headers = v
	return s
}

func (s *CountSpeechBroadcastHourResponse) SetStatusCode(v int32) *CountSpeechBroadcastHourResponse {
	s.StatusCode = &v
	return s
}

func (s *CountSpeechBroadcastHourResponse) SetBody(v *CountSpeechBroadcastHourResponseBody) *CountSpeechBroadcastHourResponse {
	s.Body = v
	return s
}

type CreateConsumerGroupRequest struct {
	// The name of the consumer group. The name must be 4 to 30 characters in length and can contain letters, digits, and underscores (\_).
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	SubBizCode    *string `json:"SubBizCode,omitempty" xml:"SubBizCode,omitempty"`
	Type          *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateConsumerGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateConsumerGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateConsumerGroupRequest) SetGroupName(v string) *CreateConsumerGroupRequest {
	s.GroupName = &v
	return s
}

func (s *CreateConsumerGroupRequest) SetIotInstanceId(v string) *CreateConsumerGroupRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateConsumerGroupRequest) SetSubBizCode(v string) *CreateConsumerGroupRequest {
	s.SubBizCode = &v
	return s
}

func (s *CreateConsumerGroupRequest) SetType(v string) *CreateConsumerGroupRequest {
	s.Type = &v
	return s
}

type CreateConsumerGroupResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the consumer group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateConsumerGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateConsumerGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateConsumerGroupResponseBody) SetCode(v string) *CreateConsumerGroupResponseBody {
	s.Code = &v
	return s
}

func (s *CreateConsumerGroupResponseBody) SetErrorMessage(v string) *CreateConsumerGroupResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateConsumerGroupResponseBody) SetGroupId(v string) *CreateConsumerGroupResponseBody {
	s.GroupId = &v
	return s
}

func (s *CreateConsumerGroupResponseBody) SetRequestId(v string) *CreateConsumerGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateConsumerGroupResponseBody) SetSuccess(v bool) *CreateConsumerGroupResponseBody {
	s.Success = &v
	return s
}

type CreateConsumerGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateConsumerGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateConsumerGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateConsumerGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateConsumerGroupResponse) SetHeaders(v map[string]*string) *CreateConsumerGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateConsumerGroupResponse) SetStatusCode(v int32) *CreateConsumerGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateConsumerGroupResponse) SetBody(v *CreateConsumerGroupResponseBody) *CreateConsumerGroupResponse {
	s.Body = v
	return s
}

type CreateConsumerGroupSubscribeRelationRequest struct {
	// The ID of the consumer group. After you call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group, the consumer group ID is returned. You can call the [QueryConsumerGroupList](~~170419~~) operation to query the consumer group ID by group name. You can also go to the IoT Platform console,and choose **Rules** > **Server-side Subscription** > **Consumer Groups** to view the consumer group ID.
	ConsumerGroupId *string `json:"ConsumerGroupId,omitempty" xml:"ConsumerGroupId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product that is specified for the subscription.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s CreateConsumerGroupSubscribeRelationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateConsumerGroupSubscribeRelationRequest) GoString() string {
	return s.String()
}

func (s *CreateConsumerGroupSubscribeRelationRequest) SetConsumerGroupId(v string) *CreateConsumerGroupSubscribeRelationRequest {
	s.ConsumerGroupId = &v
	return s
}

func (s *CreateConsumerGroupSubscribeRelationRequest) SetIotInstanceId(v string) *CreateConsumerGroupSubscribeRelationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateConsumerGroupSubscribeRelationRequest) SetProductKey(v string) *CreateConsumerGroupSubscribeRelationRequest {
	s.ProductKey = &v
	return s
}

type CreateConsumerGroupSubscribeRelationResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateConsumerGroupSubscribeRelationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateConsumerGroupSubscribeRelationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateConsumerGroupSubscribeRelationResponseBody) SetCode(v string) *CreateConsumerGroupSubscribeRelationResponseBody {
	s.Code = &v
	return s
}

func (s *CreateConsumerGroupSubscribeRelationResponseBody) SetErrorMessage(v string) *CreateConsumerGroupSubscribeRelationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateConsumerGroupSubscribeRelationResponseBody) SetRequestId(v string) *CreateConsumerGroupSubscribeRelationResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateConsumerGroupSubscribeRelationResponseBody) SetSuccess(v bool) *CreateConsumerGroupSubscribeRelationResponseBody {
	s.Success = &v
	return s
}

type CreateConsumerGroupSubscribeRelationResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateConsumerGroupSubscribeRelationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateConsumerGroupSubscribeRelationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateConsumerGroupSubscribeRelationResponse) GoString() string {
	return s.String()
}

func (s *CreateConsumerGroupSubscribeRelationResponse) SetHeaders(v map[string]*string) *CreateConsumerGroupSubscribeRelationResponse {
	s.Headers = v
	return s
}

func (s *CreateConsumerGroupSubscribeRelationResponse) SetStatusCode(v int32) *CreateConsumerGroupSubscribeRelationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateConsumerGroupSubscribeRelationResponse) SetBody(v *CreateConsumerGroupSubscribeRelationResponseBody) *CreateConsumerGroupSubscribeRelationResponse {
	s.Body = v
	return s
}

type CreateDataAPIServiceRequest struct {
	ApiPath       *string                                     `json:"ApiPath,omitempty" xml:"ApiPath,omitempty"`
	Desc          *string                                     `json:"Desc,omitempty" xml:"Desc,omitempty"`
	DisplayName   *string                                     `json:"DisplayName,omitempty" xml:"DisplayName,omitempty"`
	IotInstanceId *string                                     `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	OriginSql     *string                                     `json:"OriginSql,omitempty" xml:"OriginSql,omitempty"`
	RequestParam  []*CreateDataAPIServiceRequestRequestParam  `json:"RequestParam,omitempty" xml:"RequestParam,omitempty" type:"Repeated"`
	ResponseParam []*CreateDataAPIServiceRequestResponseParam `json:"ResponseParam,omitempty" xml:"ResponseParam,omitempty" type:"Repeated"`
	TemplateSql   *string                                     `json:"TemplateSql,omitempty" xml:"TemplateSql,omitempty"`
}

func (s CreateDataAPIServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataAPIServiceRequest) GoString() string {
	return s.String()
}

func (s *CreateDataAPIServiceRequest) SetApiPath(v string) *CreateDataAPIServiceRequest {
	s.ApiPath = &v
	return s
}

func (s *CreateDataAPIServiceRequest) SetDesc(v string) *CreateDataAPIServiceRequest {
	s.Desc = &v
	return s
}

func (s *CreateDataAPIServiceRequest) SetDisplayName(v string) *CreateDataAPIServiceRequest {
	s.DisplayName = &v
	return s
}

func (s *CreateDataAPIServiceRequest) SetIotInstanceId(v string) *CreateDataAPIServiceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateDataAPIServiceRequest) SetOriginSql(v string) *CreateDataAPIServiceRequest {
	s.OriginSql = &v
	return s
}

func (s *CreateDataAPIServiceRequest) SetRequestParam(v []*CreateDataAPIServiceRequestRequestParam) *CreateDataAPIServiceRequest {
	s.RequestParam = v
	return s
}

func (s *CreateDataAPIServiceRequest) SetResponseParam(v []*CreateDataAPIServiceRequestResponseParam) *CreateDataAPIServiceRequest {
	s.ResponseParam = v
	return s
}

func (s *CreateDataAPIServiceRequest) SetTemplateSql(v string) *CreateDataAPIServiceRequest {
	s.TemplateSql = &v
	return s
}

type CreateDataAPIServiceRequestRequestParam struct {
	Desc     *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	Example  *string `json:"Example,omitempty" xml:"Example,omitempty"`
	Name     *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Required *bool   `json:"Required,omitempty" xml:"Required,omitempty"`
	Type     *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateDataAPIServiceRequestRequestParam) String() string {
	return tea.Prettify(s)
}

func (s CreateDataAPIServiceRequestRequestParam) GoString() string {
	return s.String()
}

func (s *CreateDataAPIServiceRequestRequestParam) SetDesc(v string) *CreateDataAPIServiceRequestRequestParam {
	s.Desc = &v
	return s
}

func (s *CreateDataAPIServiceRequestRequestParam) SetExample(v string) *CreateDataAPIServiceRequestRequestParam {
	s.Example = &v
	return s
}

func (s *CreateDataAPIServiceRequestRequestParam) SetName(v string) *CreateDataAPIServiceRequestRequestParam {
	s.Name = &v
	return s
}

func (s *CreateDataAPIServiceRequestRequestParam) SetRequired(v bool) *CreateDataAPIServiceRequestRequestParam {
	s.Required = &v
	return s
}

func (s *CreateDataAPIServiceRequestRequestParam) SetType(v string) *CreateDataAPIServiceRequestRequestParam {
	s.Type = &v
	return s
}

type CreateDataAPIServiceRequestResponseParam struct {
	Desc     *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	Example  *string `json:"Example,omitempty" xml:"Example,omitempty"`
	Name     *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Required *bool   `json:"Required,omitempty" xml:"Required,omitempty"`
	Type     *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateDataAPIServiceRequestResponseParam) String() string {
	return tea.Prettify(s)
}

func (s CreateDataAPIServiceRequestResponseParam) GoString() string {
	return s.String()
}

func (s *CreateDataAPIServiceRequestResponseParam) SetDesc(v string) *CreateDataAPIServiceRequestResponseParam {
	s.Desc = &v
	return s
}

func (s *CreateDataAPIServiceRequestResponseParam) SetExample(v string) *CreateDataAPIServiceRequestResponseParam {
	s.Example = &v
	return s
}

func (s *CreateDataAPIServiceRequestResponseParam) SetName(v string) *CreateDataAPIServiceRequestResponseParam {
	s.Name = &v
	return s
}

func (s *CreateDataAPIServiceRequestResponseParam) SetRequired(v bool) *CreateDataAPIServiceRequestResponseParam {
	s.Required = &v
	return s
}

func (s *CreateDataAPIServiceRequestResponseParam) SetType(v string) *CreateDataAPIServiceRequestResponseParam {
	s.Type = &v
	return s
}

type CreateDataAPIServiceResponseBody struct {
	Code         *string                               `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *CreateDataAPIServiceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                               `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                               `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                 `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDataAPIServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDataAPIServiceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataAPIServiceResponseBody) SetCode(v string) *CreateDataAPIServiceResponseBody {
	s.Code = &v
	return s
}

func (s *CreateDataAPIServiceResponseBody) SetData(v *CreateDataAPIServiceResponseBodyData) *CreateDataAPIServiceResponseBody {
	s.Data = v
	return s
}

func (s *CreateDataAPIServiceResponseBody) SetErrorMessage(v string) *CreateDataAPIServiceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDataAPIServiceResponseBody) SetRequestId(v string) *CreateDataAPIServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDataAPIServiceResponseBody) SetSuccess(v bool) *CreateDataAPIServiceResponseBody {
	s.Success = &v
	return s
}

type CreateDataAPIServiceResponseBodyData struct {
	ApiSrn         *string `json:"ApiSrn,omitempty" xml:"ApiSrn,omitempty"`
	CreateTime     *int64  `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	LastUpdateTime *int64  `json:"LastUpdateTime,omitempty" xml:"LastUpdateTime,omitempty"`
}

func (s CreateDataAPIServiceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateDataAPIServiceResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateDataAPIServiceResponseBodyData) SetApiSrn(v string) *CreateDataAPIServiceResponseBodyData {
	s.ApiSrn = &v
	return s
}

func (s *CreateDataAPIServiceResponseBodyData) SetCreateTime(v int64) *CreateDataAPIServiceResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *CreateDataAPIServiceResponseBodyData) SetLastUpdateTime(v int64) *CreateDataAPIServiceResponseBodyData {
	s.LastUpdateTime = &v
	return s
}

type CreateDataAPIServiceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDataAPIServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDataAPIServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDataAPIServiceResponse) GoString() string {
	return s.String()
}

func (s *CreateDataAPIServiceResponse) SetHeaders(v map[string]*string) *CreateDataAPIServiceResponse {
	s.Headers = v
	return s
}

func (s *CreateDataAPIServiceResponse) SetStatusCode(v int32) *CreateDataAPIServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataAPIServiceResponse) SetBody(v *CreateDataAPIServiceResponseBody) *CreateDataAPIServiceResponse {
	s.Body = v
	return s
}

type CreateDataSourceItemRequest struct {
	DataSourceId *int64  `json:"DataSourceId,omitempty" xml:"DataSourceId,omitempty"`
	DeviceName   *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The instance ID. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
	//
	// For more information, see the [Overview](~~356505~~) topic of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	ScopeType     *string `json:"ScopeType,omitempty" xml:"ScopeType,omitempty"`
	// The topic that you want to add to the data source in the rules engine. Format: `/${productKey}/${deviceName}/topicShortName`. `${productKey}` specifies the **ProductKey** of the product to which a device belongs. `${deviceName}` specifies the name of the device. `topicShortName` specifies the custom name of the topic.
	//
	// *   Basic communication topics or Thing Specification Language (TSL) communication topics are in the `/${productKey}/${deviceName}/topicShortName` format. You can replace `${deviceName}` with the plus sign (`+`) wildcard character. The wildcard character specifies that the topic applies to all devices in the product. Valid values of `topicShortName`:
	//
	//     *   `/thing/event/property/post`: submits the property data of a device.
	//     *   `/thing/event/${tsl.event.identifier}/post`: submits the event data of a device. `${tsl.event.identifier}` specifies the identifier of an event in the TSL model.
	//     *   `/thing/lifecycle`: submits device lifecycle changes.
	//     *   `/thing/downlink/reply/message`: sends a response to a request from IoT Platform.
	//     *   `/thing/list/found`: submits data when a gateway detects a new sub-device.
	//     *   `/thing/topo/lifecycle`: submits device topology changes.
	//     *   `/thing/event/property/history/post`: submits the historical property data of a device.
	//     *   `/thing/event/${tsl.event.identifier}/post`: submits the historical event data of a device. `${tsl.event.identifier}` specifies the identifier of an event in the TSL model.
	//     *   `/ota/upgrade`: submits the over-the-air (OTA) update status.
	//     *   `/ota/version/post`: submits OTA module versions.
	//     *   `/thing/deviceinfo/update`: submits device tag changes.
	//
	//     `/${productKey}/${packageId}/${jobId}/ota/job/status`: submits the status of each OTA update batch. This topic is a basic communication topic. `${packageId}` specifies the ID of the update package. `${jobId}` specifies the ID of the update batch.
	//
	// *   Custom topics are in the `/${productKey}/${deviceName}/user/#` format. Example: `/${productKey}/${deviceName}/user/get`.
	//
	//     You can call the [QueryProductTopic](~~69647~~) operation to view all custom topics of a product.
	//
	//     When you specify a custom topic, you can use the plus sign (`+`) and number sign (`#`) wildcard characters.
	//
	//     *   You can replace `${deviceName}` with the plus sign (`+`) wildcard character. The wildcard character specifies that the topic applies to all devices in the product.
	//     *   You can replace the fields that follow ${deviceName} with `/user/#`. The number sign (`#`) wildcard character specifies that the topic applies to all fields that follow `/user`.
	//
	// *   Topics that are used to submit device status changes are in the `/as/mqtt/status/${productKey}/${deviceName}` format.
	//
	// You can use the plus sign (`+`) wildcard character to specify that the status changes of all devices in the product are submitted.
	//
	// For more information about how to use wildcard characters, see the "Custom topics with wildcard characters" section in [Use custom topics](~~85539~~).
	//
	// For more information about the data formats of topics, see [Data formats](~~73736~~).
	//
	// > You can add only the following topics to the data source in the rules engine for MQTT gateways, devices of MQTT gateways, and products and devices that use the open source MQTT protocol: custom topics, topics that are used to submit device status changes, and topics that are used to submit device lifecycle changes. For more information about custom topics, see the "Messaging" topic. If you set this parameter to a custom topic, you must specify ScopeType and ProductKey. If you set ScopeType to DEVICE, you must specify DeviceName.
	Topic *string `json:"Topic,omitempty" xml:"Topic,omitempty"`
}

func (s CreateDataSourceItemRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDataSourceItemRequest) GoString() string {
	return s.String()
}

func (s *CreateDataSourceItemRequest) SetDataSourceId(v int64) *CreateDataSourceItemRequest {
	s.DataSourceId = &v
	return s
}

func (s *CreateDataSourceItemRequest) SetDeviceName(v string) *CreateDataSourceItemRequest {
	s.DeviceName = &v
	return s
}

func (s *CreateDataSourceItemRequest) SetIotInstanceId(v string) *CreateDataSourceItemRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateDataSourceItemRequest) SetProductKey(v string) *CreateDataSourceItemRequest {
	s.ProductKey = &v
	return s
}

func (s *CreateDataSourceItemRequest) SetScopeType(v string) *CreateDataSourceItemRequest {
	s.ScopeType = &v
	return s
}

func (s *CreateDataSourceItemRequest) SetTopic(v string) *CreateDataSourceItemRequest {
	s.Topic = &v
	return s
}

type CreateDataSourceItemResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDataSourceItemResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDataSourceItemResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDataSourceItemResponseBody) SetCode(v string) *CreateDataSourceItemResponseBody {
	s.Code = &v
	return s
}

func (s *CreateDataSourceItemResponseBody) SetErrorMessage(v string) *CreateDataSourceItemResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDataSourceItemResponseBody) SetRequestId(v string) *CreateDataSourceItemResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDataSourceItemResponseBody) SetSuccess(v bool) *CreateDataSourceItemResponseBody {
	s.Success = &v
	return s
}

type CreateDataSourceItemResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDataSourceItemResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDataSourceItemResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDataSourceItemResponse) GoString() string {
	return s.String()
}

func (s *CreateDataSourceItemResponse) SetHeaders(v map[string]*string) *CreateDataSourceItemResponse {
	s.Headers = v
	return s
}

func (s *CreateDataSourceItemResponse) SetStatusCode(v int32) *CreateDataSourceItemResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDataSourceItemResponse) SetBody(v *CreateDataSourceItemResponseBody) *CreateDataSourceItemResponse {
	s.Body = v
	return s
}

type CreateDestinationRequest struct {
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
	Description   *string `json:"Description,omitempty" xml:"Description,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Name          *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Type          *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateDestinationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDestinationRequest) GoString() string {
	return s.String()
}

func (s *CreateDestinationRequest) SetConfiguration(v string) *CreateDestinationRequest {
	s.Configuration = &v
	return s
}

func (s *CreateDestinationRequest) SetDescription(v string) *CreateDestinationRequest {
	s.Description = &v
	return s
}

func (s *CreateDestinationRequest) SetIotInstanceId(v string) *CreateDestinationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateDestinationRequest) SetName(v string) *CreateDestinationRequest {
	s.Name = &v
	return s
}

func (s *CreateDestinationRequest) SetType(v string) *CreateDestinationRequest {
	s.Type = &v
	return s
}

type CreateDestinationResponseBody struct {
	Code         *string                                   `json:"Code,omitempty" xml:"Code,omitempty"`
	Destination  *CreateDestinationResponseBodyDestination `json:"Destination,omitempty" xml:"Destination,omitempty" type:"Struct"`
	ErrorMessage *string                                   `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                     `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDestinationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDestinationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDestinationResponseBody) SetCode(v string) *CreateDestinationResponseBody {
	s.Code = &v
	return s
}

func (s *CreateDestinationResponseBody) SetDestination(v *CreateDestinationResponseBodyDestination) *CreateDestinationResponseBody {
	s.Destination = v
	return s
}

func (s *CreateDestinationResponseBody) SetErrorMessage(v string) *CreateDestinationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDestinationResponseBody) SetRequestId(v string) *CreateDestinationResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDestinationResponseBody) SetSuccess(v bool) *CreateDestinationResponseBody {
	s.Success = &v
	return s
}

type CreateDestinationResponseBodyDestination struct {
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
	DestinationId *int64  `json:"DestinationId,omitempty" xml:"DestinationId,omitempty"`
	IsFailover    *bool   `json:"IsFailover,omitempty" xml:"IsFailover,omitempty"`
	Name          *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Type          *string `json:"Type,omitempty" xml:"Type,omitempty"`
	UtcCreated    *string `json:"UtcCreated,omitempty" xml:"UtcCreated,omitempty"`
}

func (s CreateDestinationResponseBodyDestination) String() string {
	return tea.Prettify(s)
}

func (s CreateDestinationResponseBodyDestination) GoString() string {
	return s.String()
}

func (s *CreateDestinationResponseBodyDestination) SetConfiguration(v string) *CreateDestinationResponseBodyDestination {
	s.Configuration = &v
	return s
}

func (s *CreateDestinationResponseBodyDestination) SetDestinationId(v int64) *CreateDestinationResponseBodyDestination {
	s.DestinationId = &v
	return s
}

func (s *CreateDestinationResponseBodyDestination) SetIsFailover(v bool) *CreateDestinationResponseBodyDestination {
	s.IsFailover = &v
	return s
}

func (s *CreateDestinationResponseBodyDestination) SetName(v string) *CreateDestinationResponseBodyDestination {
	s.Name = &v
	return s
}

func (s *CreateDestinationResponseBodyDestination) SetType(v string) *CreateDestinationResponseBodyDestination {
	s.Type = &v
	return s
}

func (s *CreateDestinationResponseBodyDestination) SetUtcCreated(v string) *CreateDestinationResponseBodyDestination {
	s.UtcCreated = &v
	return s
}

type CreateDestinationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDestinationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDestinationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDestinationResponse) GoString() string {
	return s.String()
}

func (s *CreateDestinationResponse) SetHeaders(v map[string]*string) *CreateDestinationResponse {
	s.Headers = v
	return s
}

func (s *CreateDestinationResponse) SetStatusCode(v int32) *CreateDestinationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDestinationResponse) SetBody(v *CreateDestinationResponseBody) *CreateDestinationResponse {
	s.Body = v
	return s
}

type CreateDeviceDistributeJobRequest struct {
	// The names of the devices to be distributed. You can specify a maximum of 10,000 device names.
	DeviceName []*string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty" type:"Repeated"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the source instance to which the device belongs.
	//
	// *   The IDs of public instances in different regions:
	//
	//     *   China (Shanghai): iotx-oxssharez200.
	//     *   Japan (Tokyo): iotx-oxssharez300.
	//     *   Singapore (Singapore): iotx-oxssharez400.
	//     *   US (Silicon Valley): iotx-oxssharez500.
	//     *   US (Virginia): iotx-oxssharez600.
	//     *   Germany (Frankfurt): iotx-oxssharez700.
	//
	// *   The IDs of Enterprise Edition instances:
	//
	//     1\. Log on to the IoT Platform console. Select a region from the drop-down list in the upper-left corner of the top navigation bar.
	//
	//     2\. On the **Overview** page, click the instance name. On the **Instance Details** page, view the instance ID in the **Basic Information** section.
	SourceInstanceId *string `json:"SourceInstanceId,omitempty" xml:"SourceInstanceId,omitempty"`
	// The distribution policy. Default value: 0.
	//
	// *   **0**: distributes devices to instances in a specified region.
	// *   **1**: configures instance IDs in multiple regions and distributes devices to the nearest regions based on the IP addresses of the devices.
	Strategy *int32 `json:"Strategy,omitempty" xml:"Strategy,omitempty"`
	// The Alibaba Cloud account to which the device belongs. You can log on to the IoT Platform console, click the profile picture, and then view the account ID on the **Security Settings** page.
	//
	// The **TargetUid** and **TargetAliyunId** parameters cannot be left empty at the same time.
	TargetAliyunId       *string                                                 `json:"TargetAliyunId,omitempty" xml:"TargetAliyunId,omitempty"`
	TargetInstanceConfig []*CreateDeviceDistributeJobRequestTargetInstanceConfig `json:"TargetInstanceConfig,omitempty" xml:"TargetInstanceConfig,omitempty" type:"Repeated"`
	// The ID of the Alibaba Cloud account to which the device belongs. You can log on to the IoT Platform console, click the profile picture, and then view the account ID on the **Security Settings** page.
	//
	// The **TargetUid** and **TargetAliyunId** parameters cannot be left empty at the same time.
	TargetUid *string `json:"TargetUid,omitempty" xml:"TargetUid,omitempty"`
}

func (s CreateDeviceDistributeJobRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceDistributeJobRequest) GoString() string {
	return s.String()
}

func (s *CreateDeviceDistributeJobRequest) SetDeviceName(v []*string) *CreateDeviceDistributeJobRequest {
	s.DeviceName = v
	return s
}

func (s *CreateDeviceDistributeJobRequest) SetProductKey(v string) *CreateDeviceDistributeJobRequest {
	s.ProductKey = &v
	return s
}

func (s *CreateDeviceDistributeJobRequest) SetSourceInstanceId(v string) *CreateDeviceDistributeJobRequest {
	s.SourceInstanceId = &v
	return s
}

func (s *CreateDeviceDistributeJobRequest) SetStrategy(v int32) *CreateDeviceDistributeJobRequest {
	s.Strategy = &v
	return s
}

func (s *CreateDeviceDistributeJobRequest) SetTargetAliyunId(v string) *CreateDeviceDistributeJobRequest {
	s.TargetAliyunId = &v
	return s
}

func (s *CreateDeviceDistributeJobRequest) SetTargetInstanceConfig(v []*CreateDeviceDistributeJobRequestTargetInstanceConfig) *CreateDeviceDistributeJobRequest {
	s.TargetInstanceConfig = v
	return s
}

func (s *CreateDeviceDistributeJobRequest) SetTargetUid(v string) *CreateDeviceDistributeJobRequest {
	s.TargetUid = &v
	return s
}

type CreateDeviceDistributeJobRequestTargetInstanceConfig struct {
	// The configurations of the destination instance to which the device is distributed. For more information about instance IDs, see the description of the **SourceInstanceId** parameter.
	//
	// *   If the value of the **Strategy** parameter is **1**, you can specify multiple instance IDs.
	// *   If the value of the **Strategy** parameter is **0**, you can specify only one instance ID.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
}

func (s CreateDeviceDistributeJobRequestTargetInstanceConfig) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceDistributeJobRequestTargetInstanceConfig) GoString() string {
	return s.String()
}

func (s *CreateDeviceDistributeJobRequestTargetInstanceConfig) SetTargetInstanceId(v string) *CreateDeviceDistributeJobRequestTargetInstanceConfig {
	s.TargetInstanceId = &v
	return s
}

type CreateDeviceDistributeJobResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The task ID returned if the call is successful. The ID globally identifies the task.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDeviceDistributeJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceDistributeJobResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDeviceDistributeJobResponseBody) SetCode(v string) *CreateDeviceDistributeJobResponseBody {
	s.Code = &v
	return s
}

func (s *CreateDeviceDistributeJobResponseBody) SetErrorMessage(v string) *CreateDeviceDistributeJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDeviceDistributeJobResponseBody) SetJobId(v string) *CreateDeviceDistributeJobResponseBody {
	s.JobId = &v
	return s
}

func (s *CreateDeviceDistributeJobResponseBody) SetRequestId(v string) *CreateDeviceDistributeJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDeviceDistributeJobResponseBody) SetSuccess(v bool) *CreateDeviceDistributeJobResponseBody {
	s.Success = &v
	return s
}

type CreateDeviceDistributeJobResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDeviceDistributeJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDeviceDistributeJobResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceDistributeJobResponse) GoString() string {
	return s.String()
}

func (s *CreateDeviceDistributeJobResponse) SetHeaders(v map[string]*string) *CreateDeviceDistributeJobResponse {
	s.Headers = v
	return s
}

func (s *CreateDeviceDistributeJobResponse) SetStatusCode(v int32) *CreateDeviceDistributeJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDeviceDistributeJobResponse) SetBody(v *CreateDeviceDistributeJobResponseBody) *CreateDeviceDistributeJobResponse {
	s.Body = v
	return s
}

type CreateDeviceDynamicGroupRequest struct {
	DynamicGroupExpression *string `json:"DynamicGroupExpression,omitempty" xml:"DynamicGroupExpression,omitempty"`
	GroupDesc              *string `json:"GroupDesc,omitempty" xml:"GroupDesc,omitempty"`
	GroupName              *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	IotInstanceId          *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s CreateDeviceDynamicGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceDynamicGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateDeviceDynamicGroupRequest) SetDynamicGroupExpression(v string) *CreateDeviceDynamicGroupRequest {
	s.DynamicGroupExpression = &v
	return s
}

func (s *CreateDeviceDynamicGroupRequest) SetGroupDesc(v string) *CreateDeviceDynamicGroupRequest {
	s.GroupDesc = &v
	return s
}

func (s *CreateDeviceDynamicGroupRequest) SetGroupName(v string) *CreateDeviceDynamicGroupRequest {
	s.GroupName = &v
	return s
}

func (s *CreateDeviceDynamicGroupRequest) SetIotInstanceId(v string) *CreateDeviceDynamicGroupRequest {
	s.IotInstanceId = &v
	return s
}

type CreateDeviceDynamicGroupResponseBody struct {
	Code         *string                                   `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *CreateDeviceDynamicGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                   `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                     `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDeviceDynamicGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceDynamicGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDeviceDynamicGroupResponseBody) SetCode(v string) *CreateDeviceDynamicGroupResponseBody {
	s.Code = &v
	return s
}

func (s *CreateDeviceDynamicGroupResponseBody) SetData(v *CreateDeviceDynamicGroupResponseBodyData) *CreateDeviceDynamicGroupResponseBody {
	s.Data = v
	return s
}

func (s *CreateDeviceDynamicGroupResponseBody) SetErrorMessage(v string) *CreateDeviceDynamicGroupResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDeviceDynamicGroupResponseBody) SetRequestId(v string) *CreateDeviceDynamicGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDeviceDynamicGroupResponseBody) SetSuccess(v bool) *CreateDeviceDynamicGroupResponseBody {
	s.Success = &v
	return s
}

type CreateDeviceDynamicGroupResponseBodyData struct {
	DynamicGroupExpression *string `json:"DynamicGroupExpression,omitempty" xml:"DynamicGroupExpression,omitempty"`
	GroupDesc              *string `json:"GroupDesc,omitempty" xml:"GroupDesc,omitempty"`
	GroupId                *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	GroupName              *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	UtcCreate              *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
}

func (s CreateDeviceDynamicGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceDynamicGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateDeviceDynamicGroupResponseBodyData) SetDynamicGroupExpression(v string) *CreateDeviceDynamicGroupResponseBodyData {
	s.DynamicGroupExpression = &v
	return s
}

func (s *CreateDeviceDynamicGroupResponseBodyData) SetGroupDesc(v string) *CreateDeviceDynamicGroupResponseBodyData {
	s.GroupDesc = &v
	return s
}

func (s *CreateDeviceDynamicGroupResponseBodyData) SetGroupId(v string) *CreateDeviceDynamicGroupResponseBodyData {
	s.GroupId = &v
	return s
}

func (s *CreateDeviceDynamicGroupResponseBodyData) SetGroupName(v string) *CreateDeviceDynamicGroupResponseBodyData {
	s.GroupName = &v
	return s
}

func (s *CreateDeviceDynamicGroupResponseBodyData) SetUtcCreate(v string) *CreateDeviceDynamicGroupResponseBodyData {
	s.UtcCreate = &v
	return s
}

type CreateDeviceDynamicGroupResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDeviceDynamicGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDeviceDynamicGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceDynamicGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateDeviceDynamicGroupResponse) SetHeaders(v map[string]*string) *CreateDeviceDynamicGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateDeviceDynamicGroupResponse) SetStatusCode(v int32) *CreateDeviceDynamicGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDeviceDynamicGroupResponse) SetBody(v *CreateDeviceDynamicGroupResponseBody) *CreateDeviceDynamicGroupResponse {
	s.Body = v
	return s
}

type CreateDeviceGroupRequest struct {
	// The description of the group. The description must be 1 to 100 characters in length.
	GroupDesc *string `json:"GroupDesc,omitempty" xml:"GroupDesc,omitempty"`
	// The name of the group. The alias must be 4 to 30 characters in length, and can contain letters, digits, and underscores (\_).
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	//
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the parent group.
	//
	// If you need to create a first-level group, do not specify this parameter.
	SuperGroupId *string `json:"SuperGroupId,omitempty" xml:"SuperGroupId,omitempty"`
}

func (s CreateDeviceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceGroupRequest) GoString() string {
	return s.String()
}

func (s *CreateDeviceGroupRequest) SetGroupDesc(v string) *CreateDeviceGroupRequest {
	s.GroupDesc = &v
	return s
}

func (s *CreateDeviceGroupRequest) SetGroupName(v string) *CreateDeviceGroupRequest {
	s.GroupName = &v
	return s
}

func (s *CreateDeviceGroupRequest) SetIotInstanceId(v string) *CreateDeviceGroupRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateDeviceGroupRequest) SetSuperGroupId(v string) *CreateDeviceGroupRequest {
	s.SuperGroupId = &v
	return s
}

type CreateDeviceGroupResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The group information returned if the call succeeds.
	Data *CreateDeviceGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDeviceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDeviceGroupResponseBody) SetCode(v string) *CreateDeviceGroupResponseBody {
	s.Code = &v
	return s
}

func (s *CreateDeviceGroupResponseBody) SetData(v *CreateDeviceGroupResponseBodyData) *CreateDeviceGroupResponseBody {
	s.Data = v
	return s
}

func (s *CreateDeviceGroupResponseBody) SetErrorMessage(v string) *CreateDeviceGroupResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDeviceGroupResponseBody) SetRequestId(v string) *CreateDeviceGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDeviceGroupResponseBody) SetSuccess(v bool) *CreateDeviceGroupResponseBody {
	s.Success = &v
	return s
}

type CreateDeviceGroupResponseBodyData struct {
	// The description of each group.
	GroupDesc *string `json:"GroupDesc,omitempty" xml:"GroupDesc,omitempty"`
	// The ID of the group. The ID is the globally unique identifier (GUID) that the system generates for the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The time when the group was created.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
}

func (s CreateDeviceGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateDeviceGroupResponseBodyData) SetGroupDesc(v string) *CreateDeviceGroupResponseBodyData {
	s.GroupDesc = &v
	return s
}

func (s *CreateDeviceGroupResponseBodyData) SetGroupId(v string) *CreateDeviceGroupResponseBodyData {
	s.GroupId = &v
	return s
}

func (s *CreateDeviceGroupResponseBodyData) SetGroupName(v string) *CreateDeviceGroupResponseBodyData {
	s.GroupName = &v
	return s
}

func (s *CreateDeviceGroupResponseBodyData) SetUtcCreate(v string) *CreateDeviceGroupResponseBodyData {
	s.UtcCreate = &v
	return s
}

type CreateDeviceGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDeviceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDeviceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceGroupResponse) GoString() string {
	return s.String()
}

func (s *CreateDeviceGroupResponse) SetHeaders(v map[string]*string) *CreateDeviceGroupResponse {
	s.Headers = v
	return s
}

func (s *CreateDeviceGroupResponse) SetStatusCode(v int32) *CreateDeviceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDeviceGroupResponse) SetBody(v *CreateDeviceGroupResponseBody) *CreateDeviceGroupResponse {
	s.Body = v
	return s
}

type CreateDeviceTunnelRequest struct {
	Description   *string `json:"Description,omitempty" xml:"Description,omitempty"`
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotId         *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	Udi           *string `json:"Udi,omitempty" xml:"Udi,omitempty"`
}

func (s CreateDeviceTunnelRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceTunnelRequest) GoString() string {
	return s.String()
}

func (s *CreateDeviceTunnelRequest) SetDescription(v string) *CreateDeviceTunnelRequest {
	s.Description = &v
	return s
}

func (s *CreateDeviceTunnelRequest) SetDeviceName(v string) *CreateDeviceTunnelRequest {
	s.DeviceName = &v
	return s
}

func (s *CreateDeviceTunnelRequest) SetIotId(v string) *CreateDeviceTunnelRequest {
	s.IotId = &v
	return s
}

func (s *CreateDeviceTunnelRequest) SetIotInstanceId(v string) *CreateDeviceTunnelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateDeviceTunnelRequest) SetProductKey(v string) *CreateDeviceTunnelRequest {
	s.ProductKey = &v
	return s
}

func (s *CreateDeviceTunnelRequest) SetUdi(v string) *CreateDeviceTunnelRequest {
	s.Udi = &v
	return s
}

type CreateDeviceTunnelResponseBody struct {
	Code         *string                             `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *CreateDeviceTunnelResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                             `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                               `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDeviceTunnelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceTunnelResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDeviceTunnelResponseBody) SetCode(v string) *CreateDeviceTunnelResponseBody {
	s.Code = &v
	return s
}

func (s *CreateDeviceTunnelResponseBody) SetData(v *CreateDeviceTunnelResponseBodyData) *CreateDeviceTunnelResponseBody {
	s.Data = v
	return s
}

func (s *CreateDeviceTunnelResponseBody) SetErrorMessage(v string) *CreateDeviceTunnelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDeviceTunnelResponseBody) SetRequestId(v string) *CreateDeviceTunnelResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDeviceTunnelResponseBody) SetSuccess(v bool) *CreateDeviceTunnelResponseBody {
	s.Success = &v
	return s
}

type CreateDeviceTunnelResponseBodyData struct {
	SourceAccessToken *string `json:"SourceAccessToken,omitempty" xml:"SourceAccessToken,omitempty"`
	SourceURI         *string `json:"SourceURI,omitempty" xml:"SourceURI,omitempty"`
	TunnelId          *string `json:"TunnelId,omitempty" xml:"TunnelId,omitempty"`
}

func (s CreateDeviceTunnelResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceTunnelResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateDeviceTunnelResponseBodyData) SetSourceAccessToken(v string) *CreateDeviceTunnelResponseBodyData {
	s.SourceAccessToken = &v
	return s
}

func (s *CreateDeviceTunnelResponseBodyData) SetSourceURI(v string) *CreateDeviceTunnelResponseBodyData {
	s.SourceURI = &v
	return s
}

func (s *CreateDeviceTunnelResponseBodyData) SetTunnelId(v string) *CreateDeviceTunnelResponseBodyData {
	s.TunnelId = &v
	return s
}

type CreateDeviceTunnelResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDeviceTunnelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDeviceTunnelResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDeviceTunnelResponse) GoString() string {
	return s.String()
}

func (s *CreateDeviceTunnelResponse) SetHeaders(v map[string]*string) *CreateDeviceTunnelResponse {
	s.Headers = v
	return s
}

func (s *CreateDeviceTunnelResponse) SetStatusCode(v int32) *CreateDeviceTunnelResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDeviceTunnelResponse) SetBody(v *CreateDeviceTunnelResponseBody) *CreateDeviceTunnelResponse {
	s.Body = v
	return s
}

type CreateDownloadDataJobRequest struct {
	DownloadDataType *string                `json:"DownloadDataType,omitempty" xml:"DownloadDataType,omitempty"`
	EndTime          *int64                 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	FileConfig       map[string]interface{} `json:"FileConfig,omitempty" xml:"FileConfig,omitempty"`
	IotInstanceId    *string                `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	StartTime        *int64                 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	TableName        *string                `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s CreateDownloadDataJobRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDownloadDataJobRequest) GoString() string {
	return s.String()
}

func (s *CreateDownloadDataJobRequest) SetDownloadDataType(v string) *CreateDownloadDataJobRequest {
	s.DownloadDataType = &v
	return s
}

func (s *CreateDownloadDataJobRequest) SetEndTime(v int64) *CreateDownloadDataJobRequest {
	s.EndTime = &v
	return s
}

func (s *CreateDownloadDataJobRequest) SetFileConfig(v map[string]interface{}) *CreateDownloadDataJobRequest {
	s.FileConfig = v
	return s
}

func (s *CreateDownloadDataJobRequest) SetIotInstanceId(v string) *CreateDownloadDataJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateDownloadDataJobRequest) SetStartTime(v int64) *CreateDownloadDataJobRequest {
	s.StartTime = &v
	return s
}

func (s *CreateDownloadDataJobRequest) SetTableName(v string) *CreateDownloadDataJobRequest {
	s.TableName = &v
	return s
}

type CreateDownloadDataJobShrinkRequest struct {
	DownloadDataType *string `json:"DownloadDataType,omitempty" xml:"DownloadDataType,omitempty"`
	EndTime          *int64  `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	FileConfigShrink *string `json:"FileConfig,omitempty" xml:"FileConfig,omitempty"`
	IotInstanceId    *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	StartTime        *int64  `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	TableName        *string `json:"TableName,omitempty" xml:"TableName,omitempty"`
}

func (s CreateDownloadDataJobShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateDownloadDataJobShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateDownloadDataJobShrinkRequest) SetDownloadDataType(v string) *CreateDownloadDataJobShrinkRequest {
	s.DownloadDataType = &v
	return s
}

func (s *CreateDownloadDataJobShrinkRequest) SetEndTime(v int64) *CreateDownloadDataJobShrinkRequest {
	s.EndTime = &v
	return s
}

func (s *CreateDownloadDataJobShrinkRequest) SetFileConfigShrink(v string) *CreateDownloadDataJobShrinkRequest {
	s.FileConfigShrink = &v
	return s
}

func (s *CreateDownloadDataJobShrinkRequest) SetIotInstanceId(v string) *CreateDownloadDataJobShrinkRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateDownloadDataJobShrinkRequest) SetStartTime(v int64) *CreateDownloadDataJobShrinkRequest {
	s.StartTime = &v
	return s
}

func (s *CreateDownloadDataJobShrinkRequest) SetTableName(v string) *CreateDownloadDataJobShrinkRequest {
	s.TableName = &v
	return s
}

type CreateDownloadDataJobResponseBody struct {
	Code         *string                                `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *CreateDownloadDataJobResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                  `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateDownloadDataJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateDownloadDataJobResponseBody) GoString() string {
	return s.String()
}

func (s *CreateDownloadDataJobResponseBody) SetCode(v string) *CreateDownloadDataJobResponseBody {
	s.Code = &v
	return s
}

func (s *CreateDownloadDataJobResponseBody) SetData(v *CreateDownloadDataJobResponseBodyData) *CreateDownloadDataJobResponseBody {
	s.Data = v
	return s
}

func (s *CreateDownloadDataJobResponseBody) SetErrorMessage(v string) *CreateDownloadDataJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateDownloadDataJobResponseBody) SetRequestId(v string) *CreateDownloadDataJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateDownloadDataJobResponseBody) SetSuccess(v bool) *CreateDownloadDataJobResponseBody {
	s.Success = &v
	return s
}

type CreateDownloadDataJobResponseBodyData struct {
	AsyncExecute *bool   `json:"AsyncExecute,omitempty" xml:"AsyncExecute,omitempty"`
	CsvFileName  *string `json:"CsvFileName,omitempty" xml:"CsvFileName,omitempty"`
	CsvUrl       *string `json:"CsvUrl,omitempty" xml:"CsvUrl,omitempty"`
	LongJobId    *string `json:"LongJobId,omitempty" xml:"LongJobId,omitempty"`
	Status       *int32  `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s CreateDownloadDataJobResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateDownloadDataJobResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateDownloadDataJobResponseBodyData) SetAsyncExecute(v bool) *CreateDownloadDataJobResponseBodyData {
	s.AsyncExecute = &v
	return s
}

func (s *CreateDownloadDataJobResponseBodyData) SetCsvFileName(v string) *CreateDownloadDataJobResponseBodyData {
	s.CsvFileName = &v
	return s
}

func (s *CreateDownloadDataJobResponseBodyData) SetCsvUrl(v string) *CreateDownloadDataJobResponseBodyData {
	s.CsvUrl = &v
	return s
}

func (s *CreateDownloadDataJobResponseBodyData) SetLongJobId(v string) *CreateDownloadDataJobResponseBodyData {
	s.LongJobId = &v
	return s
}

func (s *CreateDownloadDataJobResponseBodyData) SetStatus(v int32) *CreateDownloadDataJobResponseBodyData {
	s.Status = &v
	return s
}

type CreateDownloadDataJobResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateDownloadDataJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateDownloadDataJobResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateDownloadDataJobResponse) GoString() string {
	return s.String()
}

func (s *CreateDownloadDataJobResponse) SetHeaders(v map[string]*string) *CreateDownloadDataJobResponse {
	s.Headers = v
	return s
}

func (s *CreateDownloadDataJobResponse) SetStatusCode(v int32) *CreateDownloadDataJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateDownloadDataJobResponse) SetBody(v *CreateDownloadDataJobResponseBody) *CreateDownloadDataJobResponse {
	s.Body = v
	return s
}

type CreateEdgeDriverRequest struct {
	// The CPU architecture that the driver supports. Valid values:
	//
	// *   ARMv7
	// *   ARMv7-HF
	// *   AArch64
	// *   x86-64
	// *   x86
	CpuArch *string `json:"CpuArch,omitempty" xml:"CpuArch,omitempty"`
	// The name of the driver to create. The name cannot exceed 20 characters in length and can contain only uppercase letters, lowercase letters, digits, and underscores (\_). It must start with a letter.
	DriverName *string `json:"DriverName,omitempty" xml:"DriverName,omitempty"`
	// The communications protocol that the driver uses. Valid values:
	//
	// *   modbus: Modbus protocol
	// *   opc-ua: OPC UA protocol
	// *   customize: custom protocol
	DriverProtocol *string `json:"DriverProtocol,omitempty" xml:"DriverProtocol,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for public instances. However, this parameter is required for the instances that you have purchased.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// Specifies whether the driver is a built-in driver.
	//
	// *   true: indicates that the driver is a built-in driver, that is, the driver code is pre-configured on the gateway device.
	//
	// *   false: indicates that the driver is not a built-in driver and you must upload the driver code. Default value: false.
	//
	// > If the driver is not a built-in driver, you must upload the driver code.
	IsBuiltIn *bool `json:"IsBuiltIn,omitempty" xml:"IsBuiltIn,omitempty"`
	// The language in which the driver is programmed. Valid values:
	//
	// *   nodejs8: Node.js v8
	// *   python3: Python v3.5
	// *   c: C
	Runtime *string `json:"Runtime,omitempty" xml:"Runtime,omitempty"`
}

func (s CreateEdgeDriverRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeDriverRequest) GoString() string {
	return s.String()
}

func (s *CreateEdgeDriverRequest) SetCpuArch(v string) *CreateEdgeDriverRequest {
	s.CpuArch = &v
	return s
}

func (s *CreateEdgeDriverRequest) SetDriverName(v string) *CreateEdgeDriverRequest {
	s.DriverName = &v
	return s
}

func (s *CreateEdgeDriverRequest) SetDriverProtocol(v string) *CreateEdgeDriverRequest {
	s.DriverProtocol = &v
	return s
}

func (s *CreateEdgeDriverRequest) SetIotInstanceId(v string) *CreateEdgeDriverRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateEdgeDriverRequest) SetIsBuiltIn(v bool) *CreateEdgeDriverRequest {
	s.IsBuiltIn = &v
	return s
}

func (s *CreateEdgeDriverRequest) SetRuntime(v string) *CreateEdgeDriverRequest {
	s.Runtime = &v
	return s
}

type CreateEdgeDriverResponseBody struct {
	// The error code. Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the driver created.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The error message returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. true indicates that the call was successful. false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateEdgeDriverResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeDriverResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEdgeDriverResponseBody) SetCode(v string) *CreateEdgeDriverResponseBody {
	s.Code = &v
	return s
}

func (s *CreateEdgeDriverResponseBody) SetDriverId(v string) *CreateEdgeDriverResponseBody {
	s.DriverId = &v
	return s
}

func (s *CreateEdgeDriverResponseBody) SetErrorMessage(v string) *CreateEdgeDriverResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateEdgeDriverResponseBody) SetRequestId(v string) *CreateEdgeDriverResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateEdgeDriverResponseBody) SetSuccess(v bool) *CreateEdgeDriverResponseBody {
	s.Success = &v
	return s
}

type CreateEdgeDriverResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEdgeDriverResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEdgeDriverResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeDriverResponse) GoString() string {
	return s.String()
}

func (s *CreateEdgeDriverResponse) SetHeaders(v map[string]*string) *CreateEdgeDriverResponse {
	s.Headers = v
	return s
}

func (s *CreateEdgeDriverResponse) SetStatusCode(v int32) *CreateEdgeDriverResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEdgeDriverResponse) SetBody(v *CreateEdgeDriverResponseBody) *CreateEdgeDriverResponse {
	s.Body = v
	return s
}

type CreateEdgeDriverVersionRequest struct {
	// The Java Virtual Machine (JVM) startup parameter.
	Argument *string `json:"Argument,omitempty" xml:"Argument,omitempty"`
	// The rule for verifying configurations. Set this parameter to a JSON string in the following format:
	//
	// `{"deviceConfig":{"required":false},"driverConfig":{"required":false}`
	//
	// The JSON string contains the following parameters:
	//
	// *   driverConfig: the rule for verifying the configuration of the driver when the driver is to be deployed in an edge instance.
	// *   deviceConfig: the rule for verifying the configurations of devices that use the driver when the driver is to be deployed in an edge instance.
	//
	// `required`: A value of true indicates that the corresponding parameter is required. A value of false indicates that the corresponding parameter is optional.
	ConfigCheckRule *string `json:"ConfigCheckRule,omitempty" xml:"ConfigCheckRule,omitempty"`
	// The configuration of the container where the driver runs. Set this parameter to a JSON string. For more information about parameters in the JSON string, see the following parameter description of **ContainerConfig**.
	ContainerConfig *string `json:"ContainerConfig,omitempty" xml:"ContainerConfig,omitempty"`
	// The description of the driver. The description can be a maximum of 256 bytes in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The configuration of the driver. Set this parameter to a JSON string in the following format:
	//
	// `{"format":"JSON","content":"{}"}`
	//
	// The JSON string contains the following parameters:
	//
	// *   format: the format of the driver configuration. Valid values: KV (key-value pair), JSON (JSON string), and FILE (configuration file).
	//
	// *   content: the content of the driver configuration. If you set the format parameter to KV or JSON, set this parameter to the configuration content of the driver. If you set the format parameter to FILE, set this parameter to the URL of the driver configuration file stored in OSS.
	//
	// > To obtain the URL of the driver configuration file stored in OSS, call the [CreateOssPreSignedAddress](~~155858~~) operation.
	DriverConfig *string `json:"DriverConfig,omitempty" xml:"DriverConfig,omitempty"`
	// The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver for which you want to create a driver version and obtain the driver ID.
	//
	// You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The version number of the driver. The version number must be unique for the driver. The version number can be up to 64 characters in length and can contain letters, digits, underscores (\_), hyphens (-), and periods (.).
	DriverVersion *string `json:"DriverVersion,omitempty" xml:"DriverVersion,omitempty"`
	// The earliest version of Link IoT Edge that is supported by the driver. The driver can run on gateways of only this version and later. For example, if you set this parameter to 2.4.0, the driver can run on gateways of only version 2.4.0 and later.
	EdgeVersion *string `json:"EdgeVersion,omitempty" xml:"EdgeVersion,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	SourceConfig  *string `json:"SourceConfig,omitempty" xml:"SourceConfig,omitempty"`
}

func (s CreateEdgeDriverVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeDriverVersionRequest) GoString() string {
	return s.String()
}

func (s *CreateEdgeDriverVersionRequest) SetArgument(v string) *CreateEdgeDriverVersionRequest {
	s.Argument = &v
	return s
}

func (s *CreateEdgeDriverVersionRequest) SetConfigCheckRule(v string) *CreateEdgeDriverVersionRequest {
	s.ConfigCheckRule = &v
	return s
}

func (s *CreateEdgeDriverVersionRequest) SetContainerConfig(v string) *CreateEdgeDriverVersionRequest {
	s.ContainerConfig = &v
	return s
}

func (s *CreateEdgeDriverVersionRequest) SetDescription(v string) *CreateEdgeDriverVersionRequest {
	s.Description = &v
	return s
}

func (s *CreateEdgeDriverVersionRequest) SetDriverConfig(v string) *CreateEdgeDriverVersionRequest {
	s.DriverConfig = &v
	return s
}

func (s *CreateEdgeDriverVersionRequest) SetDriverId(v string) *CreateEdgeDriverVersionRequest {
	s.DriverId = &v
	return s
}

func (s *CreateEdgeDriverVersionRequest) SetDriverVersion(v string) *CreateEdgeDriverVersionRequest {
	s.DriverVersion = &v
	return s
}

func (s *CreateEdgeDriverVersionRequest) SetEdgeVersion(v string) *CreateEdgeDriverVersionRequest {
	s.EdgeVersion = &v
	return s
}

func (s *CreateEdgeDriverVersionRequest) SetIotInstanceId(v string) *CreateEdgeDriverVersionRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateEdgeDriverVersionRequest) SetSourceConfig(v string) *CreateEdgeDriverVersionRequest {
	s.SourceConfig = &v
	return s
}

type CreateEdgeDriverVersionResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateEdgeDriverVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeDriverVersionResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEdgeDriverVersionResponseBody) SetCode(v string) *CreateEdgeDriverVersionResponseBody {
	s.Code = &v
	return s
}

func (s *CreateEdgeDriverVersionResponseBody) SetErrorMessage(v string) *CreateEdgeDriverVersionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateEdgeDriverVersionResponseBody) SetRequestId(v string) *CreateEdgeDriverVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateEdgeDriverVersionResponseBody) SetSuccess(v bool) *CreateEdgeDriverVersionResponseBody {
	s.Success = &v
	return s
}

type CreateEdgeDriverVersionResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEdgeDriverVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEdgeDriverVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeDriverVersionResponse) GoString() string {
	return s.String()
}

func (s *CreateEdgeDriverVersionResponse) SetHeaders(v map[string]*string) *CreateEdgeDriverVersionResponse {
	s.Headers = v
	return s
}

func (s *CreateEdgeDriverVersionResponse) SetStatusCode(v int32) *CreateEdgeDriverVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEdgeDriverVersionResponse) SetBody(v *CreateEdgeDriverVersionResponseBody) *CreateEdgeDriverVersionResponse {
	s.Body = v
	return s
}

type CreateEdgeInstanceRequest struct {
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for public instances. However, this parameter is required for the instances that you have purchased.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The name of the edge instance.
	//
	// An instance name cannot exceed 20 characters in length and can contain uppercase letters, lowercase letters, digits, underscores (\_), and hyphens (-).
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The specification of the edge instance.
	//
	// *   10: Lite Edition.
	// *   20: Standard Edition.
	// *   30: Pro Edition.
	//
	// Default value: 20.
	Spec *int32 `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The tags of the edge instance. Syntax of a tag: `key:value`. Multiple tags are separated with commas (,), for example, `k1:v1,k2:v2`.
	//
	// *   Note the following limits on tag keys:
	//
	//     *   Tag values cannot be left empty.
	//     *   Tag keys must be unique in the edge instance.
	//     *   Tag keys only support letters.
	//     *   Each tag key cannot exceed 20 characters in length.
	//
	// *   Note the following limits on tag values:
	//
	//     *   Tag values cannot be left empty.
	//     *   A tag value can contain uppercase letters, lowercase letters, digits, underscores (\_), and hyphens (-).
	//     *   Each tag value cannot exceed 20 characters in length.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s CreateEdgeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeInstanceRequest) GoString() string {
	return s.String()
}

func (s *CreateEdgeInstanceRequest) SetIotInstanceId(v string) *CreateEdgeInstanceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateEdgeInstanceRequest) SetName(v string) *CreateEdgeInstanceRequest {
	s.Name = &v
	return s
}

func (s *CreateEdgeInstanceRequest) SetSpec(v int32) *CreateEdgeInstanceRequest {
	s.Spec = &v
	return s
}

func (s *CreateEdgeInstanceRequest) SetTags(v string) *CreateEdgeInstanceRequest {
	s.Tags = &v
	return s
}

type CreateEdgeInstanceResponseBody struct {
	// The error code. Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the edge instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. true: indicates that the call was successful. false: indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateEdgeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEdgeInstanceResponseBody) SetCode(v string) *CreateEdgeInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *CreateEdgeInstanceResponseBody) SetErrorMessage(v string) *CreateEdgeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateEdgeInstanceResponseBody) SetInstanceId(v string) *CreateEdgeInstanceResponseBody {
	s.InstanceId = &v
	return s
}

func (s *CreateEdgeInstanceResponseBody) SetRequestId(v string) *CreateEdgeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateEdgeInstanceResponseBody) SetSuccess(v bool) *CreateEdgeInstanceResponseBody {
	s.Success = &v
	return s
}

type CreateEdgeInstanceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEdgeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEdgeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeInstanceResponse) GoString() string {
	return s.String()
}

func (s *CreateEdgeInstanceResponse) SetHeaders(v map[string]*string) *CreateEdgeInstanceResponse {
	s.Headers = v
	return s
}

func (s *CreateEdgeInstanceResponse) SetStatusCode(v int32) *CreateEdgeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEdgeInstanceResponse) SetBody(v *CreateEdgeInstanceResponseBody) *CreateEdgeInstanceResponse {
	s.Body = v
	return s
}

type CreateEdgeInstanceChannelRequest struct {
	ChannelName   *string                                    `json:"ChannelName,omitempty" xml:"ChannelName,omitempty"`
	Configs       []*CreateEdgeInstanceChannelRequestConfigs `json:"Configs,omitempty" xml:"Configs,omitempty" type:"Repeated"`
	DriverId      *string                                    `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	InstanceId    *string                                    `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string                                    `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s CreateEdgeInstanceChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeInstanceChannelRequest) GoString() string {
	return s.String()
}

func (s *CreateEdgeInstanceChannelRequest) SetChannelName(v string) *CreateEdgeInstanceChannelRequest {
	s.ChannelName = &v
	return s
}

func (s *CreateEdgeInstanceChannelRequest) SetConfigs(v []*CreateEdgeInstanceChannelRequestConfigs) *CreateEdgeInstanceChannelRequest {
	s.Configs = v
	return s
}

func (s *CreateEdgeInstanceChannelRequest) SetDriverId(v string) *CreateEdgeInstanceChannelRequest {
	s.DriverId = &v
	return s
}

func (s *CreateEdgeInstanceChannelRequest) SetInstanceId(v string) *CreateEdgeInstanceChannelRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateEdgeInstanceChannelRequest) SetIotInstanceId(v string) *CreateEdgeInstanceChannelRequest {
	s.IotInstanceId = &v
	return s
}

type CreateEdgeInstanceChannelRequestConfigs struct {
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	Format  *string `json:"Format,omitempty" xml:"Format,omitempty"`
	Key     *string `json:"Key,omitempty" xml:"Key,omitempty"`
}

func (s CreateEdgeInstanceChannelRequestConfigs) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeInstanceChannelRequestConfigs) GoString() string {
	return s.String()
}

func (s *CreateEdgeInstanceChannelRequestConfigs) SetContent(v string) *CreateEdgeInstanceChannelRequestConfigs {
	s.Content = &v
	return s
}

func (s *CreateEdgeInstanceChannelRequestConfigs) SetFormat(v string) *CreateEdgeInstanceChannelRequestConfigs {
	s.Format = &v
	return s
}

func (s *CreateEdgeInstanceChannelRequestConfigs) SetKey(v string) *CreateEdgeInstanceChannelRequestConfigs {
	s.Key = &v
	return s
}

type CreateEdgeInstanceChannelResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateEdgeInstanceChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeInstanceChannelResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEdgeInstanceChannelResponseBody) SetCode(v string) *CreateEdgeInstanceChannelResponseBody {
	s.Code = &v
	return s
}

func (s *CreateEdgeInstanceChannelResponseBody) SetData(v string) *CreateEdgeInstanceChannelResponseBody {
	s.Data = &v
	return s
}

func (s *CreateEdgeInstanceChannelResponseBody) SetErrorMessage(v string) *CreateEdgeInstanceChannelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateEdgeInstanceChannelResponseBody) SetRequestId(v string) *CreateEdgeInstanceChannelResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateEdgeInstanceChannelResponseBody) SetSuccess(v bool) *CreateEdgeInstanceChannelResponseBody {
	s.Success = &v
	return s
}

type CreateEdgeInstanceChannelResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEdgeInstanceChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEdgeInstanceChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeInstanceChannelResponse) GoString() string {
	return s.String()
}

func (s *CreateEdgeInstanceChannelResponse) SetHeaders(v map[string]*string) *CreateEdgeInstanceChannelResponse {
	s.Headers = v
	return s
}

func (s *CreateEdgeInstanceChannelResponse) SetStatusCode(v int32) *CreateEdgeInstanceChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEdgeInstanceChannelResponse) SetBody(v *CreateEdgeInstanceChannelResponseBody) *CreateEdgeInstanceChannelResponse {
	s.Body = v
	return s
}

type CreateEdgeInstanceDeploymentRequest struct {
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance for which you want to create a deployment task and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The type of the deployment task.
	//
	// *   deploy: deploys the edge instance.
	// *   reset: resets the edge instance.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateEdgeInstanceDeploymentRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeInstanceDeploymentRequest) GoString() string {
	return s.String()
}

func (s *CreateEdgeInstanceDeploymentRequest) SetInstanceId(v string) *CreateEdgeInstanceDeploymentRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateEdgeInstanceDeploymentRequest) SetIotInstanceId(v string) *CreateEdgeInstanceDeploymentRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateEdgeInstanceDeploymentRequest) SetType(v string) *CreateEdgeInstanceDeploymentRequest {
	s.Type = &v
	return s
}

type CreateEdgeInstanceDeploymentResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The deployment task ID that is returned if the call was successful.
	DeploymentId *string `json:"DeploymentId,omitempty" xml:"DeploymentId,omitempty"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateEdgeInstanceDeploymentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeInstanceDeploymentResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEdgeInstanceDeploymentResponseBody) SetCode(v string) *CreateEdgeInstanceDeploymentResponseBody {
	s.Code = &v
	return s
}

func (s *CreateEdgeInstanceDeploymentResponseBody) SetDeploymentId(v string) *CreateEdgeInstanceDeploymentResponseBody {
	s.DeploymentId = &v
	return s
}

func (s *CreateEdgeInstanceDeploymentResponseBody) SetErrorMessage(v string) *CreateEdgeInstanceDeploymentResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateEdgeInstanceDeploymentResponseBody) SetRequestId(v string) *CreateEdgeInstanceDeploymentResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateEdgeInstanceDeploymentResponseBody) SetSuccess(v bool) *CreateEdgeInstanceDeploymentResponseBody {
	s.Success = &v
	return s
}

type CreateEdgeInstanceDeploymentResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEdgeInstanceDeploymentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEdgeInstanceDeploymentResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeInstanceDeploymentResponse) GoString() string {
	return s.String()
}

func (s *CreateEdgeInstanceDeploymentResponse) SetHeaders(v map[string]*string) *CreateEdgeInstanceDeploymentResponse {
	s.Headers = v
	return s
}

func (s *CreateEdgeInstanceDeploymentResponse) SetStatusCode(v int32) *CreateEdgeInstanceDeploymentResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEdgeInstanceDeploymentResponse) SetBody(v *CreateEdgeInstanceDeploymentResponseBody) *CreateEdgeInstanceDeploymentResponse {
	s.Body = v
	return s
}

type CreateEdgeInstanceMessageRoutingRequest struct {
	InstanceId      *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId   *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Name            *string `json:"Name,omitempty" xml:"Name,omitempty"`
	SourceData      *string `json:"SourceData,omitempty" xml:"SourceData,omitempty"`
	SourceType      *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	TargetData      *string `json:"TargetData,omitempty" xml:"TargetData,omitempty"`
	TargetIotHubQos *int32  `json:"TargetIotHubQos,omitempty" xml:"TargetIotHubQos,omitempty"`
	TargetType      *string `json:"TargetType,omitempty" xml:"TargetType,omitempty"`
	TopicFilter     *string `json:"TopicFilter,omitempty" xml:"TopicFilter,omitempty"`
}

func (s CreateEdgeInstanceMessageRoutingRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeInstanceMessageRoutingRequest) GoString() string {
	return s.String()
}

func (s *CreateEdgeInstanceMessageRoutingRequest) SetInstanceId(v string) *CreateEdgeInstanceMessageRoutingRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateEdgeInstanceMessageRoutingRequest) SetIotInstanceId(v string) *CreateEdgeInstanceMessageRoutingRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateEdgeInstanceMessageRoutingRequest) SetName(v string) *CreateEdgeInstanceMessageRoutingRequest {
	s.Name = &v
	return s
}

func (s *CreateEdgeInstanceMessageRoutingRequest) SetSourceData(v string) *CreateEdgeInstanceMessageRoutingRequest {
	s.SourceData = &v
	return s
}

func (s *CreateEdgeInstanceMessageRoutingRequest) SetSourceType(v string) *CreateEdgeInstanceMessageRoutingRequest {
	s.SourceType = &v
	return s
}

func (s *CreateEdgeInstanceMessageRoutingRequest) SetTargetData(v string) *CreateEdgeInstanceMessageRoutingRequest {
	s.TargetData = &v
	return s
}

func (s *CreateEdgeInstanceMessageRoutingRequest) SetTargetIotHubQos(v int32) *CreateEdgeInstanceMessageRoutingRequest {
	s.TargetIotHubQos = &v
	return s
}

func (s *CreateEdgeInstanceMessageRoutingRequest) SetTargetType(v string) *CreateEdgeInstanceMessageRoutingRequest {
	s.TargetType = &v
	return s
}

func (s *CreateEdgeInstanceMessageRoutingRequest) SetTopicFilter(v string) *CreateEdgeInstanceMessageRoutingRequest {
	s.TopicFilter = &v
	return s
}

type CreateEdgeInstanceMessageRoutingResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	RouteId      *int64  `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateEdgeInstanceMessageRoutingResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeInstanceMessageRoutingResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEdgeInstanceMessageRoutingResponseBody) SetCode(v string) *CreateEdgeInstanceMessageRoutingResponseBody {
	s.Code = &v
	return s
}

func (s *CreateEdgeInstanceMessageRoutingResponseBody) SetErrorMessage(v string) *CreateEdgeInstanceMessageRoutingResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateEdgeInstanceMessageRoutingResponseBody) SetRequestId(v string) *CreateEdgeInstanceMessageRoutingResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateEdgeInstanceMessageRoutingResponseBody) SetRouteId(v int64) *CreateEdgeInstanceMessageRoutingResponseBody {
	s.RouteId = &v
	return s
}

func (s *CreateEdgeInstanceMessageRoutingResponseBody) SetSuccess(v bool) *CreateEdgeInstanceMessageRoutingResponseBody {
	s.Success = &v
	return s
}

type CreateEdgeInstanceMessageRoutingResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEdgeInstanceMessageRoutingResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEdgeInstanceMessageRoutingResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeInstanceMessageRoutingResponse) GoString() string {
	return s.String()
}

func (s *CreateEdgeInstanceMessageRoutingResponse) SetHeaders(v map[string]*string) *CreateEdgeInstanceMessageRoutingResponse {
	s.Headers = v
	return s
}

func (s *CreateEdgeInstanceMessageRoutingResponse) SetStatusCode(v int32) *CreateEdgeInstanceMessageRoutingResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEdgeInstanceMessageRoutingResponse) SetBody(v *CreateEdgeInstanceMessageRoutingResponseBody) *CreateEdgeInstanceMessageRoutingResponse {
	s.Body = v
	return s
}

type CreateEdgeOssPreSignedAddressRequest struct {
	// The name of the object whose URL is to be obtained. The format is `<File name>.<File name extension>`.
	FileName *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that uses the driver and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	//
	// >  When the **Type** parameter is set to **INSTANCE_DRIVER_VERSION_CONFIG**, this parameter is required.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the resource for which the object URL is to be obtained. Only driver resources are supported. Set this parameter to the ID of the corresponding driver.
	//
	// To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver for which the object URL you want to obtain and obtain the driver ID. You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The version number of the resource. Only driver resources are supported. Set this parameter to the version number of the corresponding driver.
	ResourceVersion *string `json:"ResourceVersion,omitempty" xml:"ResourceVersion,omitempty"`
	// The content type of the object. Valid values:
	//
	// *   DRIVER_VERSION_CONTENT: the code of a specific driver version.
	// *   DRIVER_VERSION_DEFAULT_CONFIG: the default configuration of a specific driver version.
	// *   INSTANCE_DRIVER_VERSION_CONFIG: the configuration of a specific driver version that is used in an edge instance.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateEdgeOssPreSignedAddressRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeOssPreSignedAddressRequest) GoString() string {
	return s.String()
}

func (s *CreateEdgeOssPreSignedAddressRequest) SetFileName(v string) *CreateEdgeOssPreSignedAddressRequest {
	s.FileName = &v
	return s
}

func (s *CreateEdgeOssPreSignedAddressRequest) SetInstanceId(v string) *CreateEdgeOssPreSignedAddressRequest {
	s.InstanceId = &v
	return s
}

func (s *CreateEdgeOssPreSignedAddressRequest) SetIotInstanceId(v string) *CreateEdgeOssPreSignedAddressRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateEdgeOssPreSignedAddressRequest) SetResourceId(v string) *CreateEdgeOssPreSignedAddressRequest {
	s.ResourceId = &v
	return s
}

func (s *CreateEdgeOssPreSignedAddressRequest) SetResourceVersion(v string) *CreateEdgeOssPreSignedAddressRequest {
	s.ResourceVersion = &v
	return s
}

func (s *CreateEdgeOssPreSignedAddressRequest) SetType(v string) *CreateEdgeOssPreSignedAddressRequest {
	s.Type = &v
	return s
}

type CreateEdgeOssPreSignedAddressResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned if the call was successful.
	Data *CreateEdgeOssPreSignedAddressResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateEdgeOssPreSignedAddressResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeOssPreSignedAddressResponseBody) GoString() string {
	return s.String()
}

func (s *CreateEdgeOssPreSignedAddressResponseBody) SetCode(v string) *CreateEdgeOssPreSignedAddressResponseBody {
	s.Code = &v
	return s
}

func (s *CreateEdgeOssPreSignedAddressResponseBody) SetData(v *CreateEdgeOssPreSignedAddressResponseBodyData) *CreateEdgeOssPreSignedAddressResponseBody {
	s.Data = v
	return s
}

func (s *CreateEdgeOssPreSignedAddressResponseBody) SetErrorMessage(v string) *CreateEdgeOssPreSignedAddressResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateEdgeOssPreSignedAddressResponseBody) SetRequestId(v string) *CreateEdgeOssPreSignedAddressResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateEdgeOssPreSignedAddressResponseBody) SetSuccess(v bool) *CreateEdgeOssPreSignedAddressResponseBody {
	s.Success = &v
	return s
}

type CreateEdgeOssPreSignedAddressResponseBodyData struct {
	// The URL of the OSS object.
	OssAddress *string `json:"OssAddress,omitempty" xml:"OssAddress,omitempty"`
	// The pre-signed URL of the OSS object. For more information, see [OSS documentation](~~32016~~).
	OssPreSignedAddress *string `json:"OssPreSignedAddress,omitempty" xml:"OssPreSignedAddress,omitempty"`
}

func (s CreateEdgeOssPreSignedAddressResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeOssPreSignedAddressResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateEdgeOssPreSignedAddressResponseBodyData) SetOssAddress(v string) *CreateEdgeOssPreSignedAddressResponseBodyData {
	s.OssAddress = &v
	return s
}

func (s *CreateEdgeOssPreSignedAddressResponseBodyData) SetOssPreSignedAddress(v string) *CreateEdgeOssPreSignedAddressResponseBodyData {
	s.OssPreSignedAddress = &v
	return s
}

type CreateEdgeOssPreSignedAddressResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateEdgeOssPreSignedAddressResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateEdgeOssPreSignedAddressResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateEdgeOssPreSignedAddressResponse) GoString() string {
	return s.String()
}

func (s *CreateEdgeOssPreSignedAddressResponse) SetHeaders(v map[string]*string) *CreateEdgeOssPreSignedAddressResponse {
	s.Headers = v
	return s
}

func (s *CreateEdgeOssPreSignedAddressResponse) SetStatusCode(v int32) *CreateEdgeOssPreSignedAddressResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateEdgeOssPreSignedAddressResponse) SetBody(v *CreateEdgeOssPreSignedAddressResponseBody) *CreateEdgeOssPreSignedAddressResponse {
	s.Body = v
	return s
}

type CreateJobRequest struct {
	Description   *string                `json:"Description,omitempty" xml:"Description,omitempty"`
	IotInstanceId *string                `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	JobDocument   *string                `json:"JobDocument,omitempty" xml:"JobDocument,omitempty"`
	JobFile       map[string]interface{} `json:"JobFile,omitempty" xml:"JobFile,omitempty"`
	JobName       *string                `json:"JobName,omitempty" xml:"JobName,omitempty"`
	RolloutConfig map[string]interface{} `json:"RolloutConfig,omitempty" xml:"RolloutConfig,omitempty"`
	ScheduledTime *int64                 `json:"ScheduledTime,omitempty" xml:"ScheduledTime,omitempty"`
	TargetConfig  map[string]interface{} `json:"TargetConfig,omitempty" xml:"TargetConfig,omitempty"`
	TimeoutConfig map[string]interface{} `json:"TimeoutConfig,omitempty" xml:"TimeoutConfig,omitempty"`
	Type          *string                `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateJobRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateJobRequest) GoString() string {
	return s.String()
}

func (s *CreateJobRequest) SetDescription(v string) *CreateJobRequest {
	s.Description = &v
	return s
}

func (s *CreateJobRequest) SetIotInstanceId(v string) *CreateJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateJobRequest) SetJobDocument(v string) *CreateJobRequest {
	s.JobDocument = &v
	return s
}

func (s *CreateJobRequest) SetJobFile(v map[string]interface{}) *CreateJobRequest {
	s.JobFile = v
	return s
}

func (s *CreateJobRequest) SetJobName(v string) *CreateJobRequest {
	s.JobName = &v
	return s
}

func (s *CreateJobRequest) SetRolloutConfig(v map[string]interface{}) *CreateJobRequest {
	s.RolloutConfig = v
	return s
}

func (s *CreateJobRequest) SetScheduledTime(v int64) *CreateJobRequest {
	s.ScheduledTime = &v
	return s
}

func (s *CreateJobRequest) SetTargetConfig(v map[string]interface{}) *CreateJobRequest {
	s.TargetConfig = v
	return s
}

func (s *CreateJobRequest) SetTimeoutConfig(v map[string]interface{}) *CreateJobRequest {
	s.TimeoutConfig = v
	return s
}

func (s *CreateJobRequest) SetType(v string) *CreateJobRequest {
	s.Type = &v
	return s
}

type CreateJobShrinkRequest struct {
	Description         *string `json:"Description,omitempty" xml:"Description,omitempty"`
	IotInstanceId       *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	JobDocument         *string `json:"JobDocument,omitempty" xml:"JobDocument,omitempty"`
	JobFileShrink       *string `json:"JobFile,omitempty" xml:"JobFile,omitempty"`
	JobName             *string `json:"JobName,omitempty" xml:"JobName,omitempty"`
	RolloutConfigShrink *string `json:"RolloutConfig,omitempty" xml:"RolloutConfig,omitempty"`
	ScheduledTime       *int64  `json:"ScheduledTime,omitempty" xml:"ScheduledTime,omitempty"`
	TargetConfigShrink  *string `json:"TargetConfig,omitempty" xml:"TargetConfig,omitempty"`
	TimeoutConfigShrink *string `json:"TimeoutConfig,omitempty" xml:"TimeoutConfig,omitempty"`
	Type                *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateJobShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateJobShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateJobShrinkRequest) SetDescription(v string) *CreateJobShrinkRequest {
	s.Description = &v
	return s
}

func (s *CreateJobShrinkRequest) SetIotInstanceId(v string) *CreateJobShrinkRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateJobShrinkRequest) SetJobDocument(v string) *CreateJobShrinkRequest {
	s.JobDocument = &v
	return s
}

func (s *CreateJobShrinkRequest) SetJobFileShrink(v string) *CreateJobShrinkRequest {
	s.JobFileShrink = &v
	return s
}

func (s *CreateJobShrinkRequest) SetJobName(v string) *CreateJobShrinkRequest {
	s.JobName = &v
	return s
}

func (s *CreateJobShrinkRequest) SetRolloutConfigShrink(v string) *CreateJobShrinkRequest {
	s.RolloutConfigShrink = &v
	return s
}

func (s *CreateJobShrinkRequest) SetScheduledTime(v int64) *CreateJobShrinkRequest {
	s.ScheduledTime = &v
	return s
}

func (s *CreateJobShrinkRequest) SetTargetConfigShrink(v string) *CreateJobShrinkRequest {
	s.TargetConfigShrink = &v
	return s
}

func (s *CreateJobShrinkRequest) SetTimeoutConfigShrink(v string) *CreateJobShrinkRequest {
	s.TimeoutConfigShrink = &v
	return s
}

func (s *CreateJobShrinkRequest) SetType(v string) *CreateJobShrinkRequest {
	s.Type = &v
	return s
}

type CreateJobResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	JobId        *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateJobResponseBody) GoString() string {
	return s.String()
}

func (s *CreateJobResponseBody) SetCode(v string) *CreateJobResponseBody {
	s.Code = &v
	return s
}

func (s *CreateJobResponseBody) SetErrorMessage(v string) *CreateJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateJobResponseBody) SetJobId(v string) *CreateJobResponseBody {
	s.JobId = &v
	return s
}

func (s *CreateJobResponseBody) SetRequestId(v string) *CreateJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateJobResponseBody) SetSuccess(v bool) *CreateJobResponseBody {
	s.Success = &v
	return s
}

type CreateJobResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateJobResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateJobResponse) GoString() string {
	return s.String()
}

func (s *CreateJobResponse) SetHeaders(v map[string]*string) *CreateJobResponse {
	s.Headers = v
	return s
}

func (s *CreateJobResponse) SetStatusCode(v int32) *CreateJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateJobResponse) SetBody(v *CreateJobResponseBody) *CreateJobResponse {
	s.Body = v
	return s
}

type CreateLoRaNodesTaskRequest struct {
	// The LoRaWAN devices.
	DeviceInfo []*CreateLoRaNodesTaskRequestDeviceInfo `json:"DeviceInfo,omitempty" xml:"DeviceInfo,omitempty" type:"Repeated"`
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
	//
	// For more information, see the [Overview](~~356505~~) topic of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the devices belong.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s CreateLoRaNodesTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateLoRaNodesTaskRequest) GoString() string {
	return s.String()
}

func (s *CreateLoRaNodesTaskRequest) SetDeviceInfo(v []*CreateLoRaNodesTaskRequestDeviceInfo) *CreateLoRaNodesTaskRequest {
	s.DeviceInfo = v
	return s
}

func (s *CreateLoRaNodesTaskRequest) SetIotInstanceId(v string) *CreateLoRaNodesTaskRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateLoRaNodesTaskRequest) SetProductKey(v string) *CreateLoRaNodesTaskRequest {
	s.ProductKey = &v
	return s
}

type CreateLoRaNodesTaskRequestDeviceInfo struct {
	// The DevEUI of the LoRaWAN device.
	DevEui *string `json:"DevEui,omitempty" xml:"DevEui,omitempty"`
	// The PIN code of the LoRaWAN device. The value of the parameter is used to verify the DevEUI.
	PinCode *string `json:"PinCode,omitempty" xml:"PinCode,omitempty"`
}

func (s CreateLoRaNodesTaskRequestDeviceInfo) String() string {
	return tea.Prettify(s)
}

func (s CreateLoRaNodesTaskRequestDeviceInfo) GoString() string {
	return s.String()
}

func (s *CreateLoRaNodesTaskRequestDeviceInfo) SetDevEui(v string) *CreateLoRaNodesTaskRequestDeviceInfo {
	s.DevEui = &v
	return s
}

func (s *CreateLoRaNodesTaskRequestDeviceInfo) SetPinCode(v string) *CreateLoRaNodesTaskRequestDeviceInfo {
	s.PinCode = &v
	return s
}

type CreateLoRaNodesTaskResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The task ID returned if the request was successful.
	//
	// > Record the ID. You must use the ID to query the status of the device creation task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s CreateLoRaNodesTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateLoRaNodesTaskResponseBody) GoString() string {
	return s.String()
}

func (s *CreateLoRaNodesTaskResponseBody) SetCode(v string) *CreateLoRaNodesTaskResponseBody {
	s.Code = &v
	return s
}

func (s *CreateLoRaNodesTaskResponseBody) SetErrorMessage(v string) *CreateLoRaNodesTaskResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateLoRaNodesTaskResponseBody) SetRequestId(v string) *CreateLoRaNodesTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateLoRaNodesTaskResponseBody) SetSuccess(v bool) *CreateLoRaNodesTaskResponseBody {
	s.Success = &v
	return s
}

func (s *CreateLoRaNodesTaskResponseBody) SetTaskId(v string) *CreateLoRaNodesTaskResponseBody {
	s.TaskId = &v
	return s
}

type CreateLoRaNodesTaskResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateLoRaNodesTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateLoRaNodesTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateLoRaNodesTaskResponse) GoString() string {
	return s.String()
}

func (s *CreateLoRaNodesTaskResponse) SetHeaders(v map[string]*string) *CreateLoRaNodesTaskResponse {
	s.Headers = v
	return s
}

func (s *CreateLoRaNodesTaskResponse) SetStatusCode(v int32) *CreateLoRaNodesTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateLoRaNodesTaskResponse) SetBody(v *CreateLoRaNodesTaskResponseBody) *CreateLoRaNodesTaskResponse {
	s.Body = v
	return s
}

type CreateOTADynamicUpgradeJobRequest struct {
	// Specifies whether the device supports simultaneous updates of multiple modules. Default value: false. Valid values:
	//
	// *   **false**
	//
	// *   **true**: In this case, do not set **OverwriteMode** to **2**.********
	//
	//     The update tasks for the same module are overwritten. The update tasks that are in progress are not overwritten. The update tasks of the modules do not affect each other.
	//
	// >*   Only Enterprise Edition instances and new public instances are supported.
	// >*   You must use Link SDK for C 4.x to develop the device.
	// >*   If you initiate a group-based dynamic update batch, the settings of **MultiModuleMode** and **OverwriteMode** must be the same as those in the existing dynamic update batch of the group.
	//
	// For more information, see [Overview](~~58328~~).
	DownloadProtocol *string `json:"DownloadProtocol,omitempty" xml:"DownloadProtocol,omitempty"`
	// Specifies whether to automatically push update tasks from IoT Platform to devices. Default value: true. Valid values:
	//
	// *   **true**: After an update batch is created, IoT Platform automatically pushes update tasks to the specified online devices.
	//
	//     In this case, a device can still initiate a request to obtain the information about the over-the-air (OTA) update task from IoT Platform.
	//
	// *   **false**: A device must initiate a request to obtain the information about the OTA update task from IoT Platform.
	DynamicMode *int32 `json:"DynamicMode,omitempty" xml:"DynamicMode,omitempty"`
	// The **ProductKey** of the product to which the update package belongs.
	//
	// A **ProductKey** is the unique identifier of a product in IoT Platform. You can view the information about all products within the current Alibaba Cloud account in the IoT Platform console or by calling the [QueryProductList](~~69271~~) operation.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The type of the group. Valid value: **LINK_PLATFORM_DYNAMIC**.
	//
	// *   If you specify this parameter, you must also specify the **GroupId** parameter. In this case, do not specify the **SrcVersion.N** parameter.
	// *   If you do not specify this parameter, you do not need to specify the **GroupId** parameter. In this case, you must specify the **SrcVersion.N** parameter.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The download protocol of the update package. Valid values: **HTTPS** and **MQTT**. Default value: HTTPS. After the device receives the update package information pushed by IoT Platform, this protocol is used to download the update package.
	//
	// > If you need to download the update package over MQTT, take note of the following items:
	// >*   Your service must be deployed in the China (Shanghai) region.
	// >*   The OTA update package can contain only one file, and the size of the file cannot exceed 16 MB.
	// >*   You must use the latest version of Link SDK for C to develop the device features to perform OTA updates and download files over MQTT. For more information, see [Sample code](~~330985~~).
	GroupType *string `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The ID of the update package.
	//
	// An update package ID is returned when you call the [CreateOTAFirmware](~~147311~~) operation to create the update package.
	//
	// You can also call the [ListOTAFirmware](~~147450~~) operation to obtain the ID.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// Specifies whether to overwrite the previous update task. Default value: 1. Valid values:
	//
	// *   **1**: The previous update task is not overwritten. If a device already has an update task, the previous update task is implemented.
	// *   **2**: The previous update task is overwritten. Only the current update task is implemented. In this case, you cannot set **MultiModuleMode** to **true**.
	//
	// >  The update task that is in progress is not overwritten.
	MaximumPerMinute *int32 `json:"MaximumPerMinute,omitempty" xml:"MaximumPerMinute,omitempty"`
	// The list of firmware versions to be updated.
	//
	// *   If you specify this parameter, do not specify the **GroupId** and **GroupType** parameters.
	// *   If you do not specify this parameter, you must specify the **GroupId** and **GroupType** parameters.
	//
	// > If you use differential update packages to perform dynamic update tasks on dynamic groups, you do not need to specify this parameter.
	// >*   If you use differential update packages to perform dynamic update tasks based on versions, the value of this parameter must be the same as the value of **SrcVersion**.
	// >*   You can call the [QueryDeviceDetail](~~69594~~) operation and view the **FirmwareVersion** parameter in the response.
	// >*   The version numbers must be unique in the list.
	// >*   You can specify a maximum of 10 version numbers.
	MultiModuleMode *bool `json:"MultiModuleMode,omitempty" xml:"MultiModuleMode,omitempty"`
	// The ID of the group.
	//
	// *   If you specify this parameter, you must also specify the **GroupType** parameter. In this case, do not specify the **SrcVersion.N** parameter.
	// *   If you do not specify this parameter, you do not need to specify the **GroupType** parameter. In this case, you must specify the **SrcVersion.N** parameter.
	//
	// You can call the [QueryDeviceGroupList](~~93356~~) operation to query the **GroupId** parameter.
	NeedConfirm *bool `json:"NeedConfirm,omitempty" xml:"NeedConfirm,omitempty"`
	// Specifies whether to control the update by using a mobile app. You must develop the mobile app as needed. Default value: false. Valid values:
	//
	// *   **false**: A device obtains the information about the OTA update task based on the **NeedPush** parameter.
	// *   **true**: To perform an OTA update on a device, you must confirm the update by using your mobile app. Then, the device can obtain the information about the OTA update task based on the **NeedPush** parameter.
	NeedPush *bool `json:"NeedPush,omitempty" xml:"NeedPush,omitempty"`
	// The mode of dynamic update. Default value: 1. Valid values:
	//
	// *   **1**: constantly updates the devices that meet the conditions.
	// *   **2**: updates only the devices that subsequently submit the latest firmware versions.
	OverwriteMode *int32 `json:"OverwriteMode,omitempty" xml:"OverwriteMode,omitempty"`
	// The automatic retry interval if a device fails to be updated. Unit: minutes. Valid values:
	//
	// *   **0**: An automatic retry is immediately performed.
	// *   **10**: An automatic retry is performed after 10 minutes.
	// *   **30**: An automatic retry is performed after 30 minutes.
	// *   **60**: An automatic retry is performed after 60 minutes (1 hour).
	// *   **1440**: An automatic retry is performed after 1,440 minutes (24 hours).
	//
	// > The value of the **RetryInterval** parameter must be less than the value of the **TimeoutInMinutes** parameter. Examples:
	// >*   If the value of the **TimeoutInMinutes** parameter is set to 60, the maximum value of the **RetryInterval** parameter is 30.
	// >*   If the value of the **TimeoutInMinutes** parameter is set to 1440, the maximum value of the **RetryInterval** parameter is 60.
	//
	// If the value of the **RetryInterval** parameter is set to 1440, we recommend that you do not specify the **TimeoutInMinutes** parameter. If an update times out, no retry is performed.
	//
	// If you do not specify this parameter, no retry is performed.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The timeout period of the update. If the device is not updated within the specified period, a timeout error occurs. Unit: minutes. Valid values: 1 to 1440.
	//
	// > *   The timeout period starts from the time when the specified device submits the update progress for the first time. During the update, the update package may be repeatedly pushed to the specified device because the device goes online and offline multiple times. The start time of the update period remains unchanged.
	// >*   If an update fails due to timeout, no retry is triggered.
	//
	// If you do not specify this parameter, timeout errors do not occur.
	RetryCount *int32 `json:"RetryCount,omitempty" xml:"RetryCount,omitempty"`
	// The number of automatic retries.
	//
	// If you specify the **RetryInterval** parameter, you must specify this parameter.
	//
	// Valid values:
	//
	// *   **1**: retries once.
	// *   **2**: retries twice.
	// *   **5**: retries five times.
	RetryInterval *int32                                  `json:"RetryInterval,omitempty" xml:"RetryInterval,omitempty"`
	SrcVersion    []*string                               `json:"SrcVersion,omitempty" xml:"SrcVersion,omitempty" type:"Repeated"`
	Tag           []*CreateOTADynamicUpgradeJobRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	// The maximum number of devices to which the download URL of the update package is pushed per minute. Valid values: 10 to 10000.
	//
	// Default value: 10000.
	TimeoutInMinutes *int32 `json:"TimeoutInMinutes,omitempty" xml:"TimeoutInMinutes,omitempty"`
}

func (s CreateOTADynamicUpgradeJobRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOTADynamicUpgradeJobRequest) GoString() string {
	return s.String()
}

func (s *CreateOTADynamicUpgradeJobRequest) SetDownloadProtocol(v string) *CreateOTADynamicUpgradeJobRequest {
	s.DownloadProtocol = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetDynamicMode(v int32) *CreateOTADynamicUpgradeJobRequest {
	s.DynamicMode = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetFirmwareId(v string) *CreateOTADynamicUpgradeJobRequest {
	s.FirmwareId = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetGroupId(v string) *CreateOTADynamicUpgradeJobRequest {
	s.GroupId = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetGroupType(v string) *CreateOTADynamicUpgradeJobRequest {
	s.GroupType = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetIotInstanceId(v string) *CreateOTADynamicUpgradeJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetMaximumPerMinute(v int32) *CreateOTADynamicUpgradeJobRequest {
	s.MaximumPerMinute = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetMultiModuleMode(v bool) *CreateOTADynamicUpgradeJobRequest {
	s.MultiModuleMode = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetNeedConfirm(v bool) *CreateOTADynamicUpgradeJobRequest {
	s.NeedConfirm = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetNeedPush(v bool) *CreateOTADynamicUpgradeJobRequest {
	s.NeedPush = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetOverwriteMode(v int32) *CreateOTADynamicUpgradeJobRequest {
	s.OverwriteMode = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetProductKey(v string) *CreateOTADynamicUpgradeJobRequest {
	s.ProductKey = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetRetryCount(v int32) *CreateOTADynamicUpgradeJobRequest {
	s.RetryCount = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetRetryInterval(v int32) *CreateOTADynamicUpgradeJobRequest {
	s.RetryInterval = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetSrcVersion(v []*string) *CreateOTADynamicUpgradeJobRequest {
	s.SrcVersion = v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetTag(v []*CreateOTADynamicUpgradeJobRequestTag) *CreateOTADynamicUpgradeJobRequest {
	s.Tag = v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequest) SetTimeoutInMinutes(v int32) *CreateOTADynamicUpgradeJobRequest {
	s.TimeoutInMinutes = &v
	return s
}

type CreateOTADynamicUpgradeJobRequestTag struct {
	// The value of the update batch tag. The value must be 1 to 1,024 characters in length. You can add up to 10 tags for each update batch. The total length of the tag keys and tag values of all update batches cannot exceed 4,096 characters in length.
	//
	// >  Update batch tags are optional. If you want to specify a tag, you must specify the Tag.N.Value and Tag.N.Key parameters in pair.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOTADynamicUpgradeJobRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateOTADynamicUpgradeJobRequestTag) GoString() string {
	return s.String()
}

func (s *CreateOTADynamicUpgradeJobRequestTag) SetKey(v string) *CreateOTADynamicUpgradeJobRequestTag {
	s.Key = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobRequestTag) SetValue(v string) *CreateOTADynamicUpgradeJobRequestTag {
	s.Value = &v
	return s
}

type CreateOTADynamicUpgradeJobResponseBody struct {
	// The error message returned if the call fails.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The unique identifier of the update batch.
	Data *CreateOTADynamicUpgradeJobResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The update batch information returned if the call is successful. For more information, see Data.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateOTADynamicUpgradeJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOTADynamicUpgradeJobResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOTADynamicUpgradeJobResponseBody) SetCode(v string) *CreateOTADynamicUpgradeJobResponseBody {
	s.Code = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobResponseBody) SetData(v *CreateOTADynamicUpgradeJobResponseBodyData) *CreateOTADynamicUpgradeJobResponseBody {
	s.Data = v
	return s
}

func (s *CreateOTADynamicUpgradeJobResponseBody) SetErrorMessage(v string) *CreateOTADynamicUpgradeJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobResponseBody) SetRequestId(v string) *CreateOTADynamicUpgradeJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobResponseBody) SetSuccess(v bool) *CreateOTADynamicUpgradeJobResponseBody {
	s.Success = &v
	return s
}

type CreateOTADynamicUpgradeJobResponseBodyData struct {
	// The time when the update batch was created. The time is displayed in UTC.
	JobId     *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
}

func (s CreateOTADynamicUpgradeJobResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateOTADynamicUpgradeJobResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateOTADynamicUpgradeJobResponseBodyData) SetJobId(v string) *CreateOTADynamicUpgradeJobResponseBodyData {
	s.JobId = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobResponseBodyData) SetUtcCreate(v string) *CreateOTADynamicUpgradeJobResponseBodyData {
	s.UtcCreate = &v
	return s
}

type CreateOTADynamicUpgradeJobResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOTADynamicUpgradeJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOTADynamicUpgradeJobResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOTADynamicUpgradeJobResponse) GoString() string {
	return s.String()
}

func (s *CreateOTADynamicUpgradeJobResponse) SetHeaders(v map[string]*string) *CreateOTADynamicUpgradeJobResponse {
	s.Headers = v
	return s
}

func (s *CreateOTADynamicUpgradeJobResponse) SetStatusCode(v int32) *CreateOTADynamicUpgradeJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOTADynamicUpgradeJobResponse) SetBody(v *CreateOTADynamicUpgradeJobResponseBody) *CreateOTADynamicUpgradeJobResponse {
	s.Body = v
	return s
}

type CreateOTAFirmwareRequest struct {
	// The version number of the OTA update package. The value can contain letters, digits, periods (.), hyphens (-), and underscores (\_). The version number must be 1 to 64 characters in length.
	DestVersion *string `json:"DestVersion,omitempty" xml:"DestVersion,omitempty"`
	// The description of the OTA update package. The description must be 1 to 100 characters in length.
	FirmwareDesc *string `json:"FirmwareDesc,omitempty" xml:"FirmwareDesc,omitempty"`
	// The name of the OTA update package. The name must be unique within an Alibaba Cloud account. The name cannot be modified after the OTA update package is created. The name must be 1 to 40 characters in length, and can contain letters, digits, hyphens (-), underscores (\_), and parentheses (). The name must start with a letter or a digit.
	FirmwareName *string `json:"FirmwareName,omitempty" xml:"FirmwareName,omitempty"`
	// The signature of the OTA update package. The value is calculated by using the specified **signature algorithm** to sign the OTA update package.
	//
	// > If you add only one file to the OTA update package, you can configure this parameter. If you do not configure this parameter, the MD5 value of the OTA update package in OSS is used as the package signature.
	FirmwareSign *string `json:"FirmwareSign,omitempty" xml:"FirmwareSign,omitempty"`
	// The size of the OTA update package. Unit: bytes.
	//
	// > If you add only one file to the OTA update package, you can configure this parameter. If you do not configure this parameter, the size of the OTA update package in OSS is used.
	FirmwareSize *int32 `json:"FirmwareSize,omitempty" xml:"FirmwareSize,omitempty"`
	// The URL of the OTA update package. This parameter specifies the storage location of the OTA update package in OSS. You can call the [GenerateOTAUploadURL](~~147310~~) operation to generate a URL for the OTA update package.
	//
	// >If you add only one file to the OTA update package, you must configure this parameter.
	FirmwareUrl *string `json:"FirmwareUrl,omitempty" xml:"FirmwareUrl,omitempty"`
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The name of the OTA module. OTA modules are the updatable units of devices that belong to the same product.
	//
	// > *   If you do not configure this parameter, the default OTA module is used. The default value indicates that the complete device firmware is updated.
	// >*   You can call the [CreateOTAModule](~~186066~~) operation to create a custom OTA module. You can call the [ListOTAModuleByProduct](~~186532~~) operation to query the existing OTA modules of a product.
	ModuleName *string                               `json:"ModuleName,omitempty" xml:"ModuleName,omitempty"`
	MultiFiles []*CreateOTAFirmwareRequestMultiFiles `json:"MultiFiles,omitempty" xml:"MultiFiles,omitempty" type:"Repeated"`
	// Specifies whether to verify the OTA update package before you create a batch update task.
	//
	// *   **true** The system verifies the OTA update package before you create a batch update task. This is the default value.
	// *   **false**: The system does not verify the OTA update package before you create a batch update task.
	NeedToVerify *bool `json:"NeedToVerify,omitempty" xml:"NeedToVerify,omitempty"`
	// The **ProductKey** of the product to which the OTA update package belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The signature algorithm of the OTA update package. Set the value to **MD5**. The value indicates an MD5 signature.
	//
	// Default value: **MD5**.
	SignMethod *string `json:"SignMethod,omitempty" xml:"SignMethod,omitempty"`
	// The version number of the OTA module of the device to be updated.
	//
	// You can call the [QueryDeviceDetail](~~69594~~) operation and view the **FirmwareVersion** parameter in the response.
	//
	// > *   If you set the **Type** parameter to **1**, you must configure this parameter, and the value cannot be the same as the update package version that is specified by the **DestVersion** parameter.
	// >*   If you set the **Type** parameter to **0**, this parameter is optional.
	SrcVersion *string `json:"SrcVersion,omitempty" xml:"SrcVersion,omitempty"`
	// The type of the OTA update package. Valid values:
	//
	// *   **0**: The uploaded file contains a full update package. IoT Platform pushes the full update package to a device for update.
	// *   **1**: The uploaded file contains only the differences between the latest update package and the previous update package. IoT Platform pushes only the differences to a device for update.
	//
	// Default value: **0**.
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
	// The custom information that you want to send to a device. The format of the custom information has no limits. However, the information cannot exceed 4,096 characters in length.
	//
	// After you add the OTA update package and create an update task, IoT Platform sends the custom information to the specified device when IoT Platform pushes an update notification.
	Udi *string `json:"Udi,omitempty" xml:"Udi,omitempty"`
}

func (s CreateOTAFirmwareRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAFirmwareRequest) GoString() string {
	return s.String()
}

func (s *CreateOTAFirmwareRequest) SetDestVersion(v string) *CreateOTAFirmwareRequest {
	s.DestVersion = &v
	return s
}

func (s *CreateOTAFirmwareRequest) SetFirmwareDesc(v string) *CreateOTAFirmwareRequest {
	s.FirmwareDesc = &v
	return s
}

func (s *CreateOTAFirmwareRequest) SetFirmwareName(v string) *CreateOTAFirmwareRequest {
	s.FirmwareName = &v
	return s
}

func (s *CreateOTAFirmwareRequest) SetFirmwareSign(v string) *CreateOTAFirmwareRequest {
	s.FirmwareSign = &v
	return s
}

func (s *CreateOTAFirmwareRequest) SetFirmwareSize(v int32) *CreateOTAFirmwareRequest {
	s.FirmwareSize = &v
	return s
}

func (s *CreateOTAFirmwareRequest) SetFirmwareUrl(v string) *CreateOTAFirmwareRequest {
	s.FirmwareUrl = &v
	return s
}

func (s *CreateOTAFirmwareRequest) SetIotInstanceId(v string) *CreateOTAFirmwareRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateOTAFirmwareRequest) SetModuleName(v string) *CreateOTAFirmwareRequest {
	s.ModuleName = &v
	return s
}

func (s *CreateOTAFirmwareRequest) SetMultiFiles(v []*CreateOTAFirmwareRequestMultiFiles) *CreateOTAFirmwareRequest {
	s.MultiFiles = v
	return s
}

func (s *CreateOTAFirmwareRequest) SetNeedToVerify(v bool) *CreateOTAFirmwareRequest {
	s.NeedToVerify = &v
	return s
}

func (s *CreateOTAFirmwareRequest) SetProductKey(v string) *CreateOTAFirmwareRequest {
	s.ProductKey = &v
	return s
}

func (s *CreateOTAFirmwareRequest) SetSignMethod(v string) *CreateOTAFirmwareRequest {
	s.SignMethod = &v
	return s
}

func (s *CreateOTAFirmwareRequest) SetSrcVersion(v string) *CreateOTAFirmwareRequest {
	s.SrcVersion = &v
	return s
}

func (s *CreateOTAFirmwareRequest) SetType(v int32) *CreateOTAFirmwareRequest {
	s.Type = &v
	return s
}

func (s *CreateOTAFirmwareRequest) SetUdi(v string) *CreateOTAFirmwareRequest {
	s.Udi = &v
	return s
}

type CreateOTAFirmwareRequestMultiFiles struct {
	// The MD5 value of the file.
	//
	// >  If you want to add multiple files to the OTA update package, you can configure this parameter. If you do not configure this parameter, the MD5 value of the file in OSS is used.
	FileMd5 *string `json:"FileMd5,omitempty" xml:"FileMd5,omitempty"`
	// The name of the file in the update package. The name must be 1 to 32 characters in length. You can specify up to 20 file names. Each name must be unique in the OTA update package.
	//
	// > If you want to add multiple files to the OTA update package, you must configure this parameter.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The signature of the file. The value is calculated by using the specified **signature algorithm** to sign the file.
	//
	// >  If you want to add multiple files to the OTA update package, you can configure this parameter. If you do not configure this parameter, the MD5 value of the file in OSS is used as the file signature.
	SignValue *string `json:"SignValue,omitempty" xml:"SignValue,omitempty"`
	// The size of the file in the OTA update package. Unit: bytes.
	//
	// >  If you want to add multiple files to the OTA update package, you can configure this parameter. If you do not configure this parameter, the size of the file in OSS is used.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The URL of the file. This parameter specifies the storage location of the file in OSS. You can call the [GenerateOTAUploadURL](~~147310~~) operation to generate a URL for each file in the OTA update package.
	//
	// > If you want to add multiple files to the OTA update package, you must configure this parameter.
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s CreateOTAFirmwareRequestMultiFiles) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAFirmwareRequestMultiFiles) GoString() string {
	return s.String()
}

func (s *CreateOTAFirmwareRequestMultiFiles) SetFileMd5(v string) *CreateOTAFirmwareRequestMultiFiles {
	s.FileMd5 = &v
	return s
}

func (s *CreateOTAFirmwareRequestMultiFiles) SetName(v string) *CreateOTAFirmwareRequestMultiFiles {
	s.Name = &v
	return s
}

func (s *CreateOTAFirmwareRequestMultiFiles) SetSignValue(v string) *CreateOTAFirmwareRequestMultiFiles {
	s.SignValue = &v
	return s
}

func (s *CreateOTAFirmwareRequestMultiFiles) SetSize(v int32) *CreateOTAFirmwareRequestMultiFiles {
	s.Size = &v
	return s
}

func (s *CreateOTAFirmwareRequestMultiFiles) SetUrl(v string) *CreateOTAFirmwareRequestMultiFiles {
	s.Url = &v
	return s
}

type CreateOTAFirmwareResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The OTA update package information that is returned if the call is successful. For more information, see the "**Data**" section of this topic.
	Data *CreateOTAFirmwareResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful. The value indicates that the OTA update package was created.
	// *   **false**: The call failed. The value indicates that the system failed to create the OTA update package.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateOTAFirmwareResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAFirmwareResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOTAFirmwareResponseBody) SetCode(v string) *CreateOTAFirmwareResponseBody {
	s.Code = &v
	return s
}

func (s *CreateOTAFirmwareResponseBody) SetData(v *CreateOTAFirmwareResponseBodyData) *CreateOTAFirmwareResponseBody {
	s.Data = v
	return s
}

func (s *CreateOTAFirmwareResponseBody) SetErrorMessage(v string) *CreateOTAFirmwareResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateOTAFirmwareResponseBody) SetRequestId(v string) *CreateOTAFirmwareResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateOTAFirmwareResponseBody) SetSuccess(v bool) *CreateOTAFirmwareResponseBody {
	s.Success = &v
	return s
}

type CreateOTAFirmwareResponseBodyData struct {
	// The ID of the OTA update package. The ID is a unique identifier issued by IoT Platform to the OTA update package.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The time when the OTA update package was created. The time is displayed in UTC.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
}

func (s CreateOTAFirmwareResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAFirmwareResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateOTAFirmwareResponseBodyData) SetFirmwareId(v string) *CreateOTAFirmwareResponseBodyData {
	s.FirmwareId = &v
	return s
}

func (s *CreateOTAFirmwareResponseBodyData) SetUtcCreate(v string) *CreateOTAFirmwareResponseBodyData {
	s.UtcCreate = &v
	return s
}

type CreateOTAFirmwareResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOTAFirmwareResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOTAFirmwareResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAFirmwareResponse) GoString() string {
	return s.String()
}

func (s *CreateOTAFirmwareResponse) SetHeaders(v map[string]*string) *CreateOTAFirmwareResponse {
	s.Headers = v
	return s
}

func (s *CreateOTAFirmwareResponse) SetStatusCode(v int32) *CreateOTAFirmwareResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOTAFirmwareResponse) SetBody(v *CreateOTAFirmwareResponseBody) *CreateOTAFirmwareResponse {
	s.Body = v
	return s
}

type CreateOTAModuleRequest struct {
	// The alias of the OTA module. The alias must be 1 to 64 characters in length, and can contain letters, digits, periods(.), hyphens (-), and underscores (\_).
	AliasName *string `json:"AliasName,omitempty" xml:"AliasName,omitempty"`
	// The description of the OTA module. The description can be up to 100 characters in length.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The name of the OTA module. The name is unique in a product and cannot be modified. The name can contain letters, digits, periods (.), hyphens (-), and underscores (\_). The name must be 1 to 64 characters in length.
	//
	// >  Letters are not case-sensitive. For example, you cannot use the module names scanner and Scanner at the same time.
	ModuleName *string `json:"ModuleName,omitempty" xml:"ModuleName,omitempty"`
	// The ProductKey of the product to which the OTA module belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s CreateOTAModuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAModuleRequest) GoString() string {
	return s.String()
}

func (s *CreateOTAModuleRequest) SetAliasName(v string) *CreateOTAModuleRequest {
	s.AliasName = &v
	return s
}

func (s *CreateOTAModuleRequest) SetDesc(v string) *CreateOTAModuleRequest {
	s.Desc = &v
	return s
}

func (s *CreateOTAModuleRequest) SetIotInstanceId(v string) *CreateOTAModuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateOTAModuleRequest) SetModuleName(v string) *CreateOTAModuleRequest {
	s.ModuleName = &v
	return s
}

func (s *CreateOTAModuleRequest) SetProductKey(v string) *CreateOTAModuleRequest {
	s.ProductKey = &v
	return s
}

type CreateOTAModuleResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateOTAModuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAModuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOTAModuleResponseBody) SetCode(v string) *CreateOTAModuleResponseBody {
	s.Code = &v
	return s
}

func (s *CreateOTAModuleResponseBody) SetErrorMessage(v string) *CreateOTAModuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateOTAModuleResponseBody) SetRequestId(v string) *CreateOTAModuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateOTAModuleResponseBody) SetSuccess(v bool) *CreateOTAModuleResponseBody {
	s.Success = &v
	return s
}

type CreateOTAModuleResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOTAModuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOTAModuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAModuleResponse) GoString() string {
	return s.String()
}

func (s *CreateOTAModuleResponse) SetHeaders(v map[string]*string) *CreateOTAModuleResponse {
	s.Headers = v
	return s
}

func (s *CreateOTAModuleResponse) SetStatusCode(v int32) *CreateOTAModuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOTAModuleResponse) SetBody(v *CreateOTAModuleResponseBody) *CreateOTAModuleResponse {
	s.Body = v
	return s
}

type CreateOTAStaticUpgradeJobRequest struct {
	// The URL of the device list file that is used to perform a specific update.
	//
	// > *   If you set the TargetSelection parameter to `SPECIFIC`, you must specify this parameter or the **TargetDeviceName.N** parameter. You cannot specify the two parameters at the same time.
	// >*   You can call the [GenerateDeviceNameListURL](~~186062~~) operation to generate a file URL. Then, you can perform the operations as prompted to upload the device list file.
	// >*   During a full update, the devices that have been updated are skipped.
	// >*   During a delta update, the devices that have been updated and the devices whose initial version numbers are different from the update package are skipped.
	DnListFileUrl *string `json:"DnListFileUrl,omitempty" xml:"DnListFileUrl,omitempty"`
	// The download protocol of the update package. Valid values: **HTTPS** and **MQTT**. Default value: HTTPS. After the device receives the update package information pushed by IoT Platform, this protocol is used to download the update package.
	//
	// >If you need to download the update package over MQTT, take note of the following items:
	// >*   Your service must be deployed in the China (Shanghai), China (Beijing), or China (Shenzhen) region.
	// >*   The OTA update package can contain only one file, and the size of the file cannot exceed 16 MB.
	// >*   You must use the latest version of Link SDK for C to develop the device features to perform OTA updates and download files over MQTT. For more information, see [Sample code](~~330985~~).
	DownloadProtocol *string `json:"DownloadProtocol,omitempty" xml:"DownloadProtocol,omitempty"`
	// The ID of the update package.
	//
	// An update package ID is returned when you call the [CreateOTAFirmware](~~147311~~) operation to create the update package.
	//
	// You can also call the [ListOTAFirmware](~~147450~~) operation to obtain the ID.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The ratio of the phased update. The value is a percentage in the string format. It can be up to three decimal places. The calculated number of devices is rounded down to the nearest integer. You must specify at least one device for a phased update.
	//
	// For example, if you set the phased update ratio to 33.33 for 100 devices, the number of devices to be updated is 33.
	//
	// You must specify this parameter if you set the TargetSelection parameter to `GRAY`.
	GrayPercent *string `json:"GrayPercent,omitempty" xml:"GrayPercent,omitempty"`
	// The ID of the group.
	//
	// If you set the TargetSelection parameter to `GROUP`, you must specify this parameter and the **GroupType** parameter.
	//
	// You can call the [QueryDeviceGroupList](~~93356~~) operation to query the **GroupId** parameter.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The type of the group. Valid value: **LINK_PLATFORM**.
	//
	// If you set the TargetSelection parameter to `GROUP`, you must specify this parameter and the **GroupId** parameter.
	GroupType *string `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The ID of the instance. You can view the ID of an instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. If you do not specify the instance ID, the call fails.****
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The maximum number of devices to which the download URL of the update package is pushed per minute. Valid values: 10 to 10000.
	//
	// Default value: 10000.
	MaximumPerMinute *int32 `json:"MaximumPerMinute,omitempty" xml:"MaximumPerMinute,omitempty"`
	// Specifies whether the device supports simultaneous updates of multiple modules. Default value: false. Valid values:
	//
	// *   **false**
	//
	// *   **true**: In this case, do not set **OverwriteMode** to **2**.********
	//
	//     The update tasks for the same module are overwritten. The update tasks that are in progress are not overwritten. The update tasks of the modules do not affect each other.
	//
	// >*   Only Enterprise Edition instances and new public instances are supported.
	// >*   You must use Link SDK for C 4.x to develop the device.
	//
	// For more information, see [Overview](~~58328~~).
	MultiModuleMode *bool `json:"MultiModuleMode,omitempty" xml:"MultiModuleMode,omitempty"`
	// Specifies whether to control the update by using a mobile app. You must develop the mobile app as needed. Default false: true. Valid values:
	//
	// *   **false**: A device obtains the information about the OTA update task based on the **NeedPush** parameter.
	// *   **true**: To perform an OTA update on a device, you must confirm the update by using your mobile app. Then, the device can obtain the information about the OTA update task based on the **NeedPush** parameter.
	NeedConfirm *bool `json:"NeedConfirm,omitempty" xml:"NeedConfirm,omitempty"`
	// Specifies whether to automatically push update tasks from IoT Platform to devices. Default value: true. Valid values:
	//
	// *   **true**: After an update batch is created, IoT Platform automatically pushes update tasks to the specified online devices.
	//
	//     In this case, a device can still initiate a request to obtain the information about the over-the-air (OTA) update task from IoT Platform.
	//
	// *   **false**: A device must initiate a request to obtain the information about the OTA update task from IoT Platform.
	NeedPush *bool `json:"NeedPush,omitempty" xml:"NeedPush,omitempty"`
	// Specifies whether to overwrite the previous update task. Default value: 1. Valid values:
	//
	// *   **1**: The previous update task is not overwritten. If a device already has an update task, the previous update task is implemented.
	// *   **2**: The previous update task is overwritten. Only the current update task is implemented. In this case, you cannot set **MultiModuleMode** to **true**.
	//
	// >  The update task that is in progress is not overwritten.
	OverwriteMode *int32 `json:"OverwriteMode,omitempty" xml:"OverwriteMode,omitempty"`
	// The **ProductKey** of the product to which the update package belongs.
	//
	// A **ProductKey** is the unique identifier of a product in IoT Platform. You can view the information about all products within the current Alibaba Cloud account in the IoT Platform console or by calling the [QueryProductList](~~69271~~) operation.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The number of automatic retries.
	//
	// If you specify the **RetryInterval** parameter, you must specify this parameter.
	//
	// Valid values:
	//
	// *   **1**: retries once.
	// *   **2**: retries twice.
	// *   **5**: retries five times.
	RetryCount *int32 `json:"RetryCount,omitempty" xml:"RetryCount,omitempty"`
	// The automatic retry interval if a device fails to be updated. Unit: minutes. Valid values:
	//
	// *   **0**: An automatic retry is immediately performed.
	// *   **10**: An automatic retry is performed after 10 minutes.
	// *   **30**: An automatic retry is performed after 30 minutes.
	// *   **60**: An automatic retry is performed after 60 minutes (1 hour).
	// *   **1440**: An automatic retry is performed after 1,440 minutes (24 hours).
	//
	// > The value of the **RetryInterval** parameter must be less than the value of the **TimeoutInMinutes** parameter. Examples:
	// >*   If the value of the **TimeoutInMinutes** parameter is set to 60, the maximum value of the **RetryInterval** parameter is 30.
	// >*   If the value of the **TimeoutInMinutes** parameter is set to 1440, the maximum value of the **RetryInterval** parameter is 60.
	//
	// If the value of the **RetryInterval** parameter is set to 1440, we recommend that you do not specify the **TimeoutInMinutes** parameter. If an update times out, no retry is performed.
	//
	// If you do not specify this parameter, no retry is performed.
	RetryInterval *int32 `json:"RetryInterval,omitempty" xml:"RetryInterval,omitempty"`
	// The time to end the update.
	//
	// The end time must be 1 hour to 30 days later than the start time that is specified by the **ScheduleTime** parameter. The value must be a 13-digit timestamp.
	//
	// If you do not specify this parameter, the update is not forcibly ended.
	ScheduleFinishTime *int64 `json:"ScheduleFinishTime,omitempty" xml:"ScheduleFinishTime,omitempty"`
	// The time to start the over-the-air (OTA) update.
	//
	// The scheduled time ranges from 5 minutes to 7 days later than the current time. The value must be a 13-digit timestamp.
	//
	// If you do not specify this parameter, the update immediately starts.
	ScheduleTime     *int64                                 `json:"ScheduleTime,omitempty" xml:"ScheduleTime,omitempty"`
	SrcVersion       []*string                              `json:"SrcVersion,omitempty" xml:"SrcVersion,omitempty" type:"Repeated"`
	Tag              []*CreateOTAStaticUpgradeJobRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	TargetDeviceName []*string                              `json:"TargetDeviceName,omitempty" xml:"TargetDeviceName,omitempty" type:"Repeated"`
	// The scope of the update batch. Valid values:
	//
	// *   **ALL**: updates all devices.
	// *   **SPECIFIC**: updates specified devices.
	// *   **GRAY**: performs a phased update.
	// *   **GROUP**: updates specified groups.
	TargetSelection *string `json:"TargetSelection,omitempty" xml:"TargetSelection,omitempty"`
	// The timeout period of the update. If the device is not updated within the specified period, a timeout error occurs. Unit: minutes. Valid values: 1 to 1440.
	//
	// > *   The timeout period starts from the time when the specified device submits the update progress for the first time. During the update, the update package may be repeatedly pushed to the specified device because the device goes online and offline multiple times. The start time of the update period remains unchanged.
	// >*   If an update fails due to timeout, no retry is triggered.
	//
	// If you do not specify this parameter, timeout errors do not occur.
	TimeoutInMinutes *int32 `json:"TimeoutInMinutes,omitempty" xml:"TimeoutInMinutes,omitempty"`
}

func (s CreateOTAStaticUpgradeJobRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAStaticUpgradeJobRequest) GoString() string {
	return s.String()
}

func (s *CreateOTAStaticUpgradeJobRequest) SetDnListFileUrl(v string) *CreateOTAStaticUpgradeJobRequest {
	s.DnListFileUrl = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetDownloadProtocol(v string) *CreateOTAStaticUpgradeJobRequest {
	s.DownloadProtocol = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetFirmwareId(v string) *CreateOTAStaticUpgradeJobRequest {
	s.FirmwareId = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetGrayPercent(v string) *CreateOTAStaticUpgradeJobRequest {
	s.GrayPercent = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetGroupId(v string) *CreateOTAStaticUpgradeJobRequest {
	s.GroupId = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetGroupType(v string) *CreateOTAStaticUpgradeJobRequest {
	s.GroupType = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetIotInstanceId(v string) *CreateOTAStaticUpgradeJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetMaximumPerMinute(v int32) *CreateOTAStaticUpgradeJobRequest {
	s.MaximumPerMinute = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetMultiModuleMode(v bool) *CreateOTAStaticUpgradeJobRequest {
	s.MultiModuleMode = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetNeedConfirm(v bool) *CreateOTAStaticUpgradeJobRequest {
	s.NeedConfirm = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetNeedPush(v bool) *CreateOTAStaticUpgradeJobRequest {
	s.NeedPush = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetOverwriteMode(v int32) *CreateOTAStaticUpgradeJobRequest {
	s.OverwriteMode = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetProductKey(v string) *CreateOTAStaticUpgradeJobRequest {
	s.ProductKey = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetRetryCount(v int32) *CreateOTAStaticUpgradeJobRequest {
	s.RetryCount = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetRetryInterval(v int32) *CreateOTAStaticUpgradeJobRequest {
	s.RetryInterval = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetScheduleFinishTime(v int64) *CreateOTAStaticUpgradeJobRequest {
	s.ScheduleFinishTime = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetScheduleTime(v int64) *CreateOTAStaticUpgradeJobRequest {
	s.ScheduleTime = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetSrcVersion(v []*string) *CreateOTAStaticUpgradeJobRequest {
	s.SrcVersion = v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetTag(v []*CreateOTAStaticUpgradeJobRequestTag) *CreateOTAStaticUpgradeJobRequest {
	s.Tag = v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetTargetDeviceName(v []*string) *CreateOTAStaticUpgradeJobRequest {
	s.TargetDeviceName = v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetTargetSelection(v string) *CreateOTAStaticUpgradeJobRequest {
	s.TargetSelection = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequest) SetTimeoutInMinutes(v int32) *CreateOTAStaticUpgradeJobRequest {
	s.TimeoutInMinutes = &v
	return s
}

type CreateOTAStaticUpgradeJobRequestTag struct {
	// The key of the update batch tag. The key must be 1 to 30 characters in length and can contain letters, digits, and periods (.). You can add up to 10 tags for each update batch.
	//
	// The tags of an update batch are sent to devices when IoT Platform pushes update notifications to these devices.
	//
	// >  Update batch tags are optional. If you want to specify a tag, you must specify the Tag.N.Value and Tag.N.Key parameters in pair.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the update batch tag. The value must be 1 to 1,024 characters in length. You can add up to 10 tags for each update batch. The total length of the tag keys and tag values of all update batches cannot exceed 4,096 characters in length.
	//
	// >  Update batch tags are optional. If you want to specify a tag, you must specify the Tag.N.Value and Tag.N.Key parameters in pair.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOTAStaticUpgradeJobRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAStaticUpgradeJobRequestTag) GoString() string {
	return s.String()
}

func (s *CreateOTAStaticUpgradeJobRequestTag) SetKey(v string) *CreateOTAStaticUpgradeJobRequestTag {
	s.Key = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobRequestTag) SetValue(v string) *CreateOTAStaticUpgradeJobRequestTag {
	s.Value = &v
	return s
}

type CreateOTAStaticUpgradeJobResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The update batch information returned if the call is successful. For more information, see Data.
	Data *CreateOTAStaticUpgradeJobResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateOTAStaticUpgradeJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAStaticUpgradeJobResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOTAStaticUpgradeJobResponseBody) SetCode(v string) *CreateOTAStaticUpgradeJobResponseBody {
	s.Code = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobResponseBody) SetData(v *CreateOTAStaticUpgradeJobResponseBodyData) *CreateOTAStaticUpgradeJobResponseBody {
	s.Data = v
	return s
}

func (s *CreateOTAStaticUpgradeJobResponseBody) SetErrorMessage(v string) *CreateOTAStaticUpgradeJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobResponseBody) SetRequestId(v string) *CreateOTAStaticUpgradeJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobResponseBody) SetSuccess(v bool) *CreateOTAStaticUpgradeJobResponseBody {
	s.Success = &v
	return s
}

type CreateOTAStaticUpgradeJobResponseBodyData struct {
	// The unique identifier of the update batch.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The time when the update batch was created. The time is displayed in UTC.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
}

func (s CreateOTAStaticUpgradeJobResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAStaticUpgradeJobResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateOTAStaticUpgradeJobResponseBodyData) SetJobId(v string) *CreateOTAStaticUpgradeJobResponseBodyData {
	s.JobId = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobResponseBodyData) SetUtcCreate(v string) *CreateOTAStaticUpgradeJobResponseBodyData {
	s.UtcCreate = &v
	return s
}

type CreateOTAStaticUpgradeJobResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOTAStaticUpgradeJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOTAStaticUpgradeJobResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAStaticUpgradeJobResponse) GoString() string {
	return s.String()
}

func (s *CreateOTAStaticUpgradeJobResponse) SetHeaders(v map[string]*string) *CreateOTAStaticUpgradeJobResponse {
	s.Headers = v
	return s
}

func (s *CreateOTAStaticUpgradeJobResponse) SetStatusCode(v int32) *CreateOTAStaticUpgradeJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOTAStaticUpgradeJobResponse) SetBody(v *CreateOTAStaticUpgradeJobResponseBody) *CreateOTAStaticUpgradeJobResponse {
	s.Body = v
	return s
}

type CreateOTAVerifyJobRequest struct {
	// The download protocol of the update package. Valid values: **HTTPS** and **MQTT**. Default value: HTTPS. After the device receives the update package information pushed by IoT Platform, this protocol is used to download the update package.
	//
	// > If you want to download the update package over MQTT, take note of the following items:
	// >*   The following regions are supported: China (Shanghai), China (Beijing), and China (Shenzhen).
	// >*   The OTA update package can contain only one file and the size of the file cannot exceed 16 MB.
	// >*   You must use the latest version of Link SDK for C to develop the device features to perform OTA updates and download files over MQTT. For more information, see [Sample code](~~330985~~).
	DownloadProtocol *string `json:"DownloadProtocol,omitempty" xml:"DownloadProtocol,omitempty"`
	// The ID of the update package.
	//
	// The **FirmwareId** parameter is returned when you call the [CreateOTAFirmware](~~147311~~) operation to create an OTA update package.
	//
	// You can also call the [ListOTAFirmware](~~147450~~) operation to obtain the ID.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The ID of the instance. You can view the ID of an instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// Specifies whether to control the update by using a mobile app. You must develop the mobile app as needed.
	//
	// *   **false** (default): no. A device obtains the information about the OTA update task based on the **NeedPush** parameter.
	// *   **true**: yes To perform an OTA update on a device, you must confirm the update by using your mobile app. Then, the device can obtain the information about the OTA update task based on the **NeedPush** parameter.
	NeedConfirm *bool `json:"NeedConfirm,omitempty" xml:"NeedConfirm,omitempty"`
	// Specifies whether to automatically push update tasks from IoT Platform to devices.
	//
	// *   **true** (default): yes. After an update batch is created, IoT Platform automatically pushes update tasks to the specified online devices.
	//
	//     In this case, a device can still initiate a request to obtain the information about the over-the-air (OTA) update task from IoT Platform.
	//
	// *   **false**: no. A device must initiate a request to obtain the information about the OTA update task from IoT Platform.
	NeedPush *bool `json:"NeedPush,omitempty" xml:"NeedPush,omitempty"`
	// The ProductKey of the product to which the OTA update package belongs.
	ProductKey       *string                         `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	Tag              []*CreateOTAVerifyJobRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
	TargetDeviceName []*string                       `json:"TargetDeviceName,omitempty" xml:"TargetDeviceName,omitempty" type:"Repeated"`
	// The timeout period for a device to update the firmware. Unit: minutes. Valid values: 1 to 1440.
	TimeoutInMinutes *int32 `json:"TimeoutInMinutes,omitempty" xml:"TimeoutInMinutes,omitempty"`
}

func (s CreateOTAVerifyJobRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAVerifyJobRequest) GoString() string {
	return s.String()
}

func (s *CreateOTAVerifyJobRequest) SetDownloadProtocol(v string) *CreateOTAVerifyJobRequest {
	s.DownloadProtocol = &v
	return s
}

func (s *CreateOTAVerifyJobRequest) SetFirmwareId(v string) *CreateOTAVerifyJobRequest {
	s.FirmwareId = &v
	return s
}

func (s *CreateOTAVerifyJobRequest) SetIotInstanceId(v string) *CreateOTAVerifyJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateOTAVerifyJobRequest) SetNeedConfirm(v bool) *CreateOTAVerifyJobRequest {
	s.NeedConfirm = &v
	return s
}

func (s *CreateOTAVerifyJobRequest) SetNeedPush(v bool) *CreateOTAVerifyJobRequest {
	s.NeedPush = &v
	return s
}

func (s *CreateOTAVerifyJobRequest) SetProductKey(v string) *CreateOTAVerifyJobRequest {
	s.ProductKey = &v
	return s
}

func (s *CreateOTAVerifyJobRequest) SetTag(v []*CreateOTAVerifyJobRequestTag) *CreateOTAVerifyJobRequest {
	s.Tag = v
	return s
}

func (s *CreateOTAVerifyJobRequest) SetTargetDeviceName(v []*string) *CreateOTAVerifyJobRequest {
	s.TargetDeviceName = v
	return s
}

func (s *CreateOTAVerifyJobRequest) SetTimeoutInMinutes(v int32) *CreateOTAVerifyJobRequest {
	s.TimeoutInMinutes = &v
	return s
}

type CreateOTAVerifyJobRequestTag struct {
	// The key of the update batch tag. The key must be 1 to 30 characters in length and can contain letters, digits, and periods (.). You can add up to 10 tags for each update batch.
	//
	// The tags of an update batch are sent to devices when IoT Platform pushes update notifications to the devices.
	//
	// >  Update batch tags are optional. If you want to specify a tag, you must specify the Tag.N.Value and Tag.N.Key parameters in pair.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the update batch tag. The value must be 1 to 1,024 characters in length. You can add up to 10 tags for each update batch. The total length of the tag keys and tag values of all update batches cannot exceed 4,096 characters.
	//
	// >  Update batch tags are optional. If you want to specify a tag, you must specify the Tag.N.Value and Tag.N.Key parameters in pair.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s CreateOTAVerifyJobRequestTag) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAVerifyJobRequestTag) GoString() string {
	return s.String()
}

func (s *CreateOTAVerifyJobRequestTag) SetKey(v string) *CreateOTAVerifyJobRequestTag {
	s.Key = &v
	return s
}

func (s *CreateOTAVerifyJobRequestTag) SetValue(v string) *CreateOTAVerifyJobRequestTag {
	s.Value = &v
	return s
}

type CreateOTAVerifyJobResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The task information returned if the call is successful. For more information, see the following parameters.
	Data *CreateOTAVerifyJobResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. The ID uniquely identifies this request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateOTAVerifyJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAVerifyJobResponseBody) GoString() string {
	return s.String()
}

func (s *CreateOTAVerifyJobResponseBody) SetCode(v string) *CreateOTAVerifyJobResponseBody {
	s.Code = &v
	return s
}

func (s *CreateOTAVerifyJobResponseBody) SetData(v *CreateOTAVerifyJobResponseBodyData) *CreateOTAVerifyJobResponseBody {
	s.Data = v
	return s
}

func (s *CreateOTAVerifyJobResponseBody) SetErrorMessage(v string) *CreateOTAVerifyJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateOTAVerifyJobResponseBody) SetRequestId(v string) *CreateOTAVerifyJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateOTAVerifyJobResponseBody) SetSuccess(v bool) *CreateOTAVerifyJobResponseBody {
	s.Success = &v
	return s
}

type CreateOTAVerifyJobResponseBodyData struct {
	// The ID of the verification task.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The time when the verification task was created. The time is displayed in UTC.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
}

func (s CreateOTAVerifyJobResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAVerifyJobResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateOTAVerifyJobResponseBodyData) SetJobId(v string) *CreateOTAVerifyJobResponseBodyData {
	s.JobId = &v
	return s
}

func (s *CreateOTAVerifyJobResponseBodyData) SetUtcCreate(v string) *CreateOTAVerifyJobResponseBodyData {
	s.UtcCreate = &v
	return s
}

type CreateOTAVerifyJobResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateOTAVerifyJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateOTAVerifyJobResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateOTAVerifyJobResponse) GoString() string {
	return s.String()
}

func (s *CreateOTAVerifyJobResponse) SetHeaders(v map[string]*string) *CreateOTAVerifyJobResponse {
	s.Headers = v
	return s
}

func (s *CreateOTAVerifyJobResponse) SetStatusCode(v int32) *CreateOTAVerifyJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateOTAVerifyJobResponse) SetBody(v *CreateOTAVerifyJobResponseBody) *CreateOTAVerifyJobResponse {
	s.Body = v
	return s
}

type CreateParserRequest struct {
	Description   *string `json:"Description,omitempty" xml:"Description,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Name          *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s CreateParserRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateParserRequest) GoString() string {
	return s.String()
}

func (s *CreateParserRequest) SetDescription(v string) *CreateParserRequest {
	s.Description = &v
	return s
}

func (s *CreateParserRequest) SetIotInstanceId(v string) *CreateParserRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateParserRequest) SetName(v string) *CreateParserRequest {
	s.Name = &v
	return s
}

type CreateParserResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	ParserId     *int64  `json:"ParserId,omitempty" xml:"ParserId,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateParserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateParserResponseBody) GoString() string {
	return s.String()
}

func (s *CreateParserResponseBody) SetCode(v string) *CreateParserResponseBody {
	s.Code = &v
	return s
}

func (s *CreateParserResponseBody) SetErrorMessage(v string) *CreateParserResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateParserResponseBody) SetParserId(v int64) *CreateParserResponseBody {
	s.ParserId = &v
	return s
}

func (s *CreateParserResponseBody) SetRequestId(v string) *CreateParserResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateParserResponseBody) SetSuccess(v bool) *CreateParserResponseBody {
	s.Success = &v
	return s
}

type CreateParserResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateParserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateParserResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateParserResponse) GoString() string {
	return s.String()
}

func (s *CreateParserResponse) SetHeaders(v map[string]*string) *CreateParserResponse {
	s.Headers = v
	return s
}

func (s *CreateParserResponse) SetStatusCode(v int32) *CreateParserResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateParserResponse) SetBody(v *CreateParserResponseBody) *CreateParserResponse {
	s.Body = v
	return s
}

type CreateParserDataSourceRequest struct {
	Description   *string `json:"Description,omitempty" xml:"Description,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Name          *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s CreateParserDataSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateParserDataSourceRequest) GoString() string {
	return s.String()
}

func (s *CreateParserDataSourceRequest) SetDescription(v string) *CreateParserDataSourceRequest {
	s.Description = &v
	return s
}

func (s *CreateParserDataSourceRequest) SetIotInstanceId(v string) *CreateParserDataSourceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateParserDataSourceRequest) SetName(v string) *CreateParserDataSourceRequest {
	s.Name = &v
	return s
}

type CreateParserDataSourceResponseBody struct {
	Code         *string                                       `json:"Code,omitempty" xml:"Code,omitempty"`
	DataSource   *CreateParserDataSourceResponseBodyDataSource `json:"DataSource,omitempty" xml:"DataSource,omitempty" type:"Struct"`
	ErrorMessage *string                                       `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                         `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateParserDataSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateParserDataSourceResponseBody) GoString() string {
	return s.String()
}

func (s *CreateParserDataSourceResponseBody) SetCode(v string) *CreateParserDataSourceResponseBody {
	s.Code = &v
	return s
}

func (s *CreateParserDataSourceResponseBody) SetDataSource(v *CreateParserDataSourceResponseBodyDataSource) *CreateParserDataSourceResponseBody {
	s.DataSource = v
	return s
}

func (s *CreateParserDataSourceResponseBody) SetErrorMessage(v string) *CreateParserDataSourceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateParserDataSourceResponseBody) SetRequestId(v string) *CreateParserDataSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateParserDataSourceResponseBody) SetSuccess(v bool) *CreateParserDataSourceResponseBody {
	s.Success = &v
	return s
}

type CreateParserDataSourceResponseBodyDataSource struct {
	DataSourceId *int64  `json:"DataSourceId,omitempty" xml:"DataSourceId,omitempty"`
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	UtcCreated   *string `json:"UtcCreated,omitempty" xml:"UtcCreated,omitempty"`
}

func (s CreateParserDataSourceResponseBodyDataSource) String() string {
	return tea.Prettify(s)
}

func (s CreateParserDataSourceResponseBodyDataSource) GoString() string {
	return s.String()
}

func (s *CreateParserDataSourceResponseBodyDataSource) SetDataSourceId(v int64) *CreateParserDataSourceResponseBodyDataSource {
	s.DataSourceId = &v
	return s
}

func (s *CreateParserDataSourceResponseBodyDataSource) SetDescription(v string) *CreateParserDataSourceResponseBodyDataSource {
	s.Description = &v
	return s
}

func (s *CreateParserDataSourceResponseBodyDataSource) SetName(v string) *CreateParserDataSourceResponseBodyDataSource {
	s.Name = &v
	return s
}

func (s *CreateParserDataSourceResponseBodyDataSource) SetUtcCreated(v string) *CreateParserDataSourceResponseBodyDataSource {
	s.UtcCreated = &v
	return s
}

type CreateParserDataSourceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateParserDataSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateParserDataSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateParserDataSourceResponse) GoString() string {
	return s.String()
}

func (s *CreateParserDataSourceResponse) SetHeaders(v map[string]*string) *CreateParserDataSourceResponse {
	s.Headers = v
	return s
}

func (s *CreateParserDataSourceResponse) SetStatusCode(v int32) *CreateParserDataSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateParserDataSourceResponse) SetBody(v *CreateParserDataSourceResponseBody) *CreateParserDataSourceResponse {
	s.Body = v
	return s
}

type CreateProductRequest struct {
	// The edition of the product.
	//
	// *   If you do not configure this parameter, a product of the Basic Edition is automatically created. You cannot use a TSL model to define the product.
	// *   If you want to configure this parameter, set the value to **iothub_senior**. A product that supports TSL models is created. You must also configure the **DataFormat** parameter.
	AliyunCommodityCode *string `json:"AliyunCommodityCode,omitempty" xml:"AliyunCommodityCode,omitempty"`
	// The verification method that is used to connect the devices of the product to IoT Platform.
	//
	// You do not need to configure this parameter. **secret**: uses DeviceSecrets to verify the devices. Default value: secret. For more information, see [MQTT connections over TCP](~~73742~~).
	AuthType *string `json:"AuthType,omitempty" xml:"AuthType,omitempty"`
	// The identifier of the product category. If you configure this parameter, a TSL model of the product category is used. Otherwise, no TSL model is used.
	//
	// You can call the [ListThingTemplates](~~150316~~) operation to query the details of product categories that are predefined by IoT Platform and obtain category keys.
	CategoryKey *string `json:"CategoryKey,omitempty" xml:"CategoryKey,omitempty"`
	// The data format.
	//
	// If the **AliyunCommodityCode** parameter is set to **iothub_senior**, you must configure this parameter.
	//
	// Valid values:
	//
	// *   **0**: custom data format.
	// *   **1**: Alink JSON format.
	DataFormat *int32 `json:"DataFormat,omitempty" xml:"DataFormat,omitempty"`
	// The description of the product. The description can be up to 100 characters in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// You do not need to configure this parameter.
	Id2 *bool `json:"Id2,omitempty" xml:"Id2,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	//
	// **Important**
	//
	// *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// *   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
	//
	// For more information about the instance, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// You do not need to configure this parameter.
	JoinPermissionId *string `json:"JoinPermissionId,omitempty" xml:"JoinPermissionId,omitempty"`
	// The network connection method.
	//
	// If the **AliyunCommodityCode** parameter is set to **iothub_senior** and the devices of the product are directly connected devices or gateways, you must configure this parameter.
	//
	// Valid values:
	//
	// *   **WIFI**: Wi-Fi.
	// *   **CELLULAR**: cellular network.
	// *   **ETHERNET**: Ethernet.
	// *   **OTHER**: other networks.
	//
	// Default value: WIFI.
	NetType *string `json:"NetType,omitempty" xml:"NetType,omitempty"`
	// The node type of the product. Valid values:
	//
	// *   **0**: device. Sub-devices cannot be attached to a device. A device can be directly connected to IoT Platform or connected to IoT Platform as a sub-device of a gateway. If you use the device as a sub-device, you must also configure the **ProtocolType** parameter.
	// *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain topological relationships with sub-devices, and synchronize topological relationships to IoT Platform.
	NodeType *int32 `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The name of the product.
	//
	// The name must be 4 to 30 characters in length, and can contain letters, digits, and underscores (\_).
	//
	//
	// **Important** Each product name must be unique within the current instance.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
	// The protocol used by the devices of the product to connect to the gateway.
	//
	// If the **AliyunCommodityCode** parameter is set to **iothub_senior** and a gateway is required to connect the devices of the product to IoT Platform, you must configure this parameter.
	//
	// Valid values:
	//
	// *   **modbus**: Modbus.
	// *   **opc-ua**: Open Platform Communication Unified Architecture (OPC UA).
	// *   **customize**: custom protocol.
	// *   **ble**: Bluetooth Low Energy (BLE).
	// *   **zigbee**: ZigBee.
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// Specifies whether to publish the TSL model after the product is created.
	//
	// *   **true**: publishes the TSL model after the product is created.
	// *   **false**: does not publish the TSL model after the product is created.
	//
	// Default value: **true**.
	PublishAuto *bool `json:"PublishAuto,omitempty" xml:"PublishAuto,omitempty"`
	// The ID of the resource group to which the product belongs. If you specify a value for this parameter, the product is added to the resource group.
	//
	// You can log on to the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups) to view the ID of the resource group.
	//
	//
	// **Important**
	//
	// You can specify a value for this parameter only if you have activated Resource Management.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The level of data verification. If you do not configure this parameter, the default value is used. Valid values:
	//
	// *   **1**: weak verification. Default value: 1. IoT Platform verifies only the identifier and dataType fields of the data. All data is forwarded.
	//
	//     In the IoT Platform console, the data is displayed on the **TSL Data** tab of the **Device Details** page. The data that fails to be verified is not displayed.
	//
	//     You can view the data that failed to be verified in the **checkFailedData** parameter of the forwarded data. For more information, see [Data formats](~~73736~~).
	//
	// *   **2**: no verification. IoT Platform does not verify the data. All data is forwarded.
	//
	//     In the IoT Platform console, the data is not displayed on the **TSL Data** tab of the **Device Details** page.
	ValidateType *int32 `json:"ValidateType,omitempty" xml:"ValidateType,omitempty"`
}

func (s CreateProductRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateProductRequest) GoString() string {
	return s.String()
}

func (s *CreateProductRequest) SetAliyunCommodityCode(v string) *CreateProductRequest {
	s.AliyunCommodityCode = &v
	return s
}

func (s *CreateProductRequest) SetAuthType(v string) *CreateProductRequest {
	s.AuthType = &v
	return s
}

func (s *CreateProductRequest) SetCategoryKey(v string) *CreateProductRequest {
	s.CategoryKey = &v
	return s
}

func (s *CreateProductRequest) SetDataFormat(v int32) *CreateProductRequest {
	s.DataFormat = &v
	return s
}

func (s *CreateProductRequest) SetDescription(v string) *CreateProductRequest {
	s.Description = &v
	return s
}

func (s *CreateProductRequest) SetId2(v bool) *CreateProductRequest {
	s.Id2 = &v
	return s
}

func (s *CreateProductRequest) SetIotInstanceId(v string) *CreateProductRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateProductRequest) SetJoinPermissionId(v string) *CreateProductRequest {
	s.JoinPermissionId = &v
	return s
}

func (s *CreateProductRequest) SetNetType(v string) *CreateProductRequest {
	s.NetType = &v
	return s
}

func (s *CreateProductRequest) SetNodeType(v int32) *CreateProductRequest {
	s.NodeType = &v
	return s
}

func (s *CreateProductRequest) SetProductName(v string) *CreateProductRequest {
	s.ProductName = &v
	return s
}

func (s *CreateProductRequest) SetProtocolType(v string) *CreateProductRequest {
	s.ProtocolType = &v
	return s
}

func (s *CreateProductRequest) SetPublishAuto(v bool) *CreateProductRequest {
	s.PublishAuto = &v
	return s
}

func (s *CreateProductRequest) SetResourceGroupId(v string) *CreateProductRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateProductRequest) SetValidateType(v int32) *CreateProductRequest {
	s.ValidateType = &v
	return s
}

type CreateProductResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The product information returned if the call is successful.
	Data *CreateProductResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ProductKey of the product. A ProductKey is a GUID that is issued by IoT Platform to a product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateProductResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateProductResponseBody) GoString() string {
	return s.String()
}

func (s *CreateProductResponseBody) SetCode(v string) *CreateProductResponseBody {
	s.Code = &v
	return s
}

func (s *CreateProductResponseBody) SetData(v *CreateProductResponseBodyData) *CreateProductResponseBody {
	s.Data = v
	return s
}

func (s *CreateProductResponseBody) SetErrorMessage(v string) *CreateProductResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateProductResponseBody) SetProductKey(v string) *CreateProductResponseBody {
	s.ProductKey = &v
	return s
}

func (s *CreateProductResponseBody) SetRequestId(v string) *CreateProductResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateProductResponseBody) SetSuccess(v bool) *CreateProductResponseBody {
	s.Success = &v
	return s
}

type CreateProductResponseBodyData struct {
	// The type of the product.
	//
	// *   **iothub_senior**: A TSL model was used.
	// *   **iothub**: No TSL model was used.
	AliyunCommodityCode *string `json:"AliyunCommodityCode,omitempty" xml:"AliyunCommodityCode,omitempty"`
	// The authentication method that is used to connect the devices of the product to IoT Platform. Valid values:
	//
	// *   **secret**: uses DeviceSecrets to verify the devices.
	// *   **id2**: uses IoT Internet Device ID to verify the devices.
	// *   **x509**: uses X.509 certificates to verify the devices.
	AuthType *string `json:"AuthType,omitempty" xml:"AuthType,omitempty"`
	// The data format.
	//
	// *   **0**: custom data format.
	// *   **1**: Alink JSON format.
	//
	// >  This parameter is returned only if the AliyunCommodityCode parameter is set to iothub_senior.
	DataFormat *int32 `json:"DataFormat,omitempty" xml:"DataFormat,omitempty"`
	// The description of the product.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Indicates whether IoT Internet Device ID was enabled.
	//
	// *   **true**: IoT Internet Device ID was enabled.
	// *   **false**: IoT Internet Device ID was disabled.
	Id2 *bool `json:"Id2,omitempty" xml:"Id2,omitempty"`
	// The node type of the product. Valid values:
	//
	// *   **0**: device. Sub-devices cannot be attached to a device. A device can be directly connected to IoT Platform or connected to IoT Platform as a sub-device of a gateway.
	// *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain topological relationships with sub-devices, and synchronize topological relationships to IoT Platform.
	//
	// >  This parameter is available only if the AliyunCommodityCode parameter is set to iothub_senior.
	NodeType *int32 `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The ProductKey of the product. A ProductKey is a globally unique identifier (GUID) issued by IoT Platform to a new product.
	//
	// >  Secure the **ProductKey** of the product. The ProductKey is required when you perform specific operations.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The name of the product.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
	// The ProductSecret of the product.
	ProductSecret *string `json:"ProductSecret,omitempty" xml:"ProductSecret,omitempty"`
	// The protocol used by the devices of the product to connect to the gateway.
	//
	// >  This parameter is available only if the AliyunCommodityCode parameter is set to iothub_senior.
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
}

func (s CreateProductResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateProductResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateProductResponseBodyData) SetAliyunCommodityCode(v string) *CreateProductResponseBodyData {
	s.AliyunCommodityCode = &v
	return s
}

func (s *CreateProductResponseBodyData) SetAuthType(v string) *CreateProductResponseBodyData {
	s.AuthType = &v
	return s
}

func (s *CreateProductResponseBodyData) SetDataFormat(v int32) *CreateProductResponseBodyData {
	s.DataFormat = &v
	return s
}

func (s *CreateProductResponseBodyData) SetDescription(v string) *CreateProductResponseBodyData {
	s.Description = &v
	return s
}

func (s *CreateProductResponseBodyData) SetId2(v bool) *CreateProductResponseBodyData {
	s.Id2 = &v
	return s
}

func (s *CreateProductResponseBodyData) SetNodeType(v int32) *CreateProductResponseBodyData {
	s.NodeType = &v
	return s
}

func (s *CreateProductResponseBodyData) SetProductKey(v string) *CreateProductResponseBodyData {
	s.ProductKey = &v
	return s
}

func (s *CreateProductResponseBodyData) SetProductName(v string) *CreateProductResponseBodyData {
	s.ProductName = &v
	return s
}

func (s *CreateProductResponseBodyData) SetProductSecret(v string) *CreateProductResponseBodyData {
	s.ProductSecret = &v
	return s
}

func (s *CreateProductResponseBodyData) SetProtocolType(v string) *CreateProductResponseBodyData {
	s.ProtocolType = &v
	return s
}

type CreateProductResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateProductResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateProductResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateProductResponse) GoString() string {
	return s.String()
}

func (s *CreateProductResponse) SetHeaders(v map[string]*string) *CreateProductResponse {
	s.Headers = v
	return s
}

func (s *CreateProductResponse) SetStatusCode(v int32) *CreateProductResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateProductResponse) SetBody(v *CreateProductResponseBody) *CreateProductResponse {
	s.Body = v
	return s
}

type CreateProductDistributeJobRequest struct {
	// The **ProductKey** of the product to be published.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the source instance to which the product belongs.
	//
	// *   The IDs of public instances in different regions:
	//
	//     *   China (Shanghai): iotx-oxssharez200.
	//     *   Japan (Tokyo): iotx-oxssharez300.
	//     *   Singapore (Singapore): iotx-oxssharez400.
	//     *   US (Silicon Valley): iotx-oxssharez500.
	//     *   US (Virginia): iotx-oxssharez600.
	//     *   Germany (Frankfurt): iotx-oxssharez700.
	//
	// *   The IDs of Enterprise Edition instances:
	//
	//     1\. Log on to the IoT Platform console. Select a region from the drop-down list in the upper-left corner of the top navigation bar.
	//
	//     2\. On the **Overview** page, click the instance name. On the **Instance Details** page, view the instance ID in the **Basic Information** section.
	SourceInstanceId *string `json:"SourceInstanceId,omitempty" xml:"SourceInstanceId,omitempty"`
	// The Alibaba Cloud account to which the product belongs. You can log on to the IoT Platform console, click the profile picture, and then view **Logon Account** on the **Security Settings** page.
	//
	// The **TargetUid** and **TargetAliyunId** parameters cannot be left empty at the same time.
	TargetAliyunId *string `json:"TargetAliyunId,omitempty" xml:"TargetAliyunId,omitempty"`
	// The ID of the destination instance to which the product is distributed. For more information about instance IDs, see the description of the **SourceInstanceId** parameter.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
	// The ID of the Alibaba Cloud account to which the product belongs. You can log on to the IoT Platform console, click the profile picture, and then view **Account ID** on the **Security Settings** page.
	//
	// The **TargetUid** and **TargetAliyunId** parameters cannot be left empty at the same time.
	TargetUid *string `json:"TargetUid,omitempty" xml:"TargetUid,omitempty"`
}

func (s CreateProductDistributeJobRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateProductDistributeJobRequest) GoString() string {
	return s.String()
}

func (s *CreateProductDistributeJobRequest) SetProductKey(v string) *CreateProductDistributeJobRequest {
	s.ProductKey = &v
	return s
}

func (s *CreateProductDistributeJobRequest) SetSourceInstanceId(v string) *CreateProductDistributeJobRequest {
	s.SourceInstanceId = &v
	return s
}

func (s *CreateProductDistributeJobRequest) SetTargetAliyunId(v string) *CreateProductDistributeJobRequest {
	s.TargetAliyunId = &v
	return s
}

func (s *CreateProductDistributeJobRequest) SetTargetInstanceId(v string) *CreateProductDistributeJobRequest {
	s.TargetInstanceId = &v
	return s
}

func (s *CreateProductDistributeJobRequest) SetTargetUid(v string) *CreateProductDistributeJobRequest {
	s.TargetUid = &v
	return s
}

type CreateProductDistributeJobResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The task ID returned if the call is successful. The ID globally identifies the task.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateProductDistributeJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateProductDistributeJobResponseBody) GoString() string {
	return s.String()
}

func (s *CreateProductDistributeJobResponseBody) SetCode(v string) *CreateProductDistributeJobResponseBody {
	s.Code = &v
	return s
}

func (s *CreateProductDistributeJobResponseBody) SetErrorMessage(v string) *CreateProductDistributeJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateProductDistributeJobResponseBody) SetJobId(v string) *CreateProductDistributeJobResponseBody {
	s.JobId = &v
	return s
}

func (s *CreateProductDistributeJobResponseBody) SetRequestId(v string) *CreateProductDistributeJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateProductDistributeJobResponseBody) SetSuccess(v bool) *CreateProductDistributeJobResponseBody {
	s.Success = &v
	return s
}

type CreateProductDistributeJobResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateProductDistributeJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateProductDistributeJobResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateProductDistributeJobResponse) GoString() string {
	return s.String()
}

func (s *CreateProductDistributeJobResponse) SetHeaders(v map[string]*string) *CreateProductDistributeJobResponse {
	s.Headers = v
	return s
}

func (s *CreateProductDistributeJobResponse) SetStatusCode(v int32) *CreateProductDistributeJobResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateProductDistributeJobResponse) SetBody(v *CreateProductDistributeJobResponseBody) *CreateProductDistributeJobResponse {
	s.Body = v
	return s
}

type CreateProductTagsRequest struct {
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	//
	// **Important**
	//
	// *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// *   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product. A **ProductKey** is a GUID that is issued by IoT Platform to a product.
	//
	// You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
	ProductKey *string                               `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	ProductTag []*CreateProductTagsRequestProductTag `json:"ProductTag,omitempty" xml:"ProductTag,omitempty" type:"Repeated"`
}

func (s CreateProductTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateProductTagsRequest) GoString() string {
	return s.String()
}

func (s *CreateProductTagsRequest) SetIotInstanceId(v string) *CreateProductTagsRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateProductTagsRequest) SetProductKey(v string) *CreateProductTagsRequest {
	s.ProductKey = &v
	return s
}

func (s *CreateProductTagsRequest) SetProductTag(v []*CreateProductTagsRequestProductTag) *CreateProductTagsRequest {
	s.ProductTag = v
	return s
}

type CreateProductTagsRequestProductTag struct {
	// The keys of product tags. Each key must be 1 to 30 characters in length, and can contain letters, digits, and periods (.).
	//
	//
	// **Important** `abc` is a **key** that is reserved by IoT Platform. You cannot set a **key** to `abc`. If you set a `key` to abc, the key is automatically filtered when you query tags.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The values of the product tags. Each tag value must be 1 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-).
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s CreateProductTagsRequestProductTag) String() string {
	return tea.Prettify(s)
}

func (s CreateProductTagsRequestProductTag) GoString() string {
	return s.String()
}

func (s *CreateProductTagsRequestProductTag) SetTagKey(v string) *CreateProductTagsRequestProductTag {
	s.TagKey = &v
	return s
}

func (s *CreateProductTagsRequestProductTag) SetTagValue(v string) *CreateProductTagsRequestProductTag {
	s.TagValue = &v
	return s
}

type CreateProductTagsResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The invalid product tags returned if the call fails.
	InvalidProductTags *CreateProductTagsResponseBodyInvalidProductTags `json:"InvalidProductTags,omitempty" xml:"InvalidProductTags,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful. The tags were attached to the product.
	// *   **false**: The call failed. This value indicates that the tags failed to be attached to the product.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateProductTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateProductTagsResponseBody) GoString() string {
	return s.String()
}

func (s *CreateProductTagsResponseBody) SetCode(v string) *CreateProductTagsResponseBody {
	s.Code = &v
	return s
}

func (s *CreateProductTagsResponseBody) SetErrorMessage(v string) *CreateProductTagsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateProductTagsResponseBody) SetInvalidProductTags(v *CreateProductTagsResponseBodyInvalidProductTags) *CreateProductTagsResponseBody {
	s.InvalidProductTags = v
	return s
}

func (s *CreateProductTagsResponseBody) SetRequestId(v string) *CreateProductTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateProductTagsResponseBody) SetSuccess(v bool) *CreateProductTagsResponseBody {
	s.Success = &v
	return s
}

type CreateProductTagsResponseBodyInvalidProductTags struct {
	ProductTag []*CreateProductTagsResponseBodyInvalidProductTagsProductTag `json:"ProductTag,omitempty" xml:"ProductTag,omitempty" type:"Repeated"`
}

func (s CreateProductTagsResponseBodyInvalidProductTags) String() string {
	return tea.Prettify(s)
}

func (s CreateProductTagsResponseBodyInvalidProductTags) GoString() string {
	return s.String()
}

func (s *CreateProductTagsResponseBodyInvalidProductTags) SetProductTag(v []*CreateProductTagsResponseBodyInvalidProductTagsProductTag) *CreateProductTagsResponseBodyInvalidProductTags {
	s.ProductTag = v
	return s
}

type CreateProductTagsResponseBodyInvalidProductTagsProductTag struct {
	// The key of the tag.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The value of the tag.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s CreateProductTagsResponseBodyInvalidProductTagsProductTag) String() string {
	return tea.Prettify(s)
}

func (s CreateProductTagsResponseBodyInvalidProductTagsProductTag) GoString() string {
	return s.String()
}

func (s *CreateProductTagsResponseBodyInvalidProductTagsProductTag) SetTagKey(v string) *CreateProductTagsResponseBodyInvalidProductTagsProductTag {
	s.TagKey = &v
	return s
}

func (s *CreateProductTagsResponseBodyInvalidProductTagsProductTag) SetTagValue(v string) *CreateProductTagsResponseBodyInvalidProductTagsProductTag {
	s.TagValue = &v
	return s
}

type CreateProductTagsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateProductTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateProductTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateProductTagsResponse) GoString() string {
	return s.String()
}

func (s *CreateProductTagsResponse) SetHeaders(v map[string]*string) *CreateProductTagsResponse {
	s.Headers = v
	return s
}

func (s *CreateProductTagsResponse) SetStatusCode(v int32) *CreateProductTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateProductTagsResponse) SetBody(v *CreateProductTagsResponseBody) *CreateProductTagsResponse {
	s.Body = v
	return s
}

type CreateProductTopicRequest struct {
	Codec *string `json:"Codec,omitempty" xml:"Codec,omitempty"`
	// The description of the topic category. The description must be 1 to 100 characters in length.
	Desc                 *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	EnableProxySubscribe *bool   `json:"EnableProxySubscribe,omitempty" xml:"EnableProxySubscribe,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The operation permissions of the device on the topic category. Valid values:
	//
	// *   **SUB**: Subscribe.
	// *   **PUB**: Publish.
	// *   **ALL**: Publish and Subscribe.
	Operation *string `json:"Operation,omitempty" xml:"Operation,omitempty"`
	// The ProductKey of the product for which you want to create a topic category.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The name of the user-defined category level that you want to set. By default, a topic category includes the following levels: \_productkey\_ and \_devicename\_. Separate the two levels with slashes (/). Format of a topic category: `productKey/deviceName/topicShortName` .
	//
	// >  Each level can contain letters, digits, and underscores (\_), and cannot be empty.
	TopicShortName *string `json:"TopicShortName,omitempty" xml:"TopicShortName,omitempty"`
}

func (s CreateProductTopicRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateProductTopicRequest) GoString() string {
	return s.String()
}

func (s *CreateProductTopicRequest) SetCodec(v string) *CreateProductTopicRequest {
	s.Codec = &v
	return s
}

func (s *CreateProductTopicRequest) SetDesc(v string) *CreateProductTopicRequest {
	s.Desc = &v
	return s
}

func (s *CreateProductTopicRequest) SetEnableProxySubscribe(v bool) *CreateProductTopicRequest {
	s.EnableProxySubscribe = &v
	return s
}

func (s *CreateProductTopicRequest) SetIotInstanceId(v string) *CreateProductTopicRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateProductTopicRequest) SetOperation(v string) *CreateProductTopicRequest {
	s.Operation = &v
	return s
}

func (s *CreateProductTopicRequest) SetProductKey(v string) *CreateProductTopicRequest {
	s.ProductKey = &v
	return s
}

func (s *CreateProductTopicRequest) SetTopicShortName(v string) *CreateProductTopicRequest {
	s.TopicShortName = &v
	return s
}

type CreateProductTopicResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The ID of the topic category. The ID is generated by IoT Platform if the call is successful.
	//
	// >  Secure the information for future reference. When you call an operation that is related to the topic category, you must provide this parameter.
	TopicId *int64 `json:"TopicId,omitempty" xml:"TopicId,omitempty"`
}

func (s CreateProductTopicResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateProductTopicResponseBody) GoString() string {
	return s.String()
}

func (s *CreateProductTopicResponseBody) SetCode(v string) *CreateProductTopicResponseBody {
	s.Code = &v
	return s
}

func (s *CreateProductTopicResponseBody) SetErrorMessage(v string) *CreateProductTopicResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateProductTopicResponseBody) SetRequestId(v string) *CreateProductTopicResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateProductTopicResponseBody) SetSuccess(v bool) *CreateProductTopicResponseBody {
	s.Success = &v
	return s
}

func (s *CreateProductTopicResponseBody) SetTopicId(v int64) *CreateProductTopicResponseBody {
	s.TopicId = &v
	return s
}

type CreateProductTopicResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateProductTopicResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateProductTopicResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateProductTopicResponse) GoString() string {
	return s.String()
}

func (s *CreateProductTopicResponse) SetHeaders(v map[string]*string) *CreateProductTopicResponse {
	s.Headers = v
	return s
}

func (s *CreateProductTopicResponse) SetStatusCode(v int32) *CreateProductTopicResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateProductTopicResponse) SetBody(v *CreateProductTopicResponseBody) *CreateProductTopicResponse {
	s.Body = v
	return s
}

type CreateRuleRequest struct {
	// The format of the data that is processed based on the rule. The value of this parameter must be consistent with the format of device data that you want to process. Valid values:
	//
	// *   **JSON**: JSON data. This is the default value.
	// *   **BINARY**: binary data.
	//
	// >  If this parameter is set to **BINARY**, you cannot set the **TopicType** parameter to 0 and cannot forward data to Tablestore and ApsaraDB RDS.
	DataType *string `json:"DataType,omitempty" xml:"DataType,omitempty"`
	// The ID of the instance. On the **Overview** page in the IoT Platform console, you can view the **ID** of the instance.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If the **Overview** page or instance ID is not displayed in the IoT Platform console, you do not need to configure this parameter.
	//
	// For more information about the instance, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The name of the data forwarding rule. The rule name must be 1 to 30 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-).
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ProductKey of the product to which the rule applies.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the resource group to which the rule is assigned. You can view the resource group information in the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups).
	//
	// >You can specify a value for this parameter only if you have activated Resource Management.
	//
	// If you do not specify this parameter, the rule is assigned to the default resource group.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The description of the rule. The description can be up to 100 characters in length.
	RuleDesc *string `json:"RuleDesc,omitempty" xml:"RuleDesc,omitempty"`
	// The SQL SELECT statement that you want to execute. For more information about the syntax, see [SQL statements](~~30554~~).
	//
	// >  This parameter specifies the fields in SELECT statements. For example, if the SELECT statement is `SELECT a,b,c`, specify `a,b,c` for this parameter.
	Select *string `json:"Select,omitempty" xml:"Select,omitempty"`
	// The topic to which this rule is applied. Format: `${deviceName}/topicShortName`. `${deviceName}` specifies the name of the device, and `topicShortName` specifies the custom name of the topic.
	//
	// *   Basic communication topics or Thing Specification Language (TSL)-based communication topics. Format: `${deviceName}/topicShortName`. You can replace `${deviceName}` with the `+` wildcard character. The wildcard character indicates that the topic applies to all devices under the product. Valid values of `topicShortName`:
	//
	//     *   `/thing/event/property/post`: submits the property data of a device.
	//
	//     *   `/thing/event/${tsl.event.identifier}/post`: submits the event data of a device. `${tsl.event.identifier}` specifies the identifier of an event in the TSL model.
	//
	//     *   `/thing/lifecycle`: submits device lifecycle changes.
	//
	//     *   `/thing/downlink/reply/message`: sends a response to a request from IoT Platform.
	//
	//     *   `/thing/list/found`: submits the data when a gateway detects a new sub-device.
	//
	//     *   `/thing/topo/lifecycle`: submits device topology changes.
	//
	//     *   `/thing/event/property/history/post`: submits the historical property data of a device.
	//
	//     *   `/thing/event/${tsl.event.identifier}/post`: submits the historical event data of a device. `${tsl.event.identifier}` specifies the identifier of an event in the TSL model.
	//
	//     *   `/ota/upgrade`: submits the OTA update status.
	//
	//     *   `/ota/version/post`: submits OTA module versions.
	//
	//     *   `/thing/deviceinfo/update`: submits device tag changes.
	//
	//     *   `/edge/driver/${driver_id}/point_post`: submits pass-through data from Link IoT Edge. `${driver_id}` specifies the ID of the driver that a device uses to access Link IoT Edge.
	//
	//         The `${packageId}/${jobId}/ota/job/status` topic submits the status of OTA update batches. This topic is a basic communication topic. `${packageId}` specifies the ID of the update package. `${jobId}` specifies the ID of the update batch.
	//
	// *   Custom topics. Example: `${deviceName}/user/get`.
	//
	//     You can call the [QueryProductTopic](~~69647~~) operation to view all custom topics of the product.
	//
	//     When you specify a custom topic, you can use the `+` and `#` wildcard characters.
	//
	//     *   You can replace `${deviceName}` with the `+` wildcard character. The wildcard character specifies that the topic applies to all devices in the product.
	//
	//     *   You can add `/user/#` after ${deviceName}. The `#` wildcard character can match all field values at the levels that follow `/user`.
	//
	//         For more information about how to use wildcard characters, see [Custom topics with one or more wildcard characters](~~85539~~).
	//
	// *   Topics that are used to submit device status changes. The topic name is in the `${deviceName}` format.
	//
	//     You can use the `+` wildcard character. In this case, the status changes of all devices under the product are submitted.
	ShortTopic *string `json:"ShortTopic,omitempty" xml:"ShortTopic,omitempty"`
	// The complete topic to which the rule applies.
	//
	// If you specify this parameter, you do not need to specify the **ShortTopic** and **TopicType** parameters.
	Topic *string `json:"Topic,omitempty" xml:"Topic,omitempty"`
	// *   **0**: The topic is a basic communication topic or TSL-based communication topic. The topic that is used to submit the status of OTA update batches belongs to the basic communication topics.****
	// *   **1**: a custom topic.
	// *   **2**: The topic is used to submit device status changes. Format: `/as/mqtt/status/${productKey}/${deviceName}`.
	TopicType *int32 `json:"TopicType,omitempty" xml:"TopicType,omitempty"`
	// The condition that is used to trigger the rule. For more information about the rule, see [SQL statements](~~30554~~).
	//
	// >  This parameter specifies the fields in the **WHERE** clause. For example, if the **WHERE** clause is `WHERE a > 10`, you must specify `a > 10` for this parameter.
	Where *string `json:"Where,omitempty" xml:"Where,omitempty"`
}

func (s CreateRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateRuleRequest) SetDataType(v string) *CreateRuleRequest {
	s.DataType = &v
	return s
}

func (s *CreateRuleRequest) SetIotInstanceId(v string) *CreateRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateRuleRequest) SetName(v string) *CreateRuleRequest {
	s.Name = &v
	return s
}

func (s *CreateRuleRequest) SetProductKey(v string) *CreateRuleRequest {
	s.ProductKey = &v
	return s
}

func (s *CreateRuleRequest) SetResourceGroupId(v string) *CreateRuleRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *CreateRuleRequest) SetRuleDesc(v string) *CreateRuleRequest {
	s.RuleDesc = &v
	return s
}

func (s *CreateRuleRequest) SetSelect(v string) *CreateRuleRequest {
	s.Select = &v
	return s
}

func (s *CreateRuleRequest) SetShortTopic(v string) *CreateRuleRequest {
	s.ShortTopic = &v
	return s
}

func (s *CreateRuleRequest) SetTopic(v string) *CreateRuleRequest {
	s.Topic = &v
	return s
}

func (s *CreateRuleRequest) SetTopicType(v int32) *CreateRuleRequest {
	s.TopicType = &v
	return s
}

func (s *CreateRuleRequest) SetWhere(v string) *CreateRuleRequest {
	s.Where = &v
	return s
}

type CreateRuleResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. The ID uniquely identifies this request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The ID of the rule. If the call succeeds, the rule ID is generated by the rules engine.
	//
	// >  Keep the information safe for future reference. You must provide the rule ID when you want to call rule-related operations.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateRuleResponseBody) SetCode(v string) *CreateRuleResponseBody {
	s.Code = &v
	return s
}

func (s *CreateRuleResponseBody) SetErrorMessage(v string) *CreateRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateRuleResponseBody) SetRequestId(v string) *CreateRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateRuleResponseBody) SetRuleId(v int64) *CreateRuleResponseBody {
	s.RuleId = &v
	return s
}

func (s *CreateRuleResponseBody) SetSuccess(v bool) *CreateRuleResponseBody {
	s.Success = &v
	return s
}

type CreateRuleResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateRuleResponse) SetHeaders(v map[string]*string) *CreateRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateRuleResponse) SetStatusCode(v int32) *CreateRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateRuleResponse) SetBody(v *CreateRuleResponseBody) *CreateRuleResponse {
	s.Body = v
	return s
}

type CreateRuleActionRequest struct {
	// The configurations of the rule action. You must specify a JSON string. The configurations vary based on the types of rule actions. For more information about required syntax and examples, see the following tables.
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
	// Specifies whether the rule action forwards error operation data. Error operation data is generated when the rules engine failed to forward data from the IoT Platform topic to the destination cloud service. A data forwarding failure indicates that forwarding retries also fail. Valid values:
	//
	// *   **true**: forwards error operation data.
	// *   **false**: forwards normal data instead of error operation data.
	//
	// Default value: **false**.
	ErrorActionFlag *bool `json:"ErrorActionFlag,omitempty" xml:"ErrorActionFlag,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the rule for which you want to create an action. You can log on to the IoT Platform console, and choose **Rules** > **Data Forwarding** to view the rule ID. You can also call the [ListRule](~~69486~~) operation and view the rule ID in the response.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The type of the rule action. Valid values:
	//
	// *   **REPUBLISH**: forwards topic data that is processed by the rules engine to another IoT Platform topic.
	// *   **AMQP**: forwards data to an AMQP consumer group.
	// *   **MNS**: forwards data that is processed by the rules engine to Message Service (MNS).
	// *   **FC**: forwards topic data that is processed by the rules engine to Function Compute for event computing.
	// *   **OTS**: forwards data that is processed by the rules engine to OTS for NoSQL data storage.
	//
	// >  If you set the **DataType** parameter to **BINARY**, rules are created in the binary format. These rules cannot be used to forward data to Tablestore.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateRuleActionRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateRuleActionRequest) GoString() string {
	return s.String()
}

func (s *CreateRuleActionRequest) SetConfiguration(v string) *CreateRuleActionRequest {
	s.Configuration = &v
	return s
}

func (s *CreateRuleActionRequest) SetErrorActionFlag(v bool) *CreateRuleActionRequest {
	s.ErrorActionFlag = &v
	return s
}

func (s *CreateRuleActionRequest) SetIotInstanceId(v string) *CreateRuleActionRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateRuleActionRequest) SetRuleId(v int64) *CreateRuleActionRequest {
	s.RuleId = &v
	return s
}

func (s *CreateRuleActionRequest) SetType(v string) *CreateRuleActionRequest {
	s.Type = &v
	return s
}

type CreateRuleActionResponseBody struct {
	// The ID of the action. The action ID is generated by the rules engine if the call is successful.
	//
	// >  Secure the information for future reference. When you call an operation that is related to the rule action, you must provide the action ID.
	ActionId *int64 `json:"ActionId,omitempty" xml:"ActionId,omitempty"`
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateRuleActionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateRuleActionResponseBody) GoString() string {
	return s.String()
}

func (s *CreateRuleActionResponseBody) SetActionId(v int64) *CreateRuleActionResponseBody {
	s.ActionId = &v
	return s
}

func (s *CreateRuleActionResponseBody) SetCode(v string) *CreateRuleActionResponseBody {
	s.Code = &v
	return s
}

func (s *CreateRuleActionResponseBody) SetErrorMessage(v string) *CreateRuleActionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateRuleActionResponseBody) SetRequestId(v string) *CreateRuleActionResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateRuleActionResponseBody) SetSuccess(v bool) *CreateRuleActionResponseBody {
	s.Success = &v
	return s
}

type CreateRuleActionResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateRuleActionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateRuleActionResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateRuleActionResponse) GoString() string {
	return s.String()
}

func (s *CreateRuleActionResponse) SetHeaders(v map[string]*string) *CreateRuleActionResponse {
	s.Headers = v
	return s
}

func (s *CreateRuleActionResponse) SetStatusCode(v int32) *CreateRuleActionResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateRuleActionResponse) SetBody(v *CreateRuleActionResponseBody) *CreateRuleActionResponse {
	s.Body = v
	return s
}

type CreateSceneRuleRequest struct {
	IotInstanceId   *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	RuleContent     *string `json:"RuleContent,omitempty" xml:"RuleContent,omitempty"`
	RuleDescription *string `json:"RuleDescription,omitempty" xml:"RuleDescription,omitempty"`
	RuleName        *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
}

func (s CreateSceneRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSceneRuleRequest) GoString() string {
	return s.String()
}

func (s *CreateSceneRuleRequest) SetIotInstanceId(v string) *CreateSceneRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateSceneRuleRequest) SetRuleContent(v string) *CreateSceneRuleRequest {
	s.RuleContent = &v
	return s
}

func (s *CreateSceneRuleRequest) SetRuleDescription(v string) *CreateSceneRuleRequest {
	s.RuleDescription = &v
	return s
}

func (s *CreateSceneRuleRequest) SetRuleName(v string) *CreateSceneRuleRequest {
	s.RuleName = &v
	return s
}

type CreateSceneRuleResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	RuleId       *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateSceneRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSceneRuleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSceneRuleResponseBody) SetCode(v string) *CreateSceneRuleResponseBody {
	s.Code = &v
	return s
}

func (s *CreateSceneRuleResponseBody) SetErrorMessage(v string) *CreateSceneRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateSceneRuleResponseBody) SetRequestId(v string) *CreateSceneRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSceneRuleResponseBody) SetRuleId(v string) *CreateSceneRuleResponseBody {
	s.RuleId = &v
	return s
}

func (s *CreateSceneRuleResponseBody) SetSuccess(v bool) *CreateSceneRuleResponseBody {
	s.Success = &v
	return s
}

type CreateSceneRuleResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSceneRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSceneRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSceneRuleResponse) GoString() string {
	return s.String()
}

func (s *CreateSceneRuleResponse) SetHeaders(v map[string]*string) *CreateSceneRuleResponse {
	s.Headers = v
	return s
}

func (s *CreateSceneRuleResponse) SetStatusCode(v int32) *CreateSceneRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSceneRuleResponse) SetBody(v *CreateSceneRuleResponseBody) *CreateSceneRuleResponse {
	s.Body = v
	return s
}

type CreateSchedulePeriodRequest struct {
	Description      *string `json:"Description,omitempty" xml:"Description,omitempty"`
	EndTime          *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	IotInstanceId    *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ScheduleCode     *string `json:"ScheduleCode,omitempty" xml:"ScheduleCode,omitempty"`
	SoundCodeContent *string `json:"SoundCodeContent,omitempty" xml:"SoundCodeContent,omitempty"`
	StartTime        *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s CreateSchedulePeriodRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSchedulePeriodRequest) GoString() string {
	return s.String()
}

func (s *CreateSchedulePeriodRequest) SetDescription(v string) *CreateSchedulePeriodRequest {
	s.Description = &v
	return s
}

func (s *CreateSchedulePeriodRequest) SetEndTime(v string) *CreateSchedulePeriodRequest {
	s.EndTime = &v
	return s
}

func (s *CreateSchedulePeriodRequest) SetIotInstanceId(v string) *CreateSchedulePeriodRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateSchedulePeriodRequest) SetScheduleCode(v string) *CreateSchedulePeriodRequest {
	s.ScheduleCode = &v
	return s
}

func (s *CreateSchedulePeriodRequest) SetSoundCodeContent(v string) *CreateSchedulePeriodRequest {
	s.SoundCodeContent = &v
	return s
}

func (s *CreateSchedulePeriodRequest) SetStartTime(v string) *CreateSchedulePeriodRequest {
	s.StartTime = &v
	return s
}

type CreateSchedulePeriodResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateSchedulePeriodResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSchedulePeriodResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSchedulePeriodResponseBody) SetCode(v string) *CreateSchedulePeriodResponseBody {
	s.Code = &v
	return s
}

func (s *CreateSchedulePeriodResponseBody) SetData(v string) *CreateSchedulePeriodResponseBody {
	s.Data = &v
	return s
}

func (s *CreateSchedulePeriodResponseBody) SetErrorMessage(v string) *CreateSchedulePeriodResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateSchedulePeriodResponseBody) SetRequestId(v string) *CreateSchedulePeriodResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSchedulePeriodResponseBody) SetSuccess(v bool) *CreateSchedulePeriodResponseBody {
	s.Success = &v
	return s
}

type CreateSchedulePeriodResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSchedulePeriodResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSchedulePeriodResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSchedulePeriodResponse) GoString() string {
	return s.String()
}

func (s *CreateSchedulePeriodResponse) SetHeaders(v map[string]*string) *CreateSchedulePeriodResponse {
	s.Headers = v
	return s
}

func (s *CreateSchedulePeriodResponse) SetStatusCode(v int32) *CreateSchedulePeriodResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSchedulePeriodResponse) SetBody(v *CreateSchedulePeriodResponseBody) *CreateSchedulePeriodResponse {
	s.Body = v
	return s
}

type CreateSharePromotionActivityRequest struct {
	EndTime                    *int64  `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	IotInstanceId              *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	SharePromotionActivityName *string `json:"SharePromotionActivityName,omitempty" xml:"SharePromotionActivityName,omitempty"`
	StartTime                  *int64  `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s CreateSharePromotionActivityRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSharePromotionActivityRequest) GoString() string {
	return s.String()
}

func (s *CreateSharePromotionActivityRequest) SetEndTime(v int64) *CreateSharePromotionActivityRequest {
	s.EndTime = &v
	return s
}

func (s *CreateSharePromotionActivityRequest) SetIotInstanceId(v string) *CreateSharePromotionActivityRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateSharePromotionActivityRequest) SetSharePromotionActivityName(v string) *CreateSharePromotionActivityRequest {
	s.SharePromotionActivityName = &v
	return s
}

func (s *CreateSharePromotionActivityRequest) SetStartTime(v int64) *CreateSharePromotionActivityRequest {
	s.StartTime = &v
	return s
}

type CreateSharePromotionActivityResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateSharePromotionActivityResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSharePromotionActivityResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSharePromotionActivityResponseBody) SetCode(v string) *CreateSharePromotionActivityResponseBody {
	s.Code = &v
	return s
}

func (s *CreateSharePromotionActivityResponseBody) SetData(v string) *CreateSharePromotionActivityResponseBody {
	s.Data = &v
	return s
}

func (s *CreateSharePromotionActivityResponseBody) SetErrorMessage(v string) *CreateSharePromotionActivityResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateSharePromotionActivityResponseBody) SetRequestId(v string) *CreateSharePromotionActivityResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSharePromotionActivityResponseBody) SetSuccess(v bool) *CreateSharePromotionActivityResponseBody {
	s.Success = &v
	return s
}

type CreateSharePromotionActivityResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSharePromotionActivityResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSharePromotionActivityResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSharePromotionActivityResponse) GoString() string {
	return s.String()
}

func (s *CreateSharePromotionActivityResponse) SetHeaders(v map[string]*string) *CreateSharePromotionActivityResponse {
	s.Headers = v
	return s
}

func (s *CreateSharePromotionActivityResponse) SetStatusCode(v int32) *CreateSharePromotionActivityResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSharePromotionActivityResponse) SetBody(v *CreateSharePromotionActivityResponseBody) *CreateSharePromotionActivityResponse {
	s.Body = v
	return s
}

type CreateSharePromotionSpeechModelRequest struct {
	AudioFormat              *string `json:"AudioFormat,omitempty" xml:"AudioFormat,omitempty"`
	BizCode                  *string `json:"BizCode,omitempty" xml:"BizCode,omitempty"`
	IotInstanceId            *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	SharePromotionActivityId *string `json:"SharePromotionActivityId,omitempty" xml:"SharePromotionActivityId,omitempty"`
	ShareTaskCode            *string `json:"ShareTaskCode,omitempty" xml:"ShareTaskCode,omitempty"`
	SpeechModelType          *string `json:"SpeechModelType,omitempty" xml:"SpeechModelType,omitempty"`
	SpeechRate               *int32  `json:"SpeechRate,omitempty" xml:"SpeechRate,omitempty"`
	Text                     *string `json:"Text,omitempty" xml:"Text,omitempty"`
	Voice                    *string `json:"Voice,omitempty" xml:"Voice,omitempty"`
	Volume                   *int32  `json:"Volume,omitempty" xml:"Volume,omitempty"`
}

func (s CreateSharePromotionSpeechModelRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSharePromotionSpeechModelRequest) GoString() string {
	return s.String()
}

func (s *CreateSharePromotionSpeechModelRequest) SetAudioFormat(v string) *CreateSharePromotionSpeechModelRequest {
	s.AudioFormat = &v
	return s
}

func (s *CreateSharePromotionSpeechModelRequest) SetBizCode(v string) *CreateSharePromotionSpeechModelRequest {
	s.BizCode = &v
	return s
}

func (s *CreateSharePromotionSpeechModelRequest) SetIotInstanceId(v string) *CreateSharePromotionSpeechModelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateSharePromotionSpeechModelRequest) SetSharePromotionActivityId(v string) *CreateSharePromotionSpeechModelRequest {
	s.SharePromotionActivityId = &v
	return s
}

func (s *CreateSharePromotionSpeechModelRequest) SetShareTaskCode(v string) *CreateSharePromotionSpeechModelRequest {
	s.ShareTaskCode = &v
	return s
}

func (s *CreateSharePromotionSpeechModelRequest) SetSpeechModelType(v string) *CreateSharePromotionSpeechModelRequest {
	s.SpeechModelType = &v
	return s
}

func (s *CreateSharePromotionSpeechModelRequest) SetSpeechRate(v int32) *CreateSharePromotionSpeechModelRequest {
	s.SpeechRate = &v
	return s
}

func (s *CreateSharePromotionSpeechModelRequest) SetText(v string) *CreateSharePromotionSpeechModelRequest {
	s.Text = &v
	return s
}

func (s *CreateSharePromotionSpeechModelRequest) SetVoice(v string) *CreateSharePromotionSpeechModelRequest {
	s.Voice = &v
	return s
}

func (s *CreateSharePromotionSpeechModelRequest) SetVolume(v int32) *CreateSharePromotionSpeechModelRequest {
	s.Volume = &v
	return s
}

type CreateSharePromotionSpeechModelResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateSharePromotionSpeechModelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSharePromotionSpeechModelResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSharePromotionSpeechModelResponseBody) SetCode(v string) *CreateSharePromotionSpeechModelResponseBody {
	s.Code = &v
	return s
}

func (s *CreateSharePromotionSpeechModelResponseBody) SetErrorMessage(v string) *CreateSharePromotionSpeechModelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateSharePromotionSpeechModelResponseBody) SetRequestId(v string) *CreateSharePromotionSpeechModelResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSharePromotionSpeechModelResponseBody) SetSuccess(v bool) *CreateSharePromotionSpeechModelResponseBody {
	s.Success = &v
	return s
}

type CreateSharePromotionSpeechModelResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSharePromotionSpeechModelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSharePromotionSpeechModelResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSharePromotionSpeechModelResponse) GoString() string {
	return s.String()
}

func (s *CreateSharePromotionSpeechModelResponse) SetHeaders(v map[string]*string) *CreateSharePromotionSpeechModelResponse {
	s.Headers = v
	return s
}

func (s *CreateSharePromotionSpeechModelResponse) SetStatusCode(v int32) *CreateSharePromotionSpeechModelResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSharePromotionSpeechModelResponse) SetBody(v *CreateSharePromotionSpeechModelResponseBody) *CreateSharePromotionSpeechModelResponse {
	s.Body = v
	return s
}

type CreateSoundCodeRequest struct {
	Duration         *int32  `json:"Duration,omitempty" xml:"Duration,omitempty"`
	IotInstanceId    *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Name             *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OpenType         *string `json:"OpenType,omitempty" xml:"OpenType,omitempty"`
	SoundCodeContent *string `json:"SoundCodeContent,omitempty" xml:"SoundCodeContent,omitempty"`
}

func (s CreateSoundCodeRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSoundCodeRequest) GoString() string {
	return s.String()
}

func (s *CreateSoundCodeRequest) SetDuration(v int32) *CreateSoundCodeRequest {
	s.Duration = &v
	return s
}

func (s *CreateSoundCodeRequest) SetIotInstanceId(v string) *CreateSoundCodeRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateSoundCodeRequest) SetName(v string) *CreateSoundCodeRequest {
	s.Name = &v
	return s
}

func (s *CreateSoundCodeRequest) SetOpenType(v string) *CreateSoundCodeRequest {
	s.OpenType = &v
	return s
}

func (s *CreateSoundCodeRequest) SetSoundCodeContent(v string) *CreateSoundCodeRequest {
	s.SoundCodeContent = &v
	return s
}

type CreateSoundCodeResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateSoundCodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSoundCodeResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSoundCodeResponseBody) SetCode(v string) *CreateSoundCodeResponseBody {
	s.Code = &v
	return s
}

func (s *CreateSoundCodeResponseBody) SetData(v string) *CreateSoundCodeResponseBody {
	s.Data = &v
	return s
}

func (s *CreateSoundCodeResponseBody) SetErrorMessage(v string) *CreateSoundCodeResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateSoundCodeResponseBody) SetRequestId(v string) *CreateSoundCodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSoundCodeResponseBody) SetSuccess(v bool) *CreateSoundCodeResponseBody {
	s.Success = &v
	return s
}

type CreateSoundCodeResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSoundCodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSoundCodeResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSoundCodeResponse) GoString() string {
	return s.String()
}

func (s *CreateSoundCodeResponse) SetHeaders(v map[string]*string) *CreateSoundCodeResponse {
	s.Headers = v
	return s
}

func (s *CreateSoundCodeResponse) SetStatusCode(v int32) *CreateSoundCodeResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSoundCodeResponse) SetBody(v *CreateSoundCodeResponseBody) *CreateSoundCodeResponse {
	s.Body = v
	return s
}

type CreateSoundCodeLabelRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Label         *string `json:"Label,omitempty" xml:"Label,omitempty"`
	ScheduleCode  *string `json:"ScheduleCode,omitempty" xml:"ScheduleCode,omitempty"`
}

func (s CreateSoundCodeLabelRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSoundCodeLabelRequest) GoString() string {
	return s.String()
}

func (s *CreateSoundCodeLabelRequest) SetIotInstanceId(v string) *CreateSoundCodeLabelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateSoundCodeLabelRequest) SetLabel(v string) *CreateSoundCodeLabelRequest {
	s.Label = &v
	return s
}

func (s *CreateSoundCodeLabelRequest) SetScheduleCode(v string) *CreateSoundCodeLabelRequest {
	s.ScheduleCode = &v
	return s
}

type CreateSoundCodeLabelResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateSoundCodeLabelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSoundCodeLabelResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSoundCodeLabelResponseBody) SetCode(v string) *CreateSoundCodeLabelResponseBody {
	s.Code = &v
	return s
}

func (s *CreateSoundCodeLabelResponseBody) SetData(v string) *CreateSoundCodeLabelResponseBody {
	s.Data = &v
	return s
}

func (s *CreateSoundCodeLabelResponseBody) SetErrorMessage(v string) *CreateSoundCodeLabelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateSoundCodeLabelResponseBody) SetRequestId(v string) *CreateSoundCodeLabelResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSoundCodeLabelResponseBody) SetSuccess(v bool) *CreateSoundCodeLabelResponseBody {
	s.Success = &v
	return s
}

type CreateSoundCodeLabelResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSoundCodeLabelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSoundCodeLabelResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSoundCodeLabelResponse) GoString() string {
	return s.String()
}

func (s *CreateSoundCodeLabelResponse) SetHeaders(v map[string]*string) *CreateSoundCodeLabelResponse {
	s.Headers = v
	return s
}

func (s *CreateSoundCodeLabelResponse) SetStatusCode(v int32) *CreateSoundCodeLabelResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSoundCodeLabelResponse) SetBody(v *CreateSoundCodeLabelResponseBody) *CreateSoundCodeLabelResponse {
	s.Body = v
	return s
}

type CreateSoundCodeScheduleRequest struct {
	Description   *string `json:"Description,omitempty" xml:"Description,omitempty"`
	EndDate       *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Name          *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OpenType      *string `json:"OpenType,omitempty" xml:"OpenType,omitempty"`
	StartDate     *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
}

func (s CreateSoundCodeScheduleRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSoundCodeScheduleRequest) GoString() string {
	return s.String()
}

func (s *CreateSoundCodeScheduleRequest) SetDescription(v string) *CreateSoundCodeScheduleRequest {
	s.Description = &v
	return s
}

func (s *CreateSoundCodeScheduleRequest) SetEndDate(v string) *CreateSoundCodeScheduleRequest {
	s.EndDate = &v
	return s
}

func (s *CreateSoundCodeScheduleRequest) SetIotInstanceId(v string) *CreateSoundCodeScheduleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateSoundCodeScheduleRequest) SetName(v string) *CreateSoundCodeScheduleRequest {
	s.Name = &v
	return s
}

func (s *CreateSoundCodeScheduleRequest) SetOpenType(v string) *CreateSoundCodeScheduleRequest {
	s.OpenType = &v
	return s
}

func (s *CreateSoundCodeScheduleRequest) SetStartDate(v string) *CreateSoundCodeScheduleRequest {
	s.StartDate = &v
	return s
}

type CreateSoundCodeScheduleResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateSoundCodeScheduleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSoundCodeScheduleResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSoundCodeScheduleResponseBody) SetCode(v string) *CreateSoundCodeScheduleResponseBody {
	s.Code = &v
	return s
}

func (s *CreateSoundCodeScheduleResponseBody) SetData(v string) *CreateSoundCodeScheduleResponseBody {
	s.Data = &v
	return s
}

func (s *CreateSoundCodeScheduleResponseBody) SetErrorMessage(v string) *CreateSoundCodeScheduleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateSoundCodeScheduleResponseBody) SetRequestId(v string) *CreateSoundCodeScheduleResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSoundCodeScheduleResponseBody) SetSuccess(v bool) *CreateSoundCodeScheduleResponseBody {
	s.Success = &v
	return s
}

type CreateSoundCodeScheduleResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSoundCodeScheduleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSoundCodeScheduleResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSoundCodeScheduleResponse) GoString() string {
	return s.String()
}

func (s *CreateSoundCodeScheduleResponse) SetHeaders(v map[string]*string) *CreateSoundCodeScheduleResponse {
	s.Headers = v
	return s
}

func (s *CreateSoundCodeScheduleResponse) SetStatusCode(v int32) *CreateSoundCodeScheduleResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSoundCodeScheduleResponse) SetBody(v *CreateSoundCodeScheduleResponseBody) *CreateSoundCodeScheduleResponse {
	s.Body = v
	return s
}

type CreateSpeechRequest struct {
	AudioFormat     *string                `json:"AudioFormat,omitempty" xml:"AudioFormat,omitempty"`
	BizCode         *string                `json:"BizCode,omitempty" xml:"BizCode,omitempty"`
	EnableSoundCode *bool                  `json:"EnableSoundCode,omitempty" xml:"EnableSoundCode,omitempty"`
	IotInstanceId   *string                `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProjectCode     *string                `json:"ProjectCode,omitempty" xml:"ProjectCode,omitempty"`
	SoundCodeConfig map[string]interface{} `json:"SoundCodeConfig,omitempty" xml:"SoundCodeConfig,omitempty"`
	SpeechRate      *int32                 `json:"SpeechRate,omitempty" xml:"SpeechRate,omitempty"`
	SpeechType      *string                `json:"SpeechType,omitempty" xml:"SpeechType,omitempty"`
	Text            *string                `json:"Text,omitempty" xml:"Text,omitempty"`
	Voice           *string                `json:"Voice,omitempty" xml:"Voice,omitempty"`
	Volume          *int32                 `json:"Volume,omitempty" xml:"Volume,omitempty"`
}

func (s CreateSpeechRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSpeechRequest) GoString() string {
	return s.String()
}

func (s *CreateSpeechRequest) SetAudioFormat(v string) *CreateSpeechRequest {
	s.AudioFormat = &v
	return s
}

func (s *CreateSpeechRequest) SetBizCode(v string) *CreateSpeechRequest {
	s.BizCode = &v
	return s
}

func (s *CreateSpeechRequest) SetEnableSoundCode(v bool) *CreateSpeechRequest {
	s.EnableSoundCode = &v
	return s
}

func (s *CreateSpeechRequest) SetIotInstanceId(v string) *CreateSpeechRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateSpeechRequest) SetProjectCode(v string) *CreateSpeechRequest {
	s.ProjectCode = &v
	return s
}

func (s *CreateSpeechRequest) SetSoundCodeConfig(v map[string]interface{}) *CreateSpeechRequest {
	s.SoundCodeConfig = v
	return s
}

func (s *CreateSpeechRequest) SetSpeechRate(v int32) *CreateSpeechRequest {
	s.SpeechRate = &v
	return s
}

func (s *CreateSpeechRequest) SetSpeechType(v string) *CreateSpeechRequest {
	s.SpeechType = &v
	return s
}

func (s *CreateSpeechRequest) SetText(v string) *CreateSpeechRequest {
	s.Text = &v
	return s
}

func (s *CreateSpeechRequest) SetVoice(v string) *CreateSpeechRequest {
	s.Voice = &v
	return s
}

func (s *CreateSpeechRequest) SetVolume(v int32) *CreateSpeechRequest {
	s.Volume = &v
	return s
}

type CreateSpeechShrinkRequest struct {
	AudioFormat           *string `json:"AudioFormat,omitempty" xml:"AudioFormat,omitempty"`
	BizCode               *string `json:"BizCode,omitempty" xml:"BizCode,omitempty"`
	EnableSoundCode       *bool   `json:"EnableSoundCode,omitempty" xml:"EnableSoundCode,omitempty"`
	IotInstanceId         *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProjectCode           *string `json:"ProjectCode,omitempty" xml:"ProjectCode,omitempty"`
	SoundCodeConfigShrink *string `json:"SoundCodeConfig,omitempty" xml:"SoundCodeConfig,omitempty"`
	SpeechRate            *int32  `json:"SpeechRate,omitempty" xml:"SpeechRate,omitempty"`
	SpeechType            *string `json:"SpeechType,omitempty" xml:"SpeechType,omitempty"`
	Text                  *string `json:"Text,omitempty" xml:"Text,omitempty"`
	Voice                 *string `json:"Voice,omitempty" xml:"Voice,omitempty"`
	Volume                *int32  `json:"Volume,omitempty" xml:"Volume,omitempty"`
}

func (s CreateSpeechShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSpeechShrinkRequest) GoString() string {
	return s.String()
}

func (s *CreateSpeechShrinkRequest) SetAudioFormat(v string) *CreateSpeechShrinkRequest {
	s.AudioFormat = &v
	return s
}

func (s *CreateSpeechShrinkRequest) SetBizCode(v string) *CreateSpeechShrinkRequest {
	s.BizCode = &v
	return s
}

func (s *CreateSpeechShrinkRequest) SetEnableSoundCode(v bool) *CreateSpeechShrinkRequest {
	s.EnableSoundCode = &v
	return s
}

func (s *CreateSpeechShrinkRequest) SetIotInstanceId(v string) *CreateSpeechShrinkRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateSpeechShrinkRequest) SetProjectCode(v string) *CreateSpeechShrinkRequest {
	s.ProjectCode = &v
	return s
}

func (s *CreateSpeechShrinkRequest) SetSoundCodeConfigShrink(v string) *CreateSpeechShrinkRequest {
	s.SoundCodeConfigShrink = &v
	return s
}

func (s *CreateSpeechShrinkRequest) SetSpeechRate(v int32) *CreateSpeechShrinkRequest {
	s.SpeechRate = &v
	return s
}

func (s *CreateSpeechShrinkRequest) SetSpeechType(v string) *CreateSpeechShrinkRequest {
	s.SpeechType = &v
	return s
}

func (s *CreateSpeechShrinkRequest) SetText(v string) *CreateSpeechShrinkRequest {
	s.Text = &v
	return s
}

func (s *CreateSpeechShrinkRequest) SetVoice(v string) *CreateSpeechShrinkRequest {
	s.Voice = &v
	return s
}

func (s *CreateSpeechShrinkRequest) SetVolume(v int32) *CreateSpeechShrinkRequest {
	s.Volume = &v
	return s
}

type CreateSpeechResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateSpeechResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSpeechResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSpeechResponseBody) SetCode(v string) *CreateSpeechResponseBody {
	s.Code = &v
	return s
}

func (s *CreateSpeechResponseBody) SetData(v string) *CreateSpeechResponseBody {
	s.Data = &v
	return s
}

func (s *CreateSpeechResponseBody) SetErrorMessage(v string) *CreateSpeechResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateSpeechResponseBody) SetRequestId(v string) *CreateSpeechResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSpeechResponseBody) SetSuccess(v bool) *CreateSpeechResponseBody {
	s.Success = &v
	return s
}

type CreateSpeechResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSpeechResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSpeechResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSpeechResponse) GoString() string {
	return s.String()
}

func (s *CreateSpeechResponse) SetHeaders(v map[string]*string) *CreateSpeechResponse {
	s.Headers = v
	return s
}

func (s *CreateSpeechResponse) SetStatusCode(v int32) *CreateSpeechResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSpeechResponse) SetBody(v *CreateSpeechResponseBody) *CreateSpeechResponse {
	s.Body = v
	return s
}

type CreateStudioAppDomainOpenRequest struct {
	AppId         *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	Host          *string `json:"Host,omitempty" xml:"Host,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProjectId     *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	Protocol      *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s CreateStudioAppDomainOpenRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateStudioAppDomainOpenRequest) GoString() string {
	return s.String()
}

func (s *CreateStudioAppDomainOpenRequest) SetAppId(v string) *CreateStudioAppDomainOpenRequest {
	s.AppId = &v
	return s
}

func (s *CreateStudioAppDomainOpenRequest) SetHost(v string) *CreateStudioAppDomainOpenRequest {
	s.Host = &v
	return s
}

func (s *CreateStudioAppDomainOpenRequest) SetIotInstanceId(v string) *CreateStudioAppDomainOpenRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateStudioAppDomainOpenRequest) SetProjectId(v string) *CreateStudioAppDomainOpenRequest {
	s.ProjectId = &v
	return s
}

func (s *CreateStudioAppDomainOpenRequest) SetProtocol(v string) *CreateStudioAppDomainOpenRequest {
	s.Protocol = &v
	return s
}

type CreateStudioAppDomainOpenResponseBody struct {
	Code         *string                                    `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *CreateStudioAppDomainOpenResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                    `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                      `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateStudioAppDomainOpenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateStudioAppDomainOpenResponseBody) GoString() string {
	return s.String()
}

func (s *CreateStudioAppDomainOpenResponseBody) SetCode(v string) *CreateStudioAppDomainOpenResponseBody {
	s.Code = &v
	return s
}

func (s *CreateStudioAppDomainOpenResponseBody) SetData(v *CreateStudioAppDomainOpenResponseBodyData) *CreateStudioAppDomainOpenResponseBody {
	s.Data = v
	return s
}

func (s *CreateStudioAppDomainOpenResponseBody) SetErrorMessage(v string) *CreateStudioAppDomainOpenResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateStudioAppDomainOpenResponseBody) SetRequestId(v string) *CreateStudioAppDomainOpenResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateStudioAppDomainOpenResponseBody) SetSuccess(v bool) *CreateStudioAppDomainOpenResponseBody {
	s.Success = &v
	return s
}

type CreateStudioAppDomainOpenResponseBodyData struct {
	AppId     *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	Host      *string `json:"Host,omitempty" xml:"Host,omitempty"`
	Id        *int32  `json:"Id,omitempty" xml:"Id,omitempty"`
	IsBeian   *string `json:"IsBeian,omitempty" xml:"IsBeian,omitempty"`
	ProjectId *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	Protocol  *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	TenantId  *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s CreateStudioAppDomainOpenResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s CreateStudioAppDomainOpenResponseBodyData) GoString() string {
	return s.String()
}

func (s *CreateStudioAppDomainOpenResponseBodyData) SetAppId(v string) *CreateStudioAppDomainOpenResponseBodyData {
	s.AppId = &v
	return s
}

func (s *CreateStudioAppDomainOpenResponseBodyData) SetHost(v string) *CreateStudioAppDomainOpenResponseBodyData {
	s.Host = &v
	return s
}

func (s *CreateStudioAppDomainOpenResponseBodyData) SetId(v int32) *CreateStudioAppDomainOpenResponseBodyData {
	s.Id = &v
	return s
}

func (s *CreateStudioAppDomainOpenResponseBodyData) SetIsBeian(v string) *CreateStudioAppDomainOpenResponseBodyData {
	s.IsBeian = &v
	return s
}

func (s *CreateStudioAppDomainOpenResponseBodyData) SetProjectId(v string) *CreateStudioAppDomainOpenResponseBodyData {
	s.ProjectId = &v
	return s
}

func (s *CreateStudioAppDomainOpenResponseBodyData) SetProtocol(v string) *CreateStudioAppDomainOpenResponseBodyData {
	s.Protocol = &v
	return s
}

func (s *CreateStudioAppDomainOpenResponseBodyData) SetTenantId(v string) *CreateStudioAppDomainOpenResponseBodyData {
	s.TenantId = &v
	return s
}

type CreateStudioAppDomainOpenResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateStudioAppDomainOpenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateStudioAppDomainOpenResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateStudioAppDomainOpenResponse) GoString() string {
	return s.String()
}

func (s *CreateStudioAppDomainOpenResponse) SetHeaders(v map[string]*string) *CreateStudioAppDomainOpenResponse {
	s.Headers = v
	return s
}

func (s *CreateStudioAppDomainOpenResponse) SetStatusCode(v int32) *CreateStudioAppDomainOpenResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateStudioAppDomainOpenResponse) SetBody(v *CreateStudioAppDomainOpenResponseBody) *CreateStudioAppDomainOpenResponse {
	s.Body = v
	return s
}

type CreateSubscribeRelationRequest struct {
	ConsumerGroupIds []*string `json:"ConsumerGroupIds,omitempty" xml:"ConsumerGroupIds,omitempty" type:"Repeated"`
	// Specifies whether to push upstream device messages. Valid values:
	//
	// *   **true**: yes.
	// *   **false**: no. This is the default value.
	DeviceDataFlag *bool `json:"DeviceDataFlag,omitempty" xml:"DeviceDataFlag,omitempty"`
	// Specifies whether to push messages about device lifecycle changes. Valid values:
	//
	// *   **true**: yes.
	// *   **false**: no. This is the default value.
	DeviceLifeCycleFlag *bool `json:"DeviceLifeCycleFlag,omitempty" xml:"DeviceLifeCycleFlag,omitempty"`
	// Specifies whether to push messages about device status changes. Valid values:
	//
	// *   **true**: yes.
	// *   **false**: no. This is the default value.
	DeviceStatusChangeFlag *bool `json:"DeviceStatusChangeFlag,omitempty" xml:"DeviceStatusChangeFlag,omitempty"`
	// Specifies whether to push messages about device tag changes. Valid values:
	//
	// *   **true**: yes. This parameter is valid only if you set the **Type** parameter to **AMQP**.
	// *   **false**: no. This is the default value.
	DeviceTagFlag *bool `json:"DeviceTagFlag,omitempty" xml:"DeviceTagFlag,omitempty"`
	// Specifies whether to push messages about topological relationship changes of devices. Valid values:
	//
	// *   **true**: yes. This parameter is valid only for gateway products.
	// *   **false**: no. This is the default value.
	DeviceTopoLifeCycleFlag *bool `json:"DeviceTopoLifeCycleFlag,omitempty" xml:"DeviceTopoLifeCycleFlag,omitempty"`
	// Specifies whether to push messages when a gateway detects new sub-devices. Valid values:
	//
	// *   **true**: yes. This parameter is valid only for gateway products.
	// *   **false**: no. This is the default value.
	FoundDeviceListFlag *bool `json:"FoundDeviceListFlag,omitempty" xml:"FoundDeviceListFlag,omitempty"`
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The configurations of the MNS queue. If you set the **Type** parameter to **AMQP**, this parameter is required.
	//
	// For more information, see the "Definition of the MnsConfiguration parameter" section.
	MnsConfiguration *string `json:"MnsConfiguration,omitempty" xml:"MnsConfiguration,omitempty"`
	// Specifies whether to push notifications about the status of over-the-air (OTA) update batches. Valid values:
	//
	// *   **true**: yes.
	// *   **false**: no. This is the default value.
	OtaEventFlag *bool `json:"OtaEventFlag,omitempty" xml:"OtaEventFlag,omitempty"`
	// Specifies whether to push notifications about the status of OTA update batches. Valid values:
	//
	// *   **true**: yes. This parameter is valid only if you set the **Type** parameter to **AMQP**.
	// *   **false**: no. This is the default value.
	OtaJobFlag *bool `json:"OtaJobFlag,omitempty" xml:"OtaJobFlag,omitempty"`
	// Specifies whether to push messages about the version numbers of OTA modules. Valid values:
	//
	// *   **true**: yes. This parameter is valid only if you set the **Type** parameter to **AMQP**.
	// *   **false**: no. This is the default value.
	OtaVersionFlag *bool `json:"OtaVersionFlag,omitempty" xml:"OtaVersionFlag,omitempty"`
	// The **ProductKey** of the product that is specified for the subscription.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// Specifies whether to receive the messages of a specific subscribed product.
	//
	// If you subscribe to JT/T 808 gateway products, you must configure the **SubscribeFlags** parameter. Set the value to the following code.
	//
	// ```
	//
	// {
	//     "jt808DeviceDataFlag": true
	// }
	// ```
	SubscribeFlags *string `json:"SubscribeFlags,omitempty" xml:"SubscribeFlags,omitempty"`
	// Specifies whether to push upstream historical Thing Specification Language (TSL) data. Valid values:
	//
	// *   **true**: yes.
	// *   **false**: no. This is the default value.
	ThingHistoryFlag *bool `json:"ThingHistoryFlag,omitempty" xml:"ThingHistoryFlag,omitempty"`
	// The type of the subscription. Valid values:
	//
	// *   **MNS**
	// *   **AMQP**
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s CreateSubscribeRelationRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateSubscribeRelationRequest) GoString() string {
	return s.String()
}

func (s *CreateSubscribeRelationRequest) SetConsumerGroupIds(v []*string) *CreateSubscribeRelationRequest {
	s.ConsumerGroupIds = v
	return s
}

func (s *CreateSubscribeRelationRequest) SetDeviceDataFlag(v bool) *CreateSubscribeRelationRequest {
	s.DeviceDataFlag = &v
	return s
}

func (s *CreateSubscribeRelationRequest) SetDeviceLifeCycleFlag(v bool) *CreateSubscribeRelationRequest {
	s.DeviceLifeCycleFlag = &v
	return s
}

func (s *CreateSubscribeRelationRequest) SetDeviceStatusChangeFlag(v bool) *CreateSubscribeRelationRequest {
	s.DeviceStatusChangeFlag = &v
	return s
}

func (s *CreateSubscribeRelationRequest) SetDeviceTagFlag(v bool) *CreateSubscribeRelationRequest {
	s.DeviceTagFlag = &v
	return s
}

func (s *CreateSubscribeRelationRequest) SetDeviceTopoLifeCycleFlag(v bool) *CreateSubscribeRelationRequest {
	s.DeviceTopoLifeCycleFlag = &v
	return s
}

func (s *CreateSubscribeRelationRequest) SetFoundDeviceListFlag(v bool) *CreateSubscribeRelationRequest {
	s.FoundDeviceListFlag = &v
	return s
}

func (s *CreateSubscribeRelationRequest) SetIotInstanceId(v string) *CreateSubscribeRelationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateSubscribeRelationRequest) SetMnsConfiguration(v string) *CreateSubscribeRelationRequest {
	s.MnsConfiguration = &v
	return s
}

func (s *CreateSubscribeRelationRequest) SetOtaEventFlag(v bool) *CreateSubscribeRelationRequest {
	s.OtaEventFlag = &v
	return s
}

func (s *CreateSubscribeRelationRequest) SetOtaJobFlag(v bool) *CreateSubscribeRelationRequest {
	s.OtaJobFlag = &v
	return s
}

func (s *CreateSubscribeRelationRequest) SetOtaVersionFlag(v bool) *CreateSubscribeRelationRequest {
	s.OtaVersionFlag = &v
	return s
}

func (s *CreateSubscribeRelationRequest) SetProductKey(v string) *CreateSubscribeRelationRequest {
	s.ProductKey = &v
	return s
}

func (s *CreateSubscribeRelationRequest) SetSubscribeFlags(v string) *CreateSubscribeRelationRequest {
	s.SubscribeFlags = &v
	return s
}

func (s *CreateSubscribeRelationRequest) SetThingHistoryFlag(v bool) *CreateSubscribeRelationRequest {
	s.ThingHistoryFlag = &v
	return s
}

func (s *CreateSubscribeRelationRequest) SetType(v string) *CreateSubscribeRelationRequest {
	s.Type = &v
	return s
}

type CreateSubscribeRelationResponseBody struct {
	// The error code that is returned if the call fails. For more information about error codes, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateSubscribeRelationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateSubscribeRelationResponseBody) GoString() string {
	return s.String()
}

func (s *CreateSubscribeRelationResponseBody) SetCode(v string) *CreateSubscribeRelationResponseBody {
	s.Code = &v
	return s
}

func (s *CreateSubscribeRelationResponseBody) SetErrorMessage(v string) *CreateSubscribeRelationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateSubscribeRelationResponseBody) SetRequestId(v string) *CreateSubscribeRelationResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateSubscribeRelationResponseBody) SetSuccess(v bool) *CreateSubscribeRelationResponseBody {
	s.Success = &v
	return s
}

type CreateSubscribeRelationResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateSubscribeRelationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateSubscribeRelationResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateSubscribeRelationResponse) GoString() string {
	return s.String()
}

func (s *CreateSubscribeRelationResponse) SetHeaders(v map[string]*string) *CreateSubscribeRelationResponse {
	s.Headers = v
	return s
}

func (s *CreateSubscribeRelationResponse) SetStatusCode(v int32) *CreateSubscribeRelationResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateSubscribeRelationResponse) SetBody(v *CreateSubscribeRelationResponseBody) *CreateSubscribeRelationResponse {
	s.Body = v
	return s
}

type CreateThingModelRequest struct {
	// The identifier of the custom TSL module. Each identifier is unique in a product. The identifier must be 1 to 30 characters in length, and can contain letters, digits, and underscores (\_).
	//
	// This parameter must be used in combination with the **FunctionBlockName** parameter. If you do not specify this parameter, the system imports the default module.
	FunctionBlockId *string `json:"FunctionBlockId,omitempty" xml:"FunctionBlockId,omitempty"`
	// The name of the custom module. The name must be 4 to 30 characters in length, and can contain letters, digits, and underscores (\_).
	//
	// This parameter must be used in combination with the **FunctionBlockId** parameter. If you do not specify this parameter, the system imports the default module.
	FunctionBlockName *string `json:"FunctionBlockName,omitempty" xml:"FunctionBlockName,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product.
	//
	// You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The details of the new features.
	//
	// >  You can specify a maximum of 10 features.
	//
	// Example:
	//
	// ```
	//
	// {
	//   "properties": [
	//     {
	//       "custom": true,
	//       "dataSpecsList": [
	//         {
	//           "childDataType": "TEXT",
	//           "childName": "CCID number of the device SIM card",
	//           "dataSpecs": {
	//             "custom": true,
	//             "dataType": "TEXT",
	//             "length": 20
	//           },
	//           "dataType": "STRUCT",
	//           "identifier": "CCID",
	//           "name": "CCID number of the device SIM card"
	//         },
	//         {
	//           "childDataType": "INT",
	//           "childName": "Battery power",
	//           "dataSpecs": {
	//             "custom": true,
	//             "dataType": "INT",
	//             "max": "60000",
	//             "min": "0",
	//             "step": "1"
	//           },
	//           "dataType": "STRUCT",
	//           "identifier": "battery",
	//           "name": "Battery power"
	//         },
	//         {
	//           "childDataType": "TEXT",
	//           "childName": "Other information",
	//           "dataSpecs": {
	//             "custom": true,
	//             "dataType": "TEXT",
	//             "length": 1024
	//           },
	//           "dataType": "STRUCT",
	//           "identifier": "other_info",
	//           "name": "Other information"
	//         }
	//       ],
	//       "dataType": "STRUCT",
	//       "identifier": "DEV_INFO",
	//       "name": "Device information",
	//       "productKey": "a1T***",
	//       "propertyId": 18786548,
	//       "required": false,
	//       "rwFlag": "READ_ONLY"
	//     },
	//     {
	//       "custom": true,
	//       "dataSpecs": {
	//         "childDataType": "INT",
	//         "custom": true,
	//         "dataType": "ARRAY",
	//         "size": 1,
	//         "dataSpecs": {
	//           "custom": true,
	//           "dataType": "INT",
	//           "max": "65535",
	//           "min": "0",
	//           "step": "1",
	//           "unit": "ppm",
	//           "unitName": "Parts per million"
	//         }
	//       },
	//       "dataType": "ARRAY",
	//       "identifier": "airRH_SR",
	//       "name": "Dehumidifier humidity",
	//       "productKey": "a1T***",
	//       "propertyId": 18786551,
	//       "required": false,
	//       "rwFlag": "READ_ONLY"
	//     }
	//   ],
	//   "services": [...],
	//   "events": [...]
	// }
	//
	// ```
	//
	// In the **properties** structure of the **ThingModelJson** parameter, you can use the **extendConfig** parameter to define the extended information of the TSL model. For more information, see [Data structure of ThingModelJson](~~150457~~).
	ThingModelJson *string `json:"ThingModelJson,omitempty" xml:"ThingModelJson,omitempty"`
}

func (s CreateThingModelRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateThingModelRequest) GoString() string {
	return s.String()
}

func (s *CreateThingModelRequest) SetFunctionBlockId(v string) *CreateThingModelRequest {
	s.FunctionBlockId = &v
	return s
}

func (s *CreateThingModelRequest) SetFunctionBlockName(v string) *CreateThingModelRequest {
	s.FunctionBlockName = &v
	return s
}

func (s *CreateThingModelRequest) SetIotInstanceId(v string) *CreateThingModelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateThingModelRequest) SetProductKey(v string) *CreateThingModelRequest {
	s.ProductKey = &v
	return s
}

func (s *CreateThingModelRequest) SetThingModelJson(v string) *CreateThingModelRequest {
	s.ThingModelJson = &v
	return s
}

type CreateThingModelResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateThingModelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateThingModelResponseBody) GoString() string {
	return s.String()
}

func (s *CreateThingModelResponseBody) SetCode(v string) *CreateThingModelResponseBody {
	s.Code = &v
	return s
}

func (s *CreateThingModelResponseBody) SetErrorMessage(v string) *CreateThingModelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateThingModelResponseBody) SetRequestId(v string) *CreateThingModelResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateThingModelResponseBody) SetSuccess(v bool) *CreateThingModelResponseBody {
	s.Success = &v
	return s
}

type CreateThingModelResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateThingModelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateThingModelResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateThingModelResponse) GoString() string {
	return s.String()
}

func (s *CreateThingModelResponse) SetHeaders(v map[string]*string) *CreateThingModelResponse {
	s.Headers = v
	return s
}

func (s *CreateThingModelResponse) SetStatusCode(v int32) *CreateThingModelResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateThingModelResponse) SetBody(v *CreateThingModelResponseBody) *CreateThingModelResponse {
	s.Body = v
	return s
}

type CreateThingScriptRequest struct {
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify this parameter. Otherwise, the call fails.
	// >*   If the **Overview** page does not appear in the console or no ID is generated for your instance, you do not need to specify this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product.
	//
	// You can view the **ProductKey** on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The content of the script. You must specify this parameter.
	//
	// For more information about script examples, see [What is data parsing](~~68702~~).
	ScriptContent *string `json:"ScriptContent,omitempty" xml:"ScriptContent,omitempty"`
	// The language of the script. Valid values:
	//
	// *   JavaScript
	// *   Python\_27: Python 2.7
	// *   PHP\_72: PHP 7.2
	ScriptType *string `json:"ScriptType,omitempty" xml:"ScriptType,omitempty"`
}

func (s CreateThingScriptRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateThingScriptRequest) GoString() string {
	return s.String()
}

func (s *CreateThingScriptRequest) SetIotInstanceId(v string) *CreateThingScriptRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateThingScriptRequest) SetProductKey(v string) *CreateThingScriptRequest {
	s.ProductKey = &v
	return s
}

func (s *CreateThingScriptRequest) SetScriptContent(v string) *CreateThingScriptRequest {
	s.ScriptContent = &v
	return s
}

func (s *CreateThingScriptRequest) SetScriptType(v string) *CreateThingScriptRequest {
	s.ScriptType = &v
	return s
}

type CreateThingScriptResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. The ID uniquely identifies this request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// *   **true**: The request was successful.
	// *   **false**: The request failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateThingScriptResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateThingScriptResponseBody) GoString() string {
	return s.String()
}

func (s *CreateThingScriptResponseBody) SetCode(v string) *CreateThingScriptResponseBody {
	s.Code = &v
	return s
}

func (s *CreateThingScriptResponseBody) SetErrorMessage(v string) *CreateThingScriptResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateThingScriptResponseBody) SetRequestId(v string) *CreateThingScriptResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateThingScriptResponseBody) SetSuccess(v bool) *CreateThingScriptResponseBody {
	s.Success = &v
	return s
}

type CreateThingScriptResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateThingScriptResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateThingScriptResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateThingScriptResponse) GoString() string {
	return s.String()
}

func (s *CreateThingScriptResponse) SetHeaders(v map[string]*string) *CreateThingScriptResponse {
	s.Headers = v
	return s
}

func (s *CreateThingScriptResponse) SetStatusCode(v int32) *CreateThingScriptResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateThingScriptResponse) SetBody(v *CreateThingScriptResponseBody) *CreateThingScriptResponse {
	s.Body = v
	return s
}

type CreateTopicConfigRequest struct {
	Codec                *string `json:"Codec,omitempty" xml:"Codec,omitempty"`
	Description          *string `json:"Description,omitempty" xml:"Description,omitempty"`
	EnableBroadcast      *bool   `json:"EnableBroadcast,omitempty" xml:"EnableBroadcast,omitempty"`
	EnableProxySubscribe *bool   `json:"EnableProxySubscribe,omitempty" xml:"EnableProxySubscribe,omitempty"`
	IotInstanceId        *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Operation            *string `json:"Operation,omitempty" xml:"Operation,omitempty"`
	ProductKey           *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	TopicFullName        *string `json:"TopicFullName,omitempty" xml:"TopicFullName,omitempty"`
}

func (s CreateTopicConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTopicConfigRequest) GoString() string {
	return s.String()
}

func (s *CreateTopicConfigRequest) SetCodec(v string) *CreateTopicConfigRequest {
	s.Codec = &v
	return s
}

func (s *CreateTopicConfigRequest) SetDescription(v string) *CreateTopicConfigRequest {
	s.Description = &v
	return s
}

func (s *CreateTopicConfigRequest) SetEnableBroadcast(v bool) *CreateTopicConfigRequest {
	s.EnableBroadcast = &v
	return s
}

func (s *CreateTopicConfigRequest) SetEnableProxySubscribe(v bool) *CreateTopicConfigRequest {
	s.EnableProxySubscribe = &v
	return s
}

func (s *CreateTopicConfigRequest) SetIotInstanceId(v string) *CreateTopicConfigRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateTopicConfigRequest) SetOperation(v string) *CreateTopicConfigRequest {
	s.Operation = &v
	return s
}

func (s *CreateTopicConfigRequest) SetProductKey(v string) *CreateTopicConfigRequest {
	s.ProductKey = &v
	return s
}

func (s *CreateTopicConfigRequest) SetTopicFullName(v string) *CreateTopicConfigRequest {
	s.TopicFullName = &v
	return s
}

type CreateTopicConfigResponseBody struct {
	Code      *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Message   *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateTopicConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTopicConfigResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTopicConfigResponseBody) SetCode(v string) *CreateTopicConfigResponseBody {
	s.Code = &v
	return s
}

func (s *CreateTopicConfigResponseBody) SetMessage(v string) *CreateTopicConfigResponseBody {
	s.Message = &v
	return s
}

func (s *CreateTopicConfigResponseBody) SetRequestId(v string) *CreateTopicConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTopicConfigResponseBody) SetSuccess(v bool) *CreateTopicConfigResponseBody {
	s.Success = &v
	return s
}

type CreateTopicConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTopicConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTopicConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTopicConfigResponse) GoString() string {
	return s.String()
}

func (s *CreateTopicConfigResponse) SetHeaders(v map[string]*string) *CreateTopicConfigResponse {
	s.Headers = v
	return s
}

func (s *CreateTopicConfigResponse) SetStatusCode(v int32) *CreateTopicConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTopicConfigResponse) SetBody(v *CreateTopicConfigResponseBody) *CreateTopicConfigResponse {
	s.Body = v
	return s
}

type CreateTopicRouteTableRequest struct {
	DstTopic []*string `json:"DstTopic,omitempty" xml:"DstTopic,omitempty" type:"Repeated"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The source topic. Example: `SrcTopic=/x7aWKW9 ****** /testDataToDataHub/user/update`.
	SrcTopic *string `json:"SrcTopic,omitempty" xml:"SrcTopic,omitempty"`
}

func (s CreateTopicRouteTableRequest) String() string {
	return tea.Prettify(s)
}

func (s CreateTopicRouteTableRequest) GoString() string {
	return s.String()
}

func (s *CreateTopicRouteTableRequest) SetDstTopic(v []*string) *CreateTopicRouteTableRequest {
	s.DstTopic = v
	return s
}

func (s *CreateTopicRouteTableRequest) SetIotInstanceId(v string) *CreateTopicRouteTableRequest {
	s.IotInstanceId = &v
	return s
}

func (s *CreateTopicRouteTableRequest) SetSrcTopic(v string) *CreateTopicRouteTableRequest {
	s.SrcTopic = &v
	return s
}

type CreateTopicRouteTableResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The list of topics returned if the call fails.
	FailureTopics *CreateTopicRouteTableResponseBodyFailureTopics `json:"FailureTopics,omitempty" xml:"FailureTopics,omitempty" type:"Struct"`
	// Indicates whether all the message routing relationships between topics are established.
	//
	// *   **true**: All the message routing relationships between topics are established.
	// *   **false**: Not all the message routing relationships between topics are established.
	IsAllSucceed *bool `json:"IsAllSucceed,omitempty" xml:"IsAllSucceed,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s CreateTopicRouteTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s CreateTopicRouteTableResponseBody) GoString() string {
	return s.String()
}

func (s *CreateTopicRouteTableResponseBody) SetCode(v string) *CreateTopicRouteTableResponseBody {
	s.Code = &v
	return s
}

func (s *CreateTopicRouteTableResponseBody) SetErrorMessage(v string) *CreateTopicRouteTableResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *CreateTopicRouteTableResponseBody) SetFailureTopics(v *CreateTopicRouteTableResponseBodyFailureTopics) *CreateTopicRouteTableResponseBody {
	s.FailureTopics = v
	return s
}

func (s *CreateTopicRouteTableResponseBody) SetIsAllSucceed(v bool) *CreateTopicRouteTableResponseBody {
	s.IsAllSucceed = &v
	return s
}

func (s *CreateTopicRouteTableResponseBody) SetRequestId(v string) *CreateTopicRouteTableResponseBody {
	s.RequestId = &v
	return s
}

func (s *CreateTopicRouteTableResponseBody) SetSuccess(v bool) *CreateTopicRouteTableResponseBody {
	s.Success = &v
	return s
}

type CreateTopicRouteTableResponseBodyFailureTopics struct {
	Topic []map[string]interface{} `json:"Topic,omitempty" xml:"Topic,omitempty" type:"Repeated"`
}

func (s CreateTopicRouteTableResponseBodyFailureTopics) String() string {
	return tea.Prettify(s)
}

func (s CreateTopicRouteTableResponseBodyFailureTopics) GoString() string {
	return s.String()
}

func (s *CreateTopicRouteTableResponseBodyFailureTopics) SetTopic(v []map[string]interface{}) *CreateTopicRouteTableResponseBodyFailureTopics {
	s.Topic = v
	return s
}

type CreateTopicRouteTableResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *CreateTopicRouteTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s CreateTopicRouteTableResponse) String() string {
	return tea.Prettify(s)
}

func (s CreateTopicRouteTableResponse) GoString() string {
	return s.String()
}

func (s *CreateTopicRouteTableResponse) SetHeaders(v map[string]*string) *CreateTopicRouteTableResponse {
	s.Headers = v
	return s
}

func (s *CreateTopicRouteTableResponse) SetStatusCode(v int32) *CreateTopicRouteTableResponse {
	s.StatusCode = &v
	return s
}

func (s *CreateTopicRouteTableResponse) SetBody(v *CreateTopicRouteTableResponseBody) *CreateTopicRouteTableResponse {
	s.Body = v
	return s
}

type DeleteClientIdsRequest struct {
	// The ID of the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s DeleteClientIdsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteClientIdsRequest) GoString() string {
	return s.String()
}

func (s *DeleteClientIdsRequest) SetIotId(v string) *DeleteClientIdsRequest {
	s.IotId = &v
	return s
}

func (s *DeleteClientIdsRequest) SetIotInstanceId(v string) *DeleteClientIdsRequest {
	s.IotInstanceId = &v
	return s
}

type DeleteClientIdsResponseBody struct {
	// The response code. The value Success indicates that the call was successful. Other values indicate that errors occurred. For more information about error codes, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteClientIdsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteClientIdsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteClientIdsResponseBody) SetCode(v string) *DeleteClientIdsResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteClientIdsResponseBody) SetErrorMessage(v string) *DeleteClientIdsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteClientIdsResponseBody) SetRequestId(v string) *DeleteClientIdsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteClientIdsResponseBody) SetSuccess(v bool) *DeleteClientIdsResponseBody {
	s.Success = &v
	return s
}

type DeleteClientIdsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteClientIdsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteClientIdsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteClientIdsResponse) GoString() string {
	return s.String()
}

func (s *DeleteClientIdsResponse) SetHeaders(v map[string]*string) *DeleteClientIdsResponse {
	s.Headers = v
	return s
}

func (s *DeleteClientIdsResponse) SetStatusCode(v int32) *DeleteClientIdsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteClientIdsResponse) SetBody(v *DeleteClientIdsResponseBody) *DeleteClientIdsResponse {
	s.Body = v
	return s
}

type DeleteConsumerGroupRequest struct {
	// The ID of the consumer group. After you call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group, the consumer group ID is returned. You can call the [QueryConsumerGroupList](~~170419~~) operation to query the consumer group ID by group name. You can also go to the IoT Platform console,and choose **Rules** > **Server-side Subscription** > **Consumer Groups** to view the consumer group ID.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s DeleteConsumerGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteConsumerGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteConsumerGroupRequest) SetGroupId(v string) *DeleteConsumerGroupRequest {
	s.GroupId = &v
	return s
}

func (s *DeleteConsumerGroupRequest) SetIotInstanceId(v string) *DeleteConsumerGroupRequest {
	s.IotInstanceId = &v
	return s
}

type DeleteConsumerGroupResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteConsumerGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteConsumerGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteConsumerGroupResponseBody) SetCode(v string) *DeleteConsumerGroupResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteConsumerGroupResponseBody) SetErrorMessage(v string) *DeleteConsumerGroupResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteConsumerGroupResponseBody) SetRequestId(v string) *DeleteConsumerGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteConsumerGroupResponseBody) SetSuccess(v bool) *DeleteConsumerGroupResponseBody {
	s.Success = &v
	return s
}

type DeleteConsumerGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteConsumerGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteConsumerGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteConsumerGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteConsumerGroupResponse) SetHeaders(v map[string]*string) *DeleteConsumerGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteConsumerGroupResponse) SetStatusCode(v int32) *DeleteConsumerGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteConsumerGroupResponse) SetBody(v *DeleteConsumerGroupResponseBody) *DeleteConsumerGroupResponse {
	s.Body = v
	return s
}

type DeleteConsumerGroupSubscribeRelationRequest struct {
	// The ID of the consumer group. You can call the [QuerySubscribeRelation](~~170352~~) operation to query the consumer group ID in an AMQP subscription. You can also go to the IoT Platform console,and choose **Rules** > **Server-side Subscription** to view the consumer group ID.
	ConsumerGroupId *string `json:"ConsumerGroupId,omitempty" xml:"ConsumerGroupId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product that is specified for the subscription.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s DeleteConsumerGroupSubscribeRelationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteConsumerGroupSubscribeRelationRequest) GoString() string {
	return s.String()
}

func (s *DeleteConsumerGroupSubscribeRelationRequest) SetConsumerGroupId(v string) *DeleteConsumerGroupSubscribeRelationRequest {
	s.ConsumerGroupId = &v
	return s
}

func (s *DeleteConsumerGroupSubscribeRelationRequest) SetIotInstanceId(v string) *DeleteConsumerGroupSubscribeRelationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteConsumerGroupSubscribeRelationRequest) SetProductKey(v string) *DeleteConsumerGroupSubscribeRelationRequest {
	s.ProductKey = &v
	return s
}

type DeleteConsumerGroupSubscribeRelationResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteConsumerGroupSubscribeRelationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteConsumerGroupSubscribeRelationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteConsumerGroupSubscribeRelationResponseBody) SetCode(v string) *DeleteConsumerGroupSubscribeRelationResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteConsumerGroupSubscribeRelationResponseBody) SetErrorMessage(v string) *DeleteConsumerGroupSubscribeRelationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteConsumerGroupSubscribeRelationResponseBody) SetRequestId(v string) *DeleteConsumerGroupSubscribeRelationResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteConsumerGroupSubscribeRelationResponseBody) SetSuccess(v bool) *DeleteConsumerGroupSubscribeRelationResponseBody {
	s.Success = &v
	return s
}

type DeleteConsumerGroupSubscribeRelationResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteConsumerGroupSubscribeRelationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteConsumerGroupSubscribeRelationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteConsumerGroupSubscribeRelationResponse) GoString() string {
	return s.String()
}

func (s *DeleteConsumerGroupSubscribeRelationResponse) SetHeaders(v map[string]*string) *DeleteConsumerGroupSubscribeRelationResponse {
	s.Headers = v
	return s
}

func (s *DeleteConsumerGroupSubscribeRelationResponse) SetStatusCode(v int32) *DeleteConsumerGroupSubscribeRelationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteConsumerGroupSubscribeRelationResponse) SetBody(v *DeleteConsumerGroupSubscribeRelationResponseBody) *DeleteConsumerGroupSubscribeRelationResponse {
	s.Body = v
	return s
}

type DeleteDataSourceItemRequest struct {
	DataSourceId     *int64  `json:"DataSourceId,omitempty" xml:"DataSourceId,omitempty"`
	DataSourceItemId *int64  `json:"DataSourceItemId,omitempty" xml:"DataSourceItemId,omitempty"`
	IotInstanceId    *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s DeleteDataSourceItemRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataSourceItemRequest) GoString() string {
	return s.String()
}

func (s *DeleteDataSourceItemRequest) SetDataSourceId(v int64) *DeleteDataSourceItemRequest {
	s.DataSourceId = &v
	return s
}

func (s *DeleteDataSourceItemRequest) SetDataSourceItemId(v int64) *DeleteDataSourceItemRequest {
	s.DataSourceItemId = &v
	return s
}

func (s *DeleteDataSourceItemRequest) SetIotInstanceId(v string) *DeleteDataSourceItemRequest {
	s.IotInstanceId = &v
	return s
}

type DeleteDataSourceItemResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteDataSourceItemResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataSourceItemResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDataSourceItemResponseBody) SetCode(v string) *DeleteDataSourceItemResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteDataSourceItemResponseBody) SetErrorMessage(v string) *DeleteDataSourceItemResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteDataSourceItemResponseBody) SetRequestId(v string) *DeleteDataSourceItemResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDataSourceItemResponseBody) SetSuccess(v bool) *DeleteDataSourceItemResponseBody {
	s.Success = &v
	return s
}

type DeleteDataSourceItemResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDataSourceItemResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDataSourceItemResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDataSourceItemResponse) GoString() string {
	return s.String()
}

func (s *DeleteDataSourceItemResponse) SetHeaders(v map[string]*string) *DeleteDataSourceItemResponse {
	s.Headers = v
	return s
}

func (s *DeleteDataSourceItemResponse) SetStatusCode(v int32) *DeleteDataSourceItemResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDataSourceItemResponse) SetBody(v *DeleteDataSourceItemResponseBody) *DeleteDataSourceItemResponse {
	s.Body = v
	return s
}

type DeleteDestinationRequest struct {
	DestinationId *int64  `json:"DestinationId,omitempty" xml:"DestinationId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s DeleteDestinationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDestinationRequest) GoString() string {
	return s.String()
}

func (s *DeleteDestinationRequest) SetDestinationId(v int64) *DeleteDestinationRequest {
	s.DestinationId = &v
	return s
}

func (s *DeleteDestinationRequest) SetIotInstanceId(v string) *DeleteDestinationRequest {
	s.IotInstanceId = &v
	return s
}

type DeleteDestinationResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteDestinationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDestinationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDestinationResponseBody) SetCode(v string) *DeleteDestinationResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteDestinationResponseBody) SetErrorMessage(v string) *DeleteDestinationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteDestinationResponseBody) SetRequestId(v string) *DeleteDestinationResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDestinationResponseBody) SetSuccess(v bool) *DeleteDestinationResponseBody {
	s.Success = &v
	return s
}

type DeleteDestinationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDestinationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDestinationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDestinationResponse) GoString() string {
	return s.String()
}

func (s *DeleteDestinationResponse) SetHeaders(v map[string]*string) *DeleteDestinationResponse {
	s.Headers = v
	return s
}

func (s *DeleteDestinationResponse) SetStatusCode(v int32) *DeleteDestinationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDestinationResponse) SetBody(v *DeleteDestinationResponseBody) *DeleteDestinationResponse {
	s.Body = v
	return s
}

type DeleteDeviceRequest struct {
	// The DeviceName of the device.
	//
	//
	// > If you configure this parameter, you must specify a value for the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device.
	//
	//
	//
	// **Important** The IotId parameter specifies a globally unique identifier (GUID) for the device. The value of the **IotId** parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for this parameter, you do not need to configure the **ProductKey** or **DeviceName** parameter. If you specify values for the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
	//
	//
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	//
	//
	//
	// > If you configure this parameter, you must specify a value for the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s DeleteDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceRequest) GoString() string {
	return s.String()
}

func (s *DeleteDeviceRequest) SetDeviceName(v string) *DeleteDeviceRequest {
	s.DeviceName = &v
	return s
}

func (s *DeleteDeviceRequest) SetIotId(v string) *DeleteDeviceRequest {
	s.IotId = &v
	return s
}

func (s *DeleteDeviceRequest) SetIotInstanceId(v string) *DeleteDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteDeviceRequest) SetProductKey(v string) *DeleteDeviceRequest {
	s.ProductKey = &v
	return s
}

type DeleteDeviceResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDeviceResponseBody) SetCode(v string) *DeleteDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteDeviceResponseBody) SetErrorMessage(v string) *DeleteDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteDeviceResponseBody) SetRequestId(v string) *DeleteDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDeviceResponseBody) SetSuccess(v bool) *DeleteDeviceResponseBody {
	s.Success = &v
	return s
}

type DeleteDeviceResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceResponse) GoString() string {
	return s.String()
}

func (s *DeleteDeviceResponse) SetHeaders(v map[string]*string) *DeleteDeviceResponse {
	s.Headers = v
	return s
}

func (s *DeleteDeviceResponse) SetStatusCode(v int32) *DeleteDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDeviceResponse) SetBody(v *DeleteDeviceResponseBody) *DeleteDeviceResponse {
	s.Body = v
	return s
}

type DeleteDeviceDistributeJobRequest struct {
	// The ID of the distribution task. The ID globally identifies the task.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s DeleteDeviceDistributeJobRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceDistributeJobRequest) GoString() string {
	return s.String()
}

func (s *DeleteDeviceDistributeJobRequest) SetJobId(v string) *DeleteDeviceDistributeJobRequest {
	s.JobId = &v
	return s
}

type DeleteDeviceDistributeJobResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteDeviceDistributeJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceDistributeJobResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDeviceDistributeJobResponseBody) SetCode(v string) *DeleteDeviceDistributeJobResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteDeviceDistributeJobResponseBody) SetErrorMessage(v string) *DeleteDeviceDistributeJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteDeviceDistributeJobResponseBody) SetRequestId(v string) *DeleteDeviceDistributeJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDeviceDistributeJobResponseBody) SetSuccess(v bool) *DeleteDeviceDistributeJobResponseBody {
	s.Success = &v
	return s
}

type DeleteDeviceDistributeJobResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDeviceDistributeJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDeviceDistributeJobResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceDistributeJobResponse) GoString() string {
	return s.String()
}

func (s *DeleteDeviceDistributeJobResponse) SetHeaders(v map[string]*string) *DeleteDeviceDistributeJobResponse {
	s.Headers = v
	return s
}

func (s *DeleteDeviceDistributeJobResponse) SetStatusCode(v int32) *DeleteDeviceDistributeJobResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDeviceDistributeJobResponse) SetBody(v *DeleteDeviceDistributeJobResponseBody) *DeleteDeviceDistributeJobResponse {
	s.Body = v
	return s
}

type DeleteDeviceDynamicGroupRequest struct {
	GroupId       *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s DeleteDeviceDynamicGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceDynamicGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteDeviceDynamicGroupRequest) SetGroupId(v string) *DeleteDeviceDynamicGroupRequest {
	s.GroupId = &v
	return s
}

func (s *DeleteDeviceDynamicGroupRequest) SetIotInstanceId(v string) *DeleteDeviceDynamicGroupRequest {
	s.IotInstanceId = &v
	return s
}

type DeleteDeviceDynamicGroupResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteDeviceDynamicGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceDynamicGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDeviceDynamicGroupResponseBody) SetCode(v string) *DeleteDeviceDynamicGroupResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteDeviceDynamicGroupResponseBody) SetErrorMessage(v string) *DeleteDeviceDynamicGroupResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteDeviceDynamicGroupResponseBody) SetRequestId(v string) *DeleteDeviceDynamicGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDeviceDynamicGroupResponseBody) SetSuccess(v bool) *DeleteDeviceDynamicGroupResponseBody {
	s.Success = &v
	return s
}

type DeleteDeviceDynamicGroupResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDeviceDynamicGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDeviceDynamicGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceDynamicGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteDeviceDynamicGroupResponse) SetHeaders(v map[string]*string) *DeleteDeviceDynamicGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteDeviceDynamicGroupResponse) SetStatusCode(v int32) *DeleteDeviceDynamicGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDeviceDynamicGroupResponse) SetBody(v *DeleteDeviceDynamicGroupResponseBody) *DeleteDeviceDynamicGroupResponse {
	s.Body = v
	return s
}

type DeleteDeviceFileRequest struct {
	// The name of the device.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the file. You can call the [QueryDeviceFileList](~~112001~~) operation and view the file ID in the response.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s DeleteDeviceFileRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceFileRequest) GoString() string {
	return s.String()
}

func (s *DeleteDeviceFileRequest) SetDeviceName(v string) *DeleteDeviceFileRequest {
	s.DeviceName = &v
	return s
}

func (s *DeleteDeviceFileRequest) SetFileId(v string) *DeleteDeviceFileRequest {
	s.FileId = &v
	return s
}

func (s *DeleteDeviceFileRequest) SetIotId(v string) *DeleteDeviceFileRequest {
	s.IotId = &v
	return s
}

func (s *DeleteDeviceFileRequest) SetIotInstanceId(v string) *DeleteDeviceFileRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteDeviceFileRequest) SetProductKey(v string) *DeleteDeviceFileRequest {
	s.ProductKey = &v
	return s
}

type DeleteDeviceFileResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteDeviceFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceFileResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDeviceFileResponseBody) SetCode(v string) *DeleteDeviceFileResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteDeviceFileResponseBody) SetErrorMessage(v string) *DeleteDeviceFileResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteDeviceFileResponseBody) SetRequestId(v string) *DeleteDeviceFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDeviceFileResponseBody) SetSuccess(v bool) *DeleteDeviceFileResponseBody {
	s.Success = &v
	return s
}

type DeleteDeviceFileResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDeviceFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDeviceFileResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceFileResponse) GoString() string {
	return s.String()
}

func (s *DeleteDeviceFileResponse) SetHeaders(v map[string]*string) *DeleteDeviceFileResponse {
	s.Headers = v
	return s
}

func (s *DeleteDeviceFileResponse) SetStatusCode(v int32) *DeleteDeviceFileResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDeviceFileResponse) SetBody(v *DeleteDeviceFileResponseBody) *DeleteDeviceFileResponse {
	s.Body = v
	return s
}

type DeleteDeviceGroupRequest struct {
	// The ID of the group. The ID is the globally unique identifier (GUID) for the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s DeleteDeviceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceGroupRequest) GoString() string {
	return s.String()
}

func (s *DeleteDeviceGroupRequest) SetGroupId(v string) *DeleteDeviceGroupRequest {
	s.GroupId = &v
	return s
}

func (s *DeleteDeviceGroupRequest) SetIotInstanceId(v string) *DeleteDeviceGroupRequest {
	s.IotInstanceId = &v
	return s
}

type DeleteDeviceGroupResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteDeviceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDeviceGroupResponseBody) SetCode(v string) *DeleteDeviceGroupResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteDeviceGroupResponseBody) SetErrorMessage(v string) *DeleteDeviceGroupResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteDeviceGroupResponseBody) SetRequestId(v string) *DeleteDeviceGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDeviceGroupResponseBody) SetSuccess(v bool) *DeleteDeviceGroupResponseBody {
	s.Success = &v
	return s
}

type DeleteDeviceGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDeviceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDeviceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceGroupResponse) GoString() string {
	return s.String()
}

func (s *DeleteDeviceGroupResponse) SetHeaders(v map[string]*string) *DeleteDeviceGroupResponse {
	s.Headers = v
	return s
}

func (s *DeleteDeviceGroupResponse) SetStatusCode(v int32) *DeleteDeviceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDeviceGroupResponse) SetBody(v *DeleteDeviceGroupResponseBody) *DeleteDeviceGroupResponse {
	s.Body = v
	return s
}

type DeleteDevicePropRequest struct {
	// The name of the device.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device.
	//
	// >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The key of the tag.
	//
	// >  IoT Platform searches for the specified tag key and then deletes the tag. If no result is found, no operation is performed.
	PropKey *string `json:"PropKey,omitempty" xml:"PropKey,omitempty"`
}

func (s DeleteDevicePropRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDevicePropRequest) GoString() string {
	return s.String()
}

func (s *DeleteDevicePropRequest) SetDeviceName(v string) *DeleteDevicePropRequest {
	s.DeviceName = &v
	return s
}

func (s *DeleteDevicePropRequest) SetIotId(v string) *DeleteDevicePropRequest {
	s.IotId = &v
	return s
}

func (s *DeleteDevicePropRequest) SetIotInstanceId(v string) *DeleteDevicePropRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteDevicePropRequest) SetProductKey(v string) *DeleteDevicePropRequest {
	s.ProductKey = &v
	return s
}

func (s *DeleteDevicePropRequest) SetPropKey(v string) *DeleteDevicePropRequest {
	s.PropKey = &v
	return s
}

type DeleteDevicePropResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteDevicePropResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDevicePropResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDevicePropResponseBody) SetCode(v string) *DeleteDevicePropResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteDevicePropResponseBody) SetErrorMessage(v string) *DeleteDevicePropResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteDevicePropResponseBody) SetRequestId(v string) *DeleteDevicePropResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDevicePropResponseBody) SetSuccess(v bool) *DeleteDevicePropResponseBody {
	s.Success = &v
	return s
}

type DeleteDevicePropResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDevicePropResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDevicePropResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDevicePropResponse) GoString() string {
	return s.String()
}

func (s *DeleteDevicePropResponse) SetHeaders(v map[string]*string) *DeleteDevicePropResponse {
	s.Headers = v
	return s
}

func (s *DeleteDevicePropResponse) SetStatusCode(v int32) *DeleteDevicePropResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDevicePropResponse) SetBody(v *DeleteDevicePropResponseBody) *DeleteDevicePropResponse {
	s.Body = v
	return s
}

type DeleteDeviceSpeechRequest struct {
	DeviceSpeechList []*DeleteDeviceSpeechRequestDeviceSpeechList `json:"DeviceSpeechList,omitempty" xml:"DeviceSpeechList,omitempty" type:"Repeated"`
	IotId            *string                                      `json:"IotId,omitempty" xml:"IotId,omitempty"`
	IotInstanceId    *string                                      `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s DeleteDeviceSpeechRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceSpeechRequest) GoString() string {
	return s.String()
}

func (s *DeleteDeviceSpeechRequest) SetDeviceSpeechList(v []*DeleteDeviceSpeechRequestDeviceSpeechList) *DeleteDeviceSpeechRequest {
	s.DeviceSpeechList = v
	return s
}

func (s *DeleteDeviceSpeechRequest) SetIotId(v string) *DeleteDeviceSpeechRequest {
	s.IotId = &v
	return s
}

func (s *DeleteDeviceSpeechRequest) SetIotInstanceId(v string) *DeleteDeviceSpeechRequest {
	s.IotInstanceId = &v
	return s
}

type DeleteDeviceSpeechRequestDeviceSpeechList struct {
	AudioFormat *string `json:"AudioFormat,omitempty" xml:"AudioFormat,omitempty"`
	BizCode     *string `json:"BizCode,omitempty" xml:"BizCode,omitempty"`
}

func (s DeleteDeviceSpeechRequestDeviceSpeechList) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceSpeechRequestDeviceSpeechList) GoString() string {
	return s.String()
}

func (s *DeleteDeviceSpeechRequestDeviceSpeechList) SetAudioFormat(v string) *DeleteDeviceSpeechRequestDeviceSpeechList {
	s.AudioFormat = &v
	return s
}

func (s *DeleteDeviceSpeechRequestDeviceSpeechList) SetBizCode(v string) *DeleteDeviceSpeechRequestDeviceSpeechList {
	s.BizCode = &v
	return s
}

type DeleteDeviceSpeechResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteDeviceSpeechResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceSpeechResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDeviceSpeechResponseBody) SetCode(v string) *DeleteDeviceSpeechResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteDeviceSpeechResponseBody) SetErrorMessage(v string) *DeleteDeviceSpeechResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteDeviceSpeechResponseBody) SetRequestId(v string) *DeleteDeviceSpeechResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDeviceSpeechResponseBody) SetSuccess(v bool) *DeleteDeviceSpeechResponseBody {
	s.Success = &v
	return s
}

type DeleteDeviceSpeechResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDeviceSpeechResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDeviceSpeechResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceSpeechResponse) GoString() string {
	return s.String()
}

func (s *DeleteDeviceSpeechResponse) SetHeaders(v map[string]*string) *DeleteDeviceSpeechResponse {
	s.Headers = v
	return s
}

func (s *DeleteDeviceSpeechResponse) SetStatusCode(v int32) *DeleteDeviceSpeechResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDeviceSpeechResponse) SetBody(v *DeleteDeviceSpeechResponseBody) *DeleteDeviceSpeechResponse {
	s.Body = v
	return s
}

type DeleteDeviceTunnelRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	TunnelId      *string `json:"TunnelId,omitempty" xml:"TunnelId,omitempty"`
}

func (s DeleteDeviceTunnelRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceTunnelRequest) GoString() string {
	return s.String()
}

func (s *DeleteDeviceTunnelRequest) SetIotInstanceId(v string) *DeleteDeviceTunnelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteDeviceTunnelRequest) SetTunnelId(v string) *DeleteDeviceTunnelRequest {
	s.TunnelId = &v
	return s
}

type DeleteDeviceTunnelResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteDeviceTunnelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceTunnelResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteDeviceTunnelResponseBody) SetCode(v string) *DeleteDeviceTunnelResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteDeviceTunnelResponseBody) SetErrorMessage(v string) *DeleteDeviceTunnelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteDeviceTunnelResponseBody) SetRequestId(v string) *DeleteDeviceTunnelResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteDeviceTunnelResponseBody) SetSuccess(v bool) *DeleteDeviceTunnelResponseBody {
	s.Success = &v
	return s
}

type DeleteDeviceTunnelResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteDeviceTunnelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteDeviceTunnelResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteDeviceTunnelResponse) GoString() string {
	return s.String()
}

func (s *DeleteDeviceTunnelResponse) SetHeaders(v map[string]*string) *DeleteDeviceTunnelResponse {
	s.Headers = v
	return s
}

func (s *DeleteDeviceTunnelResponse) SetStatusCode(v int32) *DeleteDeviceTunnelResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteDeviceTunnelResponse) SetBody(v *DeleteDeviceTunnelResponseBody) *DeleteDeviceTunnelResponse {
	s.Body = v
	return s
}

type DeleteEdgeDriverRequest struct {
	// The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver that you want to delete and obtain the driver ID.
	//
	// You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s DeleteEdgeDriverRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEdgeDriverRequest) GoString() string {
	return s.String()
}

func (s *DeleteEdgeDriverRequest) SetDriverId(v string) *DeleteEdgeDriverRequest {
	s.DriverId = &v
	return s
}

func (s *DeleteEdgeDriverRequest) SetIotInstanceId(v string) *DeleteEdgeDriverRequest {
	s.IotInstanceId = &v
	return s
}

type DeleteEdgeDriverResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteEdgeDriverResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEdgeDriverResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEdgeDriverResponseBody) SetCode(v string) *DeleteEdgeDriverResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteEdgeDriverResponseBody) SetErrorMessage(v string) *DeleteEdgeDriverResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteEdgeDriverResponseBody) SetRequestId(v string) *DeleteEdgeDriverResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteEdgeDriverResponseBody) SetSuccess(v bool) *DeleteEdgeDriverResponseBody {
	s.Success = &v
	return s
}

type DeleteEdgeDriverResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEdgeDriverResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEdgeDriverResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEdgeDriverResponse) GoString() string {
	return s.String()
}

func (s *DeleteEdgeDriverResponse) SetHeaders(v map[string]*string) *DeleteEdgeDriverResponse {
	s.Headers = v
	return s
}

func (s *DeleteEdgeDriverResponse) SetStatusCode(v int32) *DeleteEdgeDriverResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEdgeDriverResponse) SetBody(v *DeleteEdgeDriverResponseBody) *DeleteEdgeDriverResponse {
	s.Body = v
	return s
}

type DeleteEdgeDriverVersionRequest struct {
	// The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver for which you want to delete a driver version and obtain the driver ID.
	//
	// You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The version number of the driver.
	DriverVersion *string `json:"DriverVersion,omitempty" xml:"DriverVersion,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s DeleteEdgeDriverVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEdgeDriverVersionRequest) GoString() string {
	return s.String()
}

func (s *DeleteEdgeDriverVersionRequest) SetDriverId(v string) *DeleteEdgeDriverVersionRequest {
	s.DriverId = &v
	return s
}

func (s *DeleteEdgeDriverVersionRequest) SetDriverVersion(v string) *DeleteEdgeDriverVersionRequest {
	s.DriverVersion = &v
	return s
}

func (s *DeleteEdgeDriverVersionRequest) SetIotInstanceId(v string) *DeleteEdgeDriverVersionRequest {
	s.IotInstanceId = &v
	return s
}

type DeleteEdgeDriverVersionResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteEdgeDriverVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEdgeDriverVersionResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEdgeDriverVersionResponseBody) SetCode(v string) *DeleteEdgeDriverVersionResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteEdgeDriverVersionResponseBody) SetErrorMessage(v string) *DeleteEdgeDriverVersionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteEdgeDriverVersionResponseBody) SetRequestId(v string) *DeleteEdgeDriverVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteEdgeDriverVersionResponseBody) SetSuccess(v bool) *DeleteEdgeDriverVersionResponseBody {
	s.Success = &v
	return s
}

type DeleteEdgeDriverVersionResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEdgeDriverVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEdgeDriverVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEdgeDriverVersionResponse) GoString() string {
	return s.String()
}

func (s *DeleteEdgeDriverVersionResponse) SetHeaders(v map[string]*string) *DeleteEdgeDriverVersionResponse {
	s.Headers = v
	return s
}

func (s *DeleteEdgeDriverVersionResponse) SetStatusCode(v int32) *DeleteEdgeDriverVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEdgeDriverVersionResponse) SetBody(v *DeleteEdgeDriverVersionResponseBody) *DeleteEdgeDriverVersionResponse {
	s.Body = v
	return s
}

type DeleteEdgeInstanceRequest struct {
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to delete and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s DeleteEdgeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEdgeInstanceRequest) GoString() string {
	return s.String()
}

func (s *DeleteEdgeInstanceRequest) SetInstanceId(v string) *DeleteEdgeInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *DeleteEdgeInstanceRequest) SetIotInstanceId(v string) *DeleteEdgeInstanceRequest {
	s.IotInstanceId = &v
	return s
}

type DeleteEdgeInstanceResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteEdgeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEdgeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEdgeInstanceResponseBody) SetCode(v string) *DeleteEdgeInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteEdgeInstanceResponseBody) SetErrorMessage(v string) *DeleteEdgeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteEdgeInstanceResponseBody) SetRequestId(v string) *DeleteEdgeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteEdgeInstanceResponseBody) SetSuccess(v bool) *DeleteEdgeInstanceResponseBody {
	s.Success = &v
	return s
}

type DeleteEdgeInstanceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEdgeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEdgeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEdgeInstanceResponse) GoString() string {
	return s.String()
}

func (s *DeleteEdgeInstanceResponse) SetHeaders(v map[string]*string) *DeleteEdgeInstanceResponse {
	s.Headers = v
	return s
}

func (s *DeleteEdgeInstanceResponse) SetStatusCode(v int32) *DeleteEdgeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEdgeInstanceResponse) SetBody(v *DeleteEdgeInstanceResponseBody) *DeleteEdgeInstanceResponse {
	s.Body = v
	return s
}

type DeleteEdgeInstanceMessageRoutingRequest struct {
	InstanceId    *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	RouteId       *int64  `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
}

func (s DeleteEdgeInstanceMessageRoutingRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteEdgeInstanceMessageRoutingRequest) GoString() string {
	return s.String()
}

func (s *DeleteEdgeInstanceMessageRoutingRequest) SetInstanceId(v string) *DeleteEdgeInstanceMessageRoutingRequest {
	s.InstanceId = &v
	return s
}

func (s *DeleteEdgeInstanceMessageRoutingRequest) SetIotInstanceId(v string) *DeleteEdgeInstanceMessageRoutingRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteEdgeInstanceMessageRoutingRequest) SetRouteId(v int64) *DeleteEdgeInstanceMessageRoutingRequest {
	s.RouteId = &v
	return s
}

type DeleteEdgeInstanceMessageRoutingResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteEdgeInstanceMessageRoutingResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteEdgeInstanceMessageRoutingResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteEdgeInstanceMessageRoutingResponseBody) SetCode(v string) *DeleteEdgeInstanceMessageRoutingResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteEdgeInstanceMessageRoutingResponseBody) SetErrorMessage(v string) *DeleteEdgeInstanceMessageRoutingResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteEdgeInstanceMessageRoutingResponseBody) SetRequestId(v string) *DeleteEdgeInstanceMessageRoutingResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteEdgeInstanceMessageRoutingResponseBody) SetSuccess(v bool) *DeleteEdgeInstanceMessageRoutingResponseBody {
	s.Success = &v
	return s
}

type DeleteEdgeInstanceMessageRoutingResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteEdgeInstanceMessageRoutingResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteEdgeInstanceMessageRoutingResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteEdgeInstanceMessageRoutingResponse) GoString() string {
	return s.String()
}

func (s *DeleteEdgeInstanceMessageRoutingResponse) SetHeaders(v map[string]*string) *DeleteEdgeInstanceMessageRoutingResponse {
	s.Headers = v
	return s
}

func (s *DeleteEdgeInstanceMessageRoutingResponse) SetStatusCode(v int32) *DeleteEdgeInstanceMessageRoutingResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteEdgeInstanceMessageRoutingResponse) SetBody(v *DeleteEdgeInstanceMessageRoutingResponseBody) *DeleteEdgeInstanceMessageRoutingResponse {
	s.Body = v
	return s
}

type DeleteJobRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	JobId         *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s DeleteJobRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteJobRequest) GoString() string {
	return s.String()
}

func (s *DeleteJobRequest) SetIotInstanceId(v string) *DeleteJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteJobRequest) SetJobId(v string) *DeleteJobRequest {
	s.JobId = &v
	return s
}

type DeleteJobResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteJobResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteJobResponseBody) SetCode(v string) *DeleteJobResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteJobResponseBody) SetErrorMessage(v string) *DeleteJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteJobResponseBody) SetRequestId(v string) *DeleteJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteJobResponseBody) SetSuccess(v bool) *DeleteJobResponseBody {
	s.Success = &v
	return s
}

type DeleteJobResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteJobResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteJobResponse) GoString() string {
	return s.String()
}

func (s *DeleteJobResponse) SetHeaders(v map[string]*string) *DeleteJobResponse {
	s.Headers = v
	return s
}

func (s *DeleteJobResponse) SetStatusCode(v int32) *DeleteJobResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteJobResponse) SetBody(v *DeleteJobResponseBody) *DeleteJobResponse {
	s.Body = v
	return s
}

type DeleteOTAFirmwareRequest struct {
	// The unique ID of the OTA update package.
	//
	// An update package ID is returned when you call the [CreateOTAFirmware](~~147311~~) operation to create the update package.
	//
	// You can call the [ListOTAFirmware](~~147450~~) operation and view the update package ID in the response.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s DeleteOTAFirmwareRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteOTAFirmwareRequest) GoString() string {
	return s.String()
}

func (s *DeleteOTAFirmwareRequest) SetFirmwareId(v string) *DeleteOTAFirmwareRequest {
	s.FirmwareId = &v
	return s
}

func (s *DeleteOTAFirmwareRequest) SetIotInstanceId(v string) *DeleteOTAFirmwareRequest {
	s.IotInstanceId = &v
	return s
}

type DeleteOTAFirmwareResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteOTAFirmwareResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteOTAFirmwareResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteOTAFirmwareResponseBody) SetCode(v string) *DeleteOTAFirmwareResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteOTAFirmwareResponseBody) SetErrorMessage(v string) *DeleteOTAFirmwareResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteOTAFirmwareResponseBody) SetRequestId(v string) *DeleteOTAFirmwareResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteOTAFirmwareResponseBody) SetSuccess(v bool) *DeleteOTAFirmwareResponseBody {
	s.Success = &v
	return s
}

type DeleteOTAFirmwareResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteOTAFirmwareResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteOTAFirmwareResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteOTAFirmwareResponse) GoString() string {
	return s.String()
}

func (s *DeleteOTAFirmwareResponse) SetHeaders(v map[string]*string) *DeleteOTAFirmwareResponse {
	s.Headers = v
	return s
}

func (s *DeleteOTAFirmwareResponse) SetStatusCode(v int32) *DeleteOTAFirmwareResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteOTAFirmwareResponse) SetBody(v *DeleteOTAFirmwareResponseBody) *DeleteOTAFirmwareResponse {
	s.Body = v
	return s
}

type DeleteOTAModuleRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The name of the OTA module.
	ModuleName *string `json:"ModuleName,omitempty" xml:"ModuleName,omitempty"`
	// The **ProductKey** of the product to which the OTA module belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s DeleteOTAModuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteOTAModuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteOTAModuleRequest) SetIotInstanceId(v string) *DeleteOTAModuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteOTAModuleRequest) SetModuleName(v string) *DeleteOTAModuleRequest {
	s.ModuleName = &v
	return s
}

func (s *DeleteOTAModuleRequest) SetProductKey(v string) *DeleteOTAModuleRequest {
	s.ProductKey = &v
	return s
}

type DeleteOTAModuleResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteOTAModuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteOTAModuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteOTAModuleResponseBody) SetCode(v string) *DeleteOTAModuleResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteOTAModuleResponseBody) SetErrorMessage(v string) *DeleteOTAModuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteOTAModuleResponseBody) SetRequestId(v string) *DeleteOTAModuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteOTAModuleResponseBody) SetSuccess(v bool) *DeleteOTAModuleResponseBody {
	s.Success = &v
	return s
}

type DeleteOTAModuleResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteOTAModuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteOTAModuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteOTAModuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteOTAModuleResponse) SetHeaders(v map[string]*string) *DeleteOTAModuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteOTAModuleResponse) SetStatusCode(v int32) *DeleteOTAModuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteOTAModuleResponse) SetBody(v *DeleteOTAModuleResponseBody) *DeleteOTAModuleResponse {
	s.Body = v
	return s
}

type DeleteParserRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ParserId      *int64  `json:"ParserId,omitempty" xml:"ParserId,omitempty"`
}

func (s DeleteParserRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteParserRequest) GoString() string {
	return s.String()
}

func (s *DeleteParserRequest) SetIotInstanceId(v string) *DeleteParserRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteParserRequest) SetParserId(v int64) *DeleteParserRequest {
	s.ParserId = &v
	return s
}

type DeleteParserResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteParserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteParserResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteParserResponseBody) SetCode(v string) *DeleteParserResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteParserResponseBody) SetErrorMessage(v string) *DeleteParserResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteParserResponseBody) SetRequestId(v string) *DeleteParserResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteParserResponseBody) SetSuccess(v bool) *DeleteParserResponseBody {
	s.Success = &v
	return s
}

type DeleteParserResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteParserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteParserResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteParserResponse) GoString() string {
	return s.String()
}

func (s *DeleteParserResponse) SetHeaders(v map[string]*string) *DeleteParserResponse {
	s.Headers = v
	return s
}

func (s *DeleteParserResponse) SetStatusCode(v int32) *DeleteParserResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteParserResponse) SetBody(v *DeleteParserResponseBody) *DeleteParserResponse {
	s.Body = v
	return s
}

type DeleteParserDataSourceRequest struct {
	DataSourceId  *int64  `json:"DataSourceId,omitempty" xml:"DataSourceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s DeleteParserDataSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteParserDataSourceRequest) GoString() string {
	return s.String()
}

func (s *DeleteParserDataSourceRequest) SetDataSourceId(v int64) *DeleteParserDataSourceRequest {
	s.DataSourceId = &v
	return s
}

func (s *DeleteParserDataSourceRequest) SetIotInstanceId(v string) *DeleteParserDataSourceRequest {
	s.IotInstanceId = &v
	return s
}

type DeleteParserDataSourceResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteParserDataSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteParserDataSourceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteParserDataSourceResponseBody) SetCode(v string) *DeleteParserDataSourceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteParserDataSourceResponseBody) SetErrorMessage(v string) *DeleteParserDataSourceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteParserDataSourceResponseBody) SetRequestId(v string) *DeleteParserDataSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteParserDataSourceResponseBody) SetSuccess(v bool) *DeleteParserDataSourceResponseBody {
	s.Success = &v
	return s
}

type DeleteParserDataSourceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteParserDataSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteParserDataSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteParserDataSourceResponse) GoString() string {
	return s.String()
}

func (s *DeleteParserDataSourceResponse) SetHeaders(v map[string]*string) *DeleteParserDataSourceResponse {
	s.Headers = v
	return s
}

func (s *DeleteParserDataSourceResponse) SetStatusCode(v int32) *DeleteParserDataSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteParserDataSourceResponse) SetBody(v *DeleteParserDataSourceResponseBody) *DeleteParserDataSourceResponse {
	s.Body = v
	return s
}

type DeleteProductRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product that you want to delete. A ProductKey is a GUID that is issued by IoT Platform to a product. You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s DeleteProductRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteProductRequest) GoString() string {
	return s.String()
}

func (s *DeleteProductRequest) SetIotInstanceId(v string) *DeleteProductRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteProductRequest) SetProductKey(v string) *DeleteProductRequest {
	s.ProductKey = &v
	return s
}

type DeleteProductResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteProductResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteProductResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteProductResponseBody) SetCode(v string) *DeleteProductResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteProductResponseBody) SetErrorMessage(v string) *DeleteProductResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteProductResponseBody) SetRequestId(v string) *DeleteProductResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteProductResponseBody) SetSuccess(v bool) *DeleteProductResponseBody {
	s.Success = &v
	return s
}

type DeleteProductResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteProductResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteProductResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteProductResponse) GoString() string {
	return s.String()
}

func (s *DeleteProductResponse) SetHeaders(v map[string]*string) *DeleteProductResponse {
	s.Headers = v
	return s
}

func (s *DeleteProductResponse) SetStatusCode(v int32) *DeleteProductResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteProductResponse) SetBody(v *DeleteProductResponseBody) *DeleteProductResponse {
	s.Body = v
	return s
}

type DeleteProductTagsRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	//
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product. A ProductKey is a GUID that is issued by IoT Platform to a product. You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
	ProductKey    *string   `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	ProductTagKey []*string `json:"ProductTagKey,omitempty" xml:"ProductTagKey,omitempty" type:"Repeated"`
}

func (s DeleteProductTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteProductTagsRequest) GoString() string {
	return s.String()
}

func (s *DeleteProductTagsRequest) SetIotInstanceId(v string) *DeleteProductTagsRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteProductTagsRequest) SetProductKey(v string) *DeleteProductTagsRequest {
	s.ProductKey = &v
	return s
}

func (s *DeleteProductTagsRequest) SetProductTagKey(v []*string) *DeleteProductTagsRequest {
	s.ProductTagKey = v
	return s
}

type DeleteProductTagsResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteProductTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteProductTagsResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteProductTagsResponseBody) SetCode(v string) *DeleteProductTagsResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteProductTagsResponseBody) SetErrorMessage(v string) *DeleteProductTagsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteProductTagsResponseBody) SetRequestId(v string) *DeleteProductTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteProductTagsResponseBody) SetSuccess(v bool) *DeleteProductTagsResponseBody {
	s.Success = &v
	return s
}

type DeleteProductTagsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteProductTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteProductTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteProductTagsResponse) GoString() string {
	return s.String()
}

func (s *DeleteProductTagsResponse) SetHeaders(v map[string]*string) *DeleteProductTagsResponse {
	s.Headers = v
	return s
}

func (s *DeleteProductTagsResponse) SetStatusCode(v int32) *DeleteProductTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteProductTagsResponse) SetBody(v *DeleteProductTagsResponseBody) *DeleteProductTagsResponse {
	s.Body = v
	return s
}

type DeleteProductTopicRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the topic category that you want to delete.
	TopicId *string `json:"TopicId,omitempty" xml:"TopicId,omitempty"`
}

func (s DeleteProductTopicRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteProductTopicRequest) GoString() string {
	return s.String()
}

func (s *DeleteProductTopicRequest) SetIotInstanceId(v string) *DeleteProductTopicRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteProductTopicRequest) SetTopicId(v string) *DeleteProductTopicRequest {
	s.TopicId = &v
	return s
}

type DeleteProductTopicResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteProductTopicResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteProductTopicResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteProductTopicResponseBody) SetCode(v string) *DeleteProductTopicResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteProductTopicResponseBody) SetErrorMessage(v string) *DeleteProductTopicResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteProductTopicResponseBody) SetRequestId(v string) *DeleteProductTopicResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteProductTopicResponseBody) SetSuccess(v bool) *DeleteProductTopicResponseBody {
	s.Success = &v
	return s
}

type DeleteProductTopicResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteProductTopicResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteProductTopicResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteProductTopicResponse) GoString() string {
	return s.String()
}

func (s *DeleteProductTopicResponse) SetHeaders(v map[string]*string) *DeleteProductTopicResponse {
	s.Headers = v
	return s
}

func (s *DeleteProductTopicResponse) SetStatusCode(v int32) *DeleteProductTopicResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteProductTopicResponse) SetBody(v *DeleteProductTopicResponseBody) *DeleteProductTopicResponse {
	s.Body = v
	return s
}

type DeleteRuleRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the rule that you want to delete. You can log on to the IoT Platform console and choose **Rules** > **Data Forwarding** to view the rule ID. You can also call the [ListRule](~~69486~~) operation and view the rule ID in the response.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s DeleteRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteRuleRequest) SetIotInstanceId(v string) *DeleteRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteRuleRequest) SetRuleId(v int64) *DeleteRuleRequest {
	s.RuleId = &v
	return s
}

type DeleteRuleResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRuleResponseBody) SetCode(v string) *DeleteRuleResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteRuleResponseBody) SetErrorMessage(v string) *DeleteRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteRuleResponseBody) SetRequestId(v string) *DeleteRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteRuleResponseBody) SetSuccess(v bool) *DeleteRuleResponseBody {
	s.Success = &v
	return s
}

type DeleteRuleResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteRuleResponse) SetHeaders(v map[string]*string) *DeleteRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteRuleResponse) SetStatusCode(v int32) *DeleteRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRuleResponse) SetBody(v *DeleteRuleResponseBody) *DeleteRuleResponse {
	s.Body = v
	return s
}

type DeleteRuleActionRequest struct {
	// The identifier of the rule action that you want to delete.
	//
	// After you call the [CreateRuleAction](~~69586~~) operation to create a rule action, the rule action ID is returned. You can call the [ListRuleActions](~~69517~~) operation to view the rule action ID.
	ActionId *int64 `json:"ActionId,omitempty" xml:"ActionId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s DeleteRuleActionRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteRuleActionRequest) GoString() string {
	return s.String()
}

func (s *DeleteRuleActionRequest) SetActionId(v int64) *DeleteRuleActionRequest {
	s.ActionId = &v
	return s
}

func (s *DeleteRuleActionRequest) SetIotInstanceId(v string) *DeleteRuleActionRequest {
	s.IotInstanceId = &v
	return s
}

type DeleteRuleActionResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteRuleActionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteRuleActionResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteRuleActionResponseBody) SetCode(v string) *DeleteRuleActionResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteRuleActionResponseBody) SetErrorMessage(v string) *DeleteRuleActionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteRuleActionResponseBody) SetRequestId(v string) *DeleteRuleActionResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteRuleActionResponseBody) SetSuccess(v bool) *DeleteRuleActionResponseBody {
	s.Success = &v
	return s
}

type DeleteRuleActionResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteRuleActionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteRuleActionResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteRuleActionResponse) GoString() string {
	return s.String()
}

func (s *DeleteRuleActionResponse) SetHeaders(v map[string]*string) *DeleteRuleActionResponse {
	s.Headers = v
	return s
}

func (s *DeleteRuleActionResponse) SetStatusCode(v int32) *DeleteRuleActionResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteRuleActionResponse) SetBody(v *DeleteRuleActionResponseBody) *DeleteRuleActionResponse {
	s.Body = v
	return s
}

type DeleteSceneRuleRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	RuleId        *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s DeleteSceneRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSceneRuleRequest) GoString() string {
	return s.String()
}

func (s *DeleteSceneRuleRequest) SetIotInstanceId(v string) *DeleteSceneRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteSceneRuleRequest) SetRuleId(v string) *DeleteSceneRuleRequest {
	s.RuleId = &v
	return s
}

type DeleteSceneRuleResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteSceneRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSceneRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSceneRuleResponseBody) SetCode(v string) *DeleteSceneRuleResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteSceneRuleResponseBody) SetErrorMessage(v string) *DeleteSceneRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteSceneRuleResponseBody) SetRequestId(v string) *DeleteSceneRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSceneRuleResponseBody) SetSuccess(v bool) *DeleteSceneRuleResponseBody {
	s.Success = &v
	return s
}

type DeleteSceneRuleResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSceneRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSceneRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSceneRuleResponse) GoString() string {
	return s.String()
}

func (s *DeleteSceneRuleResponse) SetHeaders(v map[string]*string) *DeleteSceneRuleResponse {
	s.Headers = v
	return s
}

func (s *DeleteSceneRuleResponse) SetStatusCode(v int32) *DeleteSceneRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSceneRuleResponse) SetBody(v *DeleteSceneRuleResponseBody) *DeleteSceneRuleResponse {
	s.Body = v
	return s
}

type DeleteSchedulePeriodRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PeriodCode    *string `json:"PeriodCode,omitempty" xml:"PeriodCode,omitempty"`
}

func (s DeleteSchedulePeriodRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSchedulePeriodRequest) GoString() string {
	return s.String()
}

func (s *DeleteSchedulePeriodRequest) SetIotInstanceId(v string) *DeleteSchedulePeriodRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteSchedulePeriodRequest) SetPeriodCode(v string) *DeleteSchedulePeriodRequest {
	s.PeriodCode = &v
	return s
}

type DeleteSchedulePeriodResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteSchedulePeriodResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSchedulePeriodResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSchedulePeriodResponseBody) SetCode(v string) *DeleteSchedulePeriodResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteSchedulePeriodResponseBody) SetErrorMessage(v string) *DeleteSchedulePeriodResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteSchedulePeriodResponseBody) SetRequestId(v string) *DeleteSchedulePeriodResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSchedulePeriodResponseBody) SetSuccess(v bool) *DeleteSchedulePeriodResponseBody {
	s.Success = &v
	return s
}

type DeleteSchedulePeriodResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSchedulePeriodResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSchedulePeriodResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSchedulePeriodResponse) GoString() string {
	return s.String()
}

func (s *DeleteSchedulePeriodResponse) SetHeaders(v map[string]*string) *DeleteSchedulePeriodResponse {
	s.Headers = v
	return s
}

func (s *DeleteSchedulePeriodResponse) SetStatusCode(v int32) *DeleteSchedulePeriodResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSchedulePeriodResponse) SetBody(v *DeleteSchedulePeriodResponseBody) *DeleteSchedulePeriodResponse {
	s.Body = v
	return s
}

type DeleteShareTaskDeviceRequest struct {
	IotIdList     []*string `json:"IotIdList,omitempty" xml:"IotIdList,omitempty" type:"Repeated"`
	IotInstanceId *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ShareTaskId   *string   `json:"ShareTaskId,omitempty" xml:"ShareTaskId,omitempty"`
}

func (s DeleteShareTaskDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteShareTaskDeviceRequest) GoString() string {
	return s.String()
}

func (s *DeleteShareTaskDeviceRequest) SetIotIdList(v []*string) *DeleteShareTaskDeviceRequest {
	s.IotIdList = v
	return s
}

func (s *DeleteShareTaskDeviceRequest) SetIotInstanceId(v string) *DeleteShareTaskDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteShareTaskDeviceRequest) SetShareTaskId(v string) *DeleteShareTaskDeviceRequest {
	s.ShareTaskId = &v
	return s
}

type DeleteShareTaskDeviceResponseBody struct {
	Code         *string                                `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *DeleteShareTaskDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                  `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteShareTaskDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteShareTaskDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteShareTaskDeviceResponseBody) SetCode(v string) *DeleteShareTaskDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteShareTaskDeviceResponseBody) SetData(v *DeleteShareTaskDeviceResponseBodyData) *DeleteShareTaskDeviceResponseBody {
	s.Data = v
	return s
}

func (s *DeleteShareTaskDeviceResponseBody) SetErrorMessage(v string) *DeleteShareTaskDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteShareTaskDeviceResponseBody) SetRequestId(v string) *DeleteShareTaskDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteShareTaskDeviceResponseBody) SetSuccess(v bool) *DeleteShareTaskDeviceResponseBody {
	s.Success = &v
	return s
}

type DeleteShareTaskDeviceResponseBodyData struct {
	Progress   *int32  `json:"Progress,omitempty" xml:"Progress,omitempty"`
	ProgressId *string `json:"ProgressId,omitempty" xml:"ProgressId,omitempty"`
}

func (s DeleteShareTaskDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s DeleteShareTaskDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *DeleteShareTaskDeviceResponseBodyData) SetProgress(v int32) *DeleteShareTaskDeviceResponseBodyData {
	s.Progress = &v
	return s
}

func (s *DeleteShareTaskDeviceResponseBodyData) SetProgressId(v string) *DeleteShareTaskDeviceResponseBodyData {
	s.ProgressId = &v
	return s
}

type DeleteShareTaskDeviceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteShareTaskDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteShareTaskDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteShareTaskDeviceResponse) GoString() string {
	return s.String()
}

func (s *DeleteShareTaskDeviceResponse) SetHeaders(v map[string]*string) *DeleteShareTaskDeviceResponse {
	s.Headers = v
	return s
}

func (s *DeleteShareTaskDeviceResponse) SetStatusCode(v int32) *DeleteShareTaskDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteShareTaskDeviceResponse) SetBody(v *DeleteShareTaskDeviceResponseBody) *DeleteShareTaskDeviceResponse {
	s.Body = v
	return s
}

type DeleteSoundCodeRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	SoundCode     *string `json:"SoundCode,omitempty" xml:"SoundCode,omitempty"`
}

func (s DeleteSoundCodeRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSoundCodeRequest) GoString() string {
	return s.String()
}

func (s *DeleteSoundCodeRequest) SetIotInstanceId(v string) *DeleteSoundCodeRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteSoundCodeRequest) SetSoundCode(v string) *DeleteSoundCodeRequest {
	s.SoundCode = &v
	return s
}

type DeleteSoundCodeResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteSoundCodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSoundCodeResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSoundCodeResponseBody) SetCode(v string) *DeleteSoundCodeResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteSoundCodeResponseBody) SetErrorMessage(v string) *DeleteSoundCodeResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteSoundCodeResponseBody) SetRequestId(v string) *DeleteSoundCodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSoundCodeResponseBody) SetSuccess(v bool) *DeleteSoundCodeResponseBody {
	s.Success = &v
	return s
}

type DeleteSoundCodeResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSoundCodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSoundCodeResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSoundCodeResponse) GoString() string {
	return s.String()
}

func (s *DeleteSoundCodeResponse) SetHeaders(v map[string]*string) *DeleteSoundCodeResponse {
	s.Headers = v
	return s
}

func (s *DeleteSoundCodeResponse) SetStatusCode(v int32) *DeleteSoundCodeResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSoundCodeResponse) SetBody(v *DeleteSoundCodeResponseBody) *DeleteSoundCodeResponse {
	s.Body = v
	return s
}

type DeleteSoundCodeLabelRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	SoundCode     *string `json:"SoundCode,omitempty" xml:"SoundCode,omitempty"`
}

func (s DeleteSoundCodeLabelRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSoundCodeLabelRequest) GoString() string {
	return s.String()
}

func (s *DeleteSoundCodeLabelRequest) SetIotInstanceId(v string) *DeleteSoundCodeLabelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteSoundCodeLabelRequest) SetSoundCode(v string) *DeleteSoundCodeLabelRequest {
	s.SoundCode = &v
	return s
}

type DeleteSoundCodeLabelResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteSoundCodeLabelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSoundCodeLabelResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSoundCodeLabelResponseBody) SetCode(v string) *DeleteSoundCodeLabelResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteSoundCodeLabelResponseBody) SetErrorMessage(v string) *DeleteSoundCodeLabelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteSoundCodeLabelResponseBody) SetRequestId(v string) *DeleteSoundCodeLabelResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSoundCodeLabelResponseBody) SetSuccess(v bool) *DeleteSoundCodeLabelResponseBody {
	s.Success = &v
	return s
}

type DeleteSoundCodeLabelResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSoundCodeLabelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSoundCodeLabelResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSoundCodeLabelResponse) GoString() string {
	return s.String()
}

func (s *DeleteSoundCodeLabelResponse) SetHeaders(v map[string]*string) *DeleteSoundCodeLabelResponse {
	s.Headers = v
	return s
}

func (s *DeleteSoundCodeLabelResponse) SetStatusCode(v int32) *DeleteSoundCodeLabelResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSoundCodeLabelResponse) SetBody(v *DeleteSoundCodeLabelResponseBody) *DeleteSoundCodeLabelResponse {
	s.Body = v
	return s
}

type DeleteSoundCodeScheduleRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ScheduleCode  *string `json:"ScheduleCode,omitempty" xml:"ScheduleCode,omitempty"`
}

func (s DeleteSoundCodeScheduleRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSoundCodeScheduleRequest) GoString() string {
	return s.String()
}

func (s *DeleteSoundCodeScheduleRequest) SetIotInstanceId(v string) *DeleteSoundCodeScheduleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteSoundCodeScheduleRequest) SetScheduleCode(v string) *DeleteSoundCodeScheduleRequest {
	s.ScheduleCode = &v
	return s
}

type DeleteSoundCodeScheduleResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteSoundCodeScheduleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSoundCodeScheduleResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSoundCodeScheduleResponseBody) SetCode(v string) *DeleteSoundCodeScheduleResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteSoundCodeScheduleResponseBody) SetErrorMessage(v string) *DeleteSoundCodeScheduleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteSoundCodeScheduleResponseBody) SetRequestId(v string) *DeleteSoundCodeScheduleResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSoundCodeScheduleResponseBody) SetSuccess(v bool) *DeleteSoundCodeScheduleResponseBody {
	s.Success = &v
	return s
}

type DeleteSoundCodeScheduleResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSoundCodeScheduleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSoundCodeScheduleResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSoundCodeScheduleResponse) GoString() string {
	return s.String()
}

func (s *DeleteSoundCodeScheduleResponse) SetHeaders(v map[string]*string) *DeleteSoundCodeScheduleResponse {
	s.Headers = v
	return s
}

func (s *DeleteSoundCodeScheduleResponse) SetStatusCode(v int32) *DeleteSoundCodeScheduleResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSoundCodeScheduleResponse) SetBody(v *DeleteSoundCodeScheduleResponseBody) *DeleteSoundCodeScheduleResponse {
	s.Body = v
	return s
}

type DeleteSpeechRequest struct {
	IotInstanceId  *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	SpeechCodeList []*string `json:"SpeechCodeList,omitempty" xml:"SpeechCodeList,omitempty" type:"Repeated"`
}

func (s DeleteSpeechRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSpeechRequest) GoString() string {
	return s.String()
}

func (s *DeleteSpeechRequest) SetIotInstanceId(v string) *DeleteSpeechRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteSpeechRequest) SetSpeechCodeList(v []*string) *DeleteSpeechRequest {
	s.SpeechCodeList = v
	return s
}

type DeleteSpeechResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteSpeechResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSpeechResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSpeechResponseBody) SetCode(v string) *DeleteSpeechResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteSpeechResponseBody) SetErrorMessage(v string) *DeleteSpeechResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteSpeechResponseBody) SetRequestId(v string) *DeleteSpeechResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSpeechResponseBody) SetSuccess(v bool) *DeleteSpeechResponseBody {
	s.Success = &v
	return s
}

type DeleteSpeechResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSpeechResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSpeechResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSpeechResponse) GoString() string {
	return s.String()
}

func (s *DeleteSpeechResponse) SetHeaders(v map[string]*string) *DeleteSpeechResponse {
	s.Headers = v
	return s
}

func (s *DeleteSpeechResponse) SetStatusCode(v int32) *DeleteSpeechResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSpeechResponse) SetBody(v *DeleteSpeechResponseBody) *DeleteSpeechResponse {
	s.Body = v
	return s
}

type DeleteStudioAppDomainOpenRequest struct {
	AppId         *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	DomainId      *int32  `json:"DomainId,omitempty" xml:"DomainId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProjectId     *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s DeleteStudioAppDomainOpenRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteStudioAppDomainOpenRequest) GoString() string {
	return s.String()
}

func (s *DeleteStudioAppDomainOpenRequest) SetAppId(v string) *DeleteStudioAppDomainOpenRequest {
	s.AppId = &v
	return s
}

func (s *DeleteStudioAppDomainOpenRequest) SetDomainId(v int32) *DeleteStudioAppDomainOpenRequest {
	s.DomainId = &v
	return s
}

func (s *DeleteStudioAppDomainOpenRequest) SetIotInstanceId(v string) *DeleteStudioAppDomainOpenRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteStudioAppDomainOpenRequest) SetProjectId(v string) *DeleteStudioAppDomainOpenRequest {
	s.ProjectId = &v
	return s
}

type DeleteStudioAppDomainOpenResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteStudioAppDomainOpenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteStudioAppDomainOpenResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteStudioAppDomainOpenResponseBody) SetCode(v string) *DeleteStudioAppDomainOpenResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteStudioAppDomainOpenResponseBody) SetData(v bool) *DeleteStudioAppDomainOpenResponseBody {
	s.Data = &v
	return s
}

func (s *DeleteStudioAppDomainOpenResponseBody) SetErrorMessage(v string) *DeleteStudioAppDomainOpenResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteStudioAppDomainOpenResponseBody) SetRequestId(v string) *DeleteStudioAppDomainOpenResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteStudioAppDomainOpenResponseBody) SetSuccess(v bool) *DeleteStudioAppDomainOpenResponseBody {
	s.Success = &v
	return s
}

type DeleteStudioAppDomainOpenResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteStudioAppDomainOpenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteStudioAppDomainOpenResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteStudioAppDomainOpenResponse) GoString() string {
	return s.String()
}

func (s *DeleteStudioAppDomainOpenResponse) SetHeaders(v map[string]*string) *DeleteStudioAppDomainOpenResponse {
	s.Headers = v
	return s
}

func (s *DeleteStudioAppDomainOpenResponse) SetStatusCode(v int32) *DeleteStudioAppDomainOpenResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteStudioAppDomainOpenResponse) SetBody(v *DeleteStudioAppDomainOpenResponseBody) *DeleteStudioAppDomainOpenResponse {
	s.Body = v
	return s
}

type DeleteSubscribeRelationRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product that is specified for the subscription.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The type of the subscription. Valid values:
	//
	// *   **MNS**
	// *   **AMQP**
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s DeleteSubscribeRelationRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteSubscribeRelationRequest) GoString() string {
	return s.String()
}

func (s *DeleteSubscribeRelationRequest) SetIotInstanceId(v string) *DeleteSubscribeRelationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteSubscribeRelationRequest) SetProductKey(v string) *DeleteSubscribeRelationRequest {
	s.ProductKey = &v
	return s
}

func (s *DeleteSubscribeRelationRequest) SetType(v string) *DeleteSubscribeRelationRequest {
	s.Type = &v
	return s
}

type DeleteSubscribeRelationResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteSubscribeRelationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteSubscribeRelationResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteSubscribeRelationResponseBody) SetCode(v string) *DeleteSubscribeRelationResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteSubscribeRelationResponseBody) SetErrorMessage(v string) *DeleteSubscribeRelationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteSubscribeRelationResponseBody) SetRequestId(v string) *DeleteSubscribeRelationResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteSubscribeRelationResponseBody) SetSuccess(v bool) *DeleteSubscribeRelationResponseBody {
	s.Success = &v
	return s
}

type DeleteSubscribeRelationResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteSubscribeRelationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteSubscribeRelationResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteSubscribeRelationResponse) GoString() string {
	return s.String()
}

func (s *DeleteSubscribeRelationResponse) SetHeaders(v map[string]*string) *DeleteSubscribeRelationResponse {
	s.Headers = v
	return s
}

func (s *DeleteSubscribeRelationResponse) SetStatusCode(v int32) *DeleteSubscribeRelationResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteSubscribeRelationResponse) SetBody(v *DeleteSubscribeRelationResponseBody) *DeleteSubscribeRelationResponse {
	s.Body = v
	return s
}

type DeleteThingModelRequest struct {
	EventIdentifier []*string `json:"EventIdentifier,omitempty" xml:"EventIdentifier,omitempty" type:"Repeated"`
	// The identifier of the custom TSL module. Each identifier is unique in a product.
	//
	// *   If you configure the BatteryModule parameter when a value is specified for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter, the operation removes one or more specified features from the specified custom TSL module. If you do not configure the BatteryModule parameter, the operation removes one or more specified features from the default TSL module.
	// *   If you configure the BatteryModule parameter when the **PropertyIdentifier.N**, **ServiceIdentifier.N**, and **EventIdentifier.N** parameters are empty, the operation removes all features from the specified custom TSL module.
	FunctionBlockId *string `json:"FunctionBlockId,omitempty" xml:"FunctionBlockId,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product.
	ProductKey         *string   `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	PropertyIdentifier []*string `json:"PropertyIdentifier,omitempty" xml:"PropertyIdentifier,omitempty" type:"Repeated"`
	// The ID of the resource group.
	//
	// >  You cannot configure this parameter.
	ResourceGroupId   *string   `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	ServiceIdentifier []*string `json:"ServiceIdentifier,omitempty" xml:"ServiceIdentifier,omitempty" type:"Repeated"`
}

func (s DeleteThingModelRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteThingModelRequest) GoString() string {
	return s.String()
}

func (s *DeleteThingModelRequest) SetEventIdentifier(v []*string) *DeleteThingModelRequest {
	s.EventIdentifier = v
	return s
}

func (s *DeleteThingModelRequest) SetFunctionBlockId(v string) *DeleteThingModelRequest {
	s.FunctionBlockId = &v
	return s
}

func (s *DeleteThingModelRequest) SetIotInstanceId(v string) *DeleteThingModelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteThingModelRequest) SetProductKey(v string) *DeleteThingModelRequest {
	s.ProductKey = &v
	return s
}

func (s *DeleteThingModelRequest) SetPropertyIdentifier(v []*string) *DeleteThingModelRequest {
	s.PropertyIdentifier = v
	return s
}

func (s *DeleteThingModelRequest) SetResourceGroupId(v string) *DeleteThingModelRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *DeleteThingModelRequest) SetServiceIdentifier(v []*string) *DeleteThingModelRequest {
	s.ServiceIdentifier = v
	return s
}

type DeleteThingModelResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteThingModelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteThingModelResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteThingModelResponseBody) SetCode(v string) *DeleteThingModelResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteThingModelResponseBody) SetErrorMessage(v string) *DeleteThingModelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteThingModelResponseBody) SetRequestId(v string) *DeleteThingModelResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteThingModelResponseBody) SetSuccess(v bool) *DeleteThingModelResponseBody {
	s.Success = &v
	return s
}

type DeleteThingModelResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteThingModelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteThingModelResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteThingModelResponse) GoString() string {
	return s.String()
}

func (s *DeleteThingModelResponse) SetHeaders(v map[string]*string) *DeleteThingModelResponse {
	s.Headers = v
	return s
}

func (s *DeleteThingModelResponse) SetStatusCode(v int32) *DeleteThingModelResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteThingModelResponse) SetBody(v *DeleteThingModelResponseBody) *DeleteThingModelResponse {
	s.Body = v
	return s
}

type DeleteTopicConfigRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	TopicFullName *string `json:"TopicFullName,omitempty" xml:"TopicFullName,omitempty"`
}

func (s DeleteTopicConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTopicConfigRequest) GoString() string {
	return s.String()
}

func (s *DeleteTopicConfigRequest) SetIotInstanceId(v string) *DeleteTopicConfigRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteTopicConfigRequest) SetProductKey(v string) *DeleteTopicConfigRequest {
	s.ProductKey = &v
	return s
}

func (s *DeleteTopicConfigRequest) SetTopicFullName(v string) *DeleteTopicConfigRequest {
	s.TopicFullName = &v
	return s
}

type DeleteTopicConfigResponseBody struct {
	Code      *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Message   *string `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteTopicConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTopicConfigResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTopicConfigResponseBody) SetCode(v string) *DeleteTopicConfigResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteTopicConfigResponseBody) SetMessage(v string) *DeleteTopicConfigResponseBody {
	s.Message = &v
	return s
}

func (s *DeleteTopicConfigResponseBody) SetRequestId(v string) *DeleteTopicConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteTopicConfigResponseBody) SetSuccess(v bool) *DeleteTopicConfigResponseBody {
	s.Success = &v
	return s
}

type DeleteTopicConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTopicConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTopicConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTopicConfigResponse) GoString() string {
	return s.String()
}

func (s *DeleteTopicConfigResponse) SetHeaders(v map[string]*string) *DeleteTopicConfigResponse {
	s.Headers = v
	return s
}

func (s *DeleteTopicConfigResponse) SetStatusCode(v int32) *DeleteTopicConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTopicConfigResponse) SetBody(v *DeleteTopicConfigResponseBody) *DeleteTopicConfigResponse {
	s.Body = v
	return s
}

type DeleteTopicRouteTableRequest struct {
	DstTopic []*string `json:"DstTopic,omitempty" xml:"DstTopic,omitempty" type:"Repeated"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	SrcTopic      *string `json:"SrcTopic,omitempty" xml:"SrcTopic,omitempty"`
}

func (s DeleteTopicRouteTableRequest) String() string {
	return tea.Prettify(s)
}

func (s DeleteTopicRouteTableRequest) GoString() string {
	return s.String()
}

func (s *DeleteTopicRouteTableRequest) SetDstTopic(v []*string) *DeleteTopicRouteTableRequest {
	s.DstTopic = v
	return s
}

func (s *DeleteTopicRouteTableRequest) SetIotInstanceId(v string) *DeleteTopicRouteTableRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DeleteTopicRouteTableRequest) SetSrcTopic(v string) *DeleteTopicRouteTableRequest {
	s.SrcTopic = &v
	return s
}

type DeleteTopicRouteTableResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The list of topics returned if the call fails.
	FailureTopics *DeleteTopicRouteTableResponseBodyFailureTopics `json:"FailureTopics,omitempty" xml:"FailureTopics,omitempty" type:"Struct"`
	// Indicates whether all the routing relationships of the topic are deleted.
	//
	// *   **true**: All the routing relationships of the topic are deleted.
	// *   **false**: Not all the message routing relationships of the topic are deleted.
	IsAllSucceed *bool `json:"IsAllSucceed,omitempty" xml:"IsAllSucceed,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DeleteTopicRouteTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DeleteTopicRouteTableResponseBody) GoString() string {
	return s.String()
}

func (s *DeleteTopicRouteTableResponseBody) SetCode(v string) *DeleteTopicRouteTableResponseBody {
	s.Code = &v
	return s
}

func (s *DeleteTopicRouteTableResponseBody) SetErrorMessage(v string) *DeleteTopicRouteTableResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DeleteTopicRouteTableResponseBody) SetFailureTopics(v *DeleteTopicRouteTableResponseBodyFailureTopics) *DeleteTopicRouteTableResponseBody {
	s.FailureTopics = v
	return s
}

func (s *DeleteTopicRouteTableResponseBody) SetIsAllSucceed(v bool) *DeleteTopicRouteTableResponseBody {
	s.IsAllSucceed = &v
	return s
}

func (s *DeleteTopicRouteTableResponseBody) SetRequestId(v string) *DeleteTopicRouteTableResponseBody {
	s.RequestId = &v
	return s
}

func (s *DeleteTopicRouteTableResponseBody) SetSuccess(v bool) *DeleteTopicRouteTableResponseBody {
	s.Success = &v
	return s
}

type DeleteTopicRouteTableResponseBodyFailureTopics struct {
	Topic []map[string]interface{} `json:"Topic,omitempty" xml:"Topic,omitempty" type:"Repeated"`
}

func (s DeleteTopicRouteTableResponseBodyFailureTopics) String() string {
	return tea.Prettify(s)
}

func (s DeleteTopicRouteTableResponseBodyFailureTopics) GoString() string {
	return s.String()
}

func (s *DeleteTopicRouteTableResponseBodyFailureTopics) SetTopic(v []map[string]interface{}) *DeleteTopicRouteTableResponseBodyFailureTopics {
	s.Topic = v
	return s
}

type DeleteTopicRouteTableResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DeleteTopicRouteTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DeleteTopicRouteTableResponse) String() string {
	return tea.Prettify(s)
}

func (s DeleteTopicRouteTableResponse) GoString() string {
	return s.String()
}

func (s *DeleteTopicRouteTableResponse) SetHeaders(v map[string]*string) *DeleteTopicRouteTableResponse {
	s.Headers = v
	return s
}

func (s *DeleteTopicRouteTableResponse) SetStatusCode(v int32) *DeleteTopicRouteTableResponse {
	s.StatusCode = &v
	return s
}

func (s *DeleteTopicRouteTableResponse) SetBody(v *DeleteTopicRouteTableResponseBody) *DeleteTopicRouteTableResponse {
	s.Body = v
	return s
}

type DetachDestinationRequest struct {
	// The ID of the data destination. You can call the [ListDestination](~~433025~~) operation to query data destinations and obtain the ID of the **data destination**.
	DestinationId *int64 `json:"DestinationId,omitempty" xml:"DestinationId,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the parser. You can call the [ListParser](~~444814~~) operation to query parsers and obtain the ID of the **parser**.
	ParserId *int64 `json:"ParserId,omitempty" xml:"ParserId,omitempty"`
}

func (s DetachDestinationRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachDestinationRequest) GoString() string {
	return s.String()
}

func (s *DetachDestinationRequest) SetDestinationId(v int64) *DetachDestinationRequest {
	s.DestinationId = &v
	return s
}

func (s *DetachDestinationRequest) SetIotInstanceId(v string) *DetachDestinationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DetachDestinationRequest) SetParserId(v int64) *DetachDestinationRequest {
	s.ParserId = &v
	return s
}

type DetachDestinationResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DetachDestinationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachDestinationResponseBody) GoString() string {
	return s.String()
}

func (s *DetachDestinationResponseBody) SetCode(v string) *DetachDestinationResponseBody {
	s.Code = &v
	return s
}

func (s *DetachDestinationResponseBody) SetErrorMessage(v string) *DetachDestinationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DetachDestinationResponseBody) SetRequestId(v string) *DetachDestinationResponseBody {
	s.RequestId = &v
	return s
}

func (s *DetachDestinationResponseBody) SetSuccess(v bool) *DetachDestinationResponseBody {
	s.Success = &v
	return s
}

type DetachDestinationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachDestinationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachDestinationResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachDestinationResponse) GoString() string {
	return s.String()
}

func (s *DetachDestinationResponse) SetHeaders(v map[string]*string) *DetachDestinationResponse {
	s.Headers = v
	return s
}

func (s *DetachDestinationResponse) SetStatusCode(v int32) *DetachDestinationResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachDestinationResponse) SetBody(v *DetachDestinationResponseBody) *DetachDestinationResponse {
	s.Body = v
	return s
}

type DetachParserDataSourceRequest struct {
	DataSourceId  *int64  `json:"DataSourceId,omitempty" xml:"DataSourceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ParserId      *int64  `json:"ParserId,omitempty" xml:"ParserId,omitempty"`
}

func (s DetachParserDataSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s DetachParserDataSourceRequest) GoString() string {
	return s.String()
}

func (s *DetachParserDataSourceRequest) SetDataSourceId(v int64) *DetachParserDataSourceRequest {
	s.DataSourceId = &v
	return s
}

func (s *DetachParserDataSourceRequest) SetIotInstanceId(v string) *DetachParserDataSourceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DetachParserDataSourceRequest) SetParserId(v int64) *DetachParserDataSourceRequest {
	s.ParserId = &v
	return s
}

type DetachParserDataSourceResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DetachParserDataSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DetachParserDataSourceResponseBody) GoString() string {
	return s.String()
}

func (s *DetachParserDataSourceResponseBody) SetCode(v string) *DetachParserDataSourceResponseBody {
	s.Code = &v
	return s
}

func (s *DetachParserDataSourceResponseBody) SetErrorMessage(v string) *DetachParserDataSourceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DetachParserDataSourceResponseBody) SetRequestId(v string) *DetachParserDataSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *DetachParserDataSourceResponseBody) SetSuccess(v bool) *DetachParserDataSourceResponseBody {
	s.Success = &v
	return s
}

type DetachParserDataSourceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DetachParserDataSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DetachParserDataSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s DetachParserDataSourceResponse) GoString() string {
	return s.String()
}

func (s *DetachParserDataSourceResponse) SetHeaders(v map[string]*string) *DetachParserDataSourceResponse {
	s.Headers = v
	return s
}

func (s *DetachParserDataSourceResponse) SetStatusCode(v int32) *DetachParserDataSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *DetachParserDataSourceResponse) SetBody(v *DetachParserDataSourceResponseBody) *DetachParserDataSourceResponse {
	s.Body = v
	return s
}

type DisableDeviceTunnelRequest struct {
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s DisableDeviceTunnelRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableDeviceTunnelRequest) GoString() string {
	return s.String()
}

func (s *DisableDeviceTunnelRequest) SetDeviceName(v string) *DisableDeviceTunnelRequest {
	s.DeviceName = &v
	return s
}

func (s *DisableDeviceTunnelRequest) SetIotInstanceId(v string) *DisableDeviceTunnelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DisableDeviceTunnelRequest) SetProductKey(v string) *DisableDeviceTunnelRequest {
	s.ProductKey = &v
	return s
}

type DisableDeviceTunnelResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DisableDeviceTunnelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableDeviceTunnelResponseBody) GoString() string {
	return s.String()
}

func (s *DisableDeviceTunnelResponseBody) SetCode(v string) *DisableDeviceTunnelResponseBody {
	s.Code = &v
	return s
}

func (s *DisableDeviceTunnelResponseBody) SetErrorMessage(v string) *DisableDeviceTunnelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DisableDeviceTunnelResponseBody) SetRequestId(v string) *DisableDeviceTunnelResponseBody {
	s.RequestId = &v
	return s
}

func (s *DisableDeviceTunnelResponseBody) SetSuccess(v bool) *DisableDeviceTunnelResponseBody {
	s.Success = &v
	return s
}

type DisableDeviceTunnelResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableDeviceTunnelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableDeviceTunnelResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableDeviceTunnelResponse) GoString() string {
	return s.String()
}

func (s *DisableDeviceTunnelResponse) SetHeaders(v map[string]*string) *DisableDeviceTunnelResponse {
	s.Headers = v
	return s
}

func (s *DisableDeviceTunnelResponse) SetStatusCode(v int32) *DisableDeviceTunnelResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableDeviceTunnelResponse) SetBody(v *DisableDeviceTunnelResponseBody) *DisableDeviceTunnelResponse {
	s.Body = v
	return s
}

type DisableDeviceTunnelShareRequest struct {
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s DisableDeviceTunnelShareRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableDeviceTunnelShareRequest) GoString() string {
	return s.String()
}

func (s *DisableDeviceTunnelShareRequest) SetDeviceName(v string) *DisableDeviceTunnelShareRequest {
	s.DeviceName = &v
	return s
}

func (s *DisableDeviceTunnelShareRequest) SetIotInstanceId(v string) *DisableDeviceTunnelShareRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DisableDeviceTunnelShareRequest) SetProductKey(v string) *DisableDeviceTunnelShareRequest {
	s.ProductKey = &v
	return s
}

type DisableDeviceTunnelShareResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DisableDeviceTunnelShareResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableDeviceTunnelShareResponseBody) GoString() string {
	return s.String()
}

func (s *DisableDeviceTunnelShareResponseBody) SetCode(v string) *DisableDeviceTunnelShareResponseBody {
	s.Code = &v
	return s
}

func (s *DisableDeviceTunnelShareResponseBody) SetErrorMessage(v string) *DisableDeviceTunnelShareResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DisableDeviceTunnelShareResponseBody) SetRequestId(v string) *DisableDeviceTunnelShareResponseBody {
	s.RequestId = &v
	return s
}

func (s *DisableDeviceTunnelShareResponseBody) SetSuccess(v bool) *DisableDeviceTunnelShareResponseBody {
	s.Success = &v
	return s
}

type DisableDeviceTunnelShareResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableDeviceTunnelShareResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableDeviceTunnelShareResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableDeviceTunnelShareResponse) GoString() string {
	return s.String()
}

func (s *DisableDeviceTunnelShareResponse) SetHeaders(v map[string]*string) *DisableDeviceTunnelShareResponse {
	s.Headers = v
	return s
}

func (s *DisableDeviceTunnelShareResponse) SetStatusCode(v int32) *DisableDeviceTunnelShareResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableDeviceTunnelShareResponse) SetBody(v *DisableDeviceTunnelShareResponseBody) *DisableDeviceTunnelShareResponse {
	s.Body = v
	return s
}

type DisableSceneRuleRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	RuleId        *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s DisableSceneRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableSceneRuleRequest) GoString() string {
	return s.String()
}

func (s *DisableSceneRuleRequest) SetIotInstanceId(v string) *DisableSceneRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DisableSceneRuleRequest) SetRuleId(v string) *DisableSceneRuleRequest {
	s.RuleId = &v
	return s
}

type DisableSceneRuleResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DisableSceneRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableSceneRuleResponseBody) GoString() string {
	return s.String()
}

func (s *DisableSceneRuleResponseBody) SetCode(v string) *DisableSceneRuleResponseBody {
	s.Code = &v
	return s
}

func (s *DisableSceneRuleResponseBody) SetErrorMessage(v string) *DisableSceneRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DisableSceneRuleResponseBody) SetRequestId(v string) *DisableSceneRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *DisableSceneRuleResponseBody) SetSuccess(v bool) *DisableSceneRuleResponseBody {
	s.Success = &v
	return s
}

type DisableSceneRuleResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableSceneRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableSceneRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableSceneRuleResponse) GoString() string {
	return s.String()
}

func (s *DisableSceneRuleResponse) SetHeaders(v map[string]*string) *DisableSceneRuleResponse {
	s.Headers = v
	return s
}

func (s *DisableSceneRuleResponse) SetStatusCode(v int32) *DisableSceneRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableSceneRuleResponse) SetBody(v *DisableSceneRuleResponseBody) *DisableSceneRuleResponse {
	s.Body = v
	return s
}

type DisableThingRequest struct {
	// The DeviceName of the device.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s DisableThingRequest) String() string {
	return tea.Prettify(s)
}

func (s DisableThingRequest) GoString() string {
	return s.String()
}

func (s *DisableThingRequest) SetDeviceName(v string) *DisableThingRequest {
	s.DeviceName = &v
	return s
}

func (s *DisableThingRequest) SetIotId(v string) *DisableThingRequest {
	s.IotId = &v
	return s
}

func (s *DisableThingRequest) SetIotInstanceId(v string) *DisableThingRequest {
	s.IotInstanceId = &v
	return s
}

func (s *DisableThingRequest) SetProductKey(v string) *DisableThingRequest {
	s.ProductKey = &v
	return s
}

type DisableThingResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s DisableThingResponseBody) String() string {
	return tea.Prettify(s)
}

func (s DisableThingResponseBody) GoString() string {
	return s.String()
}

func (s *DisableThingResponseBody) SetCode(v string) *DisableThingResponseBody {
	s.Code = &v
	return s
}

func (s *DisableThingResponseBody) SetErrorMessage(v string) *DisableThingResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *DisableThingResponseBody) SetRequestId(v string) *DisableThingResponseBody {
	s.RequestId = &v
	return s
}

func (s *DisableThingResponseBody) SetSuccess(v bool) *DisableThingResponseBody {
	s.Success = &v
	return s
}

type DisableThingResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *DisableThingResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s DisableThingResponse) String() string {
	return tea.Prettify(s)
}

func (s DisableThingResponse) GoString() string {
	return s.String()
}

func (s *DisableThingResponse) SetHeaders(v map[string]*string) *DisableThingResponse {
	s.Headers = v
	return s
}

func (s *DisableThingResponse) SetStatusCode(v int32) *DisableThingResponse {
	s.StatusCode = &v
	return s
}

func (s *DisableThingResponse) SetBody(v *DisableThingResponseBody) *DisableThingResponse {
	s.Body = v
	return s
}

type EnableDeviceTunnelRequest struct {
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s EnableDeviceTunnelRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableDeviceTunnelRequest) GoString() string {
	return s.String()
}

func (s *EnableDeviceTunnelRequest) SetDeviceName(v string) *EnableDeviceTunnelRequest {
	s.DeviceName = &v
	return s
}

func (s *EnableDeviceTunnelRequest) SetIotInstanceId(v string) *EnableDeviceTunnelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *EnableDeviceTunnelRequest) SetProductKey(v string) *EnableDeviceTunnelRequest {
	s.ProductKey = &v
	return s
}

type EnableDeviceTunnelResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s EnableDeviceTunnelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableDeviceTunnelResponseBody) GoString() string {
	return s.String()
}

func (s *EnableDeviceTunnelResponseBody) SetCode(v string) *EnableDeviceTunnelResponseBody {
	s.Code = &v
	return s
}

func (s *EnableDeviceTunnelResponseBody) SetErrorMessage(v string) *EnableDeviceTunnelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *EnableDeviceTunnelResponseBody) SetRequestId(v string) *EnableDeviceTunnelResponseBody {
	s.RequestId = &v
	return s
}

func (s *EnableDeviceTunnelResponseBody) SetSuccess(v bool) *EnableDeviceTunnelResponseBody {
	s.Success = &v
	return s
}

type EnableDeviceTunnelResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableDeviceTunnelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableDeviceTunnelResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableDeviceTunnelResponse) GoString() string {
	return s.String()
}

func (s *EnableDeviceTunnelResponse) SetHeaders(v map[string]*string) *EnableDeviceTunnelResponse {
	s.Headers = v
	return s
}

func (s *EnableDeviceTunnelResponse) SetStatusCode(v int32) *EnableDeviceTunnelResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableDeviceTunnelResponse) SetBody(v *EnableDeviceTunnelResponseBody) *EnableDeviceTunnelResponse {
	s.Body = v
	return s
}

type EnableDeviceTunnelShareRequest struct {
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s EnableDeviceTunnelShareRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableDeviceTunnelShareRequest) GoString() string {
	return s.String()
}

func (s *EnableDeviceTunnelShareRequest) SetDeviceName(v string) *EnableDeviceTunnelShareRequest {
	s.DeviceName = &v
	return s
}

func (s *EnableDeviceTunnelShareRequest) SetIotInstanceId(v string) *EnableDeviceTunnelShareRequest {
	s.IotInstanceId = &v
	return s
}

func (s *EnableDeviceTunnelShareRequest) SetProductKey(v string) *EnableDeviceTunnelShareRequest {
	s.ProductKey = &v
	return s
}

type EnableDeviceTunnelShareResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s EnableDeviceTunnelShareResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableDeviceTunnelShareResponseBody) GoString() string {
	return s.String()
}

func (s *EnableDeviceTunnelShareResponseBody) SetCode(v string) *EnableDeviceTunnelShareResponseBody {
	s.Code = &v
	return s
}

func (s *EnableDeviceTunnelShareResponseBody) SetErrorMessage(v string) *EnableDeviceTunnelShareResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *EnableDeviceTunnelShareResponseBody) SetRequestId(v string) *EnableDeviceTunnelShareResponseBody {
	s.RequestId = &v
	return s
}

func (s *EnableDeviceTunnelShareResponseBody) SetSuccess(v bool) *EnableDeviceTunnelShareResponseBody {
	s.Success = &v
	return s
}

type EnableDeviceTunnelShareResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableDeviceTunnelShareResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableDeviceTunnelShareResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableDeviceTunnelShareResponse) GoString() string {
	return s.String()
}

func (s *EnableDeviceTunnelShareResponse) SetHeaders(v map[string]*string) *EnableDeviceTunnelShareResponse {
	s.Headers = v
	return s
}

func (s *EnableDeviceTunnelShareResponse) SetStatusCode(v int32) *EnableDeviceTunnelShareResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableDeviceTunnelShareResponse) SetBody(v *EnableDeviceTunnelShareResponseBody) *EnableDeviceTunnelShareResponse {
	s.Body = v
	return s
}

type EnableSceneRuleRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	RuleId        *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s EnableSceneRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableSceneRuleRequest) GoString() string {
	return s.String()
}

func (s *EnableSceneRuleRequest) SetIotInstanceId(v string) *EnableSceneRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *EnableSceneRuleRequest) SetRuleId(v string) *EnableSceneRuleRequest {
	s.RuleId = &v
	return s
}

type EnableSceneRuleResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s EnableSceneRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableSceneRuleResponseBody) GoString() string {
	return s.String()
}

func (s *EnableSceneRuleResponseBody) SetCode(v string) *EnableSceneRuleResponseBody {
	s.Code = &v
	return s
}

func (s *EnableSceneRuleResponseBody) SetErrorMessage(v string) *EnableSceneRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *EnableSceneRuleResponseBody) SetRequestId(v string) *EnableSceneRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *EnableSceneRuleResponseBody) SetSuccess(v bool) *EnableSceneRuleResponseBody {
	s.Success = &v
	return s
}

type EnableSceneRuleResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableSceneRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableSceneRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableSceneRuleResponse) GoString() string {
	return s.String()
}

func (s *EnableSceneRuleResponse) SetHeaders(v map[string]*string) *EnableSceneRuleResponse {
	s.Headers = v
	return s
}

func (s *EnableSceneRuleResponse) SetStatusCode(v int32) *EnableSceneRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableSceneRuleResponse) SetBody(v *EnableSceneRuleResponseBody) *EnableSceneRuleResponse {
	s.Body = v
	return s
}

type EnableThingRequest struct {
	// The DeviceName of the device.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// >  If you provide this parameter, you do not need to provide the **ProductKey** or **DeviceName** parameters. As the GUID of the device, **IotId** corresponds to the combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s EnableThingRequest) String() string {
	return tea.Prettify(s)
}

func (s EnableThingRequest) GoString() string {
	return s.String()
}

func (s *EnableThingRequest) SetDeviceName(v string) *EnableThingRequest {
	s.DeviceName = &v
	return s
}

func (s *EnableThingRequest) SetIotId(v string) *EnableThingRequest {
	s.IotId = &v
	return s
}

func (s *EnableThingRequest) SetIotInstanceId(v string) *EnableThingRequest {
	s.IotInstanceId = &v
	return s
}

func (s *EnableThingRequest) SetProductKey(v string) *EnableThingRequest {
	s.ProductKey = &v
	return s
}

type EnableThingResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s EnableThingResponseBody) String() string {
	return tea.Prettify(s)
}

func (s EnableThingResponseBody) GoString() string {
	return s.String()
}

func (s *EnableThingResponseBody) SetCode(v string) *EnableThingResponseBody {
	s.Code = &v
	return s
}

func (s *EnableThingResponseBody) SetErrorMessage(v string) *EnableThingResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *EnableThingResponseBody) SetRequestId(v string) *EnableThingResponseBody {
	s.RequestId = &v
	return s
}

func (s *EnableThingResponseBody) SetSuccess(v bool) *EnableThingResponseBody {
	s.Success = &v
	return s
}

type EnableThingResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *EnableThingResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s EnableThingResponse) String() string {
	return tea.Prettify(s)
}

func (s EnableThingResponse) GoString() string {
	return s.String()
}

func (s *EnableThingResponse) SetHeaders(v map[string]*string) *EnableThingResponse {
	s.Headers = v
	return s
}

func (s *EnableThingResponse) SetStatusCode(v int32) *EnableThingResponse {
	s.StatusCode = &v
	return s
}

func (s *EnableThingResponse) SetBody(v *EnableThingResponseBody) *EnableThingResponse {
	s.Body = v
	return s
}

type GenerateDeviceNameListURLRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s GenerateDeviceNameListURLRequest) String() string {
	return tea.Prettify(s)
}

func (s GenerateDeviceNameListURLRequest) GoString() string {
	return s.String()
}

func (s *GenerateDeviceNameListURLRequest) SetIotInstanceId(v string) *GenerateDeviceNameListURLRequest {
	s.IotInstanceId = &v
	return s
}

type GenerateDeviceNameListURLResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information returned if the call is successful. For more information, see the following parameters:
	Data *GenerateDeviceNameListURLResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GenerateDeviceNameListURLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GenerateDeviceNameListURLResponseBody) GoString() string {
	return s.String()
}

func (s *GenerateDeviceNameListURLResponseBody) SetCode(v string) *GenerateDeviceNameListURLResponseBody {
	s.Code = &v
	return s
}

func (s *GenerateDeviceNameListURLResponseBody) SetData(v *GenerateDeviceNameListURLResponseBodyData) *GenerateDeviceNameListURLResponseBody {
	s.Data = v
	return s
}

func (s *GenerateDeviceNameListURLResponseBody) SetErrorMessage(v string) *GenerateDeviceNameListURLResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GenerateDeviceNameListURLResponseBody) SetRequestId(v string) *GenerateDeviceNameListURLResponseBody {
	s.RequestId = &v
	return s
}

func (s *GenerateDeviceNameListURLResponseBody) SetSuccess(v bool) *GenerateDeviceNameListURLResponseBody {
	s.Success = &v
	return s
}

type GenerateDeviceNameListURLResponseBodyData struct {
	// The AccessKey ID of the bucket owner.
	//
	// The OSS bucket stores the file.
	AccessKeyId *string `json:"AccessKeyId,omitempty" xml:"AccessKeyId,omitempty"`
	// The URL of the file that is stored in OSS.
	//
	// After the device list file is uploaded, this parameter is used to call the [CreateOTAStaticUpgradeJob](~~147496~~) operation to create a static update batch.
	FileUrl *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	// The endpoint of OSS.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The full path of the file in OSS. You can call the OSS PostObject operation to upload the file to OSS.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The type of the object storage. Default value: OSS.
	ObjectStorage *string `json:"ObjectStorage,omitempty" xml:"ObjectStorage,omitempty"`
	// The parameter that is used by OSS to verify form fields for the request.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The signature that is calculated based on **AccessKeySecret** and **Policy**. When you call an OSS operation, OSS uses the signature information to verify the POST request.
	Signature *string `json:"Signature,omitempty" xml:"Signature,omitempty"`
	// The time when the URL of the file that you want to upload was generated. The time is displayed in UTC.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
}

func (s GenerateDeviceNameListURLResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GenerateDeviceNameListURLResponseBodyData) GoString() string {
	return s.String()
}

func (s *GenerateDeviceNameListURLResponseBodyData) SetAccessKeyId(v string) *GenerateDeviceNameListURLResponseBodyData {
	s.AccessKeyId = &v
	return s
}

func (s *GenerateDeviceNameListURLResponseBodyData) SetFileUrl(v string) *GenerateDeviceNameListURLResponseBodyData {
	s.FileUrl = &v
	return s
}

func (s *GenerateDeviceNameListURLResponseBodyData) SetHost(v string) *GenerateDeviceNameListURLResponseBodyData {
	s.Host = &v
	return s
}

func (s *GenerateDeviceNameListURLResponseBodyData) SetKey(v string) *GenerateDeviceNameListURLResponseBodyData {
	s.Key = &v
	return s
}

func (s *GenerateDeviceNameListURLResponseBodyData) SetObjectStorage(v string) *GenerateDeviceNameListURLResponseBodyData {
	s.ObjectStorage = &v
	return s
}

func (s *GenerateDeviceNameListURLResponseBodyData) SetPolicy(v string) *GenerateDeviceNameListURLResponseBodyData {
	s.Policy = &v
	return s
}

func (s *GenerateDeviceNameListURLResponseBodyData) SetSignature(v string) *GenerateDeviceNameListURLResponseBodyData {
	s.Signature = &v
	return s
}

func (s *GenerateDeviceNameListURLResponseBodyData) SetUtcCreate(v string) *GenerateDeviceNameListURLResponseBodyData {
	s.UtcCreate = &v
	return s
}

type GenerateDeviceNameListURLResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GenerateDeviceNameListURLResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GenerateDeviceNameListURLResponse) String() string {
	return tea.Prettify(s)
}

func (s GenerateDeviceNameListURLResponse) GoString() string {
	return s.String()
}

func (s *GenerateDeviceNameListURLResponse) SetHeaders(v map[string]*string) *GenerateDeviceNameListURLResponse {
	s.Headers = v
	return s
}

func (s *GenerateDeviceNameListURLResponse) SetStatusCode(v int32) *GenerateDeviceNameListURLResponse {
	s.StatusCode = &v
	return s
}

func (s *GenerateDeviceNameListURLResponse) SetBody(v *GenerateDeviceNameListURLResponseBody) *GenerateDeviceNameListURLResponse {
	s.Body = v
	return s
}

type GenerateFileUploadURLRequest struct {
	BizCode       *string `json:"BizCode,omitempty" xml:"BizCode,omitempty"`
	FileName      *string `json:"FileName,omitempty" xml:"FileName,omitempty"`
	FileSuffix    *string `json:"FileSuffix,omitempty" xml:"FileSuffix,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s GenerateFileUploadURLRequest) String() string {
	return tea.Prettify(s)
}

func (s GenerateFileUploadURLRequest) GoString() string {
	return s.String()
}

func (s *GenerateFileUploadURLRequest) SetBizCode(v string) *GenerateFileUploadURLRequest {
	s.BizCode = &v
	return s
}

func (s *GenerateFileUploadURLRequest) SetFileName(v string) *GenerateFileUploadURLRequest {
	s.FileName = &v
	return s
}

func (s *GenerateFileUploadURLRequest) SetFileSuffix(v string) *GenerateFileUploadURLRequest {
	s.FileSuffix = &v
	return s
}

func (s *GenerateFileUploadURLRequest) SetIotInstanceId(v string) *GenerateFileUploadURLRequest {
	s.IotInstanceId = &v
	return s
}

type GenerateFileUploadURLResponseBody struct {
	Code         *string                                `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *GenerateFileUploadURLResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                  `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GenerateFileUploadURLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GenerateFileUploadURLResponseBody) GoString() string {
	return s.String()
}

func (s *GenerateFileUploadURLResponseBody) SetCode(v string) *GenerateFileUploadURLResponseBody {
	s.Code = &v
	return s
}

func (s *GenerateFileUploadURLResponseBody) SetData(v *GenerateFileUploadURLResponseBodyData) *GenerateFileUploadURLResponseBody {
	s.Data = v
	return s
}

func (s *GenerateFileUploadURLResponseBody) SetErrorMessage(v string) *GenerateFileUploadURLResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GenerateFileUploadURLResponseBody) SetRequestId(v string) *GenerateFileUploadURLResponseBody {
	s.RequestId = &v
	return s
}

func (s *GenerateFileUploadURLResponseBody) SetSuccess(v bool) *GenerateFileUploadURLResponseBody {
	s.Success = &v
	return s
}

type GenerateFileUploadURLResponseBodyData struct {
	Host           *string `json:"Host,omitempty" xml:"Host,omitempty"`
	Key            *string `json:"Key,omitempty" xml:"Key,omitempty"`
	ObjectStorage  *string `json:"ObjectStorage,omitempty" xml:"ObjectStorage,omitempty"`
	OssAccessKeyId *string `json:"OssAccessKeyId,omitempty" xml:"OssAccessKeyId,omitempty"`
	Policy         *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	Signature      *string `json:"Signature,omitempty" xml:"Signature,omitempty"`
}

func (s GenerateFileUploadURLResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GenerateFileUploadURLResponseBodyData) GoString() string {
	return s.String()
}

func (s *GenerateFileUploadURLResponseBodyData) SetHost(v string) *GenerateFileUploadURLResponseBodyData {
	s.Host = &v
	return s
}

func (s *GenerateFileUploadURLResponseBodyData) SetKey(v string) *GenerateFileUploadURLResponseBodyData {
	s.Key = &v
	return s
}

func (s *GenerateFileUploadURLResponseBodyData) SetObjectStorage(v string) *GenerateFileUploadURLResponseBodyData {
	s.ObjectStorage = &v
	return s
}

func (s *GenerateFileUploadURLResponseBodyData) SetOssAccessKeyId(v string) *GenerateFileUploadURLResponseBodyData {
	s.OssAccessKeyId = &v
	return s
}

func (s *GenerateFileUploadURLResponseBodyData) SetPolicy(v string) *GenerateFileUploadURLResponseBodyData {
	s.Policy = &v
	return s
}

func (s *GenerateFileUploadURLResponseBodyData) SetSignature(v string) *GenerateFileUploadURLResponseBodyData {
	s.Signature = &v
	return s
}

type GenerateFileUploadURLResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GenerateFileUploadURLResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GenerateFileUploadURLResponse) String() string {
	return tea.Prettify(s)
}

func (s GenerateFileUploadURLResponse) GoString() string {
	return s.String()
}

func (s *GenerateFileUploadURLResponse) SetHeaders(v map[string]*string) *GenerateFileUploadURLResponse {
	s.Headers = v
	return s
}

func (s *GenerateFileUploadURLResponse) SetStatusCode(v int32) *GenerateFileUploadURLResponse {
	s.StatusCode = &v
	return s
}

func (s *GenerateFileUploadURLResponse) SetBody(v *GenerateFileUploadURLResponseBody) *GenerateFileUploadURLResponse {
	s.Body = v
	return s
}

type GenerateOTAUploadURLRequest struct {
	// The file name extension of the update package file. Valid values: bin, dav, apk, tar, gz, tar.gz, zip, and gzip.
	//
	// Default value: bin.
	FileSuffix *string `json:"FileSuffix,omitempty" xml:"FileSuffix,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s GenerateOTAUploadURLRequest) String() string {
	return tea.Prettify(s)
}

func (s GenerateOTAUploadURLRequest) GoString() string {
	return s.String()
}

func (s *GenerateOTAUploadURLRequest) SetFileSuffix(v string) *GenerateOTAUploadURLRequest {
	s.FileSuffix = &v
	return s
}

func (s *GenerateOTAUploadURLRequest) SetIotInstanceId(v string) *GenerateOTAUploadURLRequest {
	s.IotInstanceId = &v
	return s
}

type GenerateOTAUploadURLResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information returned if the call is successful. For more information, see the following parameters.
	Data *GenerateOTAUploadURLResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GenerateOTAUploadURLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GenerateOTAUploadURLResponseBody) GoString() string {
	return s.String()
}

func (s *GenerateOTAUploadURLResponseBody) SetCode(v string) *GenerateOTAUploadURLResponseBody {
	s.Code = &v
	return s
}

func (s *GenerateOTAUploadURLResponseBody) SetData(v *GenerateOTAUploadURLResponseBodyData) *GenerateOTAUploadURLResponseBody {
	s.Data = v
	return s
}

func (s *GenerateOTAUploadURLResponseBody) SetErrorMessage(v string) *GenerateOTAUploadURLResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GenerateOTAUploadURLResponseBody) SetRequestId(v string) *GenerateOTAUploadURLResponseBody {
	s.RequestId = &v
	return s
}

func (s *GenerateOTAUploadURLResponseBody) SetSuccess(v bool) *GenerateOTAUploadURLResponseBody {
	s.Success = &v
	return s
}

type GenerateOTAUploadURLResponseBodyData struct {
	// The URL of the update package file that is stored in OSS.
	//
	// After the update package file is uploaded, this parameter is used to call the [CreateOTAFirmware](~~147311~~) operation to create an update package.
	FirmwareUrl *string `json:"FirmwareUrl,omitempty" xml:"FirmwareUrl,omitempty"`
	// The endpoint of OSS.
	Host *string `json:"Host,omitempty" xml:"Host,omitempty"`
	// The full path of the file in OSS. The file is uploaded by calling the OSS PostObject operation.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The AccessKey ID of the bucket owner.
	//
	// This OSS bucket stores the update package file.
	OSSAccessKeyId *string `json:"OSSAccessKeyId,omitempty" xml:"OSSAccessKeyId,omitempty"`
	// The type of object storage. Default value: OSS.
	ObjectStorage *string `json:"ObjectStorage,omitempty" xml:"ObjectStorage,omitempty"`
	// The parameter that is used by OSS to verify form fields for the request.
	Policy *string `json:"Policy,omitempty" xml:"Policy,omitempty"`
	// The signature that is calculated based on **AccessKeySecret** and **Policy**. When you call an OSS operation, OSS uses the signature information to verify the POST request.
	Signature *string `json:"Signature,omitempty" xml:"Signature,omitempty"`
	// The time when the URL of the uploaded update package file was generated. The time is displayed in UTC.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
}

func (s GenerateOTAUploadURLResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GenerateOTAUploadURLResponseBodyData) GoString() string {
	return s.String()
}

func (s *GenerateOTAUploadURLResponseBodyData) SetFirmwareUrl(v string) *GenerateOTAUploadURLResponseBodyData {
	s.FirmwareUrl = &v
	return s
}

func (s *GenerateOTAUploadURLResponseBodyData) SetHost(v string) *GenerateOTAUploadURLResponseBodyData {
	s.Host = &v
	return s
}

func (s *GenerateOTAUploadURLResponseBodyData) SetKey(v string) *GenerateOTAUploadURLResponseBodyData {
	s.Key = &v
	return s
}

func (s *GenerateOTAUploadURLResponseBodyData) SetOSSAccessKeyId(v string) *GenerateOTAUploadURLResponseBodyData {
	s.OSSAccessKeyId = &v
	return s
}

func (s *GenerateOTAUploadURLResponseBodyData) SetObjectStorage(v string) *GenerateOTAUploadURLResponseBodyData {
	s.ObjectStorage = &v
	return s
}

func (s *GenerateOTAUploadURLResponseBodyData) SetPolicy(v string) *GenerateOTAUploadURLResponseBodyData {
	s.Policy = &v
	return s
}

func (s *GenerateOTAUploadURLResponseBodyData) SetSignature(v string) *GenerateOTAUploadURLResponseBodyData {
	s.Signature = &v
	return s
}

func (s *GenerateOTAUploadURLResponseBodyData) SetUtcCreate(v string) *GenerateOTAUploadURLResponseBodyData {
	s.UtcCreate = &v
	return s
}

type GenerateOTAUploadURLResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GenerateOTAUploadURLResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GenerateOTAUploadURLResponse) String() string {
	return tea.Prettify(s)
}

func (s GenerateOTAUploadURLResponse) GoString() string {
	return s.String()
}

func (s *GenerateOTAUploadURLResponse) SetHeaders(v map[string]*string) *GenerateOTAUploadURLResponse {
	s.Headers = v
	return s
}

func (s *GenerateOTAUploadURLResponse) SetStatusCode(v int32) *GenerateOTAUploadURLResponse {
	s.StatusCode = &v
	return s
}

func (s *GenerateOTAUploadURLResponse) SetBody(v *GenerateOTAUploadURLResponseBody) *GenerateOTAUploadURLResponse {
	s.Body = v
	return s
}

type GetDataAPIServiceDetailRequest struct {
	ApiSrn        *string `json:"ApiSrn,omitempty" xml:"ApiSrn,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s GetDataAPIServiceDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDataAPIServiceDetailRequest) GoString() string {
	return s.String()
}

func (s *GetDataAPIServiceDetailRequest) SetApiSrn(v string) *GetDataAPIServiceDetailRequest {
	s.ApiSrn = &v
	return s
}

func (s *GetDataAPIServiceDetailRequest) SetIotInstanceId(v string) *GetDataAPIServiceDetailRequest {
	s.IotInstanceId = &v
	return s
}

type GetDataAPIServiceDetailResponseBody struct {
	Code         *string                                  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *GetDataAPIServiceDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                  `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                    `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDataAPIServiceDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDataAPIServiceDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetDataAPIServiceDetailResponseBody) SetCode(v string) *GetDataAPIServiceDetailResponseBody {
	s.Code = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBody) SetData(v *GetDataAPIServiceDetailResponseBodyData) *GetDataAPIServiceDetailResponseBody {
	s.Data = v
	return s
}

func (s *GetDataAPIServiceDetailResponseBody) SetErrorMessage(v string) *GetDataAPIServiceDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBody) SetRequestId(v string) *GetDataAPIServiceDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBody) SetSuccess(v bool) *GetDataAPIServiceDetailResponseBody {
	s.Success = &v
	return s
}

type GetDataAPIServiceDetailResponseBodyData struct {
	ApiPath         *string                                                `json:"ApiPath,omitempty" xml:"ApiPath,omitempty"`
	ApiSrn          *string                                                `json:"ApiSrn,omitempty" xml:"ApiSrn,omitempty"`
	CreateTime      *int64                                                 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	DateFormat      *string                                                `json:"DateFormat,omitempty" xml:"DateFormat,omitempty"`
	Description     *string                                                `json:"Description,omitempty" xml:"Description,omitempty"`
	DisplayName     *string                                                `json:"DisplayName,omitempty" xml:"DisplayName,omitempty"`
	LastUpdateTime  *int64                                                 `json:"LastUpdateTime,omitempty" xml:"LastUpdateTime,omitempty"`
	RequestMethod   *string                                                `json:"RequestMethod,omitempty" xml:"RequestMethod,omitempty"`
	RequestProtocol *string                                                `json:"RequestProtocol,omitempty" xml:"RequestProtocol,omitempty"`
	SqlTemplateDTO  *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO `json:"SqlTemplateDTO,omitempty" xml:"SqlTemplateDTO,omitempty" type:"Struct"`
	Status          *int32                                                 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetDataAPIServiceDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDataAPIServiceDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDataAPIServiceDetailResponseBodyData) SetApiPath(v string) *GetDataAPIServiceDetailResponseBodyData {
	s.ApiPath = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyData) SetApiSrn(v string) *GetDataAPIServiceDetailResponseBodyData {
	s.ApiSrn = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyData) SetCreateTime(v int64) *GetDataAPIServiceDetailResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyData) SetDateFormat(v string) *GetDataAPIServiceDetailResponseBodyData {
	s.DateFormat = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyData) SetDescription(v string) *GetDataAPIServiceDetailResponseBodyData {
	s.Description = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyData) SetDisplayName(v string) *GetDataAPIServiceDetailResponseBodyData {
	s.DisplayName = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyData) SetLastUpdateTime(v int64) *GetDataAPIServiceDetailResponseBodyData {
	s.LastUpdateTime = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyData) SetRequestMethod(v string) *GetDataAPIServiceDetailResponseBodyData {
	s.RequestMethod = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyData) SetRequestProtocol(v string) *GetDataAPIServiceDetailResponseBodyData {
	s.RequestProtocol = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyData) SetSqlTemplateDTO(v *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO) *GetDataAPIServiceDetailResponseBodyData {
	s.SqlTemplateDTO = v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyData) SetStatus(v int32) *GetDataAPIServiceDetailResponseBodyData {
	s.Status = &v
	return s
}

type GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO struct {
	OriginSql      *string                                                              `json:"OriginSql,omitempty" xml:"OriginSql,omitempty"`
	RequestParams  *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams  `json:"RequestParams,omitempty" xml:"RequestParams,omitempty" type:"Struct"`
	ResponseParams *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams `json:"ResponseParams,omitempty" xml:"ResponseParams,omitempty" type:"Struct"`
	TemplateSql    *string                                                              `json:"TemplateSql,omitempty" xml:"TemplateSql,omitempty"`
}

func (s GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO) String() string {
	return tea.Prettify(s)
}

func (s GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO) GoString() string {
	return s.String()
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO) SetOriginSql(v string) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO {
	s.OriginSql = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO) SetRequestParams(v *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO {
	s.RequestParams = v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO) SetResponseParams(v *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO {
	s.ResponseParams = v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO) SetTemplateSql(v string) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTO {
	s.TemplateSql = &v
	return s
}

type GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams struct {
	RequestParams []*GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams `json:"RequestParams,omitempty" xml:"RequestParams,omitempty" type:"Repeated"`
}

func (s GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams) String() string {
	return tea.Prettify(s)
}

func (s GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams) GoString() string {
	return s.String()
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams) SetRequestParams(v []*GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParams {
	s.RequestParams = v
	return s
}

type GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams struct {
	Desc     *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	Example  *string `json:"Example,omitempty" xml:"Example,omitempty"`
	Name     *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Required *bool   `json:"Required,omitempty" xml:"Required,omitempty"`
	Type     *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams) String() string {
	return tea.Prettify(s)
}

func (s GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams) GoString() string {
	return s.String()
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams) SetDesc(v string) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams {
	s.Desc = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams) SetExample(v string) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams {
	s.Example = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams) SetName(v string) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams {
	s.Name = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams) SetRequired(v bool) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams {
	s.Required = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams) SetType(v string) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTORequestParamsRequestParams {
	s.Type = &v
	return s
}

type GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams struct {
	ResponseParams []*GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams `json:"ResponseParams,omitempty" xml:"ResponseParams,omitempty" type:"Repeated"`
}

func (s GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams) String() string {
	return tea.Prettify(s)
}

func (s GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams) GoString() string {
	return s.String()
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams) SetResponseParams(v []*GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParams {
	s.ResponseParams = v
	return s
}

type GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams struct {
	Desc     *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	Example  *string `json:"Example,omitempty" xml:"Example,omitempty"`
	Name     *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Required *bool   `json:"Required,omitempty" xml:"Required,omitempty"`
	Type     *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams) String() string {
	return tea.Prettify(s)
}

func (s GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams) GoString() string {
	return s.String()
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams) SetDesc(v string) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams {
	s.Desc = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams) SetExample(v string) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams {
	s.Example = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams) SetName(v string) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams {
	s.Name = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams) SetRequired(v bool) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams {
	s.Required = &v
	return s
}

func (s *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams) SetType(v string) *GetDataAPIServiceDetailResponseBodyDataSqlTemplateDTOResponseParamsResponseParams {
	s.Type = &v
	return s
}

type GetDataAPIServiceDetailResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDataAPIServiceDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDataAPIServiceDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDataAPIServiceDetailResponse) GoString() string {
	return s.String()
}

func (s *GetDataAPIServiceDetailResponse) SetHeaders(v map[string]*string) *GetDataAPIServiceDetailResponse {
	s.Headers = v
	return s
}

func (s *GetDataAPIServiceDetailResponse) SetStatusCode(v int32) *GetDataAPIServiceDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDataAPIServiceDetailResponse) SetBody(v *GetDataAPIServiceDetailResponseBody) *GetDataAPIServiceDetailResponse {
	s.Body = v
	return s
}

type GetDestinationRequest struct {
	DestinationId *int64  `json:"DestinationId,omitempty" xml:"DestinationId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s GetDestinationRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDestinationRequest) GoString() string {
	return s.String()
}

func (s *GetDestinationRequest) SetDestinationId(v int64) *GetDestinationRequest {
	s.DestinationId = &v
	return s
}

func (s *GetDestinationRequest) SetIotInstanceId(v string) *GetDestinationRequest {
	s.IotInstanceId = &v
	return s
}

type GetDestinationResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the data destination.
	Destination *GetDestinationResponseBodyDestination `json:"Destination,omitempty" xml:"Destination,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDestinationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDestinationResponseBody) GoString() string {
	return s.String()
}

func (s *GetDestinationResponseBody) SetCode(v string) *GetDestinationResponseBody {
	s.Code = &v
	return s
}

func (s *GetDestinationResponseBody) SetDestination(v *GetDestinationResponseBodyDestination) *GetDestinationResponseBody {
	s.Destination = v
	return s
}

func (s *GetDestinationResponseBody) SetErrorMessage(v string) *GetDestinationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDestinationResponseBody) SetRequestId(v string) *GetDestinationResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDestinationResponseBody) SetSuccess(v bool) *GetDestinationResponseBody {
	s.Success = &v
	return s
}

type GetDestinationResponseBodyDestination struct {
	// The configuration data of the data destination.
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
	// The ID of the data destination.
	DestinationId *string `json:"DestinationId,omitempty" xml:"DestinationId,omitempty"`
	// Indicates whether the data destination is configured to receive error operation data. Error operation data is data that failed to be forwarded for two consecutive times.
	//
	// *   **true**: The data destination is configured to receive error operation data.
	// *   **false**: The data destination is configured to receive regular data instead of error operation data.
	//
	// Default value: **false**.
	IsFailover *bool `json:"IsFailover,omitempty" xml:"IsFailover,omitempty"`
	// The name of the data destination.
	Name   *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The operation that is performed on the data of the data destination.
	//
	// *   **REPUBLISH**: forwards topic data that is processed by a parser script to an IoT Platform communication topic.
	// *   **AMQP**: forwards topic data that is processed by a parser script to an Advanced Message Queuing Protocol (AMQP) consumer group.
	// *   **DATAHUB**: forwards topic data to Alibaba Cloud DataHub for stream data processing.
	// *   **ONS**: forwards topic data that is processed by a parser script to Message Queue for Apache RocketMQ for message distribution.
	// *   **MNS**: forwards topic data to Message Service (MNS) for message transmission.
	// *   **FC**: forwards topic data to Function Compute for event computing.
	// *   **OTS**: forwards topic data to Tablestore for NoSQL data storage.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The time when the data destination was created. The time is displayed in UTC. Format: `yyyy-MM-dd\"T\"HH:mm:ss.SSS\"Z\"`.
	UtcCreated *string `json:"UtcCreated,omitempty" xml:"UtcCreated,omitempty"`
}

func (s GetDestinationResponseBodyDestination) String() string {
	return tea.Prettify(s)
}

func (s GetDestinationResponseBodyDestination) GoString() string {
	return s.String()
}

func (s *GetDestinationResponseBodyDestination) SetConfiguration(v string) *GetDestinationResponseBodyDestination {
	s.Configuration = &v
	return s
}

func (s *GetDestinationResponseBodyDestination) SetDestinationId(v string) *GetDestinationResponseBodyDestination {
	s.DestinationId = &v
	return s
}

func (s *GetDestinationResponseBodyDestination) SetIsFailover(v bool) *GetDestinationResponseBodyDestination {
	s.IsFailover = &v
	return s
}

func (s *GetDestinationResponseBodyDestination) SetName(v string) *GetDestinationResponseBodyDestination {
	s.Name = &v
	return s
}

func (s *GetDestinationResponseBodyDestination) SetStatus(v string) *GetDestinationResponseBodyDestination {
	s.Status = &v
	return s
}

func (s *GetDestinationResponseBodyDestination) SetType(v string) *GetDestinationResponseBodyDestination {
	s.Type = &v
	return s
}

func (s *GetDestinationResponseBodyDestination) SetUtcCreated(v string) *GetDestinationResponseBodyDestination {
	s.UtcCreated = &v
	return s
}

type GetDestinationResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDestinationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDestinationResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDestinationResponse) GoString() string {
	return s.String()
}

func (s *GetDestinationResponse) SetHeaders(v map[string]*string) *GetDestinationResponse {
	s.Headers = v
	return s
}

func (s *GetDestinationResponse) SetStatusCode(v int32) *GetDestinationResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDestinationResponse) SetBody(v *GetDestinationResponseBody) *GetDestinationResponse {
	s.Body = v
	return s
}

type GetDeviceShadowRequest struct {
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****
	//
	// >*   If the instance has an ID, you must specify the **IotInstanceId** parameter. If you do not specify this parameter, the call fails.
	// >*   If the instance does not have an **ID** or the **Overview** page is not displayed, you do not need to specify this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s GetDeviceShadowRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDeviceShadowRequest) GoString() string {
	return s.String()
}

func (s *GetDeviceShadowRequest) SetDeviceName(v string) *GetDeviceShadowRequest {
	s.DeviceName = &v
	return s
}

func (s *GetDeviceShadowRequest) SetIotInstanceId(v string) *GetDeviceShadowRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetDeviceShadowRequest) SetProductKey(v string) *GetDeviceShadowRequest {
	s.ProductKey = &v
	return s
}

type GetDeviceShadowResponseBody struct {
	// The error code that is returned if the call fails. For more information about error codes, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The shadow information that is returned if the call is successful.
	//
	// >  The structure of the shadow information varies based on the status of the device. For more information, see the [Overview](~~53930~~) topic of Device shadows.
	ShadowMessage *string `json:"ShadowMessage,omitempty" xml:"ShadowMessage,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDeviceShadowResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDeviceShadowResponseBody) GoString() string {
	return s.String()
}

func (s *GetDeviceShadowResponseBody) SetCode(v string) *GetDeviceShadowResponseBody {
	s.Code = &v
	return s
}

func (s *GetDeviceShadowResponseBody) SetErrorMessage(v string) *GetDeviceShadowResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDeviceShadowResponseBody) SetRequestId(v string) *GetDeviceShadowResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDeviceShadowResponseBody) SetShadowMessage(v string) *GetDeviceShadowResponseBody {
	s.ShadowMessage = &v
	return s
}

func (s *GetDeviceShadowResponseBody) SetSuccess(v bool) *GetDeviceShadowResponseBody {
	s.Success = &v
	return s
}

type GetDeviceShadowResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDeviceShadowResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDeviceShadowResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDeviceShadowResponse) GoString() string {
	return s.String()
}

func (s *GetDeviceShadowResponse) SetHeaders(v map[string]*string) *GetDeviceShadowResponse {
	s.Headers = v
	return s
}

func (s *GetDeviceShadowResponse) SetStatusCode(v int32) *GetDeviceShadowResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDeviceShadowResponse) SetBody(v *GetDeviceShadowResponseBody) *GetDeviceShadowResponse {
	s.Body = v
	return s
}

type GetDeviceStatusRequest struct {
	// The DeviceName of the device.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s GetDeviceStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDeviceStatusRequest) GoString() string {
	return s.String()
}

func (s *GetDeviceStatusRequest) SetDeviceName(v string) *GetDeviceStatusRequest {
	s.DeviceName = &v
	return s
}

func (s *GetDeviceStatusRequest) SetIotId(v string) *GetDeviceStatusRequest {
	s.IotId = &v
	return s
}

func (s *GetDeviceStatusRequest) SetIotInstanceId(v string) *GetDeviceStatusRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetDeviceStatusRequest) SetProductKey(v string) *GetDeviceStatusRequest {
	s.ProductKey = &v
	return s
}

type GetDeviceStatusResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The device status returned if the call is successful.
	Data *GetDeviceStatusResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDeviceStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDeviceStatusResponseBody) GoString() string {
	return s.String()
}

func (s *GetDeviceStatusResponseBody) SetCode(v string) *GetDeviceStatusResponseBody {
	s.Code = &v
	return s
}

func (s *GetDeviceStatusResponseBody) SetData(v *GetDeviceStatusResponseBodyData) *GetDeviceStatusResponseBody {
	s.Data = v
	return s
}

func (s *GetDeviceStatusResponseBody) SetErrorMessage(v string) *GetDeviceStatusResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDeviceStatusResponseBody) SetRequestId(v string) *GetDeviceStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDeviceStatusResponseBody) SetSuccess(v bool) *GetDeviceStatusResponseBody {
	s.Success = &v
	return s
}

type GetDeviceStatusResponseBodyData struct {
	// The status of the device. Valid values:
	//
	// *   **ONLINE**: The device is online.
	// *   **OFFLINE**: The device is offline.
	// *   **UNACTIVE**: The device is not activated.
	// *   **DISABLE**: The device is disabled.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The time when the device status changed.
	Timestamp *int64 `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
}

func (s GetDeviceStatusResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDeviceStatusResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDeviceStatusResponseBodyData) SetStatus(v string) *GetDeviceStatusResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetDeviceStatusResponseBodyData) SetTimestamp(v int64) *GetDeviceStatusResponseBodyData {
	s.Timestamp = &v
	return s
}

type GetDeviceStatusResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDeviceStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDeviceStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDeviceStatusResponse) GoString() string {
	return s.String()
}

func (s *GetDeviceStatusResponse) SetHeaders(v map[string]*string) *GetDeviceStatusResponse {
	s.Headers = v
	return s
}

func (s *GetDeviceStatusResponse) SetStatusCode(v int32) *GetDeviceStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDeviceStatusResponse) SetBody(v *GetDeviceStatusResponseBody) *GetDeviceStatusResponse {
	s.Body = v
	return s
}

type GetDeviceTunnelShareStatusRequest struct {
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s GetDeviceTunnelShareStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDeviceTunnelShareStatusRequest) GoString() string {
	return s.String()
}

func (s *GetDeviceTunnelShareStatusRequest) SetDeviceName(v string) *GetDeviceTunnelShareStatusRequest {
	s.DeviceName = &v
	return s
}

func (s *GetDeviceTunnelShareStatusRequest) SetIotInstanceId(v string) *GetDeviceTunnelShareStatusRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetDeviceTunnelShareStatusRequest) SetProductKey(v string) *GetDeviceTunnelShareStatusRequest {
	s.ProductKey = &v
	return s
}

type GetDeviceTunnelShareStatusResponseBody struct {
	Code         *string                                     `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *GetDeviceTunnelShareStatusResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDeviceTunnelShareStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDeviceTunnelShareStatusResponseBody) GoString() string {
	return s.String()
}

func (s *GetDeviceTunnelShareStatusResponseBody) SetCode(v string) *GetDeviceTunnelShareStatusResponseBody {
	s.Code = &v
	return s
}

func (s *GetDeviceTunnelShareStatusResponseBody) SetData(v *GetDeviceTunnelShareStatusResponseBodyData) *GetDeviceTunnelShareStatusResponseBody {
	s.Data = v
	return s
}

func (s *GetDeviceTunnelShareStatusResponseBody) SetErrorMessage(v string) *GetDeviceTunnelShareStatusResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDeviceTunnelShareStatusResponseBody) SetRequestId(v string) *GetDeviceTunnelShareStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDeviceTunnelShareStatusResponseBody) SetSuccess(v bool) *GetDeviceTunnelShareStatusResponseBody {
	s.Success = &v
	return s
}

type GetDeviceTunnelShareStatusResponseBodyData struct {
	GmtOpened *int64  `json:"GmtOpened,omitempty" xml:"GmtOpened,omitempty"`
	IsOpen    *bool   `json:"IsOpen,omitempty" xml:"IsOpen,omitempty"`
	Password  *string `json:"Password,omitempty" xml:"Password,omitempty"`
	ShareId   *string `json:"ShareId,omitempty" xml:"ShareId,omitempty"`
}

func (s GetDeviceTunnelShareStatusResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDeviceTunnelShareStatusResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDeviceTunnelShareStatusResponseBodyData) SetGmtOpened(v int64) *GetDeviceTunnelShareStatusResponseBodyData {
	s.GmtOpened = &v
	return s
}

func (s *GetDeviceTunnelShareStatusResponseBodyData) SetIsOpen(v bool) *GetDeviceTunnelShareStatusResponseBodyData {
	s.IsOpen = &v
	return s
}

func (s *GetDeviceTunnelShareStatusResponseBodyData) SetPassword(v string) *GetDeviceTunnelShareStatusResponseBodyData {
	s.Password = &v
	return s
}

func (s *GetDeviceTunnelShareStatusResponseBodyData) SetShareId(v string) *GetDeviceTunnelShareStatusResponseBodyData {
	s.ShareId = &v
	return s
}

type GetDeviceTunnelShareStatusResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDeviceTunnelShareStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDeviceTunnelShareStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDeviceTunnelShareStatusResponse) GoString() string {
	return s.String()
}

func (s *GetDeviceTunnelShareStatusResponse) SetHeaders(v map[string]*string) *GetDeviceTunnelShareStatusResponse {
	s.Headers = v
	return s
}

func (s *GetDeviceTunnelShareStatusResponse) SetStatusCode(v int32) *GetDeviceTunnelShareStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDeviceTunnelShareStatusResponse) SetBody(v *GetDeviceTunnelShareStatusResponseBody) *GetDeviceTunnelShareStatusResponse {
	s.Body = v
	return s
}

type GetDeviceTunnelStatusRequest struct {
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s GetDeviceTunnelStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDeviceTunnelStatusRequest) GoString() string {
	return s.String()
}

func (s *GetDeviceTunnelStatusRequest) SetDeviceName(v string) *GetDeviceTunnelStatusRequest {
	s.DeviceName = &v
	return s
}

func (s *GetDeviceTunnelStatusRequest) SetIotInstanceId(v string) *GetDeviceTunnelStatusRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetDeviceTunnelStatusRequest) SetProductKey(v string) *GetDeviceTunnelStatusRequest {
	s.ProductKey = &v
	return s
}

type GetDeviceTunnelStatusResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDeviceTunnelStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDeviceTunnelStatusResponseBody) GoString() string {
	return s.String()
}

func (s *GetDeviceTunnelStatusResponseBody) SetCode(v string) *GetDeviceTunnelStatusResponseBody {
	s.Code = &v
	return s
}

func (s *GetDeviceTunnelStatusResponseBody) SetData(v string) *GetDeviceTunnelStatusResponseBody {
	s.Data = &v
	return s
}

func (s *GetDeviceTunnelStatusResponseBody) SetErrorMessage(v string) *GetDeviceTunnelStatusResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDeviceTunnelStatusResponseBody) SetRequestId(v string) *GetDeviceTunnelStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDeviceTunnelStatusResponseBody) SetSuccess(v bool) *GetDeviceTunnelStatusResponseBody {
	s.Success = &v
	return s
}

type GetDeviceTunnelStatusResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDeviceTunnelStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDeviceTunnelStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDeviceTunnelStatusResponse) GoString() string {
	return s.String()
}

func (s *GetDeviceTunnelStatusResponse) SetHeaders(v map[string]*string) *GetDeviceTunnelStatusResponse {
	s.Headers = v
	return s
}

func (s *GetDeviceTunnelStatusResponse) SetStatusCode(v int32) *GetDeviceTunnelStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDeviceTunnelStatusResponse) SetBody(v *GetDeviceTunnelStatusResponseBody) *GetDeviceTunnelStatusResponse {
	s.Body = v
	return s
}

type GetDownloadFileRequest struct {
	Context       map[string]interface{} `json:"Context,omitempty" xml:"Context,omitempty"`
	IotInstanceId *string                `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	LongJobId     *string                `json:"LongJobId,omitempty" xml:"LongJobId,omitempty"`
}

func (s GetDownloadFileRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadFileRequest) GoString() string {
	return s.String()
}

func (s *GetDownloadFileRequest) SetContext(v map[string]interface{}) *GetDownloadFileRequest {
	s.Context = v
	return s
}

func (s *GetDownloadFileRequest) SetIotInstanceId(v string) *GetDownloadFileRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetDownloadFileRequest) SetLongJobId(v string) *GetDownloadFileRequest {
	s.LongJobId = &v
	return s
}

type GetDownloadFileShrinkRequest struct {
	ContextShrink *string `json:"Context,omitempty" xml:"Context,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	LongJobId     *string `json:"LongJobId,omitempty" xml:"LongJobId,omitempty"`
}

func (s GetDownloadFileShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadFileShrinkRequest) GoString() string {
	return s.String()
}

func (s *GetDownloadFileShrinkRequest) SetContextShrink(v string) *GetDownloadFileShrinkRequest {
	s.ContextShrink = &v
	return s
}

func (s *GetDownloadFileShrinkRequest) SetIotInstanceId(v string) *GetDownloadFileShrinkRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetDownloadFileShrinkRequest) SetLongJobId(v string) *GetDownloadFileShrinkRequest {
	s.LongJobId = &v
	return s
}

type GetDownloadFileResponseBody struct {
	Code         *string                          `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *GetDownloadFileResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                          `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                          `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                            `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetDownloadFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadFileResponseBody) GoString() string {
	return s.String()
}

func (s *GetDownloadFileResponseBody) SetCode(v string) *GetDownloadFileResponseBody {
	s.Code = &v
	return s
}

func (s *GetDownloadFileResponseBody) SetData(v *GetDownloadFileResponseBodyData) *GetDownloadFileResponseBody {
	s.Data = v
	return s
}

func (s *GetDownloadFileResponseBody) SetErrorMessage(v string) *GetDownloadFileResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetDownloadFileResponseBody) SetRequestId(v string) *GetDownloadFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetDownloadFileResponseBody) SetSuccess(v bool) *GetDownloadFileResponseBody {
	s.Success = &v
	return s
}

type GetDownloadFileResponseBodyData struct {
	AsyncExecute       *bool                                        `json:"AsyncExecute,omitempty" xml:"AsyncExecute,omitempty"`
	BeginTime          *int64                                       `json:"BeginTime,omitempty" xml:"BeginTime,omitempty"`
	CsvFileName        *string                                      `json:"CsvFileName,omitempty" xml:"CsvFileName,omitempty"`
	CsvUrl             *string                                      `json:"CsvUrl,omitempty" xml:"CsvUrl,omitempty"`
	DatasetId          *string                                      `json:"DatasetId,omitempty" xml:"DatasetId,omitempty"`
	EndTime            *int64                                       `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	Header             []*GetDownloadFileResponseBodyDataHeader     `json:"Header,omitempty" xml:"Header,omitempty" type:"Repeated"`
	LongJobId          *string                                      `json:"LongJobId,omitempty" xml:"LongJobId,omitempty"`
	PageNo             *int32                                       `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	PageSize           *int32                                       `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	PreviewSize        *int32                                       `json:"PreviewSize,omitempty" xml:"PreviewSize,omitempty"`
	QuerySetting       *GetDownloadFileResponseBodyDataQuerySetting `json:"QuerySetting,omitempty" xml:"QuerySetting,omitempty" type:"Struct"`
	Result             []map[string]interface{}                     `json:"Result,omitempty" xml:"Result,omitempty" type:"Repeated"`
	ResultDataInString *string                                      `json:"ResultDataInString,omitempty" xml:"ResultDataInString,omitempty"`
	Status             *int32                                       `json:"Status,omitempty" xml:"Status,omitempty"`
	TotalCount         *int64                                       `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetDownloadFileResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadFileResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetDownloadFileResponseBodyData) SetAsyncExecute(v bool) *GetDownloadFileResponseBodyData {
	s.AsyncExecute = &v
	return s
}

func (s *GetDownloadFileResponseBodyData) SetBeginTime(v int64) *GetDownloadFileResponseBodyData {
	s.BeginTime = &v
	return s
}

func (s *GetDownloadFileResponseBodyData) SetCsvFileName(v string) *GetDownloadFileResponseBodyData {
	s.CsvFileName = &v
	return s
}

func (s *GetDownloadFileResponseBodyData) SetCsvUrl(v string) *GetDownloadFileResponseBodyData {
	s.CsvUrl = &v
	return s
}

func (s *GetDownloadFileResponseBodyData) SetDatasetId(v string) *GetDownloadFileResponseBodyData {
	s.DatasetId = &v
	return s
}

func (s *GetDownloadFileResponseBodyData) SetEndTime(v int64) *GetDownloadFileResponseBodyData {
	s.EndTime = &v
	return s
}

func (s *GetDownloadFileResponseBodyData) SetHeader(v []*GetDownloadFileResponseBodyDataHeader) *GetDownloadFileResponseBodyData {
	s.Header = v
	return s
}

func (s *GetDownloadFileResponseBodyData) SetLongJobId(v string) *GetDownloadFileResponseBodyData {
	s.LongJobId = &v
	return s
}

func (s *GetDownloadFileResponseBodyData) SetPageNo(v int32) *GetDownloadFileResponseBodyData {
	s.PageNo = &v
	return s
}

func (s *GetDownloadFileResponseBodyData) SetPageSize(v int32) *GetDownloadFileResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetDownloadFileResponseBodyData) SetPreviewSize(v int32) *GetDownloadFileResponseBodyData {
	s.PreviewSize = &v
	return s
}

func (s *GetDownloadFileResponseBodyData) SetQuerySetting(v *GetDownloadFileResponseBodyDataQuerySetting) *GetDownloadFileResponseBodyData {
	s.QuerySetting = v
	return s
}

func (s *GetDownloadFileResponseBodyData) SetResult(v []map[string]interface{}) *GetDownloadFileResponseBodyData {
	s.Result = v
	return s
}

func (s *GetDownloadFileResponseBodyData) SetResultDataInString(v string) *GetDownloadFileResponseBodyData {
	s.ResultDataInString = &v
	return s
}

func (s *GetDownloadFileResponseBodyData) SetStatus(v int32) *GetDownloadFileResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetDownloadFileResponseBodyData) SetTotalCount(v int64) *GetDownloadFileResponseBodyData {
	s.TotalCount = &v
	return s
}

type GetDownloadFileResponseBodyDataHeader struct {
	Alias        *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	DimDateClass *string `json:"DimDateClass,omitempty" xml:"DimDateClass,omitempty"`
	FieldName    *string `json:"FieldName,omitempty" xml:"FieldName,omitempty"`
	FieldType    *string `json:"FieldType,omitempty" xml:"FieldType,omitempty"`
	GeoClass     *string `json:"GeoClass,omitempty" xml:"GeoClass,omitempty"`
	TimeClass    *string `json:"TimeClass,omitempty" xml:"TimeClass,omitempty"`
	TypeClass    *string `json:"TypeClass,omitempty" xml:"TypeClass,omitempty"`
}

func (s GetDownloadFileResponseBodyDataHeader) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadFileResponseBodyDataHeader) GoString() string {
	return s.String()
}

func (s *GetDownloadFileResponseBodyDataHeader) SetAlias(v string) *GetDownloadFileResponseBodyDataHeader {
	s.Alias = &v
	return s
}

func (s *GetDownloadFileResponseBodyDataHeader) SetDimDateClass(v string) *GetDownloadFileResponseBodyDataHeader {
	s.DimDateClass = &v
	return s
}

func (s *GetDownloadFileResponseBodyDataHeader) SetFieldName(v string) *GetDownloadFileResponseBodyDataHeader {
	s.FieldName = &v
	return s
}

func (s *GetDownloadFileResponseBodyDataHeader) SetFieldType(v string) *GetDownloadFileResponseBodyDataHeader {
	s.FieldType = &v
	return s
}

func (s *GetDownloadFileResponseBodyDataHeader) SetGeoClass(v string) *GetDownloadFileResponseBodyDataHeader {
	s.GeoClass = &v
	return s
}

func (s *GetDownloadFileResponseBodyDataHeader) SetTimeClass(v string) *GetDownloadFileResponseBodyDataHeader {
	s.TimeClass = &v
	return s
}

func (s *GetDownloadFileResponseBodyDataHeader) SetTypeClass(v string) *GetDownloadFileResponseBodyDataHeader {
	s.TypeClass = &v
	return s
}

type GetDownloadFileResponseBodyDataQuerySetting struct {
	AstExpr         []*GetDownloadFileResponseBodyDataQuerySettingAstExpr         `json:"AstExpr,omitempty" xml:"AstExpr,omitempty" type:"Repeated"`
	SelectedHeaders []*GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders `json:"SelectedHeaders,omitempty" xml:"SelectedHeaders,omitempty" type:"Repeated"`
}

func (s GetDownloadFileResponseBodyDataQuerySetting) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadFileResponseBodyDataQuerySetting) GoString() string {
	return s.String()
}

func (s *GetDownloadFileResponseBodyDataQuerySetting) SetAstExpr(v []*GetDownloadFileResponseBodyDataQuerySettingAstExpr) *GetDownloadFileResponseBodyDataQuerySetting {
	s.AstExpr = v
	return s
}

func (s *GetDownloadFileResponseBodyDataQuerySetting) SetSelectedHeaders(v []*GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders) *GetDownloadFileResponseBodyDataQuerySetting {
	s.SelectedHeaders = v
	return s
}

type GetDownloadFileResponseBodyDataQuerySettingAstExpr struct {
	Expr     *string `json:"Expr,omitempty" xml:"Expr,omitempty"`
	ExprType *string `json:"ExprType,omitempty" xml:"ExprType,omitempty"`
}

func (s GetDownloadFileResponseBodyDataQuerySettingAstExpr) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadFileResponseBodyDataQuerySettingAstExpr) GoString() string {
	return s.String()
}

func (s *GetDownloadFileResponseBodyDataQuerySettingAstExpr) SetExpr(v string) *GetDownloadFileResponseBodyDataQuerySettingAstExpr {
	s.Expr = &v
	return s
}

func (s *GetDownloadFileResponseBodyDataQuerySettingAstExpr) SetExprType(v string) *GetDownloadFileResponseBodyDataQuerySettingAstExpr {
	s.ExprType = &v
	return s
}

type GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders struct {
	Alias        *string `json:"Alias,omitempty" xml:"Alias,omitempty"`
	DimDateClass *string `json:"DimDateClass,omitempty" xml:"DimDateClass,omitempty"`
	FieldName    *string `json:"FieldName,omitempty" xml:"FieldName,omitempty"`
	FieldType    *string `json:"FieldType,omitempty" xml:"FieldType,omitempty"`
	GeoClass     *string `json:"GeoClass,omitempty" xml:"GeoClass,omitempty"`
	TimeClass    *string `json:"TimeClass,omitempty" xml:"TimeClass,omitempty"`
}

func (s GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders) GoString() string {
	return s.String()
}

func (s *GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders) SetAlias(v string) *GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders {
	s.Alias = &v
	return s
}

func (s *GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders) SetDimDateClass(v string) *GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders {
	s.DimDateClass = &v
	return s
}

func (s *GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders) SetFieldName(v string) *GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders {
	s.FieldName = &v
	return s
}

func (s *GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders) SetFieldType(v string) *GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders {
	s.FieldType = &v
	return s
}

func (s *GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders) SetGeoClass(v string) *GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders {
	s.GeoClass = &v
	return s
}

func (s *GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders) SetTimeClass(v string) *GetDownloadFileResponseBodyDataQuerySettingSelectedHeaders {
	s.TimeClass = &v
	return s
}

type GetDownloadFileResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetDownloadFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetDownloadFileResponse) String() string {
	return tea.Prettify(s)
}

func (s GetDownloadFileResponse) GoString() string {
	return s.String()
}

func (s *GetDownloadFileResponse) SetHeaders(v map[string]*string) *GetDownloadFileResponse {
	s.Headers = v
	return s
}

func (s *GetDownloadFileResponse) SetStatusCode(v int32) *GetDownloadFileResponse {
	s.StatusCode = &v
	return s
}

func (s *GetDownloadFileResponse) SetBody(v *GetDownloadFileResponseBody) *GetDownloadFileResponse {
	s.Body = v
	return s
}

type GetEdgeDriverVersionRequest struct {
	// The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver whose version information you want to query and obtain the driver ID.
	//
	// You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The version number of the driver.
	DriverVersion *string `json:"DriverVersion,omitempty" xml:"DriverVersion,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s GetEdgeDriverVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeDriverVersionRequest) GoString() string {
	return s.String()
}

func (s *GetEdgeDriverVersionRequest) SetDriverId(v string) *GetEdgeDriverVersionRequest {
	s.DriverId = &v
	return s
}

func (s *GetEdgeDriverVersionRequest) SetDriverVersion(v string) *GetEdgeDriverVersionRequest {
	s.DriverVersion = &v
	return s
}

func (s *GetEdgeDriverVersionRequest) SetIotInstanceId(v string) *GetEdgeDriverVersionRequest {
	s.IotInstanceId = &v
	return s
}

type GetEdgeDriverVersionResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned if the call was successful.
	Data *GetEdgeDriverVersionResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetEdgeDriverVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeDriverVersionResponseBody) GoString() string {
	return s.String()
}

func (s *GetEdgeDriverVersionResponseBody) SetCode(v string) *GetEdgeDriverVersionResponseBody {
	s.Code = &v
	return s
}

func (s *GetEdgeDriverVersionResponseBody) SetData(v *GetEdgeDriverVersionResponseBodyData) *GetEdgeDriverVersionResponseBody {
	s.Data = v
	return s
}

func (s *GetEdgeDriverVersionResponseBody) SetErrorMessage(v string) *GetEdgeDriverVersionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetEdgeDriverVersionResponseBody) SetRequestId(v string) *GetEdgeDriverVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetEdgeDriverVersionResponseBody) SetSuccess(v bool) *GetEdgeDriverVersionResponseBody {
	s.Success = &v
	return s
}

type GetEdgeDriverVersionResponseBodyData struct {
	// The Java Virtual Machine (JVM) startup parameter.
	Argument *string `json:"Argument,omitempty" xml:"Argument,omitempty"`
	// The rule for verifying configurations. The value is a JSON string in the following format:
	//
	// `{"deviceConfig":{"required":false},"driverConfig":{"required":false}`
	//
	// The JSON string contains the following parameters:
	//
	// *   driverConfig: the rule for verifying the configuration of the driver when the driver is to be deployed in an edge instance.
	// *   deviceConfig: the rule for verifying the configurations of devices that use the driver when the driver is to be deployed in an edge instance.
	ConfigCheckRule *string `json:"ConfigCheckRule,omitempty" xml:"ConfigCheckRule,omitempty"`
	// The configuration of the container where the driver runs. The value is a JSON string. For more information about parameters in the JSON string, see the following parameter description of ContainerConfig.
	ContainerConfig *string `json:"ContainerConfig,omitempty" xml:"ContainerConfig,omitempty"`
	// The description of the driver.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The configuration of the driver. The value is a JSON string in the following format:
	//
	// `{"format":"JSON","content":"{}"}`
	//
	// The JSON string contains the following parameters:
	//
	// *   format: the format of the driver configuration. Valid values: KV (key-value pair), JSON (JSON string), and FILE (configuration file).
	// *   content: the content of the driver configuration. If the format parameter is set to KV or JSON, the value of this parameter is the configuration content. If the format parameter is set to FILE, the value of this parameter is the URL of the configuration file stored in Object Storage Service (OSS).
	DriverConfig *string `json:"DriverConfig,omitempty" xml:"DriverConfig,omitempty"`
	// The ID of the driver.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The version number of the driver.
	DriverVersion *string `json:"DriverVersion,omitempty" xml:"DriverVersion,omitempty"`
	// The earliest version of Link IoT Edge that is supported by the driver.
	EdgeVersion *string `json:"EdgeVersion,omitempty" xml:"EdgeVersion,omitempty"`
	// The UNIX timestamp when the driver was created.
	GmtCreateTimestamp *int64 `json:"GmtCreateTimestamp,omitempty" xml:"GmtCreateTimestamp,omitempty"`
	// The last UNIX timestamp when the driver was updated.
	GmtModifiedTimestamp *int64  `json:"GmtModifiedTimestamp,omitempty" xml:"GmtModifiedTimestamp,omitempty"`
	SourceConfig         *string `json:"SourceConfig,omitempty" xml:"SourceConfig,omitempty"`
	// The status of the driver version. Valid values:
	//
	// *   0: The driver version was not published.
	// *   1: The driver version was published.
	VersionState *string `json:"VersionState,omitempty" xml:"VersionState,omitempty"`
}

func (s GetEdgeDriverVersionResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeDriverVersionResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetEdgeDriverVersionResponseBodyData) SetArgument(v string) *GetEdgeDriverVersionResponseBodyData {
	s.Argument = &v
	return s
}

func (s *GetEdgeDriverVersionResponseBodyData) SetConfigCheckRule(v string) *GetEdgeDriverVersionResponseBodyData {
	s.ConfigCheckRule = &v
	return s
}

func (s *GetEdgeDriverVersionResponseBodyData) SetContainerConfig(v string) *GetEdgeDriverVersionResponseBodyData {
	s.ContainerConfig = &v
	return s
}

func (s *GetEdgeDriverVersionResponseBodyData) SetDescription(v string) *GetEdgeDriverVersionResponseBodyData {
	s.Description = &v
	return s
}

func (s *GetEdgeDriverVersionResponseBodyData) SetDriverConfig(v string) *GetEdgeDriverVersionResponseBodyData {
	s.DriverConfig = &v
	return s
}

func (s *GetEdgeDriverVersionResponseBodyData) SetDriverId(v string) *GetEdgeDriverVersionResponseBodyData {
	s.DriverId = &v
	return s
}

func (s *GetEdgeDriverVersionResponseBodyData) SetDriverVersion(v string) *GetEdgeDriverVersionResponseBodyData {
	s.DriverVersion = &v
	return s
}

func (s *GetEdgeDriverVersionResponseBodyData) SetEdgeVersion(v string) *GetEdgeDriverVersionResponseBodyData {
	s.EdgeVersion = &v
	return s
}

func (s *GetEdgeDriverVersionResponseBodyData) SetGmtCreateTimestamp(v int64) *GetEdgeDriverVersionResponseBodyData {
	s.GmtCreateTimestamp = &v
	return s
}

func (s *GetEdgeDriverVersionResponseBodyData) SetGmtModifiedTimestamp(v int64) *GetEdgeDriverVersionResponseBodyData {
	s.GmtModifiedTimestamp = &v
	return s
}

func (s *GetEdgeDriverVersionResponseBodyData) SetSourceConfig(v string) *GetEdgeDriverVersionResponseBodyData {
	s.SourceConfig = &v
	return s
}

func (s *GetEdgeDriverVersionResponseBodyData) SetVersionState(v string) *GetEdgeDriverVersionResponseBodyData {
	s.VersionState = &v
	return s
}

type GetEdgeDriverVersionResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetEdgeDriverVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetEdgeDriverVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeDriverVersionResponse) GoString() string {
	return s.String()
}

func (s *GetEdgeDriverVersionResponse) SetHeaders(v map[string]*string) *GetEdgeDriverVersionResponse {
	s.Headers = v
	return s
}

func (s *GetEdgeDriverVersionResponse) SetStatusCode(v int32) *GetEdgeDriverVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *GetEdgeDriverVersionResponse) SetBody(v *GetEdgeDriverVersionResponseBody) *GetEdgeDriverVersionResponse {
	s.Body = v
	return s
}

type GetEdgeInstanceRequest struct {
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance whose detailed information you want to query and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s GetEdgeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeInstanceRequest) GoString() string {
	return s.String()
}

func (s *GetEdgeInstanceRequest) SetInstanceId(v string) *GetEdgeInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *GetEdgeInstanceRequest) SetIotInstanceId(v string) *GetEdgeInstanceRequest {
	s.IotInstanceId = &v
	return s
}

type GetEdgeInstanceResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned if the call was successful.
	Data *GetEdgeInstanceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetEdgeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *GetEdgeInstanceResponseBody) SetCode(v string) *GetEdgeInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *GetEdgeInstanceResponseBody) SetData(v *GetEdgeInstanceResponseBodyData) *GetEdgeInstanceResponseBody {
	s.Data = v
	return s
}

func (s *GetEdgeInstanceResponseBody) SetErrorMessage(v string) *GetEdgeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetEdgeInstanceResponseBody) SetRequestId(v string) *GetEdgeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetEdgeInstanceResponseBody) SetSuccess(v bool) *GetEdgeInstanceResponseBody {
	s.Success = &v
	return s
}

type GetEdgeInstanceResponseBodyData struct {
	// Indicates whether the edge instance was enabled. Valid values:
	//
	// *   true: enabled
	// *   false: disabled
	BizEnable *bool `json:"BizEnable,omitempty" xml:"BizEnable,omitempty"`
	// The time when the edge instance was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The UNIX timestamp when the edge instance was created.
	GmtCreateTimestamp *int64 `json:"GmtCreateTimestamp,omitempty" xml:"GmtCreateTimestamp,omitempty"`
	// The last time when the edge instance was updated.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The last UNIX timestamp when the edge instance was updated.
	GmtModifiedTimestamp *int64 `json:"GmtModifiedTimestamp,omitempty" xml:"GmtModifiedTimestamp,omitempty"`
	// The ID of the edge instance.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The status of the latest deployment task. Valid values:
	//
	// *   0: The task was not started.
	// *   1: The task was being processed.
	// *   2: The task was successful.
	// *   3: The task failed.
	LatestDeploymentStatus *int32 `json:"LatestDeploymentStatus,omitempty" xml:"LatestDeploymentStatus,omitempty"`
	// The type of the latest deployment task. Valid values:
	//
	// *   deploy: deploys the edge instance.
	// *   reset: resets the edge instance.
	LatestDeploymentType *string `json:"LatestDeploymentType,omitempty" xml:"LatestDeploymentType,omitempty"`
	// The name of the edge instance.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the RAM role.
	RoleArn *string `json:"RoleArn,omitempty" xml:"RoleArn,omitempty"`
	// The time when the RAM role was attached to IoT Platform.
	RoleAttachTime *string `json:"RoleAttachTime,omitempty" xml:"RoleAttachTime,omitempty"`
	// The UNIX timestamp when the RAM role was attached to IoT Platform.
	RoleAttachTimestamp *int64 `json:"RoleAttachTimestamp,omitempty" xml:"RoleAttachTimestamp,omitempty"`
	// The name of the RAM role.
	RoleName *string `json:"RoleName,omitempty" xml:"RoleName,omitempty"`
	// The specifications of the edge instance. Valid values:
	//
	// *   10: Lite Edition
	// *   20: Standard Edition
	// *   30: Pro Edition
	Spec *int32 `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The tags of the edge instance. Each tag is a `key-value` pair. Multiple tags are separated with commas(,). Example: `k1:v1,k2:v2`.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// Indicates whether you own the edge instance or you are authorized to use the edge instance. Valid values:
	//
	// *   0: You own the edge instance.
	// *   1: You are authorized to use the edge instance.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetEdgeInstanceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeInstanceResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetEdgeInstanceResponseBodyData) SetBizEnable(v bool) *GetEdgeInstanceResponseBodyData {
	s.BizEnable = &v
	return s
}

func (s *GetEdgeInstanceResponseBodyData) SetGmtCreate(v string) *GetEdgeInstanceResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetEdgeInstanceResponseBodyData) SetGmtCreateTimestamp(v int64) *GetEdgeInstanceResponseBodyData {
	s.GmtCreateTimestamp = &v
	return s
}

func (s *GetEdgeInstanceResponseBodyData) SetGmtModified(v string) *GetEdgeInstanceResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetEdgeInstanceResponseBodyData) SetGmtModifiedTimestamp(v int64) *GetEdgeInstanceResponseBodyData {
	s.GmtModifiedTimestamp = &v
	return s
}

func (s *GetEdgeInstanceResponseBodyData) SetInstanceId(v string) *GetEdgeInstanceResponseBodyData {
	s.InstanceId = &v
	return s
}

func (s *GetEdgeInstanceResponseBodyData) SetLatestDeploymentStatus(v int32) *GetEdgeInstanceResponseBodyData {
	s.LatestDeploymentStatus = &v
	return s
}

func (s *GetEdgeInstanceResponseBodyData) SetLatestDeploymentType(v string) *GetEdgeInstanceResponseBodyData {
	s.LatestDeploymentType = &v
	return s
}

func (s *GetEdgeInstanceResponseBodyData) SetName(v string) *GetEdgeInstanceResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetEdgeInstanceResponseBodyData) SetRoleArn(v string) *GetEdgeInstanceResponseBodyData {
	s.RoleArn = &v
	return s
}

func (s *GetEdgeInstanceResponseBodyData) SetRoleAttachTime(v string) *GetEdgeInstanceResponseBodyData {
	s.RoleAttachTime = &v
	return s
}

func (s *GetEdgeInstanceResponseBodyData) SetRoleAttachTimestamp(v int64) *GetEdgeInstanceResponseBodyData {
	s.RoleAttachTimestamp = &v
	return s
}

func (s *GetEdgeInstanceResponseBodyData) SetRoleName(v string) *GetEdgeInstanceResponseBodyData {
	s.RoleName = &v
	return s
}

func (s *GetEdgeInstanceResponseBodyData) SetSpec(v int32) *GetEdgeInstanceResponseBodyData {
	s.Spec = &v
	return s
}

func (s *GetEdgeInstanceResponseBodyData) SetTags(v string) *GetEdgeInstanceResponseBodyData {
	s.Tags = &v
	return s
}

func (s *GetEdgeInstanceResponseBodyData) SetType(v string) *GetEdgeInstanceResponseBodyData {
	s.Type = &v
	return s
}

type GetEdgeInstanceResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetEdgeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetEdgeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeInstanceResponse) GoString() string {
	return s.String()
}

func (s *GetEdgeInstanceResponse) SetHeaders(v map[string]*string) *GetEdgeInstanceResponse {
	s.Headers = v
	return s
}

func (s *GetEdgeInstanceResponse) SetStatusCode(v int32) *GetEdgeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetEdgeInstanceResponse) SetBody(v *GetEdgeInstanceResponseBody) *GetEdgeInstanceResponse {
	s.Body = v
	return s
}

type GetEdgeInstanceDeploymentRequest struct {
	// The ID of the deployment task. You can call the [QueryEdgeInstanceHistoricDeployment](~~135275~~) operation to query the ID of a deployment task.
	DeploymentId *string `json:"DeploymentId,omitempty" xml:"DeploymentId,omitempty"`
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance for which you want to query detailed information about a deployment task and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s GetEdgeInstanceDeploymentRequest) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeInstanceDeploymentRequest) GoString() string {
	return s.String()
}

func (s *GetEdgeInstanceDeploymentRequest) SetDeploymentId(v string) *GetEdgeInstanceDeploymentRequest {
	s.DeploymentId = &v
	return s
}

func (s *GetEdgeInstanceDeploymentRequest) SetInstanceId(v string) *GetEdgeInstanceDeploymentRequest {
	s.InstanceId = &v
	return s
}

func (s *GetEdgeInstanceDeploymentRequest) SetIotInstanceId(v string) *GetEdgeInstanceDeploymentRequest {
	s.IotInstanceId = &v
	return s
}

type GetEdgeInstanceDeploymentResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned if the call was successful.
	Data *GetEdgeInstanceDeploymentResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetEdgeInstanceDeploymentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeInstanceDeploymentResponseBody) GoString() string {
	return s.String()
}

func (s *GetEdgeInstanceDeploymentResponseBody) SetCode(v string) *GetEdgeInstanceDeploymentResponseBody {
	s.Code = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBody) SetData(v *GetEdgeInstanceDeploymentResponseBodyData) *GetEdgeInstanceDeploymentResponseBody {
	s.Data = v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBody) SetErrorMessage(v string) *GetEdgeInstanceDeploymentResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBody) SetRequestId(v string) *GetEdgeInstanceDeploymentResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBody) SetSuccess(v bool) *GetEdgeInstanceDeploymentResponseBody {
	s.Success = &v
	return s
}

type GetEdgeInstanceDeploymentResponseBodyData struct {
	// The ID of the deployment task.
	DeploymentId *string `json:"DeploymentId,omitempty" xml:"DeploymentId,omitempty"`
	// The description of the deployment task.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The time when the deployment task was complete.
	GmtCompleted *string `json:"GmtCompleted,omitempty" xml:"GmtCompleted,omitempty"`
	// The UNIX timestamp when the deployment task was complete.
	GmtCompletedTimestamp *int64 `json:"GmtCompletedTimestamp,omitempty" xml:"GmtCompletedTimestamp,omitempty"`
	// The time when the deployment task was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The UNIX timestamp when the deployment task was created.
	GmtCreateTimestamp *int64 `json:"GmtCreateTimestamp,omitempty" xml:"GmtCreateTimestamp,omitempty"`
	// The last time when the deployment task was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The last UNIX timestamp when the deployment task was modified.
	GmtModifiedTimestamp *int64 `json:"GmtModifiedTimestamp,omitempty" xml:"GmtModifiedTimestamp,omitempty"`
	// The status of the deployment task.
	//
	// *   0: The task was not started.
	// *   1: The task was being processed.
	// *   2: The task was successful.
	// *   3: The task failed.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The list of deployment subtasks.
	TaskList []*GetEdgeInstanceDeploymentResponseBodyDataTaskList `json:"TaskList,omitempty" xml:"TaskList,omitempty" type:"Repeated"`
	// The type of the deployment task.
	//
	// *   deploy: deploys the edge instance.
	// *   reset: resets the edge instance.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetEdgeInstanceDeploymentResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeInstanceDeploymentResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetEdgeInstanceDeploymentResponseBodyData) SetDeploymentId(v string) *GetEdgeInstanceDeploymentResponseBodyData {
	s.DeploymentId = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyData) SetDescription(v string) *GetEdgeInstanceDeploymentResponseBodyData {
	s.Description = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyData) SetGmtCompleted(v string) *GetEdgeInstanceDeploymentResponseBodyData {
	s.GmtCompleted = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyData) SetGmtCompletedTimestamp(v int64) *GetEdgeInstanceDeploymentResponseBodyData {
	s.GmtCompletedTimestamp = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyData) SetGmtCreate(v string) *GetEdgeInstanceDeploymentResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyData) SetGmtCreateTimestamp(v int64) *GetEdgeInstanceDeploymentResponseBodyData {
	s.GmtCreateTimestamp = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyData) SetGmtModified(v string) *GetEdgeInstanceDeploymentResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyData) SetGmtModifiedTimestamp(v int64) *GetEdgeInstanceDeploymentResponseBodyData {
	s.GmtModifiedTimestamp = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyData) SetStatus(v int32) *GetEdgeInstanceDeploymentResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyData) SetTaskList(v []*GetEdgeInstanceDeploymentResponseBodyDataTaskList) *GetEdgeInstanceDeploymentResponseBodyData {
	s.TaskList = v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyData) SetType(v string) *GetEdgeInstanceDeploymentResponseBodyData {
	s.Type = &v
	return s
}

type GetEdgeInstanceDeploymentResponseBodyDataTaskList struct {
	// The ID of the gateway.
	GatewayId *string `json:"GatewayId,omitempty" xml:"GatewayId,omitempty"`
	// The time when the deployment subtask was complete.
	GmtCompleted *string `json:"GmtCompleted,omitempty" xml:"GmtCompleted,omitempty"`
	// The UNIX timestamp when the deployment subtask was complete.
	GmtCompletedTimestamp *int64 `json:"GmtCompletedTimestamp,omitempty" xml:"GmtCompletedTimestamp,omitempty"`
	// The time when the deployment subtask was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The UNIX timestamp when the deployment subtask was created.
	GmtCreateTimestamp *int64 `json:"GmtCreateTimestamp,omitempty" xml:"GmtCreateTimestamp,omitempty"`
	// The last time when the deployment subtask was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The last UNIX timestamp when the deployment subtask was modified.
	GmtModifiedTimestamp *int64 `json:"GmtModifiedTimestamp,omitempty" xml:"GmtModifiedTimestamp,omitempty"`
	// The list of deployment task snapshots.
	ResourceSnapshotList []*GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList `json:"ResourceSnapshotList,omitempty" xml:"ResourceSnapshotList,omitempty" type:"Repeated"`
	// The stage of the deployment subtask.
	//
	// *   0: The subtask was not started.
	// *   8: The subtask was being assembled.
	// *   16: The subtask was being packaged.
	// *   24: The subtask was being dispatched.
	// *   32: The subtask was complete.
	Stage *int32 `json:"Stage,omitempty" xml:"Stage,omitempty"`
	// The status of the deployment subtask.
	//
	// *   0: The subtask was in the initial state.
	// *   1: The subtask was being processed.
	// *   2: The subtask was successful.
	// *   3: The subtask failed.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the deployment subtask.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s GetEdgeInstanceDeploymentResponseBodyDataTaskList) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeInstanceDeploymentResponseBodyDataTaskList) GoString() string {
	return s.String()
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskList) SetGatewayId(v string) *GetEdgeInstanceDeploymentResponseBodyDataTaskList {
	s.GatewayId = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskList) SetGmtCompleted(v string) *GetEdgeInstanceDeploymentResponseBodyDataTaskList {
	s.GmtCompleted = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskList) SetGmtCompletedTimestamp(v int64) *GetEdgeInstanceDeploymentResponseBodyDataTaskList {
	s.GmtCompletedTimestamp = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskList) SetGmtCreate(v string) *GetEdgeInstanceDeploymentResponseBodyDataTaskList {
	s.GmtCreate = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskList) SetGmtCreateTimestamp(v int64) *GetEdgeInstanceDeploymentResponseBodyDataTaskList {
	s.GmtCreateTimestamp = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskList) SetGmtModified(v string) *GetEdgeInstanceDeploymentResponseBodyDataTaskList {
	s.GmtModified = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskList) SetGmtModifiedTimestamp(v int64) *GetEdgeInstanceDeploymentResponseBodyDataTaskList {
	s.GmtModifiedTimestamp = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskList) SetResourceSnapshotList(v []*GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) *GetEdgeInstanceDeploymentResponseBodyDataTaskList {
	s.ResourceSnapshotList = v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskList) SetStage(v int32) *GetEdgeInstanceDeploymentResponseBodyDataTaskList {
	s.Stage = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskList) SetStatus(v int32) *GetEdgeInstanceDeploymentResponseBodyDataTaskList {
	s.Status = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskList) SetTaskId(v string) *GetEdgeInstanceDeploymentResponseBodyDataTaskList {
	s.TaskId = &v
	return s
}

type GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList struct {
	// The time when the deployment task snapshot was complete.
	GmtCompleted *string `json:"GmtCompleted,omitempty" xml:"GmtCompleted,omitempty"`
	// The UNIX timestamp when the deployment task snapshot was complete.
	GmtCompletedTimestamp *int64 `json:"GmtCompletedTimestamp,omitempty" xml:"GmtCompletedTimestamp,omitempty"`
	// The time when the deployment task snapshot was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The UNIX timestamp when the deployment task snapshot was created.
	GmtCreateTimestamp *int64 `json:"GmtCreateTimestamp,omitempty" xml:"GmtCreateTimestamp,omitempty"`
	// The last time when the deployment task snapshot was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The last UNIX timestamp when the deployment task snapshot was modified.
	GmtModifiedTimestamp *int64 `json:"GmtModifiedTimestamp,omitempty" xml:"GmtModifiedTimestamp,omitempty"`
	// The logs of resource deployment.
	Log *string `json:"Log,omitempty" xml:"Log,omitempty"`
	// The type of the operation.
	//
	// *   0: deploys resources.
	// *   1: deletes resources.
	OperateType *int32 `json:"OperateType,omitempty" xml:"OperateType,omitempty"`
	// The ID of the resource.
	ResourceId *string `json:"ResourceId,omitempty" xml:"ResourceId,omitempty"`
	// The name of the resource.
	ResourceName *string `json:"ResourceName,omitempty" xml:"ResourceName,omitempty"`
	// The type of the resource.
	ResourceType *string `json:"ResourceType,omitempty" xml:"ResourceType,omitempty"`
	// The ID of the deployment task snapshot.
	SnapshotId *string `json:"SnapshotId,omitempty" xml:"SnapshotId,omitempty"`
	// The stage of the snapshot task.
	//
	// *   0: The snapshot task was in the initial state.
	// *   8: The snapshot task was being assembled.
	// *   16: The snapshot task was being packaged.
	// *   24: The snapshot task was being dispatched.
	// *   32: The snapshot task was complete.
	Stage *int32 `json:"Stage,omitempty" xml:"Stage,omitempty"`
	// The status of the snapshot task.
	//
	// *   0: The snapshot task was not started.
	// *   1: The snapshot task was being processed.
	// *   2: The snapshot task was successful.
	// *   3: The snapshot task failed.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) GoString() string {
	return s.String()
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) SetGmtCompleted(v string) *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList {
	s.GmtCompleted = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) SetGmtCompletedTimestamp(v int64) *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList {
	s.GmtCompletedTimestamp = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) SetGmtCreate(v string) *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList {
	s.GmtCreate = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) SetGmtCreateTimestamp(v int64) *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList {
	s.GmtCreateTimestamp = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) SetGmtModified(v string) *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList {
	s.GmtModified = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) SetGmtModifiedTimestamp(v int64) *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList {
	s.GmtModifiedTimestamp = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) SetLog(v string) *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList {
	s.Log = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) SetOperateType(v int32) *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList {
	s.OperateType = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) SetResourceId(v string) *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList {
	s.ResourceId = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) SetResourceName(v string) *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList {
	s.ResourceName = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) SetResourceType(v string) *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList {
	s.ResourceType = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) SetSnapshotId(v string) *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList {
	s.SnapshotId = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) SetStage(v int32) *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList {
	s.Stage = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList) SetStatus(v int32) *GetEdgeInstanceDeploymentResponseBodyDataTaskListResourceSnapshotList {
	s.Status = &v
	return s
}

type GetEdgeInstanceDeploymentResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetEdgeInstanceDeploymentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetEdgeInstanceDeploymentResponse) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeInstanceDeploymentResponse) GoString() string {
	return s.String()
}

func (s *GetEdgeInstanceDeploymentResponse) SetHeaders(v map[string]*string) *GetEdgeInstanceDeploymentResponse {
	s.Headers = v
	return s
}

func (s *GetEdgeInstanceDeploymentResponse) SetStatusCode(v int32) *GetEdgeInstanceDeploymentResponse {
	s.StatusCode = &v
	return s
}

func (s *GetEdgeInstanceDeploymentResponse) SetBody(v *GetEdgeInstanceDeploymentResponseBody) *GetEdgeInstanceDeploymentResponse {
	s.Body = v
	return s
}

type GetEdgeInstanceMessageRoutingRequest struct {
	InstanceId    *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	RouteId       *int64  `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
}

func (s GetEdgeInstanceMessageRoutingRequest) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeInstanceMessageRoutingRequest) GoString() string {
	return s.String()
}

func (s *GetEdgeInstanceMessageRoutingRequest) SetInstanceId(v string) *GetEdgeInstanceMessageRoutingRequest {
	s.InstanceId = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingRequest) SetIotInstanceId(v string) *GetEdgeInstanceMessageRoutingRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingRequest) SetRouteId(v int64) *GetEdgeInstanceMessageRoutingRequest {
	s.RouteId = &v
	return s
}

type GetEdgeInstanceMessageRoutingResponseBody struct {
	Code         *string                                        `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *GetEdgeInstanceMessageRoutingResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                        `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                        `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                          `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetEdgeInstanceMessageRoutingResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeInstanceMessageRoutingResponseBody) GoString() string {
	return s.String()
}

func (s *GetEdgeInstanceMessageRoutingResponseBody) SetCode(v string) *GetEdgeInstanceMessageRoutingResponseBody {
	s.Code = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBody) SetData(v *GetEdgeInstanceMessageRoutingResponseBodyData) *GetEdgeInstanceMessageRoutingResponseBody {
	s.Data = v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBody) SetErrorMessage(v string) *GetEdgeInstanceMessageRoutingResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBody) SetRequestId(v string) *GetEdgeInstanceMessageRoutingResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBody) SetSuccess(v bool) *GetEdgeInstanceMessageRoutingResponseBody {
	s.Success = &v
	return s
}

type GetEdgeInstanceMessageRoutingResponseBodyData struct {
	GmtCreate            *string                                                    `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtCreateTimestamp   *int64                                                     `json:"GmtCreateTimestamp,omitempty" xml:"GmtCreateTimestamp,omitempty"`
	GmtModified          *string                                                    `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	GmtModifiedTimestamp *int64                                                     `json:"GmtModifiedTimestamp,omitempty" xml:"GmtModifiedTimestamp,omitempty"`
	Name                 *string                                                    `json:"Name,omitempty" xml:"Name,omitempty"`
	RouteContext         *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext `json:"RouteContext,omitempty" xml:"RouteContext,omitempty" type:"Struct"`
	SourceData           *string                                                    `json:"SourceData,omitempty" xml:"SourceData,omitempty"`
	SourceType           *string                                                    `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	TargetData           *string                                                    `json:"TargetData,omitempty" xml:"TargetData,omitempty"`
	TargetType           *string                                                    `json:"TargetType,omitempty" xml:"TargetType,omitempty"`
	TopicFilter          *string                                                    `json:"TopicFilter,omitempty" xml:"TopicFilter,omitempty"`
}

func (s GetEdgeInstanceMessageRoutingResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeInstanceMessageRoutingResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyData) SetGmtCreate(v string) *GetEdgeInstanceMessageRoutingResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyData) SetGmtCreateTimestamp(v int64) *GetEdgeInstanceMessageRoutingResponseBodyData {
	s.GmtCreateTimestamp = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyData) SetGmtModified(v string) *GetEdgeInstanceMessageRoutingResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyData) SetGmtModifiedTimestamp(v int64) *GetEdgeInstanceMessageRoutingResponseBodyData {
	s.GmtModifiedTimestamp = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyData) SetName(v string) *GetEdgeInstanceMessageRoutingResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyData) SetRouteContext(v *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext) *GetEdgeInstanceMessageRoutingResponseBodyData {
	s.RouteContext = v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyData) SetSourceData(v string) *GetEdgeInstanceMessageRoutingResponseBodyData {
	s.SourceData = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyData) SetSourceType(v string) *GetEdgeInstanceMessageRoutingResponseBodyData {
	s.SourceType = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyData) SetTargetData(v string) *GetEdgeInstanceMessageRoutingResponseBodyData {
	s.TargetData = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyData) SetTargetType(v string) *GetEdgeInstanceMessageRoutingResponseBodyData {
	s.TargetType = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyData) SetTopicFilter(v string) *GetEdgeInstanceMessageRoutingResponseBodyData {
	s.TopicFilter = &v
	return s
}

type GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext struct {
	Qos                   *string `json:"Qos,omitempty" xml:"Qos,omitempty"`
	SourceApplicationName *string `json:"SourceApplicationName,omitempty" xml:"SourceApplicationName,omitempty"`
	SourceFcFunctionName  *string `json:"SourceFcFunctionName,omitempty" xml:"SourceFcFunctionName,omitempty"`
	SourceFcServiceName   *string `json:"SourceFcServiceName,omitempty" xml:"SourceFcServiceName,omitempty"`
	TargetApplicationName *string `json:"TargetApplicationName,omitempty" xml:"TargetApplicationName,omitempty"`
	TargetFcFunctionName  *string `json:"TargetFcFunctionName,omitempty" xml:"TargetFcFunctionName,omitempty"`
	TargetFcServiceName   *string `json:"TargetFcServiceName,omitempty" xml:"TargetFcServiceName,omitempty"`
}

func (s GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext) GoString() string {
	return s.String()
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext) SetQos(v string) *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext {
	s.Qos = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext) SetSourceApplicationName(v string) *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext {
	s.SourceApplicationName = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext) SetSourceFcFunctionName(v string) *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext {
	s.SourceFcFunctionName = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext) SetSourceFcServiceName(v string) *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext {
	s.SourceFcServiceName = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext) SetTargetApplicationName(v string) *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext {
	s.TargetApplicationName = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext) SetTargetFcFunctionName(v string) *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext {
	s.TargetFcFunctionName = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext) SetTargetFcServiceName(v string) *GetEdgeInstanceMessageRoutingResponseBodyDataRouteContext {
	s.TargetFcServiceName = &v
	return s
}

type GetEdgeInstanceMessageRoutingResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetEdgeInstanceMessageRoutingResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetEdgeInstanceMessageRoutingResponse) String() string {
	return tea.Prettify(s)
}

func (s GetEdgeInstanceMessageRoutingResponse) GoString() string {
	return s.String()
}

func (s *GetEdgeInstanceMessageRoutingResponse) SetHeaders(v map[string]*string) *GetEdgeInstanceMessageRoutingResponse {
	s.Headers = v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponse) SetStatusCode(v int32) *GetEdgeInstanceMessageRoutingResponse {
	s.StatusCode = &v
	return s
}

func (s *GetEdgeInstanceMessageRoutingResponse) SetBody(v *GetEdgeInstanceMessageRoutingResponseBody) *GetEdgeInstanceMessageRoutingResponse {
	s.Body = v
	return s
}

type GetGatewayBySubDeviceRequest struct {
	// The DeviceName of the sub-device.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the sub-device. The ID is a unique identifier that is issued by IoT Platform to the sub-device.
	//
	// >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s GetGatewayBySubDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayBySubDeviceRequest) GoString() string {
	return s.String()
}

func (s *GetGatewayBySubDeviceRequest) SetDeviceName(v string) *GetGatewayBySubDeviceRequest {
	s.DeviceName = &v
	return s
}

func (s *GetGatewayBySubDeviceRequest) SetIotId(v string) *GetGatewayBySubDeviceRequest {
	s.IotId = &v
	return s
}

func (s *GetGatewayBySubDeviceRequest) SetIotInstanceId(v string) *GetGatewayBySubDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetGatewayBySubDeviceRequest) SetProductKey(v string) *GetGatewayBySubDeviceRequest {
	s.ProductKey = &v
	return s
}

type GetGatewayBySubDeviceResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The gateway details returned if the call is successful.
	Data *GetGatewayBySubDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetGatewayBySubDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayBySubDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *GetGatewayBySubDeviceResponseBody) SetCode(v string) *GetGatewayBySubDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBody) SetData(v *GetGatewayBySubDeviceResponseBodyData) *GetGatewayBySubDeviceResponseBody {
	s.Data = v
	return s
}

func (s *GetGatewayBySubDeviceResponseBody) SetErrorMessage(v string) *GetGatewayBySubDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBody) SetRequestId(v string) *GetGatewayBySubDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBody) SetSuccess(v bool) *GetGatewayBySubDeviceResponseBody {
	s.Success = &v
	return s
}

type GetGatewayBySubDeviceResponseBodyData struct {
	// The DeviceName of the gateway.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The DeviceSecret of the gateway.
	DeviceSecret *string `json:"DeviceSecret,omitempty" xml:"DeviceSecret,omitempty"`
	// The firmware version number of the device.
	FirmwareVersion *string `json:"FirmwareVersion,omitempty" xml:"FirmwareVersion,omitempty"`
	// The activation time of the gateway. The time is displayed in GMT. The time is the local time of the region where the gateway resides.
	GmtActive *string `json:"GmtActive,omitempty" xml:"GmtActive,omitempty"`
	// The creation time of the gateway. The time is displayed in GMT. The time is the local time of the region where the gateway resides.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The last online time of the gateway. The time is displayed in GMT. The time is the local time of the region where the gateway resides.
	GmtOnline *string `json:"GmtOnline,omitempty" xml:"GmtOnline,omitempty"`
	// The IP address of the gateway.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The node type. The value 1 indicates that the device is a gateway.
	NodeType *string `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The **ProductKey** of the product to which the gateway belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The name of the product to which the gateway belongs.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
	// The status of the gateway device. Valid values:
	//
	// *   **online**: The device is online.
	// *   **offline**: The device is offline.
	// *   **unactive**: The device is not activated.
	// *   **disable**: The device is disabled.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The activation time of the gateway. The time is displayed in UTC. The actual time of the region where the gateway resides is calculated based on the time zone of the region.
	UtcActive *string `json:"UtcActive,omitempty" xml:"UtcActive,omitempty"`
	// The creation time of the gateway. The time is displayed in UTC. The actual time of the region where the gateway resides is calculated based on the time zone of the region.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
	// The last online time of the gateway. The time is displayed in UTC. The actual time of the region where the gateway resides is calculated based on the time zone of the region.
	UtcOnline *string `json:"UtcOnline,omitempty" xml:"UtcOnline,omitempty"`
	// The ID of the gateway device. The ID is the unique identifier that is issued by IoT Platform to the device.
	IotId *string `json:"iotId,omitempty" xml:"iotId,omitempty"`
	// The region where the gateway resides. This region corresponds to the region that is displayed in the IoT Platform console.
	Region *string `json:"region,omitempty" xml:"region,omitempty"`
}

func (s GetGatewayBySubDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayBySubDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetDeviceName(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.DeviceName = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetDeviceSecret(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.DeviceSecret = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetFirmwareVersion(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.FirmwareVersion = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetGmtActive(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.GmtActive = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetGmtCreate(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetGmtOnline(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.GmtOnline = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetIpAddress(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.IpAddress = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetNodeType(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.NodeType = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetProductKey(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.ProductKey = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetProductName(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.ProductName = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetStatus(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetUtcActive(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.UtcActive = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetUtcCreate(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.UtcCreate = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetUtcOnline(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.UtcOnline = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetIotId(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.IotId = &v
	return s
}

func (s *GetGatewayBySubDeviceResponseBodyData) SetRegion(v string) *GetGatewayBySubDeviceResponseBodyData {
	s.Region = &v
	return s
}

type GetGatewayBySubDeviceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetGatewayBySubDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetGatewayBySubDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetGatewayBySubDeviceResponse) GoString() string {
	return s.String()
}

func (s *GetGatewayBySubDeviceResponse) SetHeaders(v map[string]*string) *GetGatewayBySubDeviceResponse {
	s.Headers = v
	return s
}

func (s *GetGatewayBySubDeviceResponse) SetStatusCode(v int32) *GetGatewayBySubDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetGatewayBySubDeviceResponse) SetBody(v *GetGatewayBySubDeviceResponseBody) *GetGatewayBySubDeviceResponse {
	s.Body = v
	return s
}

type GetLoraNodesTaskRequest struct {
	// The instance ID.
	//
	// You can obtain the **ID** of the instance on the **Overview** page in the IoT Platform console. If your instance has an ID, you must specify this parameter. Otherwise, the request fails.
	//
	// > The ID of a public instance may not be displayed on the Overview page. For more information about how to obtain the instance ID, see [How do I obtain an instance ID?](~~267533~~)
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the task for creating the LoRaWAN devices. You can call the [CreateLoRaNodesTask](~~109299~~) operation and obtain the task ID from the value of the **TaskId** response parameter.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s GetLoraNodesTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s GetLoraNodesTaskRequest) GoString() string {
	return s.String()
}

func (s *GetLoraNodesTaskRequest) SetIotInstanceId(v string) *GetLoraNodesTaskRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetLoraNodesTaskRequest) SetTaskId(v string) *GetLoraNodesTaskRequest {
	s.TaskId = &v
	return s
}

type GetLoraNodesTaskResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The number of devices that were created.
	SuccessCount   *int64                                      `json:"SuccessCount,omitempty" xml:"SuccessCount,omitempty"`
	SuccessDevEuis *GetLoraNodesTaskResponseBodySuccessDevEuis `json:"SuccessDevEuis,omitempty" xml:"SuccessDevEuis,omitempty" type:"Struct"`
	// The task ID returned if the request is successful.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The task status.
	//
	// *   **RUNNING**: The task is in progress.
	// *   **FINISH**: The task is completed.
	TaskState *string `json:"TaskState,omitempty" xml:"TaskState,omitempty"`
	// The total number of devices that you want to create.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s GetLoraNodesTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetLoraNodesTaskResponseBody) GoString() string {
	return s.String()
}

func (s *GetLoraNodesTaskResponseBody) SetCode(v string) *GetLoraNodesTaskResponseBody {
	s.Code = &v
	return s
}

func (s *GetLoraNodesTaskResponseBody) SetErrorMessage(v string) *GetLoraNodesTaskResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetLoraNodesTaskResponseBody) SetRequestId(v string) *GetLoraNodesTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetLoraNodesTaskResponseBody) SetSuccess(v bool) *GetLoraNodesTaskResponseBody {
	s.Success = &v
	return s
}

func (s *GetLoraNodesTaskResponseBody) SetSuccessCount(v int64) *GetLoraNodesTaskResponseBody {
	s.SuccessCount = &v
	return s
}

func (s *GetLoraNodesTaskResponseBody) SetSuccessDevEuis(v *GetLoraNodesTaskResponseBodySuccessDevEuis) *GetLoraNodesTaskResponseBody {
	s.SuccessDevEuis = v
	return s
}

func (s *GetLoraNodesTaskResponseBody) SetTaskId(v string) *GetLoraNodesTaskResponseBody {
	s.TaskId = &v
	return s
}

func (s *GetLoraNodesTaskResponseBody) SetTaskState(v string) *GetLoraNodesTaskResponseBody {
	s.TaskState = &v
	return s
}

func (s *GetLoraNodesTaskResponseBody) SetTotalCount(v int64) *GetLoraNodesTaskResponseBody {
	s.TotalCount = &v
	return s
}

type GetLoraNodesTaskResponseBodySuccessDevEuis struct {
	SuccessDevEui []*string `json:"SuccessDevEui,omitempty" xml:"SuccessDevEui,omitempty" type:"Repeated"`
}

func (s GetLoraNodesTaskResponseBodySuccessDevEuis) String() string {
	return tea.Prettify(s)
}

func (s GetLoraNodesTaskResponseBodySuccessDevEuis) GoString() string {
	return s.String()
}

func (s *GetLoraNodesTaskResponseBodySuccessDevEuis) SetSuccessDevEui(v []*string) *GetLoraNodesTaskResponseBodySuccessDevEuis {
	s.SuccessDevEui = v
	return s
}

type GetLoraNodesTaskResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetLoraNodesTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetLoraNodesTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s GetLoraNodesTaskResponse) GoString() string {
	return s.String()
}

func (s *GetLoraNodesTaskResponse) SetHeaders(v map[string]*string) *GetLoraNodesTaskResponse {
	s.Headers = v
	return s
}

func (s *GetLoraNodesTaskResponse) SetStatusCode(v int32) *GetLoraNodesTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *GetLoraNodesTaskResponse) SetBody(v *GetLoraNodesTaskResponseBody) *GetLoraNodesTaskResponse {
	s.Body = v
	return s
}

type GetParserRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ParserId      *int64  `json:"ParserId,omitempty" xml:"ParserId,omitempty"`
}

func (s GetParserRequest) String() string {
	return tea.Prettify(s)
}

func (s GetParserRequest) GoString() string {
	return s.String()
}

func (s *GetParserRequest) SetIotInstanceId(v string) *GetParserRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetParserRequest) SetParserId(v int64) *GetParserRequest {
	s.ParserId = &v
	return s
}

type GetParserResponseBody struct {
	Code         *string                    `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *GetParserResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                    `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                      `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetParserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetParserResponseBody) GoString() string {
	return s.String()
}

func (s *GetParserResponseBody) SetCode(v string) *GetParserResponseBody {
	s.Code = &v
	return s
}

func (s *GetParserResponseBody) SetData(v *GetParserResponseBodyData) *GetParserResponseBody {
	s.Data = v
	return s
}

func (s *GetParserResponseBody) SetErrorMessage(v string) *GetParserResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetParserResponseBody) SetRequestId(v string) *GetParserResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetParserResponseBody) SetSuccess(v bool) *GetParserResponseBody {
	s.Success = &v
	return s
}

type GetParserResponseBodyData struct {
	DataSourceId *int64  `json:"DataSourceId,omitempty" xml:"DataSourceId,omitempty"`
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	ParserId     *int64  `json:"ParserId,omitempty" xml:"ParserId,omitempty"`
	Script       *string `json:"Script,omitempty" xml:"Script,omitempty"`
	ScriptDraft  *string `json:"ScriptDraft,omitempty" xml:"ScriptDraft,omitempty"`
	Status       *string `json:"Status,omitempty" xml:"Status,omitempty"`
	UtcCreated   *string `json:"UtcCreated,omitempty" xml:"UtcCreated,omitempty"`
	UtcModified  *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
}

func (s GetParserResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetParserResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetParserResponseBodyData) SetDataSourceId(v int64) *GetParserResponseBodyData {
	s.DataSourceId = &v
	return s
}

func (s *GetParserResponseBodyData) SetDescription(v string) *GetParserResponseBodyData {
	s.Description = &v
	return s
}

func (s *GetParserResponseBodyData) SetName(v string) *GetParserResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetParserResponseBodyData) SetParserId(v int64) *GetParserResponseBodyData {
	s.ParserId = &v
	return s
}

func (s *GetParserResponseBodyData) SetScript(v string) *GetParserResponseBodyData {
	s.Script = &v
	return s
}

func (s *GetParserResponseBodyData) SetScriptDraft(v string) *GetParserResponseBodyData {
	s.ScriptDraft = &v
	return s
}

func (s *GetParserResponseBodyData) SetStatus(v string) *GetParserResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetParserResponseBodyData) SetUtcCreated(v string) *GetParserResponseBodyData {
	s.UtcCreated = &v
	return s
}

func (s *GetParserResponseBodyData) SetUtcModified(v string) *GetParserResponseBodyData {
	s.UtcModified = &v
	return s
}

type GetParserResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetParserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetParserResponse) String() string {
	return tea.Prettify(s)
}

func (s GetParserResponse) GoString() string {
	return s.String()
}

func (s *GetParserResponse) SetHeaders(v map[string]*string) *GetParserResponse {
	s.Headers = v
	return s
}

func (s *GetParserResponse) SetStatusCode(v int32) *GetParserResponse {
	s.StatusCode = &v
	return s
}

func (s *GetParserResponse) SetBody(v *GetParserResponseBody) *GetParserResponse {
	s.Body = v
	return s
}

type GetParserDataSourceRequest struct {
	DataSourceId  *int64  `json:"DataSourceId,omitempty" xml:"DataSourceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s GetParserDataSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s GetParserDataSourceRequest) GoString() string {
	return s.String()
}

func (s *GetParserDataSourceRequest) SetDataSourceId(v int64) *GetParserDataSourceRequest {
	s.DataSourceId = &v
	return s
}

func (s *GetParserDataSourceRequest) SetIotInstanceId(v string) *GetParserDataSourceRequest {
	s.IotInstanceId = &v
	return s
}

type GetParserDataSourceResponseBody struct {
	Code         *string                                    `json:"Code,omitempty" xml:"Code,omitempty"`
	DataSource   *GetParserDataSourceResponseBodyDataSource `json:"DataSource,omitempty" xml:"DataSource,omitempty" type:"Struct"`
	ErrorMessage *string                                    `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                      `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetParserDataSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetParserDataSourceResponseBody) GoString() string {
	return s.String()
}

func (s *GetParserDataSourceResponseBody) SetCode(v string) *GetParserDataSourceResponseBody {
	s.Code = &v
	return s
}

func (s *GetParserDataSourceResponseBody) SetDataSource(v *GetParserDataSourceResponseBodyDataSource) *GetParserDataSourceResponseBody {
	s.DataSource = v
	return s
}

func (s *GetParserDataSourceResponseBody) SetErrorMessage(v string) *GetParserDataSourceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetParserDataSourceResponseBody) SetRequestId(v string) *GetParserDataSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetParserDataSourceResponseBody) SetSuccess(v bool) *GetParserDataSourceResponseBody {
	s.Success = &v
	return s
}

type GetParserDataSourceResponseBodyDataSource struct {
	CreateUserId *int64  `json:"CreateUserId,omitempty" xml:"CreateUserId,omitempty"`
	DataSourceId *int64  `json:"DataSourceId,omitempty" xml:"DataSourceId,omitempty"`
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	UtcCreated   *string `json:"UtcCreated,omitempty" xml:"UtcCreated,omitempty"`
}

func (s GetParserDataSourceResponseBodyDataSource) String() string {
	return tea.Prettify(s)
}

func (s GetParserDataSourceResponseBodyDataSource) GoString() string {
	return s.String()
}

func (s *GetParserDataSourceResponseBodyDataSource) SetCreateUserId(v int64) *GetParserDataSourceResponseBodyDataSource {
	s.CreateUserId = &v
	return s
}

func (s *GetParserDataSourceResponseBodyDataSource) SetDataSourceId(v int64) *GetParserDataSourceResponseBodyDataSource {
	s.DataSourceId = &v
	return s
}

func (s *GetParserDataSourceResponseBodyDataSource) SetDescription(v string) *GetParserDataSourceResponseBodyDataSource {
	s.Description = &v
	return s
}

func (s *GetParserDataSourceResponseBodyDataSource) SetName(v string) *GetParserDataSourceResponseBodyDataSource {
	s.Name = &v
	return s
}

func (s *GetParserDataSourceResponseBodyDataSource) SetUtcCreated(v string) *GetParserDataSourceResponseBodyDataSource {
	s.UtcCreated = &v
	return s
}

type GetParserDataSourceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetParserDataSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetParserDataSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetParserDataSourceResponse) GoString() string {
	return s.String()
}

func (s *GetParserDataSourceResponse) SetHeaders(v map[string]*string) *GetParserDataSourceResponse {
	s.Headers = v
	return s
}

func (s *GetParserDataSourceResponse) SetStatusCode(v int32) *GetParserDataSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetParserDataSourceResponse) SetBody(v *GetParserDataSourceResponseBody) *GetParserDataSourceResponse {
	s.Body = v
	return s
}

type GetRuleRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the rule that you want to query. You can log on to the IoT Platform console and choose **Rules** > **Data Forwarding** to view the rule ID. You can also call the [ListRule](~~69486~~) operation and view the rule ID in the response.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s GetRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s GetRuleRequest) GoString() string {
	return s.String()
}

func (s *GetRuleRequest) SetIotInstanceId(v string) *GetRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetRuleRequest) SetRuleId(v int64) *GetRuleRequest {
	s.RuleId = &v
	return s
}

type GetRuleResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The rule information returned if the call is successful. For more information, see RuleInfo.
	RuleInfo *GetRuleResponseBodyRuleInfo `json:"RuleInfo,omitempty" xml:"RuleInfo,omitempty" type:"Struct"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetRuleResponseBody) GoString() string {
	return s.String()
}

func (s *GetRuleResponseBody) SetCode(v string) *GetRuleResponseBody {
	s.Code = &v
	return s
}

func (s *GetRuleResponseBody) SetErrorMessage(v string) *GetRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetRuleResponseBody) SetRequestId(v string) *GetRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetRuleResponseBody) SetRuleInfo(v *GetRuleResponseBodyRuleInfo) *GetRuleResponseBody {
	s.RuleInfo = v
	return s
}

func (s *GetRuleResponseBody) SetSuccess(v bool) *GetRuleResponseBody {
	s.Success = &v
	return s
}

type GetRuleResponseBodyRuleInfo struct {
	// The ID of the user who created the rule.
	CreateUserId *int64 `json:"CreateUserId,omitempty" xml:"CreateUserId,omitempty"`
	// The time when the rule was created. The time is displayed in UTC-6.
	Created *string `json:"Created,omitempty" xml:"Created,omitempty"`
	// The data type of the rule. Valid values: **JSON** and **BINARY** .
	DataType *string `json:"DataType,omitempty" xml:"DataType,omitempty"`
	// The ID of the rule.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The time when the rule was last modified. The time is displayed in UTC-6.
	Modified *string `json:"Modified,omitempty" xml:"Modified,omitempty"`
	// The name of the rule.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The ProductKey of the product to which the rule applies.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The description of this rule.
	RuleDesc *string `json:"RuleDesc,omitempty" xml:"RuleDesc,omitempty"`
	// The values of **Select** in the SQL statements of the rule.
	Select *string `json:"Select,omitempty" xml:"Select,omitempty"`
	// The topic to which the rule applies. The topic does not include the ProductKey level. Format: `${deviceName}/topicShortName`. ${deviceName} indicates the name of the device, and topicShortName indicates the custom name of the topic.
	//
	// >  For information about how to use the `+` or `#` wildcard in a topic, see [Topic wildcards](~~73731~~).
	ShortTopic *string `json:"ShortTopic,omitempty" xml:"ShortTopic,omitempty"`
	// The status of the rule. Valid values:
	//
	// *   **RUNNING**: Running
	// *   **STOP**: Stopped
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The complete topic to which the rule applies. Format: `${productKey}/${deviceName}/topicShortName`.
	//
	// >  For information about how to use the `+` or `#` wildcard in a topic, see [Topic wildcards](~~73731~~).
	Topic *string `json:"Topic,omitempty" xml:"Topic,omitempty"`
	// The type of the topic. This parameter is returned if you set the SQL statement for the rule. Valid values:
	//
	// *   **0**: a basic communication topic or TSL communication topic.
	// *   **1**: a custom topic.
	// *   **2**: a device status topic.
	//
	// If no SQL statement is set for the rule, the value **-1** is returned.
	TopicType *int32 `json:"TopicType,omitempty" xml:"TopicType,omitempty"`
	// The time when the rule was created. The time is displayed in UTC.
	UtcCreated *string `json:"UtcCreated,omitempty" xml:"UtcCreated,omitempty"`
	// The time when the rule was last modified. The time is displayed in UTC.
	UtcModified *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
	// The **Where** query condition in the SQL statements of the rule.
	Where *string `json:"Where,omitempty" xml:"Where,omitempty"`
}

func (s GetRuleResponseBodyRuleInfo) String() string {
	return tea.Prettify(s)
}

func (s GetRuleResponseBodyRuleInfo) GoString() string {
	return s.String()
}

func (s *GetRuleResponseBodyRuleInfo) SetCreateUserId(v int64) *GetRuleResponseBodyRuleInfo {
	s.CreateUserId = &v
	return s
}

func (s *GetRuleResponseBodyRuleInfo) SetCreated(v string) *GetRuleResponseBodyRuleInfo {
	s.Created = &v
	return s
}

func (s *GetRuleResponseBodyRuleInfo) SetDataType(v string) *GetRuleResponseBodyRuleInfo {
	s.DataType = &v
	return s
}

func (s *GetRuleResponseBodyRuleInfo) SetId(v int64) *GetRuleResponseBodyRuleInfo {
	s.Id = &v
	return s
}

func (s *GetRuleResponseBodyRuleInfo) SetModified(v string) *GetRuleResponseBodyRuleInfo {
	s.Modified = &v
	return s
}

func (s *GetRuleResponseBodyRuleInfo) SetName(v string) *GetRuleResponseBodyRuleInfo {
	s.Name = &v
	return s
}

func (s *GetRuleResponseBodyRuleInfo) SetProductKey(v string) *GetRuleResponseBodyRuleInfo {
	s.ProductKey = &v
	return s
}

func (s *GetRuleResponseBodyRuleInfo) SetRuleDesc(v string) *GetRuleResponseBodyRuleInfo {
	s.RuleDesc = &v
	return s
}

func (s *GetRuleResponseBodyRuleInfo) SetSelect(v string) *GetRuleResponseBodyRuleInfo {
	s.Select = &v
	return s
}

func (s *GetRuleResponseBodyRuleInfo) SetShortTopic(v string) *GetRuleResponseBodyRuleInfo {
	s.ShortTopic = &v
	return s
}

func (s *GetRuleResponseBodyRuleInfo) SetStatus(v string) *GetRuleResponseBodyRuleInfo {
	s.Status = &v
	return s
}

func (s *GetRuleResponseBodyRuleInfo) SetTopic(v string) *GetRuleResponseBodyRuleInfo {
	s.Topic = &v
	return s
}

func (s *GetRuleResponseBodyRuleInfo) SetTopicType(v int32) *GetRuleResponseBodyRuleInfo {
	s.TopicType = &v
	return s
}

func (s *GetRuleResponseBodyRuleInfo) SetUtcCreated(v string) *GetRuleResponseBodyRuleInfo {
	s.UtcCreated = &v
	return s
}

func (s *GetRuleResponseBodyRuleInfo) SetUtcModified(v string) *GetRuleResponseBodyRuleInfo {
	s.UtcModified = &v
	return s
}

func (s *GetRuleResponseBodyRuleInfo) SetWhere(v string) *GetRuleResponseBodyRuleInfo {
	s.Where = &v
	return s
}

type GetRuleResponse struct {
	Headers    map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s GetRuleResponse) GoString() string {
	return s.String()
}

func (s *GetRuleResponse) SetHeaders(v map[string]*string) *GetRuleResponse {
	s.Headers = v
	return s
}

func (s *GetRuleResponse) SetStatusCode(v int32) *GetRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *GetRuleResponse) SetBody(v *GetRuleResponseBody) *GetRuleResponse {
	s.Body = v
	return s
}

type GetRuleActionRequest struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	ActionId *int64 `json:"ActionId,omitempty" xml:"ActionId,omitempty"`
	// The rule action ID that you want to query.
	//
	// You can query the rule action ID by using the following methods:
	//
	// *   Call the [CreateRuleAction](~~69586~~) operation and view the **ActionId** parameter in the response.
	// *   Call the [ListRuleActions](~~69517~~) operation and view the **Id** parameter in the response.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s GetRuleActionRequest) String() string {
	return tea.Prettify(s)
}

func (s GetRuleActionRequest) GoString() string {
	return s.String()
}

func (s *GetRuleActionRequest) SetActionId(v int64) *GetRuleActionRequest {
	s.ActionId = &v
	return s
}

func (s *GetRuleActionRequest) SetIotInstanceId(v string) *GetRuleActionRequest {
	s.IotInstanceId = &v
	return s
}

type GetRuleActionResponseBody struct {
	// The error message returned if the call fails.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the request.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the rule action forwarded error operation data that failed to be forwarded to the destination cloud service. A data forwarding failure indicates that forwarding retries also failed.
	//
	// *   **true**: forwards error operation data.
	// *   **false**: forwards normal data instead of error operation data.
	RuleActionInfo *GetRuleActionResponseBodyRuleActionInfo `json:"RuleActionInfo,omitempty" xml:"RuleActionInfo,omitempty" type:"Struct"`
	// The rule action information returned if the call was successful. For more information, see the following parameters.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetRuleActionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetRuleActionResponseBody) GoString() string {
	return s.String()
}

func (s *GetRuleActionResponseBody) SetCode(v string) *GetRuleActionResponseBody {
	s.Code = &v
	return s
}

func (s *GetRuleActionResponseBody) SetErrorMessage(v string) *GetRuleActionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetRuleActionResponseBody) SetRequestId(v string) *GetRuleActionResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetRuleActionResponseBody) SetRuleActionInfo(v *GetRuleActionResponseBodyRuleActionInfo) *GetRuleActionResponseBody {
	s.RuleActionInfo = v
	return s
}

func (s *GetRuleActionResponseBody) SetSuccess(v bool) *GetRuleActionResponseBody {
	s.Success = &v
	return s
}

type GetRuleActionResponseBodyRuleActionInfo struct {
	// The ID of rule action.
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
	// The type of the rule action. Valid values:
	//
	// *   **REPUBLISH**: forwards data to another topic.
	// *   **OTS**: stores data to Tablestore.
	// *   **MNS**: sends data to Message Service (MNS).
	// *   **FC**: sends data to Function Compute.
	// *   **RDS**: Save to cloud databases.
	// *   **AMQP**: forwards data to an AMQP consumer group.
	ErrorActionFlag *bool `json:"ErrorActionFlag,omitempty" xml:"ErrorActionFlag,omitempty"`
	// The ID of the rule based on which the rule action is performed.
	Id     *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The configurations of the rule action.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetRuleActionResponseBodyRuleActionInfo) String() string {
	return tea.Prettify(s)
}

func (s GetRuleActionResponseBodyRuleActionInfo) GoString() string {
	return s.String()
}

func (s *GetRuleActionResponseBodyRuleActionInfo) SetConfiguration(v string) *GetRuleActionResponseBodyRuleActionInfo {
	s.Configuration = &v
	return s
}

func (s *GetRuleActionResponseBodyRuleActionInfo) SetErrorActionFlag(v bool) *GetRuleActionResponseBodyRuleActionInfo {
	s.ErrorActionFlag = &v
	return s
}

func (s *GetRuleActionResponseBodyRuleActionInfo) SetId(v int64) *GetRuleActionResponseBodyRuleActionInfo {
	s.Id = &v
	return s
}

func (s *GetRuleActionResponseBodyRuleActionInfo) SetRuleId(v int64) *GetRuleActionResponseBodyRuleActionInfo {
	s.RuleId = &v
	return s
}

func (s *GetRuleActionResponseBodyRuleActionInfo) SetType(v string) *GetRuleActionResponseBodyRuleActionInfo {
	s.Type = &v
	return s
}

type GetRuleActionResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetRuleActionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetRuleActionResponse) String() string {
	return tea.Prettify(s)
}

func (s GetRuleActionResponse) GoString() string {
	return s.String()
}

func (s *GetRuleActionResponse) SetHeaders(v map[string]*string) *GetRuleActionResponse {
	s.Headers = v
	return s
}

func (s *GetRuleActionResponse) SetStatusCode(v int32) *GetRuleActionResponse {
	s.StatusCode = &v
	return s
}

func (s *GetRuleActionResponse) SetBody(v *GetRuleActionResponseBody) *GetRuleActionResponse {
	s.Body = v
	return s
}

type GetSceneRuleRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	RuleId        *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s GetSceneRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSceneRuleRequest) GoString() string {
	return s.String()
}

func (s *GetSceneRuleRequest) SetIotInstanceId(v string) *GetSceneRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetSceneRuleRequest) SetRuleId(v string) *GetSceneRuleRequest {
	s.RuleId = &v
	return s
}

type GetSceneRuleResponseBody struct {
	Code         *string                       `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *GetSceneRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                       `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                         `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetSceneRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSceneRuleResponseBody) GoString() string {
	return s.String()
}

func (s *GetSceneRuleResponseBody) SetCode(v string) *GetSceneRuleResponseBody {
	s.Code = &v
	return s
}

func (s *GetSceneRuleResponseBody) SetData(v *GetSceneRuleResponseBodyData) *GetSceneRuleResponseBody {
	s.Data = v
	return s
}

func (s *GetSceneRuleResponseBody) SetErrorMessage(v string) *GetSceneRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetSceneRuleResponseBody) SetRequestId(v string) *GetSceneRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSceneRuleResponseBody) SetSuccess(v bool) *GetSceneRuleResponseBody {
	s.Success = &v
	return s
}

type GetSceneRuleResponseBodyData struct {
	GmtCreate       *int64  `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtModified     *int64  `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	RuleContent     *string `json:"RuleContent,omitempty" xml:"RuleContent,omitempty"`
	RuleDescription *string `json:"RuleDescription,omitempty" xml:"RuleDescription,omitempty"`
	RuleName        *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	RuleStatus      *int32  `json:"RuleStatus,omitempty" xml:"RuleStatus,omitempty"`
}

func (s GetSceneRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetSceneRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetSceneRuleResponseBodyData) SetGmtCreate(v int64) *GetSceneRuleResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetSceneRuleResponseBodyData) SetGmtModified(v int64) *GetSceneRuleResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *GetSceneRuleResponseBodyData) SetRuleContent(v string) *GetSceneRuleResponseBodyData {
	s.RuleContent = &v
	return s
}

func (s *GetSceneRuleResponseBodyData) SetRuleDescription(v string) *GetSceneRuleResponseBodyData {
	s.RuleDescription = &v
	return s
}

func (s *GetSceneRuleResponseBodyData) SetRuleName(v string) *GetSceneRuleResponseBodyData {
	s.RuleName = &v
	return s
}

func (s *GetSceneRuleResponseBodyData) SetRuleStatus(v int32) *GetSceneRuleResponseBodyData {
	s.RuleStatus = &v
	return s
}

type GetSceneRuleResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSceneRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSceneRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSceneRuleResponse) GoString() string {
	return s.String()
}

func (s *GetSceneRuleResponse) SetHeaders(v map[string]*string) *GetSceneRuleResponse {
	s.Headers = v
	return s
}

func (s *GetSceneRuleResponse) SetStatusCode(v int32) *GetSceneRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSceneRuleResponse) SetBody(v *GetSceneRuleResponseBody) *GetSceneRuleResponse {
	s.Body = v
	return s
}

type GetShareSpeechModelAudioRequest struct {
	IotInstanceId       *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ShareTaskId         *string   `json:"ShareTaskId,omitempty" xml:"ShareTaskId,omitempty"`
	SpeechModelCodeList []*string `json:"SpeechModelCodeList,omitempty" xml:"SpeechModelCodeList,omitempty" type:"Repeated"`
}

func (s GetShareSpeechModelAudioRequest) String() string {
	return tea.Prettify(s)
}

func (s GetShareSpeechModelAudioRequest) GoString() string {
	return s.String()
}

func (s *GetShareSpeechModelAudioRequest) SetIotInstanceId(v string) *GetShareSpeechModelAudioRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetShareSpeechModelAudioRequest) SetShareTaskId(v string) *GetShareSpeechModelAudioRequest {
	s.ShareTaskId = &v
	return s
}

func (s *GetShareSpeechModelAudioRequest) SetSpeechModelCodeList(v []*string) *GetShareSpeechModelAudioRequest {
	s.SpeechModelCodeList = v
	return s
}

type GetShareSpeechModelAudioResponseBody struct {
	Code         *string                                   `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *GetShareSpeechModelAudioResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                   `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                     `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetShareSpeechModelAudioResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetShareSpeechModelAudioResponseBody) GoString() string {
	return s.String()
}

func (s *GetShareSpeechModelAudioResponseBody) SetCode(v string) *GetShareSpeechModelAudioResponseBody {
	s.Code = &v
	return s
}

func (s *GetShareSpeechModelAudioResponseBody) SetData(v *GetShareSpeechModelAudioResponseBodyData) *GetShareSpeechModelAudioResponseBody {
	s.Data = v
	return s
}

func (s *GetShareSpeechModelAudioResponseBody) SetErrorMessage(v string) *GetShareSpeechModelAudioResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetShareSpeechModelAudioResponseBody) SetRequestId(v string) *GetShareSpeechModelAudioResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetShareSpeechModelAudioResponseBody) SetSuccess(v bool) *GetShareSpeechModelAudioResponseBody {
	s.Success = &v
	return s
}

type GetShareSpeechModelAudioResponseBodyData struct {
	Data []*string `json:"data,omitempty" xml:"data,omitempty" type:"Repeated"`
}

func (s GetShareSpeechModelAudioResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetShareSpeechModelAudioResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetShareSpeechModelAudioResponseBodyData) SetData(v []*string) *GetShareSpeechModelAudioResponseBodyData {
	s.Data = v
	return s
}

type GetShareSpeechModelAudioResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetShareSpeechModelAudioResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareSpeechModelAudioResponse) String() string {
	return tea.Prettify(s)
}

func (s GetShareSpeechModelAudioResponse) GoString() string {
	return s.String()
}

func (s *GetShareSpeechModelAudioResponse) SetHeaders(v map[string]*string) *GetShareSpeechModelAudioResponse {
	s.Headers = v
	return s
}

func (s *GetShareSpeechModelAudioResponse) SetStatusCode(v int32) *GetShareSpeechModelAudioResponse {
	s.StatusCode = &v
	return s
}

func (s *GetShareSpeechModelAudioResponse) SetBody(v *GetShareSpeechModelAudioResponseBody) *GetShareSpeechModelAudioResponse {
	s.Body = v
	return s
}

type GetShareTaskByDeviceOpenRequest struct {
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotId         *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s GetShareTaskByDeviceOpenRequest) String() string {
	return tea.Prettify(s)
}

func (s GetShareTaskByDeviceOpenRequest) GoString() string {
	return s.String()
}

func (s *GetShareTaskByDeviceOpenRequest) SetDeviceName(v string) *GetShareTaskByDeviceOpenRequest {
	s.DeviceName = &v
	return s
}

func (s *GetShareTaskByDeviceOpenRequest) SetIotId(v string) *GetShareTaskByDeviceOpenRequest {
	s.IotId = &v
	return s
}

func (s *GetShareTaskByDeviceOpenRequest) SetIotInstanceId(v string) *GetShareTaskByDeviceOpenRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetShareTaskByDeviceOpenRequest) SetProductKey(v string) *GetShareTaskByDeviceOpenRequest {
	s.ProductKey = &v
	return s
}

type GetShareTaskByDeviceOpenResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetShareTaskByDeviceOpenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetShareTaskByDeviceOpenResponseBody) GoString() string {
	return s.String()
}

func (s *GetShareTaskByDeviceOpenResponseBody) SetCode(v string) *GetShareTaskByDeviceOpenResponseBody {
	s.Code = &v
	return s
}

func (s *GetShareTaskByDeviceOpenResponseBody) SetData(v string) *GetShareTaskByDeviceOpenResponseBody {
	s.Data = &v
	return s
}

func (s *GetShareTaskByDeviceOpenResponseBody) SetErrorMessage(v string) *GetShareTaskByDeviceOpenResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetShareTaskByDeviceOpenResponseBody) SetRequestId(v string) *GetShareTaskByDeviceOpenResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetShareTaskByDeviceOpenResponseBody) SetSuccess(v bool) *GetShareTaskByDeviceOpenResponseBody {
	s.Success = &v
	return s
}

type GetShareTaskByDeviceOpenResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetShareTaskByDeviceOpenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetShareTaskByDeviceOpenResponse) String() string {
	return tea.Prettify(s)
}

func (s GetShareTaskByDeviceOpenResponse) GoString() string {
	return s.String()
}

func (s *GetShareTaskByDeviceOpenResponse) SetHeaders(v map[string]*string) *GetShareTaskByDeviceOpenResponse {
	s.Headers = v
	return s
}

func (s *GetShareTaskByDeviceOpenResponse) SetStatusCode(v int32) *GetShareTaskByDeviceOpenResponse {
	s.StatusCode = &v
	return s
}

func (s *GetShareTaskByDeviceOpenResponse) SetBody(v *GetShareTaskByDeviceOpenResponseBody) *GetShareTaskByDeviceOpenResponse {
	s.Body = v
	return s
}

type GetSoundCodeAudioRequest struct {
	IotInstanceId *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	SoundCodeList []*string `json:"SoundCodeList,omitempty" xml:"SoundCodeList,omitempty" type:"Repeated"`
}

func (s GetSoundCodeAudioRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSoundCodeAudioRequest) GoString() string {
	return s.String()
}

func (s *GetSoundCodeAudioRequest) SetIotInstanceId(v string) *GetSoundCodeAudioRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetSoundCodeAudioRequest) SetSoundCodeList(v []*string) *GetSoundCodeAudioRequest {
	s.SoundCodeList = v
	return s
}

type GetSoundCodeAudioResponseBody struct {
	Code         *string                            `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *GetSoundCodeAudioResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                            `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                              `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetSoundCodeAudioResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSoundCodeAudioResponseBody) GoString() string {
	return s.String()
}

func (s *GetSoundCodeAudioResponseBody) SetCode(v string) *GetSoundCodeAudioResponseBody {
	s.Code = &v
	return s
}

func (s *GetSoundCodeAudioResponseBody) SetData(v *GetSoundCodeAudioResponseBodyData) *GetSoundCodeAudioResponseBody {
	s.Data = v
	return s
}

func (s *GetSoundCodeAudioResponseBody) SetErrorMessage(v string) *GetSoundCodeAudioResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetSoundCodeAudioResponseBody) SetRequestId(v string) *GetSoundCodeAudioResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSoundCodeAudioResponseBody) SetSuccess(v bool) *GetSoundCodeAudioResponseBody {
	s.Success = &v
	return s
}

type GetSoundCodeAudioResponseBodyData struct {
	Items []*string `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s GetSoundCodeAudioResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetSoundCodeAudioResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetSoundCodeAudioResponseBodyData) SetItems(v []*string) *GetSoundCodeAudioResponseBodyData {
	s.Items = v
	return s
}

type GetSoundCodeAudioResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSoundCodeAudioResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSoundCodeAudioResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSoundCodeAudioResponse) GoString() string {
	return s.String()
}

func (s *GetSoundCodeAudioResponse) SetHeaders(v map[string]*string) *GetSoundCodeAudioResponse {
	s.Headers = v
	return s
}

func (s *GetSoundCodeAudioResponse) SetStatusCode(v int32) *GetSoundCodeAudioResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSoundCodeAudioResponse) SetBody(v *GetSoundCodeAudioResponseBody) *GetSoundCodeAudioResponse {
	s.Body = v
	return s
}

type GetSoundCodeScheduleRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ScheduleCode  *string `json:"ScheduleCode,omitempty" xml:"ScheduleCode,omitempty"`
}

func (s GetSoundCodeScheduleRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSoundCodeScheduleRequest) GoString() string {
	return s.String()
}

func (s *GetSoundCodeScheduleRequest) SetIotInstanceId(v string) *GetSoundCodeScheduleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetSoundCodeScheduleRequest) SetScheduleCode(v string) *GetSoundCodeScheduleRequest {
	s.ScheduleCode = &v
	return s
}

type GetSoundCodeScheduleResponseBody struct {
	Code         *string                               `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *GetSoundCodeScheduleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                               `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                               `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                 `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetSoundCodeScheduleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSoundCodeScheduleResponseBody) GoString() string {
	return s.String()
}

func (s *GetSoundCodeScheduleResponseBody) SetCode(v string) *GetSoundCodeScheduleResponseBody {
	s.Code = &v
	return s
}

func (s *GetSoundCodeScheduleResponseBody) SetData(v *GetSoundCodeScheduleResponseBodyData) *GetSoundCodeScheduleResponseBody {
	s.Data = v
	return s
}

func (s *GetSoundCodeScheduleResponseBody) SetErrorMessage(v string) *GetSoundCodeScheduleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetSoundCodeScheduleResponseBody) SetRequestId(v string) *GetSoundCodeScheduleResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSoundCodeScheduleResponseBody) SetSuccess(v bool) *GetSoundCodeScheduleResponseBody {
	s.Success = &v
	return s
}

type GetSoundCodeScheduleResponseBodyData struct {
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	EndDate      *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	GmtCreate    *int64  `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OpenType     *string `json:"OpenType,omitempty" xml:"OpenType,omitempty"`
	ScheduleCode *string `json:"ScheduleCode,omitempty" xml:"ScheduleCode,omitempty"`
	StartDate    *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	StartTime    *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	Status       *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s GetSoundCodeScheduleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetSoundCodeScheduleResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetSoundCodeScheduleResponseBodyData) SetDescription(v string) *GetSoundCodeScheduleResponseBodyData {
	s.Description = &v
	return s
}

func (s *GetSoundCodeScheduleResponseBodyData) SetEndDate(v string) *GetSoundCodeScheduleResponseBodyData {
	s.EndDate = &v
	return s
}

func (s *GetSoundCodeScheduleResponseBodyData) SetEndTime(v string) *GetSoundCodeScheduleResponseBodyData {
	s.EndTime = &v
	return s
}

func (s *GetSoundCodeScheduleResponseBodyData) SetGmtCreate(v int64) *GetSoundCodeScheduleResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *GetSoundCodeScheduleResponseBodyData) SetName(v string) *GetSoundCodeScheduleResponseBodyData {
	s.Name = &v
	return s
}

func (s *GetSoundCodeScheduleResponseBodyData) SetOpenType(v string) *GetSoundCodeScheduleResponseBodyData {
	s.OpenType = &v
	return s
}

func (s *GetSoundCodeScheduleResponseBodyData) SetScheduleCode(v string) *GetSoundCodeScheduleResponseBodyData {
	s.ScheduleCode = &v
	return s
}

func (s *GetSoundCodeScheduleResponseBodyData) SetStartDate(v string) *GetSoundCodeScheduleResponseBodyData {
	s.StartDate = &v
	return s
}

func (s *GetSoundCodeScheduleResponseBodyData) SetStartTime(v string) *GetSoundCodeScheduleResponseBodyData {
	s.StartTime = &v
	return s
}

func (s *GetSoundCodeScheduleResponseBodyData) SetStatus(v string) *GetSoundCodeScheduleResponseBodyData {
	s.Status = &v
	return s
}

type GetSoundCodeScheduleResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSoundCodeScheduleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSoundCodeScheduleResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSoundCodeScheduleResponse) GoString() string {
	return s.String()
}

func (s *GetSoundCodeScheduleResponse) SetHeaders(v map[string]*string) *GetSoundCodeScheduleResponse {
	s.Headers = v
	return s
}

func (s *GetSoundCodeScheduleResponse) SetStatusCode(v int32) *GetSoundCodeScheduleResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSoundCodeScheduleResponse) SetBody(v *GetSoundCodeScheduleResponseBody) *GetSoundCodeScheduleResponse {
	s.Body = v
	return s
}

type GetSpeechDeviceDetailRequest struct {
	IotId         *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s GetSpeechDeviceDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSpeechDeviceDetailRequest) GoString() string {
	return s.String()
}

func (s *GetSpeechDeviceDetailRequest) SetIotId(v string) *GetSpeechDeviceDetailRequest {
	s.IotId = &v
	return s
}

func (s *GetSpeechDeviceDetailRequest) SetIotInstanceId(v string) *GetSpeechDeviceDetailRequest {
	s.IotInstanceId = &v
	return s
}

type GetSpeechDeviceDetailResponseBody struct {
	Code         *string                                `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *GetSpeechDeviceDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                  `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetSpeechDeviceDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSpeechDeviceDetailResponseBody) GoString() string {
	return s.String()
}

func (s *GetSpeechDeviceDetailResponseBody) SetCode(v string) *GetSpeechDeviceDetailResponseBody {
	s.Code = &v
	return s
}

func (s *GetSpeechDeviceDetailResponseBody) SetData(v *GetSpeechDeviceDetailResponseBodyData) *GetSpeechDeviceDetailResponseBody {
	s.Data = v
	return s
}

func (s *GetSpeechDeviceDetailResponseBody) SetErrorMessage(v string) *GetSpeechDeviceDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetSpeechDeviceDetailResponseBody) SetRequestId(v string) *GetSpeechDeviceDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSpeechDeviceDetailResponseBody) SetSuccess(v bool) *GetSpeechDeviceDetailResponseBody {
	s.Success = &v
	return s
}

type GetSpeechDeviceDetailResponseBodyData struct {
	AvailableSpace       *float32 `json:"AvailableSpace,omitempty" xml:"AvailableSpace,omitempty"`
	DeviceName           *string  `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotId                *string  `json:"IotId,omitempty" xml:"IotId,omitempty"`
	ProductKey           *string  `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	SpeechListUpdateTime *int64   `json:"SpeechListUpdateTime,omitempty" xml:"SpeechListUpdateTime,omitempty"`
	Status               *string  `json:"Status,omitempty" xml:"Status,omitempty"`
	TotalSpace           *float32 `json:"TotalSpace,omitempty" xml:"TotalSpace,omitempty"`
}

func (s GetSpeechDeviceDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetSpeechDeviceDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetSpeechDeviceDetailResponseBodyData) SetAvailableSpace(v float32) *GetSpeechDeviceDetailResponseBodyData {
	s.AvailableSpace = &v
	return s
}

func (s *GetSpeechDeviceDetailResponseBodyData) SetDeviceName(v string) *GetSpeechDeviceDetailResponseBodyData {
	s.DeviceName = &v
	return s
}

func (s *GetSpeechDeviceDetailResponseBodyData) SetIotId(v string) *GetSpeechDeviceDetailResponseBodyData {
	s.IotId = &v
	return s
}

func (s *GetSpeechDeviceDetailResponseBodyData) SetProductKey(v string) *GetSpeechDeviceDetailResponseBodyData {
	s.ProductKey = &v
	return s
}

func (s *GetSpeechDeviceDetailResponseBodyData) SetSpeechListUpdateTime(v int64) *GetSpeechDeviceDetailResponseBodyData {
	s.SpeechListUpdateTime = &v
	return s
}

func (s *GetSpeechDeviceDetailResponseBodyData) SetStatus(v string) *GetSpeechDeviceDetailResponseBodyData {
	s.Status = &v
	return s
}

func (s *GetSpeechDeviceDetailResponseBodyData) SetTotalSpace(v float32) *GetSpeechDeviceDetailResponseBodyData {
	s.TotalSpace = &v
	return s
}

type GetSpeechDeviceDetailResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSpeechDeviceDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSpeechDeviceDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSpeechDeviceDetailResponse) GoString() string {
	return s.String()
}

func (s *GetSpeechDeviceDetailResponse) SetHeaders(v map[string]*string) *GetSpeechDeviceDetailResponse {
	s.Headers = v
	return s
}

func (s *GetSpeechDeviceDetailResponse) SetStatusCode(v int32) *GetSpeechDeviceDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSpeechDeviceDetailResponse) SetBody(v *GetSpeechDeviceDetailResponseBody) *GetSpeechDeviceDetailResponse {
	s.Body = v
	return s
}

type GetSpeechLicenseDeviceStatisticsRequest struct {
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
	//
	// For more information, see the [Overview](~~356505~~) topic of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s GetSpeechLicenseDeviceStatisticsRequest) String() string {
	return tea.Prettify(s)
}

func (s GetSpeechLicenseDeviceStatisticsRequest) GoString() string {
	return s.String()
}

func (s *GetSpeechLicenseDeviceStatisticsRequest) SetIotInstanceId(v string) *GetSpeechLicenseDeviceStatisticsRequest {
	s.IotInstanceId = &v
	return s
}

type GetSpeechLicenseDeviceStatisticsResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The response parameters.
	Data *GetSpeechLicenseDeviceStatisticsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetSpeechLicenseDeviceStatisticsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSpeechLicenseDeviceStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *GetSpeechLicenseDeviceStatisticsResponseBody) SetCode(v string) *GetSpeechLicenseDeviceStatisticsResponseBody {
	s.Code = &v
	return s
}

func (s *GetSpeechLicenseDeviceStatisticsResponseBody) SetData(v *GetSpeechLicenseDeviceStatisticsResponseBodyData) *GetSpeechLicenseDeviceStatisticsResponseBody {
	s.Data = v
	return s
}

func (s *GetSpeechLicenseDeviceStatisticsResponseBody) SetErrorMessage(v string) *GetSpeechLicenseDeviceStatisticsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetSpeechLicenseDeviceStatisticsResponseBody) SetRequestId(v string) *GetSpeechLicenseDeviceStatisticsResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSpeechLicenseDeviceStatisticsResponseBody) SetSuccess(v bool) *GetSpeechLicenseDeviceStatisticsResponseBody {
	s.Success = &v
	return s
}

type GetSpeechLicenseDeviceStatisticsResponseBodyData struct {
	// The number of available licenses.
	AvailableQuota *int32 `json:"AvailableQuota,omitempty" xml:"AvailableQuota,omitempty"`
	// The number of expired licenses.
	ExpiredQuota *int32 `json:"ExpiredQuota,omitempty" xml:"ExpiredQuota,omitempty"`
	// The number of licenses that are about to expire.
	ExpiringQuota *int32 `json:"ExpiringQuota,omitempty" xml:"ExpiringQuota,omitempty"`
}

func (s GetSpeechLicenseDeviceStatisticsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetSpeechLicenseDeviceStatisticsResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetSpeechLicenseDeviceStatisticsResponseBodyData) SetAvailableQuota(v int32) *GetSpeechLicenseDeviceStatisticsResponseBodyData {
	s.AvailableQuota = &v
	return s
}

func (s *GetSpeechLicenseDeviceStatisticsResponseBodyData) SetExpiredQuota(v int32) *GetSpeechLicenseDeviceStatisticsResponseBodyData {
	s.ExpiredQuota = &v
	return s
}

func (s *GetSpeechLicenseDeviceStatisticsResponseBodyData) SetExpiringQuota(v int32) *GetSpeechLicenseDeviceStatisticsResponseBodyData {
	s.ExpiringQuota = &v
	return s
}

type GetSpeechLicenseDeviceStatisticsResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSpeechLicenseDeviceStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSpeechLicenseDeviceStatisticsResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSpeechLicenseDeviceStatisticsResponse) GoString() string {
	return s.String()
}

func (s *GetSpeechLicenseDeviceStatisticsResponse) SetHeaders(v map[string]*string) *GetSpeechLicenseDeviceStatisticsResponse {
	s.Headers = v
	return s
}

func (s *GetSpeechLicenseDeviceStatisticsResponse) SetStatusCode(v int32) *GetSpeechLicenseDeviceStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSpeechLicenseDeviceStatisticsResponse) SetBody(v *GetSpeechLicenseDeviceStatisticsResponseBody) *GetSpeechLicenseDeviceStatisticsResponse {
	s.Body = v
	return s
}

type GetSpeechVoiceResponseBody struct {
	Code         *string                         `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *GetSpeechVoiceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                         `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                           `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetSpeechVoiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetSpeechVoiceResponseBody) GoString() string {
	return s.String()
}

func (s *GetSpeechVoiceResponseBody) SetCode(v string) *GetSpeechVoiceResponseBody {
	s.Code = &v
	return s
}

func (s *GetSpeechVoiceResponseBody) SetData(v *GetSpeechVoiceResponseBodyData) *GetSpeechVoiceResponseBody {
	s.Data = v
	return s
}

func (s *GetSpeechVoiceResponseBody) SetErrorMessage(v string) *GetSpeechVoiceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetSpeechVoiceResponseBody) SetRequestId(v string) *GetSpeechVoiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetSpeechVoiceResponseBody) SetSuccess(v bool) *GetSpeechVoiceResponseBody {
	s.Success = &v
	return s
}

type GetSpeechVoiceResponseBodyData struct {
	Items []*GetSpeechVoiceResponseBodyDataItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s GetSpeechVoiceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetSpeechVoiceResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetSpeechVoiceResponseBodyData) SetItems(v []*GetSpeechVoiceResponseBodyDataItems) *GetSpeechVoiceResponseBodyData {
	s.Items = v
	return s
}

type GetSpeechVoiceResponseBodyDataItems struct {
	Label     *string                                       `json:"Label,omitempty" xml:"Label,omitempty"`
	Value     *string                                       `json:"Value,omitempty" xml:"Value,omitempty"`
	VoiceList *GetSpeechVoiceResponseBodyDataItemsVoiceList `json:"VoiceList,omitempty" xml:"VoiceList,omitempty" type:"Struct"`
}

func (s GetSpeechVoiceResponseBodyDataItems) String() string {
	return tea.Prettify(s)
}

func (s GetSpeechVoiceResponseBodyDataItems) GoString() string {
	return s.String()
}

func (s *GetSpeechVoiceResponseBodyDataItems) SetLabel(v string) *GetSpeechVoiceResponseBodyDataItems {
	s.Label = &v
	return s
}

func (s *GetSpeechVoiceResponseBodyDataItems) SetValue(v string) *GetSpeechVoiceResponseBodyDataItems {
	s.Value = &v
	return s
}

func (s *GetSpeechVoiceResponseBodyDataItems) SetVoiceList(v *GetSpeechVoiceResponseBodyDataItemsVoiceList) *GetSpeechVoiceResponseBodyDataItems {
	s.VoiceList = v
	return s
}

type GetSpeechVoiceResponseBodyDataItemsVoiceList struct {
	Items []*GetSpeechVoiceResponseBodyDataItemsVoiceListItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s GetSpeechVoiceResponseBodyDataItemsVoiceList) String() string {
	return tea.Prettify(s)
}

func (s GetSpeechVoiceResponseBodyDataItemsVoiceList) GoString() string {
	return s.String()
}

func (s *GetSpeechVoiceResponseBodyDataItemsVoiceList) SetItems(v []*GetSpeechVoiceResponseBodyDataItemsVoiceListItems) *GetSpeechVoiceResponseBodyDataItemsVoiceList {
	s.Items = v
	return s
}

type GetSpeechVoiceResponseBodyDataItemsVoiceListItems struct {
	Label *string `json:"Label,omitempty" xml:"Label,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s GetSpeechVoiceResponseBodyDataItemsVoiceListItems) String() string {
	return tea.Prettify(s)
}

func (s GetSpeechVoiceResponseBodyDataItemsVoiceListItems) GoString() string {
	return s.String()
}

func (s *GetSpeechVoiceResponseBodyDataItemsVoiceListItems) SetLabel(v string) *GetSpeechVoiceResponseBodyDataItemsVoiceListItems {
	s.Label = &v
	return s
}

func (s *GetSpeechVoiceResponseBodyDataItemsVoiceListItems) SetValue(v string) *GetSpeechVoiceResponseBodyDataItemsVoiceListItems {
	s.Value = &v
	return s
}

type GetSpeechVoiceResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetSpeechVoiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetSpeechVoiceResponse) String() string {
	return tea.Prettify(s)
}

func (s GetSpeechVoiceResponse) GoString() string {
	return s.String()
}

func (s *GetSpeechVoiceResponse) SetHeaders(v map[string]*string) *GetSpeechVoiceResponse {
	s.Headers = v
	return s
}

func (s *GetSpeechVoiceResponse) SetStatusCode(v int32) *GetSpeechVoiceResponse {
	s.StatusCode = &v
	return s
}

func (s *GetSpeechVoiceResponse) SetBody(v *GetSpeechVoiceResponseBody) *GetSpeechVoiceResponse {
	s.Body = v
	return s
}

type GetStudioAppTokenOpenRequest struct {
	AppId         *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProjectId     *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s GetStudioAppTokenOpenRequest) String() string {
	return tea.Prettify(s)
}

func (s GetStudioAppTokenOpenRequest) GoString() string {
	return s.String()
}

func (s *GetStudioAppTokenOpenRequest) SetAppId(v string) *GetStudioAppTokenOpenRequest {
	s.AppId = &v
	return s
}

func (s *GetStudioAppTokenOpenRequest) SetIotInstanceId(v string) *GetStudioAppTokenOpenRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetStudioAppTokenOpenRequest) SetProjectId(v string) *GetStudioAppTokenOpenRequest {
	s.ProjectId = &v
	return s
}

type GetStudioAppTokenOpenResponseBody struct {
	Code         *string                                `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *GetStudioAppTokenOpenResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                  `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetStudioAppTokenOpenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetStudioAppTokenOpenResponseBody) GoString() string {
	return s.String()
}

func (s *GetStudioAppTokenOpenResponseBody) SetCode(v string) *GetStudioAppTokenOpenResponseBody {
	s.Code = &v
	return s
}

func (s *GetStudioAppTokenOpenResponseBody) SetData(v *GetStudioAppTokenOpenResponseBodyData) *GetStudioAppTokenOpenResponseBody {
	s.Data = v
	return s
}

func (s *GetStudioAppTokenOpenResponseBody) SetErrorMessage(v string) *GetStudioAppTokenOpenResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetStudioAppTokenOpenResponseBody) SetRequestId(v string) *GetStudioAppTokenOpenResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetStudioAppTokenOpenResponseBody) SetSuccess(v bool) *GetStudioAppTokenOpenResponseBody {
	s.Success = &v
	return s
}

type GetStudioAppTokenOpenResponseBodyData struct {
	BizId    *string `json:"BizId,omitempty" xml:"BizId,omitempty"`
	BizType  *string `json:"BizType,omitempty" xml:"BizType,omitempty"`
	IsEnable *string `json:"IsEnable,omitempty" xml:"IsEnable,omitempty"`
	Token    *string `json:"Token,omitempty" xml:"Token,omitempty"`
	Type     *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s GetStudioAppTokenOpenResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetStudioAppTokenOpenResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetStudioAppTokenOpenResponseBodyData) SetBizId(v string) *GetStudioAppTokenOpenResponseBodyData {
	s.BizId = &v
	return s
}

func (s *GetStudioAppTokenOpenResponseBodyData) SetBizType(v string) *GetStudioAppTokenOpenResponseBodyData {
	s.BizType = &v
	return s
}

func (s *GetStudioAppTokenOpenResponseBodyData) SetIsEnable(v string) *GetStudioAppTokenOpenResponseBodyData {
	s.IsEnable = &v
	return s
}

func (s *GetStudioAppTokenOpenResponseBodyData) SetToken(v string) *GetStudioAppTokenOpenResponseBodyData {
	s.Token = &v
	return s
}

func (s *GetStudioAppTokenOpenResponseBodyData) SetType(v string) *GetStudioAppTokenOpenResponseBodyData {
	s.Type = &v
	return s
}

type GetStudioAppTokenOpenResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetStudioAppTokenOpenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetStudioAppTokenOpenResponse) String() string {
	return tea.Prettify(s)
}

func (s GetStudioAppTokenOpenResponse) GoString() string {
	return s.String()
}

func (s *GetStudioAppTokenOpenResponse) SetHeaders(v map[string]*string) *GetStudioAppTokenOpenResponse {
	s.Headers = v
	return s
}

func (s *GetStudioAppTokenOpenResponse) SetStatusCode(v int32) *GetStudioAppTokenOpenResponse {
	s.StatusCode = &v
	return s
}

func (s *GetStudioAppTokenOpenResponse) SetBody(v *GetStudioAppTokenOpenResponseBody) *GetStudioAppTokenOpenResponse {
	s.Body = v
	return s
}

type GetThingModelTslRequest struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	FunctionBlockId *string `json:"FunctionBlockId,omitempty" xml:"FunctionBlockId,omitempty"`
	// The ProductKey of the product.
	//
	// You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// Specifies whether to retrieve a simplified TSL model.
	//
	// *   **true**: retrieves a simplified TSL model.
	//
	//     A simplified TSL model includes only the **identifier** and **dataType** attributes of properties, services, events, and related input or output parameters. Simplified TSL models can be used by device developers for reference.
	//
	// *   **false**: retrieves the complete TSL model.
	//
	//     A complete TSL model includes all the parameters and values of properties, services, and events. Complete TSL models can be used by cloud application developers for reference.
	//
	// Default value: false.
	ModelVersion *string `json:"ModelVersion,omitempty" xml:"ModelVersion,omitempty"`
	// The version number of the TSL model to be queried.
	//
	// If you do not specify this parameter, IoT Platform returns the draft TSL model that is unpublished.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The identifier of the custom TSL module. Each identifier is unique in a product.
	//
	// If you do not specify this parameter, the default module is queried.
	Simple *bool `json:"Simple,omitempty" xml:"Simple,omitempty"`
}

func (s GetThingModelTslRequest) String() string {
	return tea.Prettify(s)
}

func (s GetThingModelTslRequest) GoString() string {
	return s.String()
}

func (s *GetThingModelTslRequest) SetFunctionBlockId(v string) *GetThingModelTslRequest {
	s.FunctionBlockId = &v
	return s
}

func (s *GetThingModelTslRequest) SetIotInstanceId(v string) *GetThingModelTslRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetThingModelTslRequest) SetModelVersion(v string) *GetThingModelTslRequest {
	s.ModelVersion = &v
	return s
}

func (s *GetThingModelTslRequest) SetProductKey(v string) *GetThingModelTslRequest {
	s.ProductKey = &v
	return s
}

func (s *GetThingModelTslRequest) SetSimple(v bool) *GetThingModelTslRequest {
	s.Simple = &v
	return s
}

type GetThingModelTslResponseBody struct {
	// The error message returned if the call fails.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The URI that is used to store the TSL data in Object Storage Service (OSS). The URI is valid for 60 minutes.
	Data *GetThingModelTslResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The TSL data returned if the call is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetThingModelTslResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetThingModelTslResponseBody) GoString() string {
	return s.String()
}

func (s *GetThingModelTslResponseBody) SetCode(v string) *GetThingModelTslResponseBody {
	s.Code = &v
	return s
}

func (s *GetThingModelTslResponseBody) SetData(v *GetThingModelTslResponseBodyData) *GetThingModelTslResponseBody {
	s.Data = v
	return s
}

func (s *GetThingModelTslResponseBody) SetErrorMessage(v string) *GetThingModelTslResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetThingModelTslResponseBody) SetRequestId(v string) *GetThingModelTslResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetThingModelTslResponseBody) SetSuccess(v bool) *GetThingModelTslResponseBody {
	s.Success = &v
	return s
}

type GetThingModelTslResponseBodyData struct {
	TslStr *string `json:"TslStr,omitempty" xml:"TslStr,omitempty"`
	// The string of the TSL model.
	TslUri *string `json:"TslUri,omitempty" xml:"TslUri,omitempty"`
}

func (s GetThingModelTslResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetThingModelTslResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetThingModelTslResponseBodyData) SetTslStr(v string) *GetThingModelTslResponseBodyData {
	s.TslStr = &v
	return s
}

func (s *GetThingModelTslResponseBodyData) SetTslUri(v string) *GetThingModelTslResponseBodyData {
	s.TslUri = &v
	return s
}

type GetThingModelTslResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetThingModelTslResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetThingModelTslResponse) String() string {
	return tea.Prettify(s)
}

func (s GetThingModelTslResponse) GoString() string {
	return s.String()
}

func (s *GetThingModelTslResponse) SetHeaders(v map[string]*string) *GetThingModelTslResponse {
	s.Headers = v
	return s
}

func (s *GetThingModelTslResponse) SetStatusCode(v int32) *GetThingModelTslResponse {
	s.StatusCode = &v
	return s
}

func (s *GetThingModelTslResponse) SetBody(v *GetThingModelTslResponseBody) *GetThingModelTslResponse {
	s.Body = v
	return s
}

type GetThingModelTslPublishedRequest struct {
	// The identifier of the custom TSL module. Each identifier is unique in a product.
	//
	// If you do not specify this parameter, the default module is queried.
	FunctionBlockId *string `json:"FunctionBlockId,omitempty" xml:"FunctionBlockId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The version number of the TSL model.
	//
	// You can call the [ListThingModelVersion](~~150318~~) operation to view the version numbers of the TSL model for a product.
	//
	// If you do not specify this parameter, the last published TSL model version is returned.
	ModelVersion *string `json:"ModelVersion,omitempty" xml:"ModelVersion,omitempty"`
	// The **ProductKey** of the product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the resource group.
	//
	// >  You cannot specify this parameter.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// Specifies whether to retrieve a simplified TSL model.
	//
	// *   true: retrieves a simplified TSL model. A simplified TSL model includes only the **identifier** and **dataType** attributes of properties, services, events, and related input or output parameters. Simplified TSL models can be used by device developers for reference.
	// *   false: retrieves the complete TSL model. A complete TSL model includes all the parameters and values of properties, services, and events. Complete TSL models can be used by cloud application developers for reference.
	//
	// Default value: false.
	Simple *bool `json:"Simple,omitempty" xml:"Simple,omitempty"`
}

func (s GetThingModelTslPublishedRequest) String() string {
	return tea.Prettify(s)
}

func (s GetThingModelTslPublishedRequest) GoString() string {
	return s.String()
}

func (s *GetThingModelTslPublishedRequest) SetFunctionBlockId(v string) *GetThingModelTslPublishedRequest {
	s.FunctionBlockId = &v
	return s
}

func (s *GetThingModelTslPublishedRequest) SetIotInstanceId(v string) *GetThingModelTslPublishedRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetThingModelTslPublishedRequest) SetModelVersion(v string) *GetThingModelTslPublishedRequest {
	s.ModelVersion = &v
	return s
}

func (s *GetThingModelTslPublishedRequest) SetProductKey(v string) *GetThingModelTslPublishedRequest {
	s.ProductKey = &v
	return s
}

func (s *GetThingModelTslPublishedRequest) SetResourceGroupId(v string) *GetThingModelTslPublishedRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *GetThingModelTslPublishedRequest) SetSimple(v bool) *GetThingModelTslPublishedRequest {
	s.Simple = &v
	return s
}

type GetThingModelTslPublishedResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *GetThingModelTslPublishedResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetThingModelTslPublishedResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetThingModelTslPublishedResponseBody) GoString() string {
	return s.String()
}

func (s *GetThingModelTslPublishedResponseBody) SetCode(v string) *GetThingModelTslPublishedResponseBody {
	s.Code = &v
	return s
}

func (s *GetThingModelTslPublishedResponseBody) SetData(v *GetThingModelTslPublishedResponseBodyData) *GetThingModelTslPublishedResponseBody {
	s.Data = v
	return s
}

func (s *GetThingModelTslPublishedResponseBody) SetErrorMessage(v string) *GetThingModelTslPublishedResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetThingModelTslPublishedResponseBody) SetRequestId(v string) *GetThingModelTslPublishedResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetThingModelTslPublishedResponseBody) SetSuccess(v bool) *GetThingModelTslPublishedResponseBody {
	s.Success = &v
	return s
}

type GetThingModelTslPublishedResponseBodyData struct {
	// The string of the TSL model.
	TslStr *string `json:"TslStr,omitempty" xml:"TslStr,omitempty"`
	// The URI that is used to store the TSL data in Object Storage Service (OSS). The URI is valid for 60 minutes.
	TslUri *string `json:"TslUri,omitempty" xml:"TslUri,omitempty"`
}

func (s GetThingModelTslPublishedResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetThingModelTslPublishedResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetThingModelTslPublishedResponseBodyData) SetTslStr(v string) *GetThingModelTslPublishedResponseBodyData {
	s.TslStr = &v
	return s
}

func (s *GetThingModelTslPublishedResponseBodyData) SetTslUri(v string) *GetThingModelTslPublishedResponseBodyData {
	s.TslUri = &v
	return s
}

type GetThingModelTslPublishedResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetThingModelTslPublishedResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetThingModelTslPublishedResponse) String() string {
	return tea.Prettify(s)
}

func (s GetThingModelTslPublishedResponse) GoString() string {
	return s.String()
}

func (s *GetThingModelTslPublishedResponse) SetHeaders(v map[string]*string) *GetThingModelTslPublishedResponse {
	s.Headers = v
	return s
}

func (s *GetThingModelTslPublishedResponse) SetStatusCode(v int32) *GetThingModelTslPublishedResponse {
	s.StatusCode = &v
	return s
}

func (s *GetThingModelTslPublishedResponse) SetBody(v *GetThingModelTslPublishedResponseBody) *GetThingModelTslPublishedResponse {
	s.Body = v
	return s
}

type GetThingScriptRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product.
	//
	// You can view the **ProductKey** on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s GetThingScriptRequest) String() string {
	return tea.Prettify(s)
}

func (s GetThingScriptRequest) GoString() string {
	return s.String()
}

func (s *GetThingScriptRequest) SetIotInstanceId(v string) *GetThingScriptRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetThingScriptRequest) SetProductKey(v string) *GetThingScriptRequest {
	s.ProductKey = &v
	return s
}

type GetThingScriptResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call is successful.
	Data *GetThingScriptResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetThingScriptResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetThingScriptResponseBody) GoString() string {
	return s.String()
}

func (s *GetThingScriptResponseBody) SetCode(v string) *GetThingScriptResponseBody {
	s.Code = &v
	return s
}

func (s *GetThingScriptResponseBody) SetData(v *GetThingScriptResponseBodyData) *GetThingScriptResponseBody {
	s.Data = v
	return s
}

func (s *GetThingScriptResponseBody) SetErrorMessage(v string) *GetThingScriptResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetThingScriptResponseBody) SetRequestId(v string) *GetThingScriptResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetThingScriptResponseBody) SetSuccess(v bool) *GetThingScriptResponseBody {
	s.Success = &v
	return s
}

type GetThingScriptResponseBodyData struct {
	// The type of the script. Valid values:
	//
	// *   JavaScript
	// *   Python\_27: Python 2.7
	// *   PHP\_72: PHP 7.2
	ScriptType *string `json:"ScriptType,omitempty" xml:"ScriptType,omitempty"`
	// The URL of the script payload.
	ScriptUrl *string `json:"ScriptUrl,omitempty" xml:"ScriptUrl,omitempty"`
}

func (s GetThingScriptResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetThingScriptResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetThingScriptResponseBodyData) SetScriptType(v string) *GetThingScriptResponseBodyData {
	s.ScriptType = &v
	return s
}

func (s *GetThingScriptResponseBodyData) SetScriptUrl(v string) *GetThingScriptResponseBodyData {
	s.ScriptUrl = &v
	return s
}

type GetThingScriptResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetThingScriptResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetThingScriptResponse) String() string {
	return tea.Prettify(s)
}

func (s GetThingScriptResponse) GoString() string {
	return s.String()
}

func (s *GetThingScriptResponse) SetHeaders(v map[string]*string) *GetThingScriptResponse {
	s.Headers = v
	return s
}

func (s *GetThingScriptResponse) SetStatusCode(v int32) *GetThingScriptResponse {
	s.StatusCode = &v
	return s
}

func (s *GetThingScriptResponse) SetBody(v *GetThingScriptResponseBody) *GetThingScriptResponse {
	s.Body = v
	return s
}

type GetThingTemplateRequest struct {
	// The error message returned if the call fails.
	CategoryKey *string `json:"CategoryKey,omitempty" xml:"CategoryKey,omitempty"`
	// The identifier of the category that you want to query.
	//
	// You can call the [ListThingTemplates](~~150316~~) operation and view all category keys in the response.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s GetThingTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s GetThingTemplateRequest) GoString() string {
	return s.String()
}

func (s *GetThingTemplateRequest) SetCategoryKey(v string) *GetThingTemplateRequest {
	s.CategoryKey = &v
	return s
}

func (s *GetThingTemplateRequest) SetIotInstanceId(v string) *GetThingTemplateRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetThingTemplateRequest) SetResourceGroupId(v string) *GetThingTemplateRequest {
	s.ResourceGroupId = &v
	return s
}

type GetThingTemplateResponseBody struct {
	// The ID of the request.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The TSL features returned if the call is successful. Format:
	//
	// ```
	//
	// {
	//   "properties": [], //The list of properties
	//   "services": [], //The list of services
	//   "events": [], //The list of events
	// }
	//
	// ```
	//
	// For more information, see [TSL formats](~~73727~~).
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
	ThingModelJSON *string `json:"ThingModelJSON,omitempty" xml:"ThingModelJSON,omitempty"`
}

func (s GetThingTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetThingTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *GetThingTemplateResponseBody) SetCode(v string) *GetThingTemplateResponseBody {
	s.Code = &v
	return s
}

func (s *GetThingTemplateResponseBody) SetErrorMessage(v string) *GetThingTemplateResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetThingTemplateResponseBody) SetRequestId(v string) *GetThingTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetThingTemplateResponseBody) SetSuccess(v bool) *GetThingTemplateResponseBody {
	s.Success = &v
	return s
}

func (s *GetThingTemplateResponseBody) SetThingModelJSON(v string) *GetThingTemplateResponseBody {
	s.ThingModelJSON = &v
	return s
}

type GetThingTemplateResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetThingTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetThingTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s GetThingTemplateResponse) GoString() string {
	return s.String()
}

func (s *GetThingTemplateResponse) SetHeaders(v map[string]*string) *GetThingTemplateResponse {
	s.Headers = v
	return s
}

func (s *GetThingTemplateResponse) SetStatusCode(v int32) *GetThingTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *GetThingTemplateResponse) SetBody(v *GetThingTemplateResponseBody) *GetThingTemplateResponse {
	s.Body = v
	return s
}

type GetThingTopoRequest struct {
	// The name of the gateway device.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the gateway device. The ID is the unique identifier that is issued by IoT Platform to the gateway device.
	//
	// >  If you specify this parameter, you do not need to specify the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a unique identifier for the device, and corresponds to a combination of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId** parameter and a combination of the **ProductKey** and **DeviceName** parameters at the same time, the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for public instances. However, this parameter is required for enterprise-edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of the page to return.
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ProductKey of the product to which the gateway device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s GetThingTopoRequest) String() string {
	return tea.Prettify(s)
}

func (s GetThingTopoRequest) GoString() string {
	return s.String()
}

func (s *GetThingTopoRequest) SetDeviceName(v string) *GetThingTopoRequest {
	s.DeviceName = &v
	return s
}

func (s *GetThingTopoRequest) SetIotId(v string) *GetThingTopoRequest {
	s.IotId = &v
	return s
}

func (s *GetThingTopoRequest) SetIotInstanceId(v string) *GetThingTopoRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GetThingTopoRequest) SetPageNo(v int32) *GetThingTopoRequest {
	s.PageNo = &v
	return s
}

func (s *GetThingTopoRequest) SetPageSize(v int32) *GetThingTopoRequest {
	s.PageSize = &v
	return s
}

func (s *GetThingTopoRequest) SetProductKey(v string) *GetThingTopoRequest {
	s.ProductKey = &v
	return s
}

type GetThingTopoResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call succeeds. For more information, see the following parameters.
	Data *GetThingTopoResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call succeeds.
	//
	// *   **true**: The call succeeds.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GetThingTopoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GetThingTopoResponseBody) GoString() string {
	return s.String()
}

func (s *GetThingTopoResponseBody) SetCode(v string) *GetThingTopoResponseBody {
	s.Code = &v
	return s
}

func (s *GetThingTopoResponseBody) SetData(v *GetThingTopoResponseBodyData) *GetThingTopoResponseBody {
	s.Data = v
	return s
}

func (s *GetThingTopoResponseBody) SetErrorMessage(v string) *GetThingTopoResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GetThingTopoResponseBody) SetRequestId(v string) *GetThingTopoResponseBody {
	s.RequestId = &v
	return s
}

func (s *GetThingTopoResponseBody) SetSuccess(v bool) *GetThingTopoResponseBody {
	s.Success = &v
	return s
}

type GetThingTopoResponseBodyData struct {
	// The page number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The details of the sub-device. The details of the sub-device are included in the **deviceInfo** parameter.
	List *GetThingTopoResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	// The total number of pages returned.
	PageCount *int64 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries returned on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	Total *int64 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s GetThingTopoResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GetThingTopoResponseBodyData) GoString() string {
	return s.String()
}

func (s *GetThingTopoResponseBodyData) SetCurrentPage(v int32) *GetThingTopoResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *GetThingTopoResponseBodyData) SetList(v *GetThingTopoResponseBodyDataList) *GetThingTopoResponseBodyData {
	s.List = v
	return s
}

func (s *GetThingTopoResponseBodyData) SetPageCount(v int64) *GetThingTopoResponseBodyData {
	s.PageCount = &v
	return s
}

func (s *GetThingTopoResponseBodyData) SetPageSize(v int32) *GetThingTopoResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *GetThingTopoResponseBodyData) SetTotal(v int64) *GetThingTopoResponseBodyData {
	s.Total = &v
	return s
}

type GetThingTopoResponseBodyDataList struct {
	DeviceInfo []*GetThingTopoResponseBodyDataListDeviceInfo `json:"deviceInfo,omitempty" xml:"deviceInfo,omitempty" type:"Repeated"`
}

func (s GetThingTopoResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s GetThingTopoResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *GetThingTopoResponseBodyDataList) SetDeviceInfo(v []*GetThingTopoResponseBodyDataListDeviceInfo) *GetThingTopoResponseBodyDataList {
	s.DeviceInfo = v
	return s
}

type GetThingTopoResponseBodyDataListDeviceInfo struct {
	// The DeviceName of the sub-device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the sub-device. The ID is the unique identifier that is issued by IoT Platform to the sub-device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ProductKey of the product to which the sub-device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s GetThingTopoResponseBodyDataListDeviceInfo) String() string {
	return tea.Prettify(s)
}

func (s GetThingTopoResponseBodyDataListDeviceInfo) GoString() string {
	return s.String()
}

func (s *GetThingTopoResponseBodyDataListDeviceInfo) SetDeviceName(v string) *GetThingTopoResponseBodyDataListDeviceInfo {
	s.DeviceName = &v
	return s
}

func (s *GetThingTopoResponseBodyDataListDeviceInfo) SetIotId(v string) *GetThingTopoResponseBodyDataListDeviceInfo {
	s.IotId = &v
	return s
}

func (s *GetThingTopoResponseBodyDataListDeviceInfo) SetProductKey(v string) *GetThingTopoResponseBodyDataListDeviceInfo {
	s.ProductKey = &v
	return s
}

type GetThingTopoResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GetThingTopoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GetThingTopoResponse) String() string {
	return tea.Prettify(s)
}

func (s GetThingTopoResponse) GoString() string {
	return s.String()
}

func (s *GetThingTopoResponse) SetHeaders(v map[string]*string) *GetThingTopoResponse {
	s.Headers = v
	return s
}

func (s *GetThingTopoResponse) SetStatusCode(v int32) *GetThingTopoResponse {
	s.StatusCode = &v
	return s
}

func (s *GetThingTopoResponse) SetBody(v *GetThingTopoResponseBody) *GetThingTopoResponse {
	s.Body = v
	return s
}

type GisQueryDeviceLocationRequest struct {
	IotInstanceId *string                                   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ThingList     []*GisQueryDeviceLocationRequestThingList `json:"ThingList,omitempty" xml:"ThingList,omitempty" type:"Repeated"`
}

func (s GisQueryDeviceLocationRequest) String() string {
	return tea.Prettify(s)
}

func (s GisQueryDeviceLocationRequest) GoString() string {
	return s.String()
}

func (s *GisQueryDeviceLocationRequest) SetIotInstanceId(v string) *GisQueryDeviceLocationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GisQueryDeviceLocationRequest) SetThingList(v []*GisQueryDeviceLocationRequestThingList) *GisQueryDeviceLocationRequest {
	s.ThingList = v
	return s
}

type GisQueryDeviceLocationRequestThingList struct {
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s GisQueryDeviceLocationRequestThingList) String() string {
	return tea.Prettify(s)
}

func (s GisQueryDeviceLocationRequestThingList) GoString() string {
	return s.String()
}

func (s *GisQueryDeviceLocationRequestThingList) SetDeviceName(v string) *GisQueryDeviceLocationRequestThingList {
	s.DeviceName = &v
	return s
}

func (s *GisQueryDeviceLocationRequestThingList) SetProductKey(v string) *GisQueryDeviceLocationRequestThingList {
	s.ProductKey = &v
	return s
}

type GisQueryDeviceLocationResponseBody struct {
	Code         *string                                   `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         []*GisQueryDeviceLocationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	ErrorMessage *string                                   `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                     `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GisQueryDeviceLocationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GisQueryDeviceLocationResponseBody) GoString() string {
	return s.String()
}

func (s *GisQueryDeviceLocationResponseBody) SetCode(v string) *GisQueryDeviceLocationResponseBody {
	s.Code = &v
	return s
}

func (s *GisQueryDeviceLocationResponseBody) SetData(v []*GisQueryDeviceLocationResponseBodyData) *GisQueryDeviceLocationResponseBody {
	s.Data = v
	return s
}

func (s *GisQueryDeviceLocationResponseBody) SetErrorMessage(v string) *GisQueryDeviceLocationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GisQueryDeviceLocationResponseBody) SetRequestId(v string) *GisQueryDeviceLocationResponseBody {
	s.RequestId = &v
	return s
}

func (s *GisQueryDeviceLocationResponseBody) SetSuccess(v bool) *GisQueryDeviceLocationResponseBody {
	s.Success = &v
	return s
}

type GisQueryDeviceLocationResponseBodyData struct {
	Adcode           *int64   `json:"Adcode,omitempty" xml:"Adcode,omitempty"`
	City             *string  `json:"City,omitempty" xml:"City,omitempty"`
	CoordinateSystem *int32   `json:"CoordinateSystem,omitempty" xml:"CoordinateSystem,omitempty"`
	Country          *string  `json:"Country,omitempty" xml:"Country,omitempty"`
	DeviceName       *string  `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	Ip               *string  `json:"Ip,omitempty" xml:"Ip,omitempty"`
	Latitude         *float32 `json:"Latitude,omitempty" xml:"Latitude,omitempty"`
	Longitude        *float32 `json:"Longitude,omitempty" xml:"Longitude,omitempty"`
	ProductKey       *string  `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	Province         *string  `json:"Province,omitempty" xml:"Province,omitempty"`
}

func (s GisQueryDeviceLocationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GisQueryDeviceLocationResponseBodyData) GoString() string {
	return s.String()
}

func (s *GisQueryDeviceLocationResponseBodyData) SetAdcode(v int64) *GisQueryDeviceLocationResponseBodyData {
	s.Adcode = &v
	return s
}

func (s *GisQueryDeviceLocationResponseBodyData) SetCity(v string) *GisQueryDeviceLocationResponseBodyData {
	s.City = &v
	return s
}

func (s *GisQueryDeviceLocationResponseBodyData) SetCoordinateSystem(v int32) *GisQueryDeviceLocationResponseBodyData {
	s.CoordinateSystem = &v
	return s
}

func (s *GisQueryDeviceLocationResponseBodyData) SetCountry(v string) *GisQueryDeviceLocationResponseBodyData {
	s.Country = &v
	return s
}

func (s *GisQueryDeviceLocationResponseBodyData) SetDeviceName(v string) *GisQueryDeviceLocationResponseBodyData {
	s.DeviceName = &v
	return s
}

func (s *GisQueryDeviceLocationResponseBodyData) SetIp(v string) *GisQueryDeviceLocationResponseBodyData {
	s.Ip = &v
	return s
}

func (s *GisQueryDeviceLocationResponseBodyData) SetLatitude(v float32) *GisQueryDeviceLocationResponseBodyData {
	s.Latitude = &v
	return s
}

func (s *GisQueryDeviceLocationResponseBodyData) SetLongitude(v float32) *GisQueryDeviceLocationResponseBodyData {
	s.Longitude = &v
	return s
}

func (s *GisQueryDeviceLocationResponseBodyData) SetProductKey(v string) *GisQueryDeviceLocationResponseBodyData {
	s.ProductKey = &v
	return s
}

func (s *GisQueryDeviceLocationResponseBodyData) SetProvince(v string) *GisQueryDeviceLocationResponseBodyData {
	s.Province = &v
	return s
}

type GisQueryDeviceLocationResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GisQueryDeviceLocationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GisQueryDeviceLocationResponse) String() string {
	return tea.Prettify(s)
}

func (s GisQueryDeviceLocationResponse) GoString() string {
	return s.String()
}

func (s *GisQueryDeviceLocationResponse) SetHeaders(v map[string]*string) *GisQueryDeviceLocationResponse {
	s.Headers = v
	return s
}

func (s *GisQueryDeviceLocationResponse) SetStatusCode(v int32) *GisQueryDeviceLocationResponse {
	s.StatusCode = &v
	return s
}

func (s *GisQueryDeviceLocationResponse) SetBody(v *GisQueryDeviceLocationResponseBody) *GisQueryDeviceLocationResponse {
	s.Body = v
	return s
}

type GisSearchDeviceTraceRequest struct {
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	EndTime       *int64  `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	MapMatch      *int32  `json:"MapMatch,omitempty" xml:"MapMatch,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	StartTime     *int64  `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s GisSearchDeviceTraceRequest) String() string {
	return tea.Prettify(s)
}

func (s GisSearchDeviceTraceRequest) GoString() string {
	return s.String()
}

func (s *GisSearchDeviceTraceRequest) SetDeviceName(v string) *GisSearchDeviceTraceRequest {
	s.DeviceName = &v
	return s
}

func (s *GisSearchDeviceTraceRequest) SetEndTime(v int64) *GisSearchDeviceTraceRequest {
	s.EndTime = &v
	return s
}

func (s *GisSearchDeviceTraceRequest) SetIotInstanceId(v string) *GisSearchDeviceTraceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *GisSearchDeviceTraceRequest) SetMapMatch(v int32) *GisSearchDeviceTraceRequest {
	s.MapMatch = &v
	return s
}

func (s *GisSearchDeviceTraceRequest) SetProductKey(v string) *GisSearchDeviceTraceRequest {
	s.ProductKey = &v
	return s
}

func (s *GisSearchDeviceTraceRequest) SetStartTime(v int64) *GisSearchDeviceTraceRequest {
	s.StartTime = &v
	return s
}

type GisSearchDeviceTraceResponseBody struct {
	Code         *string                               `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *GisSearchDeviceTraceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                               `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                               `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                 `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s GisSearchDeviceTraceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s GisSearchDeviceTraceResponseBody) GoString() string {
	return s.String()
}

func (s *GisSearchDeviceTraceResponseBody) SetCode(v string) *GisSearchDeviceTraceResponseBody {
	s.Code = &v
	return s
}

func (s *GisSearchDeviceTraceResponseBody) SetData(v *GisSearchDeviceTraceResponseBodyData) *GisSearchDeviceTraceResponseBody {
	s.Data = v
	return s
}

func (s *GisSearchDeviceTraceResponseBody) SetErrorMessage(v string) *GisSearchDeviceTraceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *GisSearchDeviceTraceResponseBody) SetRequestId(v string) *GisSearchDeviceTraceResponseBody {
	s.RequestId = &v
	return s
}

func (s *GisSearchDeviceTraceResponseBody) SetSuccess(v bool) *GisSearchDeviceTraceResponseBody {
	s.Success = &v
	return s
}

type GisSearchDeviceTraceResponseBodyData struct {
	DeviceName *string                                       `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	Points     []*GisSearchDeviceTraceResponseBodyDataPoints `json:"Points,omitempty" xml:"Points,omitempty" type:"Repeated"`
	ProductKey *string                                       `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s GisSearchDeviceTraceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s GisSearchDeviceTraceResponseBodyData) GoString() string {
	return s.String()
}

func (s *GisSearchDeviceTraceResponseBodyData) SetDeviceName(v string) *GisSearchDeviceTraceResponseBodyData {
	s.DeviceName = &v
	return s
}

func (s *GisSearchDeviceTraceResponseBodyData) SetPoints(v []*GisSearchDeviceTraceResponseBodyDataPoints) *GisSearchDeviceTraceResponseBodyData {
	s.Points = v
	return s
}

func (s *GisSearchDeviceTraceResponseBodyData) SetProductKey(v string) *GisSearchDeviceTraceResponseBodyData {
	s.ProductKey = &v
	return s
}

type GisSearchDeviceTraceResponseBodyDataPoints struct {
	LocateTime *int64  `json:"LocateTime,omitempty" xml:"LocateTime,omitempty"`
	Location   *string `json:"Location,omitempty" xml:"Location,omitempty"`
}

func (s GisSearchDeviceTraceResponseBodyDataPoints) String() string {
	return tea.Prettify(s)
}

func (s GisSearchDeviceTraceResponseBodyDataPoints) GoString() string {
	return s.String()
}

func (s *GisSearchDeviceTraceResponseBodyDataPoints) SetLocateTime(v int64) *GisSearchDeviceTraceResponseBodyDataPoints {
	s.LocateTime = &v
	return s
}

func (s *GisSearchDeviceTraceResponseBodyDataPoints) SetLocation(v string) *GisSearchDeviceTraceResponseBodyDataPoints {
	s.Location = &v
	return s
}

type GisSearchDeviceTraceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *GisSearchDeviceTraceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s GisSearchDeviceTraceResponse) String() string {
	return tea.Prettify(s)
}

func (s GisSearchDeviceTraceResponse) GoString() string {
	return s.String()
}

func (s *GisSearchDeviceTraceResponse) SetHeaders(v map[string]*string) *GisSearchDeviceTraceResponse {
	s.Headers = v
	return s
}

func (s *GisSearchDeviceTraceResponse) SetStatusCode(v int32) *GisSearchDeviceTraceResponse {
	s.StatusCode = &v
	return s
}

func (s *GisSearchDeviceTraceResponse) SetBody(v *GisSearchDeviceTraceResponseBody) *GisSearchDeviceTraceResponse {
	s.Body = v
	return s
}

type ImportDTDataRequest struct {
	DTInstanceId  *string                     `json:"DTInstanceId,omitempty" xml:"DTInstanceId,omitempty"`
	IotInstanceId *string                     `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Items         []*ImportDTDataRequestItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
	ProductKey    *string                     `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s ImportDTDataRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportDTDataRequest) GoString() string {
	return s.String()
}

func (s *ImportDTDataRequest) SetDTInstanceId(v string) *ImportDTDataRequest {
	s.DTInstanceId = &v
	return s
}

func (s *ImportDTDataRequest) SetIotInstanceId(v string) *ImportDTDataRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ImportDTDataRequest) SetItems(v []*ImportDTDataRequestItems) *ImportDTDataRequest {
	s.Items = v
	return s
}

func (s *ImportDTDataRequest) SetProductKey(v string) *ImportDTDataRequest {
	s.ProductKey = &v
	return s
}

type ImportDTDataRequestItems struct {
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	Params     *string `json:"Params,omitempty" xml:"Params,omitempty"`
}

func (s ImportDTDataRequestItems) String() string {
	return tea.Prettify(s)
}

func (s ImportDTDataRequestItems) GoString() string {
	return s.String()
}

func (s *ImportDTDataRequestItems) SetDeviceName(v string) *ImportDTDataRequestItems {
	s.DeviceName = &v
	return s
}

func (s *ImportDTDataRequestItems) SetParams(v string) *ImportDTDataRequestItems {
	s.Params = &v
	return s
}

type ImportDTDataResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ImportDTDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ImportDTDataResponseBody) GoString() string {
	return s.String()
}

func (s *ImportDTDataResponseBody) SetCode(v string) *ImportDTDataResponseBody {
	s.Code = &v
	return s
}

func (s *ImportDTDataResponseBody) SetErrorMessage(v string) *ImportDTDataResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ImportDTDataResponseBody) SetRequestId(v string) *ImportDTDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *ImportDTDataResponseBody) SetSuccess(v bool) *ImportDTDataResponseBody {
	s.Success = &v
	return s
}

type ImportDTDataResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ImportDTDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ImportDTDataResponse) String() string {
	return tea.Prettify(s)
}

func (s ImportDTDataResponse) GoString() string {
	return s.String()
}

func (s *ImportDTDataResponse) SetHeaders(v map[string]*string) *ImportDTDataResponse {
	s.Headers = v
	return s
}

func (s *ImportDTDataResponse) SetStatusCode(v int32) *ImportDTDataResponse {
	s.StatusCode = &v
	return s
}

func (s *ImportDTDataResponse) SetBody(v *ImportDTDataResponseBody) *ImportDTDataResponse {
	s.Body = v
	return s
}

type ImportDeviceRequest struct {
	// The DeviceName of the device.
	//
	// The DeviceName must be 4 to 32 characters in length, and can contain letters, digits, hyphens (-), underscores (\_), at signs (@), periods (.), and colons (:).
	//
	// The DeviceName must be unique in the product.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The DeviceSecret of the device.
	//
	// The DeviceSecret must be 1 to 32 characters in length, and can contain letters, digits, hyphens (-), underscores (\_), at signs (@), periods (.), and colons (:).
	DeviceSecret *string `json:"DeviceSecret,omitempty" xml:"DeviceSecret,omitempty"`
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
	//
	// For more information, see [Overview](~~356505~~) of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The alias of the device.
	//
	// The alias must be 1 to 64 characters in length, and can contain letters, digits, and underscores (\_).
	//
	// > If you do not specify this parameter, IoT Platform does not generate an alias for the device.
	Nickname *string `json:"Nickname,omitempty" xml:"Nickname,omitempty"`
	// The **ProductKey** of the gateway product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The serial number (SN) of the device.
	//
	// The SN must be 1 to 64 characters in length, and can contain letters, digits, and underscores (\_).
	//
	// > If you do not specify this parameter, IoT Platform does not generate an SN for the device.
	Sn *string `json:"Sn,omitempty" xml:"Sn,omitempty"`
}

func (s ImportDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportDeviceRequest) GoString() string {
	return s.String()
}

func (s *ImportDeviceRequest) SetDeviceName(v string) *ImportDeviceRequest {
	s.DeviceName = &v
	return s
}

func (s *ImportDeviceRequest) SetDeviceSecret(v string) *ImportDeviceRequest {
	s.DeviceSecret = &v
	return s
}

func (s *ImportDeviceRequest) SetIotInstanceId(v string) *ImportDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ImportDeviceRequest) SetNickname(v string) *ImportDeviceRequest {
	s.Nickname = &v
	return s
}

func (s *ImportDeviceRequest) SetProductKey(v string) *ImportDeviceRequest {
	s.ProductKey = &v
	return s
}

func (s *ImportDeviceRequest) SetSn(v string) *ImportDeviceRequest {
	s.Sn = &v
	return s
}

type ImportDeviceResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The device information returned if the request is successful.
	Data *ImportDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ImportDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ImportDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *ImportDeviceResponseBody) SetCode(v string) *ImportDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *ImportDeviceResponseBody) SetData(v *ImportDeviceResponseBodyData) *ImportDeviceResponseBody {
	s.Data = v
	return s
}

func (s *ImportDeviceResponseBody) SetErrorMessage(v string) *ImportDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ImportDeviceResponseBody) SetRequestId(v string) *ImportDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ImportDeviceResponseBody) SetSuccess(v bool) *ImportDeviceResponseBody {
	s.Success = &v
	return s
}

type ImportDeviceResponseBodyData struct {
	// The DeviceName of the device.
	//
	// >  Keep the information confidential.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The DeviceSecret of the device.
	//
	// >  Keep the information confidential.
	DeviceSecret *string `json:"DeviceSecret,omitempty" xml:"DeviceSecret,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// >  Keep the information confidential.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The alias of the device.
	//
	// > If you did not specify an alias for the device, the response parameter is empty.
	Nickname *string `json:"Nickname,omitempty" xml:"Nickname,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The SN of the device.
	//
	// > If you did not specify an SN for the device, the response parameter is empty.
	Sn *string `json:"Sn,omitempty" xml:"Sn,omitempty"`
}

func (s ImportDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ImportDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *ImportDeviceResponseBodyData) SetDeviceName(v string) *ImportDeviceResponseBodyData {
	s.DeviceName = &v
	return s
}

func (s *ImportDeviceResponseBodyData) SetDeviceSecret(v string) *ImportDeviceResponseBodyData {
	s.DeviceSecret = &v
	return s
}

func (s *ImportDeviceResponseBodyData) SetIotId(v string) *ImportDeviceResponseBodyData {
	s.IotId = &v
	return s
}

func (s *ImportDeviceResponseBodyData) SetNickname(v string) *ImportDeviceResponseBodyData {
	s.Nickname = &v
	return s
}

func (s *ImportDeviceResponseBodyData) SetProductKey(v string) *ImportDeviceResponseBodyData {
	s.ProductKey = &v
	return s
}

func (s *ImportDeviceResponseBodyData) SetSn(v string) *ImportDeviceResponseBodyData {
	s.Sn = &v
	return s
}

type ImportDeviceResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ImportDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ImportDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s ImportDeviceResponse) GoString() string {
	return s.String()
}

func (s *ImportDeviceResponse) SetHeaders(v map[string]*string) *ImportDeviceResponse {
	s.Headers = v
	return s
}

func (s *ImportDeviceResponse) SetStatusCode(v int32) *ImportDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *ImportDeviceResponse) SetBody(v *ImportDeviceResponseBody) *ImportDeviceResponse {
	s.Body = v
	return s
}

type ImportThingModelTslRequest struct {
	// The identifier of the custom TSL module. Each identifier is unique in a product. The identifier must be 1 to 30 characters in length, and can contain letters, digits, and underscores (\_).
	//
	// This parameter must be used in combination with the **FunctionBlockName** parameter. If you do not specify this parameter, the system imports the default module.
	FunctionBlockId *string `json:"FunctionBlockId,omitempty" xml:"FunctionBlockId,omitempty"`
	// The name of the custom module. The name must be 4 to 30 characters in length, and can contain letters, digits, and underscores (\_).
	//
	// This parameter must be used in combination with the **FunctionBlockId** parameter. If you do not specify this parameter, the system imports the default module.
	FunctionBlockName *string `json:"FunctionBlockName,omitempty" xml:"FunctionBlockName,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product.
	//
	// You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the resource group.
	//
	// >  You cannot specify this parameter.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The TSL model to be edited. The value is a JSON string. The TSL model defines the properties, services, and events of the product.
	//
	// The value of the **TslStr** parameter must conform to the standard TSL data format. For more information, see [TSL data format](~~73727~~).
	//
	// >  To import a TSL model, you must specify the **TslStr** parameter.
	TslStr *string `json:"TslStr,omitempty" xml:"TslStr,omitempty"`
	// The URI that is used to store the TSL data in Object Storage Service (OSS).
	//
	// >  This parameter does not take effect. To import a TSL model, you must specify the **TslStr** parameter.
	TslUrl *string `json:"TslUrl,omitempty" xml:"TslUrl,omitempty"`
}

func (s ImportThingModelTslRequest) String() string {
	return tea.Prettify(s)
}

func (s ImportThingModelTslRequest) GoString() string {
	return s.String()
}

func (s *ImportThingModelTslRequest) SetFunctionBlockId(v string) *ImportThingModelTslRequest {
	s.FunctionBlockId = &v
	return s
}

func (s *ImportThingModelTslRequest) SetFunctionBlockName(v string) *ImportThingModelTslRequest {
	s.FunctionBlockName = &v
	return s
}

func (s *ImportThingModelTslRequest) SetIotInstanceId(v string) *ImportThingModelTslRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ImportThingModelTslRequest) SetProductKey(v string) *ImportThingModelTslRequest {
	s.ProductKey = &v
	return s
}

func (s *ImportThingModelTslRequest) SetResourceGroupId(v string) *ImportThingModelTslRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *ImportThingModelTslRequest) SetTslStr(v string) *ImportThingModelTslRequest {
	s.TslStr = &v
	return s
}

func (s *ImportThingModelTslRequest) SetTslUrl(v string) *ImportThingModelTslRequest {
	s.TslUrl = &v
	return s
}

type ImportThingModelTslResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ImportThingModelTslResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ImportThingModelTslResponseBody) GoString() string {
	return s.String()
}

func (s *ImportThingModelTslResponseBody) SetCode(v string) *ImportThingModelTslResponseBody {
	s.Code = &v
	return s
}

func (s *ImportThingModelTslResponseBody) SetErrorMessage(v string) *ImportThingModelTslResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ImportThingModelTslResponseBody) SetRequestId(v string) *ImportThingModelTslResponseBody {
	s.RequestId = &v
	return s
}

func (s *ImportThingModelTslResponseBody) SetSuccess(v bool) *ImportThingModelTslResponseBody {
	s.Success = &v
	return s
}

type ImportThingModelTslResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ImportThingModelTslResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ImportThingModelTslResponse) String() string {
	return tea.Prettify(s)
}

func (s ImportThingModelTslResponse) GoString() string {
	return s.String()
}

func (s *ImportThingModelTslResponse) SetHeaders(v map[string]*string) *ImportThingModelTslResponse {
	s.Headers = v
	return s
}

func (s *ImportThingModelTslResponse) SetStatusCode(v int32) *ImportThingModelTslResponse {
	s.StatusCode = &v
	return s
}

func (s *ImportThingModelTslResponse) SetBody(v *ImportThingModelTslResponseBody) *ImportThingModelTslResponse {
	s.Body = v
	return s
}

type InvokeDataAPIServiceRequest struct {
	ApiSrn        *string                             `json:"ApiSrn,omitempty" xml:"ApiSrn,omitempty"`
	IotInstanceId *string                             `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Param         []*InvokeDataAPIServiceRequestParam `json:"Param,omitempty" xml:"Param,omitempty" type:"Repeated"`
}

func (s InvokeDataAPIServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s InvokeDataAPIServiceRequest) GoString() string {
	return s.String()
}

func (s *InvokeDataAPIServiceRequest) SetApiSrn(v string) *InvokeDataAPIServiceRequest {
	s.ApiSrn = &v
	return s
}

func (s *InvokeDataAPIServiceRequest) SetIotInstanceId(v string) *InvokeDataAPIServiceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *InvokeDataAPIServiceRequest) SetParam(v []*InvokeDataAPIServiceRequestParam) *InvokeDataAPIServiceRequest {
	s.Param = v
	return s
}

type InvokeDataAPIServiceRequestParam struct {
	ListParamType  *string   `json:"ListParamType,omitempty" xml:"ListParamType,omitempty"`
	ListParamValue []*string `json:"ListParamValue,omitempty" xml:"ListParamValue,omitempty" type:"Repeated"`
	ParamName      *string   `json:"ParamName,omitempty" xml:"ParamName,omitempty"`
	ParamType      *string   `json:"ParamType,omitempty" xml:"ParamType,omitempty"`
	ParamValue     *string   `json:"ParamValue,omitempty" xml:"ParamValue,omitempty"`
}

func (s InvokeDataAPIServiceRequestParam) String() string {
	return tea.Prettify(s)
}

func (s InvokeDataAPIServiceRequestParam) GoString() string {
	return s.String()
}

func (s *InvokeDataAPIServiceRequestParam) SetListParamType(v string) *InvokeDataAPIServiceRequestParam {
	s.ListParamType = &v
	return s
}

func (s *InvokeDataAPIServiceRequestParam) SetListParamValue(v []*string) *InvokeDataAPIServiceRequestParam {
	s.ListParamValue = v
	return s
}

func (s *InvokeDataAPIServiceRequestParam) SetParamName(v string) *InvokeDataAPIServiceRequestParam {
	s.ParamName = &v
	return s
}

func (s *InvokeDataAPIServiceRequestParam) SetParamType(v string) *InvokeDataAPIServiceRequestParam {
	s.ParamType = &v
	return s
}

func (s *InvokeDataAPIServiceRequestParam) SetParamValue(v string) *InvokeDataAPIServiceRequestParam {
	s.ParamValue = &v
	return s
}

type InvokeDataAPIServiceResponseBody struct {
	Code         *string                               `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *InvokeDataAPIServiceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                               `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                               `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                 `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s InvokeDataAPIServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InvokeDataAPIServiceResponseBody) GoString() string {
	return s.String()
}

func (s *InvokeDataAPIServiceResponseBody) SetCode(v string) *InvokeDataAPIServiceResponseBody {
	s.Code = &v
	return s
}

func (s *InvokeDataAPIServiceResponseBody) SetData(v *InvokeDataAPIServiceResponseBodyData) *InvokeDataAPIServiceResponseBody {
	s.Data = v
	return s
}

func (s *InvokeDataAPIServiceResponseBody) SetErrorMessage(v string) *InvokeDataAPIServiceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *InvokeDataAPIServiceResponseBody) SetRequestId(v string) *InvokeDataAPIServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *InvokeDataAPIServiceResponseBody) SetSuccess(v bool) *InvokeDataAPIServiceResponseBody {
	s.Success = &v
	return s
}

type InvokeDataAPIServiceResponseBodyData struct {
	ApiSrn        *string                                            `json:"ApiSrn,omitempty" xml:"ApiSrn,omitempty"`
	FieldNameList *InvokeDataAPIServiceResponseBodyDataFieldNameList `json:"FieldNameList,omitempty" xml:"FieldNameList,omitempty" type:"Struct"`
	PageNo        *int32                                             `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	PageSize      *int32                                             `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResultList    *InvokeDataAPIServiceResponseBodyDataResultList    `json:"ResultList,omitempty" xml:"ResultList,omitempty" type:"Struct"`
	TotalSize     *int32                                             `json:"TotalSize,omitempty" xml:"TotalSize,omitempty"`
}

func (s InvokeDataAPIServiceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s InvokeDataAPIServiceResponseBodyData) GoString() string {
	return s.String()
}

func (s *InvokeDataAPIServiceResponseBodyData) SetApiSrn(v string) *InvokeDataAPIServiceResponseBodyData {
	s.ApiSrn = &v
	return s
}

func (s *InvokeDataAPIServiceResponseBodyData) SetFieldNameList(v *InvokeDataAPIServiceResponseBodyDataFieldNameList) *InvokeDataAPIServiceResponseBodyData {
	s.FieldNameList = v
	return s
}

func (s *InvokeDataAPIServiceResponseBodyData) SetPageNo(v int32) *InvokeDataAPIServiceResponseBodyData {
	s.PageNo = &v
	return s
}

func (s *InvokeDataAPIServiceResponseBodyData) SetPageSize(v int32) *InvokeDataAPIServiceResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *InvokeDataAPIServiceResponseBodyData) SetResultList(v *InvokeDataAPIServiceResponseBodyDataResultList) *InvokeDataAPIServiceResponseBodyData {
	s.ResultList = v
	return s
}

func (s *InvokeDataAPIServiceResponseBodyData) SetTotalSize(v int32) *InvokeDataAPIServiceResponseBodyData {
	s.TotalSize = &v
	return s
}

type InvokeDataAPIServiceResponseBodyDataFieldNameList struct {
	FieldNameList []*string `json:"FieldNameList,omitempty" xml:"FieldNameList,omitempty" type:"Repeated"`
}

func (s InvokeDataAPIServiceResponseBodyDataFieldNameList) String() string {
	return tea.Prettify(s)
}

func (s InvokeDataAPIServiceResponseBodyDataFieldNameList) GoString() string {
	return s.String()
}

func (s *InvokeDataAPIServiceResponseBodyDataFieldNameList) SetFieldNameList(v []*string) *InvokeDataAPIServiceResponseBodyDataFieldNameList {
	s.FieldNameList = v
	return s
}

type InvokeDataAPIServiceResponseBodyDataResultList struct {
	ResultList []map[string]interface{} `json:"ResultList,omitempty" xml:"ResultList,omitempty" type:"Repeated"`
}

func (s InvokeDataAPIServiceResponseBodyDataResultList) String() string {
	return tea.Prettify(s)
}

func (s InvokeDataAPIServiceResponseBodyDataResultList) GoString() string {
	return s.String()
}

func (s *InvokeDataAPIServiceResponseBodyDataResultList) SetResultList(v []map[string]interface{}) *InvokeDataAPIServiceResponseBodyDataResultList {
	s.ResultList = v
	return s
}

type InvokeDataAPIServiceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *InvokeDataAPIServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s InvokeDataAPIServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s InvokeDataAPIServiceResponse) GoString() string {
	return s.String()
}

func (s *InvokeDataAPIServiceResponse) SetHeaders(v map[string]*string) *InvokeDataAPIServiceResponse {
	s.Headers = v
	return s
}

func (s *InvokeDataAPIServiceResponse) SetStatusCode(v int32) *InvokeDataAPIServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *InvokeDataAPIServiceResponse) SetBody(v *InvokeDataAPIServiceResponseBody) *InvokeDataAPIServiceResponse {
	s.Body = v
	return s
}

type InvokeThingServiceRequest struct {
	// The input parameter of the service. The value is a JSON string. Example: **Args={"param1": 1}**.
	//
	// If this parameter is left empty, set the value to **Args={}**.
	//
	// > If the TSL data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
	Args *string `json:"Args,omitempty" xml:"Args,omitempty"`
	// The DeviceName of the device to which the required service belongs.
	//
	// > If you configure this parameter, you must specify a value for the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The identifier of the service.
	//
	// You can use one of the following methods to view the **identifier** of the service:
	//
	// *   Log on to the [IoT Platform console](https://iot.console.aliyun.com/). On the **Define Feature** tab of the product to which the device belongs, view the identifier.
	// *   Call the [QueryThingModel](~~150321~~) operation and view the identifier in the TSL information that is returned.
	//
	// >  If a service named testService belongs to a custom module named testFb, you can set this parameter to ******testFb:testService******. The custom module is not the default module.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// >The IotId parameter specifies a globally unique identifier (GUID) for the device. The value of the **IotId** parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for this parameter, you do not need to configure the **ProductKey** or **DeviceName** parameter. If you specify values for the **IotId**,**ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the elastic container instance. On the **Overview** page in the IoT Platform console, you can view the ID of the instance.****
	//
	// >*   If your instance has an ID, you must specify the ID for the parameter. Otherwise, the call fails.********
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >If you configure this parameter, you must specify a value for the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	Qos        *int32  `json:"Qos,omitempty" xml:"Qos,omitempty"`
}

func (s InvokeThingServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s InvokeThingServiceRequest) GoString() string {
	return s.String()
}

func (s *InvokeThingServiceRequest) SetArgs(v string) *InvokeThingServiceRequest {
	s.Args = &v
	return s
}

func (s *InvokeThingServiceRequest) SetDeviceName(v string) *InvokeThingServiceRequest {
	s.DeviceName = &v
	return s
}

func (s *InvokeThingServiceRequest) SetIdentifier(v string) *InvokeThingServiceRequest {
	s.Identifier = &v
	return s
}

func (s *InvokeThingServiceRequest) SetIotId(v string) *InvokeThingServiceRequest {
	s.IotId = &v
	return s
}

func (s *InvokeThingServiceRequest) SetIotInstanceId(v string) *InvokeThingServiceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *InvokeThingServiceRequest) SetProductKey(v string) *InvokeThingServiceRequest {
	s.ProductKey = &v
	return s
}

func (s *InvokeThingServiceRequest) SetQos(v int32) *InvokeThingServiceRequest {
	s.Qos = &v
	return s
}

type InvokeThingServiceResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call is successful.
	Data *InvokeThingServiceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful. However, this value does not indicate that the service is implemented. To obtain the implementation result, view the logs of the device.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s InvokeThingServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InvokeThingServiceResponseBody) GoString() string {
	return s.String()
}

func (s *InvokeThingServiceResponseBody) SetCode(v string) *InvokeThingServiceResponseBody {
	s.Code = &v
	return s
}

func (s *InvokeThingServiceResponseBody) SetData(v *InvokeThingServiceResponseBodyData) *InvokeThingServiceResponseBody {
	s.Data = v
	return s
}

func (s *InvokeThingServiceResponseBody) SetErrorMessage(v string) *InvokeThingServiceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *InvokeThingServiceResponseBody) SetRequestId(v string) *InvokeThingServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *InvokeThingServiceResponseBody) SetSuccess(v bool) *InvokeThingServiceResponseBody {
	s.Success = &v
	return s
}

type InvokeThingServiceResponseBodyData struct {
	// The ID of the message. IoT Platform sends the message to the device to call the service.
	MessageId *string `json:"MessageId,omitempty" xml:"MessageId,omitempty"`
	// The result of the synchronous call.
	//
	// If you asynchronously call the service, this parameter is not returned.
	Result *string `json:"Result,omitempty" xml:"Result,omitempty"`
}

func (s InvokeThingServiceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s InvokeThingServiceResponseBodyData) GoString() string {
	return s.String()
}

func (s *InvokeThingServiceResponseBodyData) SetMessageId(v string) *InvokeThingServiceResponseBodyData {
	s.MessageId = &v
	return s
}

func (s *InvokeThingServiceResponseBodyData) SetResult(v string) *InvokeThingServiceResponseBodyData {
	s.Result = &v
	return s
}

type InvokeThingServiceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *InvokeThingServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s InvokeThingServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s InvokeThingServiceResponse) GoString() string {
	return s.String()
}

func (s *InvokeThingServiceResponse) SetHeaders(v map[string]*string) *InvokeThingServiceResponse {
	s.Headers = v
	return s
}

func (s *InvokeThingServiceResponse) SetStatusCode(v int32) *InvokeThingServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *InvokeThingServiceResponse) SetBody(v *InvokeThingServiceResponseBody) *InvokeThingServiceResponse {
	s.Body = v
	return s
}

type InvokeThingsServiceRequest struct {
	// The input parameter of the service. The value is a JSON string. Example: **Args={"param1": 1}**.
	//
	// If this parameter is left empty, set the value to **Args={}**.
	//
	// >If the TSL data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
	Args       *string   `json:"Args,omitempty" xml:"Args,omitempty"`
	DeviceName []*string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty" type:"Repeated"`
	// The identifier of the service.
	//
	// You can use one of the following methods to view the **identifier** of the service.
	//
	// *   Log on to the IoT Platform console. On the **Define Feature** tab of the product to which the device belongs, you can view the identifier.
	// *   Call the [QueryThingModel](~~150321~~) operation and view the identifier in the TSL information that is returned.
	//
	// >  If a service named testService belongs to a custom module named testFb, you can set this parameter to ******testFb:testService******. The custom module is not the default module.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	Qos        *int32  `json:"Qos,omitempty" xml:"Qos,omitempty"`
}

func (s InvokeThingsServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s InvokeThingsServiceRequest) GoString() string {
	return s.String()
}

func (s *InvokeThingsServiceRequest) SetArgs(v string) *InvokeThingsServiceRequest {
	s.Args = &v
	return s
}

func (s *InvokeThingsServiceRequest) SetDeviceName(v []*string) *InvokeThingsServiceRequest {
	s.DeviceName = v
	return s
}

func (s *InvokeThingsServiceRequest) SetIdentifier(v string) *InvokeThingsServiceRequest {
	s.Identifier = &v
	return s
}

func (s *InvokeThingsServiceRequest) SetIotInstanceId(v string) *InvokeThingsServiceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *InvokeThingsServiceRequest) SetProductKey(v string) *InvokeThingsServiceRequest {
	s.ProductKey = &v
	return s
}

func (s *InvokeThingsServiceRequest) SetQos(v int32) *InvokeThingsServiceRequest {
	s.Qos = &v
	return s
}

type InvokeThingsServiceResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful. However, this value does not indicate that the service is implemented. To obtain the implementation result, view the logs of the device.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s InvokeThingsServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s InvokeThingsServiceResponseBody) GoString() string {
	return s.String()
}

func (s *InvokeThingsServiceResponseBody) SetCode(v string) *InvokeThingsServiceResponseBody {
	s.Code = &v
	return s
}

func (s *InvokeThingsServiceResponseBody) SetErrorMessage(v string) *InvokeThingsServiceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *InvokeThingsServiceResponseBody) SetRequestId(v string) *InvokeThingsServiceResponseBody {
	s.RequestId = &v
	return s
}

func (s *InvokeThingsServiceResponseBody) SetSuccess(v bool) *InvokeThingsServiceResponseBody {
	s.Success = &v
	return s
}

type InvokeThingsServiceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *InvokeThingsServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s InvokeThingsServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s InvokeThingsServiceResponse) GoString() string {
	return s.String()
}

func (s *InvokeThingsServiceResponse) SetHeaders(v map[string]*string) *InvokeThingsServiceResponse {
	s.Headers = v
	return s
}

func (s *InvokeThingsServiceResponse) SetStatusCode(v int32) *InvokeThingsServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *InvokeThingsServiceResponse) SetBody(v *InvokeThingsServiceResponseBody) *InvokeThingsServiceResponse {
	s.Body = v
	return s
}

type ListAnalyticsDataRequest struct {
	ApiPath       *string                              `json:"ApiPath,omitempty" xml:"ApiPath,omitempty"`
	Condition     []*ListAnalyticsDataRequestCondition `json:"Condition,omitempty" xml:"Condition,omitempty" type:"Repeated"`
	IotInstanceId *string                              `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	IsoId         *string                              `json:"IsoId,omitempty" xml:"IsoId,omitempty"`
	PageNum       *int32                               `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	PageSize      *int32                               `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListAnalyticsDataRequest) String() string {
	return tea.Prettify(s)
}

func (s ListAnalyticsDataRequest) GoString() string {
	return s.String()
}

func (s *ListAnalyticsDataRequest) SetApiPath(v string) *ListAnalyticsDataRequest {
	s.ApiPath = &v
	return s
}

func (s *ListAnalyticsDataRequest) SetCondition(v []*ListAnalyticsDataRequestCondition) *ListAnalyticsDataRequest {
	s.Condition = v
	return s
}

func (s *ListAnalyticsDataRequest) SetIotInstanceId(v string) *ListAnalyticsDataRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListAnalyticsDataRequest) SetIsoId(v string) *ListAnalyticsDataRequest {
	s.IsoId = &v
	return s
}

func (s *ListAnalyticsDataRequest) SetPageNum(v int32) *ListAnalyticsDataRequest {
	s.PageNum = &v
	return s
}

func (s *ListAnalyticsDataRequest) SetPageSize(v int32) *ListAnalyticsDataRequest {
	s.PageSize = &v
	return s
}

type ListAnalyticsDataRequestCondition struct {
	BetweenEnd   *string `json:"BetweenEnd,omitempty" xml:"BetweenEnd,omitempty"`
	BetweenStart *string `json:"BetweenStart,omitempty" xml:"BetweenStart,omitempty"`
	FieldName    *string `json:"FieldName,omitempty" xml:"FieldName,omitempty"`
	Operate      *string `json:"Operate,omitempty" xml:"Operate,omitempty"`
	Value        *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListAnalyticsDataRequestCondition) String() string {
	return tea.Prettify(s)
}

func (s ListAnalyticsDataRequestCondition) GoString() string {
	return s.String()
}

func (s *ListAnalyticsDataRequestCondition) SetBetweenEnd(v string) *ListAnalyticsDataRequestCondition {
	s.BetweenEnd = &v
	return s
}

func (s *ListAnalyticsDataRequestCondition) SetBetweenStart(v string) *ListAnalyticsDataRequestCondition {
	s.BetweenStart = &v
	return s
}

func (s *ListAnalyticsDataRequestCondition) SetFieldName(v string) *ListAnalyticsDataRequestCondition {
	s.FieldName = &v
	return s
}

func (s *ListAnalyticsDataRequestCondition) SetOperate(v string) *ListAnalyticsDataRequestCondition {
	s.Operate = &v
	return s
}

func (s *ListAnalyticsDataRequestCondition) SetValue(v string) *ListAnalyticsDataRequestCondition {
	s.Value = &v
	return s
}

type ListAnalyticsDataResponseBody struct {
	Code         *string                            `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *ListAnalyticsDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                            `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                              `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListAnalyticsDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListAnalyticsDataResponseBody) GoString() string {
	return s.String()
}

func (s *ListAnalyticsDataResponseBody) SetCode(v string) *ListAnalyticsDataResponseBody {
	s.Code = &v
	return s
}

func (s *ListAnalyticsDataResponseBody) SetData(v *ListAnalyticsDataResponseBodyData) *ListAnalyticsDataResponseBody {
	s.Data = v
	return s
}

func (s *ListAnalyticsDataResponseBody) SetErrorMessage(v string) *ListAnalyticsDataResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListAnalyticsDataResponseBody) SetRequestId(v string) *ListAnalyticsDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListAnalyticsDataResponseBody) SetSuccess(v bool) *ListAnalyticsDataResponseBody {
	s.Success = &v
	return s
}

type ListAnalyticsDataResponseBodyData struct {
	Count      *int64  `json:"Count,omitempty" xml:"Count,omitempty"`
	HasNext    *bool   `json:"HasNext,omitempty" xml:"HasNext,omitempty"`
	PageNum    *int32  `json:"PageNum,omitempty" xml:"PageNum,omitempty"`
	PageSize   *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ResultJson *string `json:"ResultJson,omitempty" xml:"ResultJson,omitempty"`
}

func (s ListAnalyticsDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListAnalyticsDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListAnalyticsDataResponseBodyData) SetCount(v int64) *ListAnalyticsDataResponseBodyData {
	s.Count = &v
	return s
}

func (s *ListAnalyticsDataResponseBodyData) SetHasNext(v bool) *ListAnalyticsDataResponseBodyData {
	s.HasNext = &v
	return s
}

func (s *ListAnalyticsDataResponseBodyData) SetPageNum(v int32) *ListAnalyticsDataResponseBodyData {
	s.PageNum = &v
	return s
}

func (s *ListAnalyticsDataResponseBodyData) SetPageSize(v int32) *ListAnalyticsDataResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *ListAnalyticsDataResponseBodyData) SetResultJson(v string) *ListAnalyticsDataResponseBodyData {
	s.ResultJson = &v
	return s
}

type ListAnalyticsDataResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListAnalyticsDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListAnalyticsDataResponse) String() string {
	return tea.Prettify(s)
}

func (s ListAnalyticsDataResponse) GoString() string {
	return s.String()
}

func (s *ListAnalyticsDataResponse) SetHeaders(v map[string]*string) *ListAnalyticsDataResponse {
	s.Headers = v
	return s
}

func (s *ListAnalyticsDataResponse) SetStatusCode(v int32) *ListAnalyticsDataResponse {
	s.StatusCode = &v
	return s
}

func (s *ListAnalyticsDataResponse) SetBody(v *ListAnalyticsDataResponseBody) *ListAnalyticsDataResponse {
	s.Body = v
	return s
}

type ListDataSourceItemRequest struct {
	// The data source ID.
	//
	// You can call the [ListParserDataSource](~~432676~~) operation to obtain the IDs of all data sources of the instance.
	DataSourceId *int64 `json:"DataSourceId,omitempty" xml:"DataSourceId,omitempty"`
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
	//
	// For more information, see the [Overview](~~356505~~) topic of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Page          *int32  `json:"Page,omitempty" xml:"Page,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SearchName    *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
}

func (s ListDataSourceItemRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDataSourceItemRequest) GoString() string {
	return s.String()
}

func (s *ListDataSourceItemRequest) SetDataSourceId(v int64) *ListDataSourceItemRequest {
	s.DataSourceId = &v
	return s
}

func (s *ListDataSourceItemRequest) SetIotInstanceId(v string) *ListDataSourceItemRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListDataSourceItemRequest) SetPage(v int32) *ListDataSourceItemRequest {
	s.Page = &v
	return s
}

func (s *ListDataSourceItemRequest) SetPageSize(v int32) *ListDataSourceItemRequest {
	s.PageSize = &v
	return s
}

func (s *ListDataSourceItemRequest) SetSearchName(v string) *ListDataSourceItemRequest {
	s.SearchName = &v
	return s
}

type ListDataSourceItemResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The information about the topics that are returned.
	DataSourceItems *ListDataSourceItemResponseBodyDataSourceItems `json:"DataSourceItems,omitempty" xml:"DataSourceItems,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The page number.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListDataSourceItemResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDataSourceItemResponseBody) GoString() string {
	return s.String()
}

func (s *ListDataSourceItemResponseBody) SetCode(v string) *ListDataSourceItemResponseBody {
	s.Code = &v
	return s
}

func (s *ListDataSourceItemResponseBody) SetDataSourceItems(v *ListDataSourceItemResponseBodyDataSourceItems) *ListDataSourceItemResponseBody {
	s.DataSourceItems = v
	return s
}

func (s *ListDataSourceItemResponseBody) SetErrorMessage(v string) *ListDataSourceItemResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDataSourceItemResponseBody) SetPage(v int32) *ListDataSourceItemResponseBody {
	s.Page = &v
	return s
}

func (s *ListDataSourceItemResponseBody) SetPageSize(v int32) *ListDataSourceItemResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListDataSourceItemResponseBody) SetRequestId(v string) *ListDataSourceItemResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDataSourceItemResponseBody) SetSuccess(v bool) *ListDataSourceItemResponseBody {
	s.Success = &v
	return s
}

func (s *ListDataSourceItemResponseBody) SetTotal(v int32) *ListDataSourceItemResponseBody {
	s.Total = &v
	return s
}

type ListDataSourceItemResponseBodyDataSourceItems struct {
	DataSourceItem []*ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem `json:"dataSourceItem,omitempty" xml:"dataSourceItem,omitempty" type:"Repeated"`
}

func (s ListDataSourceItemResponseBodyDataSourceItems) String() string {
	return tea.Prettify(s)
}

func (s ListDataSourceItemResponseBodyDataSourceItems) GoString() string {
	return s.String()
}

func (s *ListDataSourceItemResponseBodyDataSourceItems) SetDataSourceItem(v []*ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem) *ListDataSourceItemResponseBodyDataSourceItems {
	s.DataSourceItem = v
	return s
}

type ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem struct {
	// The ID of the topic of the data source.
	DataSourceItemId *int64  `json:"DataSourceItemId,omitempty" xml:"DataSourceItemId,omitempty"`
	DeviceName       *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	ProductKey       *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	ScopeType        *string `json:"ScopeType,omitempty" xml:"ScopeType,omitempty"`
	// The name of the topic of the data source.
	Topic *string `json:"Topic,omitempty" xml:"Topic,omitempty"`
}

func (s ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem) String() string {
	return tea.Prettify(s)
}

func (s ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem) GoString() string {
	return s.String()
}

func (s *ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem) SetDataSourceItemId(v int64) *ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem {
	s.DataSourceItemId = &v
	return s
}

func (s *ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem) SetDeviceName(v string) *ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem {
	s.DeviceName = &v
	return s
}

func (s *ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem) SetProductKey(v string) *ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem {
	s.ProductKey = &v
	return s
}

func (s *ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem) SetScopeType(v string) *ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem {
	s.ScopeType = &v
	return s
}

func (s *ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem) SetTopic(v string) *ListDataSourceItemResponseBodyDataSourceItemsDataSourceItem {
	s.Topic = &v
	return s
}

type ListDataSourceItemResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDataSourceItemResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDataSourceItemResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDataSourceItemResponse) GoString() string {
	return s.String()
}

func (s *ListDataSourceItemResponse) SetHeaders(v map[string]*string) *ListDataSourceItemResponse {
	s.Headers = v
	return s
}

func (s *ListDataSourceItemResponse) SetStatusCode(v int32) *ListDataSourceItemResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDataSourceItemResponse) SetBody(v *ListDataSourceItemResponseBody) *ListDataSourceItemResponse {
	s.Body = v
	return s
}

type ListDestinationRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Page          *int32  `json:"Page,omitempty" xml:"Page,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SearchName    *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
	// The actions of forwarding data to data destinations. Data is processed by using a parser script before the data is forwarded. Valid values:
	//
	// *   **REPUBLISH**: forwards topic data to an IoT Platform communication topic.
	// *   **AMQP**: forwards topic data to an Advanced Message Queuing Protocol (AMQP) consumer group.
	// *   **DATAHUB**: forwards topic data to Alibaba Cloud DataHub for stream data processing.
	// *   **ONS**: forwards topic data to Message Queue for Apache RocketMQ for message distribution.
	// *   **MNS**: forwards topic data to Message Service (MNS) for message transmission.
	// *   **FC**: forwards topic data to Function Compute for event computing.
	// *   **OTS**: forwards topic data to Tablestore for NoSQL data storage.
	Types []*string `json:"Types,omitempty" xml:"Types,omitempty" type:"Repeated"`
}

func (s ListDestinationRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDestinationRequest) GoString() string {
	return s.String()
}

func (s *ListDestinationRequest) SetIotInstanceId(v string) *ListDestinationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListDestinationRequest) SetPage(v int32) *ListDestinationRequest {
	s.Page = &v
	return s
}

func (s *ListDestinationRequest) SetPageSize(v int32) *ListDestinationRequest {
	s.PageSize = &v
	return s
}

func (s *ListDestinationRequest) SetSearchName(v string) *ListDestinationRequest {
	s.SearchName = &v
	return s
}

func (s *ListDestinationRequest) SetTypes(v []*string) *ListDestinationRequest {
	s.Types = v
	return s
}

type ListDestinationResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data destinations.
	Destinations *ListDestinationResponseBodyDestinations `json:"Destinations,omitempty" xml:"Destinations,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The page number.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListDestinationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDestinationResponseBody) GoString() string {
	return s.String()
}

func (s *ListDestinationResponseBody) SetCode(v string) *ListDestinationResponseBody {
	s.Code = &v
	return s
}

func (s *ListDestinationResponseBody) SetDestinations(v *ListDestinationResponseBodyDestinations) *ListDestinationResponseBody {
	s.Destinations = v
	return s
}

func (s *ListDestinationResponseBody) SetErrorMessage(v string) *ListDestinationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDestinationResponseBody) SetPage(v int32) *ListDestinationResponseBody {
	s.Page = &v
	return s
}

func (s *ListDestinationResponseBody) SetPageSize(v int32) *ListDestinationResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListDestinationResponseBody) SetRequestId(v string) *ListDestinationResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDestinationResponseBody) SetSuccess(v bool) *ListDestinationResponseBody {
	s.Success = &v
	return s
}

func (s *ListDestinationResponseBody) SetTotal(v int32) *ListDestinationResponseBody {
	s.Total = &v
	return s
}

type ListDestinationResponseBodyDestinations struct {
	Destinations []*ListDestinationResponseBodyDestinationsDestinations `json:"destinations,omitempty" xml:"destinations,omitempty" type:"Repeated"`
}

func (s ListDestinationResponseBodyDestinations) String() string {
	return tea.Prettify(s)
}

func (s ListDestinationResponseBodyDestinations) GoString() string {
	return s.String()
}

func (s *ListDestinationResponseBodyDestinations) SetDestinations(v []*ListDestinationResponseBodyDestinationsDestinations) *ListDestinationResponseBodyDestinations {
	s.Destinations = v
	return s
}

type ListDestinationResponseBodyDestinationsDestinations struct {
	// The configuration data of the data destination.
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
	// The description of the data destination.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the data destination.
	DestinationId *int64 `json:"DestinationId,omitempty" xml:"DestinationId,omitempty"`
	// Indicates whether the data destination is configured to receive error operation data. Error operation data is the data that failed to be forwarded for two consecutive times.
	//
	// *   **true**: The data destination is configured to receive error operation data.
	// *   **false**: The data destination is configured to receive regular data instead of error operation data.
	//
	// Default value: **false**.
	IsFailover *bool `json:"IsFailover,omitempty" xml:"IsFailover,omitempty"`
	// The name of the data destination.
	Name   *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The action of forwarding data to the data destination.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
	// The time when the data destination was created. The time is displayed in UTC. The time follows the ISO 8601 standard in the `yyyy-MM-dd\"T\"HH:mm:ss.SSS\"Z\"` format.
	UtcCreated *string `json:"UtcCreated,omitempty" xml:"UtcCreated,omitempty"`
}

func (s ListDestinationResponseBodyDestinationsDestinations) String() string {
	return tea.Prettify(s)
}

func (s ListDestinationResponseBodyDestinationsDestinations) GoString() string {
	return s.String()
}

func (s *ListDestinationResponseBodyDestinationsDestinations) SetConfiguration(v string) *ListDestinationResponseBodyDestinationsDestinations {
	s.Configuration = &v
	return s
}

func (s *ListDestinationResponseBodyDestinationsDestinations) SetDescription(v string) *ListDestinationResponseBodyDestinationsDestinations {
	s.Description = &v
	return s
}

func (s *ListDestinationResponseBodyDestinationsDestinations) SetDestinationId(v int64) *ListDestinationResponseBodyDestinationsDestinations {
	s.DestinationId = &v
	return s
}

func (s *ListDestinationResponseBodyDestinationsDestinations) SetIsFailover(v bool) *ListDestinationResponseBodyDestinationsDestinations {
	s.IsFailover = &v
	return s
}

func (s *ListDestinationResponseBodyDestinationsDestinations) SetName(v string) *ListDestinationResponseBodyDestinationsDestinations {
	s.Name = &v
	return s
}

func (s *ListDestinationResponseBodyDestinationsDestinations) SetStatus(v string) *ListDestinationResponseBodyDestinationsDestinations {
	s.Status = &v
	return s
}

func (s *ListDestinationResponseBodyDestinationsDestinations) SetType(v string) *ListDestinationResponseBodyDestinationsDestinations {
	s.Type = &v
	return s
}

func (s *ListDestinationResponseBodyDestinationsDestinations) SetUtcCreated(v string) *ListDestinationResponseBodyDestinationsDestinations {
	s.UtcCreated = &v
	return s
}

type ListDestinationResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDestinationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDestinationResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDestinationResponse) GoString() string {
	return s.String()
}

func (s *ListDestinationResponse) SetHeaders(v map[string]*string) *ListDestinationResponse {
	s.Headers = v
	return s
}

func (s *ListDestinationResponse) SetStatusCode(v int32) *ListDestinationResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDestinationResponse) SetBody(v *ListDestinationResponseBody) *ListDestinationResponse {
	s.Body = v
	return s
}

type ListDeviceDistributeJobRequest struct {
	// The number of the page to return. Default value: 1.
	//
	// The **NextToken** or **CurrentPage** parameter specifies a condition for displaying the results. You can specify one of the two parameters. If you specify both parameters at the same time, the **NextToken parameter** is used.
	//
	// For information about the **NextToken** parameter, see the description of the **NextToken** parameter.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The ID of the distribution task. The ID is globally unique.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The token that is used to retrieve subsequent pages of the query results. The first time you perform a query operation, you do not need to specify this parameter.
	//
	// The **NextToken** or **CurrentPage** parameter specifies a condition for displaying the results. You can specify one of the two parameters. If you specify both parameters at the same time, the **NextToken** parameter is used.
	//
	//
	//
	// **Important**
	//
	// The offset in the number of results is obtained by using the following formula: **PageSize** × (**CurrentPage** - 1).
	//
	// If the offset is greater than 10,000, you must use the token that is returned in the previous query as the value of the **NextToken** parameter to obtain the value of the **Data** parameter. Otherwise, the current request is terminated and the value of the **Data** parameter cannot be returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 200.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The status of the device distribution task.
	//
	// *   **0**: The task is being initialized.
	// *   **1**: The task is running.
	// *   **2**: The task is completed. The status indicates that the distribution task is complete but does not indicate that all products and devices are distributed. To obtain distribution results, call the [QueryDeviceDistributeDetail](~~199533~~) operation.
	// *   **3**: The task is unexpectedly interrupted.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The ID of the Alibaba Cloud account to which the devices are distributed.
	TargetUid *string `json:"TargetUid,omitempty" xml:"TargetUid,omitempty"`
}

func (s ListDeviceDistributeJobRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDeviceDistributeJobRequest) GoString() string {
	return s.String()
}

func (s *ListDeviceDistributeJobRequest) SetCurrentPage(v int32) *ListDeviceDistributeJobRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListDeviceDistributeJobRequest) SetJobId(v string) *ListDeviceDistributeJobRequest {
	s.JobId = &v
	return s
}

func (s *ListDeviceDistributeJobRequest) SetNextToken(v string) *ListDeviceDistributeJobRequest {
	s.NextToken = &v
	return s
}

func (s *ListDeviceDistributeJobRequest) SetPageSize(v int32) *ListDeviceDistributeJobRequest {
	s.PageSize = &v
	return s
}

func (s *ListDeviceDistributeJobRequest) SetProductKey(v string) *ListDeviceDistributeJobRequest {
	s.ProductKey = &v
	return s
}

func (s *ListDeviceDistributeJobRequest) SetStatus(v int32) *ListDeviceDistributeJobRequest {
	s.Status = &v
	return s
}

func (s *ListDeviceDistributeJobRequest) SetTargetUid(v string) *ListDeviceDistributeJobRequest {
	s.TargetUid = &v
	return s
}

type ListDeviceDistributeJobResponseBody struct {
	// The error code that is returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The distribution tasks that are returned if the call is successful. For more information, see the **JobInfo** parameter.
	Data *ListDeviceDistributeJobResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message that is returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDeviceDistributeJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDeviceDistributeJobResponseBody) GoString() string {
	return s.String()
}

func (s *ListDeviceDistributeJobResponseBody) SetCode(v string) *ListDeviceDistributeJobResponseBody {
	s.Code = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBody) SetData(v *ListDeviceDistributeJobResponseBodyData) *ListDeviceDistributeJobResponseBody {
	s.Data = v
	return s
}

func (s *ListDeviceDistributeJobResponseBody) SetErrorMessage(v string) *ListDeviceDistributeJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBody) SetRequestId(v string) *ListDeviceDistributeJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBody) SetSuccess(v bool) *ListDeviceDistributeJobResponseBody {
	s.Success = &v
	return s
}

type ListDeviceDistributeJobResponseBodyData struct {
	// The information about the task.
	JobInfo *ListDeviceDistributeJobResponseBodyDataJobInfo `json:"JobInfo,omitempty" xml:"JobInfo,omitempty" type:"Struct"`
	// The token that is used to retrieve the subsequent pages of the query results. The value of this parameter can be used in the next query to obtain the subsequent pages of results.
	//
	// If the return value is empty, no subsequent page exists.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The total number of device distribution tasks.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListDeviceDistributeJobResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListDeviceDistributeJobResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListDeviceDistributeJobResponseBodyData) SetJobInfo(v *ListDeviceDistributeJobResponseBodyDataJobInfo) *ListDeviceDistributeJobResponseBodyData {
	s.JobInfo = v
	return s
}

func (s *ListDeviceDistributeJobResponseBodyData) SetNextToken(v string) *ListDeviceDistributeJobResponseBodyData {
	s.NextToken = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBodyData) SetTotal(v int32) *ListDeviceDistributeJobResponseBodyData {
	s.Total = &v
	return s
}

type ListDeviceDistributeJobResponseBodyDataJobInfo struct {
	Items []*ListDeviceDistributeJobResponseBodyDataJobInfoItems `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s ListDeviceDistributeJobResponseBodyDataJobInfo) String() string {
	return tea.Prettify(s)
}

func (s ListDeviceDistributeJobResponseBodyDataJobInfo) GoString() string {
	return s.String()
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfo) SetItems(v []*ListDeviceDistributeJobResponseBodyDataJobInfoItems) *ListDeviceDistributeJobResponseBodyDataJobInfo {
	s.Items = v
	return s
}

type ListDeviceDistributeJobResponseBodyDataJobInfoItems struct {
	// The time when the task was created.
	GmtCreate *int64 `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The ID of the task.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the source instance.
	SourceInstanceId *string `json:"SourceInstanceId,omitempty" xml:"SourceInstanceId,omitempty"`
	// The name of the source instance.
	SourceInstanceName *string `json:"SourceInstanceName,omitempty" xml:"SourceInstanceName,omitempty"`
	// The region where the source instance resides.
	SourceRegion *string `json:"SourceRegion,omitempty" xml:"SourceRegion,omitempty"`
	// The ID of the source Alibaba Cloud account.
	SourceUid *string `json:"SourceUid,omitempty" xml:"SourceUid,omitempty"`
	// The status of the task.
	//
	// *   **0**: The task is being initialized.
	// *   **1**: The task is running.
	// *   **2**: The task is completed. The status indicates that the distribution task is complete but does not indicate that all products and devices are distributed. To obtain distribution results, call the [QueryDeviceDistributeDetail](~~199533~~) operation.
	// *   **3**: The task is unexpectedly interrupted.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The distribution policy.
	//
	// *   **0**: distributes devices to specified instances in a specified region. This is the default value.
	// *   **1**: configures instance IDs in multiple regions and distributes devices to the nearest regions based on the IP addresses of the devices.
	Strategy *int32 `json:"Strategy,omitempty" xml:"Strategy,omitempty"`
	// The IDs of the destination instances.
	//
	// *   If the value of the **Strategy** parameter is **1**, multiple instance IDs exist.
	// *   If the value of the **Strategy** parameter is **0**, only one instance ID exists.
	TargetInstanceConfigs *ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs `json:"TargetInstanceConfigs,omitempty" xml:"TargetInstanceConfigs,omitempty" type:"Struct"`
	// The ID of the destination Alibaba Cloud account.
	TargetUid *string `json:"TargetUid,omitempty" xml:"TargetUid,omitempty"`
	// The total number of devices in the distribution task.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListDeviceDistributeJobResponseBodyDataJobInfoItems) String() string {
	return tea.Prettify(s)
}

func (s ListDeviceDistributeJobResponseBodyDataJobInfoItems) GoString() string {
	return s.String()
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItems) SetGmtCreate(v int64) *ListDeviceDistributeJobResponseBodyDataJobInfoItems {
	s.GmtCreate = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItems) SetJobId(v string) *ListDeviceDistributeJobResponseBodyDataJobInfoItems {
	s.JobId = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItems) SetProductKey(v string) *ListDeviceDistributeJobResponseBodyDataJobInfoItems {
	s.ProductKey = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItems) SetSourceInstanceId(v string) *ListDeviceDistributeJobResponseBodyDataJobInfoItems {
	s.SourceInstanceId = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItems) SetSourceInstanceName(v string) *ListDeviceDistributeJobResponseBodyDataJobInfoItems {
	s.SourceInstanceName = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItems) SetSourceRegion(v string) *ListDeviceDistributeJobResponseBodyDataJobInfoItems {
	s.SourceRegion = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItems) SetSourceUid(v string) *ListDeviceDistributeJobResponseBodyDataJobInfoItems {
	s.SourceUid = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItems) SetStatus(v int32) *ListDeviceDistributeJobResponseBodyDataJobInfoItems {
	s.Status = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItems) SetStrategy(v int32) *ListDeviceDistributeJobResponseBodyDataJobInfoItems {
	s.Strategy = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItems) SetTargetInstanceConfigs(v *ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs) *ListDeviceDistributeJobResponseBodyDataJobInfoItems {
	s.TargetInstanceConfigs = v
	return s
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItems) SetTargetUid(v string) *ListDeviceDistributeJobResponseBodyDataJobInfoItems {
	s.TargetUid = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItems) SetTotal(v int32) *ListDeviceDistributeJobResponseBodyDataJobInfoItems {
	s.Total = &v
	return s
}

type ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs struct {
	TargetInstanceConfigs []*ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs `json:"targetInstanceConfigs,omitempty" xml:"targetInstanceConfigs,omitempty" type:"Repeated"`
}

func (s ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs) String() string {
	return tea.Prettify(s)
}

func (s ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs) GoString() string {
	return s.String()
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs) SetTargetInstanceConfigs(v []*ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs) *ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigs {
	s.TargetInstanceConfigs = v
	return s
}

type ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs struct {
	// The ID of the destination instance.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
	// The name of the destination instance.
	TargetInstanceName *string `json:"TargetInstanceName,omitempty" xml:"TargetInstanceName,omitempty"`
	// The region where the destination instance resides.
	TargetRegion *string `json:"TargetRegion,omitempty" xml:"TargetRegion,omitempty"`
}

func (s ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs) String() string {
	return tea.Prettify(s)
}

func (s ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs) GoString() string {
	return s.String()
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs) SetTargetInstanceId(v string) *ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs {
	s.TargetInstanceId = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs) SetTargetInstanceName(v string) *ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs {
	s.TargetInstanceName = &v
	return s
}

func (s *ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs) SetTargetRegion(v string) *ListDeviceDistributeJobResponseBodyDataJobInfoItemsTargetInstanceConfigsTargetInstanceConfigs {
	s.TargetRegion = &v
	return s
}

type ListDeviceDistributeJobResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDeviceDistributeJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDeviceDistributeJobResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDeviceDistributeJobResponse) GoString() string {
	return s.String()
}

func (s *ListDeviceDistributeJobResponse) SetHeaders(v map[string]*string) *ListDeviceDistributeJobResponse {
	s.Headers = v
	return s
}

func (s *ListDeviceDistributeJobResponse) SetStatusCode(v int32) *ListDeviceDistributeJobResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDeviceDistributeJobResponse) SetBody(v *ListDeviceDistributeJobResponseBody) *ListDeviceDistributeJobResponse {
	s.Body = v
	return s
}

type ListDistributedDeviceRequest struct {
	// The number of the page to return. Default value: 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The number of entries to return on each page. Maximum value: 200.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the source instance to which the device belongs.
	//
	// *   The IDs of public instances in different regions:
	//
	//     *   China (Shanghai): iotx-oxssharez200.
	//     *   Japan (Tokyo): iotx-oxssharez300.
	//     *   Singapore (Singapore): iotx-oxssharez400.
	//     *   US (Silicon Valley): iotx-oxssharez500.
	//     *   US (Virginia): iotx-oxssharez600.
	//     *   Germany (Frankfurt): iotx-oxssharez700.
	//
	// *   The IDs of Enterprise Edition instances:
	//
	//     1\. Log on to the IoT Platform console. Select a region from the drop-down list in the upper-left corner of the top navigation bar.
	//
	//     2\. On the **Overview** page, click the instance name. On the **Instance Details** page, view the instance ID in the **Basic Information** section.
	SourceInstanceId *string `json:"SourceInstanceId,omitempty" xml:"SourceInstanceId,omitempty"`
	// The ID of the Alibaba Cloud account. You can log on to the IoT Platform console, click the profile picture, and then view **Account ID** on the **Security Settings** page.
	TargetUid *string `json:"TargetUid,omitempty" xml:"TargetUid,omitempty"`
}

func (s ListDistributedDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDistributedDeviceRequest) GoString() string {
	return s.String()
}

func (s *ListDistributedDeviceRequest) SetCurrentPage(v int32) *ListDistributedDeviceRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListDistributedDeviceRequest) SetDeviceName(v string) *ListDistributedDeviceRequest {
	s.DeviceName = &v
	return s
}

func (s *ListDistributedDeviceRequest) SetPageSize(v int32) *ListDistributedDeviceRequest {
	s.PageSize = &v
	return s
}

func (s *ListDistributedDeviceRequest) SetProductKey(v string) *ListDistributedDeviceRequest {
	s.ProductKey = &v
	return s
}

func (s *ListDistributedDeviceRequest) SetSourceInstanceId(v string) *ListDistributedDeviceRequest {
	s.SourceInstanceId = &v
	return s
}

func (s *ListDistributedDeviceRequest) SetTargetUid(v string) *ListDistributedDeviceRequest {
	s.TargetUid = &v
	return s
}

type ListDistributedDeviceResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The products returned if the call is successful. For more information, see **Info**.
	Data *ListDistributedDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDistributedDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDistributedDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *ListDistributedDeviceResponseBody) SetCode(v string) *ListDistributedDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *ListDistributedDeviceResponseBody) SetData(v *ListDistributedDeviceResponseBodyData) *ListDistributedDeviceResponseBody {
	s.Data = v
	return s
}

func (s *ListDistributedDeviceResponseBody) SetErrorMessage(v string) *ListDistributedDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDistributedDeviceResponseBody) SetRequestId(v string) *ListDistributedDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDistributedDeviceResponseBody) SetSuccess(v bool) *ListDistributedDeviceResponseBody {
	s.Success = &v
	return s
}

type ListDistributedDeviceResponseBodyData struct {
	// The information about the device.
	Info *ListDistributedDeviceResponseBodyDataInfo `json:"Info,omitempty" xml:"Info,omitempty" type:"Struct"`
	// The total number of returned devices.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListDistributedDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListDistributedDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListDistributedDeviceResponseBodyData) SetInfo(v *ListDistributedDeviceResponseBodyDataInfo) *ListDistributedDeviceResponseBodyData {
	s.Info = v
	return s
}

func (s *ListDistributedDeviceResponseBodyData) SetTotal(v int32) *ListDistributedDeviceResponseBodyData {
	s.Total = &v
	return s
}

type ListDistributedDeviceResponseBodyDataInfo struct {
	Items []*ListDistributedDeviceResponseBodyDataInfoItems `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s ListDistributedDeviceResponseBodyDataInfo) String() string {
	return tea.Prettify(s)
}

func (s ListDistributedDeviceResponseBodyDataInfo) GoString() string {
	return s.String()
}

func (s *ListDistributedDeviceResponseBodyDataInfo) SetItems(v []*ListDistributedDeviceResponseBodyDataInfoItems) *ListDistributedDeviceResponseBodyDataInfo {
	s.Items = v
	return s
}

type ListDistributedDeviceResponseBodyDataInfoItems struct {
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The time when the distribution task was created.
	GmtCreate *int64 `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the distribution task was modified.
	GmtModified *int64 `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the source instance.
	SourceInstanceId *string `json:"SourceInstanceId,omitempty" xml:"SourceInstanceId,omitempty"`
	// The name of the source instance.
	SourceInstanceName *string `json:"SourceInstanceName,omitempty" xml:"SourceInstanceName,omitempty"`
	// The source region in which the device resides.
	SourceRegion *string `json:"SourceRegion,omitempty" xml:"SourceRegion,omitempty"`
	// The ID of the Alibaba Cloud account that distributes the device.
	//
	// You can only distribute devices across regions and instances by using the same Alibaba cloud account. The value of this parameter is the same as the value of the **TargetUid** parameter.
	SourceUid *string `json:"SourceUid,omitempty" xml:"SourceUid,omitempty"`
	// The Alibaba Cloud account to which the device is distributed.
	TargetAliyunId *string `json:"TargetAliyunId,omitempty" xml:"TargetAliyunId,omitempty"`
	// The ID of the destination instance.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
	// The name of the destination instance.
	TargetInstanceName *string `json:"TargetInstanceName,omitempty" xml:"TargetInstanceName,omitempty"`
	// The destination region to which the device is distributed.
	TargetRegion *string `json:"TargetRegion,omitempty" xml:"TargetRegion,omitempty"`
	// The Alibaba Cloud account to which the device is distributed.
	//
	// You can only distribute devices across regions and instances by using the same Alibaba cloud account. The value of this parameter is the same as the value of the **TargetUid** parameter.
	TargetUid *string `json:"TargetUid,omitempty" xml:"TargetUid,omitempty"`
}

func (s ListDistributedDeviceResponseBodyDataInfoItems) String() string {
	return tea.Prettify(s)
}

func (s ListDistributedDeviceResponseBodyDataInfoItems) GoString() string {
	return s.String()
}

func (s *ListDistributedDeviceResponseBodyDataInfoItems) SetDeviceName(v string) *ListDistributedDeviceResponseBodyDataInfoItems {
	s.DeviceName = &v
	return s
}

func (s *ListDistributedDeviceResponseBodyDataInfoItems) SetGmtCreate(v int64) *ListDistributedDeviceResponseBodyDataInfoItems {
	s.GmtCreate = &v
	return s
}

func (s *ListDistributedDeviceResponseBodyDataInfoItems) SetGmtModified(v int64) *ListDistributedDeviceResponseBodyDataInfoItems {
	s.GmtModified = &v
	return s
}

func (s *ListDistributedDeviceResponseBodyDataInfoItems) SetProductKey(v string) *ListDistributedDeviceResponseBodyDataInfoItems {
	s.ProductKey = &v
	return s
}

func (s *ListDistributedDeviceResponseBodyDataInfoItems) SetSourceInstanceId(v string) *ListDistributedDeviceResponseBodyDataInfoItems {
	s.SourceInstanceId = &v
	return s
}

func (s *ListDistributedDeviceResponseBodyDataInfoItems) SetSourceInstanceName(v string) *ListDistributedDeviceResponseBodyDataInfoItems {
	s.SourceInstanceName = &v
	return s
}

func (s *ListDistributedDeviceResponseBodyDataInfoItems) SetSourceRegion(v string) *ListDistributedDeviceResponseBodyDataInfoItems {
	s.SourceRegion = &v
	return s
}

func (s *ListDistributedDeviceResponseBodyDataInfoItems) SetSourceUid(v string) *ListDistributedDeviceResponseBodyDataInfoItems {
	s.SourceUid = &v
	return s
}

func (s *ListDistributedDeviceResponseBodyDataInfoItems) SetTargetAliyunId(v string) *ListDistributedDeviceResponseBodyDataInfoItems {
	s.TargetAliyunId = &v
	return s
}

func (s *ListDistributedDeviceResponseBodyDataInfoItems) SetTargetInstanceId(v string) *ListDistributedDeviceResponseBodyDataInfoItems {
	s.TargetInstanceId = &v
	return s
}

func (s *ListDistributedDeviceResponseBodyDataInfoItems) SetTargetInstanceName(v string) *ListDistributedDeviceResponseBodyDataInfoItems {
	s.TargetInstanceName = &v
	return s
}

func (s *ListDistributedDeviceResponseBodyDataInfoItems) SetTargetRegion(v string) *ListDistributedDeviceResponseBodyDataInfoItems {
	s.TargetRegion = &v
	return s
}

func (s *ListDistributedDeviceResponseBodyDataInfoItems) SetTargetUid(v string) *ListDistributedDeviceResponseBodyDataInfoItems {
	s.TargetUid = &v
	return s
}

type ListDistributedDeviceResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDistributedDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDistributedDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDistributedDeviceResponse) GoString() string {
	return s.String()
}

func (s *ListDistributedDeviceResponse) SetHeaders(v map[string]*string) *ListDistributedDeviceResponse {
	s.Headers = v
	return s
}

func (s *ListDistributedDeviceResponse) SetStatusCode(v int32) *ListDistributedDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDistributedDeviceResponse) SetBody(v *ListDistributedDeviceResponseBody) *ListDistributedDeviceResponse {
	s.Body = v
	return s
}

type ListDistributedProductRequest struct {
	// The number of the page to return. Default value: 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The number of entries to return on each page. Maximum value: 200.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The **ProductKey** of the product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the source instance to which the product belongs.
	//
	// *   The IDs of public instances in different regions:
	//
	//     *   China (Shanghai): iotx-oxssharez200.
	//     *   Japan (Tokyo): iotx-oxssharez300.
	//     *   Singapore (Singapore): iotx-oxssharez400.
	//     *   US (Silicon Valley): iotx-oxssharez500.
	//     *   US (Virginia): iotx-oxssharez600.
	//     *   Germany (Frankfurt): iotx-oxssharez700.
	//
	// *   To view the ID of an Enterprise Edition instance, perform the following steps:
	//
	//     1\. Log on to the [IoT Platform console](https://iot.console.aliyun.com/). In the top navigation bar, select the region where the instance resides from the drop-down list.
	//
	//     2\. On the **Overview** page, view the **ID** of the instance.
	SourceInstanceId *string `json:"SourceInstanceId,omitempty" xml:"SourceInstanceId,omitempty"`
	// The ID of the destination instance to which the product is distributed. For more information about instance IDs, see the description of the **SourceInstanceId** parameter.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
	// The ID of the Alibaba Cloud account to which the product belongs. You can log on to the IoT Platform console, click the profile picture, and then view the **account ID** on the **Security Settings** page.
	TargetUid *string `json:"TargetUid,omitempty" xml:"TargetUid,omitempty"`
}

func (s ListDistributedProductRequest) String() string {
	return tea.Prettify(s)
}

func (s ListDistributedProductRequest) GoString() string {
	return s.String()
}

func (s *ListDistributedProductRequest) SetCurrentPage(v int32) *ListDistributedProductRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListDistributedProductRequest) SetPageSize(v int32) *ListDistributedProductRequest {
	s.PageSize = &v
	return s
}

func (s *ListDistributedProductRequest) SetProductKey(v string) *ListDistributedProductRequest {
	s.ProductKey = &v
	return s
}

func (s *ListDistributedProductRequest) SetSourceInstanceId(v string) *ListDistributedProductRequest {
	s.SourceInstanceId = &v
	return s
}

func (s *ListDistributedProductRequest) SetTargetInstanceId(v string) *ListDistributedProductRequest {
	s.TargetInstanceId = &v
	return s
}

func (s *ListDistributedProductRequest) SetTargetUid(v string) *ListDistributedProductRequest {
	s.TargetUid = &v
	return s
}

type ListDistributedProductResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The products returned if the call is successful. For more information, see the "**Info**" section of this topic.
	Data *ListDistributedProductResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListDistributedProductResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListDistributedProductResponseBody) GoString() string {
	return s.String()
}

func (s *ListDistributedProductResponseBody) SetCode(v string) *ListDistributedProductResponseBody {
	s.Code = &v
	return s
}

func (s *ListDistributedProductResponseBody) SetData(v *ListDistributedProductResponseBodyData) *ListDistributedProductResponseBody {
	s.Data = v
	return s
}

func (s *ListDistributedProductResponseBody) SetErrorMessage(v string) *ListDistributedProductResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListDistributedProductResponseBody) SetRequestId(v string) *ListDistributedProductResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListDistributedProductResponseBody) SetSuccess(v bool) *ListDistributedProductResponseBody {
	s.Success = &v
	return s
}

type ListDistributedProductResponseBodyData struct {
	// The information about the product.
	Info *ListDistributedProductResponseBodyDataInfo `json:"Info,omitempty" xml:"Info,omitempty" type:"Struct"`
	// The total number of returned products.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListDistributedProductResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListDistributedProductResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListDistributedProductResponseBodyData) SetInfo(v *ListDistributedProductResponseBodyDataInfo) *ListDistributedProductResponseBodyData {
	s.Info = v
	return s
}

func (s *ListDistributedProductResponseBodyData) SetTotal(v int32) *ListDistributedProductResponseBodyData {
	s.Total = &v
	return s
}

type ListDistributedProductResponseBodyDataInfo struct {
	Items []*ListDistributedProductResponseBodyDataInfoItems `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s ListDistributedProductResponseBodyDataInfo) String() string {
	return tea.Prettify(s)
}

func (s ListDistributedProductResponseBodyDataInfo) GoString() string {
	return s.String()
}

func (s *ListDistributedProductResponseBodyDataInfo) SetItems(v []*ListDistributedProductResponseBodyDataInfoItems) *ListDistributedProductResponseBodyDataInfo {
	s.Items = v
	return s
}

type ListDistributedProductResponseBodyDataInfoItems struct {
	// The time when the distribution task was created.
	GmtCreate *int64 `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The **ProductKey** of the product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the source instance to which the product belongs.
	SourceInstanceId *string `json:"SourceInstanceId,omitempty" xml:"SourceInstanceId,omitempty"`
	// The name of the source instance to which the product belongs.
	SourceInstanceName *string `json:"SourceInstanceName,omitempty" xml:"SourceInstanceName,omitempty"`
	// The source region to which the product belongs.
	SourceRegion *string `json:"SourceRegion,omitempty" xml:"SourceRegion,omitempty"`
	// The ID of the Alibaba Cloud account that is used to distribute the product. You can distribute products across regions and instances only within the same Alibaba cloud account. The value of this parameter is the same as the value of the **TargetUid** parameter.
	SourceUid *string `json:"SourceUid,omitempty" xml:"SourceUid,omitempty"`
	// The name of the Alibaba Cloud account to which the product is distributed.
	TargetAliyunId *string `json:"TargetAliyunId,omitempty" xml:"TargetAliyunId,omitempty"`
	// The ID of the destination instance to which the product is distributed.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
	// The name of the destination instance to which the product is distributed.
	TargetInstanceName *string `json:"TargetInstanceName,omitempty" xml:"TargetInstanceName,omitempty"`
	// The destination region to which the product is distributed.
	TargetRegion *string `json:"TargetRegion,omitempty" xml:"TargetRegion,omitempty"`
	// The ID of the Alibaba Cloud account to which the product is distributed.
	//
	// You can distribute devices across regions and instances only within the same Alibaba cloud account. The value of this parameter is the same as the value of the **TargetUid** parameter.
	TargetUid *string `json:"TargetUid,omitempty" xml:"TargetUid,omitempty"`
}

func (s ListDistributedProductResponseBodyDataInfoItems) String() string {
	return tea.Prettify(s)
}

func (s ListDistributedProductResponseBodyDataInfoItems) GoString() string {
	return s.String()
}

func (s *ListDistributedProductResponseBodyDataInfoItems) SetGmtCreate(v int64) *ListDistributedProductResponseBodyDataInfoItems {
	s.GmtCreate = &v
	return s
}

func (s *ListDistributedProductResponseBodyDataInfoItems) SetProductKey(v string) *ListDistributedProductResponseBodyDataInfoItems {
	s.ProductKey = &v
	return s
}

func (s *ListDistributedProductResponseBodyDataInfoItems) SetSourceInstanceId(v string) *ListDistributedProductResponseBodyDataInfoItems {
	s.SourceInstanceId = &v
	return s
}

func (s *ListDistributedProductResponseBodyDataInfoItems) SetSourceInstanceName(v string) *ListDistributedProductResponseBodyDataInfoItems {
	s.SourceInstanceName = &v
	return s
}

func (s *ListDistributedProductResponseBodyDataInfoItems) SetSourceRegion(v string) *ListDistributedProductResponseBodyDataInfoItems {
	s.SourceRegion = &v
	return s
}

func (s *ListDistributedProductResponseBodyDataInfoItems) SetSourceUid(v string) *ListDistributedProductResponseBodyDataInfoItems {
	s.SourceUid = &v
	return s
}

func (s *ListDistributedProductResponseBodyDataInfoItems) SetTargetAliyunId(v string) *ListDistributedProductResponseBodyDataInfoItems {
	s.TargetAliyunId = &v
	return s
}

func (s *ListDistributedProductResponseBodyDataInfoItems) SetTargetInstanceId(v string) *ListDistributedProductResponseBodyDataInfoItems {
	s.TargetInstanceId = &v
	return s
}

func (s *ListDistributedProductResponseBodyDataInfoItems) SetTargetInstanceName(v string) *ListDistributedProductResponseBodyDataInfoItems {
	s.TargetInstanceName = &v
	return s
}

func (s *ListDistributedProductResponseBodyDataInfoItems) SetTargetRegion(v string) *ListDistributedProductResponseBodyDataInfoItems {
	s.TargetRegion = &v
	return s
}

func (s *ListDistributedProductResponseBodyDataInfoItems) SetTargetUid(v string) *ListDistributedProductResponseBodyDataInfoItems {
	s.TargetUid = &v
	return s
}

type ListDistributedProductResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListDistributedProductResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListDistributedProductResponse) String() string {
	return tea.Prettify(s)
}

func (s ListDistributedProductResponse) GoString() string {
	return s.String()
}

func (s *ListDistributedProductResponse) SetHeaders(v map[string]*string) *ListDistributedProductResponse {
	s.Headers = v
	return s
}

func (s *ListDistributedProductResponse) SetStatusCode(v int32) *ListDistributedProductResponse {
	s.StatusCode = &v
	return s
}

func (s *ListDistributedProductResponse) SetBody(v *ListDistributedProductResponseBody) *ListDistributedProductResponse {
	s.Body = v
	return s
}

type ListJobRequest struct {
	CurrentPage   *int32  `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Status        *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListJobRequest) String() string {
	return tea.Prettify(s)
}

func (s ListJobRequest) GoString() string {
	return s.String()
}

func (s *ListJobRequest) SetCurrentPage(v int32) *ListJobRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListJobRequest) SetIotInstanceId(v string) *ListJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListJobRequest) SetPageSize(v int32) *ListJobRequest {
	s.PageSize = &v
	return s
}

func (s *ListJobRequest) SetStatus(v string) *ListJobRequest {
	s.Status = &v
	return s
}

type ListJobResponseBody struct {
	Code         *string                  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *ListJobResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                  `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	Page         *int32                   `json:"Page,omitempty" xml:"Page,omitempty"`
	PageSize     *int32                   `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId    *string                  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                    `json:"Success,omitempty" xml:"Success,omitempty"`
	Total        *int32                   `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListJobResponseBody) GoString() string {
	return s.String()
}

func (s *ListJobResponseBody) SetCode(v string) *ListJobResponseBody {
	s.Code = &v
	return s
}

func (s *ListJobResponseBody) SetData(v *ListJobResponseBodyData) *ListJobResponseBody {
	s.Data = v
	return s
}

func (s *ListJobResponseBody) SetErrorMessage(v string) *ListJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListJobResponseBody) SetPage(v int32) *ListJobResponseBody {
	s.Page = &v
	return s
}

func (s *ListJobResponseBody) SetPageSize(v int32) *ListJobResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListJobResponseBody) SetRequestId(v string) *ListJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListJobResponseBody) SetSuccess(v bool) *ListJobResponseBody {
	s.Success = &v
	return s
}

func (s *ListJobResponseBody) SetTotal(v int32) *ListJobResponseBody {
	s.Total = &v
	return s
}

type ListJobResponseBodyData struct {
	Data []*ListJobResponseBodyDataData `json:"data,omitempty" xml:"data,omitempty" type:"Repeated"`
}

func (s ListJobResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListJobResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListJobResponseBodyData) SetData(v []*ListJobResponseBodyDataData) *ListJobResponseBodyData {
	s.Data = v
	return s
}

type ListJobResponseBodyDataData struct {
	Description   *string `json:"Description,omitempty" xml:"Description,omitempty"`
	JobId         *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	JobName       *string `json:"JobName,omitempty" xml:"JobName,omitempty"`
	ScheduledTime *int64  `json:"ScheduledTime,omitempty" xml:"ScheduledTime,omitempty"`
	Status        *string `json:"Status,omitempty" xml:"Status,omitempty"`
	Type          *string `json:"Type,omitempty" xml:"Type,omitempty"`
	UtcCreate     *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
	UtcModified   *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
}

func (s ListJobResponseBodyDataData) String() string {
	return tea.Prettify(s)
}

func (s ListJobResponseBodyDataData) GoString() string {
	return s.String()
}

func (s *ListJobResponseBodyDataData) SetDescription(v string) *ListJobResponseBodyDataData {
	s.Description = &v
	return s
}

func (s *ListJobResponseBodyDataData) SetJobId(v string) *ListJobResponseBodyDataData {
	s.JobId = &v
	return s
}

func (s *ListJobResponseBodyDataData) SetJobName(v string) *ListJobResponseBodyDataData {
	s.JobName = &v
	return s
}

func (s *ListJobResponseBodyDataData) SetScheduledTime(v int64) *ListJobResponseBodyDataData {
	s.ScheduledTime = &v
	return s
}

func (s *ListJobResponseBodyDataData) SetStatus(v string) *ListJobResponseBodyDataData {
	s.Status = &v
	return s
}

func (s *ListJobResponseBodyDataData) SetType(v string) *ListJobResponseBodyDataData {
	s.Type = &v
	return s
}

func (s *ListJobResponseBodyDataData) SetUtcCreate(v string) *ListJobResponseBodyDataData {
	s.UtcCreate = &v
	return s
}

func (s *ListJobResponseBodyDataData) SetUtcModified(v string) *ListJobResponseBodyDataData {
	s.UtcModified = &v
	return s
}

type ListJobResponse struct {
	Headers    map[string]*string   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListJobResponse) String() string {
	return tea.Prettify(s)
}

func (s ListJobResponse) GoString() string {
	return s.String()
}

func (s *ListJobResponse) SetHeaders(v map[string]*string) *ListJobResponse {
	s.Headers = v
	return s
}

func (s *ListJobResponse) SetStatusCode(v int32) *ListJobResponse {
	s.StatusCode = &v
	return s
}

func (s *ListJobResponse) SetBody(v *ListJobResponseBody) *ListJobResponse {
	s.Body = v
	return s
}

type ListOTAFirmwareRequest struct {
	// The number of the page to return. Pages start from page 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The version number of the OTA update package. If you specify this parameter, only the OTA update package of the specified version number is returned.
	DestVersion *string `json:"DestVersion,omitempty" xml:"DestVersion,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The **ProductKey** of the product to which the OTA update package belongs.
	//
	// If you specify this parameter, IoT Platform returns the OTA update packages of the specified product. If you do not specify this parameter, IoT Platform returns the OTA update packages of the current Alibaba Cloud account.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s ListOTAFirmwareRequest) String() string {
	return tea.Prettify(s)
}

func (s ListOTAFirmwareRequest) GoString() string {
	return s.String()
}

func (s *ListOTAFirmwareRequest) SetCurrentPage(v int32) *ListOTAFirmwareRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListOTAFirmwareRequest) SetDestVersion(v string) *ListOTAFirmwareRequest {
	s.DestVersion = &v
	return s
}

func (s *ListOTAFirmwareRequest) SetIotInstanceId(v string) *ListOTAFirmwareRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListOTAFirmwareRequest) SetPageSize(v int32) *ListOTAFirmwareRequest {
	s.PageSize = &v
	return s
}

func (s *ListOTAFirmwareRequest) SetProductKey(v string) *ListOTAFirmwareRequest {
	s.ProductKey = &v
	return s
}

type ListOTAFirmwareResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The OTA update packages returned if the call is successful. For more information, see SimpleFirmwareInfo.
	FirmwareInfo *ListOTAFirmwareResponseBodyFirmwareInfo `json:"FirmwareInfo,omitempty" xml:"FirmwareInfo,omitempty" type:"Struct"`
	// The total number of pages.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of OTA update packages.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListOTAFirmwareResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListOTAFirmwareResponseBody) GoString() string {
	return s.String()
}

func (s *ListOTAFirmwareResponseBody) SetCode(v string) *ListOTAFirmwareResponseBody {
	s.Code = &v
	return s
}

func (s *ListOTAFirmwareResponseBody) SetCurrentPage(v int32) *ListOTAFirmwareResponseBody {
	s.CurrentPage = &v
	return s
}

func (s *ListOTAFirmwareResponseBody) SetErrorMessage(v string) *ListOTAFirmwareResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListOTAFirmwareResponseBody) SetFirmwareInfo(v *ListOTAFirmwareResponseBodyFirmwareInfo) *ListOTAFirmwareResponseBody {
	s.FirmwareInfo = v
	return s
}

func (s *ListOTAFirmwareResponseBody) SetPageCount(v int32) *ListOTAFirmwareResponseBody {
	s.PageCount = &v
	return s
}

func (s *ListOTAFirmwareResponseBody) SetPageSize(v int32) *ListOTAFirmwareResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListOTAFirmwareResponseBody) SetRequestId(v string) *ListOTAFirmwareResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListOTAFirmwareResponseBody) SetSuccess(v bool) *ListOTAFirmwareResponseBody {
	s.Success = &v
	return s
}

func (s *ListOTAFirmwareResponseBody) SetTotal(v int32) *ListOTAFirmwareResponseBody {
	s.Total = &v
	return s
}

type ListOTAFirmwareResponseBodyFirmwareInfo struct {
	SimpleFirmwareInfo []*ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo `json:"SimpleFirmwareInfo,omitempty" xml:"SimpleFirmwareInfo,omitempty" type:"Repeated"`
}

func (s ListOTAFirmwareResponseBodyFirmwareInfo) String() string {
	return tea.Prettify(s)
}

func (s ListOTAFirmwareResponseBodyFirmwareInfo) GoString() string {
	return s.String()
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfo) SetSimpleFirmwareInfo(v []*ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) *ListOTAFirmwareResponseBodyFirmwareInfo {
	s.SimpleFirmwareInfo = v
	return s
}

type ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo struct {
	// The version number of the OTA update package.
	DestVersion *string `json:"DestVersion,omitempty" xml:"DestVersion,omitempty"`
	// The description of the OTA update package.
	FirmwareDesc *string `json:"FirmwareDesc,omitempty" xml:"FirmwareDesc,omitempty"`
	// The unique ID of the OTA update package.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The name of the OTA update package.
	FirmwareName *string `json:"FirmwareName,omitempty" xml:"FirmwareName,omitempty"`
	// The signature of the OTA update package.
	FirmwareSign *string `json:"FirmwareSign,omitempty" xml:"FirmwareSign,omitempty"`
	// The size of the update package. Unit: bytes.
	FirmwareSize *int32 `json:"FirmwareSize,omitempty" xml:"FirmwareSize,omitempty"`
	// The name of the module.
	ModuleName *string `json:"ModuleName,omitempty" xml:"ModuleName,omitempty"`
	// The ProductKey of the product to which the OTA update package belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The name of the product to which the OTA update package belongs.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
	// The signature method of the OTA update package.
	SignMethod *string `json:"SignMethod,omitempty" xml:"SignMethod,omitempty"`
	// The version number of the original update package to be updated.
	//
	// >  The return value is null if you perform a full update.
	SrcVersion *string `json:"SrcVersion,omitempty" xml:"SrcVersion,omitempty"`
	// The status of the OTA update package. Valid values:
	//
	// *   **0**: unverified
	// *   **1**: verified
	// *   **2**: verifying
	// *   **3**: failed to be verified
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the OTA update package. Valid values:
	//
	// *   **0**: complete firmware
	// *   **1**: differential firmware
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
	// The time when the update package was created. The time is displayed in UTC.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
	// The time when the update task was last modified. The time is displayed in UTC.
	UtcModified *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
}

func (s ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) String() string {
	return tea.Prettify(s)
}

func (s ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) GoString() string {
	return s.String()
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) SetDestVersion(v string) *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo {
	s.DestVersion = &v
	return s
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) SetFirmwareDesc(v string) *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo {
	s.FirmwareDesc = &v
	return s
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) SetFirmwareId(v string) *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo {
	s.FirmwareId = &v
	return s
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) SetFirmwareName(v string) *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo {
	s.FirmwareName = &v
	return s
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) SetFirmwareSign(v string) *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo {
	s.FirmwareSign = &v
	return s
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) SetFirmwareSize(v int32) *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo {
	s.FirmwareSize = &v
	return s
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) SetModuleName(v string) *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo {
	s.ModuleName = &v
	return s
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) SetProductKey(v string) *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo {
	s.ProductKey = &v
	return s
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) SetProductName(v string) *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo {
	s.ProductName = &v
	return s
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) SetSignMethod(v string) *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo {
	s.SignMethod = &v
	return s
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) SetSrcVersion(v string) *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo {
	s.SrcVersion = &v
	return s
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) SetStatus(v int32) *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo {
	s.Status = &v
	return s
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) SetType(v int32) *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo {
	s.Type = &v
	return s
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) SetUtcCreate(v string) *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo {
	s.UtcCreate = &v
	return s
}

func (s *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo) SetUtcModified(v string) *ListOTAFirmwareResponseBodyFirmwareInfoSimpleFirmwareInfo {
	s.UtcModified = &v
	return s
}

type ListOTAFirmwareResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListOTAFirmwareResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListOTAFirmwareResponse) String() string {
	return tea.Prettify(s)
}

func (s ListOTAFirmwareResponse) GoString() string {
	return s.String()
}

func (s *ListOTAFirmwareResponse) SetHeaders(v map[string]*string) *ListOTAFirmwareResponse {
	s.Headers = v
	return s
}

func (s *ListOTAFirmwareResponse) SetStatusCode(v int32) *ListOTAFirmwareResponse {
	s.StatusCode = &v
	return s
}

func (s *ListOTAFirmwareResponse) SetBody(v *ListOTAFirmwareResponseBody) *ListOTAFirmwareResponse {
	s.Body = v
	return s
}

type ListOTAJobByDeviceRequest struct {
	// The number of the page to return. Pages start from page 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the update package. The ID is the unique identifier for the update package.
	//
	// An update package ID is returned when you call the [CreateOTAFirmware](~~147311~~) operation to create the update package. You can call the [ListOTAFirmware](~~147450~~) operation and view the update package ID in the response.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Maximum value: 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s ListOTAJobByDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s ListOTAJobByDeviceRequest) GoString() string {
	return s.String()
}

func (s *ListOTAJobByDeviceRequest) SetCurrentPage(v int32) *ListOTAJobByDeviceRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListOTAJobByDeviceRequest) SetDeviceName(v string) *ListOTAJobByDeviceRequest {
	s.DeviceName = &v
	return s
}

func (s *ListOTAJobByDeviceRequest) SetFirmwareId(v string) *ListOTAJobByDeviceRequest {
	s.FirmwareId = &v
	return s
}

func (s *ListOTAJobByDeviceRequest) SetIotInstanceId(v string) *ListOTAJobByDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListOTAJobByDeviceRequest) SetPageSize(v int32) *ListOTAJobByDeviceRequest {
	s.PageSize = &v
	return s
}

func (s *ListOTAJobByDeviceRequest) SetProductKey(v string) *ListOTAJobByDeviceRequest {
	s.ProductKey = &v
	return s
}

type ListOTAJobByDeviceResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The update batch information returned if the call is successful. For more information, see the following **SimpleOTAJobInfo** parameter.
	Data *ListOTAJobByDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The total number of pages.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of update packages returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListOTAJobByDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListOTAJobByDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *ListOTAJobByDeviceResponseBody) SetCode(v string) *ListOTAJobByDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBody) SetCurrentPage(v int32) *ListOTAJobByDeviceResponseBody {
	s.CurrentPage = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBody) SetData(v *ListOTAJobByDeviceResponseBodyData) *ListOTAJobByDeviceResponseBody {
	s.Data = v
	return s
}

func (s *ListOTAJobByDeviceResponseBody) SetErrorMessage(v string) *ListOTAJobByDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBody) SetPageCount(v int32) *ListOTAJobByDeviceResponseBody {
	s.PageCount = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBody) SetPageSize(v int32) *ListOTAJobByDeviceResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBody) SetRequestId(v string) *ListOTAJobByDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBody) SetSuccess(v bool) *ListOTAJobByDeviceResponseBody {
	s.Success = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBody) SetTotal(v int32) *ListOTAJobByDeviceResponseBody {
	s.Total = &v
	return s
}

type ListOTAJobByDeviceResponseBodyData struct {
	SimpleOTAJobInfo []*ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo `json:"SimpleOTAJobInfo,omitempty" xml:"SimpleOTAJobInfo,omitempty" type:"Repeated"`
}

func (s ListOTAJobByDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListOTAJobByDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListOTAJobByDeviceResponseBodyData) SetSimpleOTAJobInfo(v []*ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo) *ListOTAJobByDeviceResponseBodyData {
	s.SimpleOTAJobInfo = v
	return s
}

type ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo struct {
	// The ID of the update package.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The ID of the update batch.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The status of the update batch. Valid values:
	//
	// *   **IN_PROGRESS**: The update batch is running.
	// *   **COMPLETE**: The update batch is completed.
	// *   **CANCELED**: The update batch is canceled.
	JobStatus *string `json:"JobStatus,omitempty" xml:"JobStatus,omitempty"`
	// The type of the task. Valid values:
	//
	// *   **VERFIY_FIRMWARE**: update package verification.
	// *   **UPGRADE_FIRMWARE**: batch update.
	JobType *string `json:"JobType,omitempty" xml:"JobType,omitempty"`
	// The ProductKey of the product to which the update package belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The update policy of the update batch. Valid values:
	//
	// *   DYNAMIC: dynamic update. This value is returned if you call the [CreateOTADynamicUpgradeJob](~~147887~~) API operation to create an update batch.
	// *   STATIC: static update. This value is returned if you call the [CreateOTAStaticUpgradeJob](~~147496~~) API operation to create an update batch.
	SelectionType *string `json:"SelectionType,omitempty" xml:"SelectionType,omitempty"`
	// The tags of the update batch.
	Tags *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The scope of the update. Valid values:
	//
	// - **ALL**: updates all devices.
	// - **SPECIFIC**: updates specified devices.
	// - **GRAY**: performs a phased update.
	//
	// >  The value ALL is returned if you call the [CreateOTADynamicUpgradeJob](/help/en/iot-platform/latest/av6dui) API operation to create an update batch.
	TargetSelection *string `json:"TargetSelection,omitempty" xml:"TargetSelection,omitempty"`
	// The time when the update batch was created. The time is displayed in UTC.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
	// The end time of the update batch. The time is displayed in UTC.
	//
	// >  This parameter is returned only after the update batch is completed.
	UtcEndTime *string `json:"UtcEndTime,omitempty" xml:"UtcEndTime,omitempty"`
	// The time when the task was last modified. The time is in UTC.
	UtcModified *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
	// The start time of the update batch. The time is in the UTC format.
	UtcStartTime *string `json:"UtcStartTime,omitempty" xml:"UtcStartTime,omitempty"`
}

func (s ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo) String() string {
	return tea.Prettify(s)
}

func (s ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo) GoString() string {
	return s.String()
}

func (s *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo) SetFirmwareId(v string) *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo {
	s.FirmwareId = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo) SetJobId(v string) *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo {
	s.JobId = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo) SetJobStatus(v string) *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo {
	s.JobStatus = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo) SetJobType(v string) *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo {
	s.JobType = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo) SetProductKey(v string) *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo {
	s.ProductKey = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo) SetSelectionType(v string) *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo {
	s.SelectionType = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo) SetTags(v *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags) *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo {
	s.Tags = v
	return s
}

func (s *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo) SetTargetSelection(v string) *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo {
	s.TargetSelection = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo) SetUtcCreate(v string) *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo {
	s.UtcCreate = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo) SetUtcEndTime(v string) *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo {
	s.UtcEndTime = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo) SetUtcModified(v string) *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo {
	s.UtcModified = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo) SetUtcStartTime(v string) *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfo {
	s.UtcStartTime = &v
	return s
}

type ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags struct {
	OtaTagDTO []*ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO `json:"OtaTagDTO,omitempty" xml:"OtaTagDTO,omitempty" type:"Repeated"`
}

func (s ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags) String() string {
	return tea.Prettify(s)
}

func (s ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags) GoString() string {
	return s.String()
}

func (s *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags) SetOtaTagDTO(v []*ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO) *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTags {
	s.OtaTagDTO = v
	return s
}

type ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO struct {
	// The key of each tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO) String() string {
	return tea.Prettify(s)
}

func (s ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO) GoString() string {
	return s.String()
}

func (s *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO) SetKey(v string) *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO {
	s.Key = &v
	return s
}

func (s *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO) SetValue(v string) *ListOTAJobByDeviceResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO {
	s.Value = &v
	return s
}

type ListOTAJobByDeviceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListOTAJobByDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListOTAJobByDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListOTAJobByDeviceResponse) GoString() string {
	return s.String()
}

func (s *ListOTAJobByDeviceResponse) SetHeaders(v map[string]*string) *ListOTAJobByDeviceResponse {
	s.Headers = v
	return s
}

func (s *ListOTAJobByDeviceResponse) SetStatusCode(v int32) *ListOTAJobByDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *ListOTAJobByDeviceResponse) SetBody(v *ListOTAJobByDeviceResponseBody) *ListOTAJobByDeviceResponse {
	s.Body = v
	return s
}

type ListOTAJobByFirmwareRequest struct {
	// The number of the page to return. Pages start from page 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The ID of the update package.
	//
	// An update package ID is returned when you call the [CreateOTAFirmware](~~147311~~) operation to create the update package.
	//
	// You can call the [ListOTAFirmware](~~147450~~) operation and view the update package ID in the response.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Maximum value: 200.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s ListOTAJobByFirmwareRequest) String() string {
	return tea.Prettify(s)
}

func (s ListOTAJobByFirmwareRequest) GoString() string {
	return s.String()
}

func (s *ListOTAJobByFirmwareRequest) SetCurrentPage(v int32) *ListOTAJobByFirmwareRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListOTAJobByFirmwareRequest) SetFirmwareId(v string) *ListOTAJobByFirmwareRequest {
	s.FirmwareId = &v
	return s
}

func (s *ListOTAJobByFirmwareRequest) SetIotInstanceId(v string) *ListOTAJobByFirmwareRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListOTAJobByFirmwareRequest) SetPageSize(v int32) *ListOTAJobByFirmwareRequest {
	s.PageSize = &v
	return s
}

type ListOTAJobByFirmwareResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The update batch information returned if the call is successful. For more information, see **SimpleOTATaskInfo**.
	Data *ListOTAJobByFirmwareResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The total number of pages.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of update jobs returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListOTAJobByFirmwareResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListOTAJobByFirmwareResponseBody) GoString() string {
	return s.String()
}

func (s *ListOTAJobByFirmwareResponseBody) SetCode(v string) *ListOTAJobByFirmwareResponseBody {
	s.Code = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBody) SetCurrentPage(v int32) *ListOTAJobByFirmwareResponseBody {
	s.CurrentPage = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBody) SetData(v *ListOTAJobByFirmwareResponseBodyData) *ListOTAJobByFirmwareResponseBody {
	s.Data = v
	return s
}

func (s *ListOTAJobByFirmwareResponseBody) SetErrorMessage(v string) *ListOTAJobByFirmwareResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBody) SetPageCount(v int32) *ListOTAJobByFirmwareResponseBody {
	s.PageCount = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBody) SetPageSize(v int32) *ListOTAJobByFirmwareResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBody) SetRequestId(v string) *ListOTAJobByFirmwareResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBody) SetSuccess(v bool) *ListOTAJobByFirmwareResponseBody {
	s.Success = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBody) SetTotal(v int32) *ListOTAJobByFirmwareResponseBody {
	s.Total = &v
	return s
}

type ListOTAJobByFirmwareResponseBodyData struct {
	SimpleOTAJobInfo []*ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo `json:"SimpleOTAJobInfo,omitempty" xml:"SimpleOTAJobInfo,omitempty" type:"Repeated"`
}

func (s ListOTAJobByFirmwareResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListOTAJobByFirmwareResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListOTAJobByFirmwareResponseBodyData) SetSimpleOTAJobInfo(v []*ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo) *ListOTAJobByFirmwareResponseBodyData {
	s.SimpleOTAJobInfo = v
	return s
}

type ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo struct {
	// The ID of the update package.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The ID of the update batch.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The status of the update batch.
	//
	// *   **PLANNED**: The update batch is being planned. The batch is created, but the scheduled time has not arrived. This parameter is returned only if you perform a static update.
	// *   **IN_PROGRESS**: The update batch is running.
	// *   **COMPLETE**: The update batch is completed.
	// *   **CANCELED**: The update batch is canceled.
	JobStatus *string `json:"JobStatus,omitempty" xml:"JobStatus,omitempty"`
	// The type of the batch. Valid values:
	//
	// *   **VERFIY_FIRMWARE**: update package verification.
	// *   **UPGRADE_FIRMWARE**: batch update.
	JobType *string `json:"JobType,omitempty" xml:"JobType,omitempty"`
	// The ProductKey of the product to which the update package belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The update policy of the update batch. Valid values:
	//
	// *   **DYNAMIC**: dynamic update. This value is returned if you call the [CreateOTADynamicUpgradeJob](~~147887~~) API operation to create an update batch.
	// *   **STATIC**: static update. This value is returned if you call the [CreateOTAStaticUpgradeJob](~~147496~~) API operation to create an update batch.
	SelectionType *string `json:"SelectionType,omitempty" xml:"SelectionType,omitempty"`
	// The tags of the update batch.
	Tags *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The scope of the update batch. Valid values:
	//
	// - **ALL**: updates all devices.
	// - **SPECIFIC**: updates specified devices.
	// - **GRAY**: performs a phased update.
	//
	// >  The value ALL is returned if you call the [CreateOTADynamicUpgradeJob](/help/en/iot-platform/latest/av6dui) API operation to create an update batch.
	TargetSelection *string `json:"TargetSelection,omitempty" xml:"TargetSelection,omitempty"`
	// The time when the update batch was created. The time is displayed in UTC.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
	// The end time of the update batch. The time is displayed in UTC.
	//
	// This parameter is returned only after the update batch is completed.
	UtcEndTime *string `json:"UtcEndTime,omitempty" xml:"UtcEndTime,omitempty"`
	// The time when the update batch was last modified. The time is displayed in UTC.
	UtcModified *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
	// The start time of the update batch. The time is displayed in UTC.
	UtcStartTime *string `json:"UtcStartTime,omitempty" xml:"UtcStartTime,omitempty"`
}

func (s ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo) String() string {
	return tea.Prettify(s)
}

func (s ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo) GoString() string {
	return s.String()
}

func (s *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo) SetFirmwareId(v string) *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo {
	s.FirmwareId = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo) SetJobId(v string) *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo {
	s.JobId = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo) SetJobStatus(v string) *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo {
	s.JobStatus = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo) SetJobType(v string) *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo {
	s.JobType = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo) SetProductKey(v string) *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo {
	s.ProductKey = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo) SetSelectionType(v string) *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo {
	s.SelectionType = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo) SetTags(v *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags) *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo {
	s.Tags = v
	return s
}

func (s *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo) SetTargetSelection(v string) *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo {
	s.TargetSelection = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo) SetUtcCreate(v string) *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo {
	s.UtcCreate = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo) SetUtcEndTime(v string) *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo {
	s.UtcEndTime = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo) SetUtcModified(v string) *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo {
	s.UtcModified = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo) SetUtcStartTime(v string) *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfo {
	s.UtcStartTime = &v
	return s
}

type ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags struct {
	OtaTagDTO []*ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO `json:"OtaTagDTO,omitempty" xml:"OtaTagDTO,omitempty" type:"Repeated"`
}

func (s ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags) String() string {
	return tea.Prettify(s)
}

func (s ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags) GoString() string {
	return s.String()
}

func (s *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags) SetOtaTagDTO(v []*ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO) *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTags {
	s.OtaTagDTO = v
	return s
}

type ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO struct {
	// The key of each tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO) String() string {
	return tea.Prettify(s)
}

func (s ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO) GoString() string {
	return s.String()
}

func (s *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO) SetKey(v string) *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO {
	s.Key = &v
	return s
}

func (s *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO) SetValue(v string) *ListOTAJobByFirmwareResponseBodyDataSimpleOTAJobInfoTagsOtaTagDTO {
	s.Value = &v
	return s
}

type ListOTAJobByFirmwareResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListOTAJobByFirmwareResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListOTAJobByFirmwareResponse) String() string {
	return tea.Prettify(s)
}

func (s ListOTAJobByFirmwareResponse) GoString() string {
	return s.String()
}

func (s *ListOTAJobByFirmwareResponse) SetHeaders(v map[string]*string) *ListOTAJobByFirmwareResponse {
	s.Headers = v
	return s
}

func (s *ListOTAJobByFirmwareResponse) SetStatusCode(v int32) *ListOTAJobByFirmwareResponse {
	s.StatusCode = &v
	return s
}

func (s *ListOTAJobByFirmwareResponse) SetBody(v *ListOTAJobByFirmwareResponseBody) *ListOTAJobByFirmwareResponse {
	s.Body = v
	return s
}

type ListOTAModuleByProductRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s ListOTAModuleByProductRequest) String() string {
	return tea.Prettify(s)
}

func (s ListOTAModuleByProductRequest) GoString() string {
	return s.String()
}

func (s *ListOTAModuleByProductRequest) SetIotInstanceId(v string) *ListOTAModuleByProductRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListOTAModuleByProductRequest) SetProductKey(v string) *ListOTAModuleByProductRequest {
	s.ProductKey = &v
	return s
}

type ListOTAModuleByProductResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The OTA modules returned if the call is successful.
	Data []*ListOTAModuleByProductResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListOTAModuleByProductResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListOTAModuleByProductResponseBody) GoString() string {
	return s.String()
}

func (s *ListOTAModuleByProductResponseBody) SetCode(v string) *ListOTAModuleByProductResponseBody {
	s.Code = &v
	return s
}

func (s *ListOTAModuleByProductResponseBody) SetData(v []*ListOTAModuleByProductResponseBodyData) *ListOTAModuleByProductResponseBody {
	s.Data = v
	return s
}

func (s *ListOTAModuleByProductResponseBody) SetErrorMessage(v string) *ListOTAModuleByProductResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListOTAModuleByProductResponseBody) SetRequestId(v string) *ListOTAModuleByProductResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListOTAModuleByProductResponseBody) SetSuccess(v bool) *ListOTAModuleByProductResponseBody {
	s.Success = &v
	return s
}

type ListOTAModuleByProductResponseBodyData struct {
	// The alias of the OTA module.
	AliasName *string `json:"AliasName,omitempty" xml:"AliasName,omitempty"`
	// The description of the OTA module.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The time when the OTA module was created. The time is displayed in UTC.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The last time when the OTA module was updated. The time is displayed in UTC.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The name of the OTA module.
	ModuleName *string `json:"ModuleName,omitempty" xml:"ModuleName,omitempty"`
	// The ProductKey of the product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s ListOTAModuleByProductResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListOTAModuleByProductResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListOTAModuleByProductResponseBodyData) SetAliasName(v string) *ListOTAModuleByProductResponseBodyData {
	s.AliasName = &v
	return s
}

func (s *ListOTAModuleByProductResponseBodyData) SetDesc(v string) *ListOTAModuleByProductResponseBodyData {
	s.Desc = &v
	return s
}

func (s *ListOTAModuleByProductResponseBodyData) SetGmtCreate(v string) *ListOTAModuleByProductResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *ListOTAModuleByProductResponseBodyData) SetGmtModified(v string) *ListOTAModuleByProductResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *ListOTAModuleByProductResponseBodyData) SetModuleName(v string) *ListOTAModuleByProductResponseBodyData {
	s.ModuleName = &v
	return s
}

func (s *ListOTAModuleByProductResponseBodyData) SetProductKey(v string) *ListOTAModuleByProductResponseBodyData {
	s.ProductKey = &v
	return s
}

type ListOTAModuleByProductResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListOTAModuleByProductResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListOTAModuleByProductResponse) String() string {
	return tea.Prettify(s)
}

func (s ListOTAModuleByProductResponse) GoString() string {
	return s.String()
}

func (s *ListOTAModuleByProductResponse) SetHeaders(v map[string]*string) *ListOTAModuleByProductResponse {
	s.Headers = v
	return s
}

func (s *ListOTAModuleByProductResponse) SetStatusCode(v int32) *ListOTAModuleByProductResponse {
	s.StatusCode = &v
	return s
}

func (s *ListOTAModuleByProductResponse) SetBody(v *ListOTAModuleByProductResponseBody) *ListOTAModuleByProductResponse {
	s.Body = v
	return s
}

type ListOTAModuleVersionsByDeviceRequest struct {
	// The number of the page to return. Default value: 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The DeviceName of the device to be queried.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The device ID is issued by IoT Platform.
	//
	// >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. A maximum of 200 entries can be displayed on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s ListOTAModuleVersionsByDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s ListOTAModuleVersionsByDeviceRequest) GoString() string {
	return s.String()
}

func (s *ListOTAModuleVersionsByDeviceRequest) SetCurrentPage(v int32) *ListOTAModuleVersionsByDeviceRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceRequest) SetDeviceName(v string) *ListOTAModuleVersionsByDeviceRequest {
	s.DeviceName = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceRequest) SetIotId(v string) *ListOTAModuleVersionsByDeviceRequest {
	s.IotId = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceRequest) SetIotInstanceId(v string) *ListOTAModuleVersionsByDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceRequest) SetPageSize(v int32) *ListOTAModuleVersionsByDeviceRequest {
	s.PageSize = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceRequest) SetProductKey(v string) *ListOTAModuleVersionsByDeviceRequest {
	s.ProductKey = &v
	return s
}

type ListOTAModuleVersionsByDeviceResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The current page number.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The module version information returned if the call is successful. The information was submitted by the device. For more information, see the **SimpleOTAModuleInfo** parameter in this table.
	Data *ListOTAModuleVersionsByDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The total number of pages returned.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of module versions returned on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of module versions that was submitted by the device.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListOTAModuleVersionsByDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListOTAModuleVersionsByDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *ListOTAModuleVersionsByDeviceResponseBody) SetCode(v string) *ListOTAModuleVersionsByDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceResponseBody) SetCurrentPage(v int32) *ListOTAModuleVersionsByDeviceResponseBody {
	s.CurrentPage = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceResponseBody) SetData(v *ListOTAModuleVersionsByDeviceResponseBodyData) *ListOTAModuleVersionsByDeviceResponseBody {
	s.Data = v
	return s
}

func (s *ListOTAModuleVersionsByDeviceResponseBody) SetErrorMessage(v string) *ListOTAModuleVersionsByDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceResponseBody) SetPageCount(v int32) *ListOTAModuleVersionsByDeviceResponseBody {
	s.PageCount = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceResponseBody) SetPageSize(v int32) *ListOTAModuleVersionsByDeviceResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceResponseBody) SetRequestId(v string) *ListOTAModuleVersionsByDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceResponseBody) SetSuccess(v bool) *ListOTAModuleVersionsByDeviceResponseBody {
	s.Success = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceResponseBody) SetTotal(v int32) *ListOTAModuleVersionsByDeviceResponseBody {
	s.Total = &v
	return s
}

type ListOTAModuleVersionsByDeviceResponseBodyData struct {
	SimpleOTAModuleInfo []*ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo `json:"SimpleOTAModuleInfo,omitempty" xml:"SimpleOTAModuleInfo,omitempty" type:"Repeated"`
}

func (s ListOTAModuleVersionsByDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListOTAModuleVersionsByDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListOTAModuleVersionsByDeviceResponseBodyData) SetSimpleOTAModuleInfo(v []*ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo) *ListOTAModuleVersionsByDeviceResponseBodyData {
	s.SimpleOTAModuleInfo = v
	return s
}

type ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo struct {
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The name of the OTA module.
	ModuleName *string `json:"ModuleName,omitempty" xml:"ModuleName,omitempty"`
	// The module version that was submitted by the device.
	ModuleVersion *string `json:"ModuleVersion,omitempty" xml:"ModuleVersion,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo) String() string {
	return tea.Prettify(s)
}

func (s ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo) GoString() string {
	return s.String()
}

func (s *ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo) SetDeviceName(v string) *ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo {
	s.DeviceName = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo) SetIotId(v string) *ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo {
	s.IotId = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo) SetModuleName(v string) *ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo {
	s.ModuleName = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo) SetModuleVersion(v string) *ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo {
	s.ModuleVersion = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo) SetProductKey(v string) *ListOTAModuleVersionsByDeviceResponseBodyDataSimpleOTAModuleInfo {
	s.ProductKey = &v
	return s
}

type ListOTAModuleVersionsByDeviceResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListOTAModuleVersionsByDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListOTAModuleVersionsByDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListOTAModuleVersionsByDeviceResponse) GoString() string {
	return s.String()
}

func (s *ListOTAModuleVersionsByDeviceResponse) SetHeaders(v map[string]*string) *ListOTAModuleVersionsByDeviceResponse {
	s.Headers = v
	return s
}

func (s *ListOTAModuleVersionsByDeviceResponse) SetStatusCode(v int32) *ListOTAModuleVersionsByDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *ListOTAModuleVersionsByDeviceResponse) SetBody(v *ListOTAModuleVersionsByDeviceResponseBody) *ListOTAModuleVersionsByDeviceResponse {
	s.Body = v
	return s
}

type ListOTATaskByJobRequest struct {
	// The number of the page to return. Pages start from page 1.
	//
	// > The product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter must be less than or equal to 100,000.
	CurrentPage *int32    `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	DeviceNames []*string `json:"DeviceNames,omitempty" xml:"DeviceNames,omitempty" type:"Repeated"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the update batch. This ID uniquely identifies the update batch. You can obtain the ID from the value of the **JobId** parameter that is returned after you call the [CreateOTAVerifyJob](~~147480~~), [CreateOTAStaticUpgradeJob](~~147496~~), or [CreateOTADynamicUpgradeJob](~~147887~~) operation. You can also view the batch ID on the **Firmware Details** page of the IoT Platform console.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The number of entries to return on each page. Maximum value: 100.
	//
	//
	//
	// > The product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter must be less than or equal to 100,000.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// If you specify a value for this parameter, only the update tasks that are in the specified state are queried. Valid values:
	//
	// *   **CONFIRM**: The update task is pending confirmation.
	// *   **QUEUED**: The update notification is to be pushed.
	// *   **NOTIFIED**: The update notification is pushed to the device.
	// *   **IN_PROGRESS**: The update task is in progress.
	// *   **SUCCEEDED**: The update is successful.
	// *   **FAILED**: The update failed.
	// *   **CANCELED**: The update batch is canceled.
	//
	// If you do not specify a value for this parameter, all update tasks of the specified batch are queried.
	TaskStatus *string `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
}

func (s ListOTATaskByJobRequest) String() string {
	return tea.Prettify(s)
}

func (s ListOTATaskByJobRequest) GoString() string {
	return s.String()
}

func (s *ListOTATaskByJobRequest) SetCurrentPage(v int32) *ListOTATaskByJobRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListOTATaskByJobRequest) SetDeviceNames(v []*string) *ListOTATaskByJobRequest {
	s.DeviceNames = v
	return s
}

func (s *ListOTATaskByJobRequest) SetIotInstanceId(v string) *ListOTATaskByJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListOTATaskByJobRequest) SetJobId(v string) *ListOTATaskByJobRequest {
	s.JobId = &v
	return s
}

func (s *ListOTATaskByJobRequest) SetPageSize(v int32) *ListOTATaskByJobRequest {
	s.PageSize = &v
	return s
}

func (s *ListOTATaskByJobRequest) SetTaskStatus(v string) *ListOTATaskByJobRequest {
	s.TaskStatus = &v
	return s
}

type ListOTATaskByJobResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The update task information returned if the call is successful. For more information, see **SimpleOTATaskInfo**.
	Data *ListOTATaskByJobResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The total number of pages returned.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of update tasks.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListOTATaskByJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListOTATaskByJobResponseBody) GoString() string {
	return s.String()
}

func (s *ListOTATaskByJobResponseBody) SetCode(v string) *ListOTATaskByJobResponseBody {
	s.Code = &v
	return s
}

func (s *ListOTATaskByJobResponseBody) SetCurrentPage(v int32) *ListOTATaskByJobResponseBody {
	s.CurrentPage = &v
	return s
}

func (s *ListOTATaskByJobResponseBody) SetData(v *ListOTATaskByJobResponseBodyData) *ListOTATaskByJobResponseBody {
	s.Data = v
	return s
}

func (s *ListOTATaskByJobResponseBody) SetErrorMessage(v string) *ListOTATaskByJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListOTATaskByJobResponseBody) SetPageCount(v int32) *ListOTATaskByJobResponseBody {
	s.PageCount = &v
	return s
}

func (s *ListOTATaskByJobResponseBody) SetPageSize(v int32) *ListOTATaskByJobResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListOTATaskByJobResponseBody) SetRequestId(v string) *ListOTATaskByJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListOTATaskByJobResponseBody) SetSuccess(v bool) *ListOTATaskByJobResponseBody {
	s.Success = &v
	return s
}

func (s *ListOTATaskByJobResponseBody) SetTotal(v int32) *ListOTATaskByJobResponseBody {
	s.Total = &v
	return s
}

type ListOTATaskByJobResponseBodyData struct {
	SimpleOTATaskInfo []*ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo `json:"SimpleOTATaskInfo,omitempty" xml:"SimpleOTATaskInfo,omitempty" type:"Repeated"`
}

func (s ListOTATaskByJobResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListOTATaskByJobResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListOTATaskByJobResponseBodyData) SetSimpleOTATaskInfo(v []*ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) *ListOTATaskByJobResponseBodyData {
	s.SimpleOTATaskInfo = v
	return s
}

type ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo struct {
	// The version of the destination over-the-air (OTA) update package.
	DestVersion *string `json:"DestVersion,omitempty" xml:"DestVersion,omitempty"`
	// The name of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the update package.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The ID of the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the update batch.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The name of the product to which the device belongs.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
	// The current update progress.
	Progress *string `json:"Progress,omitempty" xml:"Progress,omitempty"`
	// The firmware version before the update.
	SrcVersion *string `json:"SrcVersion,omitempty" xml:"SrcVersion,omitempty"`
	// The description of the update task. This parameter displays an error message if the device update times out or the update task is canceled.
	TaskDesc *string `json:"TaskDesc,omitempty" xml:"TaskDesc,omitempty"`
	// The ID of the update task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The update status of the device.
	//
	// *   **CONFIRM**: The update task is pending confirmation.
	// *   **QUEUED**: The update notification is to be pushed.
	// *   **NOTIFIED**: The update notification is pushed to the device.
	// *   **IN_PROGRESS**: The update task is in progress.
	// *   **SUCCEEDED**: The update is successful.
	// *   **FAILED**: The update failed.
	// *   **CANCELED**: The update batch is canceled.
	TaskStatus *string `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
	// The timeout period of the device update. Unit: minutes.
	//
	// >  If no timeout period is specified for the update batch, the return value is null.
	Timeout *string `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The time when the update task was created. The time is displayed in UTC.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
	// The time when the update task was last modified. The time is displayed in UTC.
	UtcModified *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
}

func (s ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) String() string {
	return tea.Prettify(s)
}

func (s ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) GoString() string {
	return s.String()
}

func (s *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) SetDestVersion(v string) *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo {
	s.DestVersion = &v
	return s
}

func (s *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) SetDeviceName(v string) *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo {
	s.DeviceName = &v
	return s
}

func (s *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) SetFirmwareId(v string) *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo {
	s.FirmwareId = &v
	return s
}

func (s *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) SetIotId(v string) *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo {
	s.IotId = &v
	return s
}

func (s *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) SetJobId(v string) *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo {
	s.JobId = &v
	return s
}

func (s *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) SetProductKey(v string) *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo {
	s.ProductKey = &v
	return s
}

func (s *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) SetProductName(v string) *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo {
	s.ProductName = &v
	return s
}

func (s *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) SetProgress(v string) *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo {
	s.Progress = &v
	return s
}

func (s *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) SetSrcVersion(v string) *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo {
	s.SrcVersion = &v
	return s
}

func (s *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) SetTaskDesc(v string) *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo {
	s.TaskDesc = &v
	return s
}

func (s *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) SetTaskId(v string) *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo {
	s.TaskId = &v
	return s
}

func (s *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) SetTaskStatus(v string) *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo {
	s.TaskStatus = &v
	return s
}

func (s *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) SetTimeout(v string) *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo {
	s.Timeout = &v
	return s
}

func (s *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) SetUtcCreate(v string) *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo {
	s.UtcCreate = &v
	return s
}

func (s *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo) SetUtcModified(v string) *ListOTATaskByJobResponseBodyDataSimpleOTATaskInfo {
	s.UtcModified = &v
	return s
}

type ListOTATaskByJobResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListOTATaskByJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListOTATaskByJobResponse) String() string {
	return tea.Prettify(s)
}

func (s ListOTATaskByJobResponse) GoString() string {
	return s.String()
}

func (s *ListOTATaskByJobResponse) SetHeaders(v map[string]*string) *ListOTATaskByJobResponse {
	s.Headers = v
	return s
}

func (s *ListOTATaskByJobResponse) SetStatusCode(v int32) *ListOTATaskByJobResponse {
	s.StatusCode = &v
	return s
}

func (s *ListOTATaskByJobResponse) SetBody(v *ListOTATaskByJobResponseBody) *ListOTATaskByJobResponse {
	s.Body = v
	return s
}

type ListOTAUnfinishedTaskByDeviceRequest struct {
	// The DeviceName of the device.
	//
	// > If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device.
	//
	// > If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The name of the OTA module.
	//
	// *   If you specify this parameter, update tasks of the specified module are queried.
	// *   If you do not specify this parameter, update tasks of all modules are queried.
	ModuleName *string `json:"ModuleName,omitempty" xml:"ModuleName,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// > If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The status of the update task.
	//
	// *   **CONFIRM**: The update task is pending confirmation.
	// *   **QUEUED**: The update notification is to be pushed.
	// *   **NOTIFIED**: The update notification is pushed to the device.
	// *   **IN_PROGRESS**: The update task is in progress.
	TaskStatus *string `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
}

func (s ListOTAUnfinishedTaskByDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s ListOTAUnfinishedTaskByDeviceRequest) GoString() string {
	return s.String()
}

func (s *ListOTAUnfinishedTaskByDeviceRequest) SetDeviceName(v string) *ListOTAUnfinishedTaskByDeviceRequest {
	s.DeviceName = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceRequest) SetIotId(v string) *ListOTAUnfinishedTaskByDeviceRequest {
	s.IotId = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceRequest) SetIotInstanceId(v string) *ListOTAUnfinishedTaskByDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceRequest) SetModuleName(v string) *ListOTAUnfinishedTaskByDeviceRequest {
	s.ModuleName = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceRequest) SetProductKey(v string) *ListOTAUnfinishedTaskByDeviceRequest {
	s.ProductKey = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceRequest) SetTaskStatus(v string) *ListOTAUnfinishedTaskByDeviceRequest {
	s.TaskStatus = &v
	return s
}

type ListOTAUnfinishedTaskByDeviceResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The update task information returned if the call is successful. For more information, see the following **SimpleOTATaskInfo**.
	Data *ListOTAUnfinishedTaskByDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListOTAUnfinishedTaskByDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListOTAUnfinishedTaskByDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBody) SetCode(v string) *ListOTAUnfinishedTaskByDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBody) SetData(v *ListOTAUnfinishedTaskByDeviceResponseBodyData) *ListOTAUnfinishedTaskByDeviceResponseBody {
	s.Data = v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBody) SetErrorMessage(v string) *ListOTAUnfinishedTaskByDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBody) SetRequestId(v string) *ListOTAUnfinishedTaskByDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBody) SetSuccess(v bool) *ListOTAUnfinishedTaskByDeviceResponseBody {
	s.Success = &v
	return s
}

type ListOTAUnfinishedTaskByDeviceResponseBodyData struct {
	SimpleOTATaskInfo []*ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo `json:"SimpleOTATaskInfo,omitempty" xml:"SimpleOTATaskInfo,omitempty" type:"Repeated"`
}

func (s ListOTAUnfinishedTaskByDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListOTAUnfinishedTaskByDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBodyData) SetSimpleOTATaskInfo(v []*ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) *ListOTAUnfinishedTaskByDeviceResponseBodyData {
	s.SimpleOTATaskInfo = v
	return s
}

type ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo struct {
	// The firmware version after the update.
	DestVersion *string `json:"DestVersion,omitempty" xml:"DestVersion,omitempty"`
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the update package.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the update batch.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The name of the OTA module.
	ModuleName *string `json:"ModuleName,omitempty" xml:"ModuleName,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The name of the product to which the device belongs.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
	// The firmware version before the update.
	SrcVersion *string `json:"SrcVersion,omitempty" xml:"SrcVersion,omitempty"`
	// The ID of the update task.
	TaskId *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	// The status of the update task.
	//
	// *   **CONFIRM**: The update task is pending confirmation.
	// *   **QUEUED**: The update notification is to be pushed.
	// *   **NOTIFIED**: The update notification is pushed to the device.
	// *   **IN_PROGRESS**: The update task is in progress.
	TaskStatus *string `json:"TaskStatus,omitempty" xml:"TaskStatus,omitempty"`
	// The time when the update task was created. The time is displayed in UTC.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
	// The time when the update task was last modified. The time is displayed in UTC.
	UtcModified *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
}

func (s ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) String() string {
	return tea.Prettify(s)
}

func (s ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) GoString() string {
	return s.String()
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) SetDestVersion(v string) *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo {
	s.DestVersion = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) SetDeviceName(v string) *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo {
	s.DeviceName = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) SetFirmwareId(v string) *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo {
	s.FirmwareId = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) SetIotId(v string) *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo {
	s.IotId = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) SetJobId(v string) *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo {
	s.JobId = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) SetModuleName(v string) *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo {
	s.ModuleName = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) SetProductKey(v string) *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo {
	s.ProductKey = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) SetProductName(v string) *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo {
	s.ProductName = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) SetSrcVersion(v string) *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo {
	s.SrcVersion = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) SetTaskId(v string) *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo {
	s.TaskId = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) SetTaskStatus(v string) *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo {
	s.TaskStatus = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) SetUtcCreate(v string) *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo {
	s.UtcCreate = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo) SetUtcModified(v string) *ListOTAUnfinishedTaskByDeviceResponseBodyDataSimpleOTATaskInfo {
	s.UtcModified = &v
	return s
}

type ListOTAUnfinishedTaskByDeviceResponse struct {
	Headers    map[string]*string                         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListOTAUnfinishedTaskByDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListOTAUnfinishedTaskByDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListOTAUnfinishedTaskByDeviceResponse) GoString() string {
	return s.String()
}

func (s *ListOTAUnfinishedTaskByDeviceResponse) SetHeaders(v map[string]*string) *ListOTAUnfinishedTaskByDeviceResponse {
	s.Headers = v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponse) SetStatusCode(v int32) *ListOTAUnfinishedTaskByDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *ListOTAUnfinishedTaskByDeviceResponse) SetBody(v *ListOTAUnfinishedTaskByDeviceResponseBody) *ListOTAUnfinishedTaskByDeviceResponse {
	s.Body = v
	return s
}

type ListParserRequest struct {
	CurrentPage   *int32  `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SearchName    *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
}

func (s ListParserRequest) String() string {
	return tea.Prettify(s)
}

func (s ListParserRequest) GoString() string {
	return s.String()
}

func (s *ListParserRequest) SetCurrentPage(v int32) *ListParserRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListParserRequest) SetIotInstanceId(v string) *ListParserRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListParserRequest) SetPageSize(v int32) *ListParserRequest {
	s.PageSize = &v
	return s
}

func (s *ListParserRequest) SetSearchName(v string) *ListParserRequest {
	s.SearchName = &v
	return s
}

type ListParserResponseBody struct {
	Code         *string                     `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *ListParserResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                       `json:"Success,omitempty" xml:"Success,omitempty"`
	Total        *int32                      `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListParserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListParserResponseBody) GoString() string {
	return s.String()
}

func (s *ListParserResponseBody) SetCode(v string) *ListParserResponseBody {
	s.Code = &v
	return s
}

func (s *ListParserResponseBody) SetData(v *ListParserResponseBodyData) *ListParserResponseBody {
	s.Data = v
	return s
}

func (s *ListParserResponseBody) SetErrorMessage(v string) *ListParserResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListParserResponseBody) SetRequestId(v string) *ListParserResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListParserResponseBody) SetSuccess(v bool) *ListParserResponseBody {
	s.Success = &v
	return s
}

func (s *ListParserResponseBody) SetTotal(v int32) *ListParserResponseBody {
	s.Total = &v
	return s
}

type ListParserResponseBodyData struct {
	ParserList []*ListParserResponseBodyDataParserList `json:"ParserList,omitempty" xml:"ParserList,omitempty" type:"Repeated"`
}

func (s ListParserResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListParserResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListParserResponseBodyData) SetParserList(v []*ListParserResponseBodyDataParserList) *ListParserResponseBodyData {
	s.ParserList = v
	return s
}

type ListParserResponseBodyDataParserList struct {
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Name        *string `json:"Name,omitempty" xml:"Name,omitempty"`
	ParserId    *int64  `json:"ParserId,omitempty" xml:"ParserId,omitempty"`
	Status      *string `json:"Status,omitempty" xml:"Status,omitempty"`
	UtcCreated  *string `json:"UtcCreated,omitempty" xml:"UtcCreated,omitempty"`
	UtcModified *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
}

func (s ListParserResponseBodyDataParserList) String() string {
	return tea.Prettify(s)
}

func (s ListParserResponseBodyDataParserList) GoString() string {
	return s.String()
}

func (s *ListParserResponseBodyDataParserList) SetDescription(v string) *ListParserResponseBodyDataParserList {
	s.Description = &v
	return s
}

func (s *ListParserResponseBodyDataParserList) SetName(v string) *ListParserResponseBodyDataParserList {
	s.Name = &v
	return s
}

func (s *ListParserResponseBodyDataParserList) SetParserId(v int64) *ListParserResponseBodyDataParserList {
	s.ParserId = &v
	return s
}

func (s *ListParserResponseBodyDataParserList) SetStatus(v string) *ListParserResponseBodyDataParserList {
	s.Status = &v
	return s
}

func (s *ListParserResponseBodyDataParserList) SetUtcCreated(v string) *ListParserResponseBodyDataParserList {
	s.UtcCreated = &v
	return s
}

func (s *ListParserResponseBodyDataParserList) SetUtcModified(v string) *ListParserResponseBodyDataParserList {
	s.UtcModified = &v
	return s
}

type ListParserResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListParserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListParserResponse) String() string {
	return tea.Prettify(s)
}

func (s ListParserResponse) GoString() string {
	return s.String()
}

func (s *ListParserResponse) SetHeaders(v map[string]*string) *ListParserResponse {
	s.Headers = v
	return s
}

func (s *ListParserResponse) SetStatusCode(v int32) *ListParserResponse {
	s.StatusCode = &v
	return s
}

func (s *ListParserResponse) SetBody(v *ListParserResponseBody) *ListParserResponse {
	s.Body = v
	return s
}

type ListParserDataSourceRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Page          *int32  `json:"Page,omitempty" xml:"Page,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SearchName    *string `json:"SearchName,omitempty" xml:"SearchName,omitempty"`
}

func (s ListParserDataSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s ListParserDataSourceRequest) GoString() string {
	return s.String()
}

func (s *ListParserDataSourceRequest) SetIotInstanceId(v string) *ListParserDataSourceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListParserDataSourceRequest) SetPage(v int32) *ListParserDataSourceRequest {
	s.Page = &v
	return s
}

func (s *ListParserDataSourceRequest) SetPageSize(v int32) *ListParserDataSourceRequest {
	s.PageSize = &v
	return s
}

func (s *ListParserDataSourceRequest) SetSearchName(v string) *ListParserDataSourceRequest {
	s.SearchName = &v
	return s
}

type ListParserDataSourceResponseBody struct {
	Code         *string                               `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *ListParserDataSourceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                               `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	Page         *int32                                `json:"Page,omitempty" xml:"Page,omitempty"`
	PageSize     *int32                                `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RequestId    *string                               `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                 `json:"Success,omitempty" xml:"Success,omitempty"`
	Total        *int32                                `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListParserDataSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListParserDataSourceResponseBody) GoString() string {
	return s.String()
}

func (s *ListParserDataSourceResponseBody) SetCode(v string) *ListParserDataSourceResponseBody {
	s.Code = &v
	return s
}

func (s *ListParserDataSourceResponseBody) SetData(v *ListParserDataSourceResponseBodyData) *ListParserDataSourceResponseBody {
	s.Data = v
	return s
}

func (s *ListParserDataSourceResponseBody) SetErrorMessage(v string) *ListParserDataSourceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListParserDataSourceResponseBody) SetPage(v int32) *ListParserDataSourceResponseBody {
	s.Page = &v
	return s
}

func (s *ListParserDataSourceResponseBody) SetPageSize(v int32) *ListParserDataSourceResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListParserDataSourceResponseBody) SetRequestId(v string) *ListParserDataSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListParserDataSourceResponseBody) SetSuccess(v bool) *ListParserDataSourceResponseBody {
	s.Success = &v
	return s
}

func (s *ListParserDataSourceResponseBody) SetTotal(v int32) *ListParserDataSourceResponseBody {
	s.Total = &v
	return s
}

type ListParserDataSourceResponseBodyData struct {
	DataSource []*ListParserDataSourceResponseBodyDataDataSource `json:"DataSource,omitempty" xml:"DataSource,omitempty" type:"Repeated"`
}

func (s ListParserDataSourceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListParserDataSourceResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListParserDataSourceResponseBodyData) SetDataSource(v []*ListParserDataSourceResponseBodyDataDataSource) *ListParserDataSourceResponseBodyData {
	s.DataSource = v
	return s
}

type ListParserDataSourceResponseBodyDataDataSource struct {
	DataSourceId *int64  `json:"DataSourceId,omitempty" xml:"DataSourceId,omitempty"`
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	UtcCreated   *string `json:"UtcCreated,omitempty" xml:"UtcCreated,omitempty"`
}

func (s ListParserDataSourceResponseBodyDataDataSource) String() string {
	return tea.Prettify(s)
}

func (s ListParserDataSourceResponseBodyDataDataSource) GoString() string {
	return s.String()
}

func (s *ListParserDataSourceResponseBodyDataDataSource) SetDataSourceId(v int64) *ListParserDataSourceResponseBodyDataDataSource {
	s.DataSourceId = &v
	return s
}

func (s *ListParserDataSourceResponseBodyDataDataSource) SetDescription(v string) *ListParserDataSourceResponseBodyDataDataSource {
	s.Description = &v
	return s
}

func (s *ListParserDataSourceResponseBodyDataDataSource) SetName(v string) *ListParserDataSourceResponseBodyDataDataSource {
	s.Name = &v
	return s
}

func (s *ListParserDataSourceResponseBodyDataDataSource) SetUtcCreated(v string) *ListParserDataSourceResponseBodyDataDataSource {
	s.UtcCreated = &v
	return s
}

type ListParserDataSourceResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListParserDataSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListParserDataSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s ListParserDataSourceResponse) GoString() string {
	return s.String()
}

func (s *ListParserDataSourceResponse) SetHeaders(v map[string]*string) *ListParserDataSourceResponse {
	s.Headers = v
	return s
}

func (s *ListParserDataSourceResponse) SetStatusCode(v int32) *ListParserDataSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *ListParserDataSourceResponse) SetBody(v *ListParserDataSourceResponseBody) *ListParserDataSourceResponse {
	s.Body = v
	return s
}

type ListParserDestinationRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	IsFailover    *bool   `json:"IsFailover,omitempty" xml:"IsFailover,omitempty"`
	ParserId      *int64  `json:"ParserId,omitempty" xml:"ParserId,omitempty"`
}

func (s ListParserDestinationRequest) String() string {
	return tea.Prettify(s)
}

func (s ListParserDestinationRequest) GoString() string {
	return s.String()
}

func (s *ListParserDestinationRequest) SetIotInstanceId(v string) *ListParserDestinationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListParserDestinationRequest) SetIsFailover(v bool) *ListParserDestinationRequest {
	s.IsFailover = &v
	return s
}

func (s *ListParserDestinationRequest) SetParserId(v int64) *ListParserDestinationRequest {
	s.ParserId = &v
	return s
}

type ListParserDestinationResponseBody struct {
	Code         *string                                `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *ListParserDestinationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                  `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListParserDestinationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListParserDestinationResponseBody) GoString() string {
	return s.String()
}

func (s *ListParserDestinationResponseBody) SetCode(v string) *ListParserDestinationResponseBody {
	s.Code = &v
	return s
}

func (s *ListParserDestinationResponseBody) SetData(v *ListParserDestinationResponseBodyData) *ListParserDestinationResponseBody {
	s.Data = v
	return s
}

func (s *ListParserDestinationResponseBody) SetErrorMessage(v string) *ListParserDestinationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListParserDestinationResponseBody) SetRequestId(v string) *ListParserDestinationResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListParserDestinationResponseBody) SetSuccess(v bool) *ListParserDestinationResponseBody {
	s.Success = &v
	return s
}

type ListParserDestinationResponseBodyData struct {
	Destinations []*ListParserDestinationResponseBodyDataDestinations `json:"destinations,omitempty" xml:"destinations,omitempty" type:"Repeated"`
}

func (s ListParserDestinationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListParserDestinationResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListParserDestinationResponseBodyData) SetDestinations(v []*ListParserDestinationResponseBodyDataDestinations) *ListParserDestinationResponseBodyData {
	s.Destinations = v
	return s
}

type ListParserDestinationResponseBodyDataDestinations struct {
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
	DestinationId *int64  `json:"DestinationId,omitempty" xml:"DestinationId,omitempty"`
	IsFailover    *bool   `json:"IsFailover,omitempty" xml:"IsFailover,omitempty"`
	Name          *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Type          *string `json:"Type,omitempty" xml:"Type,omitempty"`
	UtcCreated    *string `json:"UtcCreated,omitempty" xml:"UtcCreated,omitempty"`
	UtcModified   *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
}

func (s ListParserDestinationResponseBodyDataDestinations) String() string {
	return tea.Prettify(s)
}

func (s ListParserDestinationResponseBodyDataDestinations) GoString() string {
	return s.String()
}

func (s *ListParserDestinationResponseBodyDataDestinations) SetConfiguration(v string) *ListParserDestinationResponseBodyDataDestinations {
	s.Configuration = &v
	return s
}

func (s *ListParserDestinationResponseBodyDataDestinations) SetDestinationId(v int64) *ListParserDestinationResponseBodyDataDestinations {
	s.DestinationId = &v
	return s
}

func (s *ListParserDestinationResponseBodyDataDestinations) SetIsFailover(v bool) *ListParserDestinationResponseBodyDataDestinations {
	s.IsFailover = &v
	return s
}

func (s *ListParserDestinationResponseBodyDataDestinations) SetName(v string) *ListParserDestinationResponseBodyDataDestinations {
	s.Name = &v
	return s
}

func (s *ListParserDestinationResponseBodyDataDestinations) SetType(v string) *ListParserDestinationResponseBodyDataDestinations {
	s.Type = &v
	return s
}

func (s *ListParserDestinationResponseBodyDataDestinations) SetUtcCreated(v string) *ListParserDestinationResponseBodyDataDestinations {
	s.UtcCreated = &v
	return s
}

func (s *ListParserDestinationResponseBodyDataDestinations) SetUtcModified(v string) *ListParserDestinationResponseBodyDataDestinations {
	s.UtcModified = &v
	return s
}

type ListParserDestinationResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListParserDestinationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListParserDestinationResponse) String() string {
	return tea.Prettify(s)
}

func (s ListParserDestinationResponse) GoString() string {
	return s.String()
}

func (s *ListParserDestinationResponse) SetHeaders(v map[string]*string) *ListParserDestinationResponse {
	s.Headers = v
	return s
}

func (s *ListParserDestinationResponse) SetStatusCode(v int32) *ListParserDestinationResponse {
	s.StatusCode = &v
	return s
}

func (s *ListParserDestinationResponse) SetBody(v *ListParserDestinationResponseBody) *ListParserDestinationResponse {
	s.Body = v
	return s
}

type ListProductByTagsRequest struct {
	// The number of the page to return.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	//
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	PageSize   *int32                                `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProductTag []*ListProductByTagsRequestProductTag `json:"ProductTag,omitempty" xml:"ProductTag,omitempty" type:"Repeated"`
}

func (s ListProductByTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListProductByTagsRequest) GoString() string {
	return s.String()
}

func (s *ListProductByTagsRequest) SetCurrentPage(v int32) *ListProductByTagsRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListProductByTagsRequest) SetIotInstanceId(v string) *ListProductByTagsRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListProductByTagsRequest) SetPageSize(v int32) *ListProductByTagsRequest {
	s.PageSize = &v
	return s
}

func (s *ListProductByTagsRequest) SetProductTag(v []*ListProductByTagsRequestProductTag) *ListProductByTagsRequest {
	s.ProductTag = v
	return s
}

type ListProductByTagsRequestProductTag struct {
	// The keys of the product tags.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The values of the product tags.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListProductByTagsRequestProductTag) String() string {
	return tea.Prettify(s)
}

func (s ListProductByTagsRequestProductTag) GoString() string {
	return s.String()
}

func (s *ListProductByTagsRequestProductTag) SetTagKey(v string) *ListProductByTagsRequestProductTag {
	s.TagKey = &v
	return s
}

func (s *ListProductByTagsRequestProductTag) SetTagValue(v string) *ListProductByTagsRequestProductTag {
	s.TagValue = &v
	return s
}

type ListProductByTagsResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The details of the products returned if the call is successful. The details are included in the **ProductInfo** parameter.
	//
	// >  The returned product information is sorted in reverse-chronological order based on the time when the products were created.
	ProductInfos *ListProductByTagsResponseBodyProductInfos `json:"ProductInfos,omitempty" xml:"ProductInfos,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListProductByTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListProductByTagsResponseBody) GoString() string {
	return s.String()
}

func (s *ListProductByTagsResponseBody) SetCode(v string) *ListProductByTagsResponseBody {
	s.Code = &v
	return s
}

func (s *ListProductByTagsResponseBody) SetErrorMessage(v string) *ListProductByTagsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListProductByTagsResponseBody) SetProductInfos(v *ListProductByTagsResponseBodyProductInfos) *ListProductByTagsResponseBody {
	s.ProductInfos = v
	return s
}

func (s *ListProductByTagsResponseBody) SetRequestId(v string) *ListProductByTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListProductByTagsResponseBody) SetSuccess(v bool) *ListProductByTagsResponseBody {
	s.Success = &v
	return s
}

type ListProductByTagsResponseBodyProductInfos struct {
	ProductInfo []*ListProductByTagsResponseBodyProductInfosProductInfo `json:"ProductInfo,omitempty" xml:"ProductInfo,omitempty" type:"Repeated"`
}

func (s ListProductByTagsResponseBodyProductInfos) String() string {
	return tea.Prettify(s)
}

func (s ListProductByTagsResponseBodyProductInfos) GoString() string {
	return s.String()
}

func (s *ListProductByTagsResponseBodyProductInfos) SetProductInfo(v []*ListProductByTagsResponseBodyProductInfosProductInfo) *ListProductByTagsResponseBodyProductInfos {
	s.ProductInfo = v
	return s
}

type ListProductByTagsResponseBodyProductInfosProductInfo struct {
	// The time when the product was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The description of the product.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The node type of the product. Valid values:
	//
	// *   **0**: device. Sub-devices cannot be attached to a device. A device can connect to IoT Platform directly or as a sub-device of a gateway.
	// *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain the topological relationships with sub-devices, and synchronize the topological relationships to IoT Platform.
	NodeType *int32 `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The ProductKey of the product. A ProductKey is a globally unique identifier (GUID) issued by IoT Platform to a new product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The name of the product.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
}

func (s ListProductByTagsResponseBodyProductInfosProductInfo) String() string {
	return tea.Prettify(s)
}

func (s ListProductByTagsResponseBodyProductInfosProductInfo) GoString() string {
	return s.String()
}

func (s *ListProductByTagsResponseBodyProductInfosProductInfo) SetCreateTime(v int64) *ListProductByTagsResponseBodyProductInfosProductInfo {
	s.CreateTime = &v
	return s
}

func (s *ListProductByTagsResponseBodyProductInfosProductInfo) SetDescription(v string) *ListProductByTagsResponseBodyProductInfosProductInfo {
	s.Description = &v
	return s
}

func (s *ListProductByTagsResponseBodyProductInfosProductInfo) SetNodeType(v int32) *ListProductByTagsResponseBodyProductInfosProductInfo {
	s.NodeType = &v
	return s
}

func (s *ListProductByTagsResponseBodyProductInfosProductInfo) SetProductKey(v string) *ListProductByTagsResponseBodyProductInfosProductInfo {
	s.ProductKey = &v
	return s
}

func (s *ListProductByTagsResponseBodyProductInfosProductInfo) SetProductName(v string) *ListProductByTagsResponseBodyProductInfosProductInfo {
	s.ProductName = &v
	return s
}

type ListProductByTagsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListProductByTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListProductByTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListProductByTagsResponse) GoString() string {
	return s.String()
}

func (s *ListProductByTagsResponse) SetHeaders(v map[string]*string) *ListProductByTagsResponse {
	s.Headers = v
	return s
}

func (s *ListProductByTagsResponse) SetStatusCode(v int32) *ListProductByTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListProductByTagsResponse) SetBody(v *ListProductByTagsResponseBody) *ListProductByTagsResponse {
	s.Body = v
	return s
}

type ListProductTagsRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product. A ProductKey is a GUID that is issued by IoT Platform to a product. You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s ListProductTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListProductTagsRequest) GoString() string {
	return s.String()
}

func (s *ListProductTagsRequest) SetIotInstanceId(v string) *ListProductTagsRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListProductTagsRequest) SetProductKey(v string) *ListProductTagsRequest {
	s.ProductKey = &v
	return s
}

type ListProductTagsResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The product tags returned if the call succeeds. For more information, see the parameters that are included in the **ProductTag** parameter.
	Data *ListProductTagsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListProductTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListProductTagsResponseBody) GoString() string {
	return s.String()
}

func (s *ListProductTagsResponseBody) SetCode(v string) *ListProductTagsResponseBody {
	s.Code = &v
	return s
}

func (s *ListProductTagsResponseBody) SetData(v *ListProductTagsResponseBodyData) *ListProductTagsResponseBody {
	s.Data = v
	return s
}

func (s *ListProductTagsResponseBody) SetErrorMessage(v string) *ListProductTagsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListProductTagsResponseBody) SetRequestId(v string) *ListProductTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListProductTagsResponseBody) SetSuccess(v bool) *ListProductTagsResponseBody {
	s.Success = &v
	return s
}

type ListProductTagsResponseBodyData struct {
	ProductTag []*ListProductTagsResponseBodyDataProductTag `json:"ProductTag,omitempty" xml:"ProductTag,omitempty" type:"Repeated"`
}

func (s ListProductTagsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListProductTagsResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListProductTagsResponseBodyData) SetProductTag(v []*ListProductTagsResponseBodyDataProductTag) *ListProductTagsResponseBodyData {
	s.ProductTag = v
	return s
}

type ListProductTagsResponseBodyDataProductTag struct {
	// The key of each tag.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The value of the tag.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s ListProductTagsResponseBodyDataProductTag) String() string {
	return tea.Prettify(s)
}

func (s ListProductTagsResponseBodyDataProductTag) GoString() string {
	return s.String()
}

func (s *ListProductTagsResponseBodyDataProductTag) SetTagKey(v string) *ListProductTagsResponseBodyDataProductTag {
	s.TagKey = &v
	return s
}

func (s *ListProductTagsResponseBodyDataProductTag) SetTagValue(v string) *ListProductTagsResponseBodyDataProductTag {
	s.TagValue = &v
	return s
}

type ListProductTagsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListProductTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListProductTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListProductTagsResponse) GoString() string {
	return s.String()
}

func (s *ListProductTagsResponse) SetHeaders(v map[string]*string) *ListProductTagsResponse {
	s.Headers = v
	return s
}

func (s *ListProductTagsResponse) SetStatusCode(v int32) *ListProductTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListProductTagsResponse) SetBody(v *ListProductTagsResponseBody) *ListProductTagsResponse {
	s.Body = v
	return s
}

type ListRuleRequest struct {
	// The number of the page to return. Maximum value: 1000. Default value: 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 100. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group to which the rule belongs. You can log on to the [Resource Management](https://resourcemanager.console.aliyun.com/resource-groups) console to view the details of the resource group.
	//
	// >You can configure this parameter only if you have activated Resource Management.
	//
	// If you do not configure this parameter, all rules of the Alibaba Cloud account are queried.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s ListRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s ListRuleRequest) GoString() string {
	return s.String()
}

func (s *ListRuleRequest) SetCurrentPage(v int32) *ListRuleRequest {
	s.CurrentPage = &v
	return s
}

func (s *ListRuleRequest) SetIotInstanceId(v string) *ListRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListRuleRequest) SetPageSize(v int32) *ListRuleRequest {
	s.PageSize = &v
	return s
}

func (s *ListRuleRequest) SetResourceGroupId(v string) *ListRuleRequest {
	s.ResourceGroupId = &v
	return s
}

type ListRuleResponseBody struct {
	// The error code that is returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The rules returned if the call is successful. For more information, see the "**RuleInfo**" section of this topic.
	//
	// >  The returned rules are sorted in reverse-chronological order based on the time when the rules were created.
	Data *ListRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message that is returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The page number of the returned page.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of pages returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s ListRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListRuleResponseBody) GoString() string {
	return s.String()
}

func (s *ListRuleResponseBody) SetCode(v string) *ListRuleResponseBody {
	s.Code = &v
	return s
}

func (s *ListRuleResponseBody) SetData(v *ListRuleResponseBodyData) *ListRuleResponseBody {
	s.Data = v
	return s
}

func (s *ListRuleResponseBody) SetErrorMessage(v string) *ListRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListRuleResponseBody) SetPage(v int32) *ListRuleResponseBody {
	s.Page = &v
	return s
}

func (s *ListRuleResponseBody) SetPageSize(v int32) *ListRuleResponseBody {
	s.PageSize = &v
	return s
}

func (s *ListRuleResponseBody) SetRequestId(v string) *ListRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListRuleResponseBody) SetSuccess(v bool) *ListRuleResponseBody {
	s.Success = &v
	return s
}

func (s *ListRuleResponseBody) SetTotal(v int32) *ListRuleResponseBody {
	s.Total = &v
	return s
}

type ListRuleResponseBodyData struct {
	RuleInfo []*ListRuleResponseBodyDataRuleInfo `json:"RuleInfo,omitempty" xml:"RuleInfo,omitempty" type:"Repeated"`
}

func (s ListRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListRuleResponseBodyData) SetRuleInfo(v []*ListRuleResponseBodyDataRuleInfo) *ListRuleResponseBodyData {
	s.RuleInfo = v
	return s
}

type ListRuleResponseBodyDataRuleInfo struct {
	// The ID of the user who created the rule.
	CreateUserId *int64 `json:"CreateUserId,omitempty" xml:"CreateUserId,omitempty"`
	// The time when the rule was created. The time is displayed in UTC-6.
	Created *string `json:"Created,omitempty" xml:"Created,omitempty"`
	// The data type of the rule. Valid values: **JSON** and **BINARY**.
	DataType *string `json:"DataType,omitempty" xml:"DataType,omitempty"`
	// The ID of the rule.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The time when the rule was last modified. The time is displayed in UTC-6.
	Modified *string `json:"Modified,omitempty" xml:"Modified,omitempty"`
	// The name of the rule.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The **ProductKey** of the product to which the rule applies.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The description of the rule.
	RuleDesc *string `json:"RuleDesc,omitempty" xml:"RuleDesc,omitempty"`
	// The content that follows the **Select** keyword in the SQL statement of the rule.
	Select *string `json:"Select,omitempty" xml:"Select,omitempty"`
	// The topic to which the rule applies. The topic does not include the ProductKey level. Format: `${deviceName}/topicShortName`. ${deviceName} indicates the name of the device, and topicShortName indicates the custom name of the topic.
	//
	// >  For information about how to use a plus sign (`+`) or a number sign (`#`) as a wildcard character in a topic, see [Topic wildcards](~~73731~~).
	ShortTopic *string `json:"ShortTopic,omitempty" xml:"ShortTopic,omitempty"`
	// The status of the rule. Valid values:
	//
	// *   **RUNNING**: The rule is running.
	// *   **STOP**: The rule is disabled.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The topic to which the rule applies. Format: `${productKey}/${deviceName}/topicShortName`.
	//
	// >  For information about how to use a plus sign (`+`) or a number sign (`#`) as a wildcard character in a topic, see [Topic wildcards](~~73731~~).
	Topic *string `json:"Topic,omitempty" xml:"Topic,omitempty"`
	// The time when the device was created. The time is displayed in UTC.
	UtcCreated *string `json:"UtcCreated,omitempty" xml:"UtcCreated,omitempty"`
	// The time when the rule was last modified.
	UtcModified *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
	// The **Where** query condition in the SQL statement of the rule.
	Where *string `json:"Where,omitempty" xml:"Where,omitempty"`
}

func (s ListRuleResponseBodyDataRuleInfo) String() string {
	return tea.Prettify(s)
}

func (s ListRuleResponseBodyDataRuleInfo) GoString() string {
	return s.String()
}

func (s *ListRuleResponseBodyDataRuleInfo) SetCreateUserId(v int64) *ListRuleResponseBodyDataRuleInfo {
	s.CreateUserId = &v
	return s
}

func (s *ListRuleResponseBodyDataRuleInfo) SetCreated(v string) *ListRuleResponseBodyDataRuleInfo {
	s.Created = &v
	return s
}

func (s *ListRuleResponseBodyDataRuleInfo) SetDataType(v string) *ListRuleResponseBodyDataRuleInfo {
	s.DataType = &v
	return s
}

func (s *ListRuleResponseBodyDataRuleInfo) SetId(v int64) *ListRuleResponseBodyDataRuleInfo {
	s.Id = &v
	return s
}

func (s *ListRuleResponseBodyDataRuleInfo) SetModified(v string) *ListRuleResponseBodyDataRuleInfo {
	s.Modified = &v
	return s
}

func (s *ListRuleResponseBodyDataRuleInfo) SetName(v string) *ListRuleResponseBodyDataRuleInfo {
	s.Name = &v
	return s
}

func (s *ListRuleResponseBodyDataRuleInfo) SetProductKey(v string) *ListRuleResponseBodyDataRuleInfo {
	s.ProductKey = &v
	return s
}

func (s *ListRuleResponseBodyDataRuleInfo) SetRuleDesc(v string) *ListRuleResponseBodyDataRuleInfo {
	s.RuleDesc = &v
	return s
}

func (s *ListRuleResponseBodyDataRuleInfo) SetSelect(v string) *ListRuleResponseBodyDataRuleInfo {
	s.Select = &v
	return s
}

func (s *ListRuleResponseBodyDataRuleInfo) SetShortTopic(v string) *ListRuleResponseBodyDataRuleInfo {
	s.ShortTopic = &v
	return s
}

func (s *ListRuleResponseBodyDataRuleInfo) SetStatus(v string) *ListRuleResponseBodyDataRuleInfo {
	s.Status = &v
	return s
}

func (s *ListRuleResponseBodyDataRuleInfo) SetTopic(v string) *ListRuleResponseBodyDataRuleInfo {
	s.Topic = &v
	return s
}

func (s *ListRuleResponseBodyDataRuleInfo) SetUtcCreated(v string) *ListRuleResponseBodyDataRuleInfo {
	s.UtcCreated = &v
	return s
}

func (s *ListRuleResponseBodyDataRuleInfo) SetUtcModified(v string) *ListRuleResponseBodyDataRuleInfo {
	s.UtcModified = &v
	return s
}

func (s *ListRuleResponseBodyDataRuleInfo) SetWhere(v string) *ListRuleResponseBodyDataRuleInfo {
	s.Where = &v
	return s
}

type ListRuleResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s ListRuleResponse) GoString() string {
	return s.String()
}

func (s *ListRuleResponse) SetHeaders(v map[string]*string) *ListRuleResponse {
	s.Headers = v
	return s
}

func (s *ListRuleResponse) SetStatusCode(v int32) *ListRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *ListRuleResponse) SetBody(v *ListRuleResponseBody) *ListRuleResponse {
	s.Body = v
	return s
}

type ListRuleActionsRequest struct {
	// The ID of the instance. On the **Overview** page in the IoT Platform console, you can view the **ID** of the instance.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If the **Overview** page or instance ID is not displayed in the IoT Platform console, you do not need to configure this parameter.
	//
	// For more information about the instance, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the rule.
	//
	// You can log on to the IoT Platform console and go to the details page of the instance that you want to manage. On the instance details page, choose **Rules Engine** > **Data Forwarding** to obtain the rule ID. Alternatively, you can call the [ListRule](~~69486~~) operation to view the value of the **Id** parameter in the response.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s ListRuleActionsRequest) String() string {
	return tea.Prettify(s)
}

func (s ListRuleActionsRequest) GoString() string {
	return s.String()
}

func (s *ListRuleActionsRequest) SetIotInstanceId(v string) *ListRuleActionsRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListRuleActionsRequest) SetRuleId(v int64) *ListRuleActionsRequest {
	s.RuleId = &v
	return s
}

type ListRuleActionsResponseBody struct {
	// The error code returned if the call fails. For more information about error codes, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// If the call is successful, all configured data forwarding actions of the specified rule are returned. For more information about the returned data, see the following **RuleActionInfo** parameter.
	RuleActionList *ListRuleActionsResponseBodyRuleActionList `json:"RuleActionList,omitempty" xml:"RuleActionList,omitempty" type:"Struct"`
	// Indicates whether the call was successful.
	//
	// - **true**: The call was successful.
	// - **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListRuleActionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListRuleActionsResponseBody) GoString() string {
	return s.String()
}

func (s *ListRuleActionsResponseBody) SetCode(v string) *ListRuleActionsResponseBody {
	s.Code = &v
	return s
}

func (s *ListRuleActionsResponseBody) SetErrorMessage(v string) *ListRuleActionsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListRuleActionsResponseBody) SetRequestId(v string) *ListRuleActionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListRuleActionsResponseBody) SetRuleActionList(v *ListRuleActionsResponseBodyRuleActionList) *ListRuleActionsResponseBody {
	s.RuleActionList = v
	return s
}

func (s *ListRuleActionsResponseBody) SetSuccess(v bool) *ListRuleActionsResponseBody {
	s.Success = &v
	return s
}

type ListRuleActionsResponseBodyRuleActionList struct {
	RuleActionInfo []*ListRuleActionsResponseBodyRuleActionListRuleActionInfo `json:"RuleActionInfo,omitempty" xml:"RuleActionInfo,omitempty" type:"Repeated"`
}

func (s ListRuleActionsResponseBodyRuleActionList) String() string {
	return tea.Prettify(s)
}

func (s ListRuleActionsResponseBodyRuleActionList) GoString() string {
	return s.String()
}

func (s *ListRuleActionsResponseBodyRuleActionList) SetRuleActionInfo(v []*ListRuleActionsResponseBodyRuleActionListRuleActionInfo) *ListRuleActionsResponseBodyRuleActionList {
	s.RuleActionInfo = v
	return s
}

type ListRuleActionsResponseBodyRuleActionListRuleActionInfo struct {
	// The configurations of the data destination.
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
	// Indicates whether the data destination is used to receive the error operation data. The error operation data is data that failed to be forwarded two consecutive times.
	//
	// *   **true**: This destination is used to receive error operation data.
	// *   **false**: This destination is not used to receive error operation data.
	ErrorActionFlag *bool `json:"ErrorActionFlag,omitempty" xml:"ErrorActionFlag,omitempty"`
	// The ID of the action in which data is forwarded to the destination.
	Id *int64 `json:"Id,omitempty" xml:"Id,omitempty"`
	// The ID of the rule based on which data is forwarded to the destination.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The status of the data forwarding action. Valid values:
	//
	// *   **INIT**: The action is being configured.
	// *   **NORMAL**: The configuration is complete, and the action can run properly.
	// *   **INVALID**: The configuration data is invalid, and the action fails to run.
	// *   **SHORTCUT**: An exception occurs and the data forwarding action is stopped.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the action in which data is forwarded to a destination. Valid values:
	//
	// *   **REPUBLISH**: Data is forwarded to a topic.
	// *   **OTS**: Data is stored in Tablestore.
	// *   **MNS**: Data is forwarded to Message Service (MNS).
	// *   **ONS**: Data is forwarded to Message Queue for Apache RocketMQ.
	// *   **TSDB**: Data is stored in Time Series Database.
	// *   **FC**: Data is forwarded to Function Compute.
	// *   **RDS**: Data is forwarded to ApsaraDB RDS.
	// *   **AMQP**: Data is forwarded to an Advanced Message Queuing Protocol (AMQP) consumer group.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s ListRuleActionsResponseBodyRuleActionListRuleActionInfo) String() string {
	return tea.Prettify(s)
}

func (s ListRuleActionsResponseBodyRuleActionListRuleActionInfo) GoString() string {
	return s.String()
}

func (s *ListRuleActionsResponseBodyRuleActionListRuleActionInfo) SetConfiguration(v string) *ListRuleActionsResponseBodyRuleActionListRuleActionInfo {
	s.Configuration = &v
	return s
}

func (s *ListRuleActionsResponseBodyRuleActionListRuleActionInfo) SetErrorActionFlag(v bool) *ListRuleActionsResponseBodyRuleActionListRuleActionInfo {
	s.ErrorActionFlag = &v
	return s
}

func (s *ListRuleActionsResponseBodyRuleActionListRuleActionInfo) SetId(v int64) *ListRuleActionsResponseBodyRuleActionListRuleActionInfo {
	s.Id = &v
	return s
}

func (s *ListRuleActionsResponseBodyRuleActionListRuleActionInfo) SetRuleId(v int64) *ListRuleActionsResponseBodyRuleActionListRuleActionInfo {
	s.RuleId = &v
	return s
}

func (s *ListRuleActionsResponseBodyRuleActionListRuleActionInfo) SetStatus(v string) *ListRuleActionsResponseBodyRuleActionListRuleActionInfo {
	s.Status = &v
	return s
}

func (s *ListRuleActionsResponseBodyRuleActionListRuleActionInfo) SetType(v string) *ListRuleActionsResponseBodyRuleActionListRuleActionInfo {
	s.Type = &v
	return s
}

type ListRuleActionsResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListRuleActionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListRuleActionsResponse) String() string {
	return tea.Prettify(s)
}

func (s ListRuleActionsResponse) GoString() string {
	return s.String()
}

func (s *ListRuleActionsResponse) SetHeaders(v map[string]*string) *ListRuleActionsResponse {
	s.Headers = v
	return s
}

func (s *ListRuleActionsResponse) SetStatusCode(v int32) *ListRuleActionsResponse {
	s.StatusCode = &v
	return s
}

func (s *ListRuleActionsResponse) SetBody(v *ListRuleActionsResponseBody) *ListRuleActionsResponse {
	s.Body = v
	return s
}

type ListTaskRequest struct {
	Device        map[string]interface{} `json:"Device,omitempty" xml:"Device,omitempty"`
	IotInstanceId *string                `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	JobId         *string                `json:"JobId,omitempty" xml:"JobId,omitempty"`
	Limit         *int32                 `json:"Limit,omitempty" xml:"Limit,omitempty"`
	NextToken     *string                `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	Status        *string                `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTaskRequest) GoString() string {
	return s.String()
}

func (s *ListTaskRequest) SetDevice(v map[string]interface{}) *ListTaskRequest {
	s.Device = v
	return s
}

func (s *ListTaskRequest) SetIotInstanceId(v string) *ListTaskRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListTaskRequest) SetJobId(v string) *ListTaskRequest {
	s.JobId = &v
	return s
}

func (s *ListTaskRequest) SetLimit(v int32) *ListTaskRequest {
	s.Limit = &v
	return s
}

func (s *ListTaskRequest) SetNextToken(v string) *ListTaskRequest {
	s.NextToken = &v
	return s
}

func (s *ListTaskRequest) SetStatus(v string) *ListTaskRequest {
	s.Status = &v
	return s
}

type ListTaskShrinkRequest struct {
	DeviceShrink  *string `json:"Device,omitempty" xml:"Device,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	JobId         *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	Limit         *int32  `json:"Limit,omitempty" xml:"Limit,omitempty"`
	NextToken     *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	Status        *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s ListTaskShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s ListTaskShrinkRequest) GoString() string {
	return s.String()
}

func (s *ListTaskShrinkRequest) SetDeviceShrink(v string) *ListTaskShrinkRequest {
	s.DeviceShrink = &v
	return s
}

func (s *ListTaskShrinkRequest) SetIotInstanceId(v string) *ListTaskShrinkRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListTaskShrinkRequest) SetJobId(v string) *ListTaskShrinkRequest {
	s.JobId = &v
	return s
}

func (s *ListTaskShrinkRequest) SetLimit(v int32) *ListTaskShrinkRequest {
	s.Limit = &v
	return s
}

func (s *ListTaskShrinkRequest) SetNextToken(v string) *ListTaskShrinkRequest {
	s.NextToken = &v
	return s
}

func (s *ListTaskShrinkRequest) SetStatus(v string) *ListTaskShrinkRequest {
	s.Status = &v
	return s
}

type ListTaskResponseBody struct {
	Code         *string                   `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *ListTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                   `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	NextToken    *string                   `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	RequestId    *string                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                     `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListTaskResponseBody) GoString() string {
	return s.String()
}

func (s *ListTaskResponseBody) SetCode(v string) *ListTaskResponseBody {
	s.Code = &v
	return s
}

func (s *ListTaskResponseBody) SetData(v *ListTaskResponseBodyData) *ListTaskResponseBody {
	s.Data = v
	return s
}

func (s *ListTaskResponseBody) SetErrorMessage(v string) *ListTaskResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListTaskResponseBody) SetNextToken(v string) *ListTaskResponseBody {
	s.NextToken = &v
	return s
}

func (s *ListTaskResponseBody) SetRequestId(v string) *ListTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListTaskResponseBody) SetSuccess(v bool) *ListTaskResponseBody {
	s.Success = &v
	return s
}

type ListTaskResponseBodyData struct {
	Data []*ListTaskResponseBodyDataData `json:"data,omitempty" xml:"data,omitempty" type:"Repeated"`
}

func (s ListTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListTaskResponseBodyData) SetData(v []*ListTaskResponseBodyDataData) *ListTaskResponseBodyData {
	s.Data = v
	return s
}

type ListTaskResponseBodyDataData struct {
	DeviceName   *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotId        *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	JobId        *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	JobName      *string `json:"JobName,omitempty" xml:"JobName,omitempty"`
	ProductKey   *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	Progress     *string `json:"Progress,omitempty" xml:"Progress,omitempty"`
	Status       *string `json:"Status,omitempty" xml:"Status,omitempty"`
	TaskId       *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	UtcModified  *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
	UtcQueueTime *string `json:"UtcQueueTime,omitempty" xml:"UtcQueueTime,omitempty"`
}

func (s ListTaskResponseBodyDataData) String() string {
	return tea.Prettify(s)
}

func (s ListTaskResponseBodyDataData) GoString() string {
	return s.String()
}

func (s *ListTaskResponseBodyDataData) SetDeviceName(v string) *ListTaskResponseBodyDataData {
	s.DeviceName = &v
	return s
}

func (s *ListTaskResponseBodyDataData) SetIotId(v string) *ListTaskResponseBodyDataData {
	s.IotId = &v
	return s
}

func (s *ListTaskResponseBodyDataData) SetJobId(v string) *ListTaskResponseBodyDataData {
	s.JobId = &v
	return s
}

func (s *ListTaskResponseBodyDataData) SetJobName(v string) *ListTaskResponseBodyDataData {
	s.JobName = &v
	return s
}

func (s *ListTaskResponseBodyDataData) SetProductKey(v string) *ListTaskResponseBodyDataData {
	s.ProductKey = &v
	return s
}

func (s *ListTaskResponseBodyDataData) SetProgress(v string) *ListTaskResponseBodyDataData {
	s.Progress = &v
	return s
}

func (s *ListTaskResponseBodyDataData) SetStatus(v string) *ListTaskResponseBodyDataData {
	s.Status = &v
	return s
}

func (s *ListTaskResponseBodyDataData) SetTaskId(v string) *ListTaskResponseBodyDataData {
	s.TaskId = &v
	return s
}

func (s *ListTaskResponseBodyDataData) SetUtcModified(v string) *ListTaskResponseBodyDataData {
	s.UtcModified = &v
	return s
}

func (s *ListTaskResponseBodyDataData) SetUtcQueueTime(v string) *ListTaskResponseBodyDataData {
	s.UtcQueueTime = &v
	return s
}

type ListTaskResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s ListTaskResponse) GoString() string {
	return s.String()
}

func (s *ListTaskResponse) SetHeaders(v map[string]*string) *ListTaskResponse {
	s.Headers = v
	return s
}

func (s *ListTaskResponse) SetStatusCode(v int32) *ListTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *ListTaskResponse) SetBody(v *ListTaskResponseBody) *ListTaskResponse {
	s.Body = v
	return s
}

type ListThingModelVersionRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product.
	//
	// You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s ListThingModelVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s ListThingModelVersionRequest) GoString() string {
	return s.String()
}

func (s *ListThingModelVersionRequest) SetIotInstanceId(v string) *ListThingModelVersionRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ListThingModelVersionRequest) SetProductKey(v string) *ListThingModelVersionRequest {
	s.ProductKey = &v
	return s
}

type ListThingModelVersionResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call is successful.
	Data *ListThingModelVersionResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListThingModelVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListThingModelVersionResponseBody) GoString() string {
	return s.String()
}

func (s *ListThingModelVersionResponseBody) SetCode(v string) *ListThingModelVersionResponseBody {
	s.Code = &v
	return s
}

func (s *ListThingModelVersionResponseBody) SetData(v *ListThingModelVersionResponseBodyData) *ListThingModelVersionResponseBody {
	s.Data = v
	return s
}

func (s *ListThingModelVersionResponseBody) SetErrorMessage(v string) *ListThingModelVersionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListThingModelVersionResponseBody) SetRequestId(v string) *ListThingModelVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListThingModelVersionResponseBody) SetSuccess(v bool) *ListThingModelVersionResponseBody {
	s.Success = &v
	return s
}

type ListThingModelVersionResponseBodyData struct {
	// The list of TSL model versions. The versions are displayed in descending order based on the release time. The first version is the current version.
	ModelVersions []*ListThingModelVersionResponseBodyDataModelVersions `json:"ModelVersions,omitempty" xml:"ModelVersions,omitempty" type:"Repeated"`
}

func (s ListThingModelVersionResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListThingModelVersionResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListThingModelVersionResponseBodyData) SetModelVersions(v []*ListThingModelVersionResponseBodyDataModelVersions) *ListThingModelVersionResponseBodyData {
	s.ModelVersions = v
	return s
}

type ListThingModelVersionResponseBodyDataModelVersions struct {
	// The description of the TSL model version.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The timestamp when the TSL model version was published. The time is displayed in UTC. Unit: milliseconds.
	GmtCreate *int64 `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The version number of the TSL model.
	ModelVersion *string `json:"ModelVersion,omitempty" xml:"ModelVersion,omitempty"`
}

func (s ListThingModelVersionResponseBodyDataModelVersions) String() string {
	return tea.Prettify(s)
}

func (s ListThingModelVersionResponseBodyDataModelVersions) GoString() string {
	return s.String()
}

func (s *ListThingModelVersionResponseBodyDataModelVersions) SetDescription(v string) *ListThingModelVersionResponseBodyDataModelVersions {
	s.Description = &v
	return s
}

func (s *ListThingModelVersionResponseBodyDataModelVersions) SetGmtCreate(v int64) *ListThingModelVersionResponseBodyDataModelVersions {
	s.GmtCreate = &v
	return s
}

func (s *ListThingModelVersionResponseBodyDataModelVersions) SetModelVersion(v string) *ListThingModelVersionResponseBodyDataModelVersions {
	s.ModelVersion = &v
	return s
}

type ListThingModelVersionResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListThingModelVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListThingModelVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s ListThingModelVersionResponse) GoString() string {
	return s.String()
}

func (s *ListThingModelVersionResponse) SetHeaders(v map[string]*string) *ListThingModelVersionResponse {
	s.Headers = v
	return s
}

func (s *ListThingModelVersionResponse) SetStatusCode(v int32) *ListThingModelVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *ListThingModelVersionResponse) SetBody(v *ListThingModelVersionResponseBody) *ListThingModelVersionResponse {
	s.Body = v
	return s
}

type ListThingTemplatesRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s ListThingTemplatesRequest) String() string {
	return tea.Prettify(s)
}

func (s ListThingTemplatesRequest) GoString() string {
	return s.String()
}

func (s *ListThingTemplatesRequest) SetIotInstanceId(v string) *ListThingTemplatesRequest {
	s.IotInstanceId = &v
	return s
}

type ListThingTemplatesResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The list of standard categories returned if the call is successful.
	Data []*ListThingTemplatesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ListThingTemplatesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ListThingTemplatesResponseBody) GoString() string {
	return s.String()
}

func (s *ListThingTemplatesResponseBody) SetCode(v string) *ListThingTemplatesResponseBody {
	s.Code = &v
	return s
}

func (s *ListThingTemplatesResponseBody) SetData(v []*ListThingTemplatesResponseBodyData) *ListThingTemplatesResponseBody {
	s.Data = v
	return s
}

func (s *ListThingTemplatesResponseBody) SetErrorMessage(v string) *ListThingTemplatesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ListThingTemplatesResponseBody) SetRequestId(v string) *ListThingTemplatesResponseBody {
	s.RequestId = &v
	return s
}

func (s *ListThingTemplatesResponseBody) SetSuccess(v bool) *ListThingTemplatesResponseBody {
	s.Success = &v
	return s
}

type ListThingTemplatesResponseBodyData struct {
	// The identifier of the category.
	CategoryKey *string `json:"CategoryKey,omitempty" xml:"CategoryKey,omitempty"`
	// The name of the category.
	CategoryName *string `json:"CategoryName,omitempty" xml:"CategoryName,omitempty"`
}

func (s ListThingTemplatesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ListThingTemplatesResponseBodyData) GoString() string {
	return s.String()
}

func (s *ListThingTemplatesResponseBodyData) SetCategoryKey(v string) *ListThingTemplatesResponseBodyData {
	s.CategoryKey = &v
	return s
}

func (s *ListThingTemplatesResponseBodyData) SetCategoryName(v string) *ListThingTemplatesResponseBodyData {
	s.CategoryName = &v
	return s
}

type ListThingTemplatesResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ListThingTemplatesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ListThingTemplatesResponse) String() string {
	return tea.Prettify(s)
}

func (s ListThingTemplatesResponse) GoString() string {
	return s.String()
}

func (s *ListThingTemplatesResponse) SetHeaders(v map[string]*string) *ListThingTemplatesResponse {
	s.Headers = v
	return s
}

func (s *ListThingTemplatesResponse) SetStatusCode(v int32) *ListThingTemplatesResponse {
	s.StatusCode = &v
	return s
}

func (s *ListThingTemplatesResponse) SetBody(v *ListThingTemplatesResponseBody) *ListThingTemplatesResponse {
	s.Body = v
	return s
}

type ModifyOTAFirmwareRequest struct {
	FirmwareDesc  *string `json:"FirmwareDesc,omitempty" xml:"FirmwareDesc,omitempty"`
	FirmwareId    *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	FirmwareName  *string `json:"FirmwareName,omitempty" xml:"FirmwareName,omitempty"`
	FirmwareUdi   *string `json:"FirmwareUdi,omitempty" xml:"FirmwareUdi,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s ModifyOTAFirmwareRequest) String() string {
	return tea.Prettify(s)
}

func (s ModifyOTAFirmwareRequest) GoString() string {
	return s.String()
}

func (s *ModifyOTAFirmwareRequest) SetFirmwareDesc(v string) *ModifyOTAFirmwareRequest {
	s.FirmwareDesc = &v
	return s
}

func (s *ModifyOTAFirmwareRequest) SetFirmwareId(v string) *ModifyOTAFirmwareRequest {
	s.FirmwareId = &v
	return s
}

func (s *ModifyOTAFirmwareRequest) SetFirmwareName(v string) *ModifyOTAFirmwareRequest {
	s.FirmwareName = &v
	return s
}

func (s *ModifyOTAFirmwareRequest) SetFirmwareUdi(v string) *ModifyOTAFirmwareRequest {
	s.FirmwareUdi = &v
	return s
}

func (s *ModifyOTAFirmwareRequest) SetIotInstanceId(v string) *ModifyOTAFirmwareRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ModifyOTAFirmwareRequest) SetProductKey(v string) *ModifyOTAFirmwareRequest {
	s.ProductKey = &v
	return s
}

type ModifyOTAFirmwareResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ModifyOTAFirmwareResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ModifyOTAFirmwareResponseBody) GoString() string {
	return s.String()
}

func (s *ModifyOTAFirmwareResponseBody) SetCode(v string) *ModifyOTAFirmwareResponseBody {
	s.Code = &v
	return s
}

func (s *ModifyOTAFirmwareResponseBody) SetErrorMessage(v string) *ModifyOTAFirmwareResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ModifyOTAFirmwareResponseBody) SetRequestId(v string) *ModifyOTAFirmwareResponseBody {
	s.RequestId = &v
	return s
}

func (s *ModifyOTAFirmwareResponseBody) SetSuccess(v bool) *ModifyOTAFirmwareResponseBody {
	s.Success = &v
	return s
}

type ModifyOTAFirmwareResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ModifyOTAFirmwareResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ModifyOTAFirmwareResponse) String() string {
	return tea.Prettify(s)
}

func (s ModifyOTAFirmwareResponse) GoString() string {
	return s.String()
}

func (s *ModifyOTAFirmwareResponse) SetHeaders(v map[string]*string) *ModifyOTAFirmwareResponse {
	s.Headers = v
	return s
}

func (s *ModifyOTAFirmwareResponse) SetStatusCode(v int32) *ModifyOTAFirmwareResponse {
	s.StatusCode = &v
	return s
}

func (s *ModifyOTAFirmwareResponse) SetBody(v *ModifyOTAFirmwareResponseBody) *ModifyOTAFirmwareResponse {
	s.Body = v
	return s
}

type NotifyAddThingTopoRequest struct {
	// A JSON array of the sub-device identity information. You can use a combination of **ProductKey** and **DeviceName** or only **IotId** to specify a device, such as **\[{"productKey":"a1BwAGxxx","deviceName":"device1"},{"IotId":"Q7uOhxxx"}]**.
	DeviceListStr *string `json:"DeviceListStr,omitempty" xml:"DeviceListStr,omitempty"`
	// The DeviceName of the gateway.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	GwDeviceName *string `json:"GwDeviceName,omitempty" xml:"GwDeviceName,omitempty"`
	// The ID of the gateway device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
	GwIotId *string `json:"GwIotId,omitempty" xml:"GwIotId,omitempty"`
	// The ProductKey of the product to which the gateway belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	GwProductKey *string `json:"GwProductKey,omitempty" xml:"GwProductKey,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s NotifyAddThingTopoRequest) String() string {
	return tea.Prettify(s)
}

func (s NotifyAddThingTopoRequest) GoString() string {
	return s.String()
}

func (s *NotifyAddThingTopoRequest) SetDeviceListStr(v string) *NotifyAddThingTopoRequest {
	s.DeviceListStr = &v
	return s
}

func (s *NotifyAddThingTopoRequest) SetGwDeviceName(v string) *NotifyAddThingTopoRequest {
	s.GwDeviceName = &v
	return s
}

func (s *NotifyAddThingTopoRequest) SetGwIotId(v string) *NotifyAddThingTopoRequest {
	s.GwIotId = &v
	return s
}

func (s *NotifyAddThingTopoRequest) SetGwProductKey(v string) *NotifyAddThingTopoRequest {
	s.GwProductKey = &v
	return s
}

func (s *NotifyAddThingTopoRequest) SetIotInstanceId(v string) *NotifyAddThingTopoRequest {
	s.IotInstanceId = &v
	return s
}

type NotifyAddThingTopoResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call is successful.
	Data *NotifyAddThingTopoResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s NotifyAddThingTopoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s NotifyAddThingTopoResponseBody) GoString() string {
	return s.String()
}

func (s *NotifyAddThingTopoResponseBody) SetCode(v string) *NotifyAddThingTopoResponseBody {
	s.Code = &v
	return s
}

func (s *NotifyAddThingTopoResponseBody) SetData(v *NotifyAddThingTopoResponseBodyData) *NotifyAddThingTopoResponseBody {
	s.Data = v
	return s
}

func (s *NotifyAddThingTopoResponseBody) SetErrorMessage(v string) *NotifyAddThingTopoResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *NotifyAddThingTopoResponseBody) SetRequestId(v string) *NotifyAddThingTopoResponseBody {
	s.RequestId = &v
	return s
}

func (s *NotifyAddThingTopoResponseBody) SetSuccess(v bool) *NotifyAddThingTopoResponseBody {
	s.Success = &v
	return s
}

type NotifyAddThingTopoResponseBodyData struct {
	// The ID of the message that IoT Platform sends to the gateway. The message is used to notify the gateway to add a topology.
	MessageId *string `json:"MessageId,omitempty" xml:"MessageId,omitempty"`
}

func (s NotifyAddThingTopoResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s NotifyAddThingTopoResponseBodyData) GoString() string {
	return s.String()
}

func (s *NotifyAddThingTopoResponseBodyData) SetMessageId(v string) *NotifyAddThingTopoResponseBodyData {
	s.MessageId = &v
	return s
}

type NotifyAddThingTopoResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *NotifyAddThingTopoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s NotifyAddThingTopoResponse) String() string {
	return tea.Prettify(s)
}

func (s NotifyAddThingTopoResponse) GoString() string {
	return s.String()
}

func (s *NotifyAddThingTopoResponse) SetHeaders(v map[string]*string) *NotifyAddThingTopoResponse {
	s.Headers = v
	return s
}

func (s *NotifyAddThingTopoResponse) SetStatusCode(v int32) *NotifyAddThingTopoResponse {
	s.StatusCode = &v
	return s
}

func (s *NotifyAddThingTopoResponse) SetBody(v *NotifyAddThingTopoResponseBody) *NotifyAddThingTopoResponse {
	s.Body = v
	return s
}

type OpenIotServiceRequest struct {
	OwnerId *int64 `json:"OwnerId,omitempty" xml:"OwnerId,omitempty"`
}

func (s OpenIotServiceRequest) String() string {
	return tea.Prettify(s)
}

func (s OpenIotServiceRequest) GoString() string {
	return s.String()
}

func (s *OpenIotServiceRequest) SetOwnerId(v int64) *OpenIotServiceRequest {
	s.OwnerId = &v
	return s
}

type OpenIotServiceResponseBody struct {
	OrderId   *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
}

func (s OpenIotServiceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s OpenIotServiceResponseBody) GoString() string {
	return s.String()
}

func (s *OpenIotServiceResponseBody) SetOrderId(v string) *OpenIotServiceResponseBody {
	s.OrderId = &v
	return s
}

func (s *OpenIotServiceResponseBody) SetRequestId(v string) *OpenIotServiceResponseBody {
	s.RequestId = &v
	return s
}

type OpenIotServiceResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *OpenIotServiceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s OpenIotServiceResponse) String() string {
	return tea.Prettify(s)
}

func (s OpenIotServiceResponse) GoString() string {
	return s.String()
}

func (s *OpenIotServiceResponse) SetHeaders(v map[string]*string) *OpenIotServiceResponse {
	s.Headers = v
	return s
}

func (s *OpenIotServiceResponse) SetStatusCode(v int32) *OpenIotServiceResponse {
	s.StatusCode = &v
	return s
}

func (s *OpenIotServiceResponse) SetBody(v *OpenIotServiceResponseBody) *OpenIotServiceResponse {
	s.Body = v
	return s
}

type PackageSoundCodeLabelBatchAudioRequest struct {
	BatchCode     *string `json:"BatchCode,omitempty" xml:"BatchCode,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s PackageSoundCodeLabelBatchAudioRequest) String() string {
	return tea.Prettify(s)
}

func (s PackageSoundCodeLabelBatchAudioRequest) GoString() string {
	return s.String()
}

func (s *PackageSoundCodeLabelBatchAudioRequest) SetBatchCode(v string) *PackageSoundCodeLabelBatchAudioRequest {
	s.BatchCode = &v
	return s
}

func (s *PackageSoundCodeLabelBatchAudioRequest) SetIotInstanceId(v string) *PackageSoundCodeLabelBatchAudioRequest {
	s.IotInstanceId = &v
	return s
}

type PackageSoundCodeLabelBatchAudioResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PackageSoundCodeLabelBatchAudioResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PackageSoundCodeLabelBatchAudioResponseBody) GoString() string {
	return s.String()
}

func (s *PackageSoundCodeLabelBatchAudioResponseBody) SetCode(v string) *PackageSoundCodeLabelBatchAudioResponseBody {
	s.Code = &v
	return s
}

func (s *PackageSoundCodeLabelBatchAudioResponseBody) SetData(v string) *PackageSoundCodeLabelBatchAudioResponseBody {
	s.Data = &v
	return s
}

func (s *PackageSoundCodeLabelBatchAudioResponseBody) SetErrorMessage(v string) *PackageSoundCodeLabelBatchAudioResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *PackageSoundCodeLabelBatchAudioResponseBody) SetRequestId(v string) *PackageSoundCodeLabelBatchAudioResponseBody {
	s.RequestId = &v
	return s
}

func (s *PackageSoundCodeLabelBatchAudioResponseBody) SetSuccess(v bool) *PackageSoundCodeLabelBatchAudioResponseBody {
	s.Success = &v
	return s
}

type PackageSoundCodeLabelBatchAudioResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PackageSoundCodeLabelBatchAudioResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PackageSoundCodeLabelBatchAudioResponse) String() string {
	return tea.Prettify(s)
}

func (s PackageSoundCodeLabelBatchAudioResponse) GoString() string {
	return s.String()
}

func (s *PackageSoundCodeLabelBatchAudioResponse) SetHeaders(v map[string]*string) *PackageSoundCodeLabelBatchAudioResponse {
	s.Headers = v
	return s
}

func (s *PackageSoundCodeLabelBatchAudioResponse) SetStatusCode(v int32) *PackageSoundCodeLabelBatchAudioResponse {
	s.StatusCode = &v
	return s
}

func (s *PackageSoundCodeLabelBatchAudioResponse) SetBody(v *PackageSoundCodeLabelBatchAudioResponseBody) *PackageSoundCodeLabelBatchAudioResponse {
	s.Body = v
	return s
}

type PageQuerySharedSpeechOpenRequest struct {
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device.
	//
	// > If you specify this parameter, you do not need to specify **ProductKey** and **DeviceName**. **IotId** specifies the GUID of the device. The value of the IotId parameter is a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
	//
	// For more information, see the [Overview](~~356505~~) topic of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The page number.
	PageId *int32 `json:"PageId,omitempty" xml:"PageId,omitempty"`
	// The number of entries per page. Valid values: 1 to 100.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The code that is used to share the speeches.
	//
	// You can obtain the **code** on the **Shared Corpus Management** page of **Speech Sending Voice Broadcasting Service**.
	ShareTaskCode *string `json:"ShareTaskCode,omitempty" xml:"ShareTaskCode,omitempty"`
	// The status of the speeches that you want to query. Valid values:
	//
	// *   **1**: The speeches are pending approval.
	// *   **2**: The speeches are approved.
	// *   **3**: The speeches are rejected.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s PageQuerySharedSpeechOpenRequest) String() string {
	return tea.Prettify(s)
}

func (s PageQuerySharedSpeechOpenRequest) GoString() string {
	return s.String()
}

func (s *PageQuerySharedSpeechOpenRequest) SetDeviceName(v string) *PageQuerySharedSpeechOpenRequest {
	s.DeviceName = &v
	return s
}

func (s *PageQuerySharedSpeechOpenRequest) SetIotId(v string) *PageQuerySharedSpeechOpenRequest {
	s.IotId = &v
	return s
}

func (s *PageQuerySharedSpeechOpenRequest) SetIotInstanceId(v string) *PageQuerySharedSpeechOpenRequest {
	s.IotInstanceId = &v
	return s
}

func (s *PageQuerySharedSpeechOpenRequest) SetPageId(v int32) *PageQuerySharedSpeechOpenRequest {
	s.PageId = &v
	return s
}

func (s *PageQuerySharedSpeechOpenRequest) SetPageSize(v int32) *PageQuerySharedSpeechOpenRequest {
	s.PageSize = &v
	return s
}

func (s *PageQuerySharedSpeechOpenRequest) SetProductKey(v string) *PageQuerySharedSpeechOpenRequest {
	s.ProductKey = &v
	return s
}

func (s *PageQuerySharedSpeechOpenRequest) SetShareTaskCode(v string) *PageQuerySharedSpeechOpenRequest {
	s.ShareTaskCode = &v
	return s
}

func (s *PageQuerySharedSpeechOpenRequest) SetStatus(v int32) *PageQuerySharedSpeechOpenRequest {
	s.Status = &v
	return s
}

type PageQuerySharedSpeechOpenResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result returned if the request was successful.
	Data *PageQuerySharedSpeechOpenResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PageQuerySharedSpeechOpenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PageQuerySharedSpeechOpenResponseBody) GoString() string {
	return s.String()
}

func (s *PageQuerySharedSpeechOpenResponseBody) SetCode(v string) *PageQuerySharedSpeechOpenResponseBody {
	s.Code = &v
	return s
}

func (s *PageQuerySharedSpeechOpenResponseBody) SetData(v *PageQuerySharedSpeechOpenResponseBodyData) *PageQuerySharedSpeechOpenResponseBody {
	s.Data = v
	return s
}

func (s *PageQuerySharedSpeechOpenResponseBody) SetErrorMessage(v string) *PageQuerySharedSpeechOpenResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *PageQuerySharedSpeechOpenResponseBody) SetRequestId(v string) *PageQuerySharedSpeechOpenResponseBody {
	s.RequestId = &v
	return s
}

func (s *PageQuerySharedSpeechOpenResponseBody) SetSuccess(v bool) *PageQuerySharedSpeechOpenResponseBody {
	s.Success = &v
	return s
}

type PageQuerySharedSpeechOpenResponseBodyData struct {
	// The page number.
	PageId *int32 `json:"PageId,omitempty" xml:"PageId,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The information about shared speeches.
	ResultData *PageQuerySharedSpeechOpenResponseBodyDataResultData `json:"ResultData,omitempty" xml:"ResultData,omitempty" type:"Struct"`
	// The total number of entries returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s PageQuerySharedSpeechOpenResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s PageQuerySharedSpeechOpenResponseBodyData) GoString() string {
	return s.String()
}

func (s *PageQuerySharedSpeechOpenResponseBodyData) SetPageId(v int32) *PageQuerySharedSpeechOpenResponseBodyData {
	s.PageId = &v
	return s
}

func (s *PageQuerySharedSpeechOpenResponseBodyData) SetPageSize(v int32) *PageQuerySharedSpeechOpenResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *PageQuerySharedSpeechOpenResponseBodyData) SetResultData(v *PageQuerySharedSpeechOpenResponseBodyDataResultData) *PageQuerySharedSpeechOpenResponseBodyData {
	s.ResultData = v
	return s
}

func (s *PageQuerySharedSpeechOpenResponseBodyData) SetTotal(v int32) *PageQuerySharedSpeechOpenResponseBodyData {
	s.Total = &v
	return s
}

type PageQuerySharedSpeechOpenResponseBodyDataResultData struct {
	Data []*PageQuerySharedSpeechOpenResponseBodyDataResultDataData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
}

func (s PageQuerySharedSpeechOpenResponseBodyDataResultData) String() string {
	return tea.Prettify(s)
}

func (s PageQuerySharedSpeechOpenResponseBodyDataResultData) GoString() string {
	return s.String()
}

func (s *PageQuerySharedSpeechOpenResponseBodyDataResultData) SetData(v []*PageQuerySharedSpeechOpenResponseBodyDataResultDataData) *PageQuerySharedSpeechOpenResponseBodyDataResultData {
	s.Data = v
	return s
}

type PageQuerySharedSpeechOpenResponseBodyDataResultDataData struct {
	// The audio format. Valid values: **wav**, **mp3**, and **amr**.
	AudioFormat *string `json:"AudioFormat,omitempty" xml:"AudioFormat,omitempty"`
	// The unique identifier of the speech in the project.
	BizCode *string `json:"BizCode,omitempty" xml:"BizCode,omitempty"`
	// The unique identifier of the template.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The broadcasting speed. Valid values: -500 to 500.
	SpeechRate *int32 `json:"SpeechRate,omitempty" xml:"SpeechRate,omitempty"`
	// The status of the speeches. Valid values:
	//
	// *   **1**: The speeches are pending approval.
	// *   **2**: The speeches are approved.
	// *   **3**: The speeches are rejected.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The content of the speech.
	Text *string `json:"Text,omitempty" xml:"Text,omitempty"`
	// The sound effect that is used to broadcast speeches.
	Voice *string `json:"Voice,omitempty" xml:"Voice,omitempty"`
	// The volume. Valid values: 0 to 100.
	Volume *int32 `json:"Volume,omitempty" xml:"Volume,omitempty"`
}

func (s PageQuerySharedSpeechOpenResponseBodyDataResultDataData) String() string {
	return tea.Prettify(s)
}

func (s PageQuerySharedSpeechOpenResponseBodyDataResultDataData) GoString() string {
	return s.String()
}

func (s *PageQuerySharedSpeechOpenResponseBodyDataResultDataData) SetAudioFormat(v string) *PageQuerySharedSpeechOpenResponseBodyDataResultDataData {
	s.AudioFormat = &v
	return s
}

func (s *PageQuerySharedSpeechOpenResponseBodyDataResultDataData) SetBizCode(v string) *PageQuerySharedSpeechOpenResponseBodyDataResultDataData {
	s.BizCode = &v
	return s
}

func (s *PageQuerySharedSpeechOpenResponseBodyDataResultDataData) SetCode(v string) *PageQuerySharedSpeechOpenResponseBodyDataResultDataData {
	s.Code = &v
	return s
}

func (s *PageQuerySharedSpeechOpenResponseBodyDataResultDataData) SetSpeechRate(v int32) *PageQuerySharedSpeechOpenResponseBodyDataResultDataData {
	s.SpeechRate = &v
	return s
}

func (s *PageQuerySharedSpeechOpenResponseBodyDataResultDataData) SetStatus(v int32) *PageQuerySharedSpeechOpenResponseBodyDataResultDataData {
	s.Status = &v
	return s
}

func (s *PageQuerySharedSpeechOpenResponseBodyDataResultDataData) SetText(v string) *PageQuerySharedSpeechOpenResponseBodyDataResultDataData {
	s.Text = &v
	return s
}

func (s *PageQuerySharedSpeechOpenResponseBodyDataResultDataData) SetVoice(v string) *PageQuerySharedSpeechOpenResponseBodyDataResultDataData {
	s.Voice = &v
	return s
}

func (s *PageQuerySharedSpeechOpenResponseBodyDataResultDataData) SetVolume(v int32) *PageQuerySharedSpeechOpenResponseBodyDataResultDataData {
	s.Volume = &v
	return s
}

type PageQuerySharedSpeechOpenResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PageQuerySharedSpeechOpenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PageQuerySharedSpeechOpenResponse) String() string {
	return tea.Prettify(s)
}

func (s PageQuerySharedSpeechOpenResponse) GoString() string {
	return s.String()
}

func (s *PageQuerySharedSpeechOpenResponse) SetHeaders(v map[string]*string) *PageQuerySharedSpeechOpenResponse {
	s.Headers = v
	return s
}

func (s *PageQuerySharedSpeechOpenResponse) SetStatusCode(v int32) *PageQuerySharedSpeechOpenResponse {
	s.StatusCode = &v
	return s
}

func (s *PageQuerySharedSpeechOpenResponse) SetBody(v *PageQuerySharedSpeechOpenResponseBody) *PageQuerySharedSpeechOpenResponse {
	s.Body = v
	return s
}

type PageQuerySpeechBroadcastHourRequest struct {
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
	//
	// For more information, see [Overview](~~356505~~) of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries per page. Default value: 10. Valid values: 1 to 2000.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of **PageToken**.
	//
	// For example, if you want to query the results on Page n, you must set PageToken to the token that you obtained when you queried the results on Page n - 1.
	PageToken *string `json:"PageToken,omitempty" xml:"PageToken,omitempty"`
	// The end time of the hour in which you want to query data. Example: 2020090919, which specifies 19:00 on September 9, 2020.
	QueryDateTimeHour *string `json:"QueryDateTimeHour,omitempty" xml:"QueryDateTimeHour,omitempty"`
	// The code of the speech sharing task.
	//
	// You can obtain the **code** on the **Shared Corpus Management** page of **Speech Sending Voice Broadcasting Service**.
	ShareTaskCode *string `json:"ShareTaskCode,omitempty" xml:"ShareTaskCode,omitempty"`
}

func (s PageQuerySpeechBroadcastHourRequest) String() string {
	return tea.Prettify(s)
}

func (s PageQuerySpeechBroadcastHourRequest) GoString() string {
	return s.String()
}

func (s *PageQuerySpeechBroadcastHourRequest) SetIotInstanceId(v string) *PageQuerySpeechBroadcastHourRequest {
	s.IotInstanceId = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourRequest) SetPageSize(v int32) *PageQuerySpeechBroadcastHourRequest {
	s.PageSize = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourRequest) SetPageToken(v string) *PageQuerySpeechBroadcastHourRequest {
	s.PageToken = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourRequest) SetQueryDateTimeHour(v string) *PageQuerySpeechBroadcastHourRequest {
	s.QueryDateTimeHour = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourRequest) SetShareTaskCode(v string) *PageQuerySpeechBroadcastHourRequest {
	s.ShareTaskCode = &v
	return s
}

type PageQuerySpeechBroadcastHourResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result returned if the call is successful.
	Data *PageQuerySpeechBroadcastHourResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PageQuerySpeechBroadcastHourResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PageQuerySpeechBroadcastHourResponseBody) GoString() string {
	return s.String()
}

func (s *PageQuerySpeechBroadcastHourResponseBody) SetCode(v string) *PageQuerySpeechBroadcastHourResponseBody {
	s.Code = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponseBody) SetData(v *PageQuerySpeechBroadcastHourResponseBodyData) *PageQuerySpeechBroadcastHourResponseBody {
	s.Data = v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponseBody) SetErrorMessage(v string) *PageQuerySpeechBroadcastHourResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponseBody) SetRequestId(v string) *PageQuerySpeechBroadcastHourResponseBody {
	s.RequestId = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponseBody) SetSuccess(v bool) *PageQuerySpeechBroadcastHourResponseBody {
	s.Success = &v
	return s
}

type PageQuerySpeechBroadcastHourResponseBodyData struct {
	// The page number.
	PageId *int32 `json:"PageId,omitempty" xml:"PageId,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// A pagination token. It can be used in the next request to retrieve a new page of results.
	//
	// If **PageToken** is empty, no next page exists.
	PageToken *string `json:"PageToken,omitempty" xml:"PageToken,omitempty"`
	// The shared speech broadcasting data returned.
	ResultData *PageQuerySpeechBroadcastHourResponseBodyDataResultData `json:"ResultData,omitempty" xml:"ResultData,omitempty" type:"Struct"`
	// The total number of entries returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s PageQuerySpeechBroadcastHourResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s PageQuerySpeechBroadcastHourResponseBodyData) GoString() string {
	return s.String()
}

func (s *PageQuerySpeechBroadcastHourResponseBodyData) SetPageId(v int32) *PageQuerySpeechBroadcastHourResponseBodyData {
	s.PageId = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponseBodyData) SetPageSize(v int32) *PageQuerySpeechBroadcastHourResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponseBodyData) SetPageToken(v string) *PageQuerySpeechBroadcastHourResponseBodyData {
	s.PageToken = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponseBodyData) SetResultData(v *PageQuerySpeechBroadcastHourResponseBodyDataResultData) *PageQuerySpeechBroadcastHourResponseBodyData {
	s.ResultData = v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponseBodyData) SetTotal(v int32) *PageQuerySpeechBroadcastHourResponseBodyData {
	s.Total = &v
	return s
}

type PageQuerySpeechBroadcastHourResponseBodyDataResultData struct {
	Data []*PageQuerySpeechBroadcastHourResponseBodyDataResultDataData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
}

func (s PageQuerySpeechBroadcastHourResponseBodyDataResultData) String() string {
	return tea.Prettify(s)
}

func (s PageQuerySpeechBroadcastHourResponseBodyDataResultData) GoString() string {
	return s.String()
}

func (s *PageQuerySpeechBroadcastHourResponseBodyDataResultData) SetData(v []*PageQuerySpeechBroadcastHourResponseBodyDataResultDataData) *PageQuerySpeechBroadcastHourResponseBodyDataResultData {
	s.Data = v
	return s
}

type PageQuerySpeechBroadcastHourResponseBodyDataResultDataData struct {
	// Indicates whether the speech was successfully broadcasted. Valid values:
	//
	// *   **0**: The speech was successfully broadcasted.
	// *   **1**: The speech was repeatedly broadcasted.
	// *   **2**: The speech does not exist.
	Code *int32 `json:"Code,omitempty" xml:"Code,omitempty"`
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The message that indicates the speech broadcasting result.
	Msg *string `json:"Msg,omitempty" xml:"Msg,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The code of the sharing task.
	ShareTaskCode *string `json:"ShareTaskCode,omitempty" xml:"ShareTaskCode,omitempty"`
	// The ID of the speech that was broadcasted.
	SpeechId *string `json:"SpeechId,omitempty" xml:"SpeechId,omitempty"`
	// The content of the broadcasted speech. The parameter value is a JSON array.
	Speechs *string `json:"Speechs,omitempty" xml:"Speechs,omitempty"`
	// The start time of speech broadcasting. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s PageQuerySpeechBroadcastHourResponseBodyDataResultDataData) String() string {
	return tea.Prettify(s)
}

func (s PageQuerySpeechBroadcastHourResponseBodyDataResultDataData) GoString() string {
	return s.String()
}

func (s *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData) SetCode(v int32) *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData {
	s.Code = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData) SetDeviceName(v string) *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData {
	s.DeviceName = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData) SetMsg(v string) *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData {
	s.Msg = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData) SetProductKey(v string) *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData {
	s.ProductKey = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData) SetShareTaskCode(v string) *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData {
	s.ShareTaskCode = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData) SetSpeechId(v string) *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData {
	s.SpeechId = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData) SetSpeechs(v string) *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData {
	s.Speechs = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData) SetStartTime(v int64) *PageQuerySpeechBroadcastHourResponseBodyDataResultDataData {
	s.StartTime = &v
	return s
}

type PageQuerySpeechBroadcastHourResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PageQuerySpeechBroadcastHourResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PageQuerySpeechBroadcastHourResponse) String() string {
	return tea.Prettify(s)
}

func (s PageQuerySpeechBroadcastHourResponse) GoString() string {
	return s.String()
}

func (s *PageQuerySpeechBroadcastHourResponse) SetHeaders(v map[string]*string) *PageQuerySpeechBroadcastHourResponse {
	s.Headers = v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponse) SetStatusCode(v int32) *PageQuerySpeechBroadcastHourResponse {
	s.StatusCode = &v
	return s
}

func (s *PageQuerySpeechBroadcastHourResponse) SetBody(v *PageQuerySpeechBroadcastHourResponseBody) *PageQuerySpeechBroadcastHourResponse {
	s.Body = v
	return s
}

type PrintByTemplateRequest struct {
	// The DeviceName of the device.
	DeviceName        *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	HistoryPrintTopic *bool   `json:"HistoryPrintTopic,omitempty" xml:"HistoryPrintTopic,omitempty"`
	// The device ID.
	//
	// > If you specify this parameter, you do not need to specify the **ProductKey** and **DeviceName** parameters. **IotId** specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The instance ID.
	//
	// You do not need to specify this parameter.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The template parameters. You can obtain the template of receipts in the Letter Sending Service console, and configure parameters in the template to create a custom receipt that you want to print.
	ParamsJsonString *string `json:"ParamsJsonString,omitempty" xml:"ParamsJsonString,omitempty"`
	// The unique identifier of the product to which the device belongs.
	//
	// > If you specify the **ProductKey** parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The template identifier. You can obtain the template identifier in the Letter Sending Service console.
	TemplateBizCode *string `json:"TemplateBizCode,omitempty" xml:"TemplateBizCode,omitempty"`
}

func (s PrintByTemplateRequest) String() string {
	return tea.Prettify(s)
}

func (s PrintByTemplateRequest) GoString() string {
	return s.String()
}

func (s *PrintByTemplateRequest) SetDeviceName(v string) *PrintByTemplateRequest {
	s.DeviceName = &v
	return s
}

func (s *PrintByTemplateRequest) SetHistoryPrintTopic(v bool) *PrintByTemplateRequest {
	s.HistoryPrintTopic = &v
	return s
}

func (s *PrintByTemplateRequest) SetIotId(v string) *PrintByTemplateRequest {
	s.IotId = &v
	return s
}

func (s *PrintByTemplateRequest) SetIotInstanceId(v string) *PrintByTemplateRequest {
	s.IotInstanceId = &v
	return s
}

func (s *PrintByTemplateRequest) SetParamsJsonString(v string) *PrintByTemplateRequest {
	s.ParamsJsonString = &v
	return s
}

func (s *PrintByTemplateRequest) SetProductKey(v string) *PrintByTemplateRequest {
	s.ProductKey = &v
	return s
}

func (s *PrintByTemplateRequest) SetTemplateBizCode(v string) *PrintByTemplateRequest {
	s.TemplateBizCode = &v
	return s
}

type PrintByTemplateResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the printing operation.
	Data *PrintByTemplateResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PrintByTemplateResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PrintByTemplateResponseBody) GoString() string {
	return s.String()
}

func (s *PrintByTemplateResponseBody) SetCode(v string) *PrintByTemplateResponseBody {
	s.Code = &v
	return s
}

func (s *PrintByTemplateResponseBody) SetData(v *PrintByTemplateResponseBodyData) *PrintByTemplateResponseBody {
	s.Data = v
	return s
}

func (s *PrintByTemplateResponseBody) SetErrorMessage(v string) *PrintByTemplateResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *PrintByTemplateResponseBody) SetRequestId(v string) *PrintByTemplateResponseBody {
	s.RequestId = &v
	return s
}

func (s *PrintByTemplateResponseBody) SetSuccess(v bool) *PrintByTemplateResponseBody {
	s.Success = &v
	return s
}

type PrintByTemplateResponseBodyData struct {
	// The error code returned by the printer. Valid values:
	//
	// *   2: The printer ran out of paper.
	// *   3: A paper jam occurred in the printer.
	DeviceErrorCode *string `json:"DeviceErrorCode,omitempty" xml:"DeviceErrorCode,omitempty"`
	// The error message returned by the printer.
	DeviceErrorMessage *string `json:"DeviceErrorMessage,omitempty" xml:"DeviceErrorMessage,omitempty"`
	// The ID of the printing operation.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The maximum number of retries. The value is fixed at 2, which indicates that up to two printing retries are supported.
	//
	// If the printer responds to the printing command with a failure or timeout error, IoT Platform delivers the printing command to the printer.
	MaxRetryCount *int32 `json:"MaxRetryCount,omitempty" xml:"MaxRetryCount,omitempty"`
	// The actual number of retries.
	RetryCount *int32 `json:"RetryCount,omitempty" xml:"RetryCount,omitempty"`
	// Indicates whether the printing operation was successful.
	//
	// *   **true**: The printing operation was successful.
	// *   **false**: The printing operation failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PrintByTemplateResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s PrintByTemplateResponseBodyData) GoString() string {
	return s.String()
}

func (s *PrintByTemplateResponseBodyData) SetDeviceErrorCode(v string) *PrintByTemplateResponseBodyData {
	s.DeviceErrorCode = &v
	return s
}

func (s *PrintByTemplateResponseBodyData) SetDeviceErrorMessage(v string) *PrintByTemplateResponseBodyData {
	s.DeviceErrorMessage = &v
	return s
}

func (s *PrintByTemplateResponseBodyData) SetId(v string) *PrintByTemplateResponseBodyData {
	s.Id = &v
	return s
}

func (s *PrintByTemplateResponseBodyData) SetMaxRetryCount(v int32) *PrintByTemplateResponseBodyData {
	s.MaxRetryCount = &v
	return s
}

func (s *PrintByTemplateResponseBodyData) SetRetryCount(v int32) *PrintByTemplateResponseBodyData {
	s.RetryCount = &v
	return s
}

func (s *PrintByTemplateResponseBodyData) SetSuccess(v bool) *PrintByTemplateResponseBodyData {
	s.Success = &v
	return s
}

type PrintByTemplateResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PrintByTemplateResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PrintByTemplateResponse) String() string {
	return tea.Prettify(s)
}

func (s PrintByTemplateResponse) GoString() string {
	return s.String()
}

func (s *PrintByTemplateResponse) SetHeaders(v map[string]*string) *PrintByTemplateResponse {
	s.Headers = v
	return s
}

func (s *PrintByTemplateResponse) SetStatusCode(v int32) *PrintByTemplateResponse {
	s.StatusCode = &v
	return s
}

func (s *PrintByTemplateResponse) SetBody(v *PrintByTemplateResponseBody) *PrintByTemplateResponse {
	s.Body = v
	return s
}

type PubRequest struct {
	// The content type of the message when you use MQTT 5.0 for communication.
	//
	// The content type is usually MIME, such as text or plain********.
	ContentType *string `json:"ContentType,omitempty" xml:"ContentType,omitempty"`
	// The related data in the request/response communication mode when you use MQTT 5.0. You can specify this parameter as needed.
	//
	// A message recipient can process the request based on the data.
	//
	// >  You must convert the related data into binary data and perform Base64 encoding to generate a value of the string type.
	CorrelationData *string `json:"CorrelationData,omitempty" xml:"CorrelationData,omitempty"`
	// The name of the MQTT cloud gateway.
	//
	// >When you publish a message to an MQTT cloud gateway, you must specify this parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the instance. You can obtain the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify this parameter. Otherwise, the call fails.
	// >*   If the **Overview** page or the instance ID is not displayed in the IoT Platform console, ignore this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The body of the message that you want to publish.
	//
	// To generate a message body, you must convert the raw message into binary data and perform Base64 encoding.
	MessageContent        *string `json:"MessageContent,omitempty" xml:"MessageContent,omitempty"`
	MessageExpiryInterval *int64  `json:"MessageExpiryInterval,omitempty" xml:"MessageExpiryInterval,omitempty"`
	// The payload identifier of the message when you use MQTT 5.0 for communication. Valid values:
	//
	// *   **0**: The message is unknown byte data.
	// *   **1**: The payload of the message is UTF-8 encoded character data.
	PayloadFormatIndicator *int32 `json:"PayloadFormatIndicator,omitempty" xml:"PayloadFormatIndicator,omitempty"`
	// The **ProductKey** of the product to which the device that receives the message belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The quality of service (QoS) level of the message. Valid values:
	//
	// *   **0**: The message is published at most once.
	// *   **1**: The message is published at least once. If a PUBACK response is not returned after you publish a QoS 1 message, the message is pushed to the device again when the device reconnects to IoT Platform.
	//
	// Default value: **0**.
	//
	// For more information about message communication, see [Limits](~~30527~~).
	Qos *int32 `json:"Qos,omitempty" xml:"Qos,omitempty"`
	// The response topic in the request/response communication mode when you use MQTT 5.0. For more information, see [MQTT 5.0](~~30540~~).
	ResponseTopic *string `json:"ResponseTopic,omitempty" xml:"ResponseTopic,omitempty"`
	Retained      *bool   `json:"Retained,omitempty" xml:"Retained,omitempty"`
	TopicAlias    *int32  `json:"TopicAlias,omitempty" xml:"TopicAlias,omitempty"`
	// The custom topic for the device that receives the message.
	//
	// *   Topic format: `/${productKey}/${deviceName}/user/${TopicShortName}`.
	// *   You must specify the **Subscribe** permission, or **Publish and Subscribe** permissions for the topic.
	//
	// > Make sure that the device subscribes to the topic before you call the Pub operation. Otherwise, the device cannot receive the message.
	//
	// You can view the custom topics of a product on the **Topic Categories** tab of the **Product Details** page, or by calling the [QueryProductTopic](~~69647~~) operation. You can view the topics to which the device subscribes on the **Topic List** tab of the **Device Details** page.
	TopicFullName *string               `json:"TopicFullName,omitempty" xml:"TopicFullName,omitempty"`
	UserProp      []*PubRequestUserProp `json:"UserProp,omitempty" xml:"UserProp,omitempty" type:"Repeated"`
}

func (s PubRequest) String() string {
	return tea.Prettify(s)
}

func (s PubRequest) GoString() string {
	return s.String()
}

func (s *PubRequest) SetContentType(v string) *PubRequest {
	s.ContentType = &v
	return s
}

func (s *PubRequest) SetCorrelationData(v string) *PubRequest {
	s.CorrelationData = &v
	return s
}

func (s *PubRequest) SetDeviceName(v string) *PubRequest {
	s.DeviceName = &v
	return s
}

func (s *PubRequest) SetIotInstanceId(v string) *PubRequest {
	s.IotInstanceId = &v
	return s
}

func (s *PubRequest) SetMessageContent(v string) *PubRequest {
	s.MessageContent = &v
	return s
}

func (s *PubRequest) SetMessageExpiryInterval(v int64) *PubRequest {
	s.MessageExpiryInterval = &v
	return s
}

func (s *PubRequest) SetPayloadFormatIndicator(v int32) *PubRequest {
	s.PayloadFormatIndicator = &v
	return s
}

func (s *PubRequest) SetProductKey(v string) *PubRequest {
	s.ProductKey = &v
	return s
}

func (s *PubRequest) SetQos(v int32) *PubRequest {
	s.Qos = &v
	return s
}

func (s *PubRequest) SetResponseTopic(v string) *PubRequest {
	s.ResponseTopic = &v
	return s
}

func (s *PubRequest) SetRetained(v bool) *PubRequest {
	s.Retained = &v
	return s
}

func (s *PubRequest) SetTopicAlias(v int32) *PubRequest {
	s.TopicAlias = &v
	return s
}

func (s *PubRequest) SetTopicFullName(v string) *PubRequest {
	s.TopicFullName = &v
	return s
}

func (s *PubRequest) SetUserProp(v []*PubRequestUserProp) *PubRequest {
	s.UserProp = v
	return s
}

type PubRequestUserProp struct {
	// The custom property key that is specified when you use MQTT 5.0 for communication.
	//
	// This parameter must be used together with the **UserProp.N.Value** parameter.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The custom property value that is specified when you use MQTT 5.0 for communication.
	//
	// This parameter must be used together with the **UserProp.N.Key** parameter.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s PubRequestUserProp) String() string {
	return tea.Prettify(s)
}

func (s PubRequestUserProp) GoString() string {
	return s.String()
}

func (s *PubRequestUserProp) SetKey(v string) *PubRequestUserProp {
	s.Key = &v
	return s
}

func (s *PubRequestUserProp) SetValue(v string) *PubRequestUserProp {
	s.Value = &v
	return s
}

type PubResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The message ID that is generated by IoT Platform when the message is sent.
	MessageId *string `json:"MessageId,omitempty" xml:"MessageId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PubResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PubResponseBody) GoString() string {
	return s.String()
}

func (s *PubResponseBody) SetCode(v string) *PubResponseBody {
	s.Code = &v
	return s
}

func (s *PubResponseBody) SetErrorMessage(v string) *PubResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *PubResponseBody) SetMessageId(v string) *PubResponseBody {
	s.MessageId = &v
	return s
}

func (s *PubResponseBody) SetRequestId(v string) *PubResponseBody {
	s.RequestId = &v
	return s
}

func (s *PubResponseBody) SetSuccess(v bool) *PubResponseBody {
	s.Success = &v
	return s
}

type PubResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PubResponseBody   `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PubResponse) String() string {
	return tea.Prettify(s)
}

func (s PubResponse) GoString() string {
	return s.String()
}

func (s *PubResponse) SetHeaders(v map[string]*string) *PubResponse {
	s.Headers = v
	return s
}

func (s *PubResponse) SetStatusCode(v int32) *PubResponse {
	s.StatusCode = &v
	return s
}

func (s *PubResponse) SetBody(v *PubResponseBody) *PubResponse {
	s.Body = v
	return s
}

type PubBroadcastRequest struct {
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify this parameter. Otherwise, the call fails.
	// >*   If the **Overview** page or an instance ID is not displayed in the IoT Platform console, ignore this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The message body that you want to send. The maximum size of a message is 64 KB.
	//
	// To generate a message body, you must convert the raw message into binary data and perform Base64 encoding.
	MessageContent *string `json:"MessageContent,omitempty" xml:"MessageContent,omitempty"`
	// The **ProductKey** of the product to which the devices belong.
	//
	// A **ProductKey** is the unique identifier of a product in IoT Platform. You can view the information about all products within the current Alibaba Cloud account in the IoT Platform console or by calling the [QueryProductList](~~69271~~) operation.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The name of the topic. This parameter is optional.
	//
	// *   If you do not specify this parameter, the message is pushed to all online devices that have the specified **ProductKey**. Devices receive the message from the broadcast topic in the following format: `/sys/${productKey}/${deviceName}/broadcast/request/${MessageId}`. The **MessageId** variable is generated by IoT Platform.
	// *   If you specify this parameter, the message is pushed to the devices that have the specified **ProductKey** and subscribe to the specified topic. You must specify a broadcast topic by using the following syntax: `/broadcast/${productKey}/Custom field`. Replace **${productKey}** with the **ProductKey** of the devices that receive the message. For the custom field, you can specify a value based on your business requirements.
	//
	// > *   When you develop devices, you need to only write code to define a broadcast topic. You do not need to create a topic in the IoT Platform console.
	// >*   A maximum of 1,000 devices can subscribe to a broadcast topic. If the number of devices exceeds the limit, you can divide the devices into groups. For example, you can divide 5,000 devices into five groups that contain 1,000 devices. In this case, you must call this operation five times and set the value of the custom field to group1, group2, group3, group4, and group5. Then, configure the devices. This way, each group of devices subscribes to the corresponding topic.
	TopicFullName *string `json:"TopicFullName,omitempty" xml:"TopicFullName,omitempty"`
}

func (s PubBroadcastRequest) String() string {
	return tea.Prettify(s)
}

func (s PubBroadcastRequest) GoString() string {
	return s.String()
}

func (s *PubBroadcastRequest) SetIotInstanceId(v string) *PubBroadcastRequest {
	s.IotInstanceId = &v
	return s
}

func (s *PubBroadcastRequest) SetMessageContent(v string) *PubBroadcastRequest {
	s.MessageContent = &v
	return s
}

func (s *PubBroadcastRequest) SetProductKey(v string) *PubBroadcastRequest {
	s.ProductKey = &v
	return s
}

func (s *PubBroadcastRequest) SetTopicFullName(v string) *PubBroadcastRequest {
	s.TopicFullName = &v
	return s
}

type PubBroadcastResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The message ID that is generated by IoT Platform when the message is sent.
	MessageId *int64 `json:"MessageId,omitempty" xml:"MessageId,omitempty"`
	// The ID of the request. The ID is a unique identifier of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PubBroadcastResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PubBroadcastResponseBody) GoString() string {
	return s.String()
}

func (s *PubBroadcastResponseBody) SetCode(v string) *PubBroadcastResponseBody {
	s.Code = &v
	return s
}

func (s *PubBroadcastResponseBody) SetErrorMessage(v string) *PubBroadcastResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *PubBroadcastResponseBody) SetMessageId(v int64) *PubBroadcastResponseBody {
	s.MessageId = &v
	return s
}

func (s *PubBroadcastResponseBody) SetRequestId(v string) *PubBroadcastResponseBody {
	s.RequestId = &v
	return s
}

func (s *PubBroadcastResponseBody) SetSuccess(v bool) *PubBroadcastResponseBody {
	s.Success = &v
	return s
}

type PubBroadcastResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PubBroadcastResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PubBroadcastResponse) String() string {
	return tea.Prettify(s)
}

func (s PubBroadcastResponse) GoString() string {
	return s.String()
}

func (s *PubBroadcastResponse) SetHeaders(v map[string]*string) *PubBroadcastResponse {
	s.Headers = v
	return s
}

func (s *PubBroadcastResponse) SetStatusCode(v int32) *PubBroadcastResponse {
	s.StatusCode = &v
	return s
}

func (s *PubBroadcastResponse) SetBody(v *PubBroadcastResponseBody) *PubBroadcastResponse {
	s.Body = v
	return s
}

type PublishScriptRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ParserId      *int64  `json:"ParserId,omitempty" xml:"ParserId,omitempty"`
}

func (s PublishScriptRequest) String() string {
	return tea.Prettify(s)
}

func (s PublishScriptRequest) GoString() string {
	return s.String()
}

func (s *PublishScriptRequest) SetIotInstanceId(v string) *PublishScriptRequest {
	s.IotInstanceId = &v
	return s
}

func (s *PublishScriptRequest) SetParserId(v int64) *PublishScriptRequest {
	s.ParserId = &v
	return s
}

type PublishScriptResponseBody struct {
	Code           *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage   *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
	SyntaxErrorMsg *string `json:"SyntaxErrorMsg,omitempty" xml:"SyntaxErrorMsg,omitempty"`
}

func (s PublishScriptResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PublishScriptResponseBody) GoString() string {
	return s.String()
}

func (s *PublishScriptResponseBody) SetCode(v string) *PublishScriptResponseBody {
	s.Code = &v
	return s
}

func (s *PublishScriptResponseBody) SetErrorMessage(v string) *PublishScriptResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *PublishScriptResponseBody) SetRequestId(v string) *PublishScriptResponseBody {
	s.RequestId = &v
	return s
}

func (s *PublishScriptResponseBody) SetSuccess(v bool) *PublishScriptResponseBody {
	s.Success = &v
	return s
}

func (s *PublishScriptResponseBody) SetSyntaxErrorMsg(v string) *PublishScriptResponseBody {
	s.SyntaxErrorMsg = &v
	return s
}

type PublishScriptResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PublishScriptResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PublishScriptResponse) String() string {
	return tea.Prettify(s)
}

func (s PublishScriptResponse) GoString() string {
	return s.String()
}

func (s *PublishScriptResponse) SetHeaders(v map[string]*string) *PublishScriptResponse {
	s.Headers = v
	return s
}

func (s *PublishScriptResponse) SetStatusCode(v int32) *PublishScriptResponse {
	s.StatusCode = &v
	return s
}

func (s *PublishScriptResponse) SetBody(v *PublishScriptResponseBody) *PublishScriptResponse {
	s.Body = v
	return s
}

type PublishStudioAppRequest struct {
	AppId         *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	Description   *string `json:"Description,omitempty" xml:"Description,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProjectId     *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s PublishStudioAppRequest) String() string {
	return tea.Prettify(s)
}

func (s PublishStudioAppRequest) GoString() string {
	return s.String()
}

func (s *PublishStudioAppRequest) SetAppId(v string) *PublishStudioAppRequest {
	s.AppId = &v
	return s
}

func (s *PublishStudioAppRequest) SetDescription(v string) *PublishStudioAppRequest {
	s.Description = &v
	return s
}

func (s *PublishStudioAppRequest) SetIotInstanceId(v string) *PublishStudioAppRequest {
	s.IotInstanceId = &v
	return s
}

func (s *PublishStudioAppRequest) SetProjectId(v string) *PublishStudioAppRequest {
	s.ProjectId = &v
	return s
}

type PublishStudioAppResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PublishStudioAppResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PublishStudioAppResponseBody) GoString() string {
	return s.String()
}

func (s *PublishStudioAppResponseBody) SetCode(v string) *PublishStudioAppResponseBody {
	s.Code = &v
	return s
}

func (s *PublishStudioAppResponseBody) SetData(v bool) *PublishStudioAppResponseBody {
	s.Data = &v
	return s
}

func (s *PublishStudioAppResponseBody) SetErrorMessage(v string) *PublishStudioAppResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *PublishStudioAppResponseBody) SetRequestId(v string) *PublishStudioAppResponseBody {
	s.RequestId = &v
	return s
}

func (s *PublishStudioAppResponseBody) SetSuccess(v bool) *PublishStudioAppResponseBody {
	s.Success = &v
	return s
}

type PublishStudioAppResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PublishStudioAppResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PublishStudioAppResponse) String() string {
	return tea.Prettify(s)
}

func (s PublishStudioAppResponse) GoString() string {
	return s.String()
}

func (s *PublishStudioAppResponse) SetHeaders(v map[string]*string) *PublishStudioAppResponse {
	s.Headers = v
	return s
}

func (s *PublishStudioAppResponse) SetStatusCode(v int32) *PublishStudioAppResponse {
	s.StatusCode = &v
	return s
}

func (s *PublishStudioAppResponse) SetBody(v *PublishStudioAppResponseBody) *PublishStudioAppResponse {
	s.Body = v
	return s
}

type PublishThingModelRequest struct {
	// The description of the TSL model version.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The version number of the TSL model.
	//
	// The version number must be 1 to 16 characters in length and can contain letters, digits, and periods (.).
	ModelVersion *string `json:"ModelVersion,omitempty" xml:"ModelVersion,omitempty"`
	// The ProductKey of the product.
	//
	// You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the resource group.
	//
	// >  You cannot specify this parameter.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s PublishThingModelRequest) String() string {
	return tea.Prettify(s)
}

func (s PublishThingModelRequest) GoString() string {
	return s.String()
}

func (s *PublishThingModelRequest) SetDescription(v string) *PublishThingModelRequest {
	s.Description = &v
	return s
}

func (s *PublishThingModelRequest) SetIotInstanceId(v string) *PublishThingModelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *PublishThingModelRequest) SetModelVersion(v string) *PublishThingModelRequest {
	s.ModelVersion = &v
	return s
}

func (s *PublishThingModelRequest) SetProductKey(v string) *PublishThingModelRequest {
	s.ProductKey = &v
	return s
}

func (s *PublishThingModelRequest) SetResourceGroupId(v string) *PublishThingModelRequest {
	s.ResourceGroupId = &v
	return s
}

type PublishThingModelResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PublishThingModelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PublishThingModelResponseBody) GoString() string {
	return s.String()
}

func (s *PublishThingModelResponseBody) SetCode(v string) *PublishThingModelResponseBody {
	s.Code = &v
	return s
}

func (s *PublishThingModelResponseBody) SetErrorMessage(v string) *PublishThingModelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *PublishThingModelResponseBody) SetRequestId(v string) *PublishThingModelResponseBody {
	s.RequestId = &v
	return s
}

func (s *PublishThingModelResponseBody) SetSuccess(v bool) *PublishThingModelResponseBody {
	s.Success = &v
	return s
}

type PublishThingModelResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PublishThingModelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PublishThingModelResponse) String() string {
	return tea.Prettify(s)
}

func (s PublishThingModelResponse) GoString() string {
	return s.String()
}

func (s *PublishThingModelResponse) SetHeaders(v map[string]*string) *PublishThingModelResponse {
	s.Headers = v
	return s
}

func (s *PublishThingModelResponse) SetStatusCode(v int32) *PublishThingModelResponse {
	s.StatusCode = &v
	return s
}

func (s *PublishThingModelResponse) SetBody(v *PublishThingModelResponseBody) *PublishThingModelResponse {
	s.Body = v
	return s
}

type PushSpeechRequest struct {
	DeviceName     *string   `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	GroupId        *string   `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	IotId          *string   `json:"IotId,omitempty" xml:"IotId,omitempty"`
	IotInstanceId  *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey     *string   `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	ProjectCode    *string   `json:"ProjectCode,omitempty" xml:"ProjectCode,omitempty"`
	PushMode       *string   `json:"PushMode,omitempty" xml:"PushMode,omitempty"`
	SpeechCodeList []*string `json:"SpeechCodeList,omitempty" xml:"SpeechCodeList,omitempty" type:"Repeated"`
}

func (s PushSpeechRequest) String() string {
	return tea.Prettify(s)
}

func (s PushSpeechRequest) GoString() string {
	return s.String()
}

func (s *PushSpeechRequest) SetDeviceName(v string) *PushSpeechRequest {
	s.DeviceName = &v
	return s
}

func (s *PushSpeechRequest) SetGroupId(v string) *PushSpeechRequest {
	s.GroupId = &v
	return s
}

func (s *PushSpeechRequest) SetIotId(v string) *PushSpeechRequest {
	s.IotId = &v
	return s
}

func (s *PushSpeechRequest) SetIotInstanceId(v string) *PushSpeechRequest {
	s.IotInstanceId = &v
	return s
}

func (s *PushSpeechRequest) SetProductKey(v string) *PushSpeechRequest {
	s.ProductKey = &v
	return s
}

func (s *PushSpeechRequest) SetProjectCode(v string) *PushSpeechRequest {
	s.ProjectCode = &v
	return s
}

func (s *PushSpeechRequest) SetPushMode(v string) *PushSpeechRequest {
	s.PushMode = &v
	return s
}

func (s *PushSpeechRequest) SetSpeechCodeList(v []*string) *PushSpeechRequest {
	s.SpeechCodeList = v
	return s
}

type PushSpeechResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s PushSpeechResponseBody) String() string {
	return tea.Prettify(s)
}

func (s PushSpeechResponseBody) GoString() string {
	return s.String()
}

func (s *PushSpeechResponseBody) SetCode(v string) *PushSpeechResponseBody {
	s.Code = &v
	return s
}

func (s *PushSpeechResponseBody) SetData(v string) *PushSpeechResponseBody {
	s.Data = &v
	return s
}

func (s *PushSpeechResponseBody) SetErrorMessage(v string) *PushSpeechResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *PushSpeechResponseBody) SetRequestId(v string) *PushSpeechResponseBody {
	s.RequestId = &v
	return s
}

func (s *PushSpeechResponseBody) SetSuccess(v bool) *PushSpeechResponseBody {
	s.Success = &v
	return s
}

type PushSpeechResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *PushSpeechResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s PushSpeechResponse) String() string {
	return tea.Prettify(s)
}

func (s PushSpeechResponse) GoString() string {
	return s.String()
}

func (s *PushSpeechResponse) SetHeaders(v map[string]*string) *PushSpeechResponse {
	s.Headers = v
	return s
}

func (s *PushSpeechResponse) SetStatusCode(v int32) *PushSpeechResponse {
	s.StatusCode = &v
	return s
}

func (s *PushSpeechResponse) SetBody(v *PushSpeechResponseBody) *PushSpeechResponse {
	s.Body = v
	return s
}

type QueryBatchRegisterDeviceStatusRequest struct {
	// The application ID. If the call of the [BatchRegisterDeviceWithApplyId](~~69514~~) or [BatchRegisterDevice](~~69473~~) operation is successful, the application ID is returned.
	ApplyId *int64 `json:"ApplyId,omitempty" xml:"ApplyId,omitempty"`
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
	//
	//
	// **Important**
	//
	// *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// *   If no **Overview** page or ID is generated for your instance, you do not need configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryBatchRegisterDeviceStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryBatchRegisterDeviceStatusRequest) GoString() string {
	return s.String()
}

func (s *QueryBatchRegisterDeviceStatusRequest) SetApplyId(v int64) *QueryBatchRegisterDeviceStatusRequest {
	s.ApplyId = &v
	return s
}

func (s *QueryBatchRegisterDeviceStatusRequest) SetIotInstanceId(v string) *QueryBatchRegisterDeviceStatusRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryBatchRegisterDeviceStatusRequest) SetProductKey(v string) *QueryBatchRegisterDeviceStatusRequest {
	s.ProductKey = &v
	return s
}

type QueryBatchRegisterDeviceStatusResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	//
	// >  X.509 certificates are available only for devices in the China (Shanghai) region. If devices do not reside in the China (Shanghai) region, you cannot generate X.509 certificates for the devices and the iot.device.RegionNotSupportX509 error code is returned.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The status information returned if the call is successful.
	Data *QueryBatchRegisterDeviceStatusResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryBatchRegisterDeviceStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryBatchRegisterDeviceStatusResponseBody) GoString() string {
	return s.String()
}

func (s *QueryBatchRegisterDeviceStatusResponseBody) SetCode(v string) *QueryBatchRegisterDeviceStatusResponseBody {
	s.Code = &v
	return s
}

func (s *QueryBatchRegisterDeviceStatusResponseBody) SetData(v *QueryBatchRegisterDeviceStatusResponseBodyData) *QueryBatchRegisterDeviceStatusResponseBody {
	s.Data = v
	return s
}

func (s *QueryBatchRegisterDeviceStatusResponseBody) SetErrorMessage(v string) *QueryBatchRegisterDeviceStatusResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryBatchRegisterDeviceStatusResponseBody) SetRequestId(v string) *QueryBatchRegisterDeviceStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryBatchRegisterDeviceStatusResponseBody) SetSuccess(v bool) *QueryBatchRegisterDeviceStatusResponseBody {
	s.Success = &v
	return s
}

type QueryBatchRegisterDeviceStatusResponseBodyData struct {
	InvalidDetailList *QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList `json:"InvalidDetailList,omitempty" xml:"InvalidDetailList,omitempty" type:"Struct"`
	// *   If the value of the **Status** parameter is **CHECK_FAILED** or **CREATE_FAILED**, some devices failed to be created and the names of the devices that failed to be created are returned in this parameter.
	// *   If the value of the **Status** parameter is **CHECK_SUCCESS** or **CREATE_SUCCESS**, all devices are created and an empty array is returned in this parameter.
	InvalidList *QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList `json:"InvalidList,omitempty" xml:"InvalidList,omitempty" type:"Struct"`
	// The processing status and result. Valid values:
	//
	// *   **CHECK**: The system is verifying device names.
	//
	// *   **CHECK_SUCCESS**: All devices in the application form are verified.
	//
	// *   **CHECK_FAILED**: All devices in the application form failed to be verified.
	//
	// *   **CREATE**: The system is creating devices.
	//
	// *   **CREATE_SUCCESS**: All devices in the application form are created.
	//
	// > If the authentication type of the product to which the devices belong is X.509, all devices and the related X.509 certificates are created.
	//
	// *   **CREATE_FAILED**: Some devices in the application form failed to be created.
	//
	// > If a device or X.509 certificate fails to be created in the current batch when the authentication type is X.509, all devices fail to be created.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// *   If the value of the **Status** parameter is **CHECK_FAILED** or **CREATE_FAILED**, some devices failed to be created and the names of the created devices are returned in this parameter.
	// *   If the value of the **Status** parameter is **CHECK_SUCCESS** or **CREATE_SUCCESS**, all devices are created and an empty array is returned in this parameter.
	ValidList *QueryBatchRegisterDeviceStatusResponseBodyDataValidList `json:"ValidList,omitempty" xml:"ValidList,omitempty" type:"Struct"`
}

func (s QueryBatchRegisterDeviceStatusResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryBatchRegisterDeviceStatusResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryBatchRegisterDeviceStatusResponseBodyData) SetInvalidDetailList(v *QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList) *QueryBatchRegisterDeviceStatusResponseBodyData {
	s.InvalidDetailList = v
	return s
}

func (s *QueryBatchRegisterDeviceStatusResponseBodyData) SetInvalidList(v *QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList) *QueryBatchRegisterDeviceStatusResponseBodyData {
	s.InvalidList = v
	return s
}

func (s *QueryBatchRegisterDeviceStatusResponseBodyData) SetStatus(v string) *QueryBatchRegisterDeviceStatusResponseBodyData {
	s.Status = &v
	return s
}

func (s *QueryBatchRegisterDeviceStatusResponseBodyData) SetValidList(v *QueryBatchRegisterDeviceStatusResponseBodyDataValidList) *QueryBatchRegisterDeviceStatusResponseBodyData {
	s.ValidList = v
	return s
}

type QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList struct {
	InvalidDetailList []*QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList `json:"invalidDetailList,omitempty" xml:"invalidDetailList,omitempty" type:"Repeated"`
}

func (s QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList) String() string {
	return tea.Prettify(s)
}

func (s QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList) GoString() string {
	return s.String()
}

func (s *QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList) SetInvalidDetailList(v []*QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList) *QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailList {
	s.InvalidDetailList = v
	return s
}

type QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList struct {
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	ErrorMsg   *string `json:"ErrorMsg,omitempty" xml:"ErrorMsg,omitempty"`
	NickName   *string `json:"NickName,omitempty" xml:"NickName,omitempty"`
}

func (s QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList) String() string {
	return tea.Prettify(s)
}

func (s QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList) GoString() string {
	return s.String()
}

func (s *QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList) SetDeviceName(v string) *QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList {
	s.DeviceName = &v
	return s
}

func (s *QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList) SetErrorMsg(v string) *QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList {
	s.ErrorMsg = &v
	return s
}

func (s *QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList) SetNickName(v string) *QueryBatchRegisterDeviceStatusResponseBodyDataInvalidDetailListInvalidDetailList {
	s.NickName = &v
	return s
}

type QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList struct {
	Name []*string `json:"Name,omitempty" xml:"Name,omitempty" type:"Repeated"`
}

func (s QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList) String() string {
	return tea.Prettify(s)
}

func (s QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList) GoString() string {
	return s.String()
}

func (s *QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList) SetName(v []*string) *QueryBatchRegisterDeviceStatusResponseBodyDataInvalidList {
	s.Name = v
	return s
}

type QueryBatchRegisterDeviceStatusResponseBodyDataValidList struct {
	Name []*string `json:"Name,omitempty" xml:"Name,omitempty" type:"Repeated"`
}

func (s QueryBatchRegisterDeviceStatusResponseBodyDataValidList) String() string {
	return tea.Prettify(s)
}

func (s QueryBatchRegisterDeviceStatusResponseBodyDataValidList) GoString() string {
	return s.String()
}

func (s *QueryBatchRegisterDeviceStatusResponseBodyDataValidList) SetName(v []*string) *QueryBatchRegisterDeviceStatusResponseBodyDataValidList {
	s.Name = v
	return s
}

type QueryBatchRegisterDeviceStatusResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryBatchRegisterDeviceStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryBatchRegisterDeviceStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryBatchRegisterDeviceStatusResponse) GoString() string {
	return s.String()
}

func (s *QueryBatchRegisterDeviceStatusResponse) SetHeaders(v map[string]*string) *QueryBatchRegisterDeviceStatusResponse {
	s.Headers = v
	return s
}

func (s *QueryBatchRegisterDeviceStatusResponse) SetStatusCode(v int32) *QueryBatchRegisterDeviceStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryBatchRegisterDeviceStatusResponse) SetBody(v *QueryBatchRegisterDeviceStatusResponseBody) *QueryBatchRegisterDeviceStatusResponse {
	s.Body = v
	return s
}

type QueryCertUrlByApplyIdRequest struct {
	// The application ID. You can view the application ID in the result that is returned by the [BatchRegisterDeviceWithApplyId](~~69514~~) or [BatchRegisterDevice](~~69473~~) operation.
	ApplyId *int64 `json:"ApplyId,omitempty" xml:"ApplyId,omitempty"`
	// The instance ID.
	//
	// You can obtain the **ID** of the instance on the **Overview** page in the IoT Platform console. If your instance has an ID, you must specify this parameter. Otherwise, the request fails.
	//
	// > The ID of a public instance may not be displayed on the Overview page. For information about how to obtain the instance ID, see [How do I obtain an instance ID?](~~267533~~)
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s QueryCertUrlByApplyIdRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryCertUrlByApplyIdRequest) GoString() string {
	return s.String()
}

func (s *QueryCertUrlByApplyIdRequest) SetApplyId(v int64) *QueryCertUrlByApplyIdRequest {
	s.ApplyId = &v
	return s
}

func (s *QueryCertUrlByApplyIdRequest) SetIotInstanceId(v string) *QueryCertUrlByApplyIdRequest {
	s.IotInstanceId = &v
	return s
}

type QueryCertUrlByApplyIdResponseBody struct {
	// The URL from which you can download the X.509 certificates of created devices.
	CertUrl *string `json:"CertUrl,omitempty" xml:"CertUrl,omitempty"`
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryCertUrlByApplyIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryCertUrlByApplyIdResponseBody) GoString() string {
	return s.String()
}

func (s *QueryCertUrlByApplyIdResponseBody) SetCertUrl(v string) *QueryCertUrlByApplyIdResponseBody {
	s.CertUrl = &v
	return s
}

func (s *QueryCertUrlByApplyIdResponseBody) SetCode(v string) *QueryCertUrlByApplyIdResponseBody {
	s.Code = &v
	return s
}

func (s *QueryCertUrlByApplyIdResponseBody) SetErrorMessage(v string) *QueryCertUrlByApplyIdResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryCertUrlByApplyIdResponseBody) SetRequestId(v string) *QueryCertUrlByApplyIdResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryCertUrlByApplyIdResponseBody) SetSuccess(v bool) *QueryCertUrlByApplyIdResponseBody {
	s.Success = &v
	return s
}

type QueryCertUrlByApplyIdResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryCertUrlByApplyIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryCertUrlByApplyIdResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryCertUrlByApplyIdResponse) GoString() string {
	return s.String()
}

func (s *QueryCertUrlByApplyIdResponse) SetHeaders(v map[string]*string) *QueryCertUrlByApplyIdResponse {
	s.Headers = v
	return s
}

func (s *QueryCertUrlByApplyIdResponse) SetStatusCode(v int32) *QueryCertUrlByApplyIdResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryCertUrlByApplyIdResponse) SetBody(v *QueryCertUrlByApplyIdResponseBody) *QueryCertUrlByApplyIdResponse {
	s.Body = v
	return s
}

type QueryClientIdsRequest struct {
	// The ID of the device. You can call the [QueryDeviceInfo](~~257184~~) operation to query the **IotId** parameter.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s QueryClientIdsRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryClientIdsRequest) GoString() string {
	return s.String()
}

func (s *QueryClientIdsRequest) SetIotId(v string) *QueryClientIdsRequest {
	s.IotId = &v
	return s
}

func (s *QueryClientIdsRequest) SetIotInstanceId(v string) *QueryClientIdsRequest {
	s.IotInstanceId = &v
	return s
}

type QueryClientIdsResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ClientIDs returned if the call is successful. For more information, see **DynamicRegClientIds**.
	Data *QueryClientIdsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryClientIdsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryClientIdsResponseBody) GoString() string {
	return s.String()
}

func (s *QueryClientIdsResponseBody) SetCode(v string) *QueryClientIdsResponseBody {
	s.Code = &v
	return s
}

func (s *QueryClientIdsResponseBody) SetData(v *QueryClientIdsResponseBodyData) *QueryClientIdsResponseBody {
	s.Data = v
	return s
}

func (s *QueryClientIdsResponseBody) SetErrorMessage(v string) *QueryClientIdsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryClientIdsResponseBody) SetRequestId(v string) *QueryClientIdsResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryClientIdsResponseBody) SetSuccess(v bool) *QueryClientIdsResponseBody {
	s.Success = &v
	return s
}

type QueryClientIdsResponseBodyData struct {
	// The list of ClientIDs.
	DynamicRegClientIds []*QueryClientIdsResponseBodyDataDynamicRegClientIds `json:"DynamicRegClientIds,omitempty" xml:"DynamicRegClientIds,omitempty" type:"Repeated"`
	// The ID of the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
}

func (s QueryClientIdsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryClientIdsResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryClientIdsResponseBodyData) SetDynamicRegClientIds(v []*QueryClientIdsResponseBodyDataDynamicRegClientIds) *QueryClientIdsResponseBodyData {
	s.DynamicRegClientIds = v
	return s
}

func (s *QueryClientIdsResponseBodyData) SetIotId(v string) *QueryClientIdsResponseBodyData {
	s.IotId = &v
	return s
}

type QueryClientIdsResponseBodyDataDynamicRegClientIds struct {
	// The ClientID of the device.
	ClientId *string `json:"ClientId,omitempty" xml:"ClientId,omitempty"`
	// The time when the ClientID was created.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
}

func (s QueryClientIdsResponseBodyDataDynamicRegClientIds) String() string {
	return tea.Prettify(s)
}

func (s QueryClientIdsResponseBodyDataDynamicRegClientIds) GoString() string {
	return s.String()
}

func (s *QueryClientIdsResponseBodyDataDynamicRegClientIds) SetClientId(v string) *QueryClientIdsResponseBodyDataDynamicRegClientIds {
	s.ClientId = &v
	return s
}

func (s *QueryClientIdsResponseBodyDataDynamicRegClientIds) SetCreateTime(v int64) *QueryClientIdsResponseBodyDataDynamicRegClientIds {
	s.CreateTime = &v
	return s
}

type QueryClientIdsResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryClientIdsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryClientIdsResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryClientIdsResponse) GoString() string {
	return s.String()
}

func (s *QueryClientIdsResponse) SetHeaders(v map[string]*string) *QueryClientIdsResponse {
	s.Headers = v
	return s
}

func (s *QueryClientIdsResponse) SetStatusCode(v int32) *QueryClientIdsResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryClientIdsResponse) SetBody(v *QueryClientIdsResponseBody) *QueryClientIdsResponse {
	s.Body = v
	return s
}

type QueryConsumerGroupByGroupIdRequest struct {
	// The ID of the consumer group. After you call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group, the consumer group ID is returned. You can call the [QueryConsumerGroupList](~~170419~~) operation to query the consumer group ID by group name. You can also go to the IoT Platform console,and choose **Rules** > **Server-side Subscription** > **Consumer Groups** to view the consumer group ID.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s QueryConsumerGroupByGroupIdRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryConsumerGroupByGroupIdRequest) GoString() string {
	return s.String()
}

func (s *QueryConsumerGroupByGroupIdRequest) SetGroupId(v string) *QueryConsumerGroupByGroupIdRequest {
	s.GroupId = &v
	return s
}

func (s *QueryConsumerGroupByGroupIdRequest) SetIotInstanceId(v string) *QueryConsumerGroupByGroupIdRequest {
	s.IotInstanceId = &v
	return s
}

type QueryConsumerGroupByGroupIdResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The details about the consumer group. This parameter is returned if the call is successful.
	Data *QueryConsumerGroupByGroupIdResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryConsumerGroupByGroupIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryConsumerGroupByGroupIdResponseBody) GoString() string {
	return s.String()
}

func (s *QueryConsumerGroupByGroupIdResponseBody) SetCode(v string) *QueryConsumerGroupByGroupIdResponseBody {
	s.Code = &v
	return s
}

func (s *QueryConsumerGroupByGroupIdResponseBody) SetData(v *QueryConsumerGroupByGroupIdResponseBodyData) *QueryConsumerGroupByGroupIdResponseBody {
	s.Data = v
	return s
}

func (s *QueryConsumerGroupByGroupIdResponseBody) SetErrorMessage(v string) *QueryConsumerGroupByGroupIdResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryConsumerGroupByGroupIdResponseBody) SetRequestId(v string) *QueryConsumerGroupByGroupIdResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryConsumerGroupByGroupIdResponseBody) SetSuccess(v bool) *QueryConsumerGroupByGroupIdResponseBody {
	s.Success = &v
	return s
}

type QueryConsumerGroupByGroupIdResponseBodyData struct {
	// The time when the consumer group was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ss.SSSZ format. The time is displayed in UTC and accurate to milliseconds.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the consumer group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the consumer group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
}

func (s QueryConsumerGroupByGroupIdResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryConsumerGroupByGroupIdResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryConsumerGroupByGroupIdResponseBodyData) SetCreateTime(v string) *QueryConsumerGroupByGroupIdResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *QueryConsumerGroupByGroupIdResponseBodyData) SetGroupId(v string) *QueryConsumerGroupByGroupIdResponseBodyData {
	s.GroupId = &v
	return s
}

func (s *QueryConsumerGroupByGroupIdResponseBodyData) SetGroupName(v string) *QueryConsumerGroupByGroupIdResponseBodyData {
	s.GroupName = &v
	return s
}

type QueryConsumerGroupByGroupIdResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryConsumerGroupByGroupIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryConsumerGroupByGroupIdResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryConsumerGroupByGroupIdResponse) GoString() string {
	return s.String()
}

func (s *QueryConsumerGroupByGroupIdResponse) SetHeaders(v map[string]*string) *QueryConsumerGroupByGroupIdResponse {
	s.Headers = v
	return s
}

func (s *QueryConsumerGroupByGroupIdResponse) SetStatusCode(v int32) *QueryConsumerGroupByGroupIdResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryConsumerGroupByGroupIdResponse) SetBody(v *QueryConsumerGroupByGroupIdResponseBody) *QueryConsumerGroupByGroupIdResponse {
	s.Body = v
	return s
}

type QueryConsumerGroupListRequest struct {
	// The number of the page to return. Pages start from page 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// Specifies whether to perform a fuzzy search. Valid values:
	//
	// *   **true**: performs a fuzzy search. You must specify the **GroupName** parameter.
	// *   **false**: queries all consumer groups of the current account.
	//
	// Default value: **false**.
	Fuzzy *bool `json:"Fuzzy,omitempty" xml:"Fuzzy,omitempty"`
	// The name of the consumer group to be queried. This parameter is required if the **Fuzzy** parameter is set to **true**.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 1000.
	PageSize   *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	SubBizCode *string `json:"SubBizCode,omitempty" xml:"SubBizCode,omitempty"`
	Type       *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s QueryConsumerGroupListRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryConsumerGroupListRequest) GoString() string {
	return s.String()
}

func (s *QueryConsumerGroupListRequest) SetCurrentPage(v int32) *QueryConsumerGroupListRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryConsumerGroupListRequest) SetFuzzy(v bool) *QueryConsumerGroupListRequest {
	s.Fuzzy = &v
	return s
}

func (s *QueryConsumerGroupListRequest) SetGroupName(v string) *QueryConsumerGroupListRequest {
	s.GroupName = &v
	return s
}

func (s *QueryConsumerGroupListRequest) SetIotInstanceId(v string) *QueryConsumerGroupListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryConsumerGroupListRequest) SetPageSize(v int32) *QueryConsumerGroupListRequest {
	s.PageSize = &v
	return s
}

func (s *QueryConsumerGroupListRequest) SetSubBizCode(v string) *QueryConsumerGroupListRequest {
	s.SubBizCode = &v
	return s
}

func (s *QueryConsumerGroupListRequest) SetType(v string) *QueryConsumerGroupListRequest {
	s.Type = &v
	return s
}

type QueryConsumerGroupListResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The details about the consumer group. This parameter is returned if the call is successful. For more information, see ConsumerGroupDTO.
	Data *QueryConsumerGroupListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The total number of returned pages.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of entries.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryConsumerGroupListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryConsumerGroupListResponseBody) GoString() string {
	return s.String()
}

func (s *QueryConsumerGroupListResponseBody) SetCode(v string) *QueryConsumerGroupListResponseBody {
	s.Code = &v
	return s
}

func (s *QueryConsumerGroupListResponseBody) SetCurrentPage(v int32) *QueryConsumerGroupListResponseBody {
	s.CurrentPage = &v
	return s
}

func (s *QueryConsumerGroupListResponseBody) SetData(v *QueryConsumerGroupListResponseBodyData) *QueryConsumerGroupListResponseBody {
	s.Data = v
	return s
}

func (s *QueryConsumerGroupListResponseBody) SetErrorMessage(v string) *QueryConsumerGroupListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryConsumerGroupListResponseBody) SetPageCount(v int32) *QueryConsumerGroupListResponseBody {
	s.PageCount = &v
	return s
}

func (s *QueryConsumerGroupListResponseBody) SetPageSize(v int32) *QueryConsumerGroupListResponseBody {
	s.PageSize = &v
	return s
}

func (s *QueryConsumerGroupListResponseBody) SetRequestId(v string) *QueryConsumerGroupListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryConsumerGroupListResponseBody) SetSuccess(v bool) *QueryConsumerGroupListResponseBody {
	s.Success = &v
	return s
}

func (s *QueryConsumerGroupListResponseBody) SetTotal(v int32) *QueryConsumerGroupListResponseBody {
	s.Total = &v
	return s
}

type QueryConsumerGroupListResponseBodyData struct {
	ConsumerGroupDTO []*QueryConsumerGroupListResponseBodyDataConsumerGroupDTO `json:"ConsumerGroupDTO,omitempty" xml:"ConsumerGroupDTO,omitempty" type:"Repeated"`
}

func (s QueryConsumerGroupListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryConsumerGroupListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryConsumerGroupListResponseBodyData) SetConsumerGroupDTO(v []*QueryConsumerGroupListResponseBodyDataConsumerGroupDTO) *QueryConsumerGroupListResponseBodyData {
	s.ConsumerGroupDTO = v
	return s
}

type QueryConsumerGroupListResponseBodyDataConsumerGroupDTO struct {
	// The time when the consumer group was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ss.SSSZ format. The time is displayed in UTC and accurate to milliseconds.
	CreateTime *string `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The ID of the consumer group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the consumer group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
}

func (s QueryConsumerGroupListResponseBodyDataConsumerGroupDTO) String() string {
	return tea.Prettify(s)
}

func (s QueryConsumerGroupListResponseBodyDataConsumerGroupDTO) GoString() string {
	return s.String()
}

func (s *QueryConsumerGroupListResponseBodyDataConsumerGroupDTO) SetCreateTime(v string) *QueryConsumerGroupListResponseBodyDataConsumerGroupDTO {
	s.CreateTime = &v
	return s
}

func (s *QueryConsumerGroupListResponseBodyDataConsumerGroupDTO) SetGroupId(v string) *QueryConsumerGroupListResponseBodyDataConsumerGroupDTO {
	s.GroupId = &v
	return s
}

func (s *QueryConsumerGroupListResponseBodyDataConsumerGroupDTO) SetGroupName(v string) *QueryConsumerGroupListResponseBodyDataConsumerGroupDTO {
	s.GroupName = &v
	return s
}

type QueryConsumerGroupListResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryConsumerGroupListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryConsumerGroupListResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryConsumerGroupListResponse) GoString() string {
	return s.String()
}

func (s *QueryConsumerGroupListResponse) SetHeaders(v map[string]*string) *QueryConsumerGroupListResponse {
	s.Headers = v
	return s
}

func (s *QueryConsumerGroupListResponse) SetStatusCode(v int32) *QueryConsumerGroupListResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryConsumerGroupListResponse) SetBody(v *QueryConsumerGroupListResponseBody) *QueryConsumerGroupListResponse {
	s.Body = v
	return s
}

type QueryConsumerGroupStatusRequest struct {
	// The ID of the consumer group. After you call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group, the consumer group ID is returned. You can call the [QueryConsumerGroupList](~~170419~~) operation to query the consumer group ID by group name. You can also go to the IoT Platform console,and choose **Rules** > **Server-side Subscription** > **Consumer Groups** to view the consumer group ID.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s QueryConsumerGroupStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryConsumerGroupStatusRequest) GoString() string {
	return s.String()
}

func (s *QueryConsumerGroupStatusRequest) SetGroupId(v string) *QueryConsumerGroupStatusRequest {
	s.GroupId = &v
	return s
}

func (s *QueryConsumerGroupStatusRequest) SetIotInstanceId(v string) *QueryConsumerGroupStatusRequest {
	s.IotInstanceId = &v
	return s
}

type QueryConsumerGroupStatusResponseBody struct {
	// The message consumption rate. Unit: messages/minute.
	AccumulatedConsumeCountPerMinute *int32 `json:"AccumulatedConsumeCountPerMinute,omitempty" xml:"AccumulatedConsumeCountPerMinute,omitempty"`
	// The number of accumulated messages.
	AccumulationCount *int32 `json:"AccumulationCount,omitempty" xml:"AccumulationCount,omitempty"`
	// The details about the client. For more information, see **ConsumerGroupClientConnectionInfo**.
	ClientConnectionStatusList *QueryConsumerGroupStatusResponseBodyClientConnectionStatusList `json:"ClientConnectionStatusList,omitempty" xml:"ClientConnectionStatusList,omitempty" type:"Struct"`
	// The error code returned if the call fails. For more information, see [Error codes](/help/en/iot-platform/latest/bce100).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The message consumption rate of the consumer group. Unit: messages/minute.
	ConsumerSpeed *int32 `json:"ConsumerSpeed,omitempty" xml:"ConsumerSpeed,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The time when the last message was consumed. The time is in the yyyy-MM-dd\"T\"HH:mm:ss.SSSZ format. The time is displayed in UTC and accurate to milliseconds.
	LastConsumerTime *string `json:"LastConsumerTime,omitempty" xml:"LastConsumerTime,omitempty"`
	// The consumption rate of real-time messages in the consumer group. Unit: messages/minute.
	RealTimeConsumeCountPerMinute *int32 `json:"RealTimeConsumeCountPerMinute,omitempty" xml:"RealTimeConsumeCountPerMinute,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryConsumerGroupStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryConsumerGroupStatusResponseBody) GoString() string {
	return s.String()
}

func (s *QueryConsumerGroupStatusResponseBody) SetAccumulatedConsumeCountPerMinute(v int32) *QueryConsumerGroupStatusResponseBody {
	s.AccumulatedConsumeCountPerMinute = &v
	return s
}

func (s *QueryConsumerGroupStatusResponseBody) SetAccumulationCount(v int32) *QueryConsumerGroupStatusResponseBody {
	s.AccumulationCount = &v
	return s
}

func (s *QueryConsumerGroupStatusResponseBody) SetClientConnectionStatusList(v *QueryConsumerGroupStatusResponseBodyClientConnectionStatusList) *QueryConsumerGroupStatusResponseBody {
	s.ClientConnectionStatusList = v
	return s
}

func (s *QueryConsumerGroupStatusResponseBody) SetCode(v string) *QueryConsumerGroupStatusResponseBody {
	s.Code = &v
	return s
}

func (s *QueryConsumerGroupStatusResponseBody) SetConsumerSpeed(v int32) *QueryConsumerGroupStatusResponseBody {
	s.ConsumerSpeed = &v
	return s
}

func (s *QueryConsumerGroupStatusResponseBody) SetErrorMessage(v string) *QueryConsumerGroupStatusResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryConsumerGroupStatusResponseBody) SetLastConsumerTime(v string) *QueryConsumerGroupStatusResponseBody {
	s.LastConsumerTime = &v
	return s
}

func (s *QueryConsumerGroupStatusResponseBody) SetRealTimeConsumeCountPerMinute(v int32) *QueryConsumerGroupStatusResponseBody {
	s.RealTimeConsumeCountPerMinute = &v
	return s
}

func (s *QueryConsumerGroupStatusResponseBody) SetRequestId(v string) *QueryConsumerGroupStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryConsumerGroupStatusResponseBody) SetSuccess(v bool) *QueryConsumerGroupStatusResponseBody {
	s.Success = &v
	return s
}

type QueryConsumerGroupStatusResponseBodyClientConnectionStatusList struct {
	ConsumerGroupClientConnectionInfo []*QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo `json:"ConsumerGroupClientConnectionInfo,omitempty" xml:"ConsumerGroupClientConnectionInfo,omitempty" type:"Repeated"`
}

func (s QueryConsumerGroupStatusResponseBodyClientConnectionStatusList) String() string {
	return tea.Prettify(s)
}

func (s QueryConsumerGroupStatusResponseBodyClientConnectionStatusList) GoString() string {
	return s.String()
}

func (s *QueryConsumerGroupStatusResponseBodyClientConnectionStatusList) SetConsumerGroupClientConnectionInfo(v []*QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo) *QueryConsumerGroupStatusResponseBodyClientConnectionStatusList {
	s.ConsumerGroupClientConnectionInfo = v
	return s
}

type QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo struct {
	// The consumption rate of accumulated messages on a single client of the consumer group. Unit: messages/minute.
	AccumulatedConsumeCountPerMinute *int32 `json:"AccumulatedConsumeCountPerMinute,omitempty" xml:"AccumulatedConsumeCountPerMinute,omitempty"`
	// The ID of the client.
	ClientId *string `json:"ClientId,omitempty" xml:"ClientId,omitempty"`
	// The IP address and port of the client.
	ClientIpPort *string `json:"ClientIpPort,omitempty" xml:"ClientIpPort,omitempty"`
	// The last time when the client was online. This value is a UNIX timestamp representing the number of milliseconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.
	OnlineTime *int64 `json:"OnlineTime,omitempty" xml:"OnlineTime,omitempty"`
	// The consumption rate of real-time messages on a single client of the consumer group. Unit: messages/minute.
	RealTimeConsumeCountPerMinute *int32 `json:"RealTimeConsumeCountPerMinute,omitempty" xml:"RealTimeConsumeCountPerMinute,omitempty"`
}

func (s QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo) GoString() string {
	return s.String()
}

func (s *QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo) SetAccumulatedConsumeCountPerMinute(v int32) *QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo {
	s.AccumulatedConsumeCountPerMinute = &v
	return s
}

func (s *QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo) SetClientId(v string) *QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo {
	s.ClientId = &v
	return s
}

func (s *QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo) SetClientIpPort(v string) *QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo {
	s.ClientIpPort = &v
	return s
}

func (s *QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo) SetOnlineTime(v int64) *QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo {
	s.OnlineTime = &v
	return s
}

func (s *QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo) SetRealTimeConsumeCountPerMinute(v int32) *QueryConsumerGroupStatusResponseBodyClientConnectionStatusListConsumerGroupClientConnectionInfo {
	s.RealTimeConsumeCountPerMinute = &v
	return s
}

type QueryConsumerGroupStatusResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryConsumerGroupStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryConsumerGroupStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryConsumerGroupStatusResponse) GoString() string {
	return s.String()
}

func (s *QueryConsumerGroupStatusResponse) SetHeaders(v map[string]*string) *QueryConsumerGroupStatusResponse {
	s.Headers = v
	return s
}

func (s *QueryConsumerGroupStatusResponse) SetStatusCode(v int32) *QueryConsumerGroupStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryConsumerGroupStatusResponse) SetBody(v *QueryConsumerGroupStatusResponseBody) *QueryConsumerGroupStatusResponse {
	s.Body = v
	return s
}

type QueryDetailSceneRuleLogRequest struct {
	CurrentPage   *int32  `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	EndTime       *int32  `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RuleId        *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	StartTime     *int32  `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	TraceId       *string `json:"TraceId,omitempty" xml:"TraceId,omitempty"`
}

func (s QueryDetailSceneRuleLogRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDetailSceneRuleLogRequest) GoString() string {
	return s.String()
}

func (s *QueryDetailSceneRuleLogRequest) SetCurrentPage(v int32) *QueryDetailSceneRuleLogRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryDetailSceneRuleLogRequest) SetEndTime(v int32) *QueryDetailSceneRuleLogRequest {
	s.EndTime = &v
	return s
}

func (s *QueryDetailSceneRuleLogRequest) SetIotInstanceId(v string) *QueryDetailSceneRuleLogRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDetailSceneRuleLogRequest) SetPageSize(v int32) *QueryDetailSceneRuleLogRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDetailSceneRuleLogRequest) SetRuleId(v string) *QueryDetailSceneRuleLogRequest {
	s.RuleId = &v
	return s
}

func (s *QueryDetailSceneRuleLogRequest) SetStartTime(v int32) *QueryDetailSceneRuleLogRequest {
	s.StartTime = &v
	return s
}

func (s *QueryDetailSceneRuleLogRequest) SetTraceId(v string) *QueryDetailSceneRuleLogRequest {
	s.TraceId = &v
	return s
}

type QueryDetailSceneRuleLogResponseBody struct {
	Code         *string                                  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryDetailSceneRuleLogResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                  `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                    `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDetailSceneRuleLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDetailSceneRuleLogResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDetailSceneRuleLogResponseBody) SetCode(v string) *QueryDetailSceneRuleLogResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDetailSceneRuleLogResponseBody) SetData(v *QueryDetailSceneRuleLogResponseBodyData) *QueryDetailSceneRuleLogResponseBody {
	s.Data = v
	return s
}

func (s *QueryDetailSceneRuleLogResponseBody) SetErrorMessage(v string) *QueryDetailSceneRuleLogResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDetailSceneRuleLogResponseBody) SetRequestId(v string) *QueryDetailSceneRuleLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDetailSceneRuleLogResponseBody) SetSuccess(v bool) *QueryDetailSceneRuleLogResponseBody {
	s.Success = &v
	return s
}

type QueryDetailSceneRuleLogResponseBodyData struct {
	CurrentPage *int32                                            `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	LogList     []*QueryDetailSceneRuleLogResponseBodyDataLogList `json:"LogList,omitempty" xml:"LogList,omitempty" type:"Repeated"`
	PageSize    *int32                                            `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total       *int32                                            `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryDetailSceneRuleLogResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDetailSceneRuleLogResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDetailSceneRuleLogResponseBodyData) SetCurrentPage(v int32) *QueryDetailSceneRuleLogResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *QueryDetailSceneRuleLogResponseBodyData) SetLogList(v []*QueryDetailSceneRuleLogResponseBodyDataLogList) *QueryDetailSceneRuleLogResponseBodyData {
	s.LogList = v
	return s
}

func (s *QueryDetailSceneRuleLogResponseBodyData) SetPageSize(v int32) *QueryDetailSceneRuleLogResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryDetailSceneRuleLogResponseBodyData) SetTotal(v int32) *QueryDetailSceneRuleLogResponseBodyData {
	s.Total = &v
	return s
}

type QueryDetailSceneRuleLogResponseBodyDataLogList struct {
	Code    *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	PkDn    *string `json:"PkDn,omitempty" xml:"PkDn,omitempty"`
}

func (s QueryDetailSceneRuleLogResponseBodyDataLogList) String() string {
	return tea.Prettify(s)
}

func (s QueryDetailSceneRuleLogResponseBodyDataLogList) GoString() string {
	return s.String()
}

func (s *QueryDetailSceneRuleLogResponseBodyDataLogList) SetCode(v string) *QueryDetailSceneRuleLogResponseBodyDataLogList {
	s.Code = &v
	return s
}

func (s *QueryDetailSceneRuleLogResponseBodyDataLogList) SetMessage(v string) *QueryDetailSceneRuleLogResponseBodyDataLogList {
	s.Message = &v
	return s
}

func (s *QueryDetailSceneRuleLogResponseBodyDataLogList) SetPkDn(v string) *QueryDetailSceneRuleLogResponseBodyDataLogList {
	s.PkDn = &v
	return s
}

type QueryDetailSceneRuleLogResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDetailSceneRuleLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDetailSceneRuleLogResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDetailSceneRuleLogResponse) GoString() string {
	return s.String()
}

func (s *QueryDetailSceneRuleLogResponse) SetHeaders(v map[string]*string) *QueryDetailSceneRuleLogResponse {
	s.Headers = v
	return s
}

func (s *QueryDetailSceneRuleLogResponse) SetStatusCode(v int32) *QueryDetailSceneRuleLogResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDetailSceneRuleLogResponse) SetBody(v *QueryDetailSceneRuleLogResponseBody) *QueryDetailSceneRuleLogResponse {
	s.Body = v
	return s
}

type QueryDeviceRequest struct {
	// The number of the page to return. Default value: 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The token that is used to retrieve the next page of the query results. The first time you perform a query operation, you do not need to configure this parameter. You must specify the token that is obtained from the previous query for the **NextToken** parameter.
	//
	// If the product of the value of the **PageSize** parameter and the value of the **CurrentPage** parameter is greater than 10,000, you must configure the **NextToken** parameter. Otherwise, data cannot be returned.
	//
	//
	// >If you configure the **NextToken** parameter, the product of the value of the **PageSize** parameter and the value of the **CurrentPage** parameter must be less than 1,000,000. Otherwise, data cannot be returned.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 50. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceRequest) SetCurrentPage(v int32) *QueryDeviceRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryDeviceRequest) SetIotInstanceId(v string) *QueryDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceRequest) SetNextToken(v string) *QueryDeviceRequest {
	s.NextToken = &v
	return s
}

func (s *QueryDeviceRequest) SetPageSize(v int32) *QueryDeviceRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceRequest) SetProductKey(v string) *QueryDeviceRequest {
	s.ProductKey = &v
	return s
}

type QueryDeviceResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The device information returned if the call is successful. The details of the devices are included in the **DeviceInfo** parameter.
	//
	// >  The returned device information is sorted in reverse chronological order based on the time when the devices were created.
	Data *QueryDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The token that is used to retrieve the subsequent page of the query results. You can specify this parameter in the subsequent query to obtain the next page of results.
	//
	// If the **NextToken** parameter is empty, no subsequent page exists.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The page number of the returned page.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The total number of pages returned.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of devices.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceResponseBody) SetCode(v string) *QueryDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceResponseBody) SetData(v *QueryDeviceResponseBodyData) *QueryDeviceResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceResponseBody) SetErrorMessage(v string) *QueryDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceResponseBody) SetNextToken(v string) *QueryDeviceResponseBody {
	s.NextToken = &v
	return s
}

func (s *QueryDeviceResponseBody) SetPage(v int32) *QueryDeviceResponseBody {
	s.Page = &v
	return s
}

func (s *QueryDeviceResponseBody) SetPageCount(v int32) *QueryDeviceResponseBody {
	s.PageCount = &v
	return s
}

func (s *QueryDeviceResponseBody) SetPageSize(v int32) *QueryDeviceResponseBody {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceResponseBody) SetRequestId(v string) *QueryDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceResponseBody) SetSuccess(v bool) *QueryDeviceResponseBody {
	s.Success = &v
	return s
}

func (s *QueryDeviceResponseBody) SetTotal(v int32) *QueryDeviceResponseBody {
	s.Total = &v
	return s
}

type QueryDeviceResponseBodyData struct {
	DeviceInfo []*QueryDeviceResponseBodyDataDeviceInfo `json:"DeviceInfo,omitempty" xml:"DeviceInfo,omitempty" type:"Repeated"`
}

func (s QueryDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceResponseBodyData) SetDeviceInfo(v []*QueryDeviceResponseBodyDataDeviceInfo) *QueryDeviceResponseBodyData {
	s.DeviceInfo = v
	return s
}

type QueryDeviceResponseBodyDataDeviceInfo struct {
	// The ID of the device.
	//
	// >  This parameter is deprecated. Do not use this parameter to identify a device. You can use the **IotId** parameter or a combination of the **ProductKey** and **DeviceName** parameters to identify a device.
	DeviceId *string `json:"DeviceId,omitempty" xml:"DeviceId,omitempty"`
	// The name of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The DeviceSecret of the device.
	DeviceSecret *string `json:"DeviceSecret,omitempty" xml:"DeviceSecret,omitempty"`
	// The status of the device. Valid values:
	//
	// *   **ONLINE**: The device is online.
	// *   **OFFLINE**: The device is offline.
	// *   **UNACTIVE**: The device is not activated.
	// *   **DISABLE**: The device is deactivated.
	DeviceStatus *string `json:"DeviceStatus,omitempty" xml:"DeviceStatus,omitempty"`
	// The category of the product to which the device belongs.
	//
	// >  This parameter is not returned.
	DeviceType *string `json:"DeviceType,omitempty" xml:"DeviceType,omitempty"`
	// The time when the device was created. The time is in the GMT format.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the device information was last updated. The time is in the GMT format.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The alias of the device.
	Nickname *string `json:"Nickname,omitempty" xml:"Nickname,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The time when the device was created. The time is displayed in UTC.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
	// The time when the device information was last updated. The time is displayed in UTC.
	UtcModified *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
}

func (s QueryDeviceResponseBodyDataDeviceInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceResponseBodyDataDeviceInfo) GoString() string {
	return s.String()
}

func (s *QueryDeviceResponseBodyDataDeviceInfo) SetDeviceId(v string) *QueryDeviceResponseBodyDataDeviceInfo {
	s.DeviceId = &v
	return s
}

func (s *QueryDeviceResponseBodyDataDeviceInfo) SetDeviceName(v string) *QueryDeviceResponseBodyDataDeviceInfo {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceResponseBodyDataDeviceInfo) SetDeviceSecret(v string) *QueryDeviceResponseBodyDataDeviceInfo {
	s.DeviceSecret = &v
	return s
}

func (s *QueryDeviceResponseBodyDataDeviceInfo) SetDeviceStatus(v string) *QueryDeviceResponseBodyDataDeviceInfo {
	s.DeviceStatus = &v
	return s
}

func (s *QueryDeviceResponseBodyDataDeviceInfo) SetDeviceType(v string) *QueryDeviceResponseBodyDataDeviceInfo {
	s.DeviceType = &v
	return s
}

func (s *QueryDeviceResponseBodyDataDeviceInfo) SetGmtCreate(v string) *QueryDeviceResponseBodyDataDeviceInfo {
	s.GmtCreate = &v
	return s
}

func (s *QueryDeviceResponseBodyDataDeviceInfo) SetGmtModified(v string) *QueryDeviceResponseBodyDataDeviceInfo {
	s.GmtModified = &v
	return s
}

func (s *QueryDeviceResponseBodyDataDeviceInfo) SetIotId(v string) *QueryDeviceResponseBodyDataDeviceInfo {
	s.IotId = &v
	return s
}

func (s *QueryDeviceResponseBodyDataDeviceInfo) SetNickname(v string) *QueryDeviceResponseBodyDataDeviceInfo {
	s.Nickname = &v
	return s
}

func (s *QueryDeviceResponseBodyDataDeviceInfo) SetProductKey(v string) *QueryDeviceResponseBodyDataDeviceInfo {
	s.ProductKey = &v
	return s
}

func (s *QueryDeviceResponseBodyDataDeviceInfo) SetUtcCreate(v string) *QueryDeviceResponseBodyDataDeviceInfo {
	s.UtcCreate = &v
	return s
}

func (s *QueryDeviceResponseBodyDataDeviceInfo) SetUtcModified(v string) *QueryDeviceResponseBodyDataDeviceInfo {
	s.UtcModified = &v
	return s
}

type QueryDeviceResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceResponse) SetHeaders(v map[string]*string) *QueryDeviceResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceResponse) SetStatusCode(v int32) *QueryDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceResponse) SetBody(v *QueryDeviceResponseBody) *QueryDeviceResponse {
	s.Body = v
	return s
}

type QueryDeviceBySQLRequest struct {
	// The ID of the instance. You can view the **ID** of the instance on the **Instance Overview** page in the IoT Platform console.
	//
	//
	// **Important**
	//
	// *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****
	// *   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The SQL-like statement that you want to execute to query devices. For more information about specific requirements and examples, see the following section.
	SQL *string `json:"SQL,omitempty" xml:"SQL,omitempty"`
}

func (s QueryDeviceBySQLRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceBySQLRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceBySQLRequest) SetIotInstanceId(v string) *QueryDeviceBySQLRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceBySQLRequest) SetSQL(v string) *QueryDeviceBySQLRequest {
	s.SQL = &v
	return s
}

type QueryDeviceBySQLResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The device information returned if the call is successful.
	Data []*QueryDeviceBySQLResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Repeated"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// If you specify `SELECT count(*) FROM device` in the SQL-like statement, the number of rows that match the specified conditions is returned.
	TotalCount *int64 `json:"TotalCount,omitempty" xml:"TotalCount,omitempty"`
}

func (s QueryDeviceBySQLResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceBySQLResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceBySQLResponseBody) SetCode(v string) *QueryDeviceBySQLResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceBySQLResponseBody) SetData(v []*QueryDeviceBySQLResponseBodyData) *QueryDeviceBySQLResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceBySQLResponseBody) SetErrorMessage(v string) *QueryDeviceBySQLResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceBySQLResponseBody) SetRequestId(v string) *QueryDeviceBySQLResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceBySQLResponseBody) SetSuccess(v bool) *QueryDeviceBySQLResponseBody {
	s.Success = &v
	return s
}

func (s *QueryDeviceBySQLResponseBody) SetTotalCount(v int64) *QueryDeviceBySQLResponseBody {
	s.TotalCount = &v
	return s
}

type QueryDeviceBySQLResponseBodyData struct {
	// The time when the device was activated. The time is in the GMT format.
	ActiveTime *string `json:"ActiveTime,omitempty" xml:"ActiveTime,omitempty"`
	// The name of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The time when the device was created. The time is in the GMT format.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the device information was last updated. The time is in the GMT format.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The information about the groups to which the device belongs.
	Groups []*QueryDeviceBySQLResponseBodyDataGroups `json:"Groups,omitempty" xml:"Groups,omitempty" type:"Repeated"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The alias of the device.
	Nickname *string `json:"Nickname,omitempty" xml:"Nickname,omitempty"`
	// The information about the firmware of each device module.
	OTAModules []*QueryDeviceBySQLResponseBodyDataOTAModules `json:"OTAModules,omitempty" xml:"OTAModules,omitempty" type:"Repeated"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The status of the device. Valid values:
	//
	// *   **ONLINE**: The device is online.
	// *   **OFFLINE**: The device is offline.
	// *   **UNACTIVE**: The device is not activated.
	// *   **DISABLE**: The device is disabled.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The information about device tags.
	Tags []*QueryDeviceBySQLResponseBodyDataTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Repeated"`
}

func (s QueryDeviceBySQLResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceBySQLResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceBySQLResponseBodyData) SetActiveTime(v string) *QueryDeviceBySQLResponseBodyData {
	s.ActiveTime = &v
	return s
}

func (s *QueryDeviceBySQLResponseBodyData) SetDeviceName(v string) *QueryDeviceBySQLResponseBodyData {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceBySQLResponseBodyData) SetGmtCreate(v string) *QueryDeviceBySQLResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *QueryDeviceBySQLResponseBodyData) SetGmtModified(v string) *QueryDeviceBySQLResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *QueryDeviceBySQLResponseBodyData) SetGroups(v []*QueryDeviceBySQLResponseBodyDataGroups) *QueryDeviceBySQLResponseBodyData {
	s.Groups = v
	return s
}

func (s *QueryDeviceBySQLResponseBodyData) SetIotId(v string) *QueryDeviceBySQLResponseBodyData {
	s.IotId = &v
	return s
}

func (s *QueryDeviceBySQLResponseBodyData) SetNickname(v string) *QueryDeviceBySQLResponseBodyData {
	s.Nickname = &v
	return s
}

func (s *QueryDeviceBySQLResponseBodyData) SetOTAModules(v []*QueryDeviceBySQLResponseBodyDataOTAModules) *QueryDeviceBySQLResponseBodyData {
	s.OTAModules = v
	return s
}

func (s *QueryDeviceBySQLResponseBodyData) SetProductKey(v string) *QueryDeviceBySQLResponseBodyData {
	s.ProductKey = &v
	return s
}

func (s *QueryDeviceBySQLResponseBodyData) SetStatus(v string) *QueryDeviceBySQLResponseBodyData {
	s.Status = &v
	return s
}

func (s *QueryDeviceBySQLResponseBodyData) SetTags(v []*QueryDeviceBySQLResponseBodyDataTags) *QueryDeviceBySQLResponseBodyData {
	s.Tags = v
	return s
}

type QueryDeviceBySQLResponseBodyDataGroups struct {
	// The ID of the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
}

func (s QueryDeviceBySQLResponseBodyDataGroups) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceBySQLResponseBodyDataGroups) GoString() string {
	return s.String()
}

func (s *QueryDeviceBySQLResponseBodyDataGroups) SetGroupId(v string) *QueryDeviceBySQLResponseBodyDataGroups {
	s.GroupId = &v
	return s
}

type QueryDeviceBySQLResponseBodyDataOTAModules struct {
	// The version number of each OTA module.
	FirmwareVersion *string `json:"FirmwareVersion,omitempty" xml:"FirmwareVersion,omitempty"`
	// The name of the OTA module.
	ModuleName *string `json:"ModuleName,omitempty" xml:"ModuleName,omitempty"`
}

func (s QueryDeviceBySQLResponseBodyDataOTAModules) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceBySQLResponseBodyDataOTAModules) GoString() string {
	return s.String()
}

func (s *QueryDeviceBySQLResponseBodyDataOTAModules) SetFirmwareVersion(v string) *QueryDeviceBySQLResponseBodyDataOTAModules {
	s.FirmwareVersion = &v
	return s
}

func (s *QueryDeviceBySQLResponseBodyDataOTAModules) SetModuleName(v string) *QueryDeviceBySQLResponseBodyDataOTAModules {
	s.ModuleName = &v
	return s
}

type QueryDeviceBySQLResponseBodyDataTags struct {
	// The tag key.
	TagName *string `json:"TagName,omitempty" xml:"TagName,omitempty"`
	// The tag value.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s QueryDeviceBySQLResponseBodyDataTags) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceBySQLResponseBodyDataTags) GoString() string {
	return s.String()
}

func (s *QueryDeviceBySQLResponseBodyDataTags) SetTagName(v string) *QueryDeviceBySQLResponseBodyDataTags {
	s.TagName = &v
	return s
}

func (s *QueryDeviceBySQLResponseBodyDataTags) SetTagValue(v string) *QueryDeviceBySQLResponseBodyDataTags {
	s.TagValue = &v
	return s
}

type QueryDeviceBySQLResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceBySQLResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceBySQLResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceBySQLResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceBySQLResponse) SetHeaders(v map[string]*string) *QueryDeviceBySQLResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceBySQLResponse) SetStatusCode(v int32) *QueryDeviceBySQLResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceBySQLResponse) SetBody(v *QueryDeviceBySQLResponseBody) *QueryDeviceBySQLResponse {
	s.Body = v
	return s
}

type QueryDeviceByStatusRequest struct {
	// The number of the page to return.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	//
	// **Important**
	//
	// *   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// *   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 50.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the resource group to which the product belongs. You can view the resource group ID in the IoT Platform console.
	//
	// >  If you specify this parameter, the system returns devices of the specified status in the resource group. If you do not specify this parameter, the system returns all devices of the specified status in the current account.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
	// The status of the devices. Valid values:
	//
	// *   **0**: inactive
	// *   **1**: online
	// *   **3**: offline
	// *   **8**: disabled
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s QueryDeviceByStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceByStatusRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceByStatusRequest) SetCurrentPage(v int32) *QueryDeviceByStatusRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryDeviceByStatusRequest) SetIotInstanceId(v string) *QueryDeviceByStatusRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceByStatusRequest) SetPageSize(v int32) *QueryDeviceByStatusRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceByStatusRequest) SetProductKey(v string) *QueryDeviceByStatusRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryDeviceByStatusRequest) SetResourceGroupId(v string) *QueryDeviceByStatusRequest {
	s.ResourceGroupId = &v
	return s
}

func (s *QueryDeviceByStatusRequest) SetStatus(v int32) *QueryDeviceByStatusRequest {
	s.Status = &v
	return s
}

type QueryDeviceByStatusResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The device list information returned if the call succeeds. The **SimpleDeviceInfo** parameter includes the details of the devices.
	Data *QueryDeviceByStatusResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The number of the returned page.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The total number of pages.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of devices returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryDeviceByStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceByStatusResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceByStatusResponseBody) SetCode(v string) *QueryDeviceByStatusResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceByStatusResponseBody) SetData(v *QueryDeviceByStatusResponseBodyData) *QueryDeviceByStatusResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceByStatusResponseBody) SetErrorMessage(v string) *QueryDeviceByStatusResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceByStatusResponseBody) SetPage(v int32) *QueryDeviceByStatusResponseBody {
	s.Page = &v
	return s
}

func (s *QueryDeviceByStatusResponseBody) SetPageCount(v int32) *QueryDeviceByStatusResponseBody {
	s.PageCount = &v
	return s
}

func (s *QueryDeviceByStatusResponseBody) SetPageSize(v int32) *QueryDeviceByStatusResponseBody {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceByStatusResponseBody) SetRequestId(v string) *QueryDeviceByStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceByStatusResponseBody) SetSuccess(v bool) *QueryDeviceByStatusResponseBody {
	s.Success = &v
	return s
}

func (s *QueryDeviceByStatusResponseBody) SetTotal(v int32) *QueryDeviceByStatusResponseBody {
	s.Total = &v
	return s
}

type QueryDeviceByStatusResponseBodyData struct {
	SimpleDeviceInfo []*QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo `json:"SimpleDeviceInfo,omitempty" xml:"SimpleDeviceInfo,omitempty" type:"Repeated"`
}

func (s QueryDeviceByStatusResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceByStatusResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceByStatusResponseBodyData) SetSimpleDeviceInfo(v []*QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo) *QueryDeviceByStatusResponseBodyData {
	s.SimpleDeviceInfo = v
	return s
}

type QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo struct {
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The secret of the device.
	DeviceSecret *string `json:"DeviceSecret,omitempty" xml:"DeviceSecret,omitempty"`
	// The time when the device was created. The time is displayed in UTC.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The time when the device information was last modified. The time is displayed in UTC.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The alias of the device.
	Nickname *string `json:"Nickname,omitempty" xml:"Nickname,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The status of the device. Valid values:
	//
	// *   **UNACTIVE**: The device is not activated.
	// *   **ONLINE**: The device is online.
	// *   **OFFLINE**: The device is offline.
	// *   **DISABLE**: The device is disabled.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The time when the device was created. The time is displayed in UTC.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
	// The time when the device information was last modified. The time is displayed in UTC.
	UtcModified *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
}

func (s QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo) GoString() string {
	return s.String()
}

func (s *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo) SetDeviceName(v string) *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo) SetDeviceSecret(v string) *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo {
	s.DeviceSecret = &v
	return s
}

func (s *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo) SetGmtCreate(v string) *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo {
	s.GmtCreate = &v
	return s
}

func (s *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo) SetGmtModified(v string) *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo {
	s.GmtModified = &v
	return s
}

func (s *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo) SetIotId(v string) *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo {
	s.IotId = &v
	return s
}

func (s *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo) SetNickname(v string) *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo {
	s.Nickname = &v
	return s
}

func (s *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo) SetProductKey(v string) *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo {
	s.ProductKey = &v
	return s
}

func (s *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo) SetStatus(v string) *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo {
	s.Status = &v
	return s
}

func (s *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo) SetUtcCreate(v string) *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo {
	s.UtcCreate = &v
	return s
}

func (s *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo) SetUtcModified(v string) *QueryDeviceByStatusResponseBodyDataSimpleDeviceInfo {
	s.UtcModified = &v
	return s
}

type QueryDeviceByStatusResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceByStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceByStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceByStatusResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceByStatusResponse) SetHeaders(v map[string]*string) *QueryDeviceByStatusResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceByStatusResponse) SetStatusCode(v int32) *QueryDeviceByStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceByStatusResponse) SetBody(v *QueryDeviceByStatusResponseBody) *QueryDeviceByStatusResponse {
	s.Body = v
	return s
}

type QueryDeviceByTagsRequest struct {
	// The number of the page to return. Default value: 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Maximum value: 50. Default value: 10.
	PageSize *int32                         `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Tag      []*QueryDeviceByTagsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s QueryDeviceByTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceByTagsRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceByTagsRequest) SetCurrentPage(v int32) *QueryDeviceByTagsRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryDeviceByTagsRequest) SetIotInstanceId(v string) *QueryDeviceByTagsRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceByTagsRequest) SetPageSize(v int32) *QueryDeviceByTagsRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceByTagsRequest) SetTag(v []*QueryDeviceByTagsRequestTag) *QueryDeviceByTagsRequest {
	s.Tag = v
	return s
}

type QueryDeviceByTagsRequestTag struct {
	// The key of the device tag.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The value of the device tag.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s QueryDeviceByTagsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceByTagsRequestTag) GoString() string {
	return s.String()
}

func (s *QueryDeviceByTagsRequestTag) SetTagKey(v string) *QueryDeviceByTagsRequestTag {
	s.TagKey = &v
	return s
}

func (s *QueryDeviceByTagsRequestTag) SetTagValue(v string) *QueryDeviceByTagsRequestTag {
	s.TagValue = &v
	return s
}

type QueryDeviceByTagsResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The device information returned if the call succeeds. The **SimpleDeviceInfo** parameter includes the details of the devices.
	Data *QueryDeviceByTagsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The page number of the returned page.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The total number of pages.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries returned on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of records.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryDeviceByTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceByTagsResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceByTagsResponseBody) SetCode(v string) *QueryDeviceByTagsResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceByTagsResponseBody) SetData(v *QueryDeviceByTagsResponseBodyData) *QueryDeviceByTagsResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceByTagsResponseBody) SetErrorMessage(v string) *QueryDeviceByTagsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceByTagsResponseBody) SetPage(v int32) *QueryDeviceByTagsResponseBody {
	s.Page = &v
	return s
}

func (s *QueryDeviceByTagsResponseBody) SetPageCount(v int32) *QueryDeviceByTagsResponseBody {
	s.PageCount = &v
	return s
}

func (s *QueryDeviceByTagsResponseBody) SetPageSize(v int32) *QueryDeviceByTagsResponseBody {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceByTagsResponseBody) SetRequestId(v string) *QueryDeviceByTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceByTagsResponseBody) SetSuccess(v bool) *QueryDeviceByTagsResponseBody {
	s.Success = &v
	return s
}

func (s *QueryDeviceByTagsResponseBody) SetTotal(v int32) *QueryDeviceByTagsResponseBody {
	s.Total = &v
	return s
}

type QueryDeviceByTagsResponseBodyData struct {
	SimpleDeviceInfo []*QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo `json:"SimpleDeviceInfo,omitempty" xml:"SimpleDeviceInfo,omitempty" type:"Repeated"`
}

func (s QueryDeviceByTagsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceByTagsResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceByTagsResponseBodyData) SetSimpleDeviceInfo(v []*QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo) *QueryDeviceByTagsResponseBodyData {
	s.SimpleDeviceInfo = v
	return s
}

type QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo struct {
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The name of the product.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
}

func (s QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo) GoString() string {
	return s.String()
}

func (s *QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo) SetDeviceName(v string) *QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo) SetIotId(v string) *QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo {
	s.IotId = &v
	return s
}

func (s *QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo) SetProductKey(v string) *QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo {
	s.ProductKey = &v
	return s
}

func (s *QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo) SetProductName(v string) *QueryDeviceByTagsResponseBodyDataSimpleDeviceInfo {
	s.ProductName = &v
	return s
}

type QueryDeviceByTagsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceByTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceByTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceByTagsResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceByTagsResponse) SetHeaders(v map[string]*string) *QueryDeviceByTagsResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceByTagsResponse) SetStatusCode(v int32) *QueryDeviceByTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceByTagsResponse) SetBody(v *QueryDeviceByTagsResponseBody) *QueryDeviceByTagsResponse {
	s.Body = v
	return s
}

type QueryDeviceCertRequest struct {
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryDeviceCertRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceCertRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceCertRequest) SetDeviceName(v string) *QueryDeviceCertRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceCertRequest) SetIotInstanceId(v string) *QueryDeviceCertRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceCertRequest) SetProductKey(v string) *QueryDeviceCertRequest {
	s.ProductKey = &v
	return s
}

type QueryDeviceCertResponseBody struct {
	Code           *string                                    `json:"Code,omitempty" xml:"Code,omitempty"`
	DeviceCertInfo *QueryDeviceCertResponseBodyDeviceCertInfo `json:"DeviceCertInfo,omitempty" xml:"DeviceCertInfo,omitempty" type:"Struct"`
	ErrorMessage   *string                                    `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId      *string                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success        *bool                                      `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceCertResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceCertResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceCertResponseBody) SetCode(v string) *QueryDeviceCertResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceCertResponseBody) SetDeviceCertInfo(v *QueryDeviceCertResponseBodyDeviceCertInfo) *QueryDeviceCertResponseBody {
	s.DeviceCertInfo = v
	return s
}

func (s *QueryDeviceCertResponseBody) SetErrorMessage(v string) *QueryDeviceCertResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceCertResponseBody) SetRequestId(v string) *QueryDeviceCertResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceCertResponseBody) SetSuccess(v bool) *QueryDeviceCertResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceCertResponseBodyDeviceCertInfo struct {
	CertSN      *string `json:"CertSN,omitempty" xml:"CertSN,omitempty"`
	Certificate *string `json:"Certificate,omitempty" xml:"Certificate,omitempty"`
	PrivateKey  *string `json:"PrivateKey,omitempty" xml:"PrivateKey,omitempty"`
	Status      *int32  `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s QueryDeviceCertResponseBodyDeviceCertInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceCertResponseBodyDeviceCertInfo) GoString() string {
	return s.String()
}

func (s *QueryDeviceCertResponseBodyDeviceCertInfo) SetCertSN(v string) *QueryDeviceCertResponseBodyDeviceCertInfo {
	s.CertSN = &v
	return s
}

func (s *QueryDeviceCertResponseBodyDeviceCertInfo) SetCertificate(v string) *QueryDeviceCertResponseBodyDeviceCertInfo {
	s.Certificate = &v
	return s
}

func (s *QueryDeviceCertResponseBodyDeviceCertInfo) SetPrivateKey(v string) *QueryDeviceCertResponseBodyDeviceCertInfo {
	s.PrivateKey = &v
	return s
}

func (s *QueryDeviceCertResponseBodyDeviceCertInfo) SetStatus(v int32) *QueryDeviceCertResponseBodyDeviceCertInfo {
	s.Status = &v
	return s
}

type QueryDeviceCertResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceCertResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceCertResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceCertResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceCertResponse) SetHeaders(v map[string]*string) *QueryDeviceCertResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceCertResponse) SetStatusCode(v int32) *QueryDeviceCertResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceCertResponse) SetBody(v *QueryDeviceCertResponseBody) *QueryDeviceCertResponse {
	s.Body = v
	return s
}

type QueryDeviceDesiredPropertyRequest struct {
	// The DeviceName of the device.
	//
	// >  If you specify a value for this parameter, you must configure the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The identifier of the custom TSL module. Each identifier is unique in a product.
	//
	// If you do not configure this parameter, the system queries the data of the default module.
	FunctionBlockId *string   `json:"FunctionBlockId,omitempty" xml:"FunctionBlockId,omitempty"`
	Identifier      []*string `json:"Identifier,omitempty" xml:"Identifier,omitempty" type:"Repeated"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// >  If you specify a value for this parameter, you do not need to configure the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a GUID for the device. The value of the IotId parameter is equivalent to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify values for the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or ID is generated for your instance, you do not need configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >  If you specify a value for this parameter, you must configure the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryDeviceDesiredPropertyRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDesiredPropertyRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceDesiredPropertyRequest) SetDeviceName(v string) *QueryDeviceDesiredPropertyRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceDesiredPropertyRequest) SetFunctionBlockId(v string) *QueryDeviceDesiredPropertyRequest {
	s.FunctionBlockId = &v
	return s
}

func (s *QueryDeviceDesiredPropertyRequest) SetIdentifier(v []*string) *QueryDeviceDesiredPropertyRequest {
	s.Identifier = v
	return s
}

func (s *QueryDeviceDesiredPropertyRequest) SetIotId(v string) *QueryDeviceDesiredPropertyRequest {
	s.IotId = &v
	return s
}

func (s *QueryDeviceDesiredPropertyRequest) SetIotInstanceId(v string) *QueryDeviceDesiredPropertyRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceDesiredPropertyRequest) SetProductKey(v string) *QueryDeviceDesiredPropertyRequest {
	s.ProductKey = &v
	return s
}

type QueryDeviceDesiredPropertyResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned in the **List** parameter if the call is successful.
	Data *QueryDeviceDesiredPropertyResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message that is returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceDesiredPropertyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDesiredPropertyResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceDesiredPropertyResponseBody) SetCode(v string) *QueryDeviceDesiredPropertyResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceDesiredPropertyResponseBody) SetData(v *QueryDeviceDesiredPropertyResponseBodyData) *QueryDeviceDesiredPropertyResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceDesiredPropertyResponseBody) SetErrorMessage(v string) *QueryDeviceDesiredPropertyResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceDesiredPropertyResponseBody) SetRequestId(v string) *QueryDeviceDesiredPropertyResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceDesiredPropertyResponseBody) SetSuccess(v bool) *QueryDeviceDesiredPropertyResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceDesiredPropertyResponseBodyData struct {
	// The desired property information returned in the **DesiredPropertyInfo** parameter.
	List *QueryDeviceDesiredPropertyResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
}

func (s QueryDeviceDesiredPropertyResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDesiredPropertyResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceDesiredPropertyResponseBodyData) SetList(v *QueryDeviceDesiredPropertyResponseBodyDataList) *QueryDeviceDesiredPropertyResponseBodyData {
	s.List = v
	return s
}

type QueryDeviceDesiredPropertyResponseBodyDataList struct {
	DesiredPropertyInfo []*QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo `json:"DesiredPropertyInfo,omitempty" xml:"DesiredPropertyInfo,omitempty" type:"Repeated"`
}

func (s QueryDeviceDesiredPropertyResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDesiredPropertyResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryDeviceDesiredPropertyResponseBodyDataList) SetDesiredPropertyInfo(v []*QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo) *QueryDeviceDesiredPropertyResponseBodyDataList {
	s.DesiredPropertyInfo = v
	return s
}

type QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo struct {
	// The data type of the property.
	DataType *string `json:"DataType,omitempty" xml:"DataType,omitempty"`
	// The identifier of the property.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The name of the property.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The time when the desired value of the property was last modified. Unit: milliseconds.
	Time *string `json:"Time,omitempty" xml:"Time,omitempty"`
	// The unit of the property.
	Unit *string `json:"Unit,omitempty" xml:"Unit,omitempty"`
	// The desired value of the property.
	//
	// >  If you call the [ClearDeviceDesiredProperty](~~477431~~) operation to delete the desired value of the property, the **Value** parameter is not returned.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
	// The version of the desired value.
	Version *int64 `json:"Version,omitempty" xml:"Version,omitempty"`
}

func (s QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo) GoString() string {
	return s.String()
}

func (s *QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo) SetDataType(v string) *QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo {
	s.DataType = &v
	return s
}

func (s *QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo) SetIdentifier(v string) *QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo {
	s.Identifier = &v
	return s
}

func (s *QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo) SetName(v string) *QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo {
	s.Name = &v
	return s
}

func (s *QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo) SetTime(v string) *QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo {
	s.Time = &v
	return s
}

func (s *QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo) SetUnit(v string) *QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo {
	s.Unit = &v
	return s
}

func (s *QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo) SetValue(v string) *QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo {
	s.Value = &v
	return s
}

func (s *QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo) SetVersion(v int64) *QueryDeviceDesiredPropertyResponseBodyDataListDesiredPropertyInfo {
	s.Version = &v
	return s
}

type QueryDeviceDesiredPropertyResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceDesiredPropertyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceDesiredPropertyResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDesiredPropertyResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceDesiredPropertyResponse) SetHeaders(v map[string]*string) *QueryDeviceDesiredPropertyResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceDesiredPropertyResponse) SetStatusCode(v int32) *QueryDeviceDesiredPropertyResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceDesiredPropertyResponse) SetBody(v *QueryDeviceDesiredPropertyResponseBody) *QueryDeviceDesiredPropertyResponse {
	s.Body = v
	return s
}

type QueryDeviceDetailRequest struct {
	// The DeviceName of the device.
	//
	// >  If you specify a value for this parameter, you must also specify a value for the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device.
	//
	// >  If you specify a value for this parameter, you do not need to specify a value for the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a globally unique identifier (GUID) for the device. The value of the IotId parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for the **IotId** parameter and values for the **ProductKey** and **DeviceName** parameters, the value of the **IotId** takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >  If you specify a value for this parameter, you must also specify a value for the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryDeviceDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDetailRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceDetailRequest) SetDeviceName(v string) *QueryDeviceDetailRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceDetailRequest) SetIotId(v string) *QueryDeviceDetailRequest {
	s.IotId = &v
	return s
}

func (s *QueryDeviceDetailRequest) SetIotInstanceId(v string) *QueryDeviceDetailRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceDetailRequest) SetProductKey(v string) *QueryDeviceDetailRequest {
	s.ProductKey = &v
	return s
}

type QueryDeviceDetailResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The device details returned if the call is successful.
	Data *QueryDeviceDetailResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDetailResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceDetailResponseBody) SetCode(v string) *QueryDeviceDetailResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceDetailResponseBody) SetData(v *QueryDeviceDetailResponseBodyData) *QueryDeviceDetailResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceDetailResponseBody) SetErrorMessage(v string) *QueryDeviceDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceDetailResponseBody) SetRequestId(v string) *QueryDeviceDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceDetailResponseBody) SetSuccess(v bool) *QueryDeviceDetailResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceDetailResponseBodyData struct {
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The DeviceSecret of the device.
	DeviceSecret *string `json:"DeviceSecret,omitempty" xml:"DeviceSecret,omitempty"`
	// The version number of the default OTA module of the device.
	//
	// If you want to query the version information about other OTA modules, call the [ListOTAModuleVersionsByDevice](~~190622~~) operation. The version information is submitted by the device.
	FirmwareVersion *string `json:"FirmwareVersion,omitempty" xml:"FirmwareVersion,omitempty"`
	// The time when the device was activated. The time is in the GMT format.
	GmtActive *string `json:"GmtActive,omitempty" xml:"GmtActive,omitempty"`
	// The time when the device was created. The time is in the GMT format.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The most recent time when the device was online. The time is in the GMT format.
	GmtOnline *string `json:"GmtOnline,omitempty" xml:"GmtOnline,omitempty"`
	// The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The IP address of the device.
	IpAddress *string `json:"IpAddress,omitempty" xml:"IpAddress,omitempty"`
	// The alias of the device.
	Nickname *string `json:"Nickname,omitempty" xml:"Nickname,omitempty"`
	// The type of the node. Valid values:
	//
	// *   **0**: device. Sub-devices cannot be attached to a device. A device can connect to IoT Platform directly or as a sub-device of a gateway.
	// *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain the topological relationships with sub-devices, and synchronize the topological relationships to IoT Platform.
	NodeType *int32 `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// Indicates whether the operation is called by the owner of the device.
	Owner *bool `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The name of the product to which the device belongs.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
	// The ID of the region where the device resides. The region is the same as the region where IoT Platform resides. You can view the region in the IoT Platform console.
	Region *string `json:"Region,omitempty" xml:"Region,omitempty"`
	// The device status. Valid values: Valid values:
	//
	// *   **ONLINE**: The device is online.
	// *   **OFFLINE**: The device is offline.
	// *   **UNACTIVE**: The device is not activated.
	// *   **DISABLE**: The device is disabled.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The time when the device was activated. The time is in the UTC format.
	UtcActive *string `json:"UtcActive,omitempty" xml:"UtcActive,omitempty"`
	// The time when the device was created. The time is in the UTC format.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
	// The most recent time when the device was online. The time is in the UTC format.
	UtcOnline *string `json:"UtcOnline,omitempty" xml:"UtcOnline,omitempty"`
}

func (s QueryDeviceDetailResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDetailResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceDetailResponseBodyData) SetDeviceName(v string) *QueryDeviceDetailResponseBodyData {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetDeviceSecret(v string) *QueryDeviceDetailResponseBodyData {
	s.DeviceSecret = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetFirmwareVersion(v string) *QueryDeviceDetailResponseBodyData {
	s.FirmwareVersion = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetGmtActive(v string) *QueryDeviceDetailResponseBodyData {
	s.GmtActive = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetGmtCreate(v string) *QueryDeviceDetailResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetGmtOnline(v string) *QueryDeviceDetailResponseBodyData {
	s.GmtOnline = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetIotId(v string) *QueryDeviceDetailResponseBodyData {
	s.IotId = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetIpAddress(v string) *QueryDeviceDetailResponseBodyData {
	s.IpAddress = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetNickname(v string) *QueryDeviceDetailResponseBodyData {
	s.Nickname = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetNodeType(v int32) *QueryDeviceDetailResponseBodyData {
	s.NodeType = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetOwner(v bool) *QueryDeviceDetailResponseBodyData {
	s.Owner = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetProductKey(v string) *QueryDeviceDetailResponseBodyData {
	s.ProductKey = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetProductName(v string) *QueryDeviceDetailResponseBodyData {
	s.ProductName = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetRegion(v string) *QueryDeviceDetailResponseBodyData {
	s.Region = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetStatus(v string) *QueryDeviceDetailResponseBodyData {
	s.Status = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetUtcActive(v string) *QueryDeviceDetailResponseBodyData {
	s.UtcActive = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetUtcCreate(v string) *QueryDeviceDetailResponseBodyData {
	s.UtcCreate = &v
	return s
}

func (s *QueryDeviceDetailResponseBodyData) SetUtcOnline(v string) *QueryDeviceDetailResponseBodyData {
	s.UtcOnline = &v
	return s
}

type QueryDeviceDetailResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDetailResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceDetailResponse) SetHeaders(v map[string]*string) *QueryDeviceDetailResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceDetailResponse) SetStatusCode(v int32) *QueryDeviceDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceDetailResponse) SetBody(v *QueryDeviceDetailResponseBody) *QueryDeviceDetailResponse {
	s.Body = v
	return s
}

type QueryDeviceDistributeDetailRequest struct {
	// The ID of the distribution task. The ID globally identifies the task.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s QueryDeviceDistributeDetailRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDistributeDetailRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceDistributeDetailRequest) SetJobId(v string) *QueryDeviceDistributeDetailRequest {
	s.JobId = &v
	return s
}

type QueryDeviceDistributeDetailResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The URL of the file that contains the distribution result. The URL indicates a storage location of the file in Object Storage Service (OSS). The URL is valid for 10 minutes.
	File *string `json:"File,omitempty" xml:"File,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceDistributeDetailResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDistributeDetailResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceDistributeDetailResponseBody) SetCode(v string) *QueryDeviceDistributeDetailResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceDistributeDetailResponseBody) SetErrorMessage(v string) *QueryDeviceDistributeDetailResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceDistributeDetailResponseBody) SetFile(v string) *QueryDeviceDistributeDetailResponseBody {
	s.File = &v
	return s
}

func (s *QueryDeviceDistributeDetailResponseBody) SetRequestId(v string) *QueryDeviceDistributeDetailResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceDistributeDetailResponseBody) SetSuccess(v bool) *QueryDeviceDistributeDetailResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceDistributeDetailResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceDistributeDetailResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceDistributeDetailResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDistributeDetailResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceDistributeDetailResponse) SetHeaders(v map[string]*string) *QueryDeviceDistributeDetailResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceDistributeDetailResponse) SetStatusCode(v int32) *QueryDeviceDistributeDetailResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceDistributeDetailResponse) SetBody(v *QueryDeviceDistributeDetailResponseBody) *QueryDeviceDistributeDetailResponse {
	s.Body = v
	return s
}

type QueryDeviceDistributeJobRequest struct {
	// The ID of the distribution task. The ID globally identifies the task.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s QueryDeviceDistributeJobRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDistributeJobRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceDistributeJobRequest) SetJobId(v string) *QueryDeviceDistributeJobRequest {
	s.JobId = &v
	return s
}

type QueryDeviceDistributeJobResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The task information returned if the call is successful.
	Data *QueryDeviceDistributeJobResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceDistributeJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDistributeJobResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceDistributeJobResponseBody) SetCode(v string) *QueryDeviceDistributeJobResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceDistributeJobResponseBody) SetData(v *QueryDeviceDistributeJobResponseBodyData) *QueryDeviceDistributeJobResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceDistributeJobResponseBody) SetErrorMessage(v string) *QueryDeviceDistributeJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceDistributeJobResponseBody) SetRequestId(v string) *QueryDeviceDistributeJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceDistributeJobResponseBody) SetSuccess(v bool) *QueryDeviceDistributeJobResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceDistributeJobResponseBodyData struct {
	// The time when the task was created.
	GmtCreate *int64 `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The ID of the distribution task.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the source instance.
	SourceInstanceId *string `json:"SourceInstanceId,omitempty" xml:"SourceInstanceId,omitempty"`
	// The ID of the Alibaba Cloud account.
	SourceUid *string `json:"SourceUid,omitempty" xml:"SourceUid,omitempty"`
	// The status of the distribution task.
	//
	// *   **0**: The task is being initialized.
	// *   **1**: The task is being implemented.
	// *   **2**: The task is completed. This status only indicates that the distribution task is completed. This status does not indicate that all products and devices are distributed. To obtain distribution results, call the [QueryDeviceDistributeDetail](~~199533~~) operation.
	// *   **3**: The task is unexpectedly interrupted.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The distribution policy.
	//
	// *   **0**: distributes devices to instances in a specified region.
	// *   **1**: configures instance IDs in multiple regions and distributes devices to the nearest regions based on the IP addresses of the devices.
	Strategy *int32 `json:"Strategy,omitempty" xml:"Strategy,omitempty"`
	// The IDs of the destination instances.
	//
	// *   If the value of the **Strategy** parameter is **1**, multiple instance IDs exist.
	// *   If the value of the **Strategy** parameter is **0**, only one instance ID exists.
	TargetInstanceConfigs *QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs `json:"TargetInstanceConfigs,omitempty" xml:"TargetInstanceConfigs,omitempty" type:"Struct"`
	TargetUid             *string                                                        `json:"TargetUid,omitempty" xml:"TargetUid,omitempty"`
	// The total number of devices in the distribution task.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryDeviceDistributeJobResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDistributeJobResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceDistributeJobResponseBodyData) SetGmtCreate(v int64) *QueryDeviceDistributeJobResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *QueryDeviceDistributeJobResponseBodyData) SetJobId(v string) *QueryDeviceDistributeJobResponseBodyData {
	s.JobId = &v
	return s
}

func (s *QueryDeviceDistributeJobResponseBodyData) SetProductKey(v string) *QueryDeviceDistributeJobResponseBodyData {
	s.ProductKey = &v
	return s
}

func (s *QueryDeviceDistributeJobResponseBodyData) SetSourceInstanceId(v string) *QueryDeviceDistributeJobResponseBodyData {
	s.SourceInstanceId = &v
	return s
}

func (s *QueryDeviceDistributeJobResponseBodyData) SetSourceUid(v string) *QueryDeviceDistributeJobResponseBodyData {
	s.SourceUid = &v
	return s
}

func (s *QueryDeviceDistributeJobResponseBodyData) SetStatus(v int32) *QueryDeviceDistributeJobResponseBodyData {
	s.Status = &v
	return s
}

func (s *QueryDeviceDistributeJobResponseBodyData) SetStrategy(v int32) *QueryDeviceDistributeJobResponseBodyData {
	s.Strategy = &v
	return s
}

func (s *QueryDeviceDistributeJobResponseBodyData) SetTargetInstanceConfigs(v *QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs) *QueryDeviceDistributeJobResponseBodyData {
	s.TargetInstanceConfigs = v
	return s
}

func (s *QueryDeviceDistributeJobResponseBodyData) SetTargetUid(v string) *QueryDeviceDistributeJobResponseBodyData {
	s.TargetUid = &v
	return s
}

func (s *QueryDeviceDistributeJobResponseBodyData) SetTotal(v int32) *QueryDeviceDistributeJobResponseBodyData {
	s.Total = &v
	return s
}

type QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs struct {
	TargetInstanceConfigs []*QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs `json:"targetInstanceConfigs,omitempty" xml:"targetInstanceConfigs,omitempty" type:"Repeated"`
}

func (s QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs) GoString() string {
	return s.String()
}

func (s *QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs) SetTargetInstanceConfigs(v []*QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs) *QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigs {
	s.TargetInstanceConfigs = v
	return s
}

type QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs struct {
	// The ID of the destination instance.
	TargetInstanceId *string `json:"TargetInstanceId,omitempty" xml:"TargetInstanceId,omitempty"`
}

func (s QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs) GoString() string {
	return s.String()
}

func (s *QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs) SetTargetInstanceId(v string) *QueryDeviceDistributeJobResponseBodyDataTargetInstanceConfigsTargetInstanceConfigs {
	s.TargetInstanceId = &v
	return s
}

type QueryDeviceDistributeJobResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceDistributeJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceDistributeJobResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceDistributeJobResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceDistributeJobResponse) SetHeaders(v map[string]*string) *QueryDeviceDistributeJobResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceDistributeJobResponse) SetStatusCode(v int32) *QueryDeviceDistributeJobResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceDistributeJobResponse) SetBody(v *QueryDeviceDistributeJobResponseBody) *QueryDeviceDistributeJobResponse {
	s.Body = v
	return s
}

type QueryDeviceEventDataRequest struct {
	// The order in which you want to sort the returned event records. Valid values:
	//
	// *   **0**: in reverse chronological order. This is the default value.
	// *   **1**: in chronological order.
	//
	// >  If you do not configure this parameter, the default value **0** is used. The system sorts the returned event records in reverse chronological order.
	Asc *int32 `json:"Asc,omitempty" xml:"Asc,omitempty"`
	// The DeviceName of the device.
	//
	// >  If you specify a value for this parameter, you must also specify a value for the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The end of the time range to query. The value is a 13-digit timestamp in milliseconds. Example: 1516541900303.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The type of the event that you want to query. Valid values:
	//
	// *   **info**: Information.
	// *   **alert**: Alert.
	// *   **error**: Error.
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// The identifier of the event that you want to query. You can view the event identifier on the Define Feature tab of the Product Details page in the IoT Platform console. You can also call the [QueryThingModel](~~150321~~) operation and view the event identifier in the returned TSL data.
	//
	// >  If the PowerOff event belongs to a custom module named testFb, this parameter is set to **testFb:PowerOff**.
	//
	// If you do not specify this parameter, the system queries all event data of the default module and custom modules.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// >  If you specify a value for this parameter, you do not need to specify a value for the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a globally unique identifier (GUID) for the device. The value of the IotId parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for the **IotId** parameter and values for the **ProductKey** and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify this parameter. Otherwise, the call fails.
	// >*   If the **Overview** page does not appear in the IoT Platform console or no ID is generated for your instance, you do not need to specify this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 50. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The beginning of the time range to query. The value is a 13-digit timestamp in milliseconds. Example: 1516538300303.
	//
	// >  You can query the event data only of the most recent 30 days.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s QueryDeviceEventDataRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceEventDataRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceEventDataRequest) SetAsc(v int32) *QueryDeviceEventDataRequest {
	s.Asc = &v
	return s
}

func (s *QueryDeviceEventDataRequest) SetDeviceName(v string) *QueryDeviceEventDataRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceEventDataRequest) SetEndTime(v int64) *QueryDeviceEventDataRequest {
	s.EndTime = &v
	return s
}

func (s *QueryDeviceEventDataRequest) SetEventType(v string) *QueryDeviceEventDataRequest {
	s.EventType = &v
	return s
}

func (s *QueryDeviceEventDataRequest) SetIdentifier(v string) *QueryDeviceEventDataRequest {
	s.Identifier = &v
	return s
}

func (s *QueryDeviceEventDataRequest) SetIotId(v string) *QueryDeviceEventDataRequest {
	s.IotId = &v
	return s
}

func (s *QueryDeviceEventDataRequest) SetIotInstanceId(v string) *QueryDeviceEventDataRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceEventDataRequest) SetPageSize(v int32) *QueryDeviceEventDataRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceEventDataRequest) SetProductKey(v string) *QueryDeviceEventDataRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryDeviceEventDataRequest) SetStartTime(v int64) *QueryDeviceEventDataRequest {
	s.StartTime = &v
	return s
}

type QueryDeviceEventDataResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The event records returned if the call succeeds.
	Data *QueryDeviceEventDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceEventDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceEventDataResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceEventDataResponseBody) SetCode(v string) *QueryDeviceEventDataResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceEventDataResponseBody) SetData(v *QueryDeviceEventDataResponseBodyData) *QueryDeviceEventDataResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceEventDataResponseBody) SetErrorMessage(v string) *QueryDeviceEventDataResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceEventDataResponseBody) SetRequestId(v string) *QueryDeviceEventDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceEventDataResponseBody) SetSuccess(v bool) *QueryDeviceEventDataResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceEventDataResponseBodyData struct {
	// The array of events. Each element represents an event.
	List *QueryDeviceEventDataResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	// The start time of the event records on the next page. The value is a timestamp in milliseconds.
	//
	// - If the **Asc** parameter is set to 0, you can specify this value for the **EndTime** parameter when you call this operation again to query the next page of event records.
	// - If the **Asc** parameter is set to 1, you can specify this value for the **StartTime** parameter when you call this operation again to query the next page of event records.
	NextTime *int64 `json:"NextTime,omitempty" xml:"NextTime,omitempty"`
	// Indicates whether the next page exists.
	//
	// *   **true**: The next page exists. The value of the **NextTime** parameter is returned. For more information, see the description of the **NextTime** parameter in this topic.
	// *   **false**: The next page does not exist.
	NextValid *bool `json:"NextValid,omitempty" xml:"NextValid,omitempty"`
}

func (s QueryDeviceEventDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceEventDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceEventDataResponseBodyData) SetList(v *QueryDeviceEventDataResponseBodyDataList) *QueryDeviceEventDataResponseBodyData {
	s.List = v
	return s
}

func (s *QueryDeviceEventDataResponseBodyData) SetNextTime(v int64) *QueryDeviceEventDataResponseBodyData {
	s.NextTime = &v
	return s
}

func (s *QueryDeviceEventDataResponseBodyData) SetNextValid(v bool) *QueryDeviceEventDataResponseBodyData {
	s.NextValid = &v
	return s
}

type QueryDeviceEventDataResponseBodyDataList struct {
	EventInfo []*QueryDeviceEventDataResponseBodyDataListEventInfo `json:"EventInfo,omitempty" xml:"EventInfo,omitempty" type:"Repeated"`
}

func (s QueryDeviceEventDataResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceEventDataResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryDeviceEventDataResponseBodyDataList) SetEventInfo(v []*QueryDeviceEventDataResponseBodyDataListEventInfo) *QueryDeviceEventDataResponseBodyDataList {
	s.EventInfo = v
	return s
}

type QueryDeviceEventDataResponseBodyDataListEventInfo struct {
	// The type of the event. Valid values:
	//
	// *   **info**: information.
	// *   **alert**: alert.
	// *   **error**: error.
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// The identifier of the event.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The name of the event.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The output parameter of the event. The value is a string in the MAP format.
	OutputData *string `json:"OutputData,omitempty" xml:"OutputData,omitempty"`
	// The time when the event occurred. The value is a timestamp in milliseconds.
	Time *string `json:"Time,omitempty" xml:"Time,omitempty"`
}

func (s QueryDeviceEventDataResponseBodyDataListEventInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceEventDataResponseBodyDataListEventInfo) GoString() string {
	return s.String()
}

func (s *QueryDeviceEventDataResponseBodyDataListEventInfo) SetEventType(v string) *QueryDeviceEventDataResponseBodyDataListEventInfo {
	s.EventType = &v
	return s
}

func (s *QueryDeviceEventDataResponseBodyDataListEventInfo) SetIdentifier(v string) *QueryDeviceEventDataResponseBodyDataListEventInfo {
	s.Identifier = &v
	return s
}

func (s *QueryDeviceEventDataResponseBodyDataListEventInfo) SetName(v string) *QueryDeviceEventDataResponseBodyDataListEventInfo {
	s.Name = &v
	return s
}

func (s *QueryDeviceEventDataResponseBodyDataListEventInfo) SetOutputData(v string) *QueryDeviceEventDataResponseBodyDataListEventInfo {
	s.OutputData = &v
	return s
}

func (s *QueryDeviceEventDataResponseBodyDataListEventInfo) SetTime(v string) *QueryDeviceEventDataResponseBodyDataListEventInfo {
	s.Time = &v
	return s
}

type QueryDeviceEventDataResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceEventDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceEventDataResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceEventDataResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceEventDataResponse) SetHeaders(v map[string]*string) *QueryDeviceEventDataResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceEventDataResponse) SetStatusCode(v int32) *QueryDeviceEventDataResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceEventDataResponse) SetBody(v *QueryDeviceEventDataResponseBody) *QueryDeviceEventDataResponse {
	s.Body = v
	return s
}

type QueryDeviceFileRequest struct {
	// The name of the device.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the file. You can call the [QueryDeviceFileList](~~112001~~) operation and view the file ID in the response.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The ID of the device. The device ID is issued by IoT Platform.
	//
	// >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryDeviceFileRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceFileRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceFileRequest) SetDeviceName(v string) *QueryDeviceFileRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceFileRequest) SetFileId(v string) *QueryDeviceFileRequest {
	s.FileId = &v
	return s
}

func (s *QueryDeviceFileRequest) SetIotId(v string) *QueryDeviceFileRequest {
	s.IotId = &v
	return s
}

func (s *QueryDeviceFileRequest) SetIotInstanceId(v string) *QueryDeviceFileRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceFileRequest) SetProductKey(v string) *QueryDeviceFileRequest {
	s.ProductKey = &v
	return s
}

type QueryDeviceFileResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The file information returned if the call succeeds.
	Data *QueryDeviceFileResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceFileResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceFileResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceFileResponseBody) SetCode(v string) *QueryDeviceFileResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceFileResponseBody) SetData(v *QueryDeviceFileResponseBodyData) *QueryDeviceFileResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceFileResponseBody) SetErrorMessage(v string) *QueryDeviceFileResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceFileResponseBody) SetRequestId(v string) *QueryDeviceFileResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceFileResponseBody) SetSuccess(v bool) *QueryDeviceFileResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceFileResponseBodyData struct {
	// The download URL of the file.
	DownloadUrl *string `json:"DownloadUrl,omitempty" xml:"DownloadUrl,omitempty"`
	// The ID of the file.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The name of the file.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The size of the file. Unit: KB.
	Size *string `json:"Size,omitempty" xml:"Size,omitempty"`
	// The time when the file was created.
	UtcCreatedOn *string `json:"UtcCreatedOn,omitempty" xml:"UtcCreatedOn,omitempty"`
}

func (s QueryDeviceFileResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceFileResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceFileResponseBodyData) SetDownloadUrl(v string) *QueryDeviceFileResponseBodyData {
	s.DownloadUrl = &v
	return s
}

func (s *QueryDeviceFileResponseBodyData) SetFileId(v string) *QueryDeviceFileResponseBodyData {
	s.FileId = &v
	return s
}

func (s *QueryDeviceFileResponseBodyData) SetName(v string) *QueryDeviceFileResponseBodyData {
	s.Name = &v
	return s
}

func (s *QueryDeviceFileResponseBodyData) SetSize(v string) *QueryDeviceFileResponseBodyData {
	s.Size = &v
	return s
}

func (s *QueryDeviceFileResponseBodyData) SetUtcCreatedOn(v string) *QueryDeviceFileResponseBodyData {
	s.UtcCreatedOn = &v
	return s
}

type QueryDeviceFileResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceFileResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceFileResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceFileResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceFileResponse) SetHeaders(v map[string]*string) *QueryDeviceFileResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceFileResponse) SetStatusCode(v int32) *QueryDeviceFileResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceFileResponse) SetBody(v *QueryDeviceFileResponseBody) *QueryDeviceFileResponse {
	s.Body = v
	return s
}

type QueryDeviceFileListRequest struct {
	// The number of the page to return. Pages start from page 1. Default value: 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The DeviceName of the device.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The device ID is issued by IoT Platform.
	//
	// >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Maximum value: 200. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryDeviceFileListRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceFileListRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceFileListRequest) SetCurrentPage(v int32) *QueryDeviceFileListRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryDeviceFileListRequest) SetDeviceName(v string) *QueryDeviceFileListRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceFileListRequest) SetIotId(v string) *QueryDeviceFileListRequest {
	s.IotId = &v
	return s
}

func (s *QueryDeviceFileListRequest) SetIotInstanceId(v string) *QueryDeviceFileListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceFileListRequest) SetPageSize(v int32) *QueryDeviceFileListRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceFileListRequest) SetProductKey(v string) *QueryDeviceFileListRequest {
	s.ProductKey = &v
	return s
}

type QueryDeviceFileListResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The file list information returned if the call succeeds.
	Data *QueryDeviceFileListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The total number of pages.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of files.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryDeviceFileListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceFileListResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceFileListResponseBody) SetCode(v string) *QueryDeviceFileListResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceFileListResponseBody) SetCurrentPage(v int32) *QueryDeviceFileListResponseBody {
	s.CurrentPage = &v
	return s
}

func (s *QueryDeviceFileListResponseBody) SetData(v *QueryDeviceFileListResponseBodyData) *QueryDeviceFileListResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceFileListResponseBody) SetErrorMessage(v string) *QueryDeviceFileListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceFileListResponseBody) SetPageCount(v int32) *QueryDeviceFileListResponseBody {
	s.PageCount = &v
	return s
}

func (s *QueryDeviceFileListResponseBody) SetPageSize(v int32) *QueryDeviceFileListResponseBody {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceFileListResponseBody) SetRequestId(v string) *QueryDeviceFileListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceFileListResponseBody) SetSuccess(v bool) *QueryDeviceFileListResponseBody {
	s.Success = &v
	return s
}

func (s *QueryDeviceFileListResponseBody) SetTotal(v int32) *QueryDeviceFileListResponseBody {
	s.Total = &v
	return s
}

type QueryDeviceFileListResponseBodyData struct {
	FileSummary []*QueryDeviceFileListResponseBodyDataFileSummary `json:"FileSummary,omitempty" xml:"FileSummary,omitempty" type:"Repeated"`
}

func (s QueryDeviceFileListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceFileListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceFileListResponseBodyData) SetFileSummary(v []*QueryDeviceFileListResponseBodyDataFileSummary) *QueryDeviceFileListResponseBodyData {
	s.FileSummary = v
	return s
}

type QueryDeviceFileListResponseBodyDataFileSummary struct {
	// The ID of each file. The ID is the unique identifier for the file.
	FileId *string `json:"FileId,omitempty" xml:"FileId,omitempty"`
	// The name of the file.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The size of the file. Unit: KB.
	Size *string `json:"Size,omitempty" xml:"Size,omitempty"`
	// The time when the file was created.
	UtcCreatedOn *string `json:"UtcCreatedOn,omitempty" xml:"UtcCreatedOn,omitempty"`
}

func (s QueryDeviceFileListResponseBodyDataFileSummary) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceFileListResponseBodyDataFileSummary) GoString() string {
	return s.String()
}

func (s *QueryDeviceFileListResponseBodyDataFileSummary) SetFileId(v string) *QueryDeviceFileListResponseBodyDataFileSummary {
	s.FileId = &v
	return s
}

func (s *QueryDeviceFileListResponseBodyDataFileSummary) SetName(v string) *QueryDeviceFileListResponseBodyDataFileSummary {
	s.Name = &v
	return s
}

func (s *QueryDeviceFileListResponseBodyDataFileSummary) SetSize(v string) *QueryDeviceFileListResponseBodyDataFileSummary {
	s.Size = &v
	return s
}

func (s *QueryDeviceFileListResponseBodyDataFileSummary) SetUtcCreatedOn(v string) *QueryDeviceFileListResponseBodyDataFileSummary {
	s.UtcCreatedOn = &v
	return s
}

type QueryDeviceFileListResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceFileListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceFileListResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceFileListResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceFileListResponse) SetHeaders(v map[string]*string) *QueryDeviceFileListResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceFileListResponse) SetStatusCode(v int32) *QueryDeviceFileListResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceFileListResponse) SetBody(v *QueryDeviceFileListResponseBody) *QueryDeviceFileListResponse {
	s.Body = v
	return s
}

type QueryDeviceGroupByDeviceRequest struct {
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryDeviceGroupByDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupByDeviceRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupByDeviceRequest) SetDeviceName(v string) *QueryDeviceGroupByDeviceRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceGroupByDeviceRequest) SetIotInstanceId(v string) *QueryDeviceGroupByDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceGroupByDeviceRequest) SetProductKey(v string) *QueryDeviceGroupByDeviceRequest {
	s.ProductKey = &v
	return s
}

type QueryDeviceGroupByDeviceResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The group information returned if the call succeeds. For more information, see the following GroupInfo parameter.
	GroupInfos *QueryDeviceGroupByDeviceResponseBodyGroupInfos `json:"GroupInfos,omitempty" xml:"GroupInfos,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceGroupByDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupByDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupByDeviceResponseBody) SetCode(v string) *QueryDeviceGroupByDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceGroupByDeviceResponseBody) SetErrorMessage(v string) *QueryDeviceGroupByDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceGroupByDeviceResponseBody) SetGroupInfos(v *QueryDeviceGroupByDeviceResponseBodyGroupInfos) *QueryDeviceGroupByDeviceResponseBody {
	s.GroupInfos = v
	return s
}

func (s *QueryDeviceGroupByDeviceResponseBody) SetRequestId(v string) *QueryDeviceGroupByDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceGroupByDeviceResponseBody) SetSuccess(v bool) *QueryDeviceGroupByDeviceResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceGroupByDeviceResponseBodyGroupInfos struct {
	GroupInfo []*QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo `json:"GroupInfo,omitempty" xml:"GroupInfo,omitempty" type:"Repeated"`
}

func (s QueryDeviceGroupByDeviceResponseBodyGroupInfos) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupByDeviceResponseBodyGroupInfos) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupByDeviceResponseBodyGroupInfos) SetGroupInfo(v []*QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo) *QueryDeviceGroupByDeviceResponseBodyGroupInfos {
	s.GroupInfo = v
	return s
}

type QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo struct {
	// The description of the group.
	GroupDesc *string `json:"GroupDesc,omitempty" xml:"GroupDesc,omitempty"`
	// The ID of the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The type of the group.
	GroupType *string `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The time when the group was created.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
}

func (s QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo) SetGroupDesc(v string) *QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo {
	s.GroupDesc = &v
	return s
}

func (s *QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo) SetGroupId(v string) *QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo {
	s.GroupId = &v
	return s
}

func (s *QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo) SetGroupName(v string) *QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo {
	s.GroupName = &v
	return s
}

func (s *QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo) SetGroupType(v string) *QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo {
	s.GroupType = &v
	return s
}

func (s *QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo) SetUtcCreate(v string) *QueryDeviceGroupByDeviceResponseBodyGroupInfosGroupInfo {
	s.UtcCreate = &v
	return s
}

type QueryDeviceGroupByDeviceResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceGroupByDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceGroupByDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupByDeviceResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupByDeviceResponse) SetHeaders(v map[string]*string) *QueryDeviceGroupByDeviceResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceGroupByDeviceResponse) SetStatusCode(v int32) *QueryDeviceGroupByDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceGroupByDeviceResponse) SetBody(v *QueryDeviceGroupByDeviceResponseBody) *QueryDeviceGroupByDeviceResponse {
	s.Body = v
	return s
}

type QueryDeviceGroupByTagsRequest struct {
	// The number of the page to return. Default value: 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Default value: 10.
	PageSize *int32                              `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Tag      []*QueryDeviceGroupByTagsRequestTag `json:"Tag,omitempty" xml:"Tag,omitempty" type:"Repeated"`
}

func (s QueryDeviceGroupByTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupByTagsRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupByTagsRequest) SetCurrentPage(v int32) *QueryDeviceGroupByTagsRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryDeviceGroupByTagsRequest) SetIotInstanceId(v string) *QueryDeviceGroupByTagsRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceGroupByTagsRequest) SetPageSize(v int32) *QueryDeviceGroupByTagsRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceGroupByTagsRequest) SetTag(v []*QueryDeviceGroupByTagsRequestTag) *QueryDeviceGroupByTagsRequest {
	s.Tag = v
	return s
}

type QueryDeviceGroupByTagsRequestTag struct {
	// The key of each tag.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The value of the tag.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s QueryDeviceGroupByTagsRequestTag) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupByTagsRequestTag) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupByTagsRequestTag) SetTagKey(v string) *QueryDeviceGroupByTagsRequestTag {
	s.TagKey = &v
	return s
}

func (s *QueryDeviceGroupByTagsRequestTag) SetTagValue(v string) *QueryDeviceGroupByTagsRequestTag {
	s.TagValue = &v
	return s
}

type QueryDeviceGroupByTagsResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The group information returned if the call succeeds.
	Data *QueryDeviceGroupByTagsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The number of the returned page.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The total number of pages.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries returned on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of records.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryDeviceGroupByTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupByTagsResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupByTagsResponseBody) SetCode(v string) *QueryDeviceGroupByTagsResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceGroupByTagsResponseBody) SetData(v *QueryDeviceGroupByTagsResponseBodyData) *QueryDeviceGroupByTagsResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceGroupByTagsResponseBody) SetErrorMessage(v string) *QueryDeviceGroupByTagsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceGroupByTagsResponseBody) SetPage(v int32) *QueryDeviceGroupByTagsResponseBody {
	s.Page = &v
	return s
}

func (s *QueryDeviceGroupByTagsResponseBody) SetPageCount(v int32) *QueryDeviceGroupByTagsResponseBody {
	s.PageCount = &v
	return s
}

func (s *QueryDeviceGroupByTagsResponseBody) SetPageSize(v int32) *QueryDeviceGroupByTagsResponseBody {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceGroupByTagsResponseBody) SetRequestId(v string) *QueryDeviceGroupByTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceGroupByTagsResponseBody) SetSuccess(v bool) *QueryDeviceGroupByTagsResponseBody {
	s.Success = &v
	return s
}

func (s *QueryDeviceGroupByTagsResponseBody) SetTotal(v int32) *QueryDeviceGroupByTagsResponseBody {
	s.Total = &v
	return s
}

type QueryDeviceGroupByTagsResponseBodyData struct {
	DeviceGroup []*QueryDeviceGroupByTagsResponseBodyDataDeviceGroup `json:"DeviceGroup,omitempty" xml:"DeviceGroup,omitempty" type:"Repeated"`
}

func (s QueryDeviceGroupByTagsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupByTagsResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupByTagsResponseBodyData) SetDeviceGroup(v []*QueryDeviceGroupByTagsResponseBodyDataDeviceGroup) *QueryDeviceGroupByTagsResponseBodyData {
	s.DeviceGroup = v
	return s
}

type QueryDeviceGroupByTagsResponseBodyDataDeviceGroup struct {
	// The ID of the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
}

func (s QueryDeviceGroupByTagsResponseBodyDataDeviceGroup) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupByTagsResponseBodyDataDeviceGroup) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupByTagsResponseBodyDataDeviceGroup) SetGroupId(v string) *QueryDeviceGroupByTagsResponseBodyDataDeviceGroup {
	s.GroupId = &v
	return s
}

func (s *QueryDeviceGroupByTagsResponseBodyDataDeviceGroup) SetGroupName(v string) *QueryDeviceGroupByTagsResponseBodyDataDeviceGroup {
	s.GroupName = &v
	return s
}

type QueryDeviceGroupByTagsResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceGroupByTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceGroupByTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupByTagsResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupByTagsResponse) SetHeaders(v map[string]*string) *QueryDeviceGroupByTagsResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceGroupByTagsResponse) SetStatusCode(v int32) *QueryDeviceGroupByTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceGroupByTagsResponse) SetBody(v *QueryDeviceGroupByTagsResponseBody) *QueryDeviceGroupByTagsResponse {
	s.Body = v
	return s
}

type QueryDeviceGroupInfoRequest struct {
	// The ID of the group. The ID is the globally unique identifier (GUID) for the group.
	//
	// You can call the [QueryDeviceGroupList](~~93356~~) operation to query the **GroupId** parameter.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The type of the group.
	//
	// Set the value to **LINK_PLATFORM_DYNAMIC**. This value indicates a dynamic group. If you do not specify this parameter, a static group is queried by default.
	GroupType *string `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s QueryDeviceGroupInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupInfoRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupInfoRequest) SetGroupId(v string) *QueryDeviceGroupInfoRequest {
	s.GroupId = &v
	return s
}

func (s *QueryDeviceGroupInfoRequest) SetGroupType(v string) *QueryDeviceGroupInfoRequest {
	s.GroupType = &v
	return s
}

func (s *QueryDeviceGroupInfoRequest) SetIotInstanceId(v string) *QueryDeviceGroupInfoRequest {
	s.IotInstanceId = &v
	return s
}

type QueryDeviceGroupInfoResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The group details returned if the call succeeds. This parameter includes the following parameters.
	Data *QueryDeviceGroupInfoResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceGroupInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupInfoResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupInfoResponseBody) SetCode(v string) *QueryDeviceGroupInfoResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceGroupInfoResponseBody) SetData(v *QueryDeviceGroupInfoResponseBodyData) *QueryDeviceGroupInfoResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceGroupInfoResponseBody) SetErrorMessage(v string) *QueryDeviceGroupInfoResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceGroupInfoResponseBody) SetRequestId(v string) *QueryDeviceGroupInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceGroupInfoResponseBody) SetSuccess(v bool) *QueryDeviceGroupInfoResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceGroupInfoResponseBodyData struct {
	// The number of activated devices.
	DeviceActive *int32 `json:"DeviceActive,omitempty" xml:"DeviceActive,omitempty"`
	// The total number of devices.
	DeviceCount *int32 `json:"DeviceCount,omitempty" xml:"DeviceCount,omitempty"`
	// The number of online devices.
	DeviceOnline *int32 `json:"DeviceOnline,omitempty" xml:"DeviceOnline,omitempty"`
	// The rule of the dynamic group. This parameter is returned if a dynamic group is queried.
	DynamicGroupExpression *string `json:"DynamicGroupExpression,omitempty" xml:"DynamicGroupExpression,omitempty"`
	// The description of the group.
	GroupDesc *string `json:"GroupDesc,omitempty" xml:"GroupDesc,omitempty"`
	// The ID of the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The time when the group was created.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
}

func (s QueryDeviceGroupInfoResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupInfoResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupInfoResponseBodyData) SetDeviceActive(v int32) *QueryDeviceGroupInfoResponseBodyData {
	s.DeviceActive = &v
	return s
}

func (s *QueryDeviceGroupInfoResponseBodyData) SetDeviceCount(v int32) *QueryDeviceGroupInfoResponseBodyData {
	s.DeviceCount = &v
	return s
}

func (s *QueryDeviceGroupInfoResponseBodyData) SetDeviceOnline(v int32) *QueryDeviceGroupInfoResponseBodyData {
	s.DeviceOnline = &v
	return s
}

func (s *QueryDeviceGroupInfoResponseBodyData) SetDynamicGroupExpression(v string) *QueryDeviceGroupInfoResponseBodyData {
	s.DynamicGroupExpression = &v
	return s
}

func (s *QueryDeviceGroupInfoResponseBodyData) SetGroupDesc(v string) *QueryDeviceGroupInfoResponseBodyData {
	s.GroupDesc = &v
	return s
}

func (s *QueryDeviceGroupInfoResponseBodyData) SetGroupId(v string) *QueryDeviceGroupInfoResponseBodyData {
	s.GroupId = &v
	return s
}

func (s *QueryDeviceGroupInfoResponseBodyData) SetGroupName(v string) *QueryDeviceGroupInfoResponseBodyData {
	s.GroupName = &v
	return s
}

func (s *QueryDeviceGroupInfoResponseBodyData) SetUtcCreate(v string) *QueryDeviceGroupInfoResponseBodyData {
	s.UtcCreate = &v
	return s
}

type QueryDeviceGroupInfoResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceGroupInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceGroupInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupInfoResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupInfoResponse) SetHeaders(v map[string]*string) *QueryDeviceGroupInfoResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceGroupInfoResponse) SetStatusCode(v int32) *QueryDeviceGroupInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceGroupInfoResponse) SetBody(v *QueryDeviceGroupInfoResponseBody) *QueryDeviceGroupInfoResponse {
	s.Body = v
	return s
}

type QueryDeviceGroupListRequest struct {
	// The number of the page to return. Default value: 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The name of the group.
	//
	// *   If you specify this parameter, the system queries groups by group name. You can perform a fuzzy search by group name.
	// *   If you do not specify this parameter, the system queries all groups.
	GroupName  *string   `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	GroupTypes []*string `json:"GroupTypes,omitempty" xml:"GroupTypes,omitempty" type:"Repeated"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of the entries to return on each page. Maximum value: 200. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the parent group. If you need to query the subgroups of a parent group, specify this parameter.
	SuperGroupId *string `json:"SuperGroupId,omitempty" xml:"SuperGroupId,omitempty"`
}

func (s QueryDeviceGroupListRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupListRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupListRequest) SetCurrentPage(v int32) *QueryDeviceGroupListRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryDeviceGroupListRequest) SetGroupName(v string) *QueryDeviceGroupListRequest {
	s.GroupName = &v
	return s
}

func (s *QueryDeviceGroupListRequest) SetGroupTypes(v []*string) *QueryDeviceGroupListRequest {
	s.GroupTypes = v
	return s
}

func (s *QueryDeviceGroupListRequest) SetIotInstanceId(v string) *QueryDeviceGroupListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceGroupListRequest) SetPageSize(v int32) *QueryDeviceGroupListRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceGroupListRequest) SetSuperGroupId(v string) *QueryDeviceGroupListRequest {
	s.SuperGroupId = &v
	return s
}

type QueryDeviceGroupListResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The page number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The group information returned if the call succeeds. For more information, see the GroupInfo parameter.
	//
	// >  The returned group information is sorted in reverse chronological order in which the groups are created.
	Data *QueryDeviceGroupListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The total number of pages.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of records that were returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryDeviceGroupListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupListResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupListResponseBody) SetCode(v string) *QueryDeviceGroupListResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceGroupListResponseBody) SetCurrentPage(v int32) *QueryDeviceGroupListResponseBody {
	s.CurrentPage = &v
	return s
}

func (s *QueryDeviceGroupListResponseBody) SetData(v *QueryDeviceGroupListResponseBodyData) *QueryDeviceGroupListResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceGroupListResponseBody) SetErrorMessage(v string) *QueryDeviceGroupListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceGroupListResponseBody) SetPageCount(v int32) *QueryDeviceGroupListResponseBody {
	s.PageCount = &v
	return s
}

func (s *QueryDeviceGroupListResponseBody) SetPageSize(v int32) *QueryDeviceGroupListResponseBody {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceGroupListResponseBody) SetRequestId(v string) *QueryDeviceGroupListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceGroupListResponseBody) SetSuccess(v bool) *QueryDeviceGroupListResponseBody {
	s.Success = &v
	return s
}

func (s *QueryDeviceGroupListResponseBody) SetTotal(v int32) *QueryDeviceGroupListResponseBody {
	s.Total = &v
	return s
}

type QueryDeviceGroupListResponseBodyData struct {
	GroupInfo []*QueryDeviceGroupListResponseBodyDataGroupInfo `json:"GroupInfo,omitempty" xml:"GroupInfo,omitempty" type:"Repeated"`
}

func (s QueryDeviceGroupListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupListResponseBodyData) SetGroupInfo(v []*QueryDeviceGroupListResponseBodyDataGroupInfo) *QueryDeviceGroupListResponseBodyData {
	s.GroupInfo = v
	return s
}

type QueryDeviceGroupListResponseBodyDataGroupInfo struct {
	// The description of the group.
	GroupDesc *string `json:"GroupDesc,omitempty" xml:"GroupDesc,omitempty"`
	// The ID of the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The type of the group.
	GroupType *string `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The time when the group was created.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
}

func (s QueryDeviceGroupListResponseBodyDataGroupInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupListResponseBodyDataGroupInfo) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupListResponseBodyDataGroupInfo) SetGroupDesc(v string) *QueryDeviceGroupListResponseBodyDataGroupInfo {
	s.GroupDesc = &v
	return s
}

func (s *QueryDeviceGroupListResponseBodyDataGroupInfo) SetGroupId(v string) *QueryDeviceGroupListResponseBodyDataGroupInfo {
	s.GroupId = &v
	return s
}

func (s *QueryDeviceGroupListResponseBodyDataGroupInfo) SetGroupName(v string) *QueryDeviceGroupListResponseBodyDataGroupInfo {
	s.GroupName = &v
	return s
}

func (s *QueryDeviceGroupListResponseBodyDataGroupInfo) SetGroupType(v string) *QueryDeviceGroupListResponseBodyDataGroupInfo {
	s.GroupType = &v
	return s
}

func (s *QueryDeviceGroupListResponseBodyDataGroupInfo) SetUtcCreate(v string) *QueryDeviceGroupListResponseBodyDataGroupInfo {
	s.UtcCreate = &v
	return s
}

type QueryDeviceGroupListResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceGroupListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceGroupListResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupListResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupListResponse) SetHeaders(v map[string]*string) *QueryDeviceGroupListResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceGroupListResponse) SetStatusCode(v int32) *QueryDeviceGroupListResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceGroupListResponse) SetBody(v *QueryDeviceGroupListResponseBody) *QueryDeviceGroupListResponse {
	s.Body = v
	return s
}

type QueryDeviceGroupTagListRequest struct {
	// The ID of the group. The ID is the globally unique identifier (GUID) for the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The type of the group.
	//
	// If you set the value to **LINK_PLATFORM_DYNAMIC**, a dynamic group is queried. If you do not specify this parameter, a static group is queried by default.
	GroupType *string `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s QueryDeviceGroupTagListRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupTagListRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupTagListRequest) SetGroupId(v string) *QueryDeviceGroupTagListRequest {
	s.GroupId = &v
	return s
}

func (s *QueryDeviceGroupTagListRequest) SetGroupType(v string) *QueryDeviceGroupTagListRequest {
	s.GroupType = &v
	return s
}

func (s *QueryDeviceGroupTagListRequest) SetIotInstanceId(v string) *QueryDeviceGroupTagListRequest {
	s.IotInstanceId = &v
	return s
}

type QueryDeviceGroupTagListResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The tag information returned if the call succeeds. For more information, see the following **GroupTagInfo** parameter.
	Data *QueryDeviceGroupTagListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceGroupTagListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupTagListResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupTagListResponseBody) SetCode(v string) *QueryDeviceGroupTagListResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceGroupTagListResponseBody) SetData(v *QueryDeviceGroupTagListResponseBodyData) *QueryDeviceGroupTagListResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceGroupTagListResponseBody) SetErrorMessage(v string) *QueryDeviceGroupTagListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceGroupTagListResponseBody) SetRequestId(v string) *QueryDeviceGroupTagListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceGroupTagListResponseBody) SetSuccess(v bool) *QueryDeviceGroupTagListResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceGroupTagListResponseBodyData struct {
	GroupTagInfo []*QueryDeviceGroupTagListResponseBodyDataGroupTagInfo `json:"GroupTagInfo,omitempty" xml:"GroupTagInfo,omitempty" type:"Repeated"`
}

func (s QueryDeviceGroupTagListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupTagListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupTagListResponseBodyData) SetGroupTagInfo(v []*QueryDeviceGroupTagListResponseBodyDataGroupTagInfo) *QueryDeviceGroupTagListResponseBodyData {
	s.GroupTagInfo = v
	return s
}

type QueryDeviceGroupTagListResponseBodyDataGroupTagInfo struct {
	// The key of the tag.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The value of the tag.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s QueryDeviceGroupTagListResponseBodyDataGroupTagInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupTagListResponseBodyDataGroupTagInfo) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupTagListResponseBodyDataGroupTagInfo) SetTagKey(v string) *QueryDeviceGroupTagListResponseBodyDataGroupTagInfo {
	s.TagKey = &v
	return s
}

func (s *QueryDeviceGroupTagListResponseBodyDataGroupTagInfo) SetTagValue(v string) *QueryDeviceGroupTagListResponseBodyDataGroupTagInfo {
	s.TagValue = &v
	return s
}

type QueryDeviceGroupTagListResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceGroupTagListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceGroupTagListResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceGroupTagListResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceGroupTagListResponse) SetHeaders(v map[string]*string) *QueryDeviceGroupTagListResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceGroupTagListResponse) SetStatusCode(v int32) *QueryDeviceGroupTagListResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceGroupTagListResponse) SetBody(v *QueryDeviceGroupTagListResponseBody) *QueryDeviceGroupTagListResponse {
	s.Body = v
	return s
}

type QueryDeviceInfoRequest struct {
	// The ID of the device.
	//
	// > If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// > If you specify this parameter, you must also specify the **DeviceName** parameter.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The DeviceName of the device.
	//
	// > If you specify this parameter, you must also specify the **ProductKey** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryDeviceInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceInfoRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceInfoRequest) SetDeviceName(v string) *QueryDeviceInfoRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceInfoRequest) SetIotId(v string) *QueryDeviceInfoRequest {
	s.IotId = &v
	return s
}

func (s *QueryDeviceInfoRequest) SetIotInstanceId(v string) *QueryDeviceInfoRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceInfoRequest) SetProductKey(v string) *QueryDeviceInfoRequest {
	s.ProductKey = &v
	return s
}

type QueryDeviceInfoResponseBody struct {
	// The error message returned if the call fails.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The alias of the device.
	Data *QueryDeviceInfoResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The information about the device returned if the call is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceInfoResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceInfoResponseBody) SetCode(v string) *QueryDeviceInfoResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceInfoResponseBody) SetData(v *QueryDeviceInfoResponseBodyData) *QueryDeviceInfoResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceInfoResponseBody) SetErrorMessage(v string) *QueryDeviceInfoResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceInfoResponseBody) SetRequestId(v string) *QueryDeviceInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceInfoResponseBody) SetSuccess(v bool) *QueryDeviceInfoResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceInfoResponseBodyData struct {
	// The DeviceSecret of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
	DeviceSecret *string `json:"DeviceSecret,omitempty" xml:"DeviceSecret,omitempty"`
	IotId        *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	Nickname *string `json:"Nickname,omitempty" xml:"Nickname,omitempty"`
	// The DeviceName of the device.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryDeviceInfoResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceInfoResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceInfoResponseBodyData) SetDeviceName(v string) *QueryDeviceInfoResponseBodyData {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceInfoResponseBodyData) SetDeviceSecret(v string) *QueryDeviceInfoResponseBodyData {
	s.DeviceSecret = &v
	return s
}

func (s *QueryDeviceInfoResponseBodyData) SetIotId(v string) *QueryDeviceInfoResponseBodyData {
	s.IotId = &v
	return s
}

func (s *QueryDeviceInfoResponseBodyData) SetNickname(v string) *QueryDeviceInfoResponseBodyData {
	s.Nickname = &v
	return s
}

func (s *QueryDeviceInfoResponseBodyData) SetProductKey(v string) *QueryDeviceInfoResponseBodyData {
	s.ProductKey = &v
	return s
}

type QueryDeviceInfoResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceInfoResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceInfoResponse) SetHeaders(v map[string]*string) *QueryDeviceInfoResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceInfoResponse) SetStatusCode(v int32) *QueryDeviceInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceInfoResponse) SetBody(v *QueryDeviceInfoResponseBody) *QueryDeviceInfoResponse {
	s.Body = v
	return s
}

type QueryDeviceListByDeviceGroupRequest struct {
	// The number of the page to return.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The ID of the group. The ID is the globally unique identifier (GUID) for the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QueryDeviceListByDeviceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceListByDeviceGroupRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceListByDeviceGroupRequest) SetCurrentPage(v int32) *QueryDeviceListByDeviceGroupRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryDeviceListByDeviceGroupRequest) SetGroupId(v string) *QueryDeviceListByDeviceGroupRequest {
	s.GroupId = &v
	return s
}

func (s *QueryDeviceListByDeviceGroupRequest) SetIotInstanceId(v string) *QueryDeviceListByDeviceGroupRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceListByDeviceGroupRequest) SetPageSize(v int32) *QueryDeviceListByDeviceGroupRequest {
	s.PageSize = &v
	return s
}

type QueryDeviceListByDeviceGroupResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The device list information returned if the call succeeds. For more information, see the following **SimpleDeviceInfo** parameter.
	Data *QueryDeviceListByDeviceGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The number of the returned page.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The total number of pages.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of devices.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryDeviceListByDeviceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceListByDeviceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceListByDeviceGroupResponseBody) SetCode(v string) *QueryDeviceListByDeviceGroupResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceListByDeviceGroupResponseBody) SetData(v *QueryDeviceListByDeviceGroupResponseBodyData) *QueryDeviceListByDeviceGroupResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceListByDeviceGroupResponseBody) SetErrorMessage(v string) *QueryDeviceListByDeviceGroupResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceListByDeviceGroupResponseBody) SetPage(v int32) *QueryDeviceListByDeviceGroupResponseBody {
	s.Page = &v
	return s
}

func (s *QueryDeviceListByDeviceGroupResponseBody) SetPageCount(v int32) *QueryDeviceListByDeviceGroupResponseBody {
	s.PageCount = &v
	return s
}

func (s *QueryDeviceListByDeviceGroupResponseBody) SetPageSize(v int32) *QueryDeviceListByDeviceGroupResponseBody {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceListByDeviceGroupResponseBody) SetRequestId(v string) *QueryDeviceListByDeviceGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceListByDeviceGroupResponseBody) SetSuccess(v bool) *QueryDeviceListByDeviceGroupResponseBody {
	s.Success = &v
	return s
}

func (s *QueryDeviceListByDeviceGroupResponseBody) SetTotal(v int32) *QueryDeviceListByDeviceGroupResponseBody {
	s.Total = &v
	return s
}

type QueryDeviceListByDeviceGroupResponseBodyData struct {
	SimpleDeviceInfo []*QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo `json:"SimpleDeviceInfo,omitempty" xml:"SimpleDeviceInfo,omitempty" type:"Repeated"`
}

func (s QueryDeviceListByDeviceGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceListByDeviceGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceListByDeviceGroupResponseBodyData) SetSimpleDeviceInfo(v []*QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo) *QueryDeviceListByDeviceGroupResponseBodyData {
	s.SimpleDeviceInfo = v
	return s
}

type QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo struct {
	// The name of each device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ProductName of the product to which the device belongs.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
}

func (s QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo) GoString() string {
	return s.String()
}

func (s *QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo) SetDeviceName(v string) *QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo) SetIotId(v string) *QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo {
	s.IotId = &v
	return s
}

func (s *QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo) SetProductKey(v string) *QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo {
	s.ProductKey = &v
	return s
}

func (s *QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo) SetProductName(v string) *QueryDeviceListByDeviceGroupResponseBodyDataSimpleDeviceInfo {
	s.ProductName = &v
	return s
}

type QueryDeviceListByDeviceGroupResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceListByDeviceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceListByDeviceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceListByDeviceGroupResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceListByDeviceGroupResponse) SetHeaders(v map[string]*string) *QueryDeviceListByDeviceGroupResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceListByDeviceGroupResponse) SetStatusCode(v int32) *QueryDeviceListByDeviceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceListByDeviceGroupResponse) SetBody(v *QueryDeviceListByDeviceGroupResponseBody) *QueryDeviceListByDeviceGroupResponse {
	s.Body = v
	return s
}

type QueryDeviceOriginalEventDataRequest struct {
	// The sorting order of the returned event records. Value values:
	//
	// *   0: descending.
	// *   1: ascending.
	Asc *int32 `json:"Asc,omitempty" xml:"Asc,omitempty"`
	// The name of the device.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The end of the time range to query. The value is a 13-digit timestamp in milliseconds.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The event identifier that you want to query.
	//
	// *   If low-level verification is applied, you can perform the following steps to view the **Identifier** of a device event: Log on to the IoT Platform console and go to the Define Feature tab of the Product Details page. You can also call the [QueryThingModel](~~150321~~) operation and view the service identifier in the returned TSL data.
	// *   If no verification is applied, the value must be the same as the value of the custom** identifier** that is submitted by the device.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The ID of the device. It is the unique identifier that IoT Platform generated for the device.
	//
	// >  If you specify this parameter, you do not need to specify the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a unique identifier for the device, and corresponds to a combination of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId** parameter and the combination of the **ProductKey** and **DeviceName** parameters at the same time, only the **IotId** parameter is used.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The identifier of the next page. If the next page exists, this parameter is returned. In this case, you must add the value of the parameter to the next request.
	NextPageToken *string `json:"NextPageToken,omitempty" xml:"NextPageToken,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 50. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The start of the time range to query. The value is a 13-digit timestamp in milliseconds.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s QueryDeviceOriginalEventDataRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalEventDataRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalEventDataRequest) SetAsc(v int32) *QueryDeviceOriginalEventDataRequest {
	s.Asc = &v
	return s
}

func (s *QueryDeviceOriginalEventDataRequest) SetDeviceName(v string) *QueryDeviceOriginalEventDataRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceOriginalEventDataRequest) SetEndTime(v int64) *QueryDeviceOriginalEventDataRequest {
	s.EndTime = &v
	return s
}

func (s *QueryDeviceOriginalEventDataRequest) SetIdentifier(v string) *QueryDeviceOriginalEventDataRequest {
	s.Identifier = &v
	return s
}

func (s *QueryDeviceOriginalEventDataRequest) SetIotId(v string) *QueryDeviceOriginalEventDataRequest {
	s.IotId = &v
	return s
}

func (s *QueryDeviceOriginalEventDataRequest) SetIotInstanceId(v string) *QueryDeviceOriginalEventDataRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceOriginalEventDataRequest) SetNextPageToken(v string) *QueryDeviceOriginalEventDataRequest {
	s.NextPageToken = &v
	return s
}

func (s *QueryDeviceOriginalEventDataRequest) SetPageSize(v int32) *QueryDeviceOriginalEventDataRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceOriginalEventDataRequest) SetProductKey(v string) *QueryDeviceOriginalEventDataRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryDeviceOriginalEventDataRequest) SetStartTime(v int64) *QueryDeviceOriginalEventDataRequest {
	s.StartTime = &v
	return s
}

type QueryDeviceOriginalEventDataResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The event records returned if the call succeeds.
	Data *QueryDeviceOriginalEventDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call succeeds.
	//
	// *   true: The call succeeded.
	// *   false: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceOriginalEventDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalEventDataResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalEventDataResponseBody) SetCode(v string) *QueryDeviceOriginalEventDataResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceOriginalEventDataResponseBody) SetData(v *QueryDeviceOriginalEventDataResponseBodyData) *QueryDeviceOriginalEventDataResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceOriginalEventDataResponseBody) SetErrorMessage(v string) *QueryDeviceOriginalEventDataResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceOriginalEventDataResponseBody) SetRequestId(v string) *QueryDeviceOriginalEventDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceOriginalEventDataResponseBody) SetSuccess(v bool) *QueryDeviceOriginalEventDataResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceOriginalEventDataResponseBodyData struct {
	// The array of events. Each element represents an event. For more information about the details of the event, see the parameters of the **EventInfo** parameter.
	List *QueryDeviceOriginalEventDataResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	// The identifier of the next page.
	NextPageToken *string `json:"NextPageToken,omitempty" xml:"NextPageToken,omitempty"`
	// Indicates whether the next page exists.
	//
	// *   **true**: The next page exists.
	// *   **false**: The next page does not exist.
	//
	// If the value ******true** is returned, you can add the value of the **NextPageToken** parameter**** to the next request. This allows you to query the data that is not included in the current query.
	NextValid *bool `json:"NextValid,omitempty" xml:"NextValid,omitempty"`
}

func (s QueryDeviceOriginalEventDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalEventDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalEventDataResponseBodyData) SetList(v *QueryDeviceOriginalEventDataResponseBodyDataList) *QueryDeviceOriginalEventDataResponseBodyData {
	s.List = v
	return s
}

func (s *QueryDeviceOriginalEventDataResponseBodyData) SetNextPageToken(v string) *QueryDeviceOriginalEventDataResponseBodyData {
	s.NextPageToken = &v
	return s
}

func (s *QueryDeviceOriginalEventDataResponseBodyData) SetNextValid(v bool) *QueryDeviceOriginalEventDataResponseBodyData {
	s.NextValid = &v
	return s
}

type QueryDeviceOriginalEventDataResponseBodyDataList struct {
	EventInfo []*QueryDeviceOriginalEventDataResponseBodyDataListEventInfo `json:"EventInfo,omitempty" xml:"EventInfo,omitempty" type:"Repeated"`
}

func (s QueryDeviceOriginalEventDataResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalEventDataResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalEventDataResponseBodyDataList) SetEventInfo(v []*QueryDeviceOriginalEventDataResponseBodyDataListEventInfo) *QueryDeviceOriginalEventDataResponseBodyDataList {
	s.EventInfo = v
	return s
}

type QueryDeviceOriginalEventDataResponseBodyDataListEventInfo struct {
	// The type of the event. Valid values:
	//
	// *   info: information.
	// *   alert: alert.
	// *   error: error.
	EventType *string `json:"EventType,omitempty" xml:"EventType,omitempty"`
	// The identifier of the event.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The name of the event.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The output parameter of the event. The value is a string in the MAP format.
	OutputData *string `json:"OutputData,omitempty" xml:"OutputData,omitempty"`
	// The time when the event occurred. The value is a 13-digit timestamp in milliseconds.
	Time *string `json:"Time,omitempty" xml:"Time,omitempty"`
}

func (s QueryDeviceOriginalEventDataResponseBodyDataListEventInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalEventDataResponseBodyDataListEventInfo) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalEventDataResponseBodyDataListEventInfo) SetEventType(v string) *QueryDeviceOriginalEventDataResponseBodyDataListEventInfo {
	s.EventType = &v
	return s
}

func (s *QueryDeviceOriginalEventDataResponseBodyDataListEventInfo) SetIdentifier(v string) *QueryDeviceOriginalEventDataResponseBodyDataListEventInfo {
	s.Identifier = &v
	return s
}

func (s *QueryDeviceOriginalEventDataResponseBodyDataListEventInfo) SetName(v string) *QueryDeviceOriginalEventDataResponseBodyDataListEventInfo {
	s.Name = &v
	return s
}

func (s *QueryDeviceOriginalEventDataResponseBodyDataListEventInfo) SetOutputData(v string) *QueryDeviceOriginalEventDataResponseBodyDataListEventInfo {
	s.OutputData = &v
	return s
}

func (s *QueryDeviceOriginalEventDataResponseBodyDataListEventInfo) SetTime(v string) *QueryDeviceOriginalEventDataResponseBodyDataListEventInfo {
	s.Time = &v
	return s
}

type QueryDeviceOriginalEventDataResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceOriginalEventDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceOriginalEventDataResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalEventDataResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalEventDataResponse) SetHeaders(v map[string]*string) *QueryDeviceOriginalEventDataResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceOriginalEventDataResponse) SetStatusCode(v int32) *QueryDeviceOriginalEventDataResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceOriginalEventDataResponse) SetBody(v *QueryDeviceOriginalEventDataResponseBody) *QueryDeviceOriginalEventDataResponse {
	s.Body = v
	return s
}

type QueryDeviceOriginalPropertyDataRequest struct {
	// The order in which you want to sort the returned property records. Valid values:
	//
	// *   0: descending.
	// *   1: ascending.
	//
	// >  The **start time** must be earlier than the **end time**. The system sorts the returned records based on the specified order.
	Asc *int32 `json:"Asc,omitempty" xml:"Asc,omitempty"`
	// The DeviceName of the device.
	//
	// > If you specify a value for this parameter, you must configure the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The end of the time range to query. The value must be a 13-digit timestamp.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The identifier of the property.
	//
	// *   If weak verification is used, you can perform the following steps to view the **Identifier** of a device property: Log on to the IoT Platform console and go to the Define Feature tab of the Product Details page. You can also call the [QueryThingModel](~~150321~~) operation and view the property identifier in the returned TSL data.
	// *   If no verification is used, the value must be the same as the custom **identifier** that is submitted by the device.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// > The IotId parameter specifies a unique ID for the device. The value of the **IotId** parameter is equivalent to a combination of the values of the **ProductKey** and **DeviceName.N** parameters. If you specify the IotId parameter, you do not need to configure the **ProductKey** or **DeviceName.N** parameter. If you specify values for the **IotId**, **ProductKey**, and **DeviceName.N** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The token that is used to retrieve the next page of the query results. If the next page exists, this parameter is returned. In this case, you must add the value of the parameter to the next request.
	NextPageToken *string `json:"NextPageToken,omitempty" xml:"NextPageToken,omitempty"`
	// The maximum number of records that can be returned for each property. Maximum value: 100.
	//
	// The number of records that are returned for an arbitrary property cannot exceed the limit.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ProductKey of the product to which the device belongs.****
	//
	//
	//
	// > If you specify a value for this parameter, you must configure the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The start of the time range to query. The value must be a 13-digit timestamp.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s QueryDeviceOriginalPropertyDataRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalPropertyDataRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalPropertyDataRequest) SetAsc(v int32) *QueryDeviceOriginalPropertyDataRequest {
	s.Asc = &v
	return s
}

func (s *QueryDeviceOriginalPropertyDataRequest) SetDeviceName(v string) *QueryDeviceOriginalPropertyDataRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceOriginalPropertyDataRequest) SetEndTime(v int64) *QueryDeviceOriginalPropertyDataRequest {
	s.EndTime = &v
	return s
}

func (s *QueryDeviceOriginalPropertyDataRequest) SetIdentifier(v string) *QueryDeviceOriginalPropertyDataRequest {
	s.Identifier = &v
	return s
}

func (s *QueryDeviceOriginalPropertyDataRequest) SetIotId(v string) *QueryDeviceOriginalPropertyDataRequest {
	s.IotId = &v
	return s
}

func (s *QueryDeviceOriginalPropertyDataRequest) SetIotInstanceId(v string) *QueryDeviceOriginalPropertyDataRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceOriginalPropertyDataRequest) SetNextPageToken(v string) *QueryDeviceOriginalPropertyDataRequest {
	s.NextPageToken = &v
	return s
}

func (s *QueryDeviceOriginalPropertyDataRequest) SetPageSize(v int32) *QueryDeviceOriginalPropertyDataRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceOriginalPropertyDataRequest) SetProductKey(v string) *QueryDeviceOriginalPropertyDataRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryDeviceOriginalPropertyDataRequest) SetStartTime(v int64) *QueryDeviceOriginalPropertyDataRequest {
	s.StartTime = &v
	return s
}

type QueryDeviceOriginalPropertyDataResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The property records returned if the call is successful.
	Data *QueryDeviceOriginalPropertyDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceOriginalPropertyDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalPropertyDataResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalPropertyDataResponseBody) SetCode(v string) *QueryDeviceOriginalPropertyDataResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceOriginalPropertyDataResponseBody) SetData(v *QueryDeviceOriginalPropertyDataResponseBodyData) *QueryDeviceOriginalPropertyDataResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceOriginalPropertyDataResponseBody) SetErrorMessage(v string) *QueryDeviceOriginalPropertyDataResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceOriginalPropertyDataResponseBody) SetRequestId(v string) *QueryDeviceOriginalPropertyDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceOriginalPropertyDataResponseBody) SetSuccess(v bool) *QueryDeviceOriginalPropertyDataResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceOriginalPropertyDataResponseBodyData struct {
	// The properties. Each element indicates a property.
	List *QueryDeviceOriginalPropertyDataResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	// Indicates whether the next page exists.
	//
	// - **true**: The next page exists.
	// - **false**: The next page does not exist.
	//
	// If **true** is returned for the **NextValid** parameter, you can add the value of the **NextPageToken** parameter to the next request. This way, you can query the data that is not included in the current query.
	NextValid *bool `json:"NextValid,omitempty" xml:"NextValid,omitempty"`
	// The token that is used to retrieve the next page of the query results.
	NextPageToken *string `json:"nextPageToken,omitempty" xml:"nextPageToken,omitempty"`
}

func (s QueryDeviceOriginalPropertyDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalPropertyDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalPropertyDataResponseBodyData) SetList(v *QueryDeviceOriginalPropertyDataResponseBodyDataList) *QueryDeviceOriginalPropertyDataResponseBodyData {
	s.List = v
	return s
}

func (s *QueryDeviceOriginalPropertyDataResponseBodyData) SetNextValid(v bool) *QueryDeviceOriginalPropertyDataResponseBodyData {
	s.NextValid = &v
	return s
}

func (s *QueryDeviceOriginalPropertyDataResponseBodyData) SetNextPageToken(v string) *QueryDeviceOriginalPropertyDataResponseBodyData {
	s.NextPageToken = &v
	return s
}

type QueryDeviceOriginalPropertyDataResponseBodyDataList struct {
	PropertyInfo []*QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo `json:"PropertyInfo,omitempty" xml:"PropertyInfo,omitempty" type:"Repeated"`
}

func (s QueryDeviceOriginalPropertyDataResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalPropertyDataResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalPropertyDataResponseBodyDataList) SetPropertyInfo(v []*QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo) *QueryDeviceOriginalPropertyDataResponseBodyDataList {
	s.PropertyInfo = v
	return s
}

type QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo struct {
	// The time when the property was modified.
	Time *string `json:"Time,omitempty" xml:"Time,omitempty"`
	// The value of the property.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo) SetTime(v string) *QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo {
	s.Time = &v
	return s
}

func (s *QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo) SetValue(v string) *QueryDeviceOriginalPropertyDataResponseBodyDataListPropertyInfo {
	s.Value = &v
	return s
}

type QueryDeviceOriginalPropertyDataResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceOriginalPropertyDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceOriginalPropertyDataResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalPropertyDataResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalPropertyDataResponse) SetHeaders(v map[string]*string) *QueryDeviceOriginalPropertyDataResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceOriginalPropertyDataResponse) SetStatusCode(v int32) *QueryDeviceOriginalPropertyDataResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceOriginalPropertyDataResponse) SetBody(v *QueryDeviceOriginalPropertyDataResponseBody) *QueryDeviceOriginalPropertyDataResponse {
	s.Body = v
	return s
}

type QueryDeviceOriginalPropertyStatusRequest struct {
	// The chronological order in which property data is queried. Valid values:
	//
	// *   0: in reverse chronological order.
	// *   1: in chronological order.
	Asc *int32 `json:"Asc,omitempty" xml:"Asc,omitempty"`
	// The name of the device.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. It is the unique identifier that IoT Platform generated for the device.
	//
	// >  If you specify this parameter, you do not need to specify the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a unique identifier for the device, and corresponds to a combination of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId** parameter and a combination of the **ProductKey** and **DeviceName** parameters at the same time, the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The identifier of the next page. If the next page exists, this parameter is returned. In this case, you must add the value of the parameter to the next request.
	NextPageToken *string `json:"NextPageToken,omitempty" xml:"NextPageToken,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 50.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryDeviceOriginalPropertyStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalPropertyStatusRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalPropertyStatusRequest) SetAsc(v int32) *QueryDeviceOriginalPropertyStatusRequest {
	s.Asc = &v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusRequest) SetDeviceName(v string) *QueryDeviceOriginalPropertyStatusRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusRequest) SetIotId(v string) *QueryDeviceOriginalPropertyStatusRequest {
	s.IotId = &v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusRequest) SetIotInstanceId(v string) *QueryDeviceOriginalPropertyStatusRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusRequest) SetNextPageToken(v string) *QueryDeviceOriginalPropertyStatusRequest {
	s.NextPageToken = &v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusRequest) SetPageSize(v int32) *QueryDeviceOriginalPropertyStatusRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusRequest) SetProductKey(v string) *QueryDeviceOriginalPropertyStatusRequest {
	s.ProductKey = &v
	return s
}

type QueryDeviceOriginalPropertyStatusResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call succeeds. For more information, see the parameters of the List parameter.
	Data *QueryDeviceOriginalPropertyStatusResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call succeeds.
	//
	// *   true: The call succeeded.
	// *   false: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceOriginalPropertyStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalPropertyStatusResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalPropertyStatusResponseBody) SetCode(v string) *QueryDeviceOriginalPropertyStatusResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusResponseBody) SetData(v *QueryDeviceOriginalPropertyStatusResponseBodyData) *QueryDeviceOriginalPropertyStatusResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusResponseBody) SetErrorMessage(v string) *QueryDeviceOriginalPropertyStatusResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusResponseBody) SetRequestId(v string) *QueryDeviceOriginalPropertyStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusResponseBody) SetSuccess(v bool) *QueryDeviceOriginalPropertyStatusResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceOriginalPropertyStatusResponseBodyData struct {
	// The array of property information. The information about each property is indicated by the **PropertyStatusInfo** parameter.
	List *QueryDeviceOriginalPropertyStatusResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	// The identifier of the next page.
	NextPageToken *string `json:"NextPageToken,omitempty" xml:"NextPageToken,omitempty"`
	// Indicates whether the next page exists.
	//
	// *   **true**: The next page exists.
	// *   **false**: The next page does not exist.
	//
	// If the value ******true** is returned, you can add the value of the **NextPageToken** parameter**** to the next query. This allows you to query the data that is not returned by the current query.
	NextValid *bool `json:"NextValid,omitempty" xml:"NextValid,omitempty"`
}

func (s QueryDeviceOriginalPropertyStatusResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalPropertyStatusResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalPropertyStatusResponseBodyData) SetList(v *QueryDeviceOriginalPropertyStatusResponseBodyDataList) *QueryDeviceOriginalPropertyStatusResponseBodyData {
	s.List = v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusResponseBodyData) SetNextPageToken(v string) *QueryDeviceOriginalPropertyStatusResponseBodyData {
	s.NextPageToken = &v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusResponseBodyData) SetNextValid(v bool) *QueryDeviceOriginalPropertyStatusResponseBodyData {
	s.NextValid = &v
	return s
}

type QueryDeviceOriginalPropertyStatusResponseBodyDataList struct {
	PropertyStatusDataInfo []*QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo `json:"PropertyStatusDataInfo,omitempty" xml:"PropertyStatusDataInfo,omitempty" type:"Repeated"`
}

func (s QueryDeviceOriginalPropertyStatusResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalPropertyStatusResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalPropertyStatusResponseBodyDataList) SetPropertyStatusDataInfo(v []*QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo) *QueryDeviceOriginalPropertyStatusResponseBodyDataList {
	s.PropertyStatusDataInfo = v
	return s
}

type QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo struct {
	// The identifier of the property.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The time when the property was modified, in milliseconds.
	Time *int64 `json:"Time,omitempty" xml:"Time,omitempty"`
	// The value of the property.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo) SetIdentifier(v string) *QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo {
	s.Identifier = &v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo) SetTime(v int64) *QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo {
	s.Time = &v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo) SetValue(v string) *QueryDeviceOriginalPropertyStatusResponseBodyDataListPropertyStatusDataInfo {
	s.Value = &v
	return s
}

type QueryDeviceOriginalPropertyStatusResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceOriginalPropertyStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceOriginalPropertyStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalPropertyStatusResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalPropertyStatusResponse) SetHeaders(v map[string]*string) *QueryDeviceOriginalPropertyStatusResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusResponse) SetStatusCode(v int32) *QueryDeviceOriginalPropertyStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceOriginalPropertyStatusResponse) SetBody(v *QueryDeviceOriginalPropertyStatusResponseBody) *QueryDeviceOriginalPropertyStatusResponse {
	s.Body = v
	return s
}

type QueryDeviceOriginalServiceDataRequest struct {
	// The sorting order of the returned service call records. Valid values:
	//
	// *   0: descending.
	// *   1: ascending.
	//
	// >  **The start time** must be earlier than **the end time**. The system sorts the returned records based on the specified order.
	Asc *int32 `json:"Asc,omitempty" xml:"Asc,omitempty"`
	// The name of the device.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The end of the time range to query. The value must be a 13-digit timestamp.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The identifier of the service.
	//
	// *   If low-level verification is applied, you can perform the following steps to view the **Identifier** of a device event: Log on to the IoT Platform console and go to the Define Feature tab of the Product Details page. You can also call the [QueryThingModel](~~150321~~) operation and view the service identifier in the returned TSL data.
	// *   If no verification is applied, the value must be the same as the value of the custom** identifier** that is submitted by the device.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The ID of the device. It is the unique identifier that IoT Platform generated for the device.
	//
	// >  If you specify this parameter, you do not need to specify the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a unique identifier for the device, and corresponds to a combination of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId** parameter and a combination of the **ProductKey** and **DeviceName** parameters at the same time, the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The identifier of the next page. The response to the first request contains this parameter, which will be added to the next request.
	NextPageToken *string `json:"NextPageToken,omitempty" xml:"NextPageToken,omitempty"`
	// The number of entries to return on each page. Maximum value: 50.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The start of the time range to query. The value must be a 13-digit timestamp.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s QueryDeviceOriginalServiceDataRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalServiceDataRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalServiceDataRequest) SetAsc(v int32) *QueryDeviceOriginalServiceDataRequest {
	s.Asc = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataRequest) SetDeviceName(v string) *QueryDeviceOriginalServiceDataRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataRequest) SetEndTime(v int64) *QueryDeviceOriginalServiceDataRequest {
	s.EndTime = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataRequest) SetIdentifier(v string) *QueryDeviceOriginalServiceDataRequest {
	s.Identifier = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataRequest) SetIotId(v string) *QueryDeviceOriginalServiceDataRequest {
	s.IotId = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataRequest) SetIotInstanceId(v string) *QueryDeviceOriginalServiceDataRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataRequest) SetNextPageToken(v string) *QueryDeviceOriginalServiceDataRequest {
	s.NextPageToken = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataRequest) SetPageSize(v int32) *QueryDeviceOriginalServiceDataRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataRequest) SetProductKey(v string) *QueryDeviceOriginalServiceDataRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataRequest) SetStartTime(v int64) *QueryDeviceOriginalServiceDataRequest {
	s.StartTime = &v
	return s
}

type QueryDeviceOriginalServiceDataResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The service call records returned if the call succeeds.
	Data *QueryDeviceOriginalServiceDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call succeeds.
	//
	// *   true: The call succeeded.
	// *   false: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceOriginalServiceDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalServiceDataResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalServiceDataResponseBody) SetCode(v string) *QueryDeviceOriginalServiceDataResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataResponseBody) SetData(v *QueryDeviceOriginalServiceDataResponseBodyData) *QueryDeviceOriginalServiceDataResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceOriginalServiceDataResponseBody) SetErrorMessage(v string) *QueryDeviceOriginalServiceDataResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataResponseBody) SetRequestId(v string) *QueryDeviceOriginalServiceDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataResponseBody) SetSuccess(v bool) *QueryDeviceOriginalServiceDataResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceOriginalServiceDataResponseBodyData struct {
	// The array of service call records. Each element represents a service call record. For more information about the details of a service, see the parameters that belong to the **ServiceInfo** parameter.
	List *QueryDeviceOriginalServiceDataResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	// The identifier of the next page.
	NextPageToken *string `json:"NextPageToken,omitempty" xml:"NextPageToken,omitempty"`
	// Indicates whether the next page exists.
	//
	// *   **true**: The next page exists.
	// *   **false**: The next page does not exist.
	//
	// If the value ******true** is returned, you can add the value of the **NextPageToken** parameter**** to the next request. This allows you to query the data that is not included in the current query.
	NextValid *bool `json:"NextValid,omitempty" xml:"NextValid,omitempty"`
}

func (s QueryDeviceOriginalServiceDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalServiceDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalServiceDataResponseBodyData) SetList(v *QueryDeviceOriginalServiceDataResponseBodyDataList) *QueryDeviceOriginalServiceDataResponseBodyData {
	s.List = v
	return s
}

func (s *QueryDeviceOriginalServiceDataResponseBodyData) SetNextPageToken(v string) *QueryDeviceOriginalServiceDataResponseBodyData {
	s.NextPageToken = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataResponseBodyData) SetNextValid(v bool) *QueryDeviceOriginalServiceDataResponseBodyData {
	s.NextValid = &v
	return s
}

type QueryDeviceOriginalServiceDataResponseBodyDataList struct {
	ServiceInfo []*QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo `json:"ServiceInfo,omitempty" xml:"ServiceInfo,omitempty" type:"Repeated"`
}

func (s QueryDeviceOriginalServiceDataResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalServiceDataResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalServiceDataResponseBodyDataList) SetServiceInfo(v []*QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo) *QueryDeviceOriginalServiceDataResponseBodyDataList {
	s.ServiceInfo = v
	return s
}

type QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo struct {
	// The identifier of the service.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The input parameter of the service. The value is a string in the MAP format. Syntax: key:value.
	InputData *string `json:"InputData,omitempty" xml:"InputData,omitempty"`
	// The service name.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The output parameter of the service. The value is a string in the MAP format. Syntax: key:value.
	OutputData *string `json:"OutputData,omitempty" xml:"OutputData,omitempty"`
	// The time when the service was called.
	Time *string `json:"Time,omitempty" xml:"Time,omitempty"`
}

func (s QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo) SetIdentifier(v string) *QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo {
	s.Identifier = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo) SetInputData(v string) *QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo {
	s.InputData = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo) SetName(v string) *QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo {
	s.Name = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo) SetOutputData(v string) *QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo {
	s.OutputData = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo) SetTime(v string) *QueryDeviceOriginalServiceDataResponseBodyDataListServiceInfo {
	s.Time = &v
	return s
}

type QueryDeviceOriginalServiceDataResponse struct {
	Headers    map[string]*string                          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceOriginalServiceDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceOriginalServiceDataResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceOriginalServiceDataResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceOriginalServiceDataResponse) SetHeaders(v map[string]*string) *QueryDeviceOriginalServiceDataResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceOriginalServiceDataResponse) SetStatusCode(v int32) *QueryDeviceOriginalServiceDataResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceOriginalServiceDataResponse) SetBody(v *QueryDeviceOriginalServiceDataResponseBody) *QueryDeviceOriginalServiceDataResponse {
	s.Body = v
	return s
}

type QueryDevicePropRequest struct {
	// The DeviceName of the device.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The device ID is issued by IoT Platform.
	//
	// >  If you specify this parameter, you do not need to specify **ProductKey** or **DeviceName**. The **IotId** parameter specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify both **IotId** and the combination of **ProductKey** and **DeviceName**, **IotId** takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	//
	// **Important**
	//
	// *   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// *   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryDevicePropRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropRequest) GoString() string {
	return s.String()
}

func (s *QueryDevicePropRequest) SetDeviceName(v string) *QueryDevicePropRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDevicePropRequest) SetIotId(v string) *QueryDevicePropRequest {
	s.IotId = &v
	return s
}

func (s *QueryDevicePropRequest) SetIotInstanceId(v string) *QueryDevicePropRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDevicePropRequest) SetProductKey(v string) *QueryDevicePropRequest {
	s.ProductKey = &v
	return s
}

type QueryDevicePropResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// A JSON string returned if the call is successful. The JSON string includes the details of the device tags.
	Props *string `json:"Props,omitempty" xml:"Props,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDevicePropResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDevicePropResponseBody) SetCode(v string) *QueryDevicePropResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDevicePropResponseBody) SetErrorMessage(v string) *QueryDevicePropResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDevicePropResponseBody) SetProps(v string) *QueryDevicePropResponseBody {
	s.Props = &v
	return s
}

func (s *QueryDevicePropResponseBody) SetRequestId(v string) *QueryDevicePropResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDevicePropResponseBody) SetSuccess(v bool) *QueryDevicePropResponseBody {
	s.Success = &v
	return s
}

type QueryDevicePropResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDevicePropResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDevicePropResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropResponse) GoString() string {
	return s.String()
}

func (s *QueryDevicePropResponse) SetHeaders(v map[string]*string) *QueryDevicePropResponse {
	s.Headers = v
	return s
}

func (s *QueryDevicePropResponse) SetStatusCode(v int32) *QueryDevicePropResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDevicePropResponse) SetBody(v *QueryDevicePropResponseBody) *QueryDevicePropResponse {
	s.Body = v
	return s
}

type QueryDevicePropertiesDataRequest struct {
	// The sorting order of the returned property records. Valid values:
	//
	// *   **0**: in reverse chronological order. In this case, the time that is specified by the **StartTime** parameter must be later than the time that is specified by the **EndTime** parameter.
	// *   **1**: in chronological order. In this case, the time that is specified by the **StartTime** parameter must be earlier than the time that is specified by the **EndTime** parameter.
	Asc *int32 `json:"Asc,omitempty" xml:"Asc,omitempty"`
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The end of the time range to query. The value is a 13-digit timestamp in milliseconds, for example 1579249499000.
	EndTime    *int64    `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	Identifier []*string `json:"Identifier,omitempty" xml:"Identifier,omitempty" type:"Repeated"`
	// The ID of the device. The device ID is issued by IoT Platform.
	//
	// >  The **IotId** parameter is a globally unique identifier (GUID), and corresponds to a combination of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId** parameter and a combination of the **ProductKey** and **DeviceName** parameters at the same time, the **IotId** parameter is used.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The maximum number of records that is returned for each property. Maximum value: 100.
	//
	// The number of records that are returned for an arbitrary property cannot exceed the limit.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The start of the time range to query. The value is a 13-digit timestamp in milliseconds, for example, 1579249499000.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s QueryDevicePropertiesDataRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertiesDataRequest) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertiesDataRequest) SetAsc(v int32) *QueryDevicePropertiesDataRequest {
	s.Asc = &v
	return s
}

func (s *QueryDevicePropertiesDataRequest) SetDeviceName(v string) *QueryDevicePropertiesDataRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDevicePropertiesDataRequest) SetEndTime(v int64) *QueryDevicePropertiesDataRequest {
	s.EndTime = &v
	return s
}

func (s *QueryDevicePropertiesDataRequest) SetIdentifier(v []*string) *QueryDevicePropertiesDataRequest {
	s.Identifier = v
	return s
}

func (s *QueryDevicePropertiesDataRequest) SetIotId(v string) *QueryDevicePropertiesDataRequest {
	s.IotId = &v
	return s
}

func (s *QueryDevicePropertiesDataRequest) SetIotInstanceId(v string) *QueryDevicePropertiesDataRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDevicePropertiesDataRequest) SetPageSize(v int32) *QueryDevicePropertiesDataRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDevicePropertiesDataRequest) SetProductKey(v string) *QueryDevicePropertiesDataRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryDevicePropertiesDataRequest) SetStartTime(v int64) *QueryDevicePropertiesDataRequest {
	s.StartTime = &v
	return s
}

type QueryDevicePropertiesDataResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The start time to query on the next page.
	//
	// You can use the value of the **NextTime** parameter as the value of the **StartTime** parameter when you query the next page of results.
	NextTime *int64 `json:"NextTime,omitempty" xml:"NextTime,omitempty"`
	// Indicates whether the next page exists.
	//
	// *   **true**: The next page exists.
	// *   **false**: The next page does not exist.
	//
	// If the return value of the **NextValid** parameter is **true**, you can use the value of the **NextTime** parameter as the value of the **StartTime** parameter when you query the next page of results.
	NextValid *bool `json:"NextValid,omitempty" xml:"NextValid,omitempty"`
	// The list of property records returned if the call is successful. For more information, see **PropertyDataInfo**.
	PropertyDataInfos *QueryDevicePropertiesDataResponseBodyPropertyDataInfos `json:"PropertyDataInfos,omitempty" xml:"PropertyDataInfos,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// - **true**: The call was successful.
	// - **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDevicePropertiesDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertiesDataResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertiesDataResponseBody) SetCode(v string) *QueryDevicePropertiesDataResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDevicePropertiesDataResponseBody) SetErrorMessage(v string) *QueryDevicePropertiesDataResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDevicePropertiesDataResponseBody) SetNextTime(v int64) *QueryDevicePropertiesDataResponseBody {
	s.NextTime = &v
	return s
}

func (s *QueryDevicePropertiesDataResponseBody) SetNextValid(v bool) *QueryDevicePropertiesDataResponseBody {
	s.NextValid = &v
	return s
}

func (s *QueryDevicePropertiesDataResponseBody) SetPropertyDataInfos(v *QueryDevicePropertiesDataResponseBodyPropertyDataInfos) *QueryDevicePropertiesDataResponseBody {
	s.PropertyDataInfos = v
	return s
}

func (s *QueryDevicePropertiesDataResponseBody) SetRequestId(v string) *QueryDevicePropertiesDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDevicePropertiesDataResponseBody) SetSuccess(v bool) *QueryDevicePropertiesDataResponseBody {
	s.Success = &v
	return s
}

type QueryDevicePropertiesDataResponseBodyPropertyDataInfos struct {
	PropertyDataInfo []*QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo `json:"PropertyDataInfo,omitempty" xml:"PropertyDataInfo,omitempty" type:"Repeated"`
}

func (s QueryDevicePropertiesDataResponseBodyPropertyDataInfos) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertiesDataResponseBodyPropertyDataInfos) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertiesDataResponseBodyPropertyDataInfos) SetPropertyDataInfo(v []*QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo) *QueryDevicePropertiesDataResponseBodyPropertyDataInfos {
	s.PropertyDataInfo = v
	return s
}

type QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo struct {
	// The identifier of the property.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The list of property records.
	List *QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
}

func (s QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo) SetIdentifier(v string) *QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo {
	s.Identifier = &v
	return s
}

func (s *QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo) SetList(v *QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList) *QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfo {
	s.List = v
	return s
}

type QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList struct {
	PropertyInfo []*QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo `json:"PropertyInfo,omitempty" xml:"PropertyInfo,omitempty" type:"Repeated"`
}

func (s QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList) SetPropertyInfo(v []*QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo) *QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoList {
	s.PropertyInfo = v
	return s
}

type QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo struct {
	// The time when the property was submitted. The value is a timestamp in milliseconds, such as 1579249499000.
	Time *int64 `json:"Time,omitempty" xml:"Time,omitempty"`
	// The value of the property.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo) SetTime(v int64) *QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo {
	s.Time = &v
	return s
}

func (s *QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo) SetValue(v string) *QueryDevicePropertiesDataResponseBodyPropertyDataInfosPropertyDataInfoListPropertyInfo {
	s.Value = &v
	return s
}

type QueryDevicePropertiesDataResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDevicePropertiesDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDevicePropertiesDataResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertiesDataResponse) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertiesDataResponse) SetHeaders(v map[string]*string) *QueryDevicePropertiesDataResponse {
	s.Headers = v
	return s
}

func (s *QueryDevicePropertiesDataResponse) SetStatusCode(v int32) *QueryDevicePropertiesDataResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDevicePropertiesDataResponse) SetBody(v *QueryDevicePropertiesDataResponseBody) *QueryDevicePropertiesDataResponse {
	s.Body = v
	return s
}

type QueryDevicePropertyDataRequest struct {
	// The order in which you want to sort the property records that are returned. Valid values:
	//
	// *   **0**: reverse chronological order
	// *   **1**: chronological order
	Asc *int32 `json:"Asc,omitempty" xml:"Asc,omitempty"`
	// The name of the device.
	//
	// >If you specify a value for this parameter, you must also specify a value for the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The end of the time range to query. The value of the EndTime parameter must be greater than the value of the **StartTime** parameter. The value is a timestamp in milliseconds, for example, 1579249499000.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The identifier of the property that you want to query.
	//
	// You can view the property **identifier** on the Define Feature tab of the Product Details page in the IoT Platform console. You can also call the [QueryThingModel](~~150321~~) operation and view the property identifier in the returned TSL data.
	//
	// >  If a property named temperature belongs to a custom module named testFb, set this parameter to **testFb:temperature**. The custom module is not the default module.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The ID of the device to which the property belongs.:
	//
	// You can call the [QueryDeviceInfo](~~257184~~) operation to query the **ID** of the device.
	//
	// >If you specify a value for this parameter, you do not need to specify a value for the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a globally unique identifier (GUID) for the device. The value of the IotId parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for the **IotId** parameter and values for the **ProductKey** and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not configure this parameter, the call fails.
	// *   If your instance has no **Overview** page or ID, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 50.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >If you specify a value for this parameter, you must also specify a value for the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The start of the time range to query. The value of the StartTime parameter must be less than the value of the **EndTime** parameter. The value is a timestamp in milliseconds, for example, 1579249499000.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s QueryDevicePropertyDataRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertyDataRequest) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertyDataRequest) SetAsc(v int32) *QueryDevicePropertyDataRequest {
	s.Asc = &v
	return s
}

func (s *QueryDevicePropertyDataRequest) SetDeviceName(v string) *QueryDevicePropertyDataRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDevicePropertyDataRequest) SetEndTime(v int64) *QueryDevicePropertyDataRequest {
	s.EndTime = &v
	return s
}

func (s *QueryDevicePropertyDataRequest) SetIdentifier(v string) *QueryDevicePropertyDataRequest {
	s.Identifier = &v
	return s
}

func (s *QueryDevicePropertyDataRequest) SetIotId(v string) *QueryDevicePropertyDataRequest {
	s.IotId = &v
	return s
}

func (s *QueryDevicePropertyDataRequest) SetIotInstanceId(v string) *QueryDevicePropertyDataRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDevicePropertyDataRequest) SetPageSize(v int32) *QueryDevicePropertyDataRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDevicePropertyDataRequest) SetProductKey(v string) *QueryDevicePropertyDataRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryDevicePropertyDataRequest) SetStartTime(v int64) *QueryDevicePropertyDataRequest {
	s.StartTime = &v
	return s
}

type QueryDevicePropertyDataResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The property data returned if the call is successful.
	Data *QueryDevicePropertyDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDevicePropertyDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertyDataResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertyDataResponseBody) SetCode(v string) *QueryDevicePropertyDataResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDevicePropertyDataResponseBody) SetData(v *QueryDevicePropertyDataResponseBodyData) *QueryDevicePropertyDataResponseBody {
	s.Data = v
	return s
}

func (s *QueryDevicePropertyDataResponseBody) SetErrorMessage(v string) *QueryDevicePropertyDataResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDevicePropertyDataResponseBody) SetRequestId(v string) *QueryDevicePropertyDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDevicePropertyDataResponseBody) SetSuccess(v bool) *QueryDevicePropertyDataResponseBody {
	s.Success = &v
	return s
}

type QueryDevicePropertyDataResponseBodyData struct {
	// The list of property records.
	List *QueryDevicePropertyDataResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	// The start time of the property records on the next page.
	//
	// - If the **Asc** parameter is set to **0**, you can specify this value for the **EndTime** parameter when you call this operation again to query the next page of property records.
	// - If the **Asc** parameter is set to **1**, you can specify this value for the **StartTime** parameter when you call this operation again to query the next page of property records.
	NextTime *int64 `json:"NextTime,omitempty" xml:"NextTime,omitempty"`
	// Indicates whether the next page exists.
	//
	// *   **true**: The next page exists. If the return value of the NextValid parameter is true, the value of the **NextTime** parameter is returned. For more information, see the description of the **NextTime** parameter in this topic.
	// *   **false**: The next page does not exist.
	NextValid *bool `json:"NextValid,omitempty" xml:"NextValid,omitempty"`
}

func (s QueryDevicePropertyDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertyDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertyDataResponseBodyData) SetList(v *QueryDevicePropertyDataResponseBodyDataList) *QueryDevicePropertyDataResponseBodyData {
	s.List = v
	return s
}

func (s *QueryDevicePropertyDataResponseBodyData) SetNextTime(v int64) *QueryDevicePropertyDataResponseBodyData {
	s.NextTime = &v
	return s
}

func (s *QueryDevicePropertyDataResponseBodyData) SetNextValid(v bool) *QueryDevicePropertyDataResponseBodyData {
	s.NextValid = &v
	return s
}

type QueryDevicePropertyDataResponseBodyDataList struct {
	PropertyInfo []*QueryDevicePropertyDataResponseBodyDataListPropertyInfo `json:"PropertyInfo,omitempty" xml:"PropertyInfo,omitempty" type:"Repeated"`
}

func (s QueryDevicePropertyDataResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertyDataResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertyDataResponseBodyDataList) SetPropertyInfo(v []*QueryDevicePropertyDataResponseBodyDataListPropertyInfo) *QueryDevicePropertyDataResponseBodyDataList {
	s.PropertyInfo = v
	return s
}

type QueryDevicePropertyDataResponseBodyDataListPropertyInfo struct {
	// The time when the property was modified.
	Time *string `json:"Time,omitempty" xml:"Time,omitempty"`
	// The value of the property.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s QueryDevicePropertyDataResponseBodyDataListPropertyInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertyDataResponseBodyDataListPropertyInfo) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertyDataResponseBodyDataListPropertyInfo) SetTime(v string) *QueryDevicePropertyDataResponseBodyDataListPropertyInfo {
	s.Time = &v
	return s
}

func (s *QueryDevicePropertyDataResponseBodyDataListPropertyInfo) SetValue(v string) *QueryDevicePropertyDataResponseBodyDataListPropertyInfo {
	s.Value = &v
	return s
}

type QueryDevicePropertyDataResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDevicePropertyDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDevicePropertyDataResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertyDataResponse) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertyDataResponse) SetHeaders(v map[string]*string) *QueryDevicePropertyDataResponse {
	s.Headers = v
	return s
}

func (s *QueryDevicePropertyDataResponse) SetStatusCode(v int32) *QueryDevicePropertyDataResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDevicePropertyDataResponse) SetBody(v *QueryDevicePropertyDataResponseBody) *QueryDevicePropertyDataResponse {
	s.Body = v
	return s
}

type QueryDevicePropertyStatusRequest struct {
	// The DeviceName of the device.
	//
	// >If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The identifier of the custom TSL module. Each identifier is unique in a product.
	//
	// If you do not specify this parameter, the system queries the data of the default module.
	FunctionBlockId *string `json:"FunctionBlockId,omitempty" xml:"FunctionBlockId,omitempty"`
	// The ID of the device or digital twin node whose property data you want to query.
	//
	// *   You can call the [QueryDeviceInfo](~~257184~~) operation to query the **ID** of the device.
	// *   Log on to the IoT Platform console. On the **Twin Details** page, click the digital twin node to view its **ID**.
	//
	// >If you specify this parameter, you do not need to specify the **ProductKey** and **DeviceName** parameters. The **IotId** parameter specifies a globally unique identifier (GUID) for the device. The value of the IotId parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or instance ID appears in the console, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryDevicePropertyStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertyStatusRequest) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertyStatusRequest) SetDeviceName(v string) *QueryDevicePropertyStatusRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDevicePropertyStatusRequest) SetFunctionBlockId(v string) *QueryDevicePropertyStatusRequest {
	s.FunctionBlockId = &v
	return s
}

func (s *QueryDevicePropertyStatusRequest) SetIotId(v string) *QueryDevicePropertyStatusRequest {
	s.IotId = &v
	return s
}

func (s *QueryDevicePropertyStatusRequest) SetIotInstanceId(v string) *QueryDevicePropertyStatusRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDevicePropertyStatusRequest) SetProductKey(v string) *QueryDevicePropertyStatusRequest {
	s.ProductKey = &v
	return s
}

type QueryDevicePropertyStatusResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call succeeds. For more information, see **List**.
	Data *QueryDevicePropertyStatusResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDevicePropertyStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertyStatusResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertyStatusResponseBody) SetCode(v string) *QueryDevicePropertyStatusResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDevicePropertyStatusResponseBody) SetData(v *QueryDevicePropertyStatusResponseBodyData) *QueryDevicePropertyStatusResponseBody {
	s.Data = v
	return s
}

func (s *QueryDevicePropertyStatusResponseBody) SetErrorMessage(v string) *QueryDevicePropertyStatusResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDevicePropertyStatusResponseBody) SetRequestId(v string) *QueryDevicePropertyStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDevicePropertyStatusResponseBody) SetSuccess(v bool) *QueryDevicePropertyStatusResponseBody {
	s.Success = &v
	return s
}

type QueryDevicePropertyStatusResponseBodyData struct {
	// The array of property information. The information about each property is indicated by the **PropertyStatusInfo** parameter.
	List *QueryDevicePropertyStatusResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
}

func (s QueryDevicePropertyStatusResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertyStatusResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertyStatusResponseBodyData) SetList(v *QueryDevicePropertyStatusResponseBodyDataList) *QueryDevicePropertyStatusResponseBodyData {
	s.List = v
	return s
}

type QueryDevicePropertyStatusResponseBodyDataList struct {
	PropertyStatusInfo []*QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo `json:"PropertyStatusInfo,omitempty" xml:"PropertyStatusInfo,omitempty" type:"Repeated"`
}

func (s QueryDevicePropertyStatusResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertyStatusResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertyStatusResponseBodyDataList) SetPropertyStatusInfo(v []*QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo) *QueryDevicePropertyStatusResponseBodyDataList {
	s.PropertyStatusInfo = v
	return s
}

type QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo struct {
	// The data type of the property. Valid values:
	//
	// *   **int**: integer
	// *   **float**: single-precision floating-point number
	// *   **double**: double-precision floating-point number
	// *   **enum**: enumeration
	// *   **bool**: Boolean
	// *   **text**: character
	// *   **date**: time (string-type UTC timestamp in milliseconds)
	// *   **array**: array
	// *   **struct**: structure
	DataType *string `json:"DataType,omitempty" xml:"DataType,omitempty"`
	// The identifier of the property.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The name of the property.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The time when the property was modified, in milliseconds.
	Time *string `json:"Time,omitempty" xml:"Time,omitempty"`
	// The unit of the property value.
	Unit *string `json:"Unit,omitempty" xml:"Unit,omitempty"`
	// The value of the property.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo) SetDataType(v string) *QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo {
	s.DataType = &v
	return s
}

func (s *QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo) SetIdentifier(v string) *QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo {
	s.Identifier = &v
	return s
}

func (s *QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo) SetName(v string) *QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo {
	s.Name = &v
	return s
}

func (s *QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo) SetTime(v string) *QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo {
	s.Time = &v
	return s
}

func (s *QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo) SetUnit(v string) *QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo {
	s.Unit = &v
	return s
}

func (s *QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo) SetValue(v string) *QueryDevicePropertyStatusResponseBodyDataListPropertyStatusInfo {
	s.Value = &v
	return s
}

type QueryDevicePropertyStatusResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDevicePropertyStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDevicePropertyStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicePropertyStatusResponse) GoString() string {
	return s.String()
}

func (s *QueryDevicePropertyStatusResponse) SetHeaders(v map[string]*string) *QueryDevicePropertyStatusResponse {
	s.Headers = v
	return s
}

func (s *QueryDevicePropertyStatusResponse) SetStatusCode(v int32) *QueryDevicePropertyStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDevicePropertyStatusResponse) SetBody(v *QueryDevicePropertyStatusResponseBody) *QueryDevicePropertyStatusResponse {
	s.Body = v
	return s
}

type QueryDeviceProvisioningRequest struct {
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryDeviceProvisioningRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceProvisioningRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceProvisioningRequest) SetDeviceName(v string) *QueryDeviceProvisioningRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceProvisioningRequest) SetProductKey(v string) *QueryDeviceProvisioningRequest {
	s.ProductKey = &v
	return s
}

type QueryDeviceProvisioningResponseBody struct {
	Code         *string                                  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryDeviceProvisioningResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                  `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                    `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceProvisioningResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceProvisioningResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceProvisioningResponseBody) SetCode(v string) *QueryDeviceProvisioningResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceProvisioningResponseBody) SetData(v *QueryDeviceProvisioningResponseBodyData) *QueryDeviceProvisioningResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceProvisioningResponseBody) SetErrorMessage(v string) *QueryDeviceProvisioningResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceProvisioningResponseBody) SetRequestId(v string) *QueryDeviceProvisioningResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceProvisioningResponseBody) SetSuccess(v bool) *QueryDeviceProvisioningResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceProvisioningResponseBodyData struct {
	AliyunUid           *string `json:"AliyunUid,omitempty" xml:"AliyunUid,omitempty"`
	DeviceName          *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	GmtCreate           *int64  `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtModified         *int64  `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	ProductKey          *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	SourceIotInstanceId *string `json:"SourceIotInstanceId,omitempty" xml:"SourceIotInstanceId,omitempty"`
	SourceRegion        *string `json:"SourceRegion,omitempty" xml:"SourceRegion,omitempty"`
	TargetIotInstanceId *string `json:"TargetIotInstanceId,omitempty" xml:"TargetIotInstanceId,omitempty"`
	TargetRegion        *string `json:"TargetRegion,omitempty" xml:"TargetRegion,omitempty"`
}

func (s QueryDeviceProvisioningResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceProvisioningResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceProvisioningResponseBodyData) SetAliyunUid(v string) *QueryDeviceProvisioningResponseBodyData {
	s.AliyunUid = &v
	return s
}

func (s *QueryDeviceProvisioningResponseBodyData) SetDeviceName(v string) *QueryDeviceProvisioningResponseBodyData {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceProvisioningResponseBodyData) SetGmtCreate(v int64) *QueryDeviceProvisioningResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *QueryDeviceProvisioningResponseBodyData) SetGmtModified(v int64) *QueryDeviceProvisioningResponseBodyData {
	s.GmtModified = &v
	return s
}

func (s *QueryDeviceProvisioningResponseBodyData) SetProductKey(v string) *QueryDeviceProvisioningResponseBodyData {
	s.ProductKey = &v
	return s
}

func (s *QueryDeviceProvisioningResponseBodyData) SetSourceIotInstanceId(v string) *QueryDeviceProvisioningResponseBodyData {
	s.SourceIotInstanceId = &v
	return s
}

func (s *QueryDeviceProvisioningResponseBodyData) SetSourceRegion(v string) *QueryDeviceProvisioningResponseBodyData {
	s.SourceRegion = &v
	return s
}

func (s *QueryDeviceProvisioningResponseBodyData) SetTargetIotInstanceId(v string) *QueryDeviceProvisioningResponseBodyData {
	s.TargetIotInstanceId = &v
	return s
}

func (s *QueryDeviceProvisioningResponseBodyData) SetTargetRegion(v string) *QueryDeviceProvisioningResponseBodyData {
	s.TargetRegion = &v
	return s
}

type QueryDeviceProvisioningResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceProvisioningResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceProvisioningResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceProvisioningResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceProvisioningResponse) SetHeaders(v map[string]*string) *QueryDeviceProvisioningResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceProvisioningResponse) SetStatusCode(v int32) *QueryDeviceProvisioningResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceProvisioningResponse) SetBody(v *QueryDeviceProvisioningResponseBody) *QueryDeviceProvisioningResponse {
	s.Body = v
	return s
}

type QueryDeviceServiceDataRequest struct {
	// The sorting order of the returned service call records. Valid values:
	//
	// *   **0**: reverse chronological order
	// *   **1**: chronological order
	Asc *int32 `json:"Asc,omitempty" xml:"Asc,omitempty"`
	// The DeviceName of the device.
	//
	// > If you specify a value for this parameter, you must configure the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The end of the time range to query. The value is a Unix timestamp. Unit: milliseconds. Example: 1579249499000.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The identifier of the service. The **identifier** of the service that is called. You can view the service identifier on the Define Feature tab in the IoT Platform console. You can also call the [QueryThingModel](~~150321~~) operation to view the service identifier.
	//
	// >  If a service named **testService** belongs to a custom module named **testFb**, you can set this parameter to **testFb:testService**. The custom module is not the default module.
	//
	// If you do not specify a value for this parameter, the system queries all service data of the default module and custom modules.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// > The IotId parameter specifies a GUID for the device. The value of the **IotId** parameter is equivalent to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for this parameter, you do not need to configure the **ProductKey** or **DeviceName** parameter. If you specify values for the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 50.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >If you specify a value for this parameter, you must configure the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The beginning of the time range to query. The value is a Unix timestamp. Unit: milliseconds. Example: 1579249499000.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s QueryDeviceServiceDataRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceServiceDataRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceServiceDataRequest) SetAsc(v int32) *QueryDeviceServiceDataRequest {
	s.Asc = &v
	return s
}

func (s *QueryDeviceServiceDataRequest) SetDeviceName(v string) *QueryDeviceServiceDataRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceServiceDataRequest) SetEndTime(v int64) *QueryDeviceServiceDataRequest {
	s.EndTime = &v
	return s
}

func (s *QueryDeviceServiceDataRequest) SetIdentifier(v string) *QueryDeviceServiceDataRequest {
	s.Identifier = &v
	return s
}

func (s *QueryDeviceServiceDataRequest) SetIotId(v string) *QueryDeviceServiceDataRequest {
	s.IotId = &v
	return s
}

func (s *QueryDeviceServiceDataRequest) SetIotInstanceId(v string) *QueryDeviceServiceDataRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceServiceDataRequest) SetPageSize(v int32) *QueryDeviceServiceDataRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceServiceDataRequest) SetProductKey(v string) *QueryDeviceServiceDataRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryDeviceServiceDataRequest) SetStartTime(v int64) *QueryDeviceServiceDataRequest {
	s.StartTime = &v
	return s
}

type QueryDeviceServiceDataResponseBody struct {
	// The error code that is returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The service call records returned if the call is successful.
	Data *QueryDeviceServiceDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message that is returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. The ID uniquely identifies the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceServiceDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceServiceDataResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceServiceDataResponseBody) SetCode(v string) *QueryDeviceServiceDataResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceServiceDataResponseBody) SetData(v *QueryDeviceServiceDataResponseBodyData) *QueryDeviceServiceDataResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceServiceDataResponseBody) SetErrorMessage(v string) *QueryDeviceServiceDataResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceServiceDataResponseBody) SetRequestId(v string) *QueryDeviceServiceDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceServiceDataResponseBody) SetSuccess(v bool) *QueryDeviceServiceDataResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceServiceDataResponseBodyData struct {
	// The array of service call records. Each element represents a service call record.
	List *QueryDeviceServiceDataResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	// The start time of service call records on the next page.
	//
	// If you call the QueryDeviceServiceData operation to query the service call records on the next page, you must set the **StartTime** parameter to the value of this parameter.
	NextTime *int64 `json:"NextTime,omitempty" xml:"NextTime,omitempty"`
	// Indicates whether the next page exists.
	//
	// *   **true**
	// *   **false**
	//
	// If the return value of the **NextValid** parameter is **true**, you can use the value of the **NextTime** parameter as the value of the **StartTime** parameter when you query the next page of results.
	NextValid *bool `json:"NextValid,omitempty" xml:"NextValid,omitempty"`
}

func (s QueryDeviceServiceDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceServiceDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceServiceDataResponseBodyData) SetList(v *QueryDeviceServiceDataResponseBodyDataList) *QueryDeviceServiceDataResponseBodyData {
	s.List = v
	return s
}

func (s *QueryDeviceServiceDataResponseBodyData) SetNextTime(v int64) *QueryDeviceServiceDataResponseBodyData {
	s.NextTime = &v
	return s
}

func (s *QueryDeviceServiceDataResponseBodyData) SetNextValid(v bool) *QueryDeviceServiceDataResponseBodyData {
	s.NextValid = &v
	return s
}

type QueryDeviceServiceDataResponseBodyDataList struct {
	ServiceInfo []*QueryDeviceServiceDataResponseBodyDataListServiceInfo `json:"ServiceInfo,omitempty" xml:"ServiceInfo,omitempty" type:"Repeated"`
}

func (s QueryDeviceServiceDataResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceServiceDataResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryDeviceServiceDataResponseBodyDataList) SetServiceInfo(v []*QueryDeviceServiceDataResponseBodyDataListServiceInfo) *QueryDeviceServiceDataResponseBodyDataList {
	s.ServiceInfo = v
	return s
}

type QueryDeviceServiceDataResponseBodyDataListServiceInfo struct {
	// The identifier of the service.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The input parameter of the service. The value is a string in the MAP format. Syntax: `key:value`.
	InputData *string `json:"InputData,omitempty" xml:"InputData,omitempty"`
	// The name of the service.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The output parameter of the service. The value is a string in the MAP format. Syntax: `key:value`.
	OutputData *string `json:"OutputData,omitempty" xml:"OutputData,omitempty"`
	// The time when the service was called.
	Time *string `json:"Time,omitempty" xml:"Time,omitempty"`
}

func (s QueryDeviceServiceDataResponseBodyDataListServiceInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceServiceDataResponseBodyDataListServiceInfo) GoString() string {
	return s.String()
}

func (s *QueryDeviceServiceDataResponseBodyDataListServiceInfo) SetIdentifier(v string) *QueryDeviceServiceDataResponseBodyDataListServiceInfo {
	s.Identifier = &v
	return s
}

func (s *QueryDeviceServiceDataResponseBodyDataListServiceInfo) SetInputData(v string) *QueryDeviceServiceDataResponseBodyDataListServiceInfo {
	s.InputData = &v
	return s
}

func (s *QueryDeviceServiceDataResponseBodyDataListServiceInfo) SetName(v string) *QueryDeviceServiceDataResponseBodyDataListServiceInfo {
	s.Name = &v
	return s
}

func (s *QueryDeviceServiceDataResponseBodyDataListServiceInfo) SetOutputData(v string) *QueryDeviceServiceDataResponseBodyDataListServiceInfo {
	s.OutputData = &v
	return s
}

func (s *QueryDeviceServiceDataResponseBodyDataListServiceInfo) SetTime(v string) *QueryDeviceServiceDataResponseBodyDataListServiceInfo {
	s.Time = &v
	return s
}

type QueryDeviceServiceDataResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceServiceDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceServiceDataResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceServiceDataResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceServiceDataResponse) SetHeaders(v map[string]*string) *QueryDeviceServiceDataResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceServiceDataResponse) SetStatusCode(v int32) *QueryDeviceServiceDataResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceServiceDataResponse) SetBody(v *QueryDeviceServiceDataResponseBody) *QueryDeviceServiceDataResponse {
	s.Body = v
	return s
}

type QueryDeviceSpeechRequest struct {
	IotId         *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageId        *int32  `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QueryDeviceSpeechRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceSpeechRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceSpeechRequest) SetIotId(v string) *QueryDeviceSpeechRequest {
	s.IotId = &v
	return s
}

func (s *QueryDeviceSpeechRequest) SetIotInstanceId(v string) *QueryDeviceSpeechRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceSpeechRequest) SetPageId(v int32) *QueryDeviceSpeechRequest {
	s.PageId = &v
	return s
}

func (s *QueryDeviceSpeechRequest) SetPageSize(v int32) *QueryDeviceSpeechRequest {
	s.PageSize = &v
	return s
}

type QueryDeviceSpeechResponseBody struct {
	Code         *string                            `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryDeviceSpeechResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                            `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                              `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceSpeechResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceSpeechResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceSpeechResponseBody) SetCode(v string) *QueryDeviceSpeechResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceSpeechResponseBody) SetData(v *QueryDeviceSpeechResponseBodyData) *QueryDeviceSpeechResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceSpeechResponseBody) SetErrorMessage(v string) *QueryDeviceSpeechResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceSpeechResponseBody) SetRequestId(v string) *QueryDeviceSpeechResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceSpeechResponseBody) SetSuccess(v bool) *QueryDeviceSpeechResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceSpeechResponseBodyData struct {
	List     *QueryDeviceSpeechResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageId   *int32                                 `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize *int32                                 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total    *int32                                 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryDeviceSpeechResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceSpeechResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceSpeechResponseBodyData) SetList(v *QueryDeviceSpeechResponseBodyDataList) *QueryDeviceSpeechResponseBodyData {
	s.List = v
	return s
}

func (s *QueryDeviceSpeechResponseBodyData) SetPageId(v int32) *QueryDeviceSpeechResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QueryDeviceSpeechResponseBodyData) SetPageSize(v int32) *QueryDeviceSpeechResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryDeviceSpeechResponseBodyData) SetTotal(v int32) *QueryDeviceSpeechResponseBodyData {
	s.Total = &v
	return s
}

type QueryDeviceSpeechResponseBodyDataList struct {
	Items []*QueryDeviceSpeechResponseBodyDataListItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s QueryDeviceSpeechResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceSpeechResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryDeviceSpeechResponseBodyDataList) SetItems(v []*QueryDeviceSpeechResponseBodyDataListItems) *QueryDeviceSpeechResponseBodyDataList {
	s.Items = v
	return s
}

type QueryDeviceSpeechResponseBodyDataListItems struct {
	AudioFormat *string  `json:"AudioFormat,omitempty" xml:"AudioFormat,omitempty"`
	BizCode     *string  `json:"BizCode,omitempty" xml:"BizCode,omitempty"`
	Size        *float32 `json:"Size,omitempty" xml:"Size,omitempty"`
}

func (s QueryDeviceSpeechResponseBodyDataListItems) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceSpeechResponseBodyDataListItems) GoString() string {
	return s.String()
}

func (s *QueryDeviceSpeechResponseBodyDataListItems) SetAudioFormat(v string) *QueryDeviceSpeechResponseBodyDataListItems {
	s.AudioFormat = &v
	return s
}

func (s *QueryDeviceSpeechResponseBodyDataListItems) SetBizCode(v string) *QueryDeviceSpeechResponseBodyDataListItems {
	s.BizCode = &v
	return s
}

func (s *QueryDeviceSpeechResponseBodyDataListItems) SetSize(v float32) *QueryDeviceSpeechResponseBodyDataListItems {
	s.Size = &v
	return s
}

type QueryDeviceSpeechResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceSpeechResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceSpeechResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceSpeechResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceSpeechResponse) SetHeaders(v map[string]*string) *QueryDeviceSpeechResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceSpeechResponse) SetStatusCode(v int32) *QueryDeviceSpeechResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceSpeechResponse) SetBody(v *QueryDeviceSpeechResponseBody) *QueryDeviceSpeechResponse {
	s.Body = v
	return s
}

type QueryDeviceStatisticsRequest struct {
	// The ID of the group to which the devices belong.
	//
	// *   If you specify this parameter, the statistics of the devices that are added to the group is returned. If you also specify **ProductKey**, the statistics of the devices that are created under the product and added to the group is returned.
	// *   If you do not specify this parameter and **ProductKey**, the statistics of all devices within the current account is returned.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the devices belong.
	//
	// *   If you specify this parameter, the statistics of the devices under the product is returned. If you also specify **GroupId**, the statistics of the devices that are created under the product and added to the group is returned.
	// *   If you do not specify this parameter and **GroupId**, the statistics of all devices within the current account is returned.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryDeviceStatisticsRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceStatisticsRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceStatisticsRequest) SetGroupId(v string) *QueryDeviceStatisticsRequest {
	s.GroupId = &v
	return s
}

func (s *QueryDeviceStatisticsRequest) SetIotInstanceId(v string) *QueryDeviceStatisticsRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceStatisticsRequest) SetProductKey(v string) *QueryDeviceStatisticsRequest {
	s.ProductKey = &v
	return s
}

type QueryDeviceStatisticsResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The device statistics returned if the call is successful.
	Data *QueryDeviceStatisticsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceStatisticsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceStatisticsResponseBody) SetCode(v string) *QueryDeviceStatisticsResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceStatisticsResponseBody) SetData(v *QueryDeviceStatisticsResponseBodyData) *QueryDeviceStatisticsResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceStatisticsResponseBody) SetErrorMessage(v string) *QueryDeviceStatisticsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceStatisticsResponseBody) SetRequestId(v string) *QueryDeviceStatisticsResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceStatisticsResponseBody) SetSuccess(v bool) *QueryDeviceStatisticsResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceStatisticsResponseBodyData struct {
	// The number of activated devices.
	ActiveCount *int64 `json:"activeCount,omitempty" xml:"activeCount,omitempty"`
	// The total number of devices.
	DeviceCount *int64 `json:"deviceCount,omitempty" xml:"deviceCount,omitempty"`
	// The number of online devices.
	OnlineCount *int64 `json:"onlineCount,omitempty" xml:"onlineCount,omitempty"`
}

func (s QueryDeviceStatisticsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceStatisticsResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceStatisticsResponseBodyData) SetActiveCount(v int64) *QueryDeviceStatisticsResponseBodyData {
	s.ActiveCount = &v
	return s
}

func (s *QueryDeviceStatisticsResponseBodyData) SetDeviceCount(v int64) *QueryDeviceStatisticsResponseBodyData {
	s.DeviceCount = &v
	return s
}

func (s *QueryDeviceStatisticsResponseBodyData) SetOnlineCount(v int64) *QueryDeviceStatisticsResponseBodyData {
	s.OnlineCount = &v
	return s
}

type QueryDeviceStatisticsResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceStatisticsResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceStatisticsResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceStatisticsResponse) SetHeaders(v map[string]*string) *QueryDeviceStatisticsResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceStatisticsResponse) SetStatusCode(v int32) *QueryDeviceStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceStatisticsResponse) SetBody(v *QueryDeviceStatisticsResponseBody) *QueryDeviceStatisticsResponse {
	s.Body = v
	return s
}

type QueryDeviceSubTopicRequest struct {
	// The name of the device.
	//
	// You can use the IoT Platform console or call the [QueryDeviceInfo](~~257184~~) operation to view the information about the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the instance. You can view the ID of an instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. If you do not specify the instance ID, the call fails.
	// >*   If the **Overview** page or instance ID is not displayed in the IoT Platform console, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current Alibaba Cloud account.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryDeviceSubTopicRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceSubTopicRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceSubTopicRequest) SetDeviceName(v string) *QueryDeviceSubTopicRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceSubTopicRequest) SetIotInstanceId(v string) *QueryDeviceSubTopicRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceSubTopicRequest) SetProductKey(v string) *QueryDeviceSubTopicRequest {
	s.ProductKey = &v
	return s
}

type QueryDeviceSubTopicResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. The ID uniquely identifies this request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The information about the topics to which the device has subscribed. This parameter is returned if the call was successful.
	TopicList []*QueryDeviceSubTopicResponseBodyTopicList `json:"TopicList,omitempty" xml:"TopicList,omitempty" type:"Repeated"`
}

func (s QueryDeviceSubTopicResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceSubTopicResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceSubTopicResponseBody) SetCode(v string) *QueryDeviceSubTopicResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceSubTopicResponseBody) SetErrorMessage(v string) *QueryDeviceSubTopicResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceSubTopicResponseBody) SetRequestId(v string) *QueryDeviceSubTopicResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceSubTopicResponseBody) SetSuccess(v bool) *QueryDeviceSubTopicResponseBody {
	s.Success = &v
	return s
}

func (s *QueryDeviceSubTopicResponseBody) SetTopicList(v []*QueryDeviceSubTopicResponseBodyTopicList) *QueryDeviceSubTopicResponseBody {
	s.TopicList = v
	return s
}

type QueryDeviceSubTopicResponseBodyTopicList struct {
	// The time when the device subscribed to a topic. Unit: milliseconds.
	Timestamp *int64 `json:"Timestamp,omitempty" xml:"Timestamp,omitempty"`
	// The name of the topic.
	TopicName *string `json:"TopicName,omitempty" xml:"TopicName,omitempty"`
}

func (s QueryDeviceSubTopicResponseBodyTopicList) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceSubTopicResponseBodyTopicList) GoString() string {
	return s.String()
}

func (s *QueryDeviceSubTopicResponseBodyTopicList) SetTimestamp(v int64) *QueryDeviceSubTopicResponseBodyTopicList {
	s.Timestamp = &v
	return s
}

func (s *QueryDeviceSubTopicResponseBodyTopicList) SetTopicName(v string) *QueryDeviceSubTopicResponseBodyTopicList {
	s.TopicName = &v
	return s
}

type QueryDeviceSubTopicResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceSubTopicResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceSubTopicResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceSubTopicResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceSubTopicResponse) SetHeaders(v map[string]*string) *QueryDeviceSubTopicResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceSubTopicResponse) SetStatusCode(v int32) *QueryDeviceSubTopicResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceSubTopicResponse) SetBody(v *QueryDeviceSubTopicResponseBody) *QueryDeviceSubTopicResponse {
	s.Body = v
	return s
}

type QueryDeviceTunnelRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	TunnelId      *string `json:"TunnelId,omitempty" xml:"TunnelId,omitempty"`
}

func (s QueryDeviceTunnelRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceTunnelRequest) GoString() string {
	return s.String()
}

func (s *QueryDeviceTunnelRequest) SetIotInstanceId(v string) *QueryDeviceTunnelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDeviceTunnelRequest) SetTunnelId(v string) *QueryDeviceTunnelRequest {
	s.TunnelId = &v
	return s
}

type QueryDeviceTunnelResponseBody struct {
	Code         *string                            `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryDeviceTunnelResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                            `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                              `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDeviceTunnelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceTunnelResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDeviceTunnelResponseBody) SetCode(v string) *QueryDeviceTunnelResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDeviceTunnelResponseBody) SetData(v *QueryDeviceTunnelResponseBodyData) *QueryDeviceTunnelResponseBody {
	s.Data = v
	return s
}

func (s *QueryDeviceTunnelResponseBody) SetErrorMessage(v string) *QueryDeviceTunnelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDeviceTunnelResponseBody) SetRequestId(v string) *QueryDeviceTunnelResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDeviceTunnelResponseBody) SetSuccess(v bool) *QueryDeviceTunnelResponseBody {
	s.Success = &v
	return s
}

type QueryDeviceTunnelResponseBodyData struct {
	Description     *string `json:"Description,omitempty" xml:"Description,omitempty"`
	DeviceConnState *string `json:"DeviceConnState,omitempty" xml:"DeviceConnState,omitempty"`
	DeviceName      *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotId           *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	ProductKey      *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	ProductName     *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
	SourceConnState *string `json:"SourceConnState,omitempty" xml:"SourceConnState,omitempty"`
	TunnelId        *string `json:"TunnelId,omitempty" xml:"TunnelId,omitempty"`
	TunnelState     *string `json:"TunnelState,omitempty" xml:"TunnelState,omitempty"`
	Udi             *string `json:"Udi,omitempty" xml:"Udi,omitempty"`
	UtcClosed       *string `json:"UtcClosed,omitempty" xml:"UtcClosed,omitempty"`
	UtcCreated      *string `json:"UtcCreated,omitempty" xml:"UtcCreated,omitempty"`
}

func (s QueryDeviceTunnelResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceTunnelResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDeviceTunnelResponseBodyData) SetDescription(v string) *QueryDeviceTunnelResponseBodyData {
	s.Description = &v
	return s
}

func (s *QueryDeviceTunnelResponseBodyData) SetDeviceConnState(v string) *QueryDeviceTunnelResponseBodyData {
	s.DeviceConnState = &v
	return s
}

func (s *QueryDeviceTunnelResponseBodyData) SetDeviceName(v string) *QueryDeviceTunnelResponseBodyData {
	s.DeviceName = &v
	return s
}

func (s *QueryDeviceTunnelResponseBodyData) SetIotId(v string) *QueryDeviceTunnelResponseBodyData {
	s.IotId = &v
	return s
}

func (s *QueryDeviceTunnelResponseBodyData) SetProductKey(v string) *QueryDeviceTunnelResponseBodyData {
	s.ProductKey = &v
	return s
}

func (s *QueryDeviceTunnelResponseBodyData) SetProductName(v string) *QueryDeviceTunnelResponseBodyData {
	s.ProductName = &v
	return s
}

func (s *QueryDeviceTunnelResponseBodyData) SetSourceConnState(v string) *QueryDeviceTunnelResponseBodyData {
	s.SourceConnState = &v
	return s
}

func (s *QueryDeviceTunnelResponseBodyData) SetTunnelId(v string) *QueryDeviceTunnelResponseBodyData {
	s.TunnelId = &v
	return s
}

func (s *QueryDeviceTunnelResponseBodyData) SetTunnelState(v string) *QueryDeviceTunnelResponseBodyData {
	s.TunnelState = &v
	return s
}

func (s *QueryDeviceTunnelResponseBodyData) SetUdi(v string) *QueryDeviceTunnelResponseBodyData {
	s.Udi = &v
	return s
}

func (s *QueryDeviceTunnelResponseBodyData) SetUtcClosed(v string) *QueryDeviceTunnelResponseBodyData {
	s.UtcClosed = &v
	return s
}

func (s *QueryDeviceTunnelResponseBodyData) SetUtcCreated(v string) *QueryDeviceTunnelResponseBodyData {
	s.UtcCreated = &v
	return s
}

type QueryDeviceTunnelResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDeviceTunnelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDeviceTunnelResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDeviceTunnelResponse) GoString() string {
	return s.String()
}

func (s *QueryDeviceTunnelResponse) SetHeaders(v map[string]*string) *QueryDeviceTunnelResponse {
	s.Headers = v
	return s
}

func (s *QueryDeviceTunnelResponse) SetStatusCode(v int32) *QueryDeviceTunnelResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDeviceTunnelResponse) SetBody(v *QueryDeviceTunnelResponseBody) *QueryDeviceTunnelResponse {
	s.Body = v
	return s
}

type QueryDevicesHotStorageDataRequest struct {
	Asc           *int32  `json:"Asc,omitempty" xml:"Asc,omitempty"`
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	EndTime       *int64  `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	Identifier    *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	IotId         *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	NextPageToken *string `json:"NextPageToken,omitempty" xml:"NextPageToken,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	StartTime     *int64  `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	UserTopic     *string `json:"UserTopic,omitempty" xml:"UserTopic,omitempty"`
}

func (s QueryDevicesHotStorageDataRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicesHotStorageDataRequest) GoString() string {
	return s.String()
}

func (s *QueryDevicesHotStorageDataRequest) SetAsc(v int32) *QueryDevicesHotStorageDataRequest {
	s.Asc = &v
	return s
}

func (s *QueryDevicesHotStorageDataRequest) SetDeviceName(v string) *QueryDevicesHotStorageDataRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDevicesHotStorageDataRequest) SetEndTime(v int64) *QueryDevicesHotStorageDataRequest {
	s.EndTime = &v
	return s
}

func (s *QueryDevicesHotStorageDataRequest) SetIdentifier(v string) *QueryDevicesHotStorageDataRequest {
	s.Identifier = &v
	return s
}

func (s *QueryDevicesHotStorageDataRequest) SetIotId(v string) *QueryDevicesHotStorageDataRequest {
	s.IotId = &v
	return s
}

func (s *QueryDevicesHotStorageDataRequest) SetIotInstanceId(v string) *QueryDevicesHotStorageDataRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDevicesHotStorageDataRequest) SetNextPageToken(v string) *QueryDevicesHotStorageDataRequest {
	s.NextPageToken = &v
	return s
}

func (s *QueryDevicesHotStorageDataRequest) SetPageSize(v int32) *QueryDevicesHotStorageDataRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDevicesHotStorageDataRequest) SetProductKey(v string) *QueryDevicesHotStorageDataRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryDevicesHotStorageDataRequest) SetStartTime(v int64) *QueryDevicesHotStorageDataRequest {
	s.StartTime = &v
	return s
}

func (s *QueryDevicesHotStorageDataRequest) SetUserTopic(v string) *QueryDevicesHotStorageDataRequest {
	s.UserTopic = &v
	return s
}

type QueryDevicesHotStorageDataResponseBody struct {
	Code         *string                                     `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryDevicesHotStorageDataResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDevicesHotStorageDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicesHotStorageDataResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDevicesHotStorageDataResponseBody) SetCode(v string) *QueryDevicesHotStorageDataResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDevicesHotStorageDataResponseBody) SetData(v *QueryDevicesHotStorageDataResponseBodyData) *QueryDevicesHotStorageDataResponseBody {
	s.Data = v
	return s
}

func (s *QueryDevicesHotStorageDataResponseBody) SetErrorMessage(v string) *QueryDevicesHotStorageDataResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDevicesHotStorageDataResponseBody) SetRequestId(v string) *QueryDevicesHotStorageDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDevicesHotStorageDataResponseBody) SetSuccess(v bool) *QueryDevicesHotStorageDataResponseBody {
	s.Success = &v
	return s
}

type QueryDevicesHotStorageDataResponseBodyData struct {
	List          *QueryDevicesHotStorageDataResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	NextValid     *bool                                           `json:"NextValid,omitempty" xml:"NextValid,omitempty"`
	NextPageToken *string                                         `json:"nextPageToken,omitempty" xml:"nextPageToken,omitempty"`
}

func (s QueryDevicesHotStorageDataResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicesHotStorageDataResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDevicesHotStorageDataResponseBodyData) SetList(v *QueryDevicesHotStorageDataResponseBodyDataList) *QueryDevicesHotStorageDataResponseBodyData {
	s.List = v
	return s
}

func (s *QueryDevicesHotStorageDataResponseBodyData) SetNextValid(v bool) *QueryDevicesHotStorageDataResponseBodyData {
	s.NextValid = &v
	return s
}

func (s *QueryDevicesHotStorageDataResponseBodyData) SetNextPageToken(v string) *QueryDevicesHotStorageDataResponseBodyData {
	s.NextPageToken = &v
	return s
}

type QueryDevicesHotStorageDataResponseBodyDataList struct {
	PropertyInfo []*QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo `json:"PropertyInfo,omitempty" xml:"PropertyInfo,omitempty" type:"Repeated"`
}

func (s QueryDevicesHotStorageDataResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicesHotStorageDataResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryDevicesHotStorageDataResponseBodyDataList) SetPropertyInfo(v []*QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo) *QueryDevicesHotStorageDataResponseBodyDataList {
	s.PropertyInfo = v
	return s
}

type QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo struct {
	Time  *string `json:"Time,omitempty" xml:"Time,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo) GoString() string {
	return s.String()
}

func (s *QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo) SetTime(v string) *QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo {
	s.Time = &v
	return s
}

func (s *QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo) SetValue(v string) *QueryDevicesHotStorageDataResponseBodyDataListPropertyInfo {
	s.Value = &v
	return s
}

type QueryDevicesHotStorageDataResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDevicesHotStorageDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDevicesHotStorageDataResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicesHotStorageDataResponse) GoString() string {
	return s.String()
}

func (s *QueryDevicesHotStorageDataResponse) SetHeaders(v map[string]*string) *QueryDevicesHotStorageDataResponse {
	s.Headers = v
	return s
}

func (s *QueryDevicesHotStorageDataResponse) SetStatusCode(v int32) *QueryDevicesHotStorageDataResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDevicesHotStorageDataResponse) SetBody(v *QueryDevicesHotStorageDataResponseBody) *QueryDevicesHotStorageDataResponse {
	s.Body = v
	return s
}

type QueryDevicesHotStorageDataStatusRequest struct {
	Asc           *int32  `json:"Asc,omitempty" xml:"Asc,omitempty"`
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotId         *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	NextPageToken *string `json:"NextPageToken,omitempty" xml:"NextPageToken,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	UserTopic     *string `json:"UserTopic,omitempty" xml:"UserTopic,omitempty"`
}

func (s QueryDevicesHotStorageDataStatusRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicesHotStorageDataStatusRequest) GoString() string {
	return s.String()
}

func (s *QueryDevicesHotStorageDataStatusRequest) SetAsc(v int32) *QueryDevicesHotStorageDataStatusRequest {
	s.Asc = &v
	return s
}

func (s *QueryDevicesHotStorageDataStatusRequest) SetDeviceName(v string) *QueryDevicesHotStorageDataStatusRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDevicesHotStorageDataStatusRequest) SetIotId(v string) *QueryDevicesHotStorageDataStatusRequest {
	s.IotId = &v
	return s
}

func (s *QueryDevicesHotStorageDataStatusRequest) SetIotInstanceId(v string) *QueryDevicesHotStorageDataStatusRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDevicesHotStorageDataStatusRequest) SetNextPageToken(v string) *QueryDevicesHotStorageDataStatusRequest {
	s.NextPageToken = &v
	return s
}

func (s *QueryDevicesHotStorageDataStatusRequest) SetPageSize(v int32) *QueryDevicesHotStorageDataStatusRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDevicesHotStorageDataStatusRequest) SetProductKey(v string) *QueryDevicesHotStorageDataStatusRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryDevicesHotStorageDataStatusRequest) SetUserTopic(v string) *QueryDevicesHotStorageDataStatusRequest {
	s.UserTopic = &v
	return s
}

type QueryDevicesHotStorageDataStatusResponseBody struct {
	Code         *string                                           `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryDevicesHotStorageDataStatusResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                           `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                             `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryDevicesHotStorageDataStatusResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicesHotStorageDataStatusResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDevicesHotStorageDataStatusResponseBody) SetCode(v string) *QueryDevicesHotStorageDataStatusResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDevicesHotStorageDataStatusResponseBody) SetData(v *QueryDevicesHotStorageDataStatusResponseBodyData) *QueryDevicesHotStorageDataStatusResponseBody {
	s.Data = v
	return s
}

func (s *QueryDevicesHotStorageDataStatusResponseBody) SetErrorMessage(v string) *QueryDevicesHotStorageDataStatusResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDevicesHotStorageDataStatusResponseBody) SetRequestId(v string) *QueryDevicesHotStorageDataStatusResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDevicesHotStorageDataStatusResponseBody) SetSuccess(v bool) *QueryDevicesHotStorageDataStatusResponseBody {
	s.Success = &v
	return s
}

type QueryDevicesHotStorageDataStatusResponseBodyData struct {
	List          *QueryDevicesHotStorageDataStatusResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	NextPageToken *string                                               `json:"NextPageToken,omitempty" xml:"NextPageToken,omitempty"`
	NextValid     *bool                                                 `json:"NextValid,omitempty" xml:"NextValid,omitempty"`
}

func (s QueryDevicesHotStorageDataStatusResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicesHotStorageDataStatusResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDevicesHotStorageDataStatusResponseBodyData) SetList(v *QueryDevicesHotStorageDataStatusResponseBodyDataList) *QueryDevicesHotStorageDataStatusResponseBodyData {
	s.List = v
	return s
}

func (s *QueryDevicesHotStorageDataStatusResponseBodyData) SetNextPageToken(v string) *QueryDevicesHotStorageDataStatusResponseBodyData {
	s.NextPageToken = &v
	return s
}

func (s *QueryDevicesHotStorageDataStatusResponseBodyData) SetNextValid(v bool) *QueryDevicesHotStorageDataStatusResponseBodyData {
	s.NextValid = &v
	return s
}

type QueryDevicesHotStorageDataStatusResponseBodyDataList struct {
	PropertyStatusDataInfo []*QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo `json:"PropertyStatusDataInfo,omitempty" xml:"PropertyStatusDataInfo,omitempty" type:"Repeated"`
}

func (s QueryDevicesHotStorageDataStatusResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicesHotStorageDataStatusResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryDevicesHotStorageDataStatusResponseBodyDataList) SetPropertyStatusDataInfo(v []*QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo) *QueryDevicesHotStorageDataStatusResponseBodyDataList {
	s.PropertyStatusDataInfo = v
	return s
}

type QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo struct {
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	Time       *int64  `json:"Time,omitempty" xml:"Time,omitempty"`
	Value      *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo) GoString() string {
	return s.String()
}

func (s *QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo) SetIdentifier(v string) *QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo {
	s.Identifier = &v
	return s
}

func (s *QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo) SetTime(v int64) *QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo {
	s.Time = &v
	return s
}

func (s *QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo) SetValue(v string) *QueryDevicesHotStorageDataStatusResponseBodyDataListPropertyStatusDataInfo {
	s.Value = &v
	return s
}

type QueryDevicesHotStorageDataStatusResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDevicesHotStorageDataStatusResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDevicesHotStorageDataStatusResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDevicesHotStorageDataStatusResponse) GoString() string {
	return s.String()
}

func (s *QueryDevicesHotStorageDataStatusResponse) SetHeaders(v map[string]*string) *QueryDevicesHotStorageDataStatusResponse {
	s.Headers = v
	return s
}

func (s *QueryDevicesHotStorageDataStatusResponse) SetStatusCode(v int32) *QueryDevicesHotStorageDataStatusResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDevicesHotStorageDataStatusResponse) SetBody(v *QueryDevicesHotStorageDataStatusResponseBody) *QueryDevicesHotStorageDataStatusResponse {
	s.Body = v
	return s
}

type QueryDynamicGroupDevicesRequest struct {
	// The page number. Default value: 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The DeviceName of the device.
	//
	// If you specify this parameter and set **FuzzyName** to **true**, the value you specified is used as the prefix to fuzzy match the DeviceName. The value must be at least 4 characters in length.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// Specifies whether to fuzzy match devices by the value of the **DeviceName** parameter. Valid values:
	//
	// *   **true**
	// *   **false** (default)
	FuzzyName *bool `json:"FuzzyName,omitempty" xml:"FuzzyName,omitempty"`
	// The ID of the group. The ID is the globally unique identifier (GUID) for the group.
	//
	// You can call the [QueryDeviceGroupList](~~93356~~) operation to query the **GroupId** parameter.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The number of entries per page. Valid values: 1 to 200. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The **ProductKey** of the product to which the devices belong.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The device status. Valid values:
	//
	// *   **ONLINE**: The device is online.
	// *   **OFFLINE**: The device is offline.
	// *   **UNACTIVE**: The device is not activated.
	// *   **DISABLE**: The device is deactivated.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s QueryDynamicGroupDevicesRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryDynamicGroupDevicesRequest) GoString() string {
	return s.String()
}

func (s *QueryDynamicGroupDevicesRequest) SetCurrentPage(v int32) *QueryDynamicGroupDevicesRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryDynamicGroupDevicesRequest) SetDeviceName(v string) *QueryDynamicGroupDevicesRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryDynamicGroupDevicesRequest) SetFuzzyName(v bool) *QueryDynamicGroupDevicesRequest {
	s.FuzzyName = &v
	return s
}

func (s *QueryDynamicGroupDevicesRequest) SetGroupId(v string) *QueryDynamicGroupDevicesRequest {
	s.GroupId = &v
	return s
}

func (s *QueryDynamicGroupDevicesRequest) SetIotInstanceId(v string) *QueryDynamicGroupDevicesRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryDynamicGroupDevicesRequest) SetNextToken(v string) *QueryDynamicGroupDevicesRequest {
	s.NextToken = &v
	return s
}

func (s *QueryDynamicGroupDevicesRequest) SetPageSize(v int32) *QueryDynamicGroupDevicesRequest {
	s.PageSize = &v
	return s
}

func (s *QueryDynamicGroupDevicesRequest) SetProductKey(v string) *QueryDynamicGroupDevicesRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryDynamicGroupDevicesRequest) SetStatus(v string) *QueryDynamicGroupDevicesRequest {
	s.Status = &v
	return s
}

type QueryDynamicGroupDevicesResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The devices returned after the request succeeds. The information is included in the **SimpleDeviceInfo** field.
	Data *QueryDynamicGroupDevicesResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// A pagination token. It can be used in the next request to retrieve a new page of results.
	//
	// If NextToken is empty, no next page exists.
	NextToken *string `json:"NextToken,omitempty" xml:"NextToken,omitempty"`
	// The page number.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The total number of pages returned.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of devices.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryDynamicGroupDevicesResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryDynamicGroupDevicesResponseBody) GoString() string {
	return s.String()
}

func (s *QueryDynamicGroupDevicesResponseBody) SetCode(v string) *QueryDynamicGroupDevicesResponseBody {
	s.Code = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBody) SetData(v *QueryDynamicGroupDevicesResponseBodyData) *QueryDynamicGroupDevicesResponseBody {
	s.Data = v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBody) SetErrorMessage(v string) *QueryDynamicGroupDevicesResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBody) SetNextToken(v string) *QueryDynamicGroupDevicesResponseBody {
	s.NextToken = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBody) SetPage(v int32) *QueryDynamicGroupDevicesResponseBody {
	s.Page = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBody) SetPageCount(v int32) *QueryDynamicGroupDevicesResponseBody {
	s.PageCount = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBody) SetPageSize(v int32) *QueryDynamicGroupDevicesResponseBody {
	s.PageSize = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBody) SetRequestId(v string) *QueryDynamicGroupDevicesResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBody) SetSuccess(v bool) *QueryDynamicGroupDevicesResponseBody {
	s.Success = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBody) SetTotal(v int32) *QueryDynamicGroupDevicesResponseBody {
	s.Total = &v
	return s
}

type QueryDynamicGroupDevicesResponseBodyData struct {
	SimpleDeviceInfo []*QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo `json:"SimpleDeviceInfo,omitempty" xml:"SimpleDeviceInfo,omitempty" type:"Repeated"`
}

func (s QueryDynamicGroupDevicesResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryDynamicGroupDevicesResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryDynamicGroupDevicesResponseBodyData) SetSimpleDeviceInfo(v []*QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo) *QueryDynamicGroupDevicesResponseBodyData {
	s.SimpleDeviceInfo = v
	return s
}

type QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo struct {
	// The time when the device was activated.
	ActiveTime *string `json:"ActiveTime,omitempty" xml:"ActiveTime,omitempty"`
	// The identifier of the category to which the product belongs.
	//
	// This parameter is returned if the product uses the Thing Specification Language (TSL) model of a standard category that is pre-defined by IoT Platform.
	CategoryKey *string `json:"CategoryKey,omitempty" xml:"CategoryKey,omitempty"`
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The last time when the device went online.
	LastOnlineTime *string `json:"LastOnlineTime,omitempty" xml:"LastOnlineTime,omitempty"`
	// The alias of the device.
	Nickname *string `json:"Nickname,omitempty" xml:"Nickname,omitempty"`
	// The node type of the product. Valid values:
	//
	// *   **0**: device. A device can connect to IoT Platform directly, or be attached to a gateway as a sub-device and then connect to IoT Platform. Sub-devices cannot be attached to a device.
	// *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain topological relationships with sub-devices, and synchronize topological relationships to IoT Platform.
	NodeType *int32 `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ProductName of the product to which the device belongs.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
	// The device status. Valid values:
	//
	// *   **ONLINE**: The device is online.
	// *   **OFFLINE**: The device is offline.
	// *   **UNACTIVE**: The device is not activated.
	// *   **DISABLE**: The device is deactivated.
	Status *string `json:"Status,omitempty" xml:"Status,omitempty"`
	// The time when the device was activated. The time is in the UTC format.
	UtcActiveTime *string `json:"UtcActiveTime,omitempty" xml:"UtcActiveTime,omitempty"`
	// The last time when the device went online. The time is in the UTC format.
	UtcLastOnlineTime *string `json:"UtcLastOnlineTime,omitempty" xml:"UtcLastOnlineTime,omitempty"`
}

func (s QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo) GoString() string {
	return s.String()
}

func (s *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo) SetActiveTime(v string) *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo {
	s.ActiveTime = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo) SetCategoryKey(v string) *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo {
	s.CategoryKey = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo) SetDeviceName(v string) *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo {
	s.DeviceName = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo) SetIotId(v string) *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo {
	s.IotId = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo) SetLastOnlineTime(v string) *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo {
	s.LastOnlineTime = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo) SetNickname(v string) *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo {
	s.Nickname = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo) SetNodeType(v int32) *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo {
	s.NodeType = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo) SetProductKey(v string) *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo {
	s.ProductKey = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo) SetProductName(v string) *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo {
	s.ProductName = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo) SetStatus(v string) *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo {
	s.Status = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo) SetUtcActiveTime(v string) *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo {
	s.UtcActiveTime = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo) SetUtcLastOnlineTime(v string) *QueryDynamicGroupDevicesResponseBodyDataSimpleDeviceInfo {
	s.UtcLastOnlineTime = &v
	return s
}

type QueryDynamicGroupDevicesResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryDynamicGroupDevicesResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryDynamicGroupDevicesResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryDynamicGroupDevicesResponse) GoString() string {
	return s.String()
}

func (s *QueryDynamicGroupDevicesResponse) SetHeaders(v map[string]*string) *QueryDynamicGroupDevicesResponse {
	s.Headers = v
	return s
}

func (s *QueryDynamicGroupDevicesResponse) SetStatusCode(v int32) *QueryDynamicGroupDevicesResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryDynamicGroupDevicesResponse) SetBody(v *QueryDynamicGroupDevicesResponseBody) *QueryDynamicGroupDevicesResponse {
	s.Body = v
	return s
}

type QueryEdgeDriverRequest struct {
	// The number of the page to return. Default value: 1. If you specify a value smaller than 1, pages start from page 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The name of the driver whose information is to be queried. If you want to query information about drivers with a specific name, set this parameter.
	DriverName *string `json:"DriverName,omitempty" xml:"DriverName,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for public instances. However, this parameter is required for the instances that you have purchased.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Maximum value: 30. Default value: 10. If you specify a value smaller than 1, a maximum of 10 entries are displayed on each page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The type of the driver whose information is to be queried. Valid values:
	//
	// *   0: official driver
	// *   1: custom driver
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s QueryEdgeDriverRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeDriverRequest) GoString() string {
	return s.String()
}

func (s *QueryEdgeDriverRequest) SetCurrentPage(v int32) *QueryEdgeDriverRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeDriverRequest) SetDriverName(v string) *QueryEdgeDriverRequest {
	s.DriverName = &v
	return s
}

func (s *QueryEdgeDriverRequest) SetIotInstanceId(v string) *QueryEdgeDriverRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryEdgeDriverRequest) SetPageSize(v int32) *QueryEdgeDriverRequest {
	s.PageSize = &v
	return s
}

func (s *QueryEdgeDriverRequest) SetType(v int32) *QueryEdgeDriverRequest {
	s.Type = &v
	return s
}

type QueryEdgeDriverResponseBody struct {
	// The error code. Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call was successful.
	Data *QueryEdgeDriverResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. true indicates that the call was successful. false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryEdgeDriverResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeDriverResponseBody) GoString() string {
	return s.String()
}

func (s *QueryEdgeDriverResponseBody) SetCode(v string) *QueryEdgeDriverResponseBody {
	s.Code = &v
	return s
}

func (s *QueryEdgeDriverResponseBody) SetData(v *QueryEdgeDriverResponseBodyData) *QueryEdgeDriverResponseBody {
	s.Data = v
	return s
}

func (s *QueryEdgeDriverResponseBody) SetErrorMessage(v string) *QueryEdgeDriverResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryEdgeDriverResponseBody) SetRequestId(v string) *QueryEdgeDriverResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryEdgeDriverResponseBody) SetSuccess(v bool) *QueryEdgeDriverResponseBody {
	s.Success = &v
	return s
}

type QueryEdgeDriverResponseBodyData struct {
	// The page number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The information about each driver.
	DriverList []*QueryEdgeDriverResponseBodyDataDriverList `json:"DriverList,omitempty" xml:"DriverList,omitempty" type:"Repeated"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of official or custom drivers found.
	//
	// *   If the value of Type is 0, the value of this parameter is the total number of official drivers found.
	// *   If the value of Type is 1, the value of this parameter is the total number of custom drivers found.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryEdgeDriverResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeDriverResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryEdgeDriverResponseBodyData) SetCurrentPage(v int32) *QueryEdgeDriverResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeDriverResponseBodyData) SetDriverList(v []*QueryEdgeDriverResponseBodyDataDriverList) *QueryEdgeDriverResponseBodyData {
	s.DriverList = v
	return s
}

func (s *QueryEdgeDriverResponseBodyData) SetPageSize(v int32) *QueryEdgeDriverResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryEdgeDriverResponseBodyData) SetTotal(v int32) *QueryEdgeDriverResponseBodyData {
	s.Total = &v
	return s
}

type QueryEdgeDriverResponseBodyDataDriverList struct {
	// The CPU architecture that the driver supports. Valid values:
	//
	// *   ARMv7
	// *   ARMv7-HF
	// *   AArch64
	// *   x86-64
	// *   x86
	CpuArch *string `json:"CpuArch,omitempty" xml:"CpuArch,omitempty"`
	// The ID of the driver.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The name of the driver.
	DriverName *string `json:"DriverName,omitempty" xml:"DriverName,omitempty"`
	// The communications protocol that the driver uses. Valid values:
	//
	// *   modbus: Modbus protocol
	// *   opc-ua: OPC UA protocol
	// *   customize: custom protocol
	DriverProtocol *string `json:"DriverProtocol,omitempty" xml:"DriverProtocol,omitempty"`
	// The time when the driver was created. The time is displayed in UTC.
	GmtCreateTimestamp *int64 `json:"GmtCreateTimestamp,omitempty" xml:"GmtCreateTimestamp,omitempty"`
	// The time when the driver was last modified. The time is displayed in UTC.
	GmtModifiedTimestamp *int64 `json:"GmtModifiedTimestamp,omitempty" xml:"GmtModifiedTimestamp,omitempty"`
	IsApply              *bool  `json:"IsApply,omitempty" xml:"IsApply,omitempty"`
	// Indicates whether the driver is a built-in driver.
	//
	// *   true: indicates that the driver is a built-in driver, that is, the driver code is pre-configured on the gateway device.
	// *   false: indicates that the driver is not a built-in driver.
	IsBuiltIn *bool `json:"IsBuiltIn,omitempty" xml:"IsBuiltIn,omitempty"`
	// The language in which the driver is programmed. Valid values:
	//
	// *   nodejs8: Node.js v8
	// *   python3: Python v3.5
	// *   c: C
	Runtime *string `json:"Runtime,omitempty" xml:"Runtime,omitempty"`
	// The type of the driver. Valid values:
	//
	// *   0: official driver
	// *   1: custom driver
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s QueryEdgeDriverResponseBodyDataDriverList) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeDriverResponseBodyDataDriverList) GoString() string {
	return s.String()
}

func (s *QueryEdgeDriverResponseBodyDataDriverList) SetCpuArch(v string) *QueryEdgeDriverResponseBodyDataDriverList {
	s.CpuArch = &v
	return s
}

func (s *QueryEdgeDriverResponseBodyDataDriverList) SetDriverId(v string) *QueryEdgeDriverResponseBodyDataDriverList {
	s.DriverId = &v
	return s
}

func (s *QueryEdgeDriverResponseBodyDataDriverList) SetDriverName(v string) *QueryEdgeDriverResponseBodyDataDriverList {
	s.DriverName = &v
	return s
}

func (s *QueryEdgeDriverResponseBodyDataDriverList) SetDriverProtocol(v string) *QueryEdgeDriverResponseBodyDataDriverList {
	s.DriverProtocol = &v
	return s
}

func (s *QueryEdgeDriverResponseBodyDataDriverList) SetGmtCreateTimestamp(v int64) *QueryEdgeDriverResponseBodyDataDriverList {
	s.GmtCreateTimestamp = &v
	return s
}

func (s *QueryEdgeDriverResponseBodyDataDriverList) SetGmtModifiedTimestamp(v int64) *QueryEdgeDriverResponseBodyDataDriverList {
	s.GmtModifiedTimestamp = &v
	return s
}

func (s *QueryEdgeDriverResponseBodyDataDriverList) SetIsApply(v bool) *QueryEdgeDriverResponseBodyDataDriverList {
	s.IsApply = &v
	return s
}

func (s *QueryEdgeDriverResponseBodyDataDriverList) SetIsBuiltIn(v bool) *QueryEdgeDriverResponseBodyDataDriverList {
	s.IsBuiltIn = &v
	return s
}

func (s *QueryEdgeDriverResponseBodyDataDriverList) SetRuntime(v string) *QueryEdgeDriverResponseBodyDataDriverList {
	s.Runtime = &v
	return s
}

func (s *QueryEdgeDriverResponseBodyDataDriverList) SetType(v int32) *QueryEdgeDriverResponseBodyDataDriverList {
	s.Type = &v
	return s
}

type QueryEdgeDriverResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryEdgeDriverResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryEdgeDriverResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeDriverResponse) GoString() string {
	return s.String()
}

func (s *QueryEdgeDriverResponse) SetHeaders(v map[string]*string) *QueryEdgeDriverResponse {
	s.Headers = v
	return s
}

func (s *QueryEdgeDriverResponse) SetStatusCode(v int32) *QueryEdgeDriverResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryEdgeDriverResponse) SetBody(v *QueryEdgeDriverResponseBody) *QueryEdgeDriverResponse {
	s.Body = v
	return s
}

type QueryEdgeDriverVersionRequest struct {
	// The number of the page to return. Pages start from Page 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver whose versions you want to query and obtain the driver ID.
	//
	// You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The version number of the driver. To query information about a specific driver version, set this parameter to the specific version number.
	DriverVersion *string `json:"DriverVersion,omitempty" xml:"DriverVersion,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 30. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The status of the driver version. Valid values:
	//
	// *   0: The driver version to be queried is not published.
	// *   1: The driver version to be queried is published.
	VersionState *int32 `json:"VersionState,omitempty" xml:"VersionState,omitempty"`
}

func (s QueryEdgeDriverVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeDriverVersionRequest) GoString() string {
	return s.String()
}

func (s *QueryEdgeDriverVersionRequest) SetCurrentPage(v int32) *QueryEdgeDriverVersionRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeDriverVersionRequest) SetDriverId(v string) *QueryEdgeDriverVersionRequest {
	s.DriverId = &v
	return s
}

func (s *QueryEdgeDriverVersionRequest) SetDriverVersion(v string) *QueryEdgeDriverVersionRequest {
	s.DriverVersion = &v
	return s
}

func (s *QueryEdgeDriverVersionRequest) SetIotInstanceId(v string) *QueryEdgeDriverVersionRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryEdgeDriverVersionRequest) SetPageSize(v int32) *QueryEdgeDriverVersionRequest {
	s.PageSize = &v
	return s
}

func (s *QueryEdgeDriverVersionRequest) SetVersionState(v int32) *QueryEdgeDriverVersionRequest {
	s.VersionState = &v
	return s
}

type QueryEdgeDriverVersionResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned if the call was successful.
	Data *QueryEdgeDriverVersionResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryEdgeDriverVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeDriverVersionResponseBody) GoString() string {
	return s.String()
}

func (s *QueryEdgeDriverVersionResponseBody) SetCode(v string) *QueryEdgeDriverVersionResponseBody {
	s.Code = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBody) SetData(v *QueryEdgeDriverVersionResponseBodyData) *QueryEdgeDriverVersionResponseBody {
	s.Data = v
	return s
}

func (s *QueryEdgeDriverVersionResponseBody) SetErrorMessage(v string) *QueryEdgeDriverVersionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBody) SetRequestId(v string) *QueryEdgeDriverVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBody) SetSuccess(v bool) *QueryEdgeDriverVersionResponseBody {
	s.Success = &v
	return s
}

type QueryEdgeDriverVersionResponseBodyData struct {
	// The page number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The information about each version of the driver.
	DriverVersionList []*QueryEdgeDriverVersionResponseBodyDataDriverVersionList `json:"DriverVersionList,omitempty" xml:"DriverVersionList,omitempty" type:"Repeated"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of driver versions.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryEdgeDriverVersionResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeDriverVersionResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryEdgeDriverVersionResponseBodyData) SetCurrentPage(v int32) *QueryEdgeDriverVersionResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBodyData) SetDriverVersionList(v []*QueryEdgeDriverVersionResponseBodyDataDriverVersionList) *QueryEdgeDriverVersionResponseBodyData {
	s.DriverVersionList = v
	return s
}

func (s *QueryEdgeDriverVersionResponseBodyData) SetPageSize(v int32) *QueryEdgeDriverVersionResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBodyData) SetTotal(v int32) *QueryEdgeDriverVersionResponseBodyData {
	s.Total = &v
	return s
}

type QueryEdgeDriverVersionResponseBodyDataDriverVersionList struct {
	// The Java Virtual Machine (JVM) startup parameter.
	Argument *string `json:"Argument,omitempty" xml:"Argument,omitempty"`
	// The rule for verifying configurations. The value is a JSON string in the following format:
	//
	// `{"deviceConfig":{"required":false},"driverConfig":{"required":false}`
	//
	// The JSON string contains the following parameters:
	//
	// *   driverConfig: the rule for verifying the configuration of the driver when the driver is to be deployed in an edge instance.
	// *   deviceConfig: the rule for verifying the configurations of devices that use the driver when the driver is to be deployed in an edge instance.
	ConfigCheckRule *string `json:"ConfigCheckRule,omitempty" xml:"ConfigCheckRule,omitempty"`
	// The configuration of the container where the driver runs. The value is a JSON string. For more information about parameters in the JSON string, see the following parameter description of ContainerConfig.
	ContainerConfig *string `json:"ContainerConfig,omitempty" xml:"ContainerConfig,omitempty"`
	// The description of the driver.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The configuration of the driver. The value is a JSON string in the following format:
	//
	// `{"format":"JSON","content":"{}"}`
	//
	// The JSON string contains the following parameters:
	//
	// *   format: the format of the driver configuration. Valid values: KV (key-value pair), JSON (JSON string), and FILE (configuration file).
	// *   content: the content of the driver configuration. If the format parameter is set to KV or JSON, the value of this parameter is the configuration content. If the format parameter is set to FILE, the value of this parameter is the URL of the configuration file stored in Object Storage Service (OSS).
	DriverConfig *string `json:"DriverConfig,omitempty" xml:"DriverConfig,omitempty"`
	// The ID of the driver.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The version number of the driver.
	DriverVersion *string `json:"DriverVersion,omitempty" xml:"DriverVersion,omitempty"`
	// The earliest version of Link IoT Edge that is supported by the driver.
	EdgeVersion *string `json:"EdgeVersion,omitempty" xml:"EdgeVersion,omitempty"`
	// The UNIX timestamp when the driver was created.
	GmtCreateTimestamp *int64 `json:"GmtCreateTimestamp,omitempty" xml:"GmtCreateTimestamp,omitempty"`
	// The last UNIX timestamp when the driver was updated.
	GmtModifiedTimestamp *int64  `json:"GmtModifiedTimestamp,omitempty" xml:"GmtModifiedTimestamp,omitempty"`
	SourceConfig         *string `json:"SourceConfig,omitempty" xml:"SourceConfig,omitempty"`
	// The status of the driver version. Valid values:
	//
	// *   0: The driver version was not published.
	// *   1: The driver version was published.
	VersionState *string `json:"VersionState,omitempty" xml:"VersionState,omitempty"`
}

func (s QueryEdgeDriverVersionResponseBodyDataDriverVersionList) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeDriverVersionResponseBodyDataDriverVersionList) GoString() string {
	return s.String()
}

func (s *QueryEdgeDriverVersionResponseBodyDataDriverVersionList) SetArgument(v string) *QueryEdgeDriverVersionResponseBodyDataDriverVersionList {
	s.Argument = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBodyDataDriverVersionList) SetConfigCheckRule(v string) *QueryEdgeDriverVersionResponseBodyDataDriverVersionList {
	s.ConfigCheckRule = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBodyDataDriverVersionList) SetContainerConfig(v string) *QueryEdgeDriverVersionResponseBodyDataDriverVersionList {
	s.ContainerConfig = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBodyDataDriverVersionList) SetDescription(v string) *QueryEdgeDriverVersionResponseBodyDataDriverVersionList {
	s.Description = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBodyDataDriverVersionList) SetDriverConfig(v string) *QueryEdgeDriverVersionResponseBodyDataDriverVersionList {
	s.DriverConfig = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBodyDataDriverVersionList) SetDriverId(v string) *QueryEdgeDriverVersionResponseBodyDataDriverVersionList {
	s.DriverId = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBodyDataDriverVersionList) SetDriverVersion(v string) *QueryEdgeDriverVersionResponseBodyDataDriverVersionList {
	s.DriverVersion = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBodyDataDriverVersionList) SetEdgeVersion(v string) *QueryEdgeDriverVersionResponseBodyDataDriverVersionList {
	s.EdgeVersion = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBodyDataDriverVersionList) SetGmtCreateTimestamp(v int64) *QueryEdgeDriverVersionResponseBodyDataDriverVersionList {
	s.GmtCreateTimestamp = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBodyDataDriverVersionList) SetGmtModifiedTimestamp(v int64) *QueryEdgeDriverVersionResponseBodyDataDriverVersionList {
	s.GmtModifiedTimestamp = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBodyDataDriverVersionList) SetSourceConfig(v string) *QueryEdgeDriverVersionResponseBodyDataDriverVersionList {
	s.SourceConfig = &v
	return s
}

func (s *QueryEdgeDriverVersionResponseBodyDataDriverVersionList) SetVersionState(v string) *QueryEdgeDriverVersionResponseBodyDataDriverVersionList {
	s.VersionState = &v
	return s
}

type QueryEdgeDriverVersionResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryEdgeDriverVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryEdgeDriverVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeDriverVersionResponse) GoString() string {
	return s.String()
}

func (s *QueryEdgeDriverVersionResponse) SetHeaders(v map[string]*string) *QueryEdgeDriverVersionResponse {
	s.Headers = v
	return s
}

func (s *QueryEdgeDriverVersionResponse) SetStatusCode(v int32) *QueryEdgeDriverVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryEdgeDriverVersionResponse) SetBody(v *QueryEdgeDriverVersionResponseBody) *QueryEdgeDriverVersionResponse {
	s.Body = v
	return s
}

type QueryEdgeInstanceRequest struct {
	// The name of the edge instance.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The number of entries to return on each page. Maximum value: 30. Default value: 10. If you specify a value smaller than 1, the system uses 10.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The error code. Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The number of the page from which the results are displayed. The minimum value is 1. If you specify a value smaller than 1, the system uses 1.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QueryEdgeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceRequest) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceRequest) SetCurrentPage(v int32) *QueryEdgeInstanceRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceRequest) SetIotInstanceId(v string) *QueryEdgeInstanceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryEdgeInstanceRequest) SetName(v string) *QueryEdgeInstanceRequest {
	s.Name = &v
	return s
}

func (s *QueryEdgeInstanceRequest) SetPageSize(v int32) *QueryEdgeInstanceRequest {
	s.PageSize = &v
	return s
}

type QueryEdgeInstanceResponseBody struct {
	// The error message returned if the call failed.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The page number of the returned page.
	Data *QueryEdgeInstanceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The ID of the request.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// Indicates whether the call was successful. true: indicates that the call was successful. false: indicates that the call failed.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The data returned if the call was successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryEdgeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceResponseBody) SetCode(v string) *QueryEdgeInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *QueryEdgeInstanceResponseBody) SetData(v *QueryEdgeInstanceResponseBodyData) *QueryEdgeInstanceResponseBody {
	s.Data = v
	return s
}

func (s *QueryEdgeInstanceResponseBody) SetErrorMessage(v string) *QueryEdgeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryEdgeInstanceResponseBody) SetRequestId(v string) *QueryEdgeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryEdgeInstanceResponseBody) SetSuccess(v bool) *QueryEdgeInstanceResponseBody {
	s.Success = &v
	return s
}

type QueryEdgeInstanceResponseBodyData struct {
	// The number of entries returned per page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// Indicates whether you own the edge instance or you are authorized to use the edge instance.
	//
	// *   0: You own the edge instance.
	// *   1: You are authorized to use the edge instance.
	InstanceList []*QueryEdgeInstanceResponseBodyDataInstanceList `json:"InstanceList,omitempty" xml:"InstanceList,omitempty" type:"Repeated"`
	// The number of edge instances.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// A list of edge instances.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryEdgeInstanceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceResponseBodyData) SetCurrentPage(v int32) *QueryEdgeInstanceResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyData) SetInstanceList(v []*QueryEdgeInstanceResponseBodyDataInstanceList) *QueryEdgeInstanceResponseBodyData {
	s.InstanceList = v
	return s
}

func (s *QueryEdgeInstanceResponseBodyData) SetPageSize(v int32) *QueryEdgeInstanceResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyData) SetTotal(v int32) *QueryEdgeInstanceResponseBodyData {
	s.Total = &v
	return s
}

type QueryEdgeInstanceResponseBodyDataInstanceList struct {
	// The time when the edge instance was created.
	BizEnable *bool `json:"BizEnable,omitempty" xml:"BizEnable,omitempty"`
	// The name of the edge instance.
	GmtCreate          *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtCreateTimestamp *int64  `json:"GmtCreateTimestamp,omitempty" xml:"GmtCreateTimestamp,omitempty"`
	// The type of the latest deployment task.
	//
	// *   deploy: deploys the edge instance.
	// *   Reset: resets the edge instance.
	GmtModified          *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	GmtModifiedTimestamp *int64  `json:"GmtModifiedTimestamp,omitempty" xml:"GmtModifiedTimestamp,omitempty"`
	// The name of the RAM role.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// Indicates whether the edge instance was enabled.
	//
	// *   true: enabled
	// *   false: disabled
	LatestDeploymentStatus *int32 `json:"LatestDeploymentStatus,omitempty" xml:"LatestDeploymentStatus,omitempty"`
	// The status of the latest deployment task.
	//
	// *   0: The task has not started.
	// *   1: The task is being processed.
	// *   2: The task was successful.
	// *   3: The task failed.
	LatestDeploymentType *string `json:"LatestDeploymentType,omitempty" xml:"LatestDeploymentType,omitempty"`
	Name                 *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The time when the RAM role was attached to IoT Platform.
	RoleArn *string `json:"RoleArn,omitempty" xml:"RoleArn,omitempty"`
	// The specification of the edge instance.
	//
	// *   10: Lite Edition.
	// *   20: Standard Edition.
	// *   30: Pro Edition.
	RoleAttachTime      *string `json:"RoleAttachTime,omitempty" xml:"RoleAttachTime,omitempty"`
	RoleAttachTimestamp *int64  `json:"RoleAttachTimestamp,omitempty" xml:"RoleAttachTimestamp,omitempty"`
	// The time when the edge instance was last updated.
	RoleName *string `json:"RoleName,omitempty" xml:"RoleName,omitempty"`
	// The tags of the edge instance.
	Spec *int32 `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The ID of the edge instance.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
	// The Alibaba Cloud Resource Name (ARN) of the RAM role.
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s QueryEdgeInstanceResponseBodyDataInstanceList) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceResponseBodyDataInstanceList) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetBizEnable(v bool) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.BizEnable = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetGmtCreate(v string) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.GmtCreate = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetGmtCreateTimestamp(v int64) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.GmtCreateTimestamp = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetGmtModified(v string) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.GmtModified = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetGmtModifiedTimestamp(v int64) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.GmtModifiedTimestamp = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetInstanceId(v string) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.InstanceId = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetLatestDeploymentStatus(v int32) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.LatestDeploymentStatus = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetLatestDeploymentType(v string) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.LatestDeploymentType = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetName(v string) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.Name = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetRoleArn(v string) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.RoleArn = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetRoleAttachTime(v string) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.RoleAttachTime = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetRoleAttachTimestamp(v int64) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.RoleAttachTimestamp = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetRoleName(v string) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.RoleName = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetSpec(v int32) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.Spec = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetTags(v string) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.Tags = &v
	return s
}

func (s *QueryEdgeInstanceResponseBodyDataInstanceList) SetType(v int32) *QueryEdgeInstanceResponseBodyDataInstanceList {
	s.Type = &v
	return s
}

type QueryEdgeInstanceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryEdgeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryEdgeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceResponse) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceResponse) SetHeaders(v map[string]*string) *QueryEdgeInstanceResponse {
	s.Headers = v
	return s
}

func (s *QueryEdgeInstanceResponse) SetStatusCode(v int32) *QueryEdgeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryEdgeInstanceResponse) SetBody(v *QueryEdgeInstanceResponseBody) *QueryEdgeInstanceResponse {
	s.Body = v
	return s
}

type QueryEdgeInstanceChannelRequest struct {
	ChannelName   *string `json:"ChannelName,omitempty" xml:"ChannelName,omitempty"`
	CurrentPage   *int32  `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	DriverId      *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	InstanceId    *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QueryEdgeInstanceChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceChannelRequest) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceChannelRequest) SetChannelName(v string) *QueryEdgeInstanceChannelRequest {
	s.ChannelName = &v
	return s
}

func (s *QueryEdgeInstanceChannelRequest) SetCurrentPage(v int32) *QueryEdgeInstanceChannelRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceChannelRequest) SetDriverId(v string) *QueryEdgeInstanceChannelRequest {
	s.DriverId = &v
	return s
}

func (s *QueryEdgeInstanceChannelRequest) SetInstanceId(v string) *QueryEdgeInstanceChannelRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryEdgeInstanceChannelRequest) SetIotInstanceId(v string) *QueryEdgeInstanceChannelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryEdgeInstanceChannelRequest) SetPageSize(v int32) *QueryEdgeInstanceChannelRequest {
	s.PageSize = &v
	return s
}

type QueryEdgeInstanceChannelResponseBody struct {
	Code         *string                                   `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryEdgeInstanceChannelResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                   `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                     `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryEdgeInstanceChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceChannelResponseBody) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceChannelResponseBody) SetCode(v string) *QueryEdgeInstanceChannelResponseBody {
	s.Code = &v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBody) SetData(v *QueryEdgeInstanceChannelResponseBodyData) *QueryEdgeInstanceChannelResponseBody {
	s.Data = v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBody) SetErrorMessage(v string) *QueryEdgeInstanceChannelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBody) SetRequestId(v string) *QueryEdgeInstanceChannelResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBody) SetSuccess(v bool) *QueryEdgeInstanceChannelResponseBody {
	s.Success = &v
	return s
}

type QueryEdgeInstanceChannelResponseBodyData struct {
	ChannelList *QueryEdgeInstanceChannelResponseBodyDataChannelList `json:"ChannelList,omitempty" xml:"ChannelList,omitempty" type:"Struct"`
	CurrentPage *int32                                               `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	PageSize    *int32                                               `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total       *int32                                               `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryEdgeInstanceChannelResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceChannelResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceChannelResponseBodyData) SetChannelList(v *QueryEdgeInstanceChannelResponseBodyDataChannelList) *QueryEdgeInstanceChannelResponseBodyData {
	s.ChannelList = v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBodyData) SetCurrentPage(v int32) *QueryEdgeInstanceChannelResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBodyData) SetPageSize(v int32) *QueryEdgeInstanceChannelResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBodyData) SetTotal(v int32) *QueryEdgeInstanceChannelResponseBodyData {
	s.Total = &v
	return s
}

type QueryEdgeInstanceChannelResponseBodyDataChannelList struct {
	Channel []*QueryEdgeInstanceChannelResponseBodyDataChannelListChannel `json:"Channel,omitempty" xml:"Channel,omitempty" type:"Repeated"`
}

func (s QueryEdgeInstanceChannelResponseBodyDataChannelList) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceChannelResponseBodyDataChannelList) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceChannelResponseBodyDataChannelList) SetChannel(v []*QueryEdgeInstanceChannelResponseBodyDataChannelListChannel) *QueryEdgeInstanceChannelResponseBodyDataChannelList {
	s.Channel = v
	return s
}

type QueryEdgeInstanceChannelResponseBodyDataChannelListChannel struct {
	ChannelId            *string                                                               `json:"ChannelId,omitempty" xml:"ChannelId,omitempty"`
	ChannelName          *string                                                               `json:"ChannelName,omitempty" xml:"ChannelName,omitempty"`
	ConfigList           *QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList `json:"ConfigList,omitempty" xml:"ConfigList,omitempty" type:"Struct"`
	GmtCreate            *string                                                               `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtCreateTimestamp   *int64                                                                `json:"GmtCreateTimestamp,omitempty" xml:"GmtCreateTimestamp,omitempty"`
	GmtModified          *string                                                               `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	GmtModifiedTimestamp *int64                                                                `json:"GmtModifiedTimestamp,omitempty" xml:"GmtModifiedTimestamp,omitempty"`
}

func (s QueryEdgeInstanceChannelResponseBodyDataChannelListChannel) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceChannelResponseBodyDataChannelListChannel) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceChannelResponseBodyDataChannelListChannel) SetChannelId(v string) *QueryEdgeInstanceChannelResponseBodyDataChannelListChannel {
	s.ChannelId = &v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBodyDataChannelListChannel) SetChannelName(v string) *QueryEdgeInstanceChannelResponseBodyDataChannelListChannel {
	s.ChannelName = &v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBodyDataChannelListChannel) SetConfigList(v *QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList) *QueryEdgeInstanceChannelResponseBodyDataChannelListChannel {
	s.ConfigList = v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBodyDataChannelListChannel) SetGmtCreate(v string) *QueryEdgeInstanceChannelResponseBodyDataChannelListChannel {
	s.GmtCreate = &v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBodyDataChannelListChannel) SetGmtCreateTimestamp(v int64) *QueryEdgeInstanceChannelResponseBodyDataChannelListChannel {
	s.GmtCreateTimestamp = &v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBodyDataChannelListChannel) SetGmtModified(v string) *QueryEdgeInstanceChannelResponseBodyDataChannelListChannel {
	s.GmtModified = &v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBodyDataChannelListChannel) SetGmtModifiedTimestamp(v int64) *QueryEdgeInstanceChannelResponseBodyDataChannelListChannel {
	s.GmtModifiedTimestamp = &v
	return s
}

type QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList struct {
	Config []*QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig `json:"Config,omitempty" xml:"Config,omitempty" type:"Repeated"`
}

func (s QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList) SetConfig(v []*QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig) *QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigList {
	s.Config = v
	return s
}

type QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig struct {
	ConfigId *string `json:"ConfigId,omitempty" xml:"ConfigId,omitempty"`
	Content  *string `json:"Content,omitempty" xml:"Content,omitempty"`
	Format   *string `json:"Format,omitempty" xml:"Format,omitempty"`
	Key      *string `json:"Key,omitempty" xml:"Key,omitempty"`
}

func (s QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig) SetConfigId(v string) *QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig {
	s.ConfigId = &v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig) SetContent(v string) *QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig {
	s.Content = &v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig) SetFormat(v string) *QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig {
	s.Format = &v
	return s
}

func (s *QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig) SetKey(v string) *QueryEdgeInstanceChannelResponseBodyDataChannelListChannelConfigListConfig {
	s.Key = &v
	return s
}

type QueryEdgeInstanceChannelResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryEdgeInstanceChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryEdgeInstanceChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceChannelResponse) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceChannelResponse) SetHeaders(v map[string]*string) *QueryEdgeInstanceChannelResponse {
	s.Headers = v
	return s
}

func (s *QueryEdgeInstanceChannelResponse) SetStatusCode(v int32) *QueryEdgeInstanceChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryEdgeInstanceChannelResponse) SetBody(v *QueryEdgeInstanceChannelResponseBody) *QueryEdgeInstanceChannelResponse {
	s.Body = v
	return s
}

type QueryEdgeInstanceDeviceRequest struct {
	// The number of the page to return. Pages start from Page 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to query and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 30. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QueryEdgeInstanceDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceDeviceRequest) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceDeviceRequest) SetCurrentPage(v int32) *QueryEdgeInstanceDeviceRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceDeviceRequest) SetInstanceId(v string) *QueryEdgeInstanceDeviceRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryEdgeInstanceDeviceRequest) SetIotInstanceId(v string) *QueryEdgeInstanceDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryEdgeInstanceDeviceRequest) SetPageSize(v int32) *QueryEdgeInstanceDeviceRequest {
	s.PageSize = &v
	return s
}

type QueryEdgeInstanceDeviceResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned if the call was successful.
	Data *QueryEdgeInstanceDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryEdgeInstanceDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceDeviceResponseBody) SetCode(v string) *QueryEdgeInstanceDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *QueryEdgeInstanceDeviceResponseBody) SetData(v *QueryEdgeInstanceDeviceResponseBodyData) *QueryEdgeInstanceDeviceResponseBody {
	s.Data = v
	return s
}

func (s *QueryEdgeInstanceDeviceResponseBody) SetErrorMessage(v string) *QueryEdgeInstanceDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryEdgeInstanceDeviceResponseBody) SetRequestId(v string) *QueryEdgeInstanceDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryEdgeInstanceDeviceResponseBody) SetSuccess(v bool) *QueryEdgeInstanceDeviceResponseBody {
	s.Success = &v
	return s
}

type QueryEdgeInstanceDeviceResponseBodyData struct {
	// The page number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The list of device information.
	DeviceList []*QueryEdgeInstanceDeviceResponseBodyDataDeviceList `json:"DeviceList,omitempty" xml:"DeviceList,omitempty" type:"Repeated"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of devices.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryEdgeInstanceDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceDeviceResponseBodyData) SetCurrentPage(v int32) *QueryEdgeInstanceDeviceResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceDeviceResponseBodyData) SetDeviceList(v []*QueryEdgeInstanceDeviceResponseBodyDataDeviceList) *QueryEdgeInstanceDeviceResponseBodyData {
	s.DeviceList = v
	return s
}

func (s *QueryEdgeInstanceDeviceResponseBodyData) SetPageSize(v int32) *QueryEdgeInstanceDeviceResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryEdgeInstanceDeviceResponseBodyData) SetTotal(v int32) *QueryEdgeInstanceDeviceResponseBodyData {
	s.Total = &v
	return s
}

type QueryEdgeInstanceDeviceResponseBodyDataDeviceList struct {
	// The name of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the driver.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The ID of the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The key that uniquely identifies the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryEdgeInstanceDeviceResponseBodyDataDeviceList) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceDeviceResponseBodyDataDeviceList) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceDeviceResponseBodyDataDeviceList) SetDeviceName(v string) *QueryEdgeInstanceDeviceResponseBodyDataDeviceList {
	s.DeviceName = &v
	return s
}

func (s *QueryEdgeInstanceDeviceResponseBodyDataDeviceList) SetDriverId(v string) *QueryEdgeInstanceDeviceResponseBodyDataDeviceList {
	s.DriverId = &v
	return s
}

func (s *QueryEdgeInstanceDeviceResponseBodyDataDeviceList) SetIotId(v string) *QueryEdgeInstanceDeviceResponseBodyDataDeviceList {
	s.IotId = &v
	return s
}

func (s *QueryEdgeInstanceDeviceResponseBodyDataDeviceList) SetProductKey(v string) *QueryEdgeInstanceDeviceResponseBodyDataDeviceList {
	s.ProductKey = &v
	return s
}

type QueryEdgeInstanceDeviceResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryEdgeInstanceDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryEdgeInstanceDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceDeviceResponse) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceDeviceResponse) SetHeaders(v map[string]*string) *QueryEdgeInstanceDeviceResponse {
	s.Headers = v
	return s
}

func (s *QueryEdgeInstanceDeviceResponse) SetStatusCode(v int32) *QueryEdgeInstanceDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryEdgeInstanceDeviceResponse) SetBody(v *QueryEdgeInstanceDeviceResponseBody) *QueryEdgeInstanceDeviceResponse {
	s.Body = v
	return s
}

type QueryEdgeInstanceDeviceByDriverRequest struct {
	ChannelId     *string `json:"ChannelId,omitempty" xml:"ChannelId,omitempty"`
	CurrentPage   *int32  `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	DriverId      *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	InstanceId    *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QueryEdgeInstanceDeviceByDriverRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceDeviceByDriverRequest) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceDeviceByDriverRequest) SetChannelId(v string) *QueryEdgeInstanceDeviceByDriverRequest {
	s.ChannelId = &v
	return s
}

func (s *QueryEdgeInstanceDeviceByDriverRequest) SetCurrentPage(v int32) *QueryEdgeInstanceDeviceByDriverRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceDeviceByDriverRequest) SetDriverId(v string) *QueryEdgeInstanceDeviceByDriverRequest {
	s.DriverId = &v
	return s
}

func (s *QueryEdgeInstanceDeviceByDriverRequest) SetInstanceId(v string) *QueryEdgeInstanceDeviceByDriverRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryEdgeInstanceDeviceByDriverRequest) SetIotInstanceId(v string) *QueryEdgeInstanceDeviceByDriverRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryEdgeInstanceDeviceByDriverRequest) SetPageSize(v int32) *QueryEdgeInstanceDeviceByDriverRequest {
	s.PageSize = &v
	return s
}

type QueryEdgeInstanceDeviceByDriverResponseBody struct {
	Code         *string                                          `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryEdgeInstanceDeviceByDriverResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                          `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                          `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                            `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryEdgeInstanceDeviceByDriverResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceDeviceByDriverResponseBody) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceDeviceByDriverResponseBody) SetCode(v string) *QueryEdgeInstanceDeviceByDriverResponseBody {
	s.Code = &v
	return s
}

func (s *QueryEdgeInstanceDeviceByDriverResponseBody) SetData(v *QueryEdgeInstanceDeviceByDriverResponseBodyData) *QueryEdgeInstanceDeviceByDriverResponseBody {
	s.Data = v
	return s
}

func (s *QueryEdgeInstanceDeviceByDriverResponseBody) SetErrorMessage(v string) *QueryEdgeInstanceDeviceByDriverResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryEdgeInstanceDeviceByDriverResponseBody) SetRequestId(v string) *QueryEdgeInstanceDeviceByDriverResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryEdgeInstanceDeviceByDriverResponseBody) SetSuccess(v bool) *QueryEdgeInstanceDeviceByDriverResponseBody {
	s.Success = &v
	return s
}

type QueryEdgeInstanceDeviceByDriverResponseBodyData struct {
	CurrentPage *int32                                                       `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	DeviceList  []*QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList `json:"DeviceList,omitempty" xml:"DeviceList,omitempty" type:"Repeated"`
	PageSize    *int32                                                       `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total       *int32                                                       `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryEdgeInstanceDeviceByDriverResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceDeviceByDriverResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceDeviceByDriverResponseBodyData) SetCurrentPage(v int32) *QueryEdgeInstanceDeviceByDriverResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceDeviceByDriverResponseBodyData) SetDeviceList(v []*QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList) *QueryEdgeInstanceDeviceByDriverResponseBodyData {
	s.DeviceList = v
	return s
}

func (s *QueryEdgeInstanceDeviceByDriverResponseBodyData) SetPageSize(v int32) *QueryEdgeInstanceDeviceByDriverResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryEdgeInstanceDeviceByDriverResponseBodyData) SetTotal(v int32) *QueryEdgeInstanceDeviceByDriverResponseBodyData {
	s.Total = &v
	return s
}

type QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList struct {
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
}

func (s QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList) SetIotId(v string) *QueryEdgeInstanceDeviceByDriverResponseBodyDataDeviceList {
	s.IotId = &v
	return s
}

type QueryEdgeInstanceDeviceByDriverResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryEdgeInstanceDeviceByDriverResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryEdgeInstanceDeviceByDriverResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceDeviceByDriverResponse) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceDeviceByDriverResponse) SetHeaders(v map[string]*string) *QueryEdgeInstanceDeviceByDriverResponse {
	s.Headers = v
	return s
}

func (s *QueryEdgeInstanceDeviceByDriverResponse) SetStatusCode(v int32) *QueryEdgeInstanceDeviceByDriverResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryEdgeInstanceDeviceByDriverResponse) SetBody(v *QueryEdgeInstanceDeviceByDriverResponseBody) *QueryEdgeInstanceDeviceByDriverResponse {
	s.Body = v
	return s
}

type QueryEdgeInstanceDriverRequest struct {
	// The number of the page to return. Pages start from Page 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to query and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 30. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QueryEdgeInstanceDriverRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceDriverRequest) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceDriverRequest) SetCurrentPage(v int32) *QueryEdgeInstanceDriverRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceDriverRequest) SetInstanceId(v string) *QueryEdgeInstanceDriverRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryEdgeInstanceDriverRequest) SetIotInstanceId(v string) *QueryEdgeInstanceDriverRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryEdgeInstanceDriverRequest) SetPageSize(v int32) *QueryEdgeInstanceDriverRequest {
	s.PageSize = &v
	return s
}

type QueryEdgeInstanceDriverResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned if the call was successful.
	Data *QueryEdgeInstanceDriverResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryEdgeInstanceDriverResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceDriverResponseBody) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceDriverResponseBody) SetCode(v string) *QueryEdgeInstanceDriverResponseBody {
	s.Code = &v
	return s
}

func (s *QueryEdgeInstanceDriverResponseBody) SetData(v *QueryEdgeInstanceDriverResponseBodyData) *QueryEdgeInstanceDriverResponseBody {
	s.Data = v
	return s
}

func (s *QueryEdgeInstanceDriverResponseBody) SetErrorMessage(v string) *QueryEdgeInstanceDriverResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryEdgeInstanceDriverResponseBody) SetRequestId(v string) *QueryEdgeInstanceDriverResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryEdgeInstanceDriverResponseBody) SetSuccess(v bool) *QueryEdgeInstanceDriverResponseBody {
	s.Success = &v
	return s
}

type QueryEdgeInstanceDriverResponseBodyData struct {
	// The page number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The list of drivers.
	DriverList []*QueryEdgeInstanceDriverResponseBodyDataDriverList `json:"DriverList,omitempty" xml:"DriverList,omitempty" type:"Repeated"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The number of drivers.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryEdgeInstanceDriverResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceDriverResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceDriverResponseBodyData) SetCurrentPage(v int32) *QueryEdgeInstanceDriverResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceDriverResponseBodyData) SetDriverList(v []*QueryEdgeInstanceDriverResponseBodyDataDriverList) *QueryEdgeInstanceDriverResponseBodyData {
	s.DriverList = v
	return s
}

func (s *QueryEdgeInstanceDriverResponseBodyData) SetPageSize(v int32) *QueryEdgeInstanceDriverResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryEdgeInstanceDriverResponseBodyData) SetTotal(v int32) *QueryEdgeInstanceDriverResponseBodyData {
	s.Total = &v
	return s
}

type QueryEdgeInstanceDriverResponseBodyDataDriverList struct {
	// The ID of the driver.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The version number of the driver.
	DriverVersion *string `json:"DriverVersion,omitempty" xml:"DriverVersion,omitempty"`
	// The time when the driver was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The last time when the driver was updated.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The ID of the order.
	OrderId *string `json:"OrderId,omitempty" xml:"OrderId,omitempty"`
}

func (s QueryEdgeInstanceDriverResponseBodyDataDriverList) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceDriverResponseBodyDataDriverList) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceDriverResponseBodyDataDriverList) SetDriverId(v string) *QueryEdgeInstanceDriverResponseBodyDataDriverList {
	s.DriverId = &v
	return s
}

func (s *QueryEdgeInstanceDriverResponseBodyDataDriverList) SetDriverVersion(v string) *QueryEdgeInstanceDriverResponseBodyDataDriverList {
	s.DriverVersion = &v
	return s
}

func (s *QueryEdgeInstanceDriverResponseBodyDataDriverList) SetGmtCreate(v string) *QueryEdgeInstanceDriverResponseBodyDataDriverList {
	s.GmtCreate = &v
	return s
}

func (s *QueryEdgeInstanceDriverResponseBodyDataDriverList) SetGmtModified(v string) *QueryEdgeInstanceDriverResponseBodyDataDriverList {
	s.GmtModified = &v
	return s
}

func (s *QueryEdgeInstanceDriverResponseBodyDataDriverList) SetOrderId(v string) *QueryEdgeInstanceDriverResponseBodyDataDriverList {
	s.OrderId = &v
	return s
}

type QueryEdgeInstanceDriverResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryEdgeInstanceDriverResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryEdgeInstanceDriverResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceDriverResponse) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceDriverResponse) SetHeaders(v map[string]*string) *QueryEdgeInstanceDriverResponse {
	s.Headers = v
	return s
}

func (s *QueryEdgeInstanceDriverResponse) SetStatusCode(v int32) *QueryEdgeInstanceDriverResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryEdgeInstanceDriverResponse) SetBody(v *QueryEdgeInstanceDriverResponseBody) *QueryEdgeInstanceDriverResponse {
	s.Body = v
	return s
}

type QueryEdgeInstanceGatewayRequest struct {
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to query and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s QueryEdgeInstanceGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceGatewayRequest) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceGatewayRequest) SetInstanceId(v string) *QueryEdgeInstanceGatewayRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryEdgeInstanceGatewayRequest) SetIotInstanceId(v string) *QueryEdgeInstanceGatewayRequest {
	s.IotInstanceId = &v
	return s
}

type QueryEdgeInstanceGatewayResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The data that is returned if the call was successful.
	GatewayList []*QueryEdgeInstanceGatewayResponseBodyGatewayList `json:"GatewayList,omitempty" xml:"GatewayList,omitempty" type:"Repeated"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryEdgeInstanceGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceGatewayResponseBody) SetCode(v string) *QueryEdgeInstanceGatewayResponseBody {
	s.Code = &v
	return s
}

func (s *QueryEdgeInstanceGatewayResponseBody) SetErrorMessage(v string) *QueryEdgeInstanceGatewayResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryEdgeInstanceGatewayResponseBody) SetGatewayList(v []*QueryEdgeInstanceGatewayResponseBodyGatewayList) *QueryEdgeInstanceGatewayResponseBody {
	s.GatewayList = v
	return s
}

func (s *QueryEdgeInstanceGatewayResponseBody) SetRequestId(v string) *QueryEdgeInstanceGatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryEdgeInstanceGatewayResponseBody) SetSuccess(v bool) *QueryEdgeInstanceGatewayResponseBody {
	s.Success = &v
	return s
}

type QueryEdgeInstanceGatewayResponseBodyGatewayList struct {
	// The name of the gateway.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The version number of Link IoT Edge.
	EdgeVersion *string `json:"EdgeVersion,omitempty" xml:"EdgeVersion,omitempty"`
	// The ID of the gateway in IoT Platform.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The key that uniquely identifies the product to which the gateway belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryEdgeInstanceGatewayResponseBodyGatewayList) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceGatewayResponseBodyGatewayList) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceGatewayResponseBodyGatewayList) SetDeviceName(v string) *QueryEdgeInstanceGatewayResponseBodyGatewayList {
	s.DeviceName = &v
	return s
}

func (s *QueryEdgeInstanceGatewayResponseBodyGatewayList) SetEdgeVersion(v string) *QueryEdgeInstanceGatewayResponseBodyGatewayList {
	s.EdgeVersion = &v
	return s
}

func (s *QueryEdgeInstanceGatewayResponseBodyGatewayList) SetIotId(v string) *QueryEdgeInstanceGatewayResponseBodyGatewayList {
	s.IotId = &v
	return s
}

func (s *QueryEdgeInstanceGatewayResponseBodyGatewayList) SetProductKey(v string) *QueryEdgeInstanceGatewayResponseBodyGatewayList {
	s.ProductKey = &v
	return s
}

type QueryEdgeInstanceGatewayResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryEdgeInstanceGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryEdgeInstanceGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceGatewayResponse) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceGatewayResponse) SetHeaders(v map[string]*string) *QueryEdgeInstanceGatewayResponse {
	s.Headers = v
	return s
}

func (s *QueryEdgeInstanceGatewayResponse) SetStatusCode(v int32) *QueryEdgeInstanceGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryEdgeInstanceGatewayResponse) SetBody(v *QueryEdgeInstanceGatewayResponseBody) *QueryEdgeInstanceGatewayResponse {
	s.Body = v
	return s
}

type QueryEdgeInstanceHistoricDeploymentRequest struct {
	// The number of the page to return. Pages start from Page 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The end of the time range to query. If you do not specify the start time and end time, all the deployment task records of the edge instance are queried.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to manage and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 30. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The beginning of the time range to query. If you do not specify the start time and end time, all the deployment task records of the edge instance are queried.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s QueryEdgeInstanceHistoricDeploymentRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceHistoricDeploymentRequest) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceHistoricDeploymentRequest) SetCurrentPage(v int32) *QueryEdgeInstanceHistoricDeploymentRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentRequest) SetEndTime(v int64) *QueryEdgeInstanceHistoricDeploymentRequest {
	s.EndTime = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentRequest) SetInstanceId(v string) *QueryEdgeInstanceHistoricDeploymentRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentRequest) SetIotInstanceId(v string) *QueryEdgeInstanceHistoricDeploymentRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentRequest) SetPageSize(v int32) *QueryEdgeInstanceHistoricDeploymentRequest {
	s.PageSize = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentRequest) SetStartTime(v int64) *QueryEdgeInstanceHistoricDeploymentRequest {
	s.StartTime = &v
	return s
}

type QueryEdgeInstanceHistoricDeploymentResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data that is returned if the call was successful.
	Data *QueryEdgeInstanceHistoricDeploymentResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryEdgeInstanceHistoricDeploymentResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceHistoricDeploymentResponseBody) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBody) SetCode(v string) *QueryEdgeInstanceHistoricDeploymentResponseBody {
	s.Code = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBody) SetData(v *QueryEdgeInstanceHistoricDeploymentResponseBodyData) *QueryEdgeInstanceHistoricDeploymentResponseBody {
	s.Data = v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBody) SetErrorMessage(v string) *QueryEdgeInstanceHistoricDeploymentResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBody) SetRequestId(v string) *QueryEdgeInstanceHistoricDeploymentResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBody) SetSuccess(v bool) *QueryEdgeInstanceHistoricDeploymentResponseBody {
	s.Success = &v
	return s
}

type QueryEdgeInstanceHistoricDeploymentResponseBodyData struct {
	// The page number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The list of deployment tasks.
	DeploymentList []*QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList `json:"DeploymentList,omitempty" xml:"DeploymentList,omitempty" type:"Repeated"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of deployment tasks.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryEdgeInstanceHistoricDeploymentResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceHistoricDeploymentResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBodyData) SetCurrentPage(v int32) *QueryEdgeInstanceHistoricDeploymentResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBodyData) SetDeploymentList(v []*QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList) *QueryEdgeInstanceHistoricDeploymentResponseBodyData {
	s.DeploymentList = v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBodyData) SetPageSize(v int32) *QueryEdgeInstanceHistoricDeploymentResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBodyData) SetTotal(v int32) *QueryEdgeInstanceHistoricDeploymentResponseBodyData {
	s.Total = &v
	return s
}

type QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList struct {
	// The ID of the deployment task.
	DeploymentId *string `json:"DeploymentId,omitempty" xml:"DeploymentId,omitempty"`
	// The description of the deployment task.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The time when the deployment task was complete.
	GmtCompleted *string `json:"GmtCompleted,omitempty" xml:"GmtCompleted,omitempty"`
	// The UNIX timestamp when the deployment task was complete.
	GmtCompletedTimestamp *int64 `json:"GmtCompletedTimestamp,omitempty" xml:"GmtCompletedTimestamp,omitempty"`
	// The time when the deployment task was created.
	GmtCreate *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The UNIX timestamp when the deployment task was created.
	GmtCreateTimestamp *int64 `json:"GmtCreateTimestamp,omitempty" xml:"GmtCreateTimestamp,omitempty"`
	// The last time when the deployment task was modified.
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	// The last UNIX timestamp when the deployment task was modified.
	GmtModifiedTimestamp *int64 `json:"GmtModifiedTimestamp,omitempty" xml:"GmtModifiedTimestamp,omitempty"`
	// The status of the deployment task.
	//
	// *   0: The task was not started.
	// *   1: The task was being processed.
	// *   2: The task was successful.
	// *   3: The task failed.
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the deployment task.
	//
	// *   deploy: deploys the edge instance.
	// *   reset: resets the edge instance.
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList) SetDeploymentId(v string) *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList {
	s.DeploymentId = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList) SetDescription(v string) *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList {
	s.Description = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList) SetGmtCompleted(v string) *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList {
	s.GmtCompleted = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList) SetGmtCompletedTimestamp(v int64) *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList {
	s.GmtCompletedTimestamp = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList) SetGmtCreate(v string) *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList {
	s.GmtCreate = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList) SetGmtCreateTimestamp(v int64) *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList {
	s.GmtCreateTimestamp = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList) SetGmtModified(v string) *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList {
	s.GmtModified = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList) SetGmtModifiedTimestamp(v int64) *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList {
	s.GmtModifiedTimestamp = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList) SetStatus(v int32) *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList {
	s.Status = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList) SetType(v string) *QueryEdgeInstanceHistoricDeploymentResponseBodyDataDeploymentList {
	s.Type = &v
	return s
}

type QueryEdgeInstanceHistoricDeploymentResponse struct {
	Headers    map[string]*string                               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryEdgeInstanceHistoricDeploymentResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryEdgeInstanceHistoricDeploymentResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceHistoricDeploymentResponse) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceHistoricDeploymentResponse) SetHeaders(v map[string]*string) *QueryEdgeInstanceHistoricDeploymentResponse {
	s.Headers = v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponse) SetStatusCode(v int32) *QueryEdgeInstanceHistoricDeploymentResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryEdgeInstanceHistoricDeploymentResponse) SetBody(v *QueryEdgeInstanceHistoricDeploymentResponseBody) *QueryEdgeInstanceHistoricDeploymentResponse {
	s.Body = v
	return s
}

type QueryEdgeInstanceMessageRoutingRequest struct {
	CurrentPage   *int32  `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	InstanceId    *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QueryEdgeInstanceMessageRoutingRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceMessageRoutingRequest) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceMessageRoutingRequest) SetCurrentPage(v int32) *QueryEdgeInstanceMessageRoutingRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingRequest) SetInstanceId(v string) *QueryEdgeInstanceMessageRoutingRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingRequest) SetIotInstanceId(v string) *QueryEdgeInstanceMessageRoutingRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingRequest) SetPageSize(v int32) *QueryEdgeInstanceMessageRoutingRequest {
	s.PageSize = &v
	return s
}

type QueryEdgeInstanceMessageRoutingResponseBody struct {
	Code         *string                                          `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryEdgeInstanceMessageRoutingResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                          `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                          `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                            `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryEdgeInstanceMessageRoutingResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceMessageRoutingResponseBody) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceMessageRoutingResponseBody) SetCode(v string) *QueryEdgeInstanceMessageRoutingResponseBody {
	s.Code = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBody) SetData(v *QueryEdgeInstanceMessageRoutingResponseBodyData) *QueryEdgeInstanceMessageRoutingResponseBody {
	s.Data = v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBody) SetErrorMessage(v string) *QueryEdgeInstanceMessageRoutingResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBody) SetRequestId(v string) *QueryEdgeInstanceMessageRoutingResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBody) SetSuccess(v bool) *QueryEdgeInstanceMessageRoutingResponseBody {
	s.Success = &v
	return s
}

type QueryEdgeInstanceMessageRoutingResponseBodyData struct {
	CurrentPage      *int32                                                           `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	MessageRouteList *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList `json:"MessageRouteList,omitempty" xml:"MessageRouteList,omitempty" type:"Struct"`
	PageSize         *int32                                                           `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total            *int32                                                           `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryEdgeInstanceMessageRoutingResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceMessageRoutingResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyData) SetCurrentPage(v int32) *QueryEdgeInstanceMessageRoutingResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyData) SetMessageRouteList(v *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList) *QueryEdgeInstanceMessageRoutingResponseBodyData {
	s.MessageRouteList = v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyData) SetPageSize(v int32) *QueryEdgeInstanceMessageRoutingResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyData) SetTotal(v int32) *QueryEdgeInstanceMessageRoutingResponseBodyData {
	s.Total = &v
	return s
}

type QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList struct {
	MessageRoute []*QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute `json:"MessageRoute,omitempty" xml:"MessageRoute,omitempty" type:"Repeated"`
}

func (s QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList) SetMessageRoute(v []*QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteList {
	s.MessageRoute = v
	return s
}

type QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute struct {
	GmtCreate            *string                                                                                  `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtCreateTimestamp   *int64                                                                                   `json:"GmtCreateTimestamp,omitempty" xml:"GmtCreateTimestamp,omitempty"`
	GmtModified          *string                                                                                  `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	GmtModifiedTimestamp *int64                                                                                   `json:"GmtModifiedTimestamp,omitempty" xml:"GmtModifiedTimestamp,omitempty"`
	Name                 *string                                                                                  `json:"Name,omitempty" xml:"Name,omitempty"`
	RouteContext         *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext `json:"RouteContext,omitempty" xml:"RouteContext,omitempty" type:"Struct"`
	RouteId              *int32                                                                                   `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
	SourceData           *string                                                                                  `json:"SourceData,omitempty" xml:"SourceData,omitempty"`
	SourceType           *string                                                                                  `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	TargetData           *string                                                                                  `json:"TargetData,omitempty" xml:"TargetData,omitempty"`
	TargetType           *string                                                                                  `json:"TargetType,omitempty" xml:"TargetType,omitempty"`
	TopicFilter          *string                                                                                  `json:"TopicFilter,omitempty" xml:"TopicFilter,omitempty"`
}

func (s QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute) SetGmtCreate(v string) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute {
	s.GmtCreate = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute) SetGmtCreateTimestamp(v int64) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute {
	s.GmtCreateTimestamp = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute) SetGmtModified(v string) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute {
	s.GmtModified = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute) SetGmtModifiedTimestamp(v int64) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute {
	s.GmtModifiedTimestamp = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute) SetName(v string) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute {
	s.Name = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute) SetRouteContext(v *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute {
	s.RouteContext = v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute) SetRouteId(v int32) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute {
	s.RouteId = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute) SetSourceData(v string) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute {
	s.SourceData = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute) SetSourceType(v string) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute {
	s.SourceType = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute) SetTargetData(v string) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute {
	s.TargetData = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute) SetTargetType(v string) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute {
	s.TargetType = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute) SetTopicFilter(v string) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRoute {
	s.TopicFilter = &v
	return s
}

type QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext struct {
	Qos                   *string `json:"Qos,omitempty" xml:"Qos,omitempty"`
	SourceApplicationName *string `json:"SourceApplicationName,omitempty" xml:"SourceApplicationName,omitempty"`
	SourceFcFunctionName  *string `json:"SourceFcFunctionName,omitempty" xml:"SourceFcFunctionName,omitempty"`
	SourceFcServiceName   *string `json:"SourceFcServiceName,omitempty" xml:"SourceFcServiceName,omitempty"`
	TargetApplicationName *string `json:"TargetApplicationName,omitempty" xml:"TargetApplicationName,omitempty"`
	TargetFcFunctionName  *string `json:"TargetFcFunctionName,omitempty" xml:"TargetFcFunctionName,omitempty"`
	TargetFcServiceName   *string `json:"TargetFcServiceName,omitempty" xml:"TargetFcServiceName,omitempty"`
}

func (s QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext) SetQos(v string) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext {
	s.Qos = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext) SetSourceApplicationName(v string) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext {
	s.SourceApplicationName = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext) SetSourceFcFunctionName(v string) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext {
	s.SourceFcFunctionName = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext) SetSourceFcServiceName(v string) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext {
	s.SourceFcServiceName = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext) SetTargetApplicationName(v string) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext {
	s.TargetApplicationName = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext) SetTargetFcFunctionName(v string) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext {
	s.TargetFcFunctionName = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext) SetTargetFcServiceName(v string) *QueryEdgeInstanceMessageRoutingResponseBodyDataMessageRouteListMessageRouteRouteContext {
	s.TargetFcServiceName = &v
	return s
}

type QueryEdgeInstanceMessageRoutingResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryEdgeInstanceMessageRoutingResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryEdgeInstanceMessageRoutingResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceMessageRoutingResponse) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceMessageRoutingResponse) SetHeaders(v map[string]*string) *QueryEdgeInstanceMessageRoutingResponse {
	s.Headers = v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponse) SetStatusCode(v int32) *QueryEdgeInstanceMessageRoutingResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryEdgeInstanceMessageRoutingResponse) SetBody(v *QueryEdgeInstanceMessageRoutingResponseBody) *QueryEdgeInstanceMessageRoutingResponse {
	s.Body = v
	return s
}

type QueryEdgeInstanceSceneRuleRequest struct {
	CurrentPage   *int32  `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	InstanceId    *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QueryEdgeInstanceSceneRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceSceneRuleRequest) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceSceneRuleRequest) SetCurrentPage(v int32) *QueryEdgeInstanceSceneRuleRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceSceneRuleRequest) SetInstanceId(v string) *QueryEdgeInstanceSceneRuleRequest {
	s.InstanceId = &v
	return s
}

func (s *QueryEdgeInstanceSceneRuleRequest) SetIotInstanceId(v string) *QueryEdgeInstanceSceneRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryEdgeInstanceSceneRuleRequest) SetPageSize(v int32) *QueryEdgeInstanceSceneRuleRequest {
	s.PageSize = &v
	return s
}

type QueryEdgeInstanceSceneRuleResponseBody struct {
	Code         *string                                     `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryEdgeInstanceSceneRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryEdgeInstanceSceneRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceSceneRuleResponseBody) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceSceneRuleResponseBody) SetCode(v string) *QueryEdgeInstanceSceneRuleResponseBody {
	s.Code = &v
	return s
}

func (s *QueryEdgeInstanceSceneRuleResponseBody) SetData(v *QueryEdgeInstanceSceneRuleResponseBodyData) *QueryEdgeInstanceSceneRuleResponseBody {
	s.Data = v
	return s
}

func (s *QueryEdgeInstanceSceneRuleResponseBody) SetErrorMessage(v string) *QueryEdgeInstanceSceneRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryEdgeInstanceSceneRuleResponseBody) SetRequestId(v string) *QueryEdgeInstanceSceneRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryEdgeInstanceSceneRuleResponseBody) SetSuccess(v bool) *QueryEdgeInstanceSceneRuleResponseBody {
	s.Success = &v
	return s
}

type QueryEdgeInstanceSceneRuleResponseBodyData struct {
	CurrentPage *int32                                                `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	PageSize    *int32                                                `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RuleList    []*QueryEdgeInstanceSceneRuleResponseBodyDataRuleList `json:"RuleList,omitempty" xml:"RuleList,omitempty" type:"Repeated"`
	Total       *int32                                                `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryEdgeInstanceSceneRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceSceneRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceSceneRuleResponseBodyData) SetCurrentPage(v int32) *QueryEdgeInstanceSceneRuleResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *QueryEdgeInstanceSceneRuleResponseBodyData) SetPageSize(v int32) *QueryEdgeInstanceSceneRuleResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryEdgeInstanceSceneRuleResponseBodyData) SetRuleList(v []*QueryEdgeInstanceSceneRuleResponseBodyDataRuleList) *QueryEdgeInstanceSceneRuleResponseBodyData {
	s.RuleList = v
	return s
}

func (s *QueryEdgeInstanceSceneRuleResponseBodyData) SetTotal(v int32) *QueryEdgeInstanceSceneRuleResponseBodyData {
	s.Total = &v
	return s
}

type QueryEdgeInstanceSceneRuleResponseBodyDataRuleList struct {
	GmtCreate *int64  `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	IsExisted *int32  `json:"IsExisted,omitempty" xml:"IsExisted,omitempty"`
	RuleId    *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	RuleName  *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	Status    *int32  `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s QueryEdgeInstanceSceneRuleResponseBodyDataRuleList) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceSceneRuleResponseBodyDataRuleList) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceSceneRuleResponseBodyDataRuleList) SetGmtCreate(v int64) *QueryEdgeInstanceSceneRuleResponseBodyDataRuleList {
	s.GmtCreate = &v
	return s
}

func (s *QueryEdgeInstanceSceneRuleResponseBodyDataRuleList) SetIsExisted(v int32) *QueryEdgeInstanceSceneRuleResponseBodyDataRuleList {
	s.IsExisted = &v
	return s
}

func (s *QueryEdgeInstanceSceneRuleResponseBodyDataRuleList) SetRuleId(v string) *QueryEdgeInstanceSceneRuleResponseBodyDataRuleList {
	s.RuleId = &v
	return s
}

func (s *QueryEdgeInstanceSceneRuleResponseBodyDataRuleList) SetRuleName(v string) *QueryEdgeInstanceSceneRuleResponseBodyDataRuleList {
	s.RuleName = &v
	return s
}

func (s *QueryEdgeInstanceSceneRuleResponseBodyDataRuleList) SetStatus(v int32) *QueryEdgeInstanceSceneRuleResponseBodyDataRuleList {
	s.Status = &v
	return s
}

type QueryEdgeInstanceSceneRuleResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryEdgeInstanceSceneRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryEdgeInstanceSceneRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryEdgeInstanceSceneRuleResponse) GoString() string {
	return s.String()
}

func (s *QueryEdgeInstanceSceneRuleResponse) SetHeaders(v map[string]*string) *QueryEdgeInstanceSceneRuleResponse {
	s.Headers = v
	return s
}

func (s *QueryEdgeInstanceSceneRuleResponse) SetStatusCode(v int32) *QueryEdgeInstanceSceneRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryEdgeInstanceSceneRuleResponse) SetBody(v *QueryEdgeInstanceSceneRuleResponseBody) *QueryEdgeInstanceSceneRuleResponse {
	s.Body = v
	return s
}

type QueryImportedDeviceByApplyIdRequest struct {
	// The application ID. You can call the [BatchImportDevice](~~433878~~) operation to obtain the application ID.
	ApplyId *int64 `json:"ApplyId,omitempty" xml:"ApplyId,omitempty"`
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
	//
	// For more information, see the [Overview](~~356505~~) topic of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The page number. Valid values: 1 to 10000.
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries per page. Default value: 10. Valid values: 1 to 50.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QueryImportedDeviceByApplyIdRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryImportedDeviceByApplyIdRequest) GoString() string {
	return s.String()
}

func (s *QueryImportedDeviceByApplyIdRequest) SetApplyId(v int64) *QueryImportedDeviceByApplyIdRequest {
	s.ApplyId = &v
	return s
}

func (s *QueryImportedDeviceByApplyIdRequest) SetIotInstanceId(v string) *QueryImportedDeviceByApplyIdRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryImportedDeviceByApplyIdRequest) SetPageNo(v int32) *QueryImportedDeviceByApplyIdRequest {
	s.PageNo = &v
	return s
}

func (s *QueryImportedDeviceByApplyIdRequest) SetPageSize(v int32) *QueryImportedDeviceByApplyIdRequest {
	s.PageSize = &v
	return s
}

type QueryImportedDeviceByApplyIdResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The queried devices.
	DeviceList *QueryImportedDeviceByApplyIdResponseBodyDeviceList `json:"DeviceList,omitempty" xml:"DeviceList,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The page number.
	PageNo *int32 `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The **ProductKey** of the product to which the devices belong.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of pages returned.
	TotalPage *int32 `json:"TotalPage,omitempty" xml:"TotalPage,omitempty"`
}

func (s QueryImportedDeviceByApplyIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryImportedDeviceByApplyIdResponseBody) GoString() string {
	return s.String()
}

func (s *QueryImportedDeviceByApplyIdResponseBody) SetCode(v string) *QueryImportedDeviceByApplyIdResponseBody {
	s.Code = &v
	return s
}

func (s *QueryImportedDeviceByApplyIdResponseBody) SetDeviceList(v *QueryImportedDeviceByApplyIdResponseBodyDeviceList) *QueryImportedDeviceByApplyIdResponseBody {
	s.DeviceList = v
	return s
}

func (s *QueryImportedDeviceByApplyIdResponseBody) SetErrorMessage(v string) *QueryImportedDeviceByApplyIdResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryImportedDeviceByApplyIdResponseBody) SetPageNo(v int32) *QueryImportedDeviceByApplyIdResponseBody {
	s.PageNo = &v
	return s
}

func (s *QueryImportedDeviceByApplyIdResponseBody) SetPageSize(v int32) *QueryImportedDeviceByApplyIdResponseBody {
	s.PageSize = &v
	return s
}

func (s *QueryImportedDeviceByApplyIdResponseBody) SetProductKey(v string) *QueryImportedDeviceByApplyIdResponseBody {
	s.ProductKey = &v
	return s
}

func (s *QueryImportedDeviceByApplyIdResponseBody) SetRequestId(v string) *QueryImportedDeviceByApplyIdResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryImportedDeviceByApplyIdResponseBody) SetSuccess(v bool) *QueryImportedDeviceByApplyIdResponseBody {
	s.Success = &v
	return s
}

func (s *QueryImportedDeviceByApplyIdResponseBody) SetTotalPage(v int32) *QueryImportedDeviceByApplyIdResponseBody {
	s.TotalPage = &v
	return s
}

type QueryImportedDeviceByApplyIdResponseBodyDeviceList struct {
	Device []*QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice `json:"device,omitempty" xml:"device,omitempty" type:"Repeated"`
}

func (s QueryImportedDeviceByApplyIdResponseBodyDeviceList) String() string {
	return tea.Prettify(s)
}

func (s QueryImportedDeviceByApplyIdResponseBodyDeviceList) GoString() string {
	return s.String()
}

func (s *QueryImportedDeviceByApplyIdResponseBodyDeviceList) SetDevice(v []*QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice) *QueryImportedDeviceByApplyIdResponseBodyDeviceList {
	s.Device = v
	return s
}

type QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice struct {
	// The DeviceName of the device.
	//
	// >  Keep the information confidential.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The DeviceSecret of the device.
	//
	// >  Keep the information confidential.
	DeviceSecret *string `json:"DeviceSecret,omitempty" xml:"DeviceSecret,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The serial number (SN) of the device.
	//
	// > If you did not specify an SN for the device, this parameter is empty.
	Sn *string `json:"Sn,omitempty" xml:"Sn,omitempty"`
}

func (s QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice) String() string {
	return tea.Prettify(s)
}

func (s QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice) GoString() string {
	return s.String()
}

func (s *QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice) SetDeviceName(v string) *QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice {
	s.DeviceName = &v
	return s
}

func (s *QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice) SetDeviceSecret(v string) *QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice {
	s.DeviceSecret = &v
	return s
}

func (s *QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice) SetProductKey(v string) *QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice {
	s.ProductKey = &v
	return s
}

func (s *QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice) SetSn(v string) *QueryImportedDeviceByApplyIdResponseBodyDeviceListDevice {
	s.Sn = &v
	return s
}

type QueryImportedDeviceByApplyIdResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryImportedDeviceByApplyIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryImportedDeviceByApplyIdResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryImportedDeviceByApplyIdResponse) GoString() string {
	return s.String()
}

func (s *QueryImportedDeviceByApplyIdResponse) SetHeaders(v map[string]*string) *QueryImportedDeviceByApplyIdResponse {
	s.Headers = v
	return s
}

func (s *QueryImportedDeviceByApplyIdResponse) SetStatusCode(v int32) *QueryImportedDeviceByApplyIdResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryImportedDeviceByApplyIdResponse) SetBody(v *QueryImportedDeviceByApplyIdResponseBody) *QueryImportedDeviceByApplyIdResponse {
	s.Body = v
	return s
}

type QueryJobRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	JobId         *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s QueryJobRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryJobRequest) GoString() string {
	return s.String()
}

func (s *QueryJobRequest) SetIotInstanceId(v string) *QueryJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryJobRequest) SetJobId(v string) *QueryJobRequest {
	s.JobId = &v
	return s
}

type QueryJobResponseBody struct {
	Code         *string                   `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryJobResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                   `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                     `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryJobResponseBody) GoString() string {
	return s.String()
}

func (s *QueryJobResponseBody) SetCode(v string) *QueryJobResponseBody {
	s.Code = &v
	return s
}

func (s *QueryJobResponseBody) SetData(v *QueryJobResponseBodyData) *QueryJobResponseBody {
	s.Data = v
	return s
}

func (s *QueryJobResponseBody) SetErrorMessage(v string) *QueryJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryJobResponseBody) SetRequestId(v string) *QueryJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryJobResponseBody) SetSuccess(v bool) *QueryJobResponseBody {
	s.Success = &v
	return s
}

type QueryJobResponseBodyData struct {
	Description   *string                                `json:"Description,omitempty" xml:"Description,omitempty"`
	JobDocument   *string                                `json:"JobDocument,omitempty" xml:"JobDocument,omitempty"`
	JobFile       *QueryJobResponseBodyDataJobFile       `json:"JobFile,omitempty" xml:"JobFile,omitempty" type:"Struct"`
	JobId         *string                                `json:"JobId,omitempty" xml:"JobId,omitempty"`
	JobName       *string                                `json:"JobName,omitempty" xml:"JobName,omitempty"`
	RolloutConfig *QueryJobResponseBodyDataRolloutConfig `json:"RolloutConfig,omitempty" xml:"RolloutConfig,omitempty" type:"Struct"`
	ScheduledTime *int64                                 `json:"ScheduledTime,omitempty" xml:"ScheduledTime,omitempty"`
	Status        *string                                `json:"Status,omitempty" xml:"Status,omitempty"`
	TargetConfig  *QueryJobResponseBodyDataTargetConfig  `json:"TargetConfig,omitempty" xml:"TargetConfig,omitempty" type:"Struct"`
	TimeoutConfig *QueryJobResponseBodyDataTimeoutConfig `json:"TimeoutConfig,omitempty" xml:"TimeoutConfig,omitempty" type:"Struct"`
	Type          *string                                `json:"Type,omitempty" xml:"Type,omitempty"`
	UtcCreate     *string                                `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
	UtcModified   *string                                `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
}

func (s QueryJobResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryJobResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryJobResponseBodyData) SetDescription(v string) *QueryJobResponseBodyData {
	s.Description = &v
	return s
}

func (s *QueryJobResponseBodyData) SetJobDocument(v string) *QueryJobResponseBodyData {
	s.JobDocument = &v
	return s
}

func (s *QueryJobResponseBodyData) SetJobFile(v *QueryJobResponseBodyDataJobFile) *QueryJobResponseBodyData {
	s.JobFile = v
	return s
}

func (s *QueryJobResponseBodyData) SetJobId(v string) *QueryJobResponseBodyData {
	s.JobId = &v
	return s
}

func (s *QueryJobResponseBodyData) SetJobName(v string) *QueryJobResponseBodyData {
	s.JobName = &v
	return s
}

func (s *QueryJobResponseBodyData) SetRolloutConfig(v *QueryJobResponseBodyDataRolloutConfig) *QueryJobResponseBodyData {
	s.RolloutConfig = v
	return s
}

func (s *QueryJobResponseBodyData) SetScheduledTime(v int64) *QueryJobResponseBodyData {
	s.ScheduledTime = &v
	return s
}

func (s *QueryJobResponseBodyData) SetStatus(v string) *QueryJobResponseBodyData {
	s.Status = &v
	return s
}

func (s *QueryJobResponseBodyData) SetTargetConfig(v *QueryJobResponseBodyDataTargetConfig) *QueryJobResponseBodyData {
	s.TargetConfig = v
	return s
}

func (s *QueryJobResponseBodyData) SetTimeoutConfig(v *QueryJobResponseBodyDataTimeoutConfig) *QueryJobResponseBodyData {
	s.TimeoutConfig = v
	return s
}

func (s *QueryJobResponseBodyData) SetType(v string) *QueryJobResponseBodyData {
	s.Type = &v
	return s
}

func (s *QueryJobResponseBodyData) SetUtcCreate(v string) *QueryJobResponseBodyData {
	s.UtcCreate = &v
	return s
}

func (s *QueryJobResponseBodyData) SetUtcModified(v string) *QueryJobResponseBodyData {
	s.UtcModified = &v
	return s
}

type QueryJobResponseBodyDataJobFile struct {
	FileUrl    *string `json:"FileUrl,omitempty" xml:"FileUrl,omitempty"`
	Sign       *string `json:"Sign,omitempty" xml:"Sign,omitempty"`
	SignMethod *string `json:"SignMethod,omitempty" xml:"SignMethod,omitempty"`
}

func (s QueryJobResponseBodyDataJobFile) String() string {
	return tea.Prettify(s)
}

func (s QueryJobResponseBodyDataJobFile) GoString() string {
	return s.String()
}

func (s *QueryJobResponseBodyDataJobFile) SetFileUrl(v string) *QueryJobResponseBodyDataJobFile {
	s.FileUrl = &v
	return s
}

func (s *QueryJobResponseBodyDataJobFile) SetSign(v string) *QueryJobResponseBodyDataJobFile {
	s.Sign = &v
	return s
}

func (s *QueryJobResponseBodyDataJobFile) SetSignMethod(v string) *QueryJobResponseBodyDataJobFile {
	s.SignMethod = &v
	return s
}

type QueryJobResponseBodyDataRolloutConfig struct {
	MaximumPerMinute *int32  `json:"MaximumPerMinute,omitempty" xml:"MaximumPerMinute,omitempty"`
	MessageQoS       *string `json:"MessageQoS,omitempty" xml:"MessageQoS,omitempty"`
}

func (s QueryJobResponseBodyDataRolloutConfig) String() string {
	return tea.Prettify(s)
}

func (s QueryJobResponseBodyDataRolloutConfig) GoString() string {
	return s.String()
}

func (s *QueryJobResponseBodyDataRolloutConfig) SetMaximumPerMinute(v int32) *QueryJobResponseBodyDataRolloutConfig {
	s.MaximumPerMinute = &v
	return s
}

func (s *QueryJobResponseBodyDataRolloutConfig) SetMessageQoS(v string) *QueryJobResponseBodyDataRolloutConfig {
	s.MessageQoS = &v
	return s
}

type QueryJobResponseBodyDataTargetConfig struct {
	TargetDevices *QueryJobResponseBodyDataTargetConfigTargetDevices `json:"TargetDevices,omitempty" xml:"TargetDevices,omitempty" type:"Struct"`
	TargetGroup   *string                                            `json:"TargetGroup,omitempty" xml:"TargetGroup,omitempty"`
	TargetProduct *string                                            `json:"TargetProduct,omitempty" xml:"TargetProduct,omitempty"`
	TargetType    *string                                            `json:"TargetType,omitempty" xml:"TargetType,omitempty"`
}

func (s QueryJobResponseBodyDataTargetConfig) String() string {
	return tea.Prettify(s)
}

func (s QueryJobResponseBodyDataTargetConfig) GoString() string {
	return s.String()
}

func (s *QueryJobResponseBodyDataTargetConfig) SetTargetDevices(v *QueryJobResponseBodyDataTargetConfigTargetDevices) *QueryJobResponseBodyDataTargetConfig {
	s.TargetDevices = v
	return s
}

func (s *QueryJobResponseBodyDataTargetConfig) SetTargetGroup(v string) *QueryJobResponseBodyDataTargetConfig {
	s.TargetGroup = &v
	return s
}

func (s *QueryJobResponseBodyDataTargetConfig) SetTargetProduct(v string) *QueryJobResponseBodyDataTargetConfig {
	s.TargetProduct = &v
	return s
}

func (s *QueryJobResponseBodyDataTargetConfig) SetTargetType(v string) *QueryJobResponseBodyDataTargetConfig {
	s.TargetType = &v
	return s
}

type QueryJobResponseBodyDataTargetConfigTargetDevices struct {
	TargetDevices []*QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices `json:"targetDevices,omitempty" xml:"targetDevices,omitempty" type:"Repeated"`
}

func (s QueryJobResponseBodyDataTargetConfigTargetDevices) String() string {
	return tea.Prettify(s)
}

func (s QueryJobResponseBodyDataTargetConfigTargetDevices) GoString() string {
	return s.String()
}

func (s *QueryJobResponseBodyDataTargetConfigTargetDevices) SetTargetDevices(v []*QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices) *QueryJobResponseBodyDataTargetConfigTargetDevices {
	s.TargetDevices = v
	return s
}

type QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices struct {
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices) String() string {
	return tea.Prettify(s)
}

func (s QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices) GoString() string {
	return s.String()
}

func (s *QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices) SetDeviceName(v string) *QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices {
	s.DeviceName = &v
	return s
}

func (s *QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices) SetProductKey(v string) *QueryJobResponseBodyDataTargetConfigTargetDevicesTargetDevices {
	s.ProductKey = &v
	return s
}

type QueryJobResponseBodyDataTimeoutConfig struct {
	InProgressTimeoutInMinutes *int32 `json:"InProgressTimeoutInMinutes,omitempty" xml:"InProgressTimeoutInMinutes,omitempty"`
}

func (s QueryJobResponseBodyDataTimeoutConfig) String() string {
	return tea.Prettify(s)
}

func (s QueryJobResponseBodyDataTimeoutConfig) GoString() string {
	return s.String()
}

func (s *QueryJobResponseBodyDataTimeoutConfig) SetInProgressTimeoutInMinutes(v int32) *QueryJobResponseBodyDataTimeoutConfig {
	s.InProgressTimeoutInMinutes = &v
	return s
}

type QueryJobResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryJobResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryJobResponse) GoString() string {
	return s.String()
}

func (s *QueryJobResponse) SetHeaders(v map[string]*string) *QueryJobResponse {
	s.Headers = v
	return s
}

func (s *QueryJobResponse) SetStatusCode(v int32) *QueryJobResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryJobResponse) SetBody(v *QueryJobResponseBody) *QueryJobResponse {
	s.Body = v
	return s
}

type QueryJobStatisticsRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	JobId         *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s QueryJobStatisticsRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryJobStatisticsRequest) GoString() string {
	return s.String()
}

func (s *QueryJobStatisticsRequest) SetIotInstanceId(v string) *QueryJobStatisticsRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryJobStatisticsRequest) SetJobId(v string) *QueryJobStatisticsRequest {
	s.JobId = &v
	return s
}

type QueryJobStatisticsResponseBody struct {
	Code         *string                             `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryJobStatisticsResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                             `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                               `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryJobStatisticsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryJobStatisticsResponseBody) GoString() string {
	return s.String()
}

func (s *QueryJobStatisticsResponseBody) SetCode(v string) *QueryJobStatisticsResponseBody {
	s.Code = &v
	return s
}

func (s *QueryJobStatisticsResponseBody) SetData(v *QueryJobStatisticsResponseBodyData) *QueryJobStatisticsResponseBody {
	s.Data = v
	return s
}

func (s *QueryJobStatisticsResponseBody) SetErrorMessage(v string) *QueryJobStatisticsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryJobStatisticsResponseBody) SetRequestId(v string) *QueryJobStatisticsResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryJobStatisticsResponseBody) SetSuccess(v bool) *QueryJobStatisticsResponseBody {
	s.Success = &v
	return s
}

type QueryJobStatisticsResponseBodyData struct {
	Cancelled  *int32 `json:"Cancelled,omitempty" xml:"Cancelled,omitempty"`
	Failed     *int32 `json:"Failed,omitempty" xml:"Failed,omitempty"`
	InProgress *int32 `json:"InProgress,omitempty" xml:"InProgress,omitempty"`
	Queued     *int32 `json:"Queued,omitempty" xml:"Queued,omitempty"`
	Rejected   *int32 `json:"Rejected,omitempty" xml:"Rejected,omitempty"`
	Sent       *int32 `json:"Sent,omitempty" xml:"Sent,omitempty"`
	Succeeded  *int32 `json:"Succeeded,omitempty" xml:"Succeeded,omitempty"`
	TimeOut    *int32 `json:"TimeOut,omitempty" xml:"TimeOut,omitempty"`
	Total      *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryJobStatisticsResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryJobStatisticsResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryJobStatisticsResponseBodyData) SetCancelled(v int32) *QueryJobStatisticsResponseBodyData {
	s.Cancelled = &v
	return s
}

func (s *QueryJobStatisticsResponseBodyData) SetFailed(v int32) *QueryJobStatisticsResponseBodyData {
	s.Failed = &v
	return s
}

func (s *QueryJobStatisticsResponseBodyData) SetInProgress(v int32) *QueryJobStatisticsResponseBodyData {
	s.InProgress = &v
	return s
}

func (s *QueryJobStatisticsResponseBodyData) SetQueued(v int32) *QueryJobStatisticsResponseBodyData {
	s.Queued = &v
	return s
}

func (s *QueryJobStatisticsResponseBodyData) SetRejected(v int32) *QueryJobStatisticsResponseBodyData {
	s.Rejected = &v
	return s
}

func (s *QueryJobStatisticsResponseBodyData) SetSent(v int32) *QueryJobStatisticsResponseBodyData {
	s.Sent = &v
	return s
}

func (s *QueryJobStatisticsResponseBodyData) SetSucceeded(v int32) *QueryJobStatisticsResponseBodyData {
	s.Succeeded = &v
	return s
}

func (s *QueryJobStatisticsResponseBodyData) SetTimeOut(v int32) *QueryJobStatisticsResponseBodyData {
	s.TimeOut = &v
	return s
}

func (s *QueryJobStatisticsResponseBodyData) SetTotal(v int32) *QueryJobStatisticsResponseBodyData {
	s.Total = &v
	return s
}

type QueryJobStatisticsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryJobStatisticsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryJobStatisticsResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryJobStatisticsResponse) GoString() string {
	return s.String()
}

func (s *QueryJobStatisticsResponse) SetHeaders(v map[string]*string) *QueryJobStatisticsResponse {
	s.Headers = v
	return s
}

func (s *QueryJobStatisticsResponse) SetStatusCode(v int32) *QueryJobStatisticsResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryJobStatisticsResponse) SetBody(v *QueryJobStatisticsResponseBody) *QueryJobStatisticsResponse {
	s.Body = v
	return s
}

type QueryLicenseDeviceListRequest struct {
	// The end time of the time range in which the license is bound to the devices.The timestamp follows the UNIX time format. It is the number of seconds that have elapsed since 00:00:00 Thursday, January 1, 1970.
	EndTime *int64 `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	// The ID of the device.
	//
	// You can call the [QueryDevice](~~69905~~) operation to query the **IotId** values of all devices that belong to a specific product.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  You must specify this parameter for a public instance of the new version or an Enterprise Edition instance. You do not need to specify this parameter for a public instance of the previous version.
	//
	// For more information, see the [Overview](~~356505~~) topic of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The license type that specifies the audio and video specifications. Valid values: **480P** and **720P**.
	LicenseCode *string `json:"LicenseCode,omitempty" xml:"LicenseCode,omitempty"`
	// The page number.
	PageId *int32 `json:"PageId,omitempty" xml:"PageId,omitempty"`
	// The number of entries per page. Valid values: 1 to 100. Default value: 20.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The **ProductKey** of the product to which the devices belong.
	//
	// You can go to the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products of the instance.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The start time of the time range in which the license is bound to the devices. The timestamp follows the UNIX time format. It is the number of seconds that have elapsed since 00:00:00 Thursday, January 1, 1970.
	StartTime *int64 `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s QueryLicenseDeviceListRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryLicenseDeviceListRequest) GoString() string {
	return s.String()
}

func (s *QueryLicenseDeviceListRequest) SetEndTime(v int64) *QueryLicenseDeviceListRequest {
	s.EndTime = &v
	return s
}

func (s *QueryLicenseDeviceListRequest) SetIotId(v string) *QueryLicenseDeviceListRequest {
	s.IotId = &v
	return s
}

func (s *QueryLicenseDeviceListRequest) SetIotInstanceId(v string) *QueryLicenseDeviceListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryLicenseDeviceListRequest) SetLicenseCode(v string) *QueryLicenseDeviceListRequest {
	s.LicenseCode = &v
	return s
}

func (s *QueryLicenseDeviceListRequest) SetPageId(v int32) *QueryLicenseDeviceListRequest {
	s.PageId = &v
	return s
}

func (s *QueryLicenseDeviceListRequest) SetPageSize(v int32) *QueryLicenseDeviceListRequest {
	s.PageSize = &v
	return s
}

func (s *QueryLicenseDeviceListRequest) SetProductKey(v string) *QueryLicenseDeviceListRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryLicenseDeviceListRequest) SetStartTime(v int64) *QueryLicenseDeviceListRequest {
	s.StartTime = &v
	return s
}

type QueryLicenseDeviceListResponseBody struct {
	// The error code returned if the request fails. For more information, see the **"Error codes"** section in this topic.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The response message.
	Data *QueryLicenseDeviceListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryLicenseDeviceListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryLicenseDeviceListResponseBody) GoString() string {
	return s.String()
}

func (s *QueryLicenseDeviceListResponseBody) SetCode(v string) *QueryLicenseDeviceListResponseBody {
	s.Code = &v
	return s
}

func (s *QueryLicenseDeviceListResponseBody) SetData(v *QueryLicenseDeviceListResponseBodyData) *QueryLicenseDeviceListResponseBody {
	s.Data = v
	return s
}

func (s *QueryLicenseDeviceListResponseBody) SetErrorMessage(v string) *QueryLicenseDeviceListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryLicenseDeviceListResponseBody) SetRequestId(v string) *QueryLicenseDeviceListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryLicenseDeviceListResponseBody) SetSuccess(v bool) *QueryLicenseDeviceListResponseBody {
	s.Success = &v
	return s
}

type QueryLicenseDeviceListResponseBodyData struct {
	// The information about the devices.
	DeviceList *QueryLicenseDeviceListResponseBodyDataDeviceList `json:"DeviceList,omitempty" xml:"DeviceList,omitempty" type:"Struct"`
	// The page number.
	PageId *int32 `json:"PageId,omitempty" xml:"PageId,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryLicenseDeviceListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryLicenseDeviceListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryLicenseDeviceListResponseBodyData) SetDeviceList(v *QueryLicenseDeviceListResponseBodyDataDeviceList) *QueryLicenseDeviceListResponseBodyData {
	s.DeviceList = v
	return s
}

func (s *QueryLicenseDeviceListResponseBodyData) SetPageId(v int32) *QueryLicenseDeviceListResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QueryLicenseDeviceListResponseBodyData) SetPageSize(v int32) *QueryLicenseDeviceListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryLicenseDeviceListResponseBodyData) SetTotal(v int32) *QueryLicenseDeviceListResponseBodyData {
	s.Total = &v
	return s
}

type QueryLicenseDeviceListResponseBodyDataDeviceList struct {
	Item []*QueryLicenseDeviceListResponseBodyDataDeviceListItem `json:"item,omitempty" xml:"item,omitempty" type:"Repeated"`
}

func (s QueryLicenseDeviceListResponseBodyDataDeviceList) String() string {
	return tea.Prettify(s)
}

func (s QueryLicenseDeviceListResponseBodyDataDeviceList) GoString() string {
	return s.String()
}

func (s *QueryLicenseDeviceListResponseBodyDataDeviceList) SetItem(v []*QueryLicenseDeviceListResponseBodyDataDeviceListItem) *QueryLicenseDeviceListResponseBodyDataDeviceList {
	s.Item = v
	return s
}

type QueryLicenseDeviceListResponseBodyDataDeviceListItem struct {
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The expiration time of the license.
	ExpiryTime *int64 `json:"ExpiryTime,omitempty" xml:"ExpiryTime,omitempty"`
	// The time when the license was bound to the device.
	GmtCreate *int64 `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The device ID.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The license type that indicates the audio and video specifications. Valid values: **480P** and **720P**.
	LicenseCode *string `json:"LicenseCode,omitempty" xml:"LicenseCode,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ProductName of the product.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
}

func (s QueryLicenseDeviceListResponseBodyDataDeviceListItem) String() string {
	return tea.Prettify(s)
}

func (s QueryLicenseDeviceListResponseBodyDataDeviceListItem) GoString() string {
	return s.String()
}

func (s *QueryLicenseDeviceListResponseBodyDataDeviceListItem) SetDeviceName(v string) *QueryLicenseDeviceListResponseBodyDataDeviceListItem {
	s.DeviceName = &v
	return s
}

func (s *QueryLicenseDeviceListResponseBodyDataDeviceListItem) SetExpiryTime(v int64) *QueryLicenseDeviceListResponseBodyDataDeviceListItem {
	s.ExpiryTime = &v
	return s
}

func (s *QueryLicenseDeviceListResponseBodyDataDeviceListItem) SetGmtCreate(v int64) *QueryLicenseDeviceListResponseBodyDataDeviceListItem {
	s.GmtCreate = &v
	return s
}

func (s *QueryLicenseDeviceListResponseBodyDataDeviceListItem) SetIotId(v string) *QueryLicenseDeviceListResponseBodyDataDeviceListItem {
	s.IotId = &v
	return s
}

func (s *QueryLicenseDeviceListResponseBodyDataDeviceListItem) SetLicenseCode(v string) *QueryLicenseDeviceListResponseBodyDataDeviceListItem {
	s.LicenseCode = &v
	return s
}

func (s *QueryLicenseDeviceListResponseBodyDataDeviceListItem) SetProductKey(v string) *QueryLicenseDeviceListResponseBodyDataDeviceListItem {
	s.ProductKey = &v
	return s
}

func (s *QueryLicenseDeviceListResponseBodyDataDeviceListItem) SetProductName(v string) *QueryLicenseDeviceListResponseBodyDataDeviceListItem {
	s.ProductName = &v
	return s
}

type QueryLicenseDeviceListResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryLicenseDeviceListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryLicenseDeviceListResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryLicenseDeviceListResponse) GoString() string {
	return s.String()
}

func (s *QueryLicenseDeviceListResponse) SetHeaders(v map[string]*string) *QueryLicenseDeviceListResponse {
	s.Headers = v
	return s
}

func (s *QueryLicenseDeviceListResponse) SetStatusCode(v int32) *QueryLicenseDeviceListResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryLicenseDeviceListResponse) SetBody(v *QueryLicenseDeviceListResponseBody) *QueryLicenseDeviceListResponse {
	s.Body = v
	return s
}

type QueryLoRaJoinPermissionsRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s QueryLoRaJoinPermissionsRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryLoRaJoinPermissionsRequest) GoString() string {
	return s.String()
}

func (s *QueryLoRaJoinPermissionsRequest) SetIotInstanceId(v string) *QueryLoRaJoinPermissionsRequest {
	s.IotInstanceId = &v
	return s
}

type QueryLoRaJoinPermissionsResponseBody struct {
	Code            *string                                              `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage    *string                                              `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	JoinPermissions *QueryLoRaJoinPermissionsResponseBodyJoinPermissions `json:"JoinPermissions,omitempty" xml:"JoinPermissions,omitempty" type:"Struct"`
	ProductKey      *string                                              `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	RequestId       *string                                              `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success         *bool                                                `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryLoRaJoinPermissionsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryLoRaJoinPermissionsResponseBody) GoString() string {
	return s.String()
}

func (s *QueryLoRaJoinPermissionsResponseBody) SetCode(v string) *QueryLoRaJoinPermissionsResponseBody {
	s.Code = &v
	return s
}

func (s *QueryLoRaJoinPermissionsResponseBody) SetErrorMessage(v string) *QueryLoRaJoinPermissionsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryLoRaJoinPermissionsResponseBody) SetJoinPermissions(v *QueryLoRaJoinPermissionsResponseBodyJoinPermissions) *QueryLoRaJoinPermissionsResponseBody {
	s.JoinPermissions = v
	return s
}

func (s *QueryLoRaJoinPermissionsResponseBody) SetProductKey(v string) *QueryLoRaJoinPermissionsResponseBody {
	s.ProductKey = &v
	return s
}

func (s *QueryLoRaJoinPermissionsResponseBody) SetRequestId(v string) *QueryLoRaJoinPermissionsResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryLoRaJoinPermissionsResponseBody) SetSuccess(v bool) *QueryLoRaJoinPermissionsResponseBody {
	s.Success = &v
	return s
}

type QueryLoRaJoinPermissionsResponseBodyJoinPermissions struct {
	JoinPermission []*QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission `json:"JoinPermission,omitempty" xml:"JoinPermission,omitempty" type:"Repeated"`
}

func (s QueryLoRaJoinPermissionsResponseBodyJoinPermissions) String() string {
	return tea.Prettify(s)
}

func (s QueryLoRaJoinPermissionsResponseBodyJoinPermissions) GoString() string {
	return s.String()
}

func (s *QueryLoRaJoinPermissionsResponseBodyJoinPermissions) SetJoinPermission(v []*QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission) *QueryLoRaJoinPermissionsResponseBodyJoinPermissions {
	s.JoinPermission = v
	return s
}

type QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission struct {
	ClassMode          *string `json:"ClassMode,omitempty" xml:"ClassMode,omitempty"`
	Enabled            *bool   `json:"Enabled,omitempty" xml:"Enabled,omitempty"`
	JoinPermissionId   *string `json:"JoinPermissionId,omitempty" xml:"JoinPermissionId,omitempty"`
	JoinPermissionName *string `json:"JoinPermissionName,omitempty" xml:"JoinPermissionName,omitempty"`
	JoinPermissionType *string `json:"JoinPermissionType,omitempty" xml:"JoinPermissionType,omitempty"`
	OwnerAliyunPk      *string `json:"OwnerAliyunPk,omitempty" xml:"OwnerAliyunPk,omitempty"`
}

func (s QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission) String() string {
	return tea.Prettify(s)
}

func (s QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission) GoString() string {
	return s.String()
}

func (s *QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission) SetClassMode(v string) *QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission {
	s.ClassMode = &v
	return s
}

func (s *QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission) SetEnabled(v bool) *QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission {
	s.Enabled = &v
	return s
}

func (s *QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission) SetJoinPermissionId(v string) *QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission {
	s.JoinPermissionId = &v
	return s
}

func (s *QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission) SetJoinPermissionName(v string) *QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission {
	s.JoinPermissionName = &v
	return s
}

func (s *QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission) SetJoinPermissionType(v string) *QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission {
	s.JoinPermissionType = &v
	return s
}

func (s *QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission) SetOwnerAliyunPk(v string) *QueryLoRaJoinPermissionsResponseBodyJoinPermissionsJoinPermission {
	s.OwnerAliyunPk = &v
	return s
}

type QueryLoRaJoinPermissionsResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryLoRaJoinPermissionsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryLoRaJoinPermissionsResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryLoRaJoinPermissionsResponse) GoString() string {
	return s.String()
}

func (s *QueryLoRaJoinPermissionsResponse) SetHeaders(v map[string]*string) *QueryLoRaJoinPermissionsResponse {
	s.Headers = v
	return s
}

func (s *QueryLoRaJoinPermissionsResponse) SetStatusCode(v int32) *QueryLoRaJoinPermissionsResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryLoRaJoinPermissionsResponse) SetBody(v *QueryLoRaJoinPermissionsResponseBody) *QueryLoRaJoinPermissionsResponse {
	s.Body = v
	return s
}

type QueryMessageInfoRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	UniMsgId      *string `json:"UniMsgId,omitempty" xml:"UniMsgId,omitempty"`
}

func (s QueryMessageInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryMessageInfoRequest) GoString() string {
	return s.String()
}

func (s *QueryMessageInfoRequest) SetIotInstanceId(v string) *QueryMessageInfoRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryMessageInfoRequest) SetUniMsgId(v string) *QueryMessageInfoRequest {
	s.UniMsgId = &v
	return s
}

type QueryMessageInfoResponseBody struct {
	Code         *string                              `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string                              `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	Message      *QueryMessageInfoResponseBodyMessage `json:"Message,omitempty" xml:"Message,omitempty" type:"Struct"`
	RequestId    *string                              `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryMessageInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryMessageInfoResponseBody) GoString() string {
	return s.String()
}

func (s *QueryMessageInfoResponseBody) SetCode(v string) *QueryMessageInfoResponseBody {
	s.Code = &v
	return s
}

func (s *QueryMessageInfoResponseBody) SetErrorMessage(v string) *QueryMessageInfoResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryMessageInfoResponseBody) SetMessage(v *QueryMessageInfoResponseBodyMessage) *QueryMessageInfoResponseBody {
	s.Message = v
	return s
}

func (s *QueryMessageInfoResponseBody) SetRequestId(v string) *QueryMessageInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryMessageInfoResponseBody) SetSuccess(v bool) *QueryMessageInfoResponseBody {
	s.Success = &v
	return s
}

type QueryMessageInfoResponseBodyMessage struct {
	GenerateTime   *int64                                               `json:"GenerateTime,omitempty" xml:"GenerateTime,omitempty"`
	MessageContent *string                                              `json:"MessageContent,omitempty" xml:"MessageContent,omitempty"`
	TopicFullName  *string                                              `json:"TopicFullName,omitempty" xml:"TopicFullName,omitempty"`
	UniMsgId       *string                                              `json:"UniMsgId,omitempty" xml:"UniMsgId,omitempty"`
	UserProperties []*QueryMessageInfoResponseBodyMessageUserProperties `json:"UserProperties,omitempty" xml:"UserProperties,omitempty" type:"Repeated"`
}

func (s QueryMessageInfoResponseBodyMessage) String() string {
	return tea.Prettify(s)
}

func (s QueryMessageInfoResponseBodyMessage) GoString() string {
	return s.String()
}

func (s *QueryMessageInfoResponseBodyMessage) SetGenerateTime(v int64) *QueryMessageInfoResponseBodyMessage {
	s.GenerateTime = &v
	return s
}

func (s *QueryMessageInfoResponseBodyMessage) SetMessageContent(v string) *QueryMessageInfoResponseBodyMessage {
	s.MessageContent = &v
	return s
}

func (s *QueryMessageInfoResponseBodyMessage) SetTopicFullName(v string) *QueryMessageInfoResponseBodyMessage {
	s.TopicFullName = &v
	return s
}

func (s *QueryMessageInfoResponseBodyMessage) SetUniMsgId(v string) *QueryMessageInfoResponseBodyMessage {
	s.UniMsgId = &v
	return s
}

func (s *QueryMessageInfoResponseBodyMessage) SetUserProperties(v []*QueryMessageInfoResponseBodyMessageUserProperties) *QueryMessageInfoResponseBodyMessage {
	s.UserProperties = v
	return s
}

type QueryMessageInfoResponseBodyMessageUserProperties struct {
	Key   *string `json:"Key,omitempty" xml:"Key,omitempty"`
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s QueryMessageInfoResponseBodyMessageUserProperties) String() string {
	return tea.Prettify(s)
}

func (s QueryMessageInfoResponseBodyMessageUserProperties) GoString() string {
	return s.String()
}

func (s *QueryMessageInfoResponseBodyMessageUserProperties) SetKey(v string) *QueryMessageInfoResponseBodyMessageUserProperties {
	s.Key = &v
	return s
}

func (s *QueryMessageInfoResponseBodyMessageUserProperties) SetValue(v string) *QueryMessageInfoResponseBodyMessageUserProperties {
	s.Value = &v
	return s
}

type QueryMessageInfoResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryMessageInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryMessageInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryMessageInfoResponse) GoString() string {
	return s.String()
}

func (s *QueryMessageInfoResponse) SetHeaders(v map[string]*string) *QueryMessageInfoResponse {
	s.Headers = v
	return s
}

func (s *QueryMessageInfoResponse) SetStatusCode(v int32) *QueryMessageInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryMessageInfoResponse) SetBody(v *QueryMessageInfoResponseBody) *QueryMessageInfoResponse {
	s.Body = v
	return s
}

type QueryOTAFirmwareRequest struct {
	// The unique ID of the OTA update package.
	//
	// An update package ID is returned when you call the [CreateOTAFirmware](~~147311~~) operation to create the update package.
	//
	// You can call the [ListOTAFirmware](~~147450~~) operation and view the update package ID in the response.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s QueryOTAFirmwareRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryOTAFirmwareRequest) GoString() string {
	return s.String()
}

func (s *QueryOTAFirmwareRequest) SetFirmwareId(v string) *QueryOTAFirmwareRequest {
	s.FirmwareId = &v
	return s
}

func (s *QueryOTAFirmwareRequest) SetIotInstanceId(v string) *QueryOTAFirmwareRequest {
	s.IotInstanceId = &v
	return s
}

type QueryOTAFirmwareResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The update package information returned if the call succeeds. For more information, see **FirmwareInfo**.
	FirmwareInfo *QueryOTAFirmwareResponseBodyFirmwareInfo `json:"FirmwareInfo,omitempty" xml:"FirmwareInfo,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryOTAFirmwareResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryOTAFirmwareResponseBody) GoString() string {
	return s.String()
}

func (s *QueryOTAFirmwareResponseBody) SetCode(v string) *QueryOTAFirmwareResponseBody {
	s.Code = &v
	return s
}

func (s *QueryOTAFirmwareResponseBody) SetErrorMessage(v string) *QueryOTAFirmwareResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryOTAFirmwareResponseBody) SetFirmwareInfo(v *QueryOTAFirmwareResponseBodyFirmwareInfo) *QueryOTAFirmwareResponseBody {
	s.FirmwareInfo = v
	return s
}

func (s *QueryOTAFirmwareResponseBody) SetRequestId(v string) *QueryOTAFirmwareResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryOTAFirmwareResponseBody) SetSuccess(v bool) *QueryOTAFirmwareResponseBody {
	s.Success = &v
	return s
}

type QueryOTAFirmwareResponseBodyFirmwareInfo struct {
	// The version number of the OTA update package.
	DestVersion *string `json:"DestVersion,omitempty" xml:"DestVersion,omitempty"`
	// The description of the OTA update package.
	FirmwareDesc *string `json:"FirmwareDesc,omitempty" xml:"FirmwareDesc,omitempty"`
	// The unique ID of the OTA update package.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The name of the OTA update package.
	FirmwareName *string `json:"FirmwareName,omitempty" xml:"FirmwareName,omitempty"`
	// The signature of the OTA update package.
	//
	// >  This parameter is available if the OTA update package contains a single file.
	FirmwareSign *string `json:"FirmwareSign,omitempty" xml:"FirmwareSign,omitempty"`
	// The size of the OTA update package file. Unit: bytes.
	//
	// >  This parameter is available if the OTA update package contains a single file.
	FirmwareSize *int32 `json:"FirmwareSize,omitempty" xml:"FirmwareSize,omitempty"`
	// The URL of the update package file that is stored in Object Storage Service (OSS).
	//
	// >  This parameter is available if the OTA update package contains a single file.
	FirmwareUrl *string `json:"FirmwareUrl,omitempty" xml:"FirmwareUrl,omitempty"`
	// The name of the module.
	//
	// OTA updates are based on the firmware modules of a device. For more information, see [Add a custom OTA module to an update package](~~202664~~).
	ModuleName *string `json:"ModuleName,omitempty" xml:"ModuleName,omitempty"`
	// The information about the OTA update package files. This parameter is available if the OTA update package contains multiple files.
	MultiFiles []*QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles `json:"MultiFiles,omitempty" xml:"MultiFiles,omitempty" type:"Repeated"`
	// The **ProductKey** of the product to which the OTA update package belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The name of the product to which the OTA update package belongs.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
	// The signature method of the OTA update package.
	SignMethod *string `json:"SignMethod,omitempty" xml:"SignMethod,omitempty"`
	// The version number of the original update package to be updated.
	//
	// >  This parameter is returned if you perform a delta update. For more information about update package types, see the description of the **Type** parameter.
	SrcVersion *string `json:"SrcVersion,omitempty" xml:"SrcVersion,omitempty"`
	// The status of the OTA update package. Valid values:
	//
	// *   **-1**: no verification is required
	// *   **0**: unverified
	// *   **1**: verified
	// *   **2**: verifying
	// *   **3**: failed to be verified
	Status *int32 `json:"Status,omitempty" xml:"Status,omitempty"`
	// The type of the OTA update package. Valid values:
	//
	// *   **0**: The uploaded file contains a full update package. IoT Platform pushes the full update package to a device for update.
	// *   **1**: The uploaded file contains only the differences between the latest update package and previous update package. IoT Platform pushes only the differences to a device for update.
	Type *int32 `json:"Type,omitempty" xml:"Type,omitempty"`
	// The custom information that was pushed to the device. The information can be up to 4,096 characters in length. No limit is applies to the content format.
	//
	// After you add the update package and create an update task, IoT Platform sends the custom information to the specified device when IoT Platform pushes the update notification.
	Udi *string `json:"Udi,omitempty" xml:"Udi,omitempty"`
	// The time when the OTA update package was created. The time is displayed in UTC.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
	// The time when the update task was last modified. The time is displayed in UTC.
	UtcModified *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
	// The verification status of the OTA update package. Valid values:
	//
	// *   **0**: unverified
	// *   **100**: verified
	// *   A value N between 0 and 100 indicates that the update task is N percent completed. You can check the response parameter **Status** to see the verification status.
	VerifyProgress *int32 `json:"VerifyProgress,omitempty" xml:"VerifyProgress,omitempty"`
}

func (s QueryOTAFirmwareResponseBodyFirmwareInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryOTAFirmwareResponseBodyFirmwareInfo) GoString() string {
	return s.String()
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetDestVersion(v string) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.DestVersion = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetFirmwareDesc(v string) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.FirmwareDesc = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetFirmwareId(v string) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.FirmwareId = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetFirmwareName(v string) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.FirmwareName = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetFirmwareSign(v string) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.FirmwareSign = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetFirmwareSize(v int32) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.FirmwareSize = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetFirmwareUrl(v string) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.FirmwareUrl = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetModuleName(v string) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.ModuleName = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetMultiFiles(v []*QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.MultiFiles = v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetProductKey(v string) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.ProductKey = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetProductName(v string) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.ProductName = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetSignMethod(v string) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.SignMethod = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetSrcVersion(v string) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.SrcVersion = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetStatus(v int32) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.Status = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetType(v int32) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.Type = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetUdi(v string) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.Udi = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetUtcCreate(v string) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.UtcCreate = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetUtcModified(v string) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.UtcModified = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfo) SetVerifyProgress(v int32) *QueryOTAFirmwareResponseBodyFirmwareInfo {
	s.VerifyProgress = &v
	return s
}

type QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles struct {
	// The MD5 value of the OTA update package file.
	FileMd5 *string `json:"FileMd5,omitempty" xml:"FileMd5,omitempty"`
	// The name of the OTA update package file.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The signature of the OTA update package file.
	SignValue *string `json:"SignValue,omitempty" xml:"SignValue,omitempty"`
	// The size of the OTA update package file. Unit: bytes.
	Size *int32 `json:"Size,omitempty" xml:"Size,omitempty"`
	// The URL of the update package file that is stored in Object Storage Service (OSS).
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles) String() string {
	return tea.Prettify(s)
}

func (s QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles) GoString() string {
	return s.String()
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles) SetFileMd5(v string) *QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles {
	s.FileMd5 = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles) SetName(v string) *QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles {
	s.Name = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles) SetSignValue(v string) *QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles {
	s.SignValue = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles) SetSize(v int32) *QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles {
	s.Size = &v
	return s
}

func (s *QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles) SetUrl(v string) *QueryOTAFirmwareResponseBodyFirmwareInfoMultiFiles {
	s.Url = &v
	return s
}

type QueryOTAFirmwareResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryOTAFirmwareResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryOTAFirmwareResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryOTAFirmwareResponse) GoString() string {
	return s.String()
}

func (s *QueryOTAFirmwareResponse) SetHeaders(v map[string]*string) *QueryOTAFirmwareResponse {
	s.Headers = v
	return s
}

func (s *QueryOTAFirmwareResponse) SetStatusCode(v int32) *QueryOTAFirmwareResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryOTAFirmwareResponse) SetBody(v *QueryOTAFirmwareResponseBody) *QueryOTAFirmwareResponse {
	s.Body = v
	return s
}

type QueryOTAJobRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the update batch.
	//
	// After you call the [CreateOTAVerifyJob](~~147480~~), [CreateOTAStaticUpgradeJob](~~147496~~), or [CreateOTADynamicUpgradeJob](~~147887~~) API operation to create the update batch, you can obtain the **JobId** parameter. You can also view the batch ID on the **Update Package Details** page of the IoT Platform console.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s QueryOTAJobRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryOTAJobRequest) GoString() string {
	return s.String()
}

func (s *QueryOTAJobRequest) SetIotInstanceId(v string) *QueryOTAJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryOTAJobRequest) SetJobId(v string) *QueryOTAJobRequest {
	s.JobId = &v
	return s
}

type QueryOTAJobResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The update batch information returned if the call is successful. For more information, see the following parameters.
	Data *QueryOTAJobResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryOTAJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryOTAJobResponseBody) GoString() string {
	return s.String()
}

func (s *QueryOTAJobResponseBody) SetCode(v string) *QueryOTAJobResponseBody {
	s.Code = &v
	return s
}

func (s *QueryOTAJobResponseBody) SetData(v *QueryOTAJobResponseBodyData) *QueryOTAJobResponseBody {
	s.Data = v
	return s
}

func (s *QueryOTAJobResponseBody) SetErrorMessage(v string) *QueryOTAJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryOTAJobResponseBody) SetRequestId(v string) *QueryOTAJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryOTAJobResponseBody) SetSuccess(v bool) *QueryOTAJobResponseBody {
	s.Success = &v
	return s
}

type QueryOTAJobResponseBodyData struct {
	// The destination firmware version of the update.
	DestVersion *string `json:"DestVersion,omitempty" xml:"DestVersion,omitempty"`
	// The download protocol of the update package.
	DownloadProtocol *string `json:"DownloadProtocol,omitempty" xml:"DownloadProtocol,omitempty"`
	// The mode of dynamic update. Valid values:
	//
	// *   **1**: constantly updates the devices that meet the conditions.
	// *   **2**: updates only the devices that subsequently submit the latest firmware versions.
	//
	// This parameter is returned only if you perform a dynamic update.
	DynamicMode *int32 `json:"DynamicMode,omitempty" xml:"DynamicMode,omitempty"`
	// The ID of the update package.
	FirmwareId *string `json:"FirmwareId,omitempty" xml:"FirmwareId,omitempty"`
	// The phase ratio of the phased update.
	//
	// This parameter is returned only if you perform a phased update.
	GrayPercent *string `json:"GrayPercent,omitempty" xml:"GrayPercent,omitempty"`
	// The ID of the device group to be updated.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the device group to be updated.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	// The description of the update batch.
	JobDesc *string `json:"JobDesc,omitempty" xml:"JobDesc,omitempty"`
	// The ID of the update batch.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The status of the update batch.
	//
	// *   **PLANNED**: The update batch is being planned. The batch is created, but the scheduled time has not arrived. This parameter is returned only if you perform a static update.
	// *   **IN_PROGRESS**: The update batch is running.
	// *   **COMPLETED**: The update batch is completed.
	// *   **CANCELED**: The update batch is canceled.
	JobStatus *string `json:"JobStatus,omitempty" xml:"JobStatus,omitempty"`
	// The type of the batch. Valid values:
	//
	// *   **VERFIY_FIRMWARE**: update package verification.
	// *   **UPGRADE_FIRMWARE**: batch update.
	JobType *string `json:"JobType,omitempty" xml:"JobType,omitempty"`
	// The maximum number of devices to which the download URL of the update package is pushed per minute.
	MaximumPerMinute *int32 `json:"MaximumPerMinute,omitempty" xml:"MaximumPerMinute,omitempty"`
	// Specifies whether the device supports simultaneous updates of multiple modules.
	//
	// *   **false** (default): no.
	// *   **true**: yes.
	//
	// For more information, see [Overview](~~58328~~).
	MultiModuleMode *bool `json:"MultiModuleMode,omitempty" xml:"MultiModuleMode,omitempty"`
	// The name of the update package.
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// Specifies whether to confirm the update by using your mobile app.
	NeedConfirm *bool `json:"NeedConfirm,omitempty" xml:"NeedConfirm,omitempty"`
	// Specifies whether to automatically push update tasks from IoT Platform to devices.
	NeedPush *bool `json:"NeedPush,omitempty" xml:"NeedPush,omitempty"`
	// Specifies whether to overwrite the previous update task. Valid values:
	//
	// *   **1**: The previous update task is not overwritten. If a device already has an update task, the previous update task is implemented.
	// *   **2**: The previous update task is overwritten. Only the current update task is implemented.
	//
	// The update task that is in progress is not overwritten.
	OverwriteMode *int32 `json:"OverwriteMode,omitempty" xml:"OverwriteMode,omitempty"`
	// The ProductKey of the product to which the update package belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The number of automatic retries after a device fails to be updated.
	//
	// This parameter is returned if a retry policy is set when you create the update batch.
	RetryCount *int32 `json:"RetryCount,omitempty" xml:"RetryCount,omitempty"`
	// The automatic retry interval after a device fails to be updated. Unit: minutes.
	//
	// This parameter is returned if a retry policy is set when you create the update batch.
	RetryInterval *int32 `json:"RetryInterval,omitempty" xml:"RetryInterval,omitempty"`
	// The update policy of the update batch. Valid values:
	//
	// *   **DYNAMIC**: dynamic update. This value is returned if you call the [CreateOTADynamicUpgradeJob](~~147887~~) API operation to create an update batch.
	// *   **STATIC**: static update. This value is returned if you call the [CreateOTAStaticUpgradeJob](~~147496~~) API operation to create an update batch.
	SelectionType *string `json:"SelectionType,omitempty" xml:"SelectionType,omitempty"`
	// The list of firmware versions to be updated.
	SrcVersions *QueryOTAJobResponseBodyDataSrcVersions `json:"SrcVersions,omitempty" xml:"SrcVersions,omitempty" type:"Struct"`
	// The tags of the update batch.
	Tags *QueryOTAJobResponseBodyDataTags `json:"Tags,omitempty" xml:"Tags,omitempty" type:"Struct"`
	// The scope of the update batch. Valid values:
	//
	// - **ALL**: updates all devices.
	// - **SPECIFIC**: updates specified devices.
	// - **GRAY**: performs a phased update.
	//
	// >  The value ALL is returned if you call the [CreateOTADynamicUpgradeJob](/help/en/iot-platform/latest/av6dui) API operation to create an update batch.
	TargetSelection *string `json:"TargetSelection,omitempty" xml:"TargetSelection,omitempty"`
	// The timeout period of the device update. Unit: minutes.
	//
	// This parameter is returned if the timeout period is set when you create the update batch.
	TimeoutInMinutes *int32 `json:"TimeoutInMinutes,omitempty" xml:"TimeoutInMinutes,omitempty"`
	// The time when the update batch was created. The time is displayed in UTC.
	UtcCreate *string `json:"UtcCreate,omitempty" xml:"UtcCreate,omitempty"`
	// The end time of the update batch. The time is displayed in UTC.
	//
	// This parameter is returned only after the update batch is completed.
	UtcEndTime *string `json:"UtcEndTime,omitempty" xml:"UtcEndTime,omitempty"`
	// The time when the update batch was last modified. The time is displayed in UTC.
	UtcModified *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
	// The end time of the scheduled update batch. This parameter is returned only if the update batch is scheduled and the end time of the scheduled update batch is specified.
	UtcScheduleFinishTime *string `json:"UtcScheduleFinishTime,omitempty" xml:"UtcScheduleFinishTime,omitempty"`
	// The start time of the scheduled update batch. This parameter is returned only for scheduled update batches.
	UtcScheduleTime *string `json:"UtcScheduleTime,omitempty" xml:"UtcScheduleTime,omitempty"`
	// The start time of the update batch. The time is displayed in UTC.
	UtcStartTime *string `json:"UtcStartTime,omitempty" xml:"UtcStartTime,omitempty"`
}

func (s QueryOTAJobResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryOTAJobResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryOTAJobResponseBodyData) SetDestVersion(v string) *QueryOTAJobResponseBodyData {
	s.DestVersion = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetDownloadProtocol(v string) *QueryOTAJobResponseBodyData {
	s.DownloadProtocol = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetDynamicMode(v int32) *QueryOTAJobResponseBodyData {
	s.DynamicMode = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetFirmwareId(v string) *QueryOTAJobResponseBodyData {
	s.FirmwareId = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetGrayPercent(v string) *QueryOTAJobResponseBodyData {
	s.GrayPercent = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetGroupId(v string) *QueryOTAJobResponseBodyData {
	s.GroupId = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetGroupName(v string) *QueryOTAJobResponseBodyData {
	s.GroupName = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetJobDesc(v string) *QueryOTAJobResponseBodyData {
	s.JobDesc = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetJobId(v string) *QueryOTAJobResponseBodyData {
	s.JobId = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetJobStatus(v string) *QueryOTAJobResponseBodyData {
	s.JobStatus = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetJobType(v string) *QueryOTAJobResponseBodyData {
	s.JobType = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetMaximumPerMinute(v int32) *QueryOTAJobResponseBodyData {
	s.MaximumPerMinute = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetMultiModuleMode(v bool) *QueryOTAJobResponseBodyData {
	s.MultiModuleMode = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetName(v string) *QueryOTAJobResponseBodyData {
	s.Name = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetNeedConfirm(v bool) *QueryOTAJobResponseBodyData {
	s.NeedConfirm = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetNeedPush(v bool) *QueryOTAJobResponseBodyData {
	s.NeedPush = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetOverwriteMode(v int32) *QueryOTAJobResponseBodyData {
	s.OverwriteMode = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetProductKey(v string) *QueryOTAJobResponseBodyData {
	s.ProductKey = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetRetryCount(v int32) *QueryOTAJobResponseBodyData {
	s.RetryCount = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetRetryInterval(v int32) *QueryOTAJobResponseBodyData {
	s.RetryInterval = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetSelectionType(v string) *QueryOTAJobResponseBodyData {
	s.SelectionType = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetSrcVersions(v *QueryOTAJobResponseBodyDataSrcVersions) *QueryOTAJobResponseBodyData {
	s.SrcVersions = v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetTags(v *QueryOTAJobResponseBodyDataTags) *QueryOTAJobResponseBodyData {
	s.Tags = v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetTargetSelection(v string) *QueryOTAJobResponseBodyData {
	s.TargetSelection = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetTimeoutInMinutes(v int32) *QueryOTAJobResponseBodyData {
	s.TimeoutInMinutes = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetUtcCreate(v string) *QueryOTAJobResponseBodyData {
	s.UtcCreate = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetUtcEndTime(v string) *QueryOTAJobResponseBodyData {
	s.UtcEndTime = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetUtcModified(v string) *QueryOTAJobResponseBodyData {
	s.UtcModified = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetUtcScheduleFinishTime(v string) *QueryOTAJobResponseBodyData {
	s.UtcScheduleFinishTime = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetUtcScheduleTime(v string) *QueryOTAJobResponseBodyData {
	s.UtcScheduleTime = &v
	return s
}

func (s *QueryOTAJobResponseBodyData) SetUtcStartTime(v string) *QueryOTAJobResponseBodyData {
	s.UtcStartTime = &v
	return s
}

type QueryOTAJobResponseBodyDataSrcVersions struct {
	SrcVersion []*string `json:"SrcVersion,omitempty" xml:"SrcVersion,omitempty" type:"Repeated"`
}

func (s QueryOTAJobResponseBodyDataSrcVersions) String() string {
	return tea.Prettify(s)
}

func (s QueryOTAJobResponseBodyDataSrcVersions) GoString() string {
	return s.String()
}

func (s *QueryOTAJobResponseBodyDataSrcVersions) SetSrcVersion(v []*string) *QueryOTAJobResponseBodyDataSrcVersions {
	s.SrcVersion = v
	return s
}

type QueryOTAJobResponseBodyDataTags struct {
	OtaTagDTO []*QueryOTAJobResponseBodyDataTagsOtaTagDTO `json:"OtaTagDTO,omitempty" xml:"OtaTagDTO,omitempty" type:"Repeated"`
}

func (s QueryOTAJobResponseBodyDataTags) String() string {
	return tea.Prettify(s)
}

func (s QueryOTAJobResponseBodyDataTags) GoString() string {
	return s.String()
}

func (s *QueryOTAJobResponseBodyDataTags) SetOtaTagDTO(v []*QueryOTAJobResponseBodyDataTagsOtaTagDTO) *QueryOTAJobResponseBodyDataTags {
	s.OtaTagDTO = v
	return s
}

type QueryOTAJobResponseBodyDataTagsOtaTagDTO struct {
	// The key of each tag.
	Key *string `json:"Key,omitempty" xml:"Key,omitempty"`
	// The value of the tag.
	Value *string `json:"Value,omitempty" xml:"Value,omitempty"`
}

func (s QueryOTAJobResponseBodyDataTagsOtaTagDTO) String() string {
	return tea.Prettify(s)
}

func (s QueryOTAJobResponseBodyDataTagsOtaTagDTO) GoString() string {
	return s.String()
}

func (s *QueryOTAJobResponseBodyDataTagsOtaTagDTO) SetKey(v string) *QueryOTAJobResponseBodyDataTagsOtaTagDTO {
	s.Key = &v
	return s
}

func (s *QueryOTAJobResponseBodyDataTagsOtaTagDTO) SetValue(v string) *QueryOTAJobResponseBodyDataTagsOtaTagDTO {
	s.Value = &v
	return s
}

type QueryOTAJobResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryOTAJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryOTAJobResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryOTAJobResponse) GoString() string {
	return s.String()
}

func (s *QueryOTAJobResponse) SetHeaders(v map[string]*string) *QueryOTAJobResponse {
	s.Headers = v
	return s
}

func (s *QueryOTAJobResponse) SetStatusCode(v int32) *QueryOTAJobResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryOTAJobResponse) SetBody(v *QueryOTAJobResponseBody) *QueryOTAJobResponse {
	s.Body = v
	return s
}

type QueryPageByApplyIdRequest struct {
	// The ID of the application. You can view the application ID in the response of the [BatchRegisterDeviceWithApplyId](~~69514~~) or [BatchRegisterDevice](~~69473~~) operation.
	ApplyId *int64 `json:"ApplyId,omitempty" xml:"ApplyId,omitempty"`
	// The number of the page to return. Default value: 1.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Maximum value: 50. Default value: 10.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QueryPageByApplyIdRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryPageByApplyIdRequest) GoString() string {
	return s.String()
}

func (s *QueryPageByApplyIdRequest) SetApplyId(v int64) *QueryPageByApplyIdRequest {
	s.ApplyId = &v
	return s
}

func (s *QueryPageByApplyIdRequest) SetCurrentPage(v int32) *QueryPageByApplyIdRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryPageByApplyIdRequest) SetIotInstanceId(v string) *QueryPageByApplyIdRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryPageByApplyIdRequest) SetPageSize(v int32) *QueryPageByApplyIdRequest {
	s.PageSize = &v
	return s
}

type QueryPageByApplyIdResponseBody struct {
	// The registered device list information returned if the call succeeds. The **ApplyDeviceInfo** parameter includes the details of the registered devices.
	ApplyDeviceList *QueryPageByApplyIdResponseBodyApplyDeviceList `json:"ApplyDeviceList,omitempty" xml:"ApplyDeviceList,omitempty" type:"Struct"`
	// The error code returned if the call fails. For more information, see [Error codes](/help/en/iot-platform/latest/bce100).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The page number of the returned page.
	Page *int32 `json:"Page,omitempty" xml:"Page,omitempty"`
	// The total number of pages.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// The total number of devices.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryPageByApplyIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryPageByApplyIdResponseBody) GoString() string {
	return s.String()
}

func (s *QueryPageByApplyIdResponseBody) SetApplyDeviceList(v *QueryPageByApplyIdResponseBodyApplyDeviceList) *QueryPageByApplyIdResponseBody {
	s.ApplyDeviceList = v
	return s
}

func (s *QueryPageByApplyIdResponseBody) SetCode(v string) *QueryPageByApplyIdResponseBody {
	s.Code = &v
	return s
}

func (s *QueryPageByApplyIdResponseBody) SetErrorMessage(v string) *QueryPageByApplyIdResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryPageByApplyIdResponseBody) SetPage(v int32) *QueryPageByApplyIdResponseBody {
	s.Page = &v
	return s
}

func (s *QueryPageByApplyIdResponseBody) SetPageCount(v int32) *QueryPageByApplyIdResponseBody {
	s.PageCount = &v
	return s
}

func (s *QueryPageByApplyIdResponseBody) SetPageSize(v int32) *QueryPageByApplyIdResponseBody {
	s.PageSize = &v
	return s
}

func (s *QueryPageByApplyIdResponseBody) SetRequestId(v string) *QueryPageByApplyIdResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryPageByApplyIdResponseBody) SetSuccess(v bool) *QueryPageByApplyIdResponseBody {
	s.Success = &v
	return s
}

func (s *QueryPageByApplyIdResponseBody) SetTotal(v int32) *QueryPageByApplyIdResponseBody {
	s.Total = &v
	return s
}

type QueryPageByApplyIdResponseBodyApplyDeviceList struct {
	ApplyDeviceInfo []*QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo `json:"ApplyDeviceInfo,omitempty" xml:"ApplyDeviceInfo,omitempty" type:"Repeated"`
}

func (s QueryPageByApplyIdResponseBodyApplyDeviceList) String() string {
	return tea.Prettify(s)
}

func (s QueryPageByApplyIdResponseBodyApplyDeviceList) GoString() string {
	return s.String()
}

func (s *QueryPageByApplyIdResponseBodyApplyDeviceList) SetApplyDeviceInfo(v []*QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo) *QueryPageByApplyIdResponseBodyApplyDeviceList {
	s.ApplyDeviceInfo = v
	return s
}

type QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo struct {
	// The ID of the device (expired).
	//
	// >  This parameter is no longer used. Do not use this parameter to identify a device. You can use the **IotId** parameter or a combination of the **ProductKey** and **DeviceName** parameters to identify a device.
	DeviceId *string `json:"DeviceId,omitempty" xml:"DeviceId,omitempty"`
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The DeviceSecret of the device.
	DeviceSecret *string `json:"DeviceSecret,omitempty" xml:"DeviceSecret,omitempty"`
	// The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
}

func (s QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo) GoString() string {
	return s.String()
}

func (s *QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo) SetDeviceId(v string) *QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo {
	s.DeviceId = &v
	return s
}

func (s *QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo) SetDeviceName(v string) *QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo {
	s.DeviceName = &v
	return s
}

func (s *QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo) SetDeviceSecret(v string) *QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo {
	s.DeviceSecret = &v
	return s
}

func (s *QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo) SetIotId(v string) *QueryPageByApplyIdResponseBodyApplyDeviceListApplyDeviceInfo {
	s.IotId = &v
	return s
}

type QueryPageByApplyIdResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryPageByApplyIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryPageByApplyIdResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryPageByApplyIdResponse) GoString() string {
	return s.String()
}

func (s *QueryPageByApplyIdResponse) SetHeaders(v map[string]*string) *QueryPageByApplyIdResponse {
	s.Headers = v
	return s
}

func (s *QueryPageByApplyIdResponse) SetStatusCode(v int32) *QueryPageByApplyIdResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryPageByApplyIdResponse) SetBody(v *QueryPageByApplyIdResponseBody) *QueryPageByApplyIdResponse {
	s.Body = v
	return s
}

type QueryProductRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// > *   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >  *   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product that you want to query. A ProductKey is a GUID that is issued by IoT Platform to a product. You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryProductRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryProductRequest) GoString() string {
	return s.String()
}

func (s *QueryProductRequest) SetIotInstanceId(v string) *QueryProductRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryProductRequest) SetProductKey(v string) *QueryProductRequest {
	s.ProductKey = &v
	return s
}

type QueryProductResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The product information returned if the call is successful.
	Data *QueryProductResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryProductResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryProductResponseBody) GoString() string {
	return s.String()
}

func (s *QueryProductResponseBody) SetCode(v string) *QueryProductResponseBody {
	s.Code = &v
	return s
}

func (s *QueryProductResponseBody) SetData(v *QueryProductResponseBodyData) *QueryProductResponseBody {
	s.Data = v
	return s
}

func (s *QueryProductResponseBody) SetErrorMessage(v string) *QueryProductResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryProductResponseBody) SetRequestId(v string) *QueryProductResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryProductResponseBody) SetSuccess(v bool) *QueryProductResponseBody {
	s.Success = &v
	return s
}

type QueryProductResponseBodyData struct {
	// The type of the product. This parameter indicates whether a Thing Specification Language (TSL) model was used.
	//
	// Valid values:
	//
	// *   **iothub_senior**: A TSL model was used.
	// *   **iothub**: No TSL model was used.
	AliyunCommodityCode *string `json:"AliyunCommodityCode,omitempty" xml:"AliyunCommodityCode,omitempty"`
	// The authentication method that was used to connect the devices of the product to IoT Platform. Valid values:
	//
	// *   **secret**: DeviceSecrets were used to authenticate the devices.
	// *   **id2**: IoT Internet Device ID was used to authenticate the devices.
	// *   **x509**: X.509 certificates were used to authenticate the devices.
	AuthType *string `json:"AuthType,omitempty" xml:"AuthType,omitempty"`
	// The identifier of the category to which the product belongs.
	//
	// This parameter is returned if the product uses the TSL model of a standard category that is pre-defined by IoT Platform.
	//
	// This parameter is available if the AliyunCommodityCode parameter is set to iothub_senior.
	CategoryKey *string `json:"CategoryKey,omitempty" xml:"CategoryKey,omitempty"`
	// The name of the product category.
	//
	// This parameter is returned if the product uses the TSL model of a standard category that is pre-defined by IoT Platform.
	//
	// This parameter is available if the AliyunCommodityCode parameter is set to iothub_senior.
	CategoryName *string `json:"CategoryName,omitempty" xml:"CategoryName,omitempty"`
	// The data format that was used by a communication protocol to transmit data between the devices and IoT Platform. This parameter is available if the AliyunCommodityCode parameter is set to iothub_senior.
	//
	// Valid values:
	//
	// *   **0**: custom. A custom serial data format was used. In this case, the device can submit raw data, such as binary data streams. IoT Platform converts the raw data into standard Alink JSON data by using a specified data parsing script.
	// *   **1**: Alink JSON. Alink JSON data is transmitted between the devices and IoT Platform. Alink is a data exchange protocol that is pre-defined by IoT Platform.
	DataFormat *int32 `json:"DataFormat,omitempty" xml:"DataFormat,omitempty"`
	// The description of the product.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The number of devices under the product.
	DeviceCount *int32 `json:"DeviceCount,omitempty" xml:"DeviceCount,omitempty"`
	// The time when the product was created. The value is a timestamp in milliseconds.
	GmtCreate *int64 `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// Indicates whether IoT Internet Device ID was enabled. Valid values:
	//
	// *   **true**: IoT Internet Device ID was enabled.
	// *   **false**: IoT Internet Device ID was disabled.
	Id2 *bool `json:"Id2,omitempty" xml:"Id2,omitempty"`
	// The network connection method. Valid values:
	//
	// *   **3**: Wi-Fi.
	// *   **6**: cellular network (2G/3G/4G/5G).
	// *   **7**: Ethernet.
	// *   **8**: others.
	NetType *int32 `json:"NetType,omitempty" xml:"NetType,omitempty"`
	// The node type of the product. This parameter is available if the AliyunCommodityCode parameter is set to iothub_senior. Valid values:
	//
	// *   **0**: device. Sub-devices cannot be attached to a device. A device can connect to IoT Platform directly or as a sub-device of a gateway.
	// *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain the topological relationships with sub-devices, and synchronize the topological relationships to IoT Platform.
	NodeType *int32 `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// Indicates whether the operation was called by the owner of the product.
	//
	// *   **true**: yes.
	// *   **false**: no.
	Owner *bool `json:"Owner,omitempty" xml:"Owner,omitempty"`
	// The ProductKey of the product. When you create a product, a ProductKey is the globally unique identifier (GUID) that is issued by IoT Platform to the product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The name of the product.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
	// The ProductSecret of the product.
	ProductSecret *string `json:"ProductSecret,omitempty" xml:"ProductSecret,omitempty"`
	// The status of the product.
	//
	// *   **DEVELOPMENT_STATUS**: The product is being developed.
	// *   **RELEASE_STATUS**: The product was published.
	ProductStatus *string `json:"ProductStatus,omitempty" xml:"ProductStatus,omitempty"`
	// The type of the protocol that was used by the sub-devices to connect with a gateway.
	//
	// This parameter is available if the AliyunCommodityCode parameter is set to iothub_senior and the NodeType parameter is set to 1. Valid values:
	//
	// *   **modbus**: Modbus.
	// *   **opc-ua**: OPC UA.
	// *   **customize**: custom protocol.
	// *   **ble**: BLE.
	// *   **zigbee**: ZigBee.
	ProtocolType *string `json:"ProtocolType,omitempty" xml:"ProtocolType,omitempty"`
	// The level of the data verification. Valid values:
	//
	// *   **2**: no verification. IoT Platform does not verify the data. All data is forwarded.
	//
	//     In the IoT Platform console, the data is not displayed on the TSL Data tab of the Device Details page.
	//
	// *   **1**: low-level verification. IoT Platform verifies only the identifier and dataType fields of the data. All data is forwarded.
	//
	// *   **0**: high-level verification. IoT Platform verifies all fields of the data. Only the data that passes the verification is forwarded.
	//
	//     The products that were created before October 14, 2020 support only high-level verification.
	//
	// The products that were created on October 14, 2020 or later support low-level verification or no verification.
	//
	// After verification, you can view the data that passes or fails the verification.
	//
	// *   In the IoT Platform console, the data is displayed on the **TSL Data** tab of the **Device Details** page. The data that fails the verification is not displayed.
	// *   You can view the data that fails the verification in the **checkFailedData** parameter of the forwarded data. For more information, see [Data formats](~~73736~~).
	ValidateType *int32 `json:"ValidateType,omitempty" xml:"ValidateType,omitempty"`
}

func (s QueryProductResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryProductResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryProductResponseBodyData) SetAliyunCommodityCode(v string) *QueryProductResponseBodyData {
	s.AliyunCommodityCode = &v
	return s
}

func (s *QueryProductResponseBodyData) SetAuthType(v string) *QueryProductResponseBodyData {
	s.AuthType = &v
	return s
}

func (s *QueryProductResponseBodyData) SetCategoryKey(v string) *QueryProductResponseBodyData {
	s.CategoryKey = &v
	return s
}

func (s *QueryProductResponseBodyData) SetCategoryName(v string) *QueryProductResponseBodyData {
	s.CategoryName = &v
	return s
}

func (s *QueryProductResponseBodyData) SetDataFormat(v int32) *QueryProductResponseBodyData {
	s.DataFormat = &v
	return s
}

func (s *QueryProductResponseBodyData) SetDescription(v string) *QueryProductResponseBodyData {
	s.Description = &v
	return s
}

func (s *QueryProductResponseBodyData) SetDeviceCount(v int32) *QueryProductResponseBodyData {
	s.DeviceCount = &v
	return s
}

func (s *QueryProductResponseBodyData) SetGmtCreate(v int64) *QueryProductResponseBodyData {
	s.GmtCreate = &v
	return s
}

func (s *QueryProductResponseBodyData) SetId2(v bool) *QueryProductResponseBodyData {
	s.Id2 = &v
	return s
}

func (s *QueryProductResponseBodyData) SetNetType(v int32) *QueryProductResponseBodyData {
	s.NetType = &v
	return s
}

func (s *QueryProductResponseBodyData) SetNodeType(v int32) *QueryProductResponseBodyData {
	s.NodeType = &v
	return s
}

func (s *QueryProductResponseBodyData) SetOwner(v bool) *QueryProductResponseBodyData {
	s.Owner = &v
	return s
}

func (s *QueryProductResponseBodyData) SetProductKey(v string) *QueryProductResponseBodyData {
	s.ProductKey = &v
	return s
}

func (s *QueryProductResponseBodyData) SetProductName(v string) *QueryProductResponseBodyData {
	s.ProductName = &v
	return s
}

func (s *QueryProductResponseBodyData) SetProductSecret(v string) *QueryProductResponseBodyData {
	s.ProductSecret = &v
	return s
}

func (s *QueryProductResponseBodyData) SetProductStatus(v string) *QueryProductResponseBodyData {
	s.ProductStatus = &v
	return s
}

func (s *QueryProductResponseBodyData) SetProtocolType(v string) *QueryProductResponseBodyData {
	s.ProtocolType = &v
	return s
}

func (s *QueryProductResponseBodyData) SetValidateType(v int32) *QueryProductResponseBodyData {
	s.ValidateType = &v
	return s
}

type QueryProductResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryProductResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryProductResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryProductResponse) GoString() string {
	return s.String()
}

func (s *QueryProductResponse) SetHeaders(v map[string]*string) *QueryProductResponse {
	s.Headers = v
	return s
}

func (s *QueryProductResponse) SetStatusCode(v int32) *QueryProductResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryProductResponse) SetBody(v *QueryProductResponseBody) *QueryProductResponse {
	s.Body = v
	return s
}

type QueryProductCertInfoRequest struct {
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****
	//
	// >  If your instance has an ID, you must specify the ID for this parameter. If you do not specify the instance ID, the call fails. If no Overview page or ID is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryProductCertInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryProductCertInfoRequest) GoString() string {
	return s.String()
}

func (s *QueryProductCertInfoRequest) SetIotInstanceId(v string) *QueryProductCertInfoRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryProductCertInfoRequest) SetProductKey(v string) *QueryProductCertInfoRequest {
	s.ProductKey = &v
	return s
}

type QueryProductCertInfoResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The returned certificate information that includes the value of the **IssueModel** parameter.
	ProductCertInfo *QueryProductCertInfoResponseBodyProductCertInfo `json:"ProductCertInfo,omitempty" xml:"ProductCertInfo,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryProductCertInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryProductCertInfoResponseBody) GoString() string {
	return s.String()
}

func (s *QueryProductCertInfoResponseBody) SetCode(v string) *QueryProductCertInfoResponseBody {
	s.Code = &v
	return s
}

func (s *QueryProductCertInfoResponseBody) SetErrorMessage(v string) *QueryProductCertInfoResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryProductCertInfoResponseBody) SetProductCertInfo(v *QueryProductCertInfoResponseBodyProductCertInfo) *QueryProductCertInfoResponseBody {
	s.ProductCertInfo = v
	return s
}

func (s *QueryProductCertInfoResponseBody) SetRequestId(v string) *QueryProductCertInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryProductCertInfoResponseBody) SetSuccess(v bool) *QueryProductCertInfoResponseBody {
	s.Success = &v
	return s
}

type QueryProductCertInfoResponseBodyProductCertInfo struct {
	// The source from which the X.509 certificate is issued.
	//
	// *   **1**: The X.509 certificate is issued by IoT Platform.
	// *   **3**: The X.509 certificate is issued by a third-party platform.
	IssueModel *int32 `json:"IssueModel,omitempty" xml:"IssueModel,omitempty"`
}

func (s QueryProductCertInfoResponseBodyProductCertInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryProductCertInfoResponseBodyProductCertInfo) GoString() string {
	return s.String()
}

func (s *QueryProductCertInfoResponseBodyProductCertInfo) SetIssueModel(v int32) *QueryProductCertInfoResponseBodyProductCertInfo {
	s.IssueModel = &v
	return s
}

type QueryProductCertInfoResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryProductCertInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryProductCertInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryProductCertInfoResponse) GoString() string {
	return s.String()
}

func (s *QueryProductCertInfoResponse) SetHeaders(v map[string]*string) *QueryProductCertInfoResponse {
	s.Headers = v
	return s
}

func (s *QueryProductCertInfoResponse) SetStatusCode(v int32) *QueryProductCertInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryProductCertInfoResponse) SetBody(v *QueryProductCertInfoResponseBody) *QueryProductCertInfoResponse {
	s.Body = v
	return s
}

type QueryProductListRequest struct {
	// The type of the product. Valid values:
	//
	// *   **iothub_senior**: A Thing Specification Language (TSL) model is used for the product.
	// *   **iothub**: No TSL model is used for the product.
	//
	// >  If you do not configure this parameter, all products are returned.
	AliyunCommodityCode *string `json:"AliyunCommodityCode,omitempty" xml:"AliyunCommodityCode,omitempty"`
	// The number of the page to return.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	//
	// > *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// > *   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The number of entries to return on each page. Valid values: 1 to 200.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the resource group to which the product belongs. You can log on to the [Resource Management](https://resourcemanager.console.aliyun.com/resource-groups) console to view the details of the resource group.
	//
	// > You can specify a value for this parameter only if you have activated Resource Management.
	//
	// If you leave this parameter empty, the information about all products in the current account is queried.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s QueryProductListRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryProductListRequest) GoString() string {
	return s.String()
}

func (s *QueryProductListRequest) SetAliyunCommodityCode(v string) *QueryProductListRequest {
	s.AliyunCommodityCode = &v
	return s
}

func (s *QueryProductListRequest) SetCurrentPage(v int32) *QueryProductListRequest {
	s.CurrentPage = &v
	return s
}

func (s *QueryProductListRequest) SetIotInstanceId(v string) *QueryProductListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryProductListRequest) SetPageSize(v int32) *QueryProductListRequest {
	s.PageSize = &v
	return s
}

func (s *QueryProductListRequest) SetResourceGroupId(v string) *QueryProductListRequest {
	s.ResourceGroupId = &v
	return s
}

type QueryProductListResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The product information returned if the call is successful. For more information, see the following parameters.
	Data *QueryProductListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryProductListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryProductListResponseBody) GoString() string {
	return s.String()
}

func (s *QueryProductListResponseBody) SetCode(v string) *QueryProductListResponseBody {
	s.Code = &v
	return s
}

func (s *QueryProductListResponseBody) SetData(v *QueryProductListResponseBodyData) *QueryProductListResponseBody {
	s.Data = v
	return s
}

func (s *QueryProductListResponseBody) SetErrorMessage(v string) *QueryProductListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryProductListResponseBody) SetRequestId(v string) *QueryProductListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryProductListResponseBody) SetSuccess(v bool) *QueryProductListResponseBody {
	s.Success = &v
	return s
}

type QueryProductListResponseBodyData struct {
	// The page number of the returned page.
	CurrentPage *int32 `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	// The details of the products.
	//
	// >  The returned product information is sorted in reverse-chronological order based on the time when the products were created.
	List *QueryProductListResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	// The total number of returned pages.
	PageCount *int32 `json:"PageCount,omitempty" xml:"PageCount,omitempty"`
	// The number of entries returned per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of products.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryProductListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryProductListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryProductListResponseBodyData) SetCurrentPage(v int32) *QueryProductListResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *QueryProductListResponseBodyData) SetList(v *QueryProductListResponseBodyDataList) *QueryProductListResponseBodyData {
	s.List = v
	return s
}

func (s *QueryProductListResponseBodyData) SetPageCount(v int32) *QueryProductListResponseBodyData {
	s.PageCount = &v
	return s
}

func (s *QueryProductListResponseBodyData) SetPageSize(v int32) *QueryProductListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryProductListResponseBodyData) SetTotal(v int32) *QueryProductListResponseBodyData {
	s.Total = &v
	return s
}

type QueryProductListResponseBodyDataList struct {
	ProductInfo []*QueryProductListResponseBodyDataListProductInfo `json:"ProductInfo,omitempty" xml:"ProductInfo,omitempty" type:"Repeated"`
}

func (s QueryProductListResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryProductListResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryProductListResponseBodyDataList) SetProductInfo(v []*QueryProductListResponseBodyDataListProductInfo) *QueryProductListResponseBodyDataList {
	s.ProductInfo = v
	return s
}

type QueryProductListResponseBodyDataListProductInfo struct {
	// The authentication method that was used to connect the devices of the product to IoT Platform. Valid values:
	//
	// *   **secret**: DeviceSecrets were used to authenticate the devices.
	// *   **id2**: IoT Internet Device ID was used to authenticate the devices.
	// *   **x509**: X.509 certificates were used to authenticate the devices.
	AuthType *string `json:"AuthType,omitempty" xml:"AuthType,omitempty"`
	// The data format that was used by a communication protocol to transmit data between the devices and IoT Platform. This parameter is available only if the AliyunCommodityCode parameter is set to iothub_senior.
	//
	// Valid values:
	//
	// *   **0**: custom. A custom serial data format was used. In this case, the device can submit raw data, such as binary data streams. IoT Platform converts the raw data into standard Alink JSON data by using a specified data parsing script.
	// *   **1**: Alink JSON. Alink JSON data is transmitted between the devices and IoT Platform. Alink is a data exchange protocol that is pre-defined by IoT Platform.
	DataFormat *int32 `json:"DataFormat,omitempty" xml:"DataFormat,omitempty"`
	// The description of the product.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The number of devices in the product.
	DeviceCount *int32 `json:"DeviceCount,omitempty" xml:"DeviceCount,omitempty"`
	// The time when the product was created. The value is a timestamp in milliseconds.
	GmtCreate *int64 `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	// The node type of the product. This parameter is available only if the AliyunCommodityCode parameter is set to iothub_senior. Valid values:
	//
	// *   **0**: device. Sub-devices cannot be attached to a device. A device can be directly connected to IoT Platform or connected to IoT Platform as a sub-device of a gateway.
	// *   **1**: gateway. Sub-devices can be attached to a gateway. A gateway can manage sub-devices, maintain topological relationships with sub-devices, and synchronize topological relationships to IoT Platform.
	NodeType *int32 `json:"NodeType,omitempty" xml:"NodeType,omitempty"`
	// The ProductKey of the product. When you create a product, a ProductKey is a globally unique identifier (GUID) that is issued by IoT Platform to the product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The name of the service.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
}

func (s QueryProductListResponseBodyDataListProductInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryProductListResponseBodyDataListProductInfo) GoString() string {
	return s.String()
}

func (s *QueryProductListResponseBodyDataListProductInfo) SetAuthType(v string) *QueryProductListResponseBodyDataListProductInfo {
	s.AuthType = &v
	return s
}

func (s *QueryProductListResponseBodyDataListProductInfo) SetDataFormat(v int32) *QueryProductListResponseBodyDataListProductInfo {
	s.DataFormat = &v
	return s
}

func (s *QueryProductListResponseBodyDataListProductInfo) SetDescription(v string) *QueryProductListResponseBodyDataListProductInfo {
	s.Description = &v
	return s
}

func (s *QueryProductListResponseBodyDataListProductInfo) SetDeviceCount(v int32) *QueryProductListResponseBodyDataListProductInfo {
	s.DeviceCount = &v
	return s
}

func (s *QueryProductListResponseBodyDataListProductInfo) SetGmtCreate(v int64) *QueryProductListResponseBodyDataListProductInfo {
	s.GmtCreate = &v
	return s
}

func (s *QueryProductListResponseBodyDataListProductInfo) SetNodeType(v int32) *QueryProductListResponseBodyDataListProductInfo {
	s.NodeType = &v
	return s
}

func (s *QueryProductListResponseBodyDataListProductInfo) SetProductKey(v string) *QueryProductListResponseBodyDataListProductInfo {
	s.ProductKey = &v
	return s
}

func (s *QueryProductListResponseBodyDataListProductInfo) SetProductName(v string) *QueryProductListResponseBodyDataListProductInfo {
	s.ProductName = &v
	return s
}

type QueryProductListResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryProductListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryProductListResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryProductListResponse) GoString() string {
	return s.String()
}

func (s *QueryProductListResponse) SetHeaders(v map[string]*string) *QueryProductListResponse {
	s.Headers = v
	return s
}

func (s *QueryProductListResponse) SetStatusCode(v int32) *QueryProductListResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryProductListResponse) SetBody(v *QueryProductListResponseBody) *QueryProductListResponse {
	s.Body = v
	return s
}

type QueryProductTopicRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryProductTopicRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryProductTopicRequest) GoString() string {
	return s.String()
}

func (s *QueryProductTopicRequest) SetIotInstanceId(v string) *QueryProductTopicRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryProductTopicRequest) SetProductKey(v string) *QueryProductTopicRequest {
	s.ProductKey = &v
	return s
}

type QueryProductTopicResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The list of topic categories returned if the call is successful. For more information, see **ProductTopicInfo**.
	Data *QueryProductTopicResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryProductTopicResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryProductTopicResponseBody) GoString() string {
	return s.String()
}

func (s *QueryProductTopicResponseBody) SetCode(v string) *QueryProductTopicResponseBody {
	s.Code = &v
	return s
}

func (s *QueryProductTopicResponseBody) SetData(v *QueryProductTopicResponseBodyData) *QueryProductTopicResponseBody {
	s.Data = v
	return s
}

func (s *QueryProductTopicResponseBody) SetErrorMessage(v string) *QueryProductTopicResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryProductTopicResponseBody) SetRequestId(v string) *QueryProductTopicResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryProductTopicResponseBody) SetSuccess(v bool) *QueryProductTopicResponseBody {
	s.Success = &v
	return s
}

type QueryProductTopicResponseBodyData struct {
	ProductTopicInfo []*QueryProductTopicResponseBodyDataProductTopicInfo `json:"ProductTopicInfo,omitempty" xml:"ProductTopicInfo,omitempty" type:"Repeated"`
}

func (s QueryProductTopicResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryProductTopicResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryProductTopicResponseBodyData) SetProductTopicInfo(v []*QueryProductTopicResponseBodyDataProductTopicInfo) *QueryProductTopicResponseBodyData {
	s.ProductTopicInfo = v
	return s
}

type QueryProductTopicResponseBodyDataProductTopicInfo struct {
	Codec *string `json:"Codec,omitempty" xml:"Codec,omitempty"`
	// The description of the topic category.
	Desc                 *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	EnableProxySubscribe *bool   `json:"EnableProxySubscribe,omitempty" xml:"EnableProxySubscribe,omitempty"`
	// The ID of the topic category.
	Id *string `json:"Id,omitempty" xml:"Id,omitempty"`
	// The operation that devices can perform on the topic category. Valid values:
	//
	// *   **0**: Publish.
	// *   **1**: Subscribe.
	// *   **2**: Publish and Subscribe.
	Operation *string `json:"Operation,omitempty" xml:"Operation,omitempty"`
	// The ProductKey of the product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The topic category that does not include the \_productKey\_ and \_deviceName\_ levels.
	TopicShortName *string `json:"TopicShortName,omitempty" xml:"TopicShortName,omitempty"`
}

func (s QueryProductTopicResponseBodyDataProductTopicInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryProductTopicResponseBodyDataProductTopicInfo) GoString() string {
	return s.String()
}

func (s *QueryProductTopicResponseBodyDataProductTopicInfo) SetCodec(v string) *QueryProductTopicResponseBodyDataProductTopicInfo {
	s.Codec = &v
	return s
}

func (s *QueryProductTopicResponseBodyDataProductTopicInfo) SetDesc(v string) *QueryProductTopicResponseBodyDataProductTopicInfo {
	s.Desc = &v
	return s
}

func (s *QueryProductTopicResponseBodyDataProductTopicInfo) SetEnableProxySubscribe(v bool) *QueryProductTopicResponseBodyDataProductTopicInfo {
	s.EnableProxySubscribe = &v
	return s
}

func (s *QueryProductTopicResponseBodyDataProductTopicInfo) SetId(v string) *QueryProductTopicResponseBodyDataProductTopicInfo {
	s.Id = &v
	return s
}

func (s *QueryProductTopicResponseBodyDataProductTopicInfo) SetOperation(v string) *QueryProductTopicResponseBodyDataProductTopicInfo {
	s.Operation = &v
	return s
}

func (s *QueryProductTopicResponseBodyDataProductTopicInfo) SetProductKey(v string) *QueryProductTopicResponseBodyDataProductTopicInfo {
	s.ProductKey = &v
	return s
}

func (s *QueryProductTopicResponseBodyDataProductTopicInfo) SetTopicShortName(v string) *QueryProductTopicResponseBodyDataProductTopicInfo {
	s.TopicShortName = &v
	return s
}

type QueryProductTopicResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryProductTopicResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryProductTopicResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryProductTopicResponse) GoString() string {
	return s.String()
}

func (s *QueryProductTopicResponse) SetHeaders(v map[string]*string) *QueryProductTopicResponse {
	s.Headers = v
	return s
}

func (s *QueryProductTopicResponse) SetStatusCode(v int32) *QueryProductTopicResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryProductTopicResponse) SetBody(v *QueryProductTopicResponseBody) *QueryProductTopicResponse {
	s.Body = v
	return s
}

type QueryProjectShareDeviceListRequest struct {
	// The keyword in the DeviceName of the devices that you want to query. Fuzzy match is supported.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
	//
	// For more information, see the [Overview](~~356505~~) topic of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The page number. Valid values: 1 to 10000.
	PageId *int32 `json:"PageId,omitempty" xml:"PageId,omitempty"`
	// The number of entries per page. Valid values: 1 to 50. Default value: 20.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The **ProductKey** of the product to which the devices belong.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryProjectShareDeviceListRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryProjectShareDeviceListRequest) GoString() string {
	return s.String()
}

func (s *QueryProjectShareDeviceListRequest) SetDeviceName(v string) *QueryProjectShareDeviceListRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryProjectShareDeviceListRequest) SetIotInstanceId(v string) *QueryProjectShareDeviceListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryProjectShareDeviceListRequest) SetPageId(v int32) *QueryProjectShareDeviceListRequest {
	s.PageId = &v
	return s
}

func (s *QueryProjectShareDeviceListRequest) SetPageSize(v int32) *QueryProjectShareDeviceListRequest {
	s.PageSize = &v
	return s
}

func (s *QueryProjectShareDeviceListRequest) SetProductKey(v string) *QueryProjectShareDeviceListRequest {
	s.ProductKey = &v
	return s
}

type QueryProjectShareDeviceListResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the request.
	Data *QueryProjectShareDeviceListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryProjectShareDeviceListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryProjectShareDeviceListResponseBody) GoString() string {
	return s.String()
}

func (s *QueryProjectShareDeviceListResponseBody) SetCode(v string) *QueryProjectShareDeviceListResponseBody {
	s.Code = &v
	return s
}

func (s *QueryProjectShareDeviceListResponseBody) SetData(v *QueryProjectShareDeviceListResponseBodyData) *QueryProjectShareDeviceListResponseBody {
	s.Data = v
	return s
}

func (s *QueryProjectShareDeviceListResponseBody) SetErrorMessage(v string) *QueryProjectShareDeviceListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryProjectShareDeviceListResponseBody) SetRequestId(v string) *QueryProjectShareDeviceListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryProjectShareDeviceListResponseBody) SetSuccess(v bool) *QueryProjectShareDeviceListResponseBody {
	s.Success = &v
	return s
}

type QueryProjectShareDeviceListResponseBodyData struct {
	// The information about devices that you queried.
	DeviceList *QueryProjectShareDeviceListResponseBodyDataDeviceList `json:"DeviceList,omitempty" xml:"DeviceList,omitempty" type:"Struct"`
	// The page number.
	PageId *int32 `json:"PageId,omitempty" xml:"PageId,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryProjectShareDeviceListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryProjectShareDeviceListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryProjectShareDeviceListResponseBodyData) SetDeviceList(v *QueryProjectShareDeviceListResponseBodyDataDeviceList) *QueryProjectShareDeviceListResponseBodyData {
	s.DeviceList = v
	return s
}

func (s *QueryProjectShareDeviceListResponseBodyData) SetPageId(v int32) *QueryProjectShareDeviceListResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QueryProjectShareDeviceListResponseBodyData) SetPageSize(v int32) *QueryProjectShareDeviceListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryProjectShareDeviceListResponseBodyData) SetTotal(v int32) *QueryProjectShareDeviceListResponseBodyData {
	s.Total = &v
	return s
}

type QueryProjectShareDeviceListResponseBodyDataDeviceList struct {
	Items []*QueryProjectShareDeviceListResponseBodyDataDeviceListItems `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s QueryProjectShareDeviceListResponseBodyDataDeviceList) String() string {
	return tea.Prettify(s)
}

func (s QueryProjectShareDeviceListResponseBodyDataDeviceList) GoString() string {
	return s.String()
}

func (s *QueryProjectShareDeviceListResponseBodyDataDeviceList) SetItems(v []*QueryProjectShareDeviceListResponseBodyDataDeviceListItems) *QueryProjectShareDeviceListResponseBodyDataDeviceList {
	s.Items = v
	return s
}

type QueryProjectShareDeviceListResponseBodyDataDeviceListItems struct {
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// Indicates whether the project was shared to the device.
	//
	// *   **1**: The project was shared.
	// *   **0**: The project failed to be shared.
	Sharable *int64 `json:"Sharable,omitempty" xml:"Sharable,omitempty"`
}

func (s QueryProjectShareDeviceListResponseBodyDataDeviceListItems) String() string {
	return tea.Prettify(s)
}

func (s QueryProjectShareDeviceListResponseBodyDataDeviceListItems) GoString() string {
	return s.String()
}

func (s *QueryProjectShareDeviceListResponseBodyDataDeviceListItems) SetDeviceName(v string) *QueryProjectShareDeviceListResponseBodyDataDeviceListItems {
	s.DeviceName = &v
	return s
}

func (s *QueryProjectShareDeviceListResponseBodyDataDeviceListItems) SetIotId(v string) *QueryProjectShareDeviceListResponseBodyDataDeviceListItems {
	s.IotId = &v
	return s
}

func (s *QueryProjectShareDeviceListResponseBodyDataDeviceListItems) SetProductKey(v string) *QueryProjectShareDeviceListResponseBodyDataDeviceListItems {
	s.ProductKey = &v
	return s
}

func (s *QueryProjectShareDeviceListResponseBodyDataDeviceListItems) SetSharable(v int64) *QueryProjectShareDeviceListResponseBodyDataDeviceListItems {
	s.Sharable = &v
	return s
}

type QueryProjectShareDeviceListResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryProjectShareDeviceListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryProjectShareDeviceListResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryProjectShareDeviceListResponse) GoString() string {
	return s.String()
}

func (s *QueryProjectShareDeviceListResponse) SetHeaders(v map[string]*string) *QueryProjectShareDeviceListResponse {
	s.Headers = v
	return s
}

func (s *QueryProjectShareDeviceListResponse) SetStatusCode(v int32) *QueryProjectShareDeviceListResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryProjectShareDeviceListResponse) SetBody(v *QueryProjectShareDeviceListResponseBody) *QueryProjectShareDeviceListResponse {
	s.Body = v
	return s
}

type QuerySceneRuleRequest struct {
	CurrentPage   *int32  `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RuleName      *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
}

func (s QuerySceneRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySceneRuleRequest) GoString() string {
	return s.String()
}

func (s *QuerySceneRuleRequest) SetCurrentPage(v int32) *QuerySceneRuleRequest {
	s.CurrentPage = &v
	return s
}

func (s *QuerySceneRuleRequest) SetIotInstanceId(v string) *QuerySceneRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySceneRuleRequest) SetPageSize(v int32) *QuerySceneRuleRequest {
	s.PageSize = &v
	return s
}

func (s *QuerySceneRuleRequest) SetRuleName(v string) *QuerySceneRuleRequest {
	s.RuleName = &v
	return s
}

type QuerySceneRuleResponseBody struct {
	Code         *string                         `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySceneRuleResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                         `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                         `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                           `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySceneRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySceneRuleResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySceneRuleResponseBody) SetCode(v string) *QuerySceneRuleResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySceneRuleResponseBody) SetData(v *QuerySceneRuleResponseBodyData) *QuerySceneRuleResponseBody {
	s.Data = v
	return s
}

func (s *QuerySceneRuleResponseBody) SetErrorMessage(v string) *QuerySceneRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySceneRuleResponseBody) SetRequestId(v string) *QuerySceneRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySceneRuleResponseBody) SetSuccess(v bool) *QuerySceneRuleResponseBody {
	s.Success = &v
	return s
}

type QuerySceneRuleResponseBodyData struct {
	CurrentPage *int32                                    `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	PageSize    *int32                                    `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RuleList    []*QuerySceneRuleResponseBodyDataRuleList `json:"RuleList,omitempty" xml:"RuleList,omitempty" type:"Repeated"`
	Total       *int32                                    `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QuerySceneRuleResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySceneRuleResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySceneRuleResponseBodyData) SetCurrentPage(v int32) *QuerySceneRuleResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *QuerySceneRuleResponseBodyData) SetPageSize(v int32) *QuerySceneRuleResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QuerySceneRuleResponseBodyData) SetRuleList(v []*QuerySceneRuleResponseBodyDataRuleList) *QuerySceneRuleResponseBodyData {
	s.RuleList = v
	return s
}

func (s *QuerySceneRuleResponseBodyData) SetTotal(v int32) *QuerySceneRuleResponseBodyData {
	s.Total = &v
	return s
}

type QuerySceneRuleResponseBodyDataRuleList struct {
	GmtCreate       *int64  `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtModified     *int64  `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	RuleDescription *string `json:"RuleDescription,omitempty" xml:"RuleDescription,omitempty"`
	RuleId          *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	RuleName        *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
	RuleStatus      *int32  `json:"RuleStatus,omitempty" xml:"RuleStatus,omitempty"`
}

func (s QuerySceneRuleResponseBodyDataRuleList) String() string {
	return tea.Prettify(s)
}

func (s QuerySceneRuleResponseBodyDataRuleList) GoString() string {
	return s.String()
}

func (s *QuerySceneRuleResponseBodyDataRuleList) SetGmtCreate(v int64) *QuerySceneRuleResponseBodyDataRuleList {
	s.GmtCreate = &v
	return s
}

func (s *QuerySceneRuleResponseBodyDataRuleList) SetGmtModified(v int64) *QuerySceneRuleResponseBodyDataRuleList {
	s.GmtModified = &v
	return s
}

func (s *QuerySceneRuleResponseBodyDataRuleList) SetRuleDescription(v string) *QuerySceneRuleResponseBodyDataRuleList {
	s.RuleDescription = &v
	return s
}

func (s *QuerySceneRuleResponseBodyDataRuleList) SetRuleId(v string) *QuerySceneRuleResponseBodyDataRuleList {
	s.RuleId = &v
	return s
}

func (s *QuerySceneRuleResponseBodyDataRuleList) SetRuleName(v string) *QuerySceneRuleResponseBodyDataRuleList {
	s.RuleName = &v
	return s
}

func (s *QuerySceneRuleResponseBodyDataRuleList) SetRuleStatus(v int32) *QuerySceneRuleResponseBodyDataRuleList {
	s.RuleStatus = &v
	return s
}

type QuerySceneRuleResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySceneRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySceneRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySceneRuleResponse) GoString() string {
	return s.String()
}

func (s *QuerySceneRuleResponse) SetHeaders(v map[string]*string) *QuerySceneRuleResponse {
	s.Headers = v
	return s
}

func (s *QuerySceneRuleResponse) SetStatusCode(v int32) *QuerySceneRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySceneRuleResponse) SetBody(v *QuerySceneRuleResponseBody) *QuerySceneRuleResponse {
	s.Body = v
	return s
}

type QuerySchedulePeriodListRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageId        *int32  `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ScheduleCode  *string `json:"ScheduleCode,omitempty" xml:"ScheduleCode,omitempty"`
}

func (s QuerySchedulePeriodListRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySchedulePeriodListRequest) GoString() string {
	return s.String()
}

func (s *QuerySchedulePeriodListRequest) SetIotInstanceId(v string) *QuerySchedulePeriodListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySchedulePeriodListRequest) SetPageId(v int32) *QuerySchedulePeriodListRequest {
	s.PageId = &v
	return s
}

func (s *QuerySchedulePeriodListRequest) SetPageSize(v int32) *QuerySchedulePeriodListRequest {
	s.PageSize = &v
	return s
}

func (s *QuerySchedulePeriodListRequest) SetScheduleCode(v string) *QuerySchedulePeriodListRequest {
	s.ScheduleCode = &v
	return s
}

type QuerySchedulePeriodListResponseBody struct {
	Code         *string                                  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySchedulePeriodListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                  `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                    `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySchedulePeriodListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySchedulePeriodListResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySchedulePeriodListResponseBody) SetCode(v string) *QuerySchedulePeriodListResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySchedulePeriodListResponseBody) SetData(v *QuerySchedulePeriodListResponseBodyData) *QuerySchedulePeriodListResponseBody {
	s.Data = v
	return s
}

func (s *QuerySchedulePeriodListResponseBody) SetErrorMessage(v string) *QuerySchedulePeriodListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySchedulePeriodListResponseBody) SetRequestId(v string) *QuerySchedulePeriodListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySchedulePeriodListResponseBody) SetSuccess(v bool) *QuerySchedulePeriodListResponseBody {
	s.Success = &v
	return s
}

type QuerySchedulePeriodListResponseBodyData struct {
	List     *QuerySchedulePeriodListResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageId   *int32                                       `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize *int32                                       `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total    *int32                                       `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QuerySchedulePeriodListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySchedulePeriodListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySchedulePeriodListResponseBodyData) SetList(v *QuerySchedulePeriodListResponseBodyDataList) *QuerySchedulePeriodListResponseBodyData {
	s.List = v
	return s
}

func (s *QuerySchedulePeriodListResponseBodyData) SetPageId(v int32) *QuerySchedulePeriodListResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QuerySchedulePeriodListResponseBodyData) SetPageSize(v int32) *QuerySchedulePeriodListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QuerySchedulePeriodListResponseBodyData) SetTotal(v int32) *QuerySchedulePeriodListResponseBodyData {
	s.Total = &v
	return s
}

type QuerySchedulePeriodListResponseBodyDataList struct {
	Items []*QuerySchedulePeriodListResponseBodyDataListItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s QuerySchedulePeriodListResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QuerySchedulePeriodListResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QuerySchedulePeriodListResponseBodyDataList) SetItems(v []*QuerySchedulePeriodListResponseBodyDataListItems) *QuerySchedulePeriodListResponseBodyDataList {
	s.Items = v
	return s
}

type QuerySchedulePeriodListResponseBodyDataListItems struct {
	Description      *string `json:"Description,omitempty" xml:"Description,omitempty"`
	EndTime          *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	PeriodCode       *string `json:"PeriodCode,omitempty" xml:"PeriodCode,omitempty"`
	SoundCodeContent *string `json:"SoundCodeContent,omitempty" xml:"SoundCodeContent,omitempty"`
	StartTime        *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s QuerySchedulePeriodListResponseBodyDataListItems) String() string {
	return tea.Prettify(s)
}

func (s QuerySchedulePeriodListResponseBodyDataListItems) GoString() string {
	return s.String()
}

func (s *QuerySchedulePeriodListResponseBodyDataListItems) SetDescription(v string) *QuerySchedulePeriodListResponseBodyDataListItems {
	s.Description = &v
	return s
}

func (s *QuerySchedulePeriodListResponseBodyDataListItems) SetEndTime(v string) *QuerySchedulePeriodListResponseBodyDataListItems {
	s.EndTime = &v
	return s
}

func (s *QuerySchedulePeriodListResponseBodyDataListItems) SetPeriodCode(v string) *QuerySchedulePeriodListResponseBodyDataListItems {
	s.PeriodCode = &v
	return s
}

func (s *QuerySchedulePeriodListResponseBodyDataListItems) SetSoundCodeContent(v string) *QuerySchedulePeriodListResponseBodyDataListItems {
	s.SoundCodeContent = &v
	return s
}

func (s *QuerySchedulePeriodListResponseBodyDataListItems) SetStartTime(v string) *QuerySchedulePeriodListResponseBodyDataListItems {
	s.StartTime = &v
	return s
}

type QuerySchedulePeriodListResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySchedulePeriodListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySchedulePeriodListResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySchedulePeriodListResponse) GoString() string {
	return s.String()
}

func (s *QuerySchedulePeriodListResponse) SetHeaders(v map[string]*string) *QuerySchedulePeriodListResponse {
	s.Headers = v
	return s
}

func (s *QuerySchedulePeriodListResponse) SetStatusCode(v int32) *QuerySchedulePeriodListResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySchedulePeriodListResponse) SetBody(v *QuerySchedulePeriodListResponseBody) *QuerySchedulePeriodListResponse {
	s.Body = v
	return s
}

type QueryShareProductNameByProductKeyRequest struct {
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	ShareTaskCode *string `json:"ShareTaskCode,omitempty" xml:"ShareTaskCode,omitempty"`
}

func (s QueryShareProductNameByProductKeyRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryShareProductNameByProductKeyRequest) GoString() string {
	return s.String()
}

func (s *QueryShareProductNameByProductKeyRequest) SetProductKey(v string) *QueryShareProductNameByProductKeyRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryShareProductNameByProductKeyRequest) SetShareTaskCode(v string) *QueryShareProductNameByProductKeyRequest {
	s.ShareTaskCode = &v
	return s
}

type QueryShareProductNameByProductKeyResponseBody struct {
	Code         *string                                            `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryShareProductNameByProductKeyResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                            `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                              `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryShareProductNameByProductKeyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryShareProductNameByProductKeyResponseBody) GoString() string {
	return s.String()
}

func (s *QueryShareProductNameByProductKeyResponseBody) SetCode(v string) *QueryShareProductNameByProductKeyResponseBody {
	s.Code = &v
	return s
}

func (s *QueryShareProductNameByProductKeyResponseBody) SetData(v *QueryShareProductNameByProductKeyResponseBodyData) *QueryShareProductNameByProductKeyResponseBody {
	s.Data = v
	return s
}

func (s *QueryShareProductNameByProductKeyResponseBody) SetErrorMessage(v string) *QueryShareProductNameByProductKeyResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryShareProductNameByProductKeyResponseBody) SetRequestId(v string) *QueryShareProductNameByProductKeyResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryShareProductNameByProductKeyResponseBody) SetSuccess(v bool) *QueryShareProductNameByProductKeyResponseBody {
	s.Success = &v
	return s
}

type QueryShareProductNameByProductKeyResponseBodyData struct {
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
}

func (s QueryShareProductNameByProductKeyResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryShareProductNameByProductKeyResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryShareProductNameByProductKeyResponseBodyData) SetProductName(v string) *QueryShareProductNameByProductKeyResponseBodyData {
	s.ProductName = &v
	return s
}

type QueryShareProductNameByProductKeyResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryShareProductNameByProductKeyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryShareProductNameByProductKeyResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryShareProductNameByProductKeyResponse) GoString() string {
	return s.String()
}

func (s *QueryShareProductNameByProductKeyResponse) SetHeaders(v map[string]*string) *QueryShareProductNameByProductKeyResponse {
	s.Headers = v
	return s
}

func (s *QueryShareProductNameByProductKeyResponse) SetStatusCode(v int32) *QueryShareProductNameByProductKeyResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryShareProductNameByProductKeyResponse) SetBody(v *QueryShareProductNameByProductKeyResponseBody) *QueryShareProductNameByProductKeyResponse {
	s.Body = v
	return s
}

type QuerySharePromotionActivityAuditResultRequest struct {
	IotInstanceId            *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	SharePromotionActivityId *string `json:"SharePromotionActivityId,omitempty" xml:"SharePromotionActivityId,omitempty"`
	ShareTaskCode            *string `json:"ShareTaskCode,omitempty" xml:"ShareTaskCode,omitempty"`
}

func (s QuerySharePromotionActivityAuditResultRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySharePromotionActivityAuditResultRequest) GoString() string {
	return s.String()
}

func (s *QuerySharePromotionActivityAuditResultRequest) SetIotInstanceId(v string) *QuerySharePromotionActivityAuditResultRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySharePromotionActivityAuditResultRequest) SetSharePromotionActivityId(v string) *QuerySharePromotionActivityAuditResultRequest {
	s.SharePromotionActivityId = &v
	return s
}

func (s *QuerySharePromotionActivityAuditResultRequest) SetShareTaskCode(v string) *QuerySharePromotionActivityAuditResultRequest {
	s.ShareTaskCode = &v
	return s
}

type QuerySharePromotionActivityAuditResultResponseBody struct {
	Code         *string                                                 `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySharePromotionActivityAuditResultResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                                 `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                                 `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                                   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySharePromotionActivityAuditResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySharePromotionActivityAuditResultResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySharePromotionActivityAuditResultResponseBody) SetCode(v string) *QuerySharePromotionActivityAuditResultResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySharePromotionActivityAuditResultResponseBody) SetData(v *QuerySharePromotionActivityAuditResultResponseBodyData) *QuerySharePromotionActivityAuditResultResponseBody {
	s.Data = v
	return s
}

func (s *QuerySharePromotionActivityAuditResultResponseBody) SetErrorMessage(v string) *QuerySharePromotionActivityAuditResultResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySharePromotionActivityAuditResultResponseBody) SetRequestId(v string) *QuerySharePromotionActivityAuditResultResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySharePromotionActivityAuditResultResponseBody) SetSuccess(v bool) *QuerySharePromotionActivityAuditResultResponseBody {
	s.Success = &v
	return s
}

type QuerySharePromotionActivityAuditResultResponseBodyData struct {
	AuditResult *int32 `json:"AuditResult,omitempty" xml:"AuditResult,omitempty"`
}

func (s QuerySharePromotionActivityAuditResultResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySharePromotionActivityAuditResultResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySharePromotionActivityAuditResultResponseBodyData) SetAuditResult(v int32) *QuerySharePromotionActivityAuditResultResponseBodyData {
	s.AuditResult = &v
	return s
}

type QuerySharePromotionActivityAuditResultResponse struct {
	Headers    map[string]*string                                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySharePromotionActivityAuditResultResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySharePromotionActivityAuditResultResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySharePromotionActivityAuditResultResponse) GoString() string {
	return s.String()
}

func (s *QuerySharePromotionActivityAuditResultResponse) SetHeaders(v map[string]*string) *QuerySharePromotionActivityAuditResultResponse {
	s.Headers = v
	return s
}

func (s *QuerySharePromotionActivityAuditResultResponse) SetStatusCode(v int32) *QuerySharePromotionActivityAuditResultResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySharePromotionActivityAuditResultResponse) SetBody(v *QuerySharePromotionActivityAuditResultResponseBody) *QuerySharePromotionActivityAuditResultResponse {
	s.Body = v
	return s
}

type QueryShareTaskDeviceListRequest struct {
	// The keyword in the DeviceName of the device that you want to query. Fuzzy match is supported.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
	//
	// For more information, see [Overview](~~356505~~) of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The page number. Valid values: 1 to 10000.
	PageId *int32 `json:"PageId,omitempty" xml:"PageId,omitempty"`
	// The number of entries per page. Valid values: 1 to 50. Default value: 20.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The ID of the sharing task.
	ShareTaskId *string `json:"ShareTaskId,omitempty" xml:"ShareTaskId,omitempty"`
}

func (s QueryShareTaskDeviceListRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryShareTaskDeviceListRequest) GoString() string {
	return s.String()
}

func (s *QueryShareTaskDeviceListRequest) SetDeviceName(v string) *QueryShareTaskDeviceListRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryShareTaskDeviceListRequest) SetIotInstanceId(v string) *QueryShareTaskDeviceListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryShareTaskDeviceListRequest) SetPageId(v int32) *QueryShareTaskDeviceListRequest {
	s.PageId = &v
	return s
}

func (s *QueryShareTaskDeviceListRequest) SetPageSize(v int32) *QueryShareTaskDeviceListRequest {
	s.PageSize = &v
	return s
}

func (s *QueryShareTaskDeviceListRequest) SetShareTaskId(v string) *QueryShareTaskDeviceListRequest {
	s.ShareTaskId = &v
	return s
}

type QueryShareTaskDeviceListResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the request.
	Data *QueryShareTaskDeviceListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryShareTaskDeviceListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryShareTaskDeviceListResponseBody) GoString() string {
	return s.String()
}

func (s *QueryShareTaskDeviceListResponseBody) SetCode(v string) *QueryShareTaskDeviceListResponseBody {
	s.Code = &v
	return s
}

func (s *QueryShareTaskDeviceListResponseBody) SetData(v *QueryShareTaskDeviceListResponseBodyData) *QueryShareTaskDeviceListResponseBody {
	s.Data = v
	return s
}

func (s *QueryShareTaskDeviceListResponseBody) SetErrorMessage(v string) *QueryShareTaskDeviceListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryShareTaskDeviceListResponseBody) SetRequestId(v string) *QueryShareTaskDeviceListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryShareTaskDeviceListResponseBody) SetSuccess(v bool) *QueryShareTaskDeviceListResponseBody {
	s.Success = &v
	return s
}

type QueryShareTaskDeviceListResponseBodyData struct {
	// The devices in the sharing task.
	DeviceList *QueryShareTaskDeviceListResponseBodyDataDeviceList `json:"DeviceList,omitempty" xml:"DeviceList,omitempty" type:"Struct"`
	// The page number.
	PageId *int32 `json:"PageId,omitempty" xml:"PageId,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QueryShareTaskDeviceListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryShareTaskDeviceListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryShareTaskDeviceListResponseBodyData) SetDeviceList(v *QueryShareTaskDeviceListResponseBodyDataDeviceList) *QueryShareTaskDeviceListResponseBodyData {
	s.DeviceList = v
	return s
}

func (s *QueryShareTaskDeviceListResponseBodyData) SetPageId(v int32) *QueryShareTaskDeviceListResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QueryShareTaskDeviceListResponseBodyData) SetPageSize(v int32) *QueryShareTaskDeviceListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryShareTaskDeviceListResponseBodyData) SetTotal(v int32) *QueryShareTaskDeviceListResponseBodyData {
	s.Total = &v
	return s
}

type QueryShareTaskDeviceListResponseBodyDataDeviceList struct {
	Items []*QueryShareTaskDeviceListResponseBodyDataDeviceListItems `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s QueryShareTaskDeviceListResponseBodyDataDeviceList) String() string {
	return tea.Prettify(s)
}

func (s QueryShareTaskDeviceListResponseBodyDataDeviceList) GoString() string {
	return s.String()
}

func (s *QueryShareTaskDeviceListResponseBodyDataDeviceList) SetItems(v []*QueryShareTaskDeviceListResponseBodyDataDeviceListItems) *QueryShareTaskDeviceListResponseBodyDataDeviceList {
	s.Items = v
	return s
}

type QueryShareTaskDeviceListResponseBodyDataDeviceListItems struct {
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The time when the device was added to the sharing task.
	GmtAdded *int64 `json:"GmtAdded,omitempty" xml:"GmtAdded,omitempty"`
	// The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryShareTaskDeviceListResponseBodyDataDeviceListItems) String() string {
	return tea.Prettify(s)
}

func (s QueryShareTaskDeviceListResponseBodyDataDeviceListItems) GoString() string {
	return s.String()
}

func (s *QueryShareTaskDeviceListResponseBodyDataDeviceListItems) SetDeviceName(v string) *QueryShareTaskDeviceListResponseBodyDataDeviceListItems {
	s.DeviceName = &v
	return s
}

func (s *QueryShareTaskDeviceListResponseBodyDataDeviceListItems) SetGmtAdded(v int64) *QueryShareTaskDeviceListResponseBodyDataDeviceListItems {
	s.GmtAdded = &v
	return s
}

func (s *QueryShareTaskDeviceListResponseBodyDataDeviceListItems) SetIotId(v string) *QueryShareTaskDeviceListResponseBodyDataDeviceListItems {
	s.IotId = &v
	return s
}

func (s *QueryShareTaskDeviceListResponseBodyDataDeviceListItems) SetProductKey(v string) *QueryShareTaskDeviceListResponseBodyDataDeviceListItems {
	s.ProductKey = &v
	return s
}

type QueryShareTaskDeviceListResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryShareTaskDeviceListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryShareTaskDeviceListResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryShareTaskDeviceListResponse) GoString() string {
	return s.String()
}

func (s *QueryShareTaskDeviceListResponse) SetHeaders(v map[string]*string) *QueryShareTaskDeviceListResponse {
	s.Headers = v
	return s
}

func (s *QueryShareTaskDeviceListResponse) SetStatusCode(v int32) *QueryShareTaskDeviceListResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryShareTaskDeviceListResponse) SetBody(v *QueryShareTaskDeviceListResponseBody) *QueryShareTaskDeviceListResponse {
	s.Body = v
	return s
}

type QuerySolutionDeviceGroupPageRequest struct {
	FuzzyGroupName *string `json:"FuzzyGroupName,omitempty" xml:"FuzzyGroupName,omitempty"`
	IotInstanceId  *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageId         *int32  `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize       *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProjectCode    *string `json:"ProjectCode,omitempty" xml:"ProjectCode,omitempty"`
}

func (s QuerySolutionDeviceGroupPageRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySolutionDeviceGroupPageRequest) GoString() string {
	return s.String()
}

func (s *QuerySolutionDeviceGroupPageRequest) SetFuzzyGroupName(v string) *QuerySolutionDeviceGroupPageRequest {
	s.FuzzyGroupName = &v
	return s
}

func (s *QuerySolutionDeviceGroupPageRequest) SetIotInstanceId(v string) *QuerySolutionDeviceGroupPageRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySolutionDeviceGroupPageRequest) SetPageId(v int32) *QuerySolutionDeviceGroupPageRequest {
	s.PageId = &v
	return s
}

func (s *QuerySolutionDeviceGroupPageRequest) SetPageSize(v int32) *QuerySolutionDeviceGroupPageRequest {
	s.PageSize = &v
	return s
}

func (s *QuerySolutionDeviceGroupPageRequest) SetProjectCode(v string) *QuerySolutionDeviceGroupPageRequest {
	s.ProjectCode = &v
	return s
}

type QuerySolutionDeviceGroupPageResponseBody struct {
	Code         *string                                       `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySolutionDeviceGroupPageResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                       `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                         `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySolutionDeviceGroupPageResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySolutionDeviceGroupPageResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySolutionDeviceGroupPageResponseBody) SetCode(v string) *QuerySolutionDeviceGroupPageResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySolutionDeviceGroupPageResponseBody) SetData(v *QuerySolutionDeviceGroupPageResponseBodyData) *QuerySolutionDeviceGroupPageResponseBody {
	s.Data = v
	return s
}

func (s *QuerySolutionDeviceGroupPageResponseBody) SetErrorMessage(v string) *QuerySolutionDeviceGroupPageResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySolutionDeviceGroupPageResponseBody) SetRequestId(v string) *QuerySolutionDeviceGroupPageResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySolutionDeviceGroupPageResponseBody) SetSuccess(v bool) *QuerySolutionDeviceGroupPageResponseBody {
	s.Success = &v
	return s
}

type QuerySolutionDeviceGroupPageResponseBodyData struct {
	List     *QuerySolutionDeviceGroupPageResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageId   *int32                                            `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize *int32                                            `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total    *int32                                            `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QuerySolutionDeviceGroupPageResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySolutionDeviceGroupPageResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySolutionDeviceGroupPageResponseBodyData) SetList(v *QuerySolutionDeviceGroupPageResponseBodyDataList) *QuerySolutionDeviceGroupPageResponseBodyData {
	s.List = v
	return s
}

func (s *QuerySolutionDeviceGroupPageResponseBodyData) SetPageId(v int32) *QuerySolutionDeviceGroupPageResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QuerySolutionDeviceGroupPageResponseBodyData) SetPageSize(v int32) *QuerySolutionDeviceGroupPageResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QuerySolutionDeviceGroupPageResponseBodyData) SetTotal(v int32) *QuerySolutionDeviceGroupPageResponseBodyData {
	s.Total = &v
	return s
}

type QuerySolutionDeviceGroupPageResponseBodyDataList struct {
	ItemName []*QuerySolutionDeviceGroupPageResponseBodyDataListItemName `json:"itemName,omitempty" xml:"itemName,omitempty" type:"Repeated"`
}

func (s QuerySolutionDeviceGroupPageResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QuerySolutionDeviceGroupPageResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QuerySolutionDeviceGroupPageResponseBodyDataList) SetItemName(v []*QuerySolutionDeviceGroupPageResponseBodyDataListItemName) *QuerySolutionDeviceGroupPageResponseBodyDataList {
	s.ItemName = v
	return s
}

type QuerySolutionDeviceGroupPageResponseBodyDataListItemName struct {
	DeviceCount *int64  `json:"DeviceCount,omitempty" xml:"DeviceCount,omitempty"`
	GmtCreate   *int64  `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtModified *int64  `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	GroupDesc   *string `json:"GroupDesc,omitempty" xml:"GroupDesc,omitempty"`
	GroupId     *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	GroupName   *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
}

func (s QuerySolutionDeviceGroupPageResponseBodyDataListItemName) String() string {
	return tea.Prettify(s)
}

func (s QuerySolutionDeviceGroupPageResponseBodyDataListItemName) GoString() string {
	return s.String()
}

func (s *QuerySolutionDeviceGroupPageResponseBodyDataListItemName) SetDeviceCount(v int64) *QuerySolutionDeviceGroupPageResponseBodyDataListItemName {
	s.DeviceCount = &v
	return s
}

func (s *QuerySolutionDeviceGroupPageResponseBodyDataListItemName) SetGmtCreate(v int64) *QuerySolutionDeviceGroupPageResponseBodyDataListItemName {
	s.GmtCreate = &v
	return s
}

func (s *QuerySolutionDeviceGroupPageResponseBodyDataListItemName) SetGmtModified(v int64) *QuerySolutionDeviceGroupPageResponseBodyDataListItemName {
	s.GmtModified = &v
	return s
}

func (s *QuerySolutionDeviceGroupPageResponseBodyDataListItemName) SetGroupDesc(v string) *QuerySolutionDeviceGroupPageResponseBodyDataListItemName {
	s.GroupDesc = &v
	return s
}

func (s *QuerySolutionDeviceGroupPageResponseBodyDataListItemName) SetGroupId(v string) *QuerySolutionDeviceGroupPageResponseBodyDataListItemName {
	s.GroupId = &v
	return s
}

func (s *QuerySolutionDeviceGroupPageResponseBodyDataListItemName) SetGroupName(v string) *QuerySolutionDeviceGroupPageResponseBodyDataListItemName {
	s.GroupName = &v
	return s
}

type QuerySolutionDeviceGroupPageResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySolutionDeviceGroupPageResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySolutionDeviceGroupPageResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySolutionDeviceGroupPageResponse) GoString() string {
	return s.String()
}

func (s *QuerySolutionDeviceGroupPageResponse) SetHeaders(v map[string]*string) *QuerySolutionDeviceGroupPageResponse {
	s.Headers = v
	return s
}

func (s *QuerySolutionDeviceGroupPageResponse) SetStatusCode(v int32) *QuerySolutionDeviceGroupPageResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySolutionDeviceGroupPageResponse) SetBody(v *QuerySolutionDeviceGroupPageResponseBody) *QuerySolutionDeviceGroupPageResponse {
	s.Body = v
	return s
}

type QuerySoundCodeLabelBatchFailedResultRequest struct {
	BatchCode     *string `json:"BatchCode,omitempty" xml:"BatchCode,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s QuerySoundCodeLabelBatchFailedResultRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelBatchFailedResultRequest) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelBatchFailedResultRequest) SetBatchCode(v string) *QuerySoundCodeLabelBatchFailedResultRequest {
	s.BatchCode = &v
	return s
}

func (s *QuerySoundCodeLabelBatchFailedResultRequest) SetIotInstanceId(v string) *QuerySoundCodeLabelBatchFailedResultRequest {
	s.IotInstanceId = &v
	return s
}

type QuerySoundCodeLabelBatchFailedResultResponseBody struct {
	Code         *string                                               `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySoundCodeLabelBatchFailedResultResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                               `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                               `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                                 `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySoundCodeLabelBatchFailedResultResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelBatchFailedResultResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelBatchFailedResultResponseBody) SetCode(v string) *QuerySoundCodeLabelBatchFailedResultResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySoundCodeLabelBatchFailedResultResponseBody) SetData(v *QuerySoundCodeLabelBatchFailedResultResponseBodyData) *QuerySoundCodeLabelBatchFailedResultResponseBody {
	s.Data = v
	return s
}

func (s *QuerySoundCodeLabelBatchFailedResultResponseBody) SetErrorMessage(v string) *QuerySoundCodeLabelBatchFailedResultResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySoundCodeLabelBatchFailedResultResponseBody) SetRequestId(v string) *QuerySoundCodeLabelBatchFailedResultResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySoundCodeLabelBatchFailedResultResponseBody) SetSuccess(v bool) *QuerySoundCodeLabelBatchFailedResultResponseBody {
	s.Success = &v
	return s
}

type QuerySoundCodeLabelBatchFailedResultResponseBodyData struct {
	Items []*QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s QuerySoundCodeLabelBatchFailedResultResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelBatchFailedResultResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelBatchFailedResultResponseBodyData) SetItems(v []*QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems) *QuerySoundCodeLabelBatchFailedResultResponseBodyData {
	s.Items = v
	return s
}

type QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems struct {
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	Label        *string `json:"Label,omitempty" xml:"Label,omitempty"`
	ResultCode   *string `json:"ResultCode,omitempty" xml:"ResultCode,omitempty"`
}

func (s QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems) SetErrorMessage(v string) *QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems) SetLabel(v string) *QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems {
	s.Label = &v
	return s
}

func (s *QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems) SetResultCode(v string) *QuerySoundCodeLabelBatchFailedResultResponseBodyDataItems {
	s.ResultCode = &v
	return s
}

type QuerySoundCodeLabelBatchFailedResultResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySoundCodeLabelBatchFailedResultResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySoundCodeLabelBatchFailedResultResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelBatchFailedResultResponse) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelBatchFailedResultResponse) SetHeaders(v map[string]*string) *QuerySoundCodeLabelBatchFailedResultResponse {
	s.Headers = v
	return s
}

func (s *QuerySoundCodeLabelBatchFailedResultResponse) SetStatusCode(v int32) *QuerySoundCodeLabelBatchFailedResultResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySoundCodeLabelBatchFailedResultResponse) SetBody(v *QuerySoundCodeLabelBatchFailedResultResponseBody) *QuerySoundCodeLabelBatchFailedResultResponse {
	s.Body = v
	return s
}

type QuerySoundCodeLabelBatchListRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageId        *int32  `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ScheduleCode  *string `json:"ScheduleCode,omitempty" xml:"ScheduleCode,omitempty"`
}

func (s QuerySoundCodeLabelBatchListRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelBatchListRequest) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelBatchListRequest) SetIotInstanceId(v string) *QuerySoundCodeLabelBatchListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySoundCodeLabelBatchListRequest) SetPageId(v int32) *QuerySoundCodeLabelBatchListRequest {
	s.PageId = &v
	return s
}

func (s *QuerySoundCodeLabelBatchListRequest) SetPageSize(v int32) *QuerySoundCodeLabelBatchListRequest {
	s.PageSize = &v
	return s
}

func (s *QuerySoundCodeLabelBatchListRequest) SetScheduleCode(v string) *QuerySoundCodeLabelBatchListRequest {
	s.ScheduleCode = &v
	return s
}

type QuerySoundCodeLabelBatchListResponseBody struct {
	Code         *string                                       `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySoundCodeLabelBatchListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                       `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                         `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySoundCodeLabelBatchListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelBatchListResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelBatchListResponseBody) SetCode(v string) *QuerySoundCodeLabelBatchListResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySoundCodeLabelBatchListResponseBody) SetData(v *QuerySoundCodeLabelBatchListResponseBodyData) *QuerySoundCodeLabelBatchListResponseBody {
	s.Data = v
	return s
}

func (s *QuerySoundCodeLabelBatchListResponseBody) SetErrorMessage(v string) *QuerySoundCodeLabelBatchListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySoundCodeLabelBatchListResponseBody) SetRequestId(v string) *QuerySoundCodeLabelBatchListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySoundCodeLabelBatchListResponseBody) SetSuccess(v bool) *QuerySoundCodeLabelBatchListResponseBody {
	s.Success = &v
	return s
}

type QuerySoundCodeLabelBatchListResponseBodyData struct {
	List     *QuerySoundCodeLabelBatchListResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageId   *int32                                            `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize *int32                                            `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total    *int32                                            `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QuerySoundCodeLabelBatchListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelBatchListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelBatchListResponseBodyData) SetList(v *QuerySoundCodeLabelBatchListResponseBodyDataList) *QuerySoundCodeLabelBatchListResponseBodyData {
	s.List = v
	return s
}

func (s *QuerySoundCodeLabelBatchListResponseBodyData) SetPageId(v int32) *QuerySoundCodeLabelBatchListResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QuerySoundCodeLabelBatchListResponseBodyData) SetPageSize(v int32) *QuerySoundCodeLabelBatchListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QuerySoundCodeLabelBatchListResponseBodyData) SetTotal(v int32) *QuerySoundCodeLabelBatchListResponseBodyData {
	s.Total = &v
	return s
}

type QuerySoundCodeLabelBatchListResponseBodyDataList struct {
	Items []*QuerySoundCodeLabelBatchListResponseBodyDataListItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s QuerySoundCodeLabelBatchListResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelBatchListResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelBatchListResponseBodyDataList) SetItems(v []*QuerySoundCodeLabelBatchListResponseBodyDataListItems) *QuerySoundCodeLabelBatchListResponseBodyDataList {
	s.Items = v
	return s
}

type QuerySoundCodeLabelBatchListResponseBodyDataListItems struct {
	BatchCode   *string `json:"BatchCode,omitempty" xml:"BatchCode,omitempty"`
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	GmtCreate   *int64  `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	Status      *string `json:"Status,omitempty" xml:"Status,omitempty"`
	SuccessNum  *int32  `json:"SuccessNum,omitempty" xml:"SuccessNum,omitempty"`
	Total       *int32  `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QuerySoundCodeLabelBatchListResponseBodyDataListItems) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelBatchListResponseBodyDataListItems) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelBatchListResponseBodyDataListItems) SetBatchCode(v string) *QuerySoundCodeLabelBatchListResponseBodyDataListItems {
	s.BatchCode = &v
	return s
}

func (s *QuerySoundCodeLabelBatchListResponseBodyDataListItems) SetDescription(v string) *QuerySoundCodeLabelBatchListResponseBodyDataListItems {
	s.Description = &v
	return s
}

func (s *QuerySoundCodeLabelBatchListResponseBodyDataListItems) SetGmtCreate(v int64) *QuerySoundCodeLabelBatchListResponseBodyDataListItems {
	s.GmtCreate = &v
	return s
}

func (s *QuerySoundCodeLabelBatchListResponseBodyDataListItems) SetStatus(v string) *QuerySoundCodeLabelBatchListResponseBodyDataListItems {
	s.Status = &v
	return s
}

func (s *QuerySoundCodeLabelBatchListResponseBodyDataListItems) SetSuccessNum(v int32) *QuerySoundCodeLabelBatchListResponseBodyDataListItems {
	s.SuccessNum = &v
	return s
}

func (s *QuerySoundCodeLabelBatchListResponseBodyDataListItems) SetTotal(v int32) *QuerySoundCodeLabelBatchListResponseBodyDataListItems {
	s.Total = &v
	return s
}

type QuerySoundCodeLabelBatchListResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySoundCodeLabelBatchListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySoundCodeLabelBatchListResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelBatchListResponse) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelBatchListResponse) SetHeaders(v map[string]*string) *QuerySoundCodeLabelBatchListResponse {
	s.Headers = v
	return s
}

func (s *QuerySoundCodeLabelBatchListResponse) SetStatusCode(v int32) *QuerySoundCodeLabelBatchListResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySoundCodeLabelBatchListResponse) SetBody(v *QuerySoundCodeLabelBatchListResponseBody) *QuerySoundCodeLabelBatchListResponse {
	s.Body = v
	return s
}

type QuerySoundCodeLabelListRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageId        *int32  `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ScheduleCode  *string `json:"ScheduleCode,omitempty" xml:"ScheduleCode,omitempty"`
}

func (s QuerySoundCodeLabelListRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelListRequest) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelListRequest) SetIotInstanceId(v string) *QuerySoundCodeLabelListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySoundCodeLabelListRequest) SetPageId(v int32) *QuerySoundCodeLabelListRequest {
	s.PageId = &v
	return s
}

func (s *QuerySoundCodeLabelListRequest) SetPageSize(v int32) *QuerySoundCodeLabelListRequest {
	s.PageSize = &v
	return s
}

func (s *QuerySoundCodeLabelListRequest) SetScheduleCode(v string) *QuerySoundCodeLabelListRequest {
	s.ScheduleCode = &v
	return s
}

type QuerySoundCodeLabelListResponseBody struct {
	Code         *string                                  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySoundCodeLabelListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                  `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                    `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySoundCodeLabelListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelListResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelListResponseBody) SetCode(v string) *QuerySoundCodeLabelListResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySoundCodeLabelListResponseBody) SetData(v *QuerySoundCodeLabelListResponseBodyData) *QuerySoundCodeLabelListResponseBody {
	s.Data = v
	return s
}

func (s *QuerySoundCodeLabelListResponseBody) SetErrorMessage(v string) *QuerySoundCodeLabelListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySoundCodeLabelListResponseBody) SetRequestId(v string) *QuerySoundCodeLabelListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySoundCodeLabelListResponseBody) SetSuccess(v bool) *QuerySoundCodeLabelListResponseBody {
	s.Success = &v
	return s
}

type QuerySoundCodeLabelListResponseBodyData struct {
	List     *QuerySoundCodeLabelListResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageId   *int32                                       `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize *int32                                       `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total    *int32                                       `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QuerySoundCodeLabelListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelListResponseBodyData) SetList(v *QuerySoundCodeLabelListResponseBodyDataList) *QuerySoundCodeLabelListResponseBodyData {
	s.List = v
	return s
}

func (s *QuerySoundCodeLabelListResponseBodyData) SetPageId(v int32) *QuerySoundCodeLabelListResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QuerySoundCodeLabelListResponseBodyData) SetPageSize(v int32) *QuerySoundCodeLabelListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QuerySoundCodeLabelListResponseBodyData) SetTotal(v int32) *QuerySoundCodeLabelListResponseBodyData {
	s.Total = &v
	return s
}

type QuerySoundCodeLabelListResponseBodyDataList struct {
	Items []*QuerySoundCodeLabelListResponseBodyDataListItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s QuerySoundCodeLabelListResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelListResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelListResponseBodyDataList) SetItems(v []*QuerySoundCodeLabelListResponseBodyDataListItems) *QuerySoundCodeLabelListResponseBodyDataList {
	s.Items = v
	return s
}

type QuerySoundCodeLabelListResponseBodyDataListItems struct {
	Label     *string `json:"Label,omitempty" xml:"Label,omitempty"`
	SoundCode *string `json:"SoundCode,omitempty" xml:"SoundCode,omitempty"`
}

func (s QuerySoundCodeLabelListResponseBodyDataListItems) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelListResponseBodyDataListItems) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelListResponseBodyDataListItems) SetLabel(v string) *QuerySoundCodeLabelListResponseBodyDataListItems {
	s.Label = &v
	return s
}

func (s *QuerySoundCodeLabelListResponseBodyDataListItems) SetSoundCode(v string) *QuerySoundCodeLabelListResponseBodyDataListItems {
	s.SoundCode = &v
	return s
}

type QuerySoundCodeLabelListResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySoundCodeLabelListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySoundCodeLabelListResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeLabelListResponse) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeLabelListResponse) SetHeaders(v map[string]*string) *QuerySoundCodeLabelListResponse {
	s.Headers = v
	return s
}

func (s *QuerySoundCodeLabelListResponse) SetStatusCode(v int32) *QuerySoundCodeLabelListResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySoundCodeLabelListResponse) SetBody(v *QuerySoundCodeLabelListResponseBody) *QuerySoundCodeLabelListResponse {
	s.Body = v
	return s
}

type QuerySoundCodeListRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageId        *int32  `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QuerySoundCodeListRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeListRequest) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeListRequest) SetIotInstanceId(v string) *QuerySoundCodeListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySoundCodeListRequest) SetPageId(v int32) *QuerySoundCodeListRequest {
	s.PageId = &v
	return s
}

func (s *QuerySoundCodeListRequest) SetPageSize(v int32) *QuerySoundCodeListRequest {
	s.PageSize = &v
	return s
}

type QuerySoundCodeListResponseBody struct {
	Code         *string                             `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySoundCodeListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                             `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                               `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySoundCodeListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeListResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeListResponseBody) SetCode(v string) *QuerySoundCodeListResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySoundCodeListResponseBody) SetData(v *QuerySoundCodeListResponseBodyData) *QuerySoundCodeListResponseBody {
	s.Data = v
	return s
}

func (s *QuerySoundCodeListResponseBody) SetErrorMessage(v string) *QuerySoundCodeListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySoundCodeListResponseBody) SetRequestId(v string) *QuerySoundCodeListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySoundCodeListResponseBody) SetSuccess(v bool) *QuerySoundCodeListResponseBody {
	s.Success = &v
	return s
}

type QuerySoundCodeListResponseBodyData struct {
	List     *QuerySoundCodeListResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageId   *int32                                  `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize *int32                                  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total    *int32                                  `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QuerySoundCodeListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeListResponseBodyData) SetList(v *QuerySoundCodeListResponseBodyDataList) *QuerySoundCodeListResponseBodyData {
	s.List = v
	return s
}

func (s *QuerySoundCodeListResponseBodyData) SetPageId(v int32) *QuerySoundCodeListResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QuerySoundCodeListResponseBodyData) SetPageSize(v int32) *QuerySoundCodeListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QuerySoundCodeListResponseBodyData) SetTotal(v int32) *QuerySoundCodeListResponseBodyData {
	s.Total = &v
	return s
}

type QuerySoundCodeListResponseBodyDataList struct {
	Items []*QuerySoundCodeListResponseBodyDataListItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s QuerySoundCodeListResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeListResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeListResponseBodyDataList) SetItems(v []*QuerySoundCodeListResponseBodyDataListItems) *QuerySoundCodeListResponseBodyDataList {
	s.Items = v
	return s
}

type QuerySoundCodeListResponseBodyDataListItems struct {
	Duration         *int32  `json:"Duration,omitempty" xml:"Duration,omitempty"`
	GmtCreate        *int64  `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	Name             *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OpenType         *string `json:"OpenType,omitempty" xml:"OpenType,omitempty"`
	SoundCode        *string `json:"SoundCode,omitempty" xml:"SoundCode,omitempty"`
	SoundCodeContent *string `json:"SoundCodeContent,omitempty" xml:"SoundCodeContent,omitempty"`
}

func (s QuerySoundCodeListResponseBodyDataListItems) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeListResponseBodyDataListItems) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeListResponseBodyDataListItems) SetDuration(v int32) *QuerySoundCodeListResponseBodyDataListItems {
	s.Duration = &v
	return s
}

func (s *QuerySoundCodeListResponseBodyDataListItems) SetGmtCreate(v int64) *QuerySoundCodeListResponseBodyDataListItems {
	s.GmtCreate = &v
	return s
}

func (s *QuerySoundCodeListResponseBodyDataListItems) SetName(v string) *QuerySoundCodeListResponseBodyDataListItems {
	s.Name = &v
	return s
}

func (s *QuerySoundCodeListResponseBodyDataListItems) SetOpenType(v string) *QuerySoundCodeListResponseBodyDataListItems {
	s.OpenType = &v
	return s
}

func (s *QuerySoundCodeListResponseBodyDataListItems) SetSoundCode(v string) *QuerySoundCodeListResponseBodyDataListItems {
	s.SoundCode = &v
	return s
}

func (s *QuerySoundCodeListResponseBodyDataListItems) SetSoundCodeContent(v string) *QuerySoundCodeListResponseBodyDataListItems {
	s.SoundCodeContent = &v
	return s
}

type QuerySoundCodeListResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySoundCodeListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySoundCodeListResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeListResponse) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeListResponse) SetHeaders(v map[string]*string) *QuerySoundCodeListResponse {
	s.Headers = v
	return s
}

func (s *QuerySoundCodeListResponse) SetStatusCode(v int32) *QuerySoundCodeListResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySoundCodeListResponse) SetBody(v *QuerySoundCodeListResponseBody) *QuerySoundCodeListResponse {
	s.Body = v
	return s
}

type QuerySoundCodeScheduleListRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageId        *int32  `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QuerySoundCodeScheduleListRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeScheduleListRequest) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeScheduleListRequest) SetIotInstanceId(v string) *QuerySoundCodeScheduleListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySoundCodeScheduleListRequest) SetPageId(v int32) *QuerySoundCodeScheduleListRequest {
	s.PageId = &v
	return s
}

func (s *QuerySoundCodeScheduleListRequest) SetPageSize(v int32) *QuerySoundCodeScheduleListRequest {
	s.PageSize = &v
	return s
}

type QuerySoundCodeScheduleListResponseBody struct {
	Code         *string                                     `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySoundCodeScheduleListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySoundCodeScheduleListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeScheduleListResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeScheduleListResponseBody) SetCode(v string) *QuerySoundCodeScheduleListResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBody) SetData(v *QuerySoundCodeScheduleListResponseBodyData) *QuerySoundCodeScheduleListResponseBody {
	s.Data = v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBody) SetErrorMessage(v string) *QuerySoundCodeScheduleListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBody) SetRequestId(v string) *QuerySoundCodeScheduleListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBody) SetSuccess(v bool) *QuerySoundCodeScheduleListResponseBody {
	s.Success = &v
	return s
}

type QuerySoundCodeScheduleListResponseBodyData struct {
	List     *QuerySoundCodeScheduleListResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageId   *int32                                          `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize *int32                                          `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total    *int32                                          `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QuerySoundCodeScheduleListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeScheduleListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeScheduleListResponseBodyData) SetList(v *QuerySoundCodeScheduleListResponseBodyDataList) *QuerySoundCodeScheduleListResponseBodyData {
	s.List = v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBodyData) SetPageId(v int32) *QuerySoundCodeScheduleListResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBodyData) SetPageSize(v int32) *QuerySoundCodeScheduleListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBodyData) SetTotal(v int32) *QuerySoundCodeScheduleListResponseBodyData {
	s.Total = &v
	return s
}

type QuerySoundCodeScheduleListResponseBodyDataList struct {
	Items []*QuerySoundCodeScheduleListResponseBodyDataListItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s QuerySoundCodeScheduleListResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeScheduleListResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeScheduleListResponseBodyDataList) SetItems(v []*QuerySoundCodeScheduleListResponseBodyDataListItems) *QuerySoundCodeScheduleListResponseBodyDataList {
	s.Items = v
	return s
}

type QuerySoundCodeScheduleListResponseBodyDataListItems struct {
	Description  *string `json:"Description,omitempty" xml:"Description,omitempty"`
	EndDate      *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	EndTime      *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	GmtCreate    *int64  `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	Name         *string `json:"Name,omitempty" xml:"Name,omitempty"`
	OpenType     *string `json:"OpenType,omitempty" xml:"OpenType,omitempty"`
	ScheduleCode *string `json:"ScheduleCode,omitempty" xml:"ScheduleCode,omitempty"`
	StartDate    *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	StartTime    *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	Status       *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s QuerySoundCodeScheduleListResponseBodyDataListItems) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeScheduleListResponseBodyDataListItems) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeScheduleListResponseBodyDataListItems) SetDescription(v string) *QuerySoundCodeScheduleListResponseBodyDataListItems {
	s.Description = &v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBodyDataListItems) SetEndDate(v string) *QuerySoundCodeScheduleListResponseBodyDataListItems {
	s.EndDate = &v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBodyDataListItems) SetEndTime(v string) *QuerySoundCodeScheduleListResponseBodyDataListItems {
	s.EndTime = &v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBodyDataListItems) SetGmtCreate(v int64) *QuerySoundCodeScheduleListResponseBodyDataListItems {
	s.GmtCreate = &v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBodyDataListItems) SetName(v string) *QuerySoundCodeScheduleListResponseBodyDataListItems {
	s.Name = &v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBodyDataListItems) SetOpenType(v string) *QuerySoundCodeScheduleListResponseBodyDataListItems {
	s.OpenType = &v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBodyDataListItems) SetScheduleCode(v string) *QuerySoundCodeScheduleListResponseBodyDataListItems {
	s.ScheduleCode = &v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBodyDataListItems) SetStartDate(v string) *QuerySoundCodeScheduleListResponseBodyDataListItems {
	s.StartDate = &v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBodyDataListItems) SetStartTime(v string) *QuerySoundCodeScheduleListResponseBodyDataListItems {
	s.StartTime = &v
	return s
}

func (s *QuerySoundCodeScheduleListResponseBodyDataListItems) SetStatus(v string) *QuerySoundCodeScheduleListResponseBodyDataListItems {
	s.Status = &v
	return s
}

type QuerySoundCodeScheduleListResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySoundCodeScheduleListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySoundCodeScheduleListResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySoundCodeScheduleListResponse) GoString() string {
	return s.String()
}

func (s *QuerySoundCodeScheduleListResponse) SetHeaders(v map[string]*string) *QuerySoundCodeScheduleListResponse {
	s.Headers = v
	return s
}

func (s *QuerySoundCodeScheduleListResponse) SetStatusCode(v int32) *QuerySoundCodeScheduleListResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySoundCodeScheduleListResponse) SetBody(v *QuerySoundCodeScheduleListResponseBody) *QuerySoundCodeScheduleListResponse {
	s.Body = v
	return s
}

type QuerySpeechRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	SpeechCode    *string `json:"SpeechCode,omitempty" xml:"SpeechCode,omitempty"`
}

func (s QuerySpeechRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechRequest) GoString() string {
	return s.String()
}

func (s *QuerySpeechRequest) SetIotInstanceId(v string) *QuerySpeechRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySpeechRequest) SetSpeechCode(v string) *QuerySpeechRequest {
	s.SpeechCode = &v
	return s
}

type QuerySpeechResponseBody struct {
	Code         *string                      `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySpeechResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                      `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                      `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                        `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySpeechResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySpeechResponseBody) SetCode(v string) *QuerySpeechResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySpeechResponseBody) SetData(v *QuerySpeechResponseBodyData) *QuerySpeechResponseBody {
	s.Data = v
	return s
}

func (s *QuerySpeechResponseBody) SetErrorMessage(v string) *QuerySpeechResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySpeechResponseBody) SetRequestId(v string) *QuerySpeechResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySpeechResponseBody) SetSuccess(v bool) *QuerySpeechResponseBody {
	s.Success = &v
	return s
}

type QuerySpeechResponseBodyData struct {
	AudioFormat     *string                                     `json:"AudioFormat,omitempty" xml:"AudioFormat,omitempty"`
	BizCode         *string                                     `json:"BizCode,omitempty" xml:"BizCode,omitempty"`
	EnableSoundCode *bool                                       `json:"EnableSoundCode,omitempty" xml:"EnableSoundCode,omitempty"`
	SoundCodeConfig *QuerySpeechResponseBodyDataSoundCodeConfig `json:"SoundCodeConfig,omitempty" xml:"SoundCodeConfig,omitempty" type:"Struct"`
	SpeechCode      *string                                     `json:"SpeechCode,omitempty" xml:"SpeechCode,omitempty"`
	SpeechRate      *int32                                      `json:"SpeechRate,omitempty" xml:"SpeechRate,omitempty"`
	SpeechType      *string                                     `json:"SpeechType,omitempty" xml:"SpeechType,omitempty"`
	Text            *string                                     `json:"Text,omitempty" xml:"Text,omitempty"`
	Voice           *string                                     `json:"Voice,omitempty" xml:"Voice,omitempty"`
	Volume          *int32                                      `json:"Volume,omitempty" xml:"Volume,omitempty"`
}

func (s QuerySpeechResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySpeechResponseBodyData) SetAudioFormat(v string) *QuerySpeechResponseBodyData {
	s.AudioFormat = &v
	return s
}

func (s *QuerySpeechResponseBodyData) SetBizCode(v string) *QuerySpeechResponseBodyData {
	s.BizCode = &v
	return s
}

func (s *QuerySpeechResponseBodyData) SetEnableSoundCode(v bool) *QuerySpeechResponseBodyData {
	s.EnableSoundCode = &v
	return s
}

func (s *QuerySpeechResponseBodyData) SetSoundCodeConfig(v *QuerySpeechResponseBodyDataSoundCodeConfig) *QuerySpeechResponseBodyData {
	s.SoundCodeConfig = v
	return s
}

func (s *QuerySpeechResponseBodyData) SetSpeechCode(v string) *QuerySpeechResponseBodyData {
	s.SpeechCode = &v
	return s
}

func (s *QuerySpeechResponseBodyData) SetSpeechRate(v int32) *QuerySpeechResponseBodyData {
	s.SpeechRate = &v
	return s
}

func (s *QuerySpeechResponseBodyData) SetSpeechType(v string) *QuerySpeechResponseBodyData {
	s.SpeechType = &v
	return s
}

func (s *QuerySpeechResponseBodyData) SetText(v string) *QuerySpeechResponseBodyData {
	s.Text = &v
	return s
}

func (s *QuerySpeechResponseBodyData) SetVoice(v string) *QuerySpeechResponseBodyData {
	s.Voice = &v
	return s
}

func (s *QuerySpeechResponseBodyData) SetVolume(v int32) *QuerySpeechResponseBodyData {
	s.Volume = &v
	return s
}

type QuerySpeechResponseBodyDataSoundCodeConfig struct {
	AdditionalDuration *int32  `json:"AdditionalDuration,omitempty" xml:"AdditionalDuration,omitempty"`
	SoundCodeContent   *string `json:"SoundCodeContent,omitempty" xml:"SoundCodeContent,omitempty"`
}

func (s QuerySpeechResponseBodyDataSoundCodeConfig) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechResponseBodyDataSoundCodeConfig) GoString() string {
	return s.String()
}

func (s *QuerySpeechResponseBodyDataSoundCodeConfig) SetAdditionalDuration(v int32) *QuerySpeechResponseBodyDataSoundCodeConfig {
	s.AdditionalDuration = &v
	return s
}

func (s *QuerySpeechResponseBodyDataSoundCodeConfig) SetSoundCodeContent(v string) *QuerySpeechResponseBodyDataSoundCodeConfig {
	s.SoundCodeContent = &v
	return s
}

type QuerySpeechResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySpeechResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySpeechResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechResponse) GoString() string {
	return s.String()
}

func (s *QuerySpeechResponse) SetHeaders(v map[string]*string) *QuerySpeechResponse {
	s.Headers = v
	return s
}

func (s *QuerySpeechResponse) SetStatusCode(v int32) *QuerySpeechResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySpeechResponse) SetBody(v *QuerySpeechResponseBody) *QuerySpeechResponse {
	s.Body = v
	return s
}

type QuerySpeechDeviceRequest struct {
	AvailableSpace      *string `json:"AvailableSpace,omitempty" xml:"AvailableSpace,omitempty"`
	AvailableSpaceScope *string `json:"AvailableSpaceScope,omitempty" xml:"AvailableSpaceScope,omitempty"`
	DeviceName          *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotInstanceId       *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageId              *int32  `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize            *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProjectCode         *string `json:"ProjectCode,omitempty" xml:"ProjectCode,omitempty"`
}

func (s QuerySpeechDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechDeviceRequest) GoString() string {
	return s.String()
}

func (s *QuerySpeechDeviceRequest) SetAvailableSpace(v string) *QuerySpeechDeviceRequest {
	s.AvailableSpace = &v
	return s
}

func (s *QuerySpeechDeviceRequest) SetAvailableSpaceScope(v string) *QuerySpeechDeviceRequest {
	s.AvailableSpaceScope = &v
	return s
}

func (s *QuerySpeechDeviceRequest) SetDeviceName(v string) *QuerySpeechDeviceRequest {
	s.DeviceName = &v
	return s
}

func (s *QuerySpeechDeviceRequest) SetIotInstanceId(v string) *QuerySpeechDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySpeechDeviceRequest) SetPageId(v int32) *QuerySpeechDeviceRequest {
	s.PageId = &v
	return s
}

func (s *QuerySpeechDeviceRequest) SetPageSize(v int32) *QuerySpeechDeviceRequest {
	s.PageSize = &v
	return s
}

func (s *QuerySpeechDeviceRequest) SetProjectCode(v string) *QuerySpeechDeviceRequest {
	s.ProjectCode = &v
	return s
}

type QuerySpeechDeviceResponseBody struct {
	Code         *string                            `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySpeechDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                            `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                            `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                              `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySpeechDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySpeechDeviceResponseBody) SetCode(v string) *QuerySpeechDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySpeechDeviceResponseBody) SetData(v *QuerySpeechDeviceResponseBodyData) *QuerySpeechDeviceResponseBody {
	s.Data = v
	return s
}

func (s *QuerySpeechDeviceResponseBody) SetErrorMessage(v string) *QuerySpeechDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySpeechDeviceResponseBody) SetRequestId(v string) *QuerySpeechDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySpeechDeviceResponseBody) SetSuccess(v bool) *QuerySpeechDeviceResponseBody {
	s.Success = &v
	return s
}

type QuerySpeechDeviceResponseBodyData struct {
	List     *QuerySpeechDeviceResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageId   *int32                                 `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize *int32                                 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total    *int32                                 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QuerySpeechDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySpeechDeviceResponseBodyData) SetList(v *QuerySpeechDeviceResponseBodyDataList) *QuerySpeechDeviceResponseBodyData {
	s.List = v
	return s
}

func (s *QuerySpeechDeviceResponseBodyData) SetPageId(v int32) *QuerySpeechDeviceResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QuerySpeechDeviceResponseBodyData) SetPageSize(v int32) *QuerySpeechDeviceResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QuerySpeechDeviceResponseBodyData) SetTotal(v int32) *QuerySpeechDeviceResponseBodyData {
	s.Total = &v
	return s
}

type QuerySpeechDeviceResponseBodyDataList struct {
	Items []*QuerySpeechDeviceResponseBodyDataListItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s QuerySpeechDeviceResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechDeviceResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QuerySpeechDeviceResponseBodyDataList) SetItems(v []*QuerySpeechDeviceResponseBodyDataListItems) *QuerySpeechDeviceResponseBodyDataList {
	s.Items = v
	return s
}

type QuerySpeechDeviceResponseBodyDataListItems struct {
	AvailableSpace *float32 `json:"AvailableSpace,omitempty" xml:"AvailableSpace,omitempty"`
	DeviceName     *string  `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotId          *string  `json:"IotId,omitempty" xml:"IotId,omitempty"`
	ProductKey     *string  `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QuerySpeechDeviceResponseBodyDataListItems) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechDeviceResponseBodyDataListItems) GoString() string {
	return s.String()
}

func (s *QuerySpeechDeviceResponseBodyDataListItems) SetAvailableSpace(v float32) *QuerySpeechDeviceResponseBodyDataListItems {
	s.AvailableSpace = &v
	return s
}

func (s *QuerySpeechDeviceResponseBodyDataListItems) SetDeviceName(v string) *QuerySpeechDeviceResponseBodyDataListItems {
	s.DeviceName = &v
	return s
}

func (s *QuerySpeechDeviceResponseBodyDataListItems) SetIotId(v string) *QuerySpeechDeviceResponseBodyDataListItems {
	s.IotId = &v
	return s
}

func (s *QuerySpeechDeviceResponseBodyDataListItems) SetProductKey(v string) *QuerySpeechDeviceResponseBodyDataListItems {
	s.ProductKey = &v
	return s
}

type QuerySpeechDeviceResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySpeechDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySpeechDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechDeviceResponse) GoString() string {
	return s.String()
}

func (s *QuerySpeechDeviceResponse) SetHeaders(v map[string]*string) *QuerySpeechDeviceResponse {
	s.Headers = v
	return s
}

func (s *QuerySpeechDeviceResponse) SetStatusCode(v int32) *QuerySpeechDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySpeechDeviceResponse) SetBody(v *QuerySpeechDeviceResponseBody) *QuerySpeechDeviceResponse {
	s.Body = v
	return s
}

type QuerySpeechLicenseAvailableQuotaRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s QuerySpeechLicenseAvailableQuotaRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechLicenseAvailableQuotaRequest) GoString() string {
	return s.String()
}

func (s *QuerySpeechLicenseAvailableQuotaRequest) SetIotInstanceId(v string) *QuerySpeechLicenseAvailableQuotaRequest {
	s.IotInstanceId = &v
	return s
}

type QuerySpeechLicenseAvailableQuotaResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *int64  `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySpeechLicenseAvailableQuotaResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechLicenseAvailableQuotaResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySpeechLicenseAvailableQuotaResponseBody) SetCode(v string) *QuerySpeechLicenseAvailableQuotaResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySpeechLicenseAvailableQuotaResponseBody) SetData(v int64) *QuerySpeechLicenseAvailableQuotaResponseBody {
	s.Data = &v
	return s
}

func (s *QuerySpeechLicenseAvailableQuotaResponseBody) SetErrorMessage(v string) *QuerySpeechLicenseAvailableQuotaResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySpeechLicenseAvailableQuotaResponseBody) SetRequestId(v string) *QuerySpeechLicenseAvailableQuotaResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySpeechLicenseAvailableQuotaResponseBody) SetSuccess(v bool) *QuerySpeechLicenseAvailableQuotaResponseBody {
	s.Success = &v
	return s
}

type QuerySpeechLicenseAvailableQuotaResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySpeechLicenseAvailableQuotaResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySpeechLicenseAvailableQuotaResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechLicenseAvailableQuotaResponse) GoString() string {
	return s.String()
}

func (s *QuerySpeechLicenseAvailableQuotaResponse) SetHeaders(v map[string]*string) *QuerySpeechLicenseAvailableQuotaResponse {
	s.Headers = v
	return s
}

func (s *QuerySpeechLicenseAvailableQuotaResponse) SetStatusCode(v int32) *QuerySpeechLicenseAvailableQuotaResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySpeechLicenseAvailableQuotaResponse) SetBody(v *QuerySpeechLicenseAvailableQuotaResponseBody) *QuerySpeechLicenseAvailableQuotaResponse {
	s.Body = v
	return s
}

type QuerySpeechLicenseDeviceListRequest struct {
	// The ID of a device group. The InSpecifiedGroup response parameter indicates whether the devices belong to the specified group.
	CheckGroupId *string `json:"CheckGroupId,omitempty" xml:"CheckGroupId,omitempty"`
	// The keyword in the DeviceName of the device whose information you want to query. Fuzzy match is supported.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  You must specify this parameter for a public instance of the new version or an Enterprise Edition instance. You do not need to specify this parameter for a public instance of the previous version.
	//
	// For more information, see the [Overview](~~356505~~) topic of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The license status.
	//
	// *   **NORMAL**: The license is valid.
	// *   **EXPIRE**: The license is expired.
	// *   **EXPIRING**: The license is about to expire.
	LicenseStatusList []*string `json:"LicenseStatusList,omitempty" xml:"LicenseStatusList,omitempty" type:"Repeated"`
	// The page number. Valid values: 1 to 10000.
	PageId *int32 `json:"PageId,omitempty" xml:"PageId,omitempty"`
	// The number of entries per page. Valid values: 1 to 50. Default value: 20.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The **ProductKey** of the product to which the devices belong.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QuerySpeechLicenseDeviceListRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechLicenseDeviceListRequest) GoString() string {
	return s.String()
}

func (s *QuerySpeechLicenseDeviceListRequest) SetCheckGroupId(v string) *QuerySpeechLicenseDeviceListRequest {
	s.CheckGroupId = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListRequest) SetDeviceName(v string) *QuerySpeechLicenseDeviceListRequest {
	s.DeviceName = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListRequest) SetIotInstanceId(v string) *QuerySpeechLicenseDeviceListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListRequest) SetLicenseStatusList(v []*string) *QuerySpeechLicenseDeviceListRequest {
	s.LicenseStatusList = v
	return s
}

func (s *QuerySpeechLicenseDeviceListRequest) SetPageId(v int32) *QuerySpeechLicenseDeviceListRequest {
	s.PageId = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListRequest) SetPageSize(v int32) *QuerySpeechLicenseDeviceListRequest {
	s.PageSize = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListRequest) SetProductKey(v string) *QuerySpeechLicenseDeviceListRequest {
	s.ProductKey = &v
	return s
}

type QuerySpeechLicenseDeviceListResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the request.
	Data *QuerySpeechLicenseDeviceListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySpeechLicenseDeviceListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechLicenseDeviceListResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySpeechLicenseDeviceListResponseBody) SetCode(v string) *QuerySpeechLicenseDeviceListResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponseBody) SetData(v *QuerySpeechLicenseDeviceListResponseBodyData) *QuerySpeechLicenseDeviceListResponseBody {
	s.Data = v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponseBody) SetErrorMessage(v string) *QuerySpeechLicenseDeviceListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponseBody) SetRequestId(v string) *QuerySpeechLicenseDeviceListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponseBody) SetSuccess(v bool) *QuerySpeechLicenseDeviceListResponseBody {
	s.Success = &v
	return s
}

type QuerySpeechLicenseDeviceListResponseBodyData struct {
	// The information about devices.
	DeviceList *QuerySpeechLicenseDeviceListResponseBodyDataDeviceList `json:"DeviceList,omitempty" xml:"DeviceList,omitempty" type:"Struct"`
	// The page number.
	PageId *int32 `json:"PageId,omitempty" xml:"PageId,omitempty"`
	// The number of entries per page.
	PageSize *int32 `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	// The total number of entries returned.
	Total *int32 `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QuerySpeechLicenseDeviceListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechLicenseDeviceListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySpeechLicenseDeviceListResponseBodyData) SetDeviceList(v *QuerySpeechLicenseDeviceListResponseBodyDataDeviceList) *QuerySpeechLicenseDeviceListResponseBodyData {
	s.DeviceList = v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponseBodyData) SetPageId(v int32) *QuerySpeechLicenseDeviceListResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponseBodyData) SetPageSize(v int32) *QuerySpeechLicenseDeviceListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponseBodyData) SetTotal(v int32) *QuerySpeechLicenseDeviceListResponseBodyData {
	s.Total = &v
	return s
}

type QuerySpeechLicenseDeviceListResponseBodyDataDeviceList struct {
	Item []*QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem `json:"item,omitempty" xml:"item,omitempty" type:"Repeated"`
}

func (s QuerySpeechLicenseDeviceListResponseBodyDataDeviceList) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechLicenseDeviceListResponseBodyDataDeviceList) GoString() string {
	return s.String()
}

func (s *QuerySpeechLicenseDeviceListResponseBodyDataDeviceList) SetItem(v []*QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem) *QuerySpeechLicenseDeviceListResponseBodyDataDeviceList {
	s.Item = v
	return s
}

type QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem struct {
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The status of the device.
	//
	// *   **ONLINE**: The device is online.
	// *   **OFFLINE**: The device is offline.
	// *   **UNACTIVE**: The device is not activated.
	// *   **DISABLE**: The device is disabled.
	// *   **DELETE**: The device is deleted.
	DeviceStatus *string `json:"DeviceStatus,omitempty" xml:"DeviceStatus,omitempty"`
	// The expiration time of the license.
	ExpiryTime *int64 `json:"ExpiryTime,omitempty" xml:"ExpiryTime,omitempty"`
	// Indicates whether the device belongs to the specified device group.
	InSpecifiedGroup *bool `json:"InSpecifiedGroup,omitempty" xml:"InSpecifiedGroup,omitempty"`
	// The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The license status.
	//
	// *   **NORMAL**: The license is valid.
	// *   **EXPIRE**: The license is expired.
	// *   **EXPIRING**: The license is about to expire.
	LicenseStatus *string `json:"LicenseStatus,omitempty" xml:"LicenseStatus,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ProductName of the product to which the device belongs.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
}

func (s QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem) GoString() string {
	return s.String()
}

func (s *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem) SetDeviceName(v string) *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem {
	s.DeviceName = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem) SetDeviceStatus(v string) *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem {
	s.DeviceStatus = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem) SetExpiryTime(v int64) *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem {
	s.ExpiryTime = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem) SetInSpecifiedGroup(v bool) *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem {
	s.InSpecifiedGroup = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem) SetIotId(v string) *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem {
	s.IotId = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem) SetLicenseStatus(v string) *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem {
	s.LicenseStatus = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem) SetProductKey(v string) *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem {
	s.ProductKey = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem) SetProductName(v string) *QuerySpeechLicenseDeviceListResponseBodyDataDeviceListItem {
	s.ProductName = &v
	return s
}

type QuerySpeechLicenseDeviceListResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySpeechLicenseDeviceListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySpeechLicenseDeviceListResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechLicenseDeviceListResponse) GoString() string {
	return s.String()
}

func (s *QuerySpeechLicenseDeviceListResponse) SetHeaders(v map[string]*string) *QuerySpeechLicenseDeviceListResponse {
	s.Headers = v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponse) SetStatusCode(v int32) *QuerySpeechLicenseDeviceListResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySpeechLicenseDeviceListResponse) SetBody(v *QuerySpeechLicenseDeviceListResponseBody) *QuerySpeechLicenseDeviceListResponse {
	s.Body = v
	return s
}

type QuerySpeechListRequest struct {
	AudioFormat   *string `json:"AudioFormat,omitempty" xml:"AudioFormat,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageId        *int32  `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProjectCode   *string `json:"ProjectCode,omitempty" xml:"ProjectCode,omitempty"`
}

func (s QuerySpeechListRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechListRequest) GoString() string {
	return s.String()
}

func (s *QuerySpeechListRequest) SetAudioFormat(v string) *QuerySpeechListRequest {
	s.AudioFormat = &v
	return s
}

func (s *QuerySpeechListRequest) SetIotInstanceId(v string) *QuerySpeechListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySpeechListRequest) SetPageId(v int32) *QuerySpeechListRequest {
	s.PageId = &v
	return s
}

func (s *QuerySpeechListRequest) SetPageSize(v int32) *QuerySpeechListRequest {
	s.PageSize = &v
	return s
}

func (s *QuerySpeechListRequest) SetProjectCode(v string) *QuerySpeechListRequest {
	s.ProjectCode = &v
	return s
}

type QuerySpeechListResponseBody struct {
	Code         *string                          `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySpeechListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                          `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                          `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                            `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySpeechListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechListResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySpeechListResponseBody) SetCode(v string) *QuerySpeechListResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySpeechListResponseBody) SetData(v *QuerySpeechListResponseBodyData) *QuerySpeechListResponseBody {
	s.Data = v
	return s
}

func (s *QuerySpeechListResponseBody) SetErrorMessage(v string) *QuerySpeechListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySpeechListResponseBody) SetRequestId(v string) *QuerySpeechListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySpeechListResponseBody) SetSuccess(v bool) *QuerySpeechListResponseBody {
	s.Success = &v
	return s
}

type QuerySpeechListResponseBodyData struct {
	List     *QuerySpeechListResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageId   *int32                               `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize *int32                               `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total    *int32                               `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QuerySpeechListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySpeechListResponseBodyData) SetList(v *QuerySpeechListResponseBodyDataList) *QuerySpeechListResponseBodyData {
	s.List = v
	return s
}

func (s *QuerySpeechListResponseBodyData) SetPageId(v int32) *QuerySpeechListResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QuerySpeechListResponseBodyData) SetPageSize(v int32) *QuerySpeechListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QuerySpeechListResponseBodyData) SetTotal(v int32) *QuerySpeechListResponseBodyData {
	s.Total = &v
	return s
}

type QuerySpeechListResponseBodyDataList struct {
	Items []*QuerySpeechListResponseBodyDataListItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s QuerySpeechListResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechListResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QuerySpeechListResponseBodyDataList) SetItems(v []*QuerySpeechListResponseBodyDataListItems) *QuerySpeechListResponseBodyDataList {
	s.Items = v
	return s
}

type QuerySpeechListResponseBodyDataListItems struct {
	AudioFormat *string                                             `json:"AudioFormat,omitempty" xml:"AudioFormat,omitempty"`
	BizCode     *string                                             `json:"BizCode,omitempty" xml:"BizCode,omitempty"`
	SpeechCode  *string                                             `json:"SpeechCode,omitempty" xml:"SpeechCode,omitempty"`
	SpeechList  *QuerySpeechListResponseBodyDataListItemsSpeechList `json:"SpeechList,omitempty" xml:"SpeechList,omitempty" type:"Struct"`
	SpeechType  *string                                             `json:"SpeechType,omitempty" xml:"SpeechType,omitempty"`
	Text        *string                                             `json:"Text,omitempty" xml:"Text,omitempty"`
	Voice       *string                                             `json:"Voice,omitempty" xml:"Voice,omitempty"`
}

func (s QuerySpeechListResponseBodyDataListItems) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechListResponseBodyDataListItems) GoString() string {
	return s.String()
}

func (s *QuerySpeechListResponseBodyDataListItems) SetAudioFormat(v string) *QuerySpeechListResponseBodyDataListItems {
	s.AudioFormat = &v
	return s
}

func (s *QuerySpeechListResponseBodyDataListItems) SetBizCode(v string) *QuerySpeechListResponseBodyDataListItems {
	s.BizCode = &v
	return s
}

func (s *QuerySpeechListResponseBodyDataListItems) SetSpeechCode(v string) *QuerySpeechListResponseBodyDataListItems {
	s.SpeechCode = &v
	return s
}

func (s *QuerySpeechListResponseBodyDataListItems) SetSpeechList(v *QuerySpeechListResponseBodyDataListItemsSpeechList) *QuerySpeechListResponseBodyDataListItems {
	s.SpeechList = v
	return s
}

func (s *QuerySpeechListResponseBodyDataListItems) SetSpeechType(v string) *QuerySpeechListResponseBodyDataListItems {
	s.SpeechType = &v
	return s
}

func (s *QuerySpeechListResponseBodyDataListItems) SetText(v string) *QuerySpeechListResponseBodyDataListItems {
	s.Text = &v
	return s
}

func (s *QuerySpeechListResponseBodyDataListItems) SetVoice(v string) *QuerySpeechListResponseBodyDataListItems {
	s.Voice = &v
	return s
}

type QuerySpeechListResponseBodyDataListItemsSpeechList struct {
	Items []*QuerySpeechListResponseBodyDataListItemsSpeechListItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s QuerySpeechListResponseBodyDataListItemsSpeechList) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechListResponseBodyDataListItemsSpeechList) GoString() string {
	return s.String()
}

func (s *QuerySpeechListResponseBodyDataListItemsSpeechList) SetItems(v []*QuerySpeechListResponseBodyDataListItemsSpeechListItems) *QuerySpeechListResponseBodyDataListItemsSpeechList {
	s.Items = v
	return s
}

type QuerySpeechListResponseBodyDataListItemsSpeechListItems struct {
	BizCode    *string `json:"BizCode,omitempty" xml:"BizCode,omitempty"`
	SpeechCode *string `json:"SpeechCode,omitempty" xml:"SpeechCode,omitempty"`
	Text       *string `json:"Text,omitempty" xml:"Text,omitempty"`
	Voice      *string `json:"Voice,omitempty" xml:"Voice,omitempty"`
}

func (s QuerySpeechListResponseBodyDataListItemsSpeechListItems) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechListResponseBodyDataListItemsSpeechListItems) GoString() string {
	return s.String()
}

func (s *QuerySpeechListResponseBodyDataListItemsSpeechListItems) SetBizCode(v string) *QuerySpeechListResponseBodyDataListItemsSpeechListItems {
	s.BizCode = &v
	return s
}

func (s *QuerySpeechListResponseBodyDataListItemsSpeechListItems) SetSpeechCode(v string) *QuerySpeechListResponseBodyDataListItemsSpeechListItems {
	s.SpeechCode = &v
	return s
}

func (s *QuerySpeechListResponseBodyDataListItemsSpeechListItems) SetText(v string) *QuerySpeechListResponseBodyDataListItemsSpeechListItems {
	s.Text = &v
	return s
}

func (s *QuerySpeechListResponseBodyDataListItemsSpeechListItems) SetVoice(v string) *QuerySpeechListResponseBodyDataListItemsSpeechListItems {
	s.Voice = &v
	return s
}

type QuerySpeechListResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySpeechListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySpeechListResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechListResponse) GoString() string {
	return s.String()
}

func (s *QuerySpeechListResponse) SetHeaders(v map[string]*string) *QuerySpeechListResponse {
	s.Headers = v
	return s
}

func (s *QuerySpeechListResponse) SetStatusCode(v int32) *QuerySpeechListResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySpeechListResponse) SetBody(v *QuerySpeechListResponseBody) *QuerySpeechListResponse {
	s.Body = v
	return s
}

type QuerySpeechPushJobRequest struct {
	IotInstanceId *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	JobCode       *string   `json:"JobCode,omitempty" xml:"JobCode,omitempty"`
	PageId        *int32    `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize      *int32    `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProjectCode   *string   `json:"ProjectCode,omitempty" xml:"ProjectCode,omitempty"`
	PushMode      *string   `json:"PushMode,omitempty" xml:"PushMode,omitempty"`
	StatusList    []*string `json:"StatusList,omitempty" xml:"StatusList,omitempty" type:"Repeated"`
}

func (s QuerySpeechPushJobRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobRequest) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobRequest) SetIotInstanceId(v string) *QuerySpeechPushJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySpeechPushJobRequest) SetJobCode(v string) *QuerySpeechPushJobRequest {
	s.JobCode = &v
	return s
}

func (s *QuerySpeechPushJobRequest) SetPageId(v int32) *QuerySpeechPushJobRequest {
	s.PageId = &v
	return s
}

func (s *QuerySpeechPushJobRequest) SetPageSize(v int32) *QuerySpeechPushJobRequest {
	s.PageSize = &v
	return s
}

func (s *QuerySpeechPushJobRequest) SetProjectCode(v string) *QuerySpeechPushJobRequest {
	s.ProjectCode = &v
	return s
}

func (s *QuerySpeechPushJobRequest) SetPushMode(v string) *QuerySpeechPushJobRequest {
	s.PushMode = &v
	return s
}

func (s *QuerySpeechPushJobRequest) SetStatusList(v []*string) *QuerySpeechPushJobRequest {
	s.StatusList = v
	return s
}

type QuerySpeechPushJobResponseBody struct {
	Code         *string                             `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySpeechPushJobResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                             `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                               `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySpeechPushJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobResponseBody) SetCode(v string) *QuerySpeechPushJobResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySpeechPushJobResponseBody) SetData(v *QuerySpeechPushJobResponseBodyData) *QuerySpeechPushJobResponseBody {
	s.Data = v
	return s
}

func (s *QuerySpeechPushJobResponseBody) SetErrorMessage(v string) *QuerySpeechPushJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySpeechPushJobResponseBody) SetRequestId(v string) *QuerySpeechPushJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySpeechPushJobResponseBody) SetSuccess(v bool) *QuerySpeechPushJobResponseBody {
	s.Success = &v
	return s
}

type QuerySpeechPushJobResponseBodyData struct {
	List     *QuerySpeechPushJobResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageId   *int32                                  `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize *int32                                  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total    *int32                                  `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QuerySpeechPushJobResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobResponseBodyData) SetList(v *QuerySpeechPushJobResponseBodyDataList) *QuerySpeechPushJobResponseBodyData {
	s.List = v
	return s
}

func (s *QuerySpeechPushJobResponseBodyData) SetPageId(v int32) *QuerySpeechPushJobResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyData) SetPageSize(v int32) *QuerySpeechPushJobResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyData) SetTotal(v int32) *QuerySpeechPushJobResponseBodyData {
	s.Total = &v
	return s
}

type QuerySpeechPushJobResponseBodyDataList struct {
	Items []*QuerySpeechPushJobResponseBodyDataListItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s QuerySpeechPushJobResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobResponseBodyDataList) SetItems(v []*QuerySpeechPushJobResponseBodyDataListItems) *QuerySpeechPushJobResponseBodyDataList {
	s.Items = v
	return s
}

type QuerySpeechPushJobResponseBodyDataListItems struct {
	Code             *string `json:"Code,omitempty" xml:"Code,omitempty"`
	CreatedTime      *int64  `json:"CreatedTime,omitempty" xml:"CreatedTime,omitempty"`
	DeviceName       *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	ExpiredTime      *int64  `json:"ExpiredTime,omitempty" xml:"ExpiredTime,omitempty"`
	FailDeviceNum    *int32  `json:"FailDeviceNum,omitempty" xml:"FailDeviceNum,omitempty"`
	GroupId          *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	GroupName        *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
	IotId            *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	ProductKey       *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	PushMode         *string `json:"PushMode,omitempty" xml:"PushMode,omitempty"`
	RunningDeviceNum *int32  `json:"RunningDeviceNum,omitempty" xml:"RunningDeviceNum,omitempty"`
	SpeechNum        *int32  `json:"SpeechNum,omitempty" xml:"SpeechNum,omitempty"`
	SpeechStatus     *bool   `json:"SpeechStatus,omitempty" xml:"SpeechStatus,omitempty"`
	Status           *string `json:"Status,omitempty" xml:"Status,omitempty"`
	SuccessDeviceNum *int32  `json:"SuccessDeviceNum,omitempty" xml:"SuccessDeviceNum,omitempty"`
	TotalDeviceNum   *int32  `json:"TotalDeviceNum,omitempty" xml:"TotalDeviceNum,omitempty"`
}

func (s QuerySpeechPushJobResponseBodyDataListItems) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobResponseBodyDataListItems) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetCode(v string) *QuerySpeechPushJobResponseBodyDataListItems {
	s.Code = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetCreatedTime(v int64) *QuerySpeechPushJobResponseBodyDataListItems {
	s.CreatedTime = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetDeviceName(v string) *QuerySpeechPushJobResponseBodyDataListItems {
	s.DeviceName = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetExpiredTime(v int64) *QuerySpeechPushJobResponseBodyDataListItems {
	s.ExpiredTime = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetFailDeviceNum(v int32) *QuerySpeechPushJobResponseBodyDataListItems {
	s.FailDeviceNum = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetGroupId(v string) *QuerySpeechPushJobResponseBodyDataListItems {
	s.GroupId = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetGroupName(v string) *QuerySpeechPushJobResponseBodyDataListItems {
	s.GroupName = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetIotId(v string) *QuerySpeechPushJobResponseBodyDataListItems {
	s.IotId = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetProductKey(v string) *QuerySpeechPushJobResponseBodyDataListItems {
	s.ProductKey = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetPushMode(v string) *QuerySpeechPushJobResponseBodyDataListItems {
	s.PushMode = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetRunningDeviceNum(v int32) *QuerySpeechPushJobResponseBodyDataListItems {
	s.RunningDeviceNum = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetSpeechNum(v int32) *QuerySpeechPushJobResponseBodyDataListItems {
	s.SpeechNum = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetSpeechStatus(v bool) *QuerySpeechPushJobResponseBodyDataListItems {
	s.SpeechStatus = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetStatus(v string) *QuerySpeechPushJobResponseBodyDataListItems {
	s.Status = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetSuccessDeviceNum(v int32) *QuerySpeechPushJobResponseBodyDataListItems {
	s.SuccessDeviceNum = &v
	return s
}

func (s *QuerySpeechPushJobResponseBodyDataListItems) SetTotalDeviceNum(v int32) *QuerySpeechPushJobResponseBodyDataListItems {
	s.TotalDeviceNum = &v
	return s
}

type QuerySpeechPushJobResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySpeechPushJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySpeechPushJobResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobResponse) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobResponse) SetHeaders(v map[string]*string) *QuerySpeechPushJobResponse {
	s.Headers = v
	return s
}

func (s *QuerySpeechPushJobResponse) SetStatusCode(v int32) *QuerySpeechPushJobResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySpeechPushJobResponse) SetBody(v *QuerySpeechPushJobResponseBody) *QuerySpeechPushJobResponse {
	s.Body = v
	return s
}

type QuerySpeechPushJobDeviceRequest struct {
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	JobCode       *string `json:"JobCode,omitempty" xml:"JobCode,omitempty"`
	PageId        *int32  `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Status        *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s QuerySpeechPushJobDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobDeviceRequest) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobDeviceRequest) SetDeviceName(v string) *QuerySpeechPushJobDeviceRequest {
	s.DeviceName = &v
	return s
}

func (s *QuerySpeechPushJobDeviceRequest) SetIotInstanceId(v string) *QuerySpeechPushJobDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySpeechPushJobDeviceRequest) SetJobCode(v string) *QuerySpeechPushJobDeviceRequest {
	s.JobCode = &v
	return s
}

func (s *QuerySpeechPushJobDeviceRequest) SetPageId(v int32) *QuerySpeechPushJobDeviceRequest {
	s.PageId = &v
	return s
}

func (s *QuerySpeechPushJobDeviceRequest) SetPageSize(v int32) *QuerySpeechPushJobDeviceRequest {
	s.PageSize = &v
	return s
}

func (s *QuerySpeechPushJobDeviceRequest) SetStatus(v string) *QuerySpeechPushJobDeviceRequest {
	s.Status = &v
	return s
}

type QuerySpeechPushJobDeviceResponseBody struct {
	Code         *string                                   `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySpeechPushJobDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                   `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                     `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySpeechPushJobDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobDeviceResponseBody) SetCode(v string) *QuerySpeechPushJobDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySpeechPushJobDeviceResponseBody) SetData(v *QuerySpeechPushJobDeviceResponseBodyData) *QuerySpeechPushJobDeviceResponseBody {
	s.Data = v
	return s
}

func (s *QuerySpeechPushJobDeviceResponseBody) SetErrorMessage(v string) *QuerySpeechPushJobDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySpeechPushJobDeviceResponseBody) SetRequestId(v string) *QuerySpeechPushJobDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySpeechPushJobDeviceResponseBody) SetSuccess(v bool) *QuerySpeechPushJobDeviceResponseBody {
	s.Success = &v
	return s
}

type QuerySpeechPushJobDeviceResponseBodyData struct {
	List     *QuerySpeechPushJobDeviceResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageId   *int32                                        `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize *int32                                        `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total    *int32                                        `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QuerySpeechPushJobDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobDeviceResponseBodyData) SetList(v *QuerySpeechPushJobDeviceResponseBodyDataList) *QuerySpeechPushJobDeviceResponseBodyData {
	s.List = v
	return s
}

func (s *QuerySpeechPushJobDeviceResponseBodyData) SetPageId(v int32) *QuerySpeechPushJobDeviceResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QuerySpeechPushJobDeviceResponseBodyData) SetPageSize(v int32) *QuerySpeechPushJobDeviceResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QuerySpeechPushJobDeviceResponseBodyData) SetTotal(v int32) *QuerySpeechPushJobDeviceResponseBodyData {
	s.Total = &v
	return s
}

type QuerySpeechPushJobDeviceResponseBodyDataList struct {
	Items []*QuerySpeechPushJobDeviceResponseBodyDataListItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s QuerySpeechPushJobDeviceResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobDeviceResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobDeviceResponseBodyDataList) SetItems(v []*QuerySpeechPushJobDeviceResponseBodyDataListItems) *QuerySpeechPushJobDeviceResponseBodyDataList {
	s.Items = v
	return s
}

type QuerySpeechPushJobDeviceResponseBodyDataListItems struct {
	DeviceName   *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	ErrorCode    *string `json:"ErrorCode,omitempty" xml:"ErrorCode,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	GmtModified  *int64  `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	Status       *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s QuerySpeechPushJobDeviceResponseBodyDataListItems) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobDeviceResponseBodyDataListItems) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobDeviceResponseBodyDataListItems) SetDeviceName(v string) *QuerySpeechPushJobDeviceResponseBodyDataListItems {
	s.DeviceName = &v
	return s
}

func (s *QuerySpeechPushJobDeviceResponseBodyDataListItems) SetErrorCode(v string) *QuerySpeechPushJobDeviceResponseBodyDataListItems {
	s.ErrorCode = &v
	return s
}

func (s *QuerySpeechPushJobDeviceResponseBodyDataListItems) SetErrorMessage(v string) *QuerySpeechPushJobDeviceResponseBodyDataListItems {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySpeechPushJobDeviceResponseBodyDataListItems) SetGmtModified(v int64) *QuerySpeechPushJobDeviceResponseBodyDataListItems {
	s.GmtModified = &v
	return s
}

func (s *QuerySpeechPushJobDeviceResponseBodyDataListItems) SetStatus(v string) *QuerySpeechPushJobDeviceResponseBodyDataListItems {
	s.Status = &v
	return s
}

type QuerySpeechPushJobDeviceResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySpeechPushJobDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySpeechPushJobDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobDeviceResponse) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobDeviceResponse) SetHeaders(v map[string]*string) *QuerySpeechPushJobDeviceResponse {
	s.Headers = v
	return s
}

func (s *QuerySpeechPushJobDeviceResponse) SetStatusCode(v int32) *QuerySpeechPushJobDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySpeechPushJobDeviceResponse) SetBody(v *QuerySpeechPushJobDeviceResponseBody) *QuerySpeechPushJobDeviceResponse {
	s.Body = v
	return s
}

type QuerySpeechPushJobSpeechRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	JobCode       *string `json:"JobCode,omitempty" xml:"JobCode,omitempty"`
	PageId        *int32  `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QuerySpeechPushJobSpeechRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobSpeechRequest) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobSpeechRequest) SetIotInstanceId(v string) *QuerySpeechPushJobSpeechRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySpeechPushJobSpeechRequest) SetJobCode(v string) *QuerySpeechPushJobSpeechRequest {
	s.JobCode = &v
	return s
}

func (s *QuerySpeechPushJobSpeechRequest) SetPageId(v int32) *QuerySpeechPushJobSpeechRequest {
	s.PageId = &v
	return s
}

func (s *QuerySpeechPushJobSpeechRequest) SetPageSize(v int32) *QuerySpeechPushJobSpeechRequest {
	s.PageSize = &v
	return s
}

type QuerySpeechPushJobSpeechResponseBody struct {
	Code         *string                                   `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySpeechPushJobSpeechResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                   `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                     `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySpeechPushJobSpeechResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobSpeechResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobSpeechResponseBody) SetCode(v string) *QuerySpeechPushJobSpeechResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySpeechPushJobSpeechResponseBody) SetData(v *QuerySpeechPushJobSpeechResponseBodyData) *QuerySpeechPushJobSpeechResponseBody {
	s.Data = v
	return s
}

func (s *QuerySpeechPushJobSpeechResponseBody) SetErrorMessage(v string) *QuerySpeechPushJobSpeechResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySpeechPushJobSpeechResponseBody) SetRequestId(v string) *QuerySpeechPushJobSpeechResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySpeechPushJobSpeechResponseBody) SetSuccess(v bool) *QuerySpeechPushJobSpeechResponseBody {
	s.Success = &v
	return s
}

type QuerySpeechPushJobSpeechResponseBodyData struct {
	List     *QuerySpeechPushJobSpeechResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageId   *int32                                        `json:"PageId,omitempty" xml:"PageId,omitempty"`
	PageSize *int32                                        `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total    *int32                                        `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QuerySpeechPushJobSpeechResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobSpeechResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobSpeechResponseBodyData) SetList(v *QuerySpeechPushJobSpeechResponseBodyDataList) *QuerySpeechPushJobSpeechResponseBodyData {
	s.List = v
	return s
}

func (s *QuerySpeechPushJobSpeechResponseBodyData) SetPageId(v int32) *QuerySpeechPushJobSpeechResponseBodyData {
	s.PageId = &v
	return s
}

func (s *QuerySpeechPushJobSpeechResponseBodyData) SetPageSize(v int32) *QuerySpeechPushJobSpeechResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QuerySpeechPushJobSpeechResponseBodyData) SetTotal(v int32) *QuerySpeechPushJobSpeechResponseBodyData {
	s.Total = &v
	return s
}

type QuerySpeechPushJobSpeechResponseBodyDataList struct {
	Items []*QuerySpeechPushJobSpeechResponseBodyDataListItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s QuerySpeechPushJobSpeechResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobSpeechResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobSpeechResponseBodyDataList) SetItems(v []*QuerySpeechPushJobSpeechResponseBodyDataListItems) *QuerySpeechPushJobSpeechResponseBodyDataList {
	s.Items = v
	return s
}

type QuerySpeechPushJobSpeechResponseBodyDataListItems struct {
	BizCode    *string                                                      `json:"BizCode,omitempty" xml:"BizCode,omitempty"`
	SpeechList *QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList `json:"SpeechList,omitempty" xml:"SpeechList,omitempty" type:"Struct"`
	SpeechType *string                                                      `json:"SpeechType,omitempty" xml:"SpeechType,omitempty"`
	Text       *string                                                      `json:"Text,omitempty" xml:"Text,omitempty"`
	Voice      *string                                                      `json:"Voice,omitempty" xml:"Voice,omitempty"`
}

func (s QuerySpeechPushJobSpeechResponseBodyDataListItems) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobSpeechResponseBodyDataListItems) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobSpeechResponseBodyDataListItems) SetBizCode(v string) *QuerySpeechPushJobSpeechResponseBodyDataListItems {
	s.BizCode = &v
	return s
}

func (s *QuerySpeechPushJobSpeechResponseBodyDataListItems) SetSpeechList(v *QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList) *QuerySpeechPushJobSpeechResponseBodyDataListItems {
	s.SpeechList = v
	return s
}

func (s *QuerySpeechPushJobSpeechResponseBodyDataListItems) SetSpeechType(v string) *QuerySpeechPushJobSpeechResponseBodyDataListItems {
	s.SpeechType = &v
	return s
}

func (s *QuerySpeechPushJobSpeechResponseBodyDataListItems) SetText(v string) *QuerySpeechPushJobSpeechResponseBodyDataListItems {
	s.Text = &v
	return s
}

func (s *QuerySpeechPushJobSpeechResponseBodyDataListItems) SetVoice(v string) *QuerySpeechPushJobSpeechResponseBodyDataListItems {
	s.Voice = &v
	return s
}

type QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList struct {
	Items []*QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems `json:"Items,omitempty" xml:"Items,omitempty" type:"Repeated"`
}

func (s QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList) SetItems(v []*QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems) *QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechList {
	s.Items = v
	return s
}

type QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems struct {
	BizCode *string `json:"BizCode,omitempty" xml:"BizCode,omitempty"`
	Text    *string `json:"Text,omitempty" xml:"Text,omitempty"`
	Voice   *string `json:"Voice,omitempty" xml:"Voice,omitempty"`
}

func (s QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems) SetBizCode(v string) *QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems {
	s.BizCode = &v
	return s
}

func (s *QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems) SetText(v string) *QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems {
	s.Text = &v
	return s
}

func (s *QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems) SetVoice(v string) *QuerySpeechPushJobSpeechResponseBodyDataListItemsSpeechListItems {
	s.Voice = &v
	return s
}

type QuerySpeechPushJobSpeechResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySpeechPushJobSpeechResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySpeechPushJobSpeechResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySpeechPushJobSpeechResponse) GoString() string {
	return s.String()
}

func (s *QuerySpeechPushJobSpeechResponse) SetHeaders(v map[string]*string) *QuerySpeechPushJobSpeechResponse {
	s.Headers = v
	return s
}

func (s *QuerySpeechPushJobSpeechResponse) SetStatusCode(v int32) *QuerySpeechPushJobSpeechResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySpeechPushJobSpeechResponse) SetBody(v *QuerySpeechPushJobSpeechResponseBody) *QuerySpeechPushJobSpeechResponse {
	s.Body = v
	return s
}

type QueryStudioAppDomainListOpenRequest struct {
	AppId         *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProjectId     *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s QueryStudioAppDomainListOpenRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppDomainListOpenRequest) GoString() string {
	return s.String()
}

func (s *QueryStudioAppDomainListOpenRequest) SetAppId(v string) *QueryStudioAppDomainListOpenRequest {
	s.AppId = &v
	return s
}

func (s *QueryStudioAppDomainListOpenRequest) SetIotInstanceId(v string) *QueryStudioAppDomainListOpenRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryStudioAppDomainListOpenRequest) SetProjectId(v string) *QueryStudioAppDomainListOpenRequest {
	s.ProjectId = &v
	return s
}

type QueryStudioAppDomainListOpenResponseBody struct {
	Code         *string                                       `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryStudioAppDomainListOpenResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                       `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                       `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                         `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryStudioAppDomainListOpenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppDomainListOpenResponseBody) GoString() string {
	return s.String()
}

func (s *QueryStudioAppDomainListOpenResponseBody) SetCode(v string) *QueryStudioAppDomainListOpenResponseBody {
	s.Code = &v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBody) SetData(v *QueryStudioAppDomainListOpenResponseBodyData) *QueryStudioAppDomainListOpenResponseBody {
	s.Data = v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBody) SetErrorMessage(v string) *QueryStudioAppDomainListOpenResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBody) SetRequestId(v string) *QueryStudioAppDomainListOpenResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBody) SetSuccess(v bool) *QueryStudioAppDomainListOpenResponseBody {
	s.Success = &v
	return s
}

type QueryStudioAppDomainListOpenResponseBodyData struct {
	List      *QueryStudioAppDomainListOpenResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageNo    *int32                                            `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	PageSize  *int32                                            `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total     *int32                                            `json:"Total,omitempty" xml:"Total,omitempty"`
	TotalPage *int32                                            `json:"TotalPage,omitempty" xml:"TotalPage,omitempty"`
}

func (s QueryStudioAppDomainListOpenResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppDomainListOpenResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryStudioAppDomainListOpenResponseBodyData) SetList(v *QueryStudioAppDomainListOpenResponseBodyDataList) *QueryStudioAppDomainListOpenResponseBodyData {
	s.List = v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBodyData) SetPageNo(v int32) *QueryStudioAppDomainListOpenResponseBodyData {
	s.PageNo = &v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBodyData) SetPageSize(v int32) *QueryStudioAppDomainListOpenResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBodyData) SetTotal(v int32) *QueryStudioAppDomainListOpenResponseBodyData {
	s.Total = &v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBodyData) SetTotalPage(v int32) *QueryStudioAppDomainListOpenResponseBodyData {
	s.TotalPage = &v
	return s
}

type QueryStudioAppDomainListOpenResponseBodyDataList struct {
	DomainInfo []*QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo `json:"DomainInfo,omitempty" xml:"DomainInfo,omitempty" type:"Repeated"`
}

func (s QueryStudioAppDomainListOpenResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppDomainListOpenResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryStudioAppDomainListOpenResponseBodyDataList) SetDomainInfo(v []*QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo) *QueryStudioAppDomainListOpenResponseBodyDataList {
	s.DomainInfo = v
	return s
}

type QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo struct {
	AppId       *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	GmtCreate   *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	Host        *string `json:"Host,omitempty" xml:"Host,omitempty"`
	Id          *int32  `json:"Id,omitempty" xml:"Id,omitempty"`
	IsBeian     *string `json:"IsBeian,omitempty" xml:"IsBeian,omitempty"`
	ProjectId   *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	Protocol    *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
	TenantId    *string `json:"TenantId,omitempty" xml:"TenantId,omitempty"`
}

func (s QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo) GoString() string {
	return s.String()
}

func (s *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo) SetAppId(v string) *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo {
	s.AppId = &v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo) SetGmtCreate(v string) *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo {
	s.GmtCreate = &v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo) SetGmtModified(v string) *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo {
	s.GmtModified = &v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo) SetHost(v string) *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo {
	s.Host = &v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo) SetId(v int32) *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo {
	s.Id = &v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo) SetIsBeian(v string) *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo {
	s.IsBeian = &v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo) SetProjectId(v string) *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo {
	s.ProjectId = &v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo) SetProtocol(v string) *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo {
	s.Protocol = &v
	return s
}

func (s *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo) SetTenantId(v string) *QueryStudioAppDomainListOpenResponseBodyDataListDomainInfo {
	s.TenantId = &v
	return s
}

type QueryStudioAppDomainListOpenResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryStudioAppDomainListOpenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryStudioAppDomainListOpenResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppDomainListOpenResponse) GoString() string {
	return s.String()
}

func (s *QueryStudioAppDomainListOpenResponse) SetHeaders(v map[string]*string) *QueryStudioAppDomainListOpenResponse {
	s.Headers = v
	return s
}

func (s *QueryStudioAppDomainListOpenResponse) SetStatusCode(v int32) *QueryStudioAppDomainListOpenResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryStudioAppDomainListOpenResponse) SetBody(v *QueryStudioAppDomainListOpenResponseBody) *QueryStudioAppDomainListOpenResponse {
	s.Body = v
	return s
}

type QueryStudioAppListRequest struct {
	FuzzyName     *string   `json:"FuzzyName,omitempty" xml:"FuzzyName,omitempty"`
	IotInstanceId *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageNo        *int32    `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	PageSize      *int32    `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProjectId     *string   `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	Types         []*string `json:"Types,omitempty" xml:"Types,omitempty" type:"Repeated"`
}

func (s QueryStudioAppListRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppListRequest) GoString() string {
	return s.String()
}

func (s *QueryStudioAppListRequest) SetFuzzyName(v string) *QueryStudioAppListRequest {
	s.FuzzyName = &v
	return s
}

func (s *QueryStudioAppListRequest) SetIotInstanceId(v string) *QueryStudioAppListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryStudioAppListRequest) SetPageNo(v int32) *QueryStudioAppListRequest {
	s.PageNo = &v
	return s
}

func (s *QueryStudioAppListRequest) SetPageSize(v int32) *QueryStudioAppListRequest {
	s.PageSize = &v
	return s
}

func (s *QueryStudioAppListRequest) SetProjectId(v string) *QueryStudioAppListRequest {
	s.ProjectId = &v
	return s
}

func (s *QueryStudioAppListRequest) SetTypes(v []*string) *QueryStudioAppListRequest {
	s.Types = v
	return s
}

type QueryStudioAppListResponseBody struct {
	Code         *string                             `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryStudioAppListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                             `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                             `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                               `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryStudioAppListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppListResponseBody) GoString() string {
	return s.String()
}

func (s *QueryStudioAppListResponseBody) SetCode(v string) *QueryStudioAppListResponseBody {
	s.Code = &v
	return s
}

func (s *QueryStudioAppListResponseBody) SetData(v *QueryStudioAppListResponseBodyData) *QueryStudioAppListResponseBody {
	s.Data = v
	return s
}

func (s *QueryStudioAppListResponseBody) SetErrorMessage(v string) *QueryStudioAppListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryStudioAppListResponseBody) SetRequestId(v string) *QueryStudioAppListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryStudioAppListResponseBody) SetSuccess(v bool) *QueryStudioAppListResponseBody {
	s.Success = &v
	return s
}

type QueryStudioAppListResponseBodyData struct {
	List      *QueryStudioAppListResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageNo    *int32                                  `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	PageSize  *int32                                  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total     *int32                                  `json:"Total,omitempty" xml:"Total,omitempty"`
	TotalPage *int32                                  `json:"TotalPage,omitempty" xml:"TotalPage,omitempty"`
}

func (s QueryStudioAppListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryStudioAppListResponseBodyData) SetList(v *QueryStudioAppListResponseBodyDataList) *QueryStudioAppListResponseBodyData {
	s.List = v
	return s
}

func (s *QueryStudioAppListResponseBodyData) SetPageNo(v int32) *QueryStudioAppListResponseBodyData {
	s.PageNo = &v
	return s
}

func (s *QueryStudioAppListResponseBodyData) SetPageSize(v int32) *QueryStudioAppListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryStudioAppListResponseBodyData) SetTotal(v int32) *QueryStudioAppListResponseBodyData {
	s.Total = &v
	return s
}

func (s *QueryStudioAppListResponseBodyData) SetTotalPage(v int32) *QueryStudioAppListResponseBodyData {
	s.TotalPage = &v
	return s
}

type QueryStudioAppListResponseBodyDataList struct {
	AppInfo []*QueryStudioAppListResponseBodyDataListAppInfo `json:"AppInfo,omitempty" xml:"AppInfo,omitempty" type:"Repeated"`
}

func (s QueryStudioAppListResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppListResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryStudioAppListResponseBodyDataList) SetAppInfo(v []*QueryStudioAppListResponseBodyDataListAppInfo) *QueryStudioAppListResponseBodyDataList {
	s.AppInfo = v
	return s
}

type QueryStudioAppListResponseBodyDataListAppInfo struct {
	AppId       *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	AppKey      *string `json:"AppKey,omitempty" xml:"AppKey,omitempty"`
	AppSecret   *string `json:"AppSecret,omitempty" xml:"AppSecret,omitempty"`
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	GmtCreate   *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	GmtRelease  *string `json:"GmtRelease,omitempty" xml:"GmtRelease,omitempty"`
	Name        *string `json:"Name,omitempty" xml:"Name,omitempty"`
	ProjectId   *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
	Type        *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s QueryStudioAppListResponseBodyDataListAppInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppListResponseBodyDataListAppInfo) GoString() string {
	return s.String()
}

func (s *QueryStudioAppListResponseBodyDataListAppInfo) SetAppId(v string) *QueryStudioAppListResponseBodyDataListAppInfo {
	s.AppId = &v
	return s
}

func (s *QueryStudioAppListResponseBodyDataListAppInfo) SetAppKey(v string) *QueryStudioAppListResponseBodyDataListAppInfo {
	s.AppKey = &v
	return s
}

func (s *QueryStudioAppListResponseBodyDataListAppInfo) SetAppSecret(v string) *QueryStudioAppListResponseBodyDataListAppInfo {
	s.AppSecret = &v
	return s
}

func (s *QueryStudioAppListResponseBodyDataListAppInfo) SetDescription(v string) *QueryStudioAppListResponseBodyDataListAppInfo {
	s.Description = &v
	return s
}

func (s *QueryStudioAppListResponseBodyDataListAppInfo) SetGmtCreate(v string) *QueryStudioAppListResponseBodyDataListAppInfo {
	s.GmtCreate = &v
	return s
}

func (s *QueryStudioAppListResponseBodyDataListAppInfo) SetGmtModified(v string) *QueryStudioAppListResponseBodyDataListAppInfo {
	s.GmtModified = &v
	return s
}

func (s *QueryStudioAppListResponseBodyDataListAppInfo) SetGmtRelease(v string) *QueryStudioAppListResponseBodyDataListAppInfo {
	s.GmtRelease = &v
	return s
}

func (s *QueryStudioAppListResponseBodyDataListAppInfo) SetName(v string) *QueryStudioAppListResponseBodyDataListAppInfo {
	s.Name = &v
	return s
}

func (s *QueryStudioAppListResponseBodyDataListAppInfo) SetProjectId(v string) *QueryStudioAppListResponseBodyDataListAppInfo {
	s.ProjectId = &v
	return s
}

func (s *QueryStudioAppListResponseBodyDataListAppInfo) SetType(v string) *QueryStudioAppListResponseBodyDataListAppInfo {
	s.Type = &v
	return s
}

type QueryStudioAppListResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryStudioAppListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryStudioAppListResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppListResponse) GoString() string {
	return s.String()
}

func (s *QueryStudioAppListResponse) SetHeaders(v map[string]*string) *QueryStudioAppListResponse {
	s.Headers = v
	return s
}

func (s *QueryStudioAppListResponse) SetStatusCode(v int32) *QueryStudioAppListResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryStudioAppListResponse) SetBody(v *QueryStudioAppListResponseBody) *QueryStudioAppListResponse {
	s.Body = v
	return s
}

type QueryStudioAppPageListOpenRequest struct {
	AppId         *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	IsRelease     *bool   `json:"IsRelease,omitempty" xml:"IsRelease,omitempty"`
	PageNo        *int32  `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	ProjectId     *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s QueryStudioAppPageListOpenRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppPageListOpenRequest) GoString() string {
	return s.String()
}

func (s *QueryStudioAppPageListOpenRequest) SetAppId(v string) *QueryStudioAppPageListOpenRequest {
	s.AppId = &v
	return s
}

func (s *QueryStudioAppPageListOpenRequest) SetIotInstanceId(v string) *QueryStudioAppPageListOpenRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryStudioAppPageListOpenRequest) SetIsRelease(v bool) *QueryStudioAppPageListOpenRequest {
	s.IsRelease = &v
	return s
}

func (s *QueryStudioAppPageListOpenRequest) SetPageNo(v int32) *QueryStudioAppPageListOpenRequest {
	s.PageNo = &v
	return s
}

func (s *QueryStudioAppPageListOpenRequest) SetPageSize(v int32) *QueryStudioAppPageListOpenRequest {
	s.PageSize = &v
	return s
}

func (s *QueryStudioAppPageListOpenRequest) SetProjectId(v string) *QueryStudioAppPageListOpenRequest {
	s.ProjectId = &v
	return s
}

type QueryStudioAppPageListOpenResponseBody struct {
	Code         *string                                     `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryStudioAppPageListOpenResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryStudioAppPageListOpenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppPageListOpenResponseBody) GoString() string {
	return s.String()
}

func (s *QueryStudioAppPageListOpenResponseBody) SetCode(v string) *QueryStudioAppPageListOpenResponseBody {
	s.Code = &v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBody) SetData(v *QueryStudioAppPageListOpenResponseBodyData) *QueryStudioAppPageListOpenResponseBody {
	s.Data = v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBody) SetErrorMessage(v string) *QueryStudioAppPageListOpenResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBody) SetRequestId(v string) *QueryStudioAppPageListOpenResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBody) SetSuccess(v bool) *QueryStudioAppPageListOpenResponseBody {
	s.Success = &v
	return s
}

type QueryStudioAppPageListOpenResponseBodyData struct {
	List      *QueryStudioAppPageListOpenResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageNo    *int32                                          `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	PageSize  *int32                                          `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total     *int32                                          `json:"Total,omitempty" xml:"Total,omitempty"`
	TotalPage *int32                                          `json:"TotalPage,omitempty" xml:"TotalPage,omitempty"`
}

func (s QueryStudioAppPageListOpenResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppPageListOpenResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryStudioAppPageListOpenResponseBodyData) SetList(v *QueryStudioAppPageListOpenResponseBodyDataList) *QueryStudioAppPageListOpenResponseBodyData {
	s.List = v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBodyData) SetPageNo(v int32) *QueryStudioAppPageListOpenResponseBodyData {
	s.PageNo = &v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBodyData) SetPageSize(v int32) *QueryStudioAppPageListOpenResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBodyData) SetTotal(v int32) *QueryStudioAppPageListOpenResponseBodyData {
	s.Total = &v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBodyData) SetTotalPage(v int32) *QueryStudioAppPageListOpenResponseBodyData {
	s.TotalPage = &v
	return s
}

type QueryStudioAppPageListOpenResponseBodyDataList struct {
	PageInfo []*QueryStudioAppPageListOpenResponseBodyDataListPageInfo `json:"PageInfo,omitempty" xml:"PageInfo,omitempty" type:"Repeated"`
}

func (s QueryStudioAppPageListOpenResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppPageListOpenResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryStudioAppPageListOpenResponseBodyDataList) SetPageInfo(v []*QueryStudioAppPageListOpenResponseBodyDataListPageInfo) *QueryStudioAppPageListOpenResponseBodyDataList {
	s.PageInfo = v
	return s
}

type QueryStudioAppPageListOpenResponseBodyDataListPageInfo struct {
	GmtCreate   *string `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtModified *string `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	Id          *int32  `json:"Id,omitempty" xml:"Id,omitempty"`
	IsHidden    *int32  `json:"IsHidden,omitempty" xml:"IsHidden,omitempty"`
	IsHome      *int32  `json:"IsHome,omitempty" xml:"IsHome,omitempty"`
	IsLoginPage *int32  `json:"IsLoginPage,omitempty" xml:"IsLoginPage,omitempty"`
	Name        *string `json:"Name,omitempty" xml:"Name,omitempty"`
	PageId      *string `json:"PageId,omitempty" xml:"PageId,omitempty"`
	Path        *string `json:"Path,omitempty" xml:"Path,omitempty"`
}

func (s QueryStudioAppPageListOpenResponseBodyDataListPageInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppPageListOpenResponseBodyDataListPageInfo) GoString() string {
	return s.String()
}

func (s *QueryStudioAppPageListOpenResponseBodyDataListPageInfo) SetGmtCreate(v string) *QueryStudioAppPageListOpenResponseBodyDataListPageInfo {
	s.GmtCreate = &v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBodyDataListPageInfo) SetGmtModified(v string) *QueryStudioAppPageListOpenResponseBodyDataListPageInfo {
	s.GmtModified = &v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBodyDataListPageInfo) SetId(v int32) *QueryStudioAppPageListOpenResponseBodyDataListPageInfo {
	s.Id = &v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBodyDataListPageInfo) SetIsHidden(v int32) *QueryStudioAppPageListOpenResponseBodyDataListPageInfo {
	s.IsHidden = &v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBodyDataListPageInfo) SetIsHome(v int32) *QueryStudioAppPageListOpenResponseBodyDataListPageInfo {
	s.IsHome = &v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBodyDataListPageInfo) SetIsLoginPage(v int32) *QueryStudioAppPageListOpenResponseBodyDataListPageInfo {
	s.IsLoginPage = &v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBodyDataListPageInfo) SetName(v string) *QueryStudioAppPageListOpenResponseBodyDataListPageInfo {
	s.Name = &v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBodyDataListPageInfo) SetPageId(v string) *QueryStudioAppPageListOpenResponseBodyDataListPageInfo {
	s.PageId = &v
	return s
}

func (s *QueryStudioAppPageListOpenResponseBodyDataListPageInfo) SetPath(v string) *QueryStudioAppPageListOpenResponseBodyDataListPageInfo {
	s.Path = &v
	return s
}

type QueryStudioAppPageListOpenResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryStudioAppPageListOpenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryStudioAppPageListOpenResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioAppPageListOpenResponse) GoString() string {
	return s.String()
}

func (s *QueryStudioAppPageListOpenResponse) SetHeaders(v map[string]*string) *QueryStudioAppPageListOpenResponse {
	s.Headers = v
	return s
}

func (s *QueryStudioAppPageListOpenResponse) SetStatusCode(v int32) *QueryStudioAppPageListOpenResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryStudioAppPageListOpenResponse) SetBody(v *QueryStudioAppPageListOpenResponseBody) *QueryStudioAppPageListOpenResponse {
	s.Body = v
	return s
}

type QueryStudioProjectListRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Name          *string `json:"Name,omitempty" xml:"Name,omitempty"`
	PageNo        *int32  `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
}

func (s QueryStudioProjectListRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioProjectListRequest) GoString() string {
	return s.String()
}

func (s *QueryStudioProjectListRequest) SetIotInstanceId(v string) *QueryStudioProjectListRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryStudioProjectListRequest) SetName(v string) *QueryStudioProjectListRequest {
	s.Name = &v
	return s
}

func (s *QueryStudioProjectListRequest) SetPageNo(v int32) *QueryStudioProjectListRequest {
	s.PageNo = &v
	return s
}

func (s *QueryStudioProjectListRequest) SetPageSize(v int32) *QueryStudioProjectListRequest {
	s.PageSize = &v
	return s
}

type QueryStudioProjectListResponseBody struct {
	Code         *string                                 `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryStudioProjectListResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                 `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                 `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryStudioProjectListResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioProjectListResponseBody) GoString() string {
	return s.String()
}

func (s *QueryStudioProjectListResponseBody) SetCode(v string) *QueryStudioProjectListResponseBody {
	s.Code = &v
	return s
}

func (s *QueryStudioProjectListResponseBody) SetData(v *QueryStudioProjectListResponseBodyData) *QueryStudioProjectListResponseBody {
	s.Data = v
	return s
}

func (s *QueryStudioProjectListResponseBody) SetErrorMessage(v string) *QueryStudioProjectListResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryStudioProjectListResponseBody) SetRequestId(v string) *QueryStudioProjectListResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryStudioProjectListResponseBody) SetSuccess(v bool) *QueryStudioProjectListResponseBody {
	s.Success = &v
	return s
}

type QueryStudioProjectListResponseBodyData struct {
	List      *QueryStudioProjectListResponseBodyDataList `json:"List,omitempty" xml:"List,omitempty" type:"Struct"`
	PageNo    *int32                                      `json:"PageNo,omitempty" xml:"PageNo,omitempty"`
	PageSize  *int32                                      `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total     *int32                                      `json:"Total,omitempty" xml:"Total,omitempty"`
	TotalPage *int32                                      `json:"TotalPage,omitempty" xml:"TotalPage,omitempty"`
}

func (s QueryStudioProjectListResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioProjectListResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryStudioProjectListResponseBodyData) SetList(v *QueryStudioProjectListResponseBodyDataList) *QueryStudioProjectListResponseBodyData {
	s.List = v
	return s
}

func (s *QueryStudioProjectListResponseBodyData) SetPageNo(v int32) *QueryStudioProjectListResponseBodyData {
	s.PageNo = &v
	return s
}

func (s *QueryStudioProjectListResponseBodyData) SetPageSize(v int32) *QueryStudioProjectListResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QueryStudioProjectListResponseBodyData) SetTotal(v int32) *QueryStudioProjectListResponseBodyData {
	s.Total = &v
	return s
}

func (s *QueryStudioProjectListResponseBodyData) SetTotalPage(v int32) *QueryStudioProjectListResponseBodyData {
	s.TotalPage = &v
	return s
}

type QueryStudioProjectListResponseBodyDataList struct {
	ProjectInfo []*QueryStudioProjectListResponseBodyDataListProjectInfo `json:"ProjectInfo,omitempty" xml:"ProjectInfo,omitempty" type:"Repeated"`
}

func (s QueryStudioProjectListResponseBodyDataList) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioProjectListResponseBodyDataList) GoString() string {
	return s.String()
}

func (s *QueryStudioProjectListResponseBodyDataList) SetProjectInfo(v []*QueryStudioProjectListResponseBodyDataListProjectInfo) *QueryStudioProjectListResponseBodyDataList {
	s.ProjectInfo = v
	return s
}

type QueryStudioProjectListResponseBodyDataListProjectInfo struct {
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	GmtCreate   *int64  `json:"GmtCreate,omitempty" xml:"GmtCreate,omitempty"`
	GmtModified *int64  `json:"GmtModified,omitempty" xml:"GmtModified,omitempty"`
	Name        *string `json:"Name,omitempty" xml:"Name,omitempty"`
	ProjectId   *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s QueryStudioProjectListResponseBodyDataListProjectInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioProjectListResponseBodyDataListProjectInfo) GoString() string {
	return s.String()
}

func (s *QueryStudioProjectListResponseBodyDataListProjectInfo) SetDescription(v string) *QueryStudioProjectListResponseBodyDataListProjectInfo {
	s.Description = &v
	return s
}

func (s *QueryStudioProjectListResponseBodyDataListProjectInfo) SetGmtCreate(v int64) *QueryStudioProjectListResponseBodyDataListProjectInfo {
	s.GmtCreate = &v
	return s
}

func (s *QueryStudioProjectListResponseBodyDataListProjectInfo) SetGmtModified(v int64) *QueryStudioProjectListResponseBodyDataListProjectInfo {
	s.GmtModified = &v
	return s
}

func (s *QueryStudioProjectListResponseBodyDataListProjectInfo) SetName(v string) *QueryStudioProjectListResponseBodyDataListProjectInfo {
	s.Name = &v
	return s
}

func (s *QueryStudioProjectListResponseBodyDataListProjectInfo) SetProjectId(v string) *QueryStudioProjectListResponseBodyDataListProjectInfo {
	s.ProjectId = &v
	return s
}

type QueryStudioProjectListResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryStudioProjectListResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryStudioProjectListResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryStudioProjectListResponse) GoString() string {
	return s.String()
}

func (s *QueryStudioProjectListResponse) SetHeaders(v map[string]*string) *QueryStudioProjectListResponse {
	s.Headers = v
	return s
}

func (s *QueryStudioProjectListResponse) SetStatusCode(v int32) *QueryStudioProjectListResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryStudioProjectListResponse) SetBody(v *QueryStudioProjectListResponseBody) *QueryStudioProjectListResponse {
	s.Body = v
	return s
}

type QuerySubscribeRelationRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product that is specified for the subscription.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The type of the subscription. Valid values:
	//
	// *   **MNS**
	// *   **AMQP**
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s QuerySubscribeRelationRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySubscribeRelationRequest) GoString() string {
	return s.String()
}

func (s *QuerySubscribeRelationRequest) SetIotInstanceId(v string) *QuerySubscribeRelationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySubscribeRelationRequest) SetProductKey(v string) *QuerySubscribeRelationRequest {
	s.ProductKey = &v
	return s
}

func (s *QuerySubscribeRelationRequest) SetType(v string) *QuerySubscribeRelationRequest {
	s.Type = &v
	return s
}

type QuerySubscribeRelationResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The IDs of the consumer groups that are created in the AMQP subscription. This parameter is returned if the **Type** parameter is set to **AMQP**.
	ConsumerGroupIds []*string `json:"ConsumerGroupIds,omitempty" xml:"ConsumerGroupIds,omitempty" type:"Repeated"`
	// Indicates whether upstream device messages were pushed.
	//
	// *   **true**: yes.
	// *   **false**: no.
	DeviceDataFlag *bool `json:"DeviceDataFlag,omitempty" xml:"DeviceDataFlag,omitempty"`
	// Indicates whether messages about device lifecycle changes were pushed.
	//
	// *   **true**: yes.
	// *   **false**: no.
	DeviceLifeCycleFlag *bool `json:"DeviceLifeCycleFlag,omitempty" xml:"DeviceLifeCycleFlag,omitempty"`
	// Indicates whether messages about device status changes were pushed.
	//
	// *   **true**: yes.
	// *   **false**: no.
	DeviceStatusChangeFlag *bool `json:"DeviceStatusChangeFlag,omitempty" xml:"DeviceStatusChangeFlag,omitempty"`
	// Indicates whether messages about device tag changes were pushed. Valid values:
	//
	// *   **true**: yes. This parameter takes effect only if the **Type** parameter is set to **AMQP**.
	// *   **false**: no.
	//
	// Default value: **false**.
	DeviceTagFlag *bool `json:"DeviceTagFlag,omitempty" xml:"DeviceTagFlag,omitempty"`
	// Indicates whether messages about topological relationship changes of devices were pushed.
	//
	// *   **true**: yes. The value **true** is returned only when you query a gateway product.
	// *   **false**: no.
	DeviceTopoLifeCycleFlag *bool `json:"DeviceTopoLifeCycleFlag,omitempty" xml:"DeviceTopoLifeCycleFlag,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// Indicates whether messages were pushed if a gateway detected new sub-devices.
	//
	// *   **true**: yes. The value **true** is returned only when you query a gateway product.
	// *   **false**: no.
	FoundDeviceListFlag *bool `json:"FoundDeviceListFlag,omitempty" xml:"FoundDeviceListFlag,omitempty"`
	// The configurations of the MNS queue. This parameter is returned if the **Type** parameter is set to **MNS**.
	//
	// For more information, see the "Definition of the MnsConfiguration parameter" section.
	MnsConfiguration *string `json:"MnsConfiguration,omitempty" xml:"MnsConfiguration,omitempty"`
	// Indicates whether notifications about the status of OTA update batches were pushed.
	//
	// *   **true**: yes.
	// *   **false**: no.
	OtaEventFlag *bool `json:"OtaEventFlag,omitempty" xml:"OtaEventFlag,omitempty"`
	// Indicates whether notifications about OTA batch updates were pushed. Valid values:
	//
	// *   **true**: yes. This parameter takes effect only if the **Type** parameter is set to **AMQP**.
	// *   **false**: no.
	//
	// Default value: **false**.
	OtaJobFlag *bool `json:"OtaJobFlag,omitempty" xml:"OtaJobFlag,omitempty"`
	// Indicates whether messages about the version numbers of OTA modules were pushed. Valid values:
	//
	// *   **true**: yes. This parameter takes effect only if the **Type** parameter is set to **AMQP**.
	// *   **false**: no.
	//
	// Default value: **false**.
	OtaVersionFlag *bool `json:"OtaVersionFlag,omitempty" xml:"OtaVersionFlag,omitempty"`
	// The ProductKey of the product that is specified for the subscription.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the request.
	RequestId      *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	SubscribeFlags *string `json:"SubscribeFlags,omitempty" xml:"SubscribeFlags,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
	// Indicates whether upstream historical Thing Specification Language (TSL) data was pushed.
	//
	// *   **true**: yes.
	// *   **false**: no.
	ThingHistoryFlag *bool `json:"ThingHistoryFlag,omitempty" xml:"ThingHistoryFlag,omitempty"`
	// The type of the subscription. Valid values:
	//
	// *   **MNS**
	// *   **AMQP**
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s QuerySubscribeRelationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySubscribeRelationResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySubscribeRelationResponseBody) SetCode(v string) *QuerySubscribeRelationResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetConsumerGroupIds(v []*string) *QuerySubscribeRelationResponseBody {
	s.ConsumerGroupIds = v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetDeviceDataFlag(v bool) *QuerySubscribeRelationResponseBody {
	s.DeviceDataFlag = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetDeviceLifeCycleFlag(v bool) *QuerySubscribeRelationResponseBody {
	s.DeviceLifeCycleFlag = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetDeviceStatusChangeFlag(v bool) *QuerySubscribeRelationResponseBody {
	s.DeviceStatusChangeFlag = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetDeviceTagFlag(v bool) *QuerySubscribeRelationResponseBody {
	s.DeviceTagFlag = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetDeviceTopoLifeCycleFlag(v bool) *QuerySubscribeRelationResponseBody {
	s.DeviceTopoLifeCycleFlag = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetErrorMessage(v string) *QuerySubscribeRelationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetFoundDeviceListFlag(v bool) *QuerySubscribeRelationResponseBody {
	s.FoundDeviceListFlag = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetMnsConfiguration(v string) *QuerySubscribeRelationResponseBody {
	s.MnsConfiguration = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetOtaEventFlag(v bool) *QuerySubscribeRelationResponseBody {
	s.OtaEventFlag = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetOtaJobFlag(v bool) *QuerySubscribeRelationResponseBody {
	s.OtaJobFlag = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetOtaVersionFlag(v bool) *QuerySubscribeRelationResponseBody {
	s.OtaVersionFlag = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetProductKey(v string) *QuerySubscribeRelationResponseBody {
	s.ProductKey = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetRequestId(v string) *QuerySubscribeRelationResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetSubscribeFlags(v string) *QuerySubscribeRelationResponseBody {
	s.SubscribeFlags = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetSuccess(v bool) *QuerySubscribeRelationResponseBody {
	s.Success = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetThingHistoryFlag(v bool) *QuerySubscribeRelationResponseBody {
	s.ThingHistoryFlag = &v
	return s
}

func (s *QuerySubscribeRelationResponseBody) SetType(v string) *QuerySubscribeRelationResponseBody {
	s.Type = &v
	return s
}

type QuerySubscribeRelationResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySubscribeRelationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySubscribeRelationResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySubscribeRelationResponse) GoString() string {
	return s.String()
}

func (s *QuerySubscribeRelationResponse) SetHeaders(v map[string]*string) *QuerySubscribeRelationResponse {
	s.Headers = v
	return s
}

func (s *QuerySubscribeRelationResponse) SetStatusCode(v int32) *QuerySubscribeRelationResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySubscribeRelationResponse) SetBody(v *QuerySubscribeRelationResponseBody) *QuerySubscribeRelationResponse {
	s.Body = v
	return s
}

type QuerySummarySceneRuleLogRequest struct {
	CurrentPage   *int32  `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	EndTime       *int32  `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PageSize      *int32  `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	RuleId        *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	StartTime     *int32  `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	Status        *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s QuerySummarySceneRuleLogRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySummarySceneRuleLogRequest) GoString() string {
	return s.String()
}

func (s *QuerySummarySceneRuleLogRequest) SetCurrentPage(v int32) *QuerySummarySceneRuleLogRequest {
	s.CurrentPage = &v
	return s
}

func (s *QuerySummarySceneRuleLogRequest) SetEndTime(v int32) *QuerySummarySceneRuleLogRequest {
	s.EndTime = &v
	return s
}

func (s *QuerySummarySceneRuleLogRequest) SetIotInstanceId(v string) *QuerySummarySceneRuleLogRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QuerySummarySceneRuleLogRequest) SetPageSize(v int32) *QuerySummarySceneRuleLogRequest {
	s.PageSize = &v
	return s
}

func (s *QuerySummarySceneRuleLogRequest) SetRuleId(v string) *QuerySummarySceneRuleLogRequest {
	s.RuleId = &v
	return s
}

func (s *QuerySummarySceneRuleLogRequest) SetStartTime(v int32) *QuerySummarySceneRuleLogRequest {
	s.StartTime = &v
	return s
}

func (s *QuerySummarySceneRuleLogRequest) SetStatus(v string) *QuerySummarySceneRuleLogRequest {
	s.Status = &v
	return s
}

type QuerySummarySceneRuleLogResponseBody struct {
	Code         *string                                   `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QuerySummarySceneRuleLogResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                   `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                   `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                     `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySummarySceneRuleLogResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySummarySceneRuleLogResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySummarySceneRuleLogResponseBody) SetCode(v string) *QuerySummarySceneRuleLogResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySummarySceneRuleLogResponseBody) SetData(v *QuerySummarySceneRuleLogResponseBodyData) *QuerySummarySceneRuleLogResponseBody {
	s.Data = v
	return s
}

func (s *QuerySummarySceneRuleLogResponseBody) SetErrorMessage(v string) *QuerySummarySceneRuleLogResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySummarySceneRuleLogResponseBody) SetRequestId(v string) *QuerySummarySceneRuleLogResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySummarySceneRuleLogResponseBody) SetSuccess(v bool) *QuerySummarySceneRuleLogResponseBody {
	s.Success = &v
	return s
}

type QuerySummarySceneRuleLogResponseBodyData struct {
	CurrentPage *int32                                           `json:"CurrentPage,omitempty" xml:"CurrentPage,omitempty"`
	LogList     *QuerySummarySceneRuleLogResponseBodyDataLogList `json:"LogList,omitempty" xml:"LogList,omitempty" type:"Struct"`
	PageSize    *int32                                           `json:"PageSize,omitempty" xml:"PageSize,omitempty"`
	Total       *int32                                           `json:"Total,omitempty" xml:"Total,omitempty"`
}

func (s QuerySummarySceneRuleLogResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySummarySceneRuleLogResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySummarySceneRuleLogResponseBodyData) SetCurrentPage(v int32) *QuerySummarySceneRuleLogResponseBodyData {
	s.CurrentPage = &v
	return s
}

func (s *QuerySummarySceneRuleLogResponseBodyData) SetLogList(v *QuerySummarySceneRuleLogResponseBodyDataLogList) *QuerySummarySceneRuleLogResponseBodyData {
	s.LogList = v
	return s
}

func (s *QuerySummarySceneRuleLogResponseBodyData) SetPageSize(v int32) *QuerySummarySceneRuleLogResponseBodyData {
	s.PageSize = &v
	return s
}

func (s *QuerySummarySceneRuleLogResponseBodyData) SetTotal(v int32) *QuerySummarySceneRuleLogResponseBodyData {
	s.Total = &v
	return s
}

type QuerySummarySceneRuleLogResponseBodyDataLogList struct {
	LogInfo []*QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo `json:"LogInfo,omitempty" xml:"LogInfo,omitempty" type:"Repeated"`
}

func (s QuerySummarySceneRuleLogResponseBodyDataLogList) String() string {
	return tea.Prettify(s)
}

func (s QuerySummarySceneRuleLogResponseBodyDataLogList) GoString() string {
	return s.String()
}

func (s *QuerySummarySceneRuleLogResponseBodyDataLogList) SetLogInfo(v []*QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo) *QuerySummarySceneRuleLogResponseBodyDataLogList {
	s.LogInfo = v
	return s
}

type QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo struct {
	LogTime *int32  `json:"LogTime,omitempty" xml:"LogTime,omitempty"`
	Result  *string `json:"Result,omitempty" xml:"Result,omitempty"`
	TraceId *string `json:"TraceId,omitempty" xml:"TraceId,omitempty"`
}

func (s QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo) String() string {
	return tea.Prettify(s)
}

func (s QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo) GoString() string {
	return s.String()
}

func (s *QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo) SetLogTime(v int32) *QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo {
	s.LogTime = &v
	return s
}

func (s *QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo) SetResult(v string) *QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo {
	s.Result = &v
	return s
}

func (s *QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo) SetTraceId(v string) *QuerySummarySceneRuleLogResponseBodyDataLogListLogInfo {
	s.TraceId = &v
	return s
}

type QuerySummarySceneRuleLogResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySummarySceneRuleLogResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySummarySceneRuleLogResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySummarySceneRuleLogResponse) GoString() string {
	return s.String()
}

func (s *QuerySummarySceneRuleLogResponse) SetHeaders(v map[string]*string) *QuerySummarySceneRuleLogResponse {
	s.Headers = v
	return s
}

func (s *QuerySummarySceneRuleLogResponse) SetStatusCode(v int32) *QuerySummarySceneRuleLogResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySummarySceneRuleLogResponse) SetBody(v *QuerySummarySceneRuleLogResponseBody) *QuerySummarySceneRuleLogResponse {
	s.Body = v
	return s
}

type QuerySuperDeviceGroupRequest struct {
	// The ID of the subgroup. The ID is the globally unique identifier (GUID) for the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s QuerySuperDeviceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s QuerySuperDeviceGroupRequest) GoString() string {
	return s.String()
}

func (s *QuerySuperDeviceGroupRequest) SetGroupId(v string) *QuerySuperDeviceGroupRequest {
	s.GroupId = &v
	return s
}

func (s *QuerySuperDeviceGroupRequest) SetIotInstanceId(v string) *QuerySuperDeviceGroupRequest {
	s.IotInstanceId = &v
	return s
}

type QuerySuperDeviceGroupResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The parent group information returned if the call succeeds. For more information, see the following **GroupInfo** parameter.
	Data *QuerySuperDeviceGroupResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QuerySuperDeviceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QuerySuperDeviceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *QuerySuperDeviceGroupResponseBody) SetCode(v string) *QuerySuperDeviceGroupResponseBody {
	s.Code = &v
	return s
}

func (s *QuerySuperDeviceGroupResponseBody) SetData(v *QuerySuperDeviceGroupResponseBodyData) *QuerySuperDeviceGroupResponseBody {
	s.Data = v
	return s
}

func (s *QuerySuperDeviceGroupResponseBody) SetErrorMessage(v string) *QuerySuperDeviceGroupResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QuerySuperDeviceGroupResponseBody) SetRequestId(v string) *QuerySuperDeviceGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *QuerySuperDeviceGroupResponseBody) SetSuccess(v bool) *QuerySuperDeviceGroupResponseBody {
	s.Success = &v
	return s
}

type QuerySuperDeviceGroupResponseBodyData struct {
	GroupInfo []*QuerySuperDeviceGroupResponseBodyDataGroupInfo `json:"GroupInfo,omitempty" xml:"GroupInfo,omitempty" type:"Repeated"`
}

func (s QuerySuperDeviceGroupResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QuerySuperDeviceGroupResponseBodyData) GoString() string {
	return s.String()
}

func (s *QuerySuperDeviceGroupResponseBodyData) SetGroupInfo(v []*QuerySuperDeviceGroupResponseBodyDataGroupInfo) *QuerySuperDeviceGroupResponseBodyData {
	s.GroupInfo = v
	return s
}

type QuerySuperDeviceGroupResponseBodyDataGroupInfo struct {
	// The description of the parent group.
	GroupDesc *string `json:"GroupDesc,omitempty" xml:"GroupDesc,omitempty"`
	// The ID of the parent group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The name of the parent group.
	GroupName *string `json:"GroupName,omitempty" xml:"GroupName,omitempty"`
}

func (s QuerySuperDeviceGroupResponseBodyDataGroupInfo) String() string {
	return tea.Prettify(s)
}

func (s QuerySuperDeviceGroupResponseBodyDataGroupInfo) GoString() string {
	return s.String()
}

func (s *QuerySuperDeviceGroupResponseBodyDataGroupInfo) SetGroupDesc(v string) *QuerySuperDeviceGroupResponseBodyDataGroupInfo {
	s.GroupDesc = &v
	return s
}

func (s *QuerySuperDeviceGroupResponseBodyDataGroupInfo) SetGroupId(v string) *QuerySuperDeviceGroupResponseBodyDataGroupInfo {
	s.GroupId = &v
	return s
}

func (s *QuerySuperDeviceGroupResponseBodyDataGroupInfo) SetGroupName(v string) *QuerySuperDeviceGroupResponseBodyDataGroupInfo {
	s.GroupName = &v
	return s
}

type QuerySuperDeviceGroupResponse struct {
	Headers    map[string]*string                 `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QuerySuperDeviceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QuerySuperDeviceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s QuerySuperDeviceGroupResponse) GoString() string {
	return s.String()
}

func (s *QuerySuperDeviceGroupResponse) SetHeaders(v map[string]*string) *QuerySuperDeviceGroupResponse {
	s.Headers = v
	return s
}

func (s *QuerySuperDeviceGroupResponse) SetStatusCode(v int32) *QuerySuperDeviceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *QuerySuperDeviceGroupResponse) SetBody(v *QuerySuperDeviceGroupResponseBody) *QuerySuperDeviceGroupResponse {
	s.Body = v
	return s
}

type QueryTaskRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	TaskId        *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
}

func (s QueryTaskRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryTaskRequest) GoString() string {
	return s.String()
}

func (s *QueryTaskRequest) SetIotInstanceId(v string) *QueryTaskRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryTaskRequest) SetTaskId(v string) *QueryTaskRequest {
	s.TaskId = &v
	return s
}

type QueryTaskResponseBody struct {
	Code         *string                    `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *QueryTaskResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                    `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                      `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryTaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryTaskResponseBody) GoString() string {
	return s.String()
}

func (s *QueryTaskResponseBody) SetCode(v string) *QueryTaskResponseBody {
	s.Code = &v
	return s
}

func (s *QueryTaskResponseBody) SetData(v *QueryTaskResponseBodyData) *QueryTaskResponseBody {
	s.Data = v
	return s
}

func (s *QueryTaskResponseBody) SetErrorMessage(v string) *QueryTaskResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryTaskResponseBody) SetRequestId(v string) *QueryTaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryTaskResponseBody) SetSuccess(v bool) *QueryTaskResponseBody {
	s.Success = &v
	return s
}

type QueryTaskResponseBodyData struct {
	DeviceName   *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotId        *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	JobId        *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	JobName      *string `json:"JobName,omitempty" xml:"JobName,omitempty"`
	Message      *string `json:"Message,omitempty" xml:"Message,omitempty"`
	ProductKey   *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	Progress     *string `json:"Progress,omitempty" xml:"Progress,omitempty"`
	Status       *string `json:"Status,omitempty" xml:"Status,omitempty"`
	StatusDetail *string `json:"StatusDetail,omitempty" xml:"StatusDetail,omitempty"`
	TaskId       *string `json:"TaskId,omitempty" xml:"TaskId,omitempty"`
	UtcModified  *string `json:"UtcModified,omitempty" xml:"UtcModified,omitempty"`
	UtcQueueTime *string `json:"UtcQueueTime,omitempty" xml:"UtcQueueTime,omitempty"`
}

func (s QueryTaskResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryTaskResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryTaskResponseBodyData) SetDeviceName(v string) *QueryTaskResponseBodyData {
	s.DeviceName = &v
	return s
}

func (s *QueryTaskResponseBodyData) SetIotId(v string) *QueryTaskResponseBodyData {
	s.IotId = &v
	return s
}

func (s *QueryTaskResponseBodyData) SetJobId(v string) *QueryTaskResponseBodyData {
	s.JobId = &v
	return s
}

func (s *QueryTaskResponseBodyData) SetJobName(v string) *QueryTaskResponseBodyData {
	s.JobName = &v
	return s
}

func (s *QueryTaskResponseBodyData) SetMessage(v string) *QueryTaskResponseBodyData {
	s.Message = &v
	return s
}

func (s *QueryTaskResponseBodyData) SetProductKey(v string) *QueryTaskResponseBodyData {
	s.ProductKey = &v
	return s
}

func (s *QueryTaskResponseBodyData) SetProgress(v string) *QueryTaskResponseBodyData {
	s.Progress = &v
	return s
}

func (s *QueryTaskResponseBodyData) SetStatus(v string) *QueryTaskResponseBodyData {
	s.Status = &v
	return s
}

func (s *QueryTaskResponseBodyData) SetStatusDetail(v string) *QueryTaskResponseBodyData {
	s.StatusDetail = &v
	return s
}

func (s *QueryTaskResponseBodyData) SetTaskId(v string) *QueryTaskResponseBodyData {
	s.TaskId = &v
	return s
}

func (s *QueryTaskResponseBodyData) SetUtcModified(v string) *QueryTaskResponseBodyData {
	s.UtcModified = &v
	return s
}

func (s *QueryTaskResponseBodyData) SetUtcQueueTime(v string) *QueryTaskResponseBodyData {
	s.UtcQueueTime = &v
	return s
}

type QueryTaskResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryTaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryTaskResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryTaskResponse) GoString() string {
	return s.String()
}

func (s *QueryTaskResponse) SetHeaders(v map[string]*string) *QueryTaskResponse {
	s.Headers = v
	return s
}

func (s *QueryTaskResponse) SetStatusCode(v int32) *QueryTaskResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryTaskResponse) SetBody(v *QueryTaskResponseBody) *QueryTaskResponse {
	s.Body = v
	return s
}

type QueryThingModelRequest struct {
	// The identifier of the custom TSL module. Each identifier is unique in a product.
	//
	// If you do not specify this parameter, the default module is queried.
	FunctionBlockId *string `json:"FunctionBlockId,omitempty" xml:"FunctionBlockId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The version number of the TSL model.
	//
	// You can call the [ListThingModelVersion](~~150318~~) operation to view the version numbers of the TSL model for a product.
	//
	// If you do not specify this parameter, the TSL model that is in the draft status is queried. If you specify this parameter, the TSL model of the specified version is queried.
	ModelVersion *string `json:"ModelVersion,omitempty" xml:"ModelVersion,omitempty"`
	// The **ProductKey** of the product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the resource group.
	//
	// >  You cannot specify this parameter.
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s QueryThingModelRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelRequest) GoString() string {
	return s.String()
}

func (s *QueryThingModelRequest) SetFunctionBlockId(v string) *QueryThingModelRequest {
	s.FunctionBlockId = &v
	return s
}

func (s *QueryThingModelRequest) SetIotInstanceId(v string) *QueryThingModelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryThingModelRequest) SetModelVersion(v string) *QueryThingModelRequest {
	s.ModelVersion = &v
	return s
}

func (s *QueryThingModelRequest) SetProductKey(v string) *QueryThingModelRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryThingModelRequest) SetResourceGroupId(v string) *QueryThingModelRequest {
	s.ResourceGroupId = &v
	return s
}

type QueryThingModelResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call is successful.
	Data *QueryThingModelResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The **ProductKey** of the product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryThingModelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelResponseBody) GoString() string {
	return s.String()
}

func (s *QueryThingModelResponseBody) SetCode(v string) *QueryThingModelResponseBody {
	s.Code = &v
	return s
}

func (s *QueryThingModelResponseBody) SetData(v *QueryThingModelResponseBodyData) *QueryThingModelResponseBody {
	s.Data = v
	return s
}

func (s *QueryThingModelResponseBody) SetErrorMessage(v string) *QueryThingModelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryThingModelResponseBody) SetProductKey(v string) *QueryThingModelResponseBody {
	s.ProductKey = &v
	return s
}

func (s *QueryThingModelResponseBody) SetRequestId(v string) *QueryThingModelResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryThingModelResponseBody) SetSuccess(v bool) *QueryThingModelResponseBody {
	s.Success = &v
	return s
}

type QueryThingModelResponseBodyData struct {
	// The features of the TSL model. The TSL data format of the default module is different from the TSL data format of a custom module.
	//
	// For more information about the data format of the ThingModelJson parameter, see [Data structure of ThingModelJson](~~150457~~).
	ThingModelJson *string `json:"ThingModelJson,omitempty" xml:"ThingModelJson,omitempty"`
}

func (s QueryThingModelResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryThingModelResponseBodyData) SetThingModelJson(v string) *QueryThingModelResponseBodyData {
	s.ThingModelJson = &v
	return s
}

type QueryThingModelResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryThingModelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryThingModelResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelResponse) GoString() string {
	return s.String()
}

func (s *QueryThingModelResponse) SetHeaders(v map[string]*string) *QueryThingModelResponse {
	s.Headers = v
	return s
}

func (s *QueryThingModelResponse) SetStatusCode(v int32) *QueryThingModelResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryThingModelResponse) SetBody(v *QueryThingModelResponseBody) *QueryThingModelResponse {
	s.Body = v
	return s
}

type QueryThingModelExtendConfigRequest struct {
	// The identifier of the custom TSL module. Each identifier is unique in a product.
	//
	// If you do not specify this parameter, the system exports the data of the default module.
	FunctionBlockId *string `json:"FunctionBlockId,omitempty" xml:"FunctionBlockId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The version number of the TSL model.
	//
	// You can call the [ListThingModelVersion](~~150318~~) operation to view the version numbers of the TSL model for a product.
	//
	// If you do not specify this parameter, the last published TSL version is returned.
	ModelVersion *string `json:"ModelVersion,omitempty" xml:"ModelVersion,omitempty"`
	// The ProductKey of the product.
	ProductKey      *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s QueryThingModelExtendConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelExtendConfigRequest) GoString() string {
	return s.String()
}

func (s *QueryThingModelExtendConfigRequest) SetFunctionBlockId(v string) *QueryThingModelExtendConfigRequest {
	s.FunctionBlockId = &v
	return s
}

func (s *QueryThingModelExtendConfigRequest) SetIotInstanceId(v string) *QueryThingModelExtendConfigRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryThingModelExtendConfigRequest) SetModelVersion(v string) *QueryThingModelExtendConfigRequest {
	s.ModelVersion = &v
	return s
}

func (s *QueryThingModelExtendConfigRequest) SetProductKey(v string) *QueryThingModelExtendConfigRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryThingModelExtendConfigRequest) SetResourceGroupId(v string) *QueryThingModelExtendConfigRequest {
	s.ResourceGroupId = &v
	return s
}

type QueryThingModelExtendConfigResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call is successful.
	Data *QueryThingModelExtendConfigResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryThingModelExtendConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelExtendConfigResponseBody) GoString() string {
	return s.String()
}

func (s *QueryThingModelExtendConfigResponseBody) SetCode(v string) *QueryThingModelExtendConfigResponseBody {
	s.Code = &v
	return s
}

func (s *QueryThingModelExtendConfigResponseBody) SetData(v *QueryThingModelExtendConfigResponseBodyData) *QueryThingModelExtendConfigResponseBody {
	s.Data = v
	return s
}

func (s *QueryThingModelExtendConfigResponseBody) SetErrorMessage(v string) *QueryThingModelExtendConfigResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryThingModelExtendConfigResponseBody) SetRequestId(v string) *QueryThingModelExtendConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryThingModelExtendConfigResponseBody) SetSuccess(v bool) *QueryThingModelExtendConfigResponseBody {
	s.Success = &v
	return s
}

type QueryThingModelExtendConfigResponseBodyData struct {
	// The information of the extended TSL parameters. For more information about the definition of extended parameters, see [CreateThingModel](~~150323~~).
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
}

func (s QueryThingModelExtendConfigResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelExtendConfigResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryThingModelExtendConfigResponseBodyData) SetConfiguration(v string) *QueryThingModelExtendConfigResponseBodyData {
	s.Configuration = &v
	return s
}

type QueryThingModelExtendConfigResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryThingModelExtendConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryThingModelExtendConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelExtendConfigResponse) GoString() string {
	return s.String()
}

func (s *QueryThingModelExtendConfigResponse) SetHeaders(v map[string]*string) *QueryThingModelExtendConfigResponse {
	s.Headers = v
	return s
}

func (s *QueryThingModelExtendConfigResponse) SetStatusCode(v int32) *QueryThingModelExtendConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryThingModelExtendConfigResponse) SetBody(v *QueryThingModelExtendConfigResponseBody) *QueryThingModelExtendConfigResponse {
	s.Body = v
	return s
}

type QueryThingModelExtendConfigPublishedRequest struct {
	// The identifier of the custom TSL module. Each identifier is unique in a product.
	//
	// If you do not specify this parameter, the default module is queried.
	FunctionBlockId *string `json:"FunctionBlockId,omitempty" xml:"FunctionBlockId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The version number of the TSL model. If you do not specify this parameter, the last published TSL model is returned.
	ModelVersion *string `json:"ModelVersion,omitempty" xml:"ModelVersion,omitempty"`
	// The **ProductKey** of the product.
	//
	// You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryThingModelExtendConfigPublishedRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelExtendConfigPublishedRequest) GoString() string {
	return s.String()
}

func (s *QueryThingModelExtendConfigPublishedRequest) SetFunctionBlockId(v string) *QueryThingModelExtendConfigPublishedRequest {
	s.FunctionBlockId = &v
	return s
}

func (s *QueryThingModelExtendConfigPublishedRequest) SetIotInstanceId(v string) *QueryThingModelExtendConfigPublishedRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryThingModelExtendConfigPublishedRequest) SetModelVersion(v string) *QueryThingModelExtendConfigPublishedRequest {
	s.ModelVersion = &v
	return s
}

func (s *QueryThingModelExtendConfigPublishedRequest) SetProductKey(v string) *QueryThingModelExtendConfigPublishedRequest {
	s.ProductKey = &v
	return s
}

type QueryThingModelExtendConfigPublishedResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call is successful.
	Data *QueryThingModelExtendConfigPublishedResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryThingModelExtendConfigPublishedResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelExtendConfigPublishedResponseBody) GoString() string {
	return s.String()
}

func (s *QueryThingModelExtendConfigPublishedResponseBody) SetCode(v string) *QueryThingModelExtendConfigPublishedResponseBody {
	s.Code = &v
	return s
}

func (s *QueryThingModelExtendConfigPublishedResponseBody) SetData(v *QueryThingModelExtendConfigPublishedResponseBodyData) *QueryThingModelExtendConfigPublishedResponseBody {
	s.Data = v
	return s
}

func (s *QueryThingModelExtendConfigPublishedResponseBody) SetErrorMessage(v string) *QueryThingModelExtendConfigPublishedResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryThingModelExtendConfigPublishedResponseBody) SetRequestId(v string) *QueryThingModelExtendConfigPublishedResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryThingModelExtendConfigPublishedResponseBody) SetSuccess(v bool) *QueryThingModelExtendConfigPublishedResponseBody {
	s.Success = &v
	return s
}

type QueryThingModelExtendConfigPublishedResponseBodyData struct {
	// The information about the extended TSL parameters. For more information about the definition of extended parameters, see [CreateThingModel](~~150323~~).
	//
	// For more information, see [Data structure of ThingModelJson](~~150457~~).
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
}

func (s QueryThingModelExtendConfigPublishedResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelExtendConfigPublishedResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryThingModelExtendConfigPublishedResponseBodyData) SetConfiguration(v string) *QueryThingModelExtendConfigPublishedResponseBodyData {
	s.Configuration = &v
	return s
}

type QueryThingModelExtendConfigPublishedResponse struct {
	Headers    map[string]*string                                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryThingModelExtendConfigPublishedResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryThingModelExtendConfigPublishedResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelExtendConfigPublishedResponse) GoString() string {
	return s.String()
}

func (s *QueryThingModelExtendConfigPublishedResponse) SetHeaders(v map[string]*string) *QueryThingModelExtendConfigPublishedResponse {
	s.Headers = v
	return s
}

func (s *QueryThingModelExtendConfigPublishedResponse) SetStatusCode(v int32) *QueryThingModelExtendConfigPublishedResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryThingModelExtendConfigPublishedResponse) SetBody(v *QueryThingModelExtendConfigPublishedResponseBody) *QueryThingModelExtendConfigPublishedResponse {
	s.Body = v
	return s
}

type QueryThingModelPublishedRequest struct {
	// The identifier of the custom TSL module. Each identifier is unique in a product.
	//
	// If you do not specify this parameter, the default module is queried.
	FunctionBlockId *string `json:"FunctionBlockId,omitempty" xml:"FunctionBlockId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The version number of the TSL model.
	//
	// You can call the [ListThingModelVersion](~~150318~~) operation to view the version numbers of the TSL model for a product.
	//
	// If you do not specify this parameter, the last published TSL model version is returned.
	ModelVersion *string `json:"ModelVersion,omitempty" xml:"ModelVersion,omitempty"`
	// The ProductKey of the product.
	ProductKey      *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	ResourceGroupId *string `json:"ResourceGroupId,omitempty" xml:"ResourceGroupId,omitempty"`
}

func (s QueryThingModelPublishedRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelPublishedRequest) GoString() string {
	return s.String()
}

func (s *QueryThingModelPublishedRequest) SetFunctionBlockId(v string) *QueryThingModelPublishedRequest {
	s.FunctionBlockId = &v
	return s
}

func (s *QueryThingModelPublishedRequest) SetIotInstanceId(v string) *QueryThingModelPublishedRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryThingModelPublishedRequest) SetModelVersion(v string) *QueryThingModelPublishedRequest {
	s.ModelVersion = &v
	return s
}

func (s *QueryThingModelPublishedRequest) SetProductKey(v string) *QueryThingModelPublishedRequest {
	s.ProductKey = &v
	return s
}

func (s *QueryThingModelPublishedRequest) SetResourceGroupId(v string) *QueryThingModelPublishedRequest {
	s.ResourceGroupId = &v
	return s
}

type QueryThingModelPublishedResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The returned data.
	Data *QueryThingModelPublishedResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ProductKey of the product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryThingModelPublishedResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelPublishedResponseBody) GoString() string {
	return s.String()
}

func (s *QueryThingModelPublishedResponseBody) SetCode(v string) *QueryThingModelPublishedResponseBody {
	s.Code = &v
	return s
}

func (s *QueryThingModelPublishedResponseBody) SetData(v *QueryThingModelPublishedResponseBodyData) *QueryThingModelPublishedResponseBody {
	s.Data = v
	return s
}

func (s *QueryThingModelPublishedResponseBody) SetErrorMessage(v string) *QueryThingModelPublishedResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryThingModelPublishedResponseBody) SetProductKey(v string) *QueryThingModelPublishedResponseBody {
	s.ProductKey = &v
	return s
}

func (s *QueryThingModelPublishedResponseBody) SetRequestId(v string) *QueryThingModelPublishedResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryThingModelPublishedResponseBody) SetSuccess(v bool) *QueryThingModelPublishedResponseBody {
	s.Success = &v
	return s
}

type QueryThingModelPublishedResponseBodyData struct {
	// Define features for the TSL model. For more information about the data format of the ThingModelJson parameter, see [Data structure of ThingModelJson](~~150457~~).
	ThingModelJson *string `json:"ThingModelJson,omitempty" xml:"ThingModelJson,omitempty"`
}

func (s QueryThingModelPublishedResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelPublishedResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryThingModelPublishedResponseBodyData) SetThingModelJson(v string) *QueryThingModelPublishedResponseBodyData {
	s.ThingModelJson = &v
	return s
}

type QueryThingModelPublishedResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryThingModelPublishedResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryThingModelPublishedResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryThingModelPublishedResponse) GoString() string {
	return s.String()
}

func (s *QueryThingModelPublishedResponse) SetHeaders(v map[string]*string) *QueryThingModelPublishedResponse {
	s.Headers = v
	return s
}

func (s *QueryThingModelPublishedResponse) SetStatusCode(v int32) *QueryThingModelPublishedResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryThingModelPublishedResponse) SetBody(v *QueryThingModelPublishedResponseBody) *QueryThingModelPublishedResponse {
	s.Body = v
	return s
}

type QueryTopicConfigRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryTopicConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryTopicConfigRequest) GoString() string {
	return s.String()
}

func (s *QueryTopicConfigRequest) SetIotInstanceId(v string) *QueryTopicConfigRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryTopicConfigRequest) SetProductKey(v string) *QueryTopicConfigRequest {
	s.ProductKey = &v
	return s
}

type QueryTopicConfigResponseBody struct {
	Code      *string                           `json:"Code,omitempty" xml:"Code,omitempty"`
	Data      *QueryTopicConfigResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	Message   *string                           `json:"Message,omitempty" xml:"Message,omitempty"`
	RequestId *string                           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success   *bool                             `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryTopicConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryTopicConfigResponseBody) GoString() string {
	return s.String()
}

func (s *QueryTopicConfigResponseBody) SetCode(v string) *QueryTopicConfigResponseBody {
	s.Code = &v
	return s
}

func (s *QueryTopicConfigResponseBody) SetData(v *QueryTopicConfigResponseBodyData) *QueryTopicConfigResponseBody {
	s.Data = v
	return s
}

func (s *QueryTopicConfigResponseBody) SetMessage(v string) *QueryTopicConfigResponseBody {
	s.Message = &v
	return s
}

func (s *QueryTopicConfigResponseBody) SetRequestId(v string) *QueryTopicConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryTopicConfigResponseBody) SetSuccess(v bool) *QueryTopicConfigResponseBody {
	s.Success = &v
	return s
}

type QueryTopicConfigResponseBodyData struct {
	TopicConfigInfo []*QueryTopicConfigResponseBodyDataTopicConfigInfo `json:"TopicConfigInfo,omitempty" xml:"TopicConfigInfo,omitempty" type:"Repeated"`
}

func (s QueryTopicConfigResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryTopicConfigResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryTopicConfigResponseBodyData) SetTopicConfigInfo(v []*QueryTopicConfigResponseBodyDataTopicConfigInfo) *QueryTopicConfigResponseBodyData {
	s.TopicConfigInfo = v
	return s
}

type QueryTopicConfigResponseBodyDataTopicConfigInfo struct {
	Codec                *string `json:"Codec,omitempty" xml:"Codec,omitempty"`
	Description          *string `json:"Description,omitempty" xml:"Description,omitempty"`
	EnableBroadcast      *bool   `json:"EnableBroadcast,omitempty" xml:"EnableBroadcast,omitempty"`
	EnableProxySubscribe *bool   `json:"EnableProxySubscribe,omitempty" xml:"EnableProxySubscribe,omitempty"`
	Operation            *string `json:"Operation,omitempty" xml:"Operation,omitempty"`
	ProductKey           *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	TopicFullName        *string `json:"TopicFullName,omitempty" xml:"TopicFullName,omitempty"`
}

func (s QueryTopicConfigResponseBodyDataTopicConfigInfo) String() string {
	return tea.Prettify(s)
}

func (s QueryTopicConfigResponseBodyDataTopicConfigInfo) GoString() string {
	return s.String()
}

func (s *QueryTopicConfigResponseBodyDataTopicConfigInfo) SetCodec(v string) *QueryTopicConfigResponseBodyDataTopicConfigInfo {
	s.Codec = &v
	return s
}

func (s *QueryTopicConfigResponseBodyDataTopicConfigInfo) SetDescription(v string) *QueryTopicConfigResponseBodyDataTopicConfigInfo {
	s.Description = &v
	return s
}

func (s *QueryTopicConfigResponseBodyDataTopicConfigInfo) SetEnableBroadcast(v bool) *QueryTopicConfigResponseBodyDataTopicConfigInfo {
	s.EnableBroadcast = &v
	return s
}

func (s *QueryTopicConfigResponseBodyDataTopicConfigInfo) SetEnableProxySubscribe(v bool) *QueryTopicConfigResponseBodyDataTopicConfigInfo {
	s.EnableProxySubscribe = &v
	return s
}

func (s *QueryTopicConfigResponseBodyDataTopicConfigInfo) SetOperation(v string) *QueryTopicConfigResponseBodyDataTopicConfigInfo {
	s.Operation = &v
	return s
}

func (s *QueryTopicConfigResponseBodyDataTopicConfigInfo) SetProductKey(v string) *QueryTopicConfigResponseBodyDataTopicConfigInfo {
	s.ProductKey = &v
	return s
}

func (s *QueryTopicConfigResponseBodyDataTopicConfigInfo) SetTopicFullName(v string) *QueryTopicConfigResponseBodyDataTopicConfigInfo {
	s.TopicFullName = &v
	return s
}

type QueryTopicConfigResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryTopicConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryTopicConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryTopicConfigResponse) GoString() string {
	return s.String()
}

func (s *QueryTopicConfigResponse) SetHeaders(v map[string]*string) *QueryTopicConfigResponse {
	s.Headers = v
	return s
}

func (s *QueryTopicConfigResponse) SetStatusCode(v int32) *QueryTopicConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryTopicConfigResponse) SetBody(v *QueryTopicConfigResponseBody) *QueryTopicConfigResponse {
	s.Body = v
	return s
}

type QueryTopicReverseRouteTableRequest struct {
	// The region where your devices reside. The region you specify must match the region that is specified in the console. Example: cn-shanghai.
	//
	// >  This parameter is no longer used as an operation-specific request parameter. It is included in common request parameters.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The destination topic that receives messages.
	RegionId *string `json:"RegionId,omitempty" xml:"RegionId,omitempty"`
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Topic *string `json:"Topic,omitempty" xml:"Topic,omitempty"`
}

func (s QueryTopicReverseRouteTableRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryTopicReverseRouteTableRequest) GoString() string {
	return s.String()
}

func (s *QueryTopicReverseRouteTableRequest) SetIotInstanceId(v string) *QueryTopicReverseRouteTableRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryTopicReverseRouteTableRequest) SetRegionId(v string) *QueryTopicReverseRouteTableRequest {
	s.RegionId = &v
	return s
}

func (s *QueryTopicReverseRouteTableRequest) SetTopic(v string) *QueryTopicReverseRouteTableRequest {
	s.Topic = &v
	return s
}

type QueryTopicReverseRouteTableResponseBody struct {
	// The error message returned if the call fails.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The ID of the request.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	RequestId *string                                           `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	SrcTopics *QueryTopicReverseRouteTableResponseBodySrcTopics `json:"SrcTopics,omitempty" xml:"SrcTopics,omitempty" type:"Struct"`
	// The list of source topics returned if the call is successful.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryTopicReverseRouteTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryTopicReverseRouteTableResponseBody) GoString() string {
	return s.String()
}

func (s *QueryTopicReverseRouteTableResponseBody) SetCode(v string) *QueryTopicReverseRouteTableResponseBody {
	s.Code = &v
	return s
}

func (s *QueryTopicReverseRouteTableResponseBody) SetErrorMessage(v string) *QueryTopicReverseRouteTableResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryTopicReverseRouteTableResponseBody) SetRequestId(v string) *QueryTopicReverseRouteTableResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryTopicReverseRouteTableResponseBody) SetSrcTopics(v *QueryTopicReverseRouteTableResponseBodySrcTopics) *QueryTopicReverseRouteTableResponseBody {
	s.SrcTopics = v
	return s
}

func (s *QueryTopicReverseRouteTableResponseBody) SetSuccess(v bool) *QueryTopicReverseRouteTableResponseBody {
	s.Success = &v
	return s
}

type QueryTopicReverseRouteTableResponseBodySrcTopics struct {
	Topic []map[string]interface{} `json:"Topic,omitempty" xml:"Topic,omitempty" type:"Repeated"`
}

func (s QueryTopicReverseRouteTableResponseBodySrcTopics) String() string {
	return tea.Prettify(s)
}

func (s QueryTopicReverseRouteTableResponseBodySrcTopics) GoString() string {
	return s.String()
}

func (s *QueryTopicReverseRouteTableResponseBodySrcTopics) SetTopic(v []map[string]interface{}) *QueryTopicReverseRouteTableResponseBodySrcTopics {
	s.Topic = v
	return s
}

type QueryTopicReverseRouteTableResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryTopicReverseRouteTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryTopicReverseRouteTableResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryTopicReverseRouteTableResponse) GoString() string {
	return s.String()
}

func (s *QueryTopicReverseRouteTableResponse) SetHeaders(v map[string]*string) *QueryTopicReverseRouteTableResponse {
	s.Headers = v
	return s
}

func (s *QueryTopicReverseRouteTableResponse) SetStatusCode(v int32) *QueryTopicReverseRouteTableResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryTopicReverseRouteTableResponse) SetBody(v *QueryTopicReverseRouteTableResponseBody) *QueryTopicReverseRouteTableResponse {
	s.Body = v
	return s
}

type QueryTopicRouteTableRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The source topic that publishes messages.
	Topic *string `json:"Topic,omitempty" xml:"Topic,omitempty"`
}

func (s QueryTopicRouteTableRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryTopicRouteTableRequest) GoString() string {
	return s.String()
}

func (s *QueryTopicRouteTableRequest) SetIotInstanceId(v string) *QueryTopicRouteTableRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryTopicRouteTableRequest) SetTopic(v string) *QueryTopicRouteTableRequest {
	s.Topic = &v
	return s
}

type QueryTopicRouteTableResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The list of destination topics returned if the call is successful.
	DstTopics *QueryTopicRouteTableResponseBodyDstTopics `json:"DstTopics,omitempty" xml:"DstTopics,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryTopicRouteTableResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryTopicRouteTableResponseBody) GoString() string {
	return s.String()
}

func (s *QueryTopicRouteTableResponseBody) SetCode(v string) *QueryTopicRouteTableResponseBody {
	s.Code = &v
	return s
}

func (s *QueryTopicRouteTableResponseBody) SetDstTopics(v *QueryTopicRouteTableResponseBodyDstTopics) *QueryTopicRouteTableResponseBody {
	s.DstTopics = v
	return s
}

func (s *QueryTopicRouteTableResponseBody) SetErrorMessage(v string) *QueryTopicRouteTableResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryTopicRouteTableResponseBody) SetRequestId(v string) *QueryTopicRouteTableResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryTopicRouteTableResponseBody) SetSuccess(v bool) *QueryTopicRouteTableResponseBody {
	s.Success = &v
	return s
}

type QueryTopicRouteTableResponseBodyDstTopics struct {
	Topic []map[string]interface{} `json:"Topic,omitempty" xml:"Topic,omitempty" type:"Repeated"`
}

func (s QueryTopicRouteTableResponseBodyDstTopics) String() string {
	return tea.Prettify(s)
}

func (s QueryTopicRouteTableResponseBodyDstTopics) GoString() string {
	return s.String()
}

func (s *QueryTopicRouteTableResponseBodyDstTopics) SetTopic(v []map[string]interface{}) *QueryTopicRouteTableResponseBodyDstTopics {
	s.Topic = v
	return s
}

type QueryTopicRouteTableResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryTopicRouteTableResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryTopicRouteTableResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryTopicRouteTableResponse) GoString() string {
	return s.String()
}

func (s *QueryTopicRouteTableResponse) SetHeaders(v map[string]*string) *QueryTopicRouteTableResponse {
	s.Headers = v
	return s
}

func (s *QueryTopicRouteTableResponse) SetStatusCode(v int32) *QueryTopicRouteTableResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryTopicRouteTableResponse) SetBody(v *QueryTopicRouteTableResponseBody) *QueryTopicRouteTableResponse {
	s.Body = v
	return s
}

type QueryVehicleDeviceRequest struct {
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Instance Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the gateway product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s QueryVehicleDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s QueryVehicleDeviceRequest) GoString() string {
	return s.String()
}

func (s *QueryVehicleDeviceRequest) SetDeviceName(v string) *QueryVehicleDeviceRequest {
	s.DeviceName = &v
	return s
}

func (s *QueryVehicleDeviceRequest) SetIotInstanceId(v string) *QueryVehicleDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *QueryVehicleDeviceRequest) SetProductKey(v string) *QueryVehicleDeviceRequest {
	s.ProductKey = &v
	return s
}

type QueryVehicleDeviceResponseBody struct {
	// The error code returned if the call fails. For more information, see the "**Error codes**" section of this topic.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The device information returned.
	Data *QueryVehicleDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s QueryVehicleDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s QueryVehicleDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *QueryVehicleDeviceResponseBody) SetCode(v string) *QueryVehicleDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *QueryVehicleDeviceResponseBody) SetData(v *QueryVehicleDeviceResponseBodyData) *QueryVehicleDeviceResponseBody {
	s.Data = v
	return s
}

func (s *QueryVehicleDeviceResponseBody) SetErrorMessage(v string) *QueryVehicleDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *QueryVehicleDeviceResponseBody) SetRequestId(v string) *QueryVehicleDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *QueryVehicleDeviceResponseBody) SetSuccess(v bool) *QueryVehicleDeviceResponseBody {
	s.Success = &v
	return s
}

type QueryVehicleDeviceResponseBodyData struct {
	// The timestamp when the device was created. Unit: milliseconds.
	CreateTime *int64 `json:"CreateTime,omitempty" xml:"CreateTime,omitempty"`
	// The DeviceName of the device.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID is a unique identifier that is issued by IoT Platform to the device.
	IotId                *string                                                 `json:"IotId,omitempty" xml:"IotId,omitempty"`
	JtProtocolDeviceData *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData `json:"JtProtocolDeviceData,omitempty" xml:"JtProtocolDeviceData,omitempty" type:"Struct"`
	// The timestamp when the device was last updated. Unit: milliseconds.
	ModifiedTime *int64 `json:"ModifiedTime,omitempty" xml:"ModifiedTime,omitempty"`
	// The **ProductKey** of the gateway product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	Protocol   *string `json:"Protocol,omitempty" xml:"Protocol,omitempty"`
}

func (s QueryVehicleDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s QueryVehicleDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *QueryVehicleDeviceResponseBodyData) SetCreateTime(v int64) *QueryVehicleDeviceResponseBodyData {
	s.CreateTime = &v
	return s
}

func (s *QueryVehicleDeviceResponseBodyData) SetDeviceName(v string) *QueryVehicleDeviceResponseBodyData {
	s.DeviceName = &v
	return s
}

func (s *QueryVehicleDeviceResponseBodyData) SetIotId(v string) *QueryVehicleDeviceResponseBodyData {
	s.IotId = &v
	return s
}

func (s *QueryVehicleDeviceResponseBodyData) SetJtProtocolDeviceData(v *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData) *QueryVehicleDeviceResponseBodyData {
	s.JtProtocolDeviceData = v
	return s
}

func (s *QueryVehicleDeviceResponseBodyData) SetModifiedTime(v int64) *QueryVehicleDeviceResponseBodyData {
	s.ModifiedTime = &v
	return s
}

func (s *QueryVehicleDeviceResponseBodyData) SetProductKey(v string) *QueryVehicleDeviceResponseBodyData {
	s.ProductKey = &v
	return s
}

func (s *QueryVehicleDeviceResponseBodyData) SetProtocol(v string) *QueryVehicleDeviceResponseBodyData {
	s.Protocol = &v
	return s
}

type QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData struct {
	AuthCode      *string `json:"AuthCode,omitempty" xml:"AuthCode,omitempty"`
	City          *string `json:"City,omitempty" xml:"City,omitempty"`
	DeviceId      *string `json:"DeviceId,omitempty" xml:"DeviceId,omitempty"`
	DeviceModel   *string `json:"DeviceModel,omitempty" xml:"DeviceModel,omitempty"`
	Manufacturer  *string `json:"Manufacturer,omitempty" xml:"Manufacturer,omitempty"`
	Province      *string `json:"Province,omitempty" xml:"Province,omitempty"`
	RegisterTime  *string `json:"RegisterTime,omitempty" xml:"RegisterTime,omitempty"`
	Status        *string `json:"Status,omitempty" xml:"Status,omitempty"`
	VehicleColour *string `json:"VehicleColour,omitempty" xml:"VehicleColour,omitempty"`
	VehicleNumber *string `json:"VehicleNumber,omitempty" xml:"VehicleNumber,omitempty"`
}

func (s QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData) String() string {
	return tea.Prettify(s)
}

func (s QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData) GoString() string {
	return s.String()
}

func (s *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData) SetAuthCode(v string) *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData {
	s.AuthCode = &v
	return s
}

func (s *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData) SetCity(v string) *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData {
	s.City = &v
	return s
}

func (s *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData) SetDeviceId(v string) *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData {
	s.DeviceId = &v
	return s
}

func (s *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData) SetDeviceModel(v string) *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData {
	s.DeviceModel = &v
	return s
}

func (s *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData) SetManufacturer(v string) *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData {
	s.Manufacturer = &v
	return s
}

func (s *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData) SetProvince(v string) *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData {
	s.Province = &v
	return s
}

func (s *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData) SetRegisterTime(v string) *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData {
	s.RegisterTime = &v
	return s
}

func (s *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData) SetStatus(v string) *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData {
	s.Status = &v
	return s
}

func (s *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData) SetVehicleColour(v string) *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData {
	s.VehicleColour = &v
	return s
}

func (s *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData) SetVehicleNumber(v string) *QueryVehicleDeviceResponseBodyDataJtProtocolDeviceData {
	s.VehicleNumber = &v
	return s
}

type QueryVehicleDeviceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *QueryVehicleDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s QueryVehicleDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s QueryVehicleDeviceResponse) GoString() string {
	return s.String()
}

func (s *QueryVehicleDeviceResponse) SetHeaders(v map[string]*string) *QueryVehicleDeviceResponse {
	s.Headers = v
	return s
}

func (s *QueryVehicleDeviceResponse) SetStatusCode(v int32) *QueryVehicleDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *QueryVehicleDeviceResponse) SetBody(v *QueryVehicleDeviceResponseBody) *QueryVehicleDeviceResponse {
	s.Body = v
	return s
}

type RRpcRequest struct {
	ContentType *string `json:"ContentType,omitempty" xml:"ContentType,omitempty"`
	// The name of the device that receives the request.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey        *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	RequestBase64Byte *string `json:"RequestBase64Byte,omitempty" xml:"RequestBase64Byte,omitempty"`
	// The timeout period of a response. Unit: milliseconds. Valid values: 1000 to 8000.
	Timeout *int32 `json:"Timeout,omitempty" xml:"Timeout,omitempty"`
	// The custom revert-RPC (RRPC) topic. Before you can use a custom RRPC topic, you must configure the device. For more information, see [Use custom topics](~~90570~~).
	//
	// If you do not configure this parameter, the default RRPC topic is used.
	Topic *string `json:"Topic,omitempty" xml:"Topic,omitempty"`
}

func (s RRpcRequest) String() string {
	return tea.Prettify(s)
}

func (s RRpcRequest) GoString() string {
	return s.String()
}

func (s *RRpcRequest) SetContentType(v string) *RRpcRequest {
	s.ContentType = &v
	return s
}

func (s *RRpcRequest) SetDeviceName(v string) *RRpcRequest {
	s.DeviceName = &v
	return s
}

func (s *RRpcRequest) SetIotInstanceId(v string) *RRpcRequest {
	s.IotInstanceId = &v
	return s
}

func (s *RRpcRequest) SetProductKey(v string) *RRpcRequest {
	s.ProductKey = &v
	return s
}

func (s *RRpcRequest) SetRequestBase64Byte(v string) *RRpcRequest {
	s.RequestBase64Byte = &v
	return s
}

func (s *RRpcRequest) SetTimeout(v int32) *RRpcRequest {
	s.Timeout = &v
	return s
}

func (s *RRpcRequest) SetTopic(v string) *RRpcRequest {
	s.Topic = &v
	return s
}

type RRpcResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request. The request ID is generated by IoT Platform after the request is sent.
	MessageId *int64 `json:"MessageId,omitempty" xml:"MessageId,omitempty"`
	// The Base64 encoded payload that is returned by the device.
	PayloadBase64Byte *string `json:"PayloadBase64Byte,omitempty" xml:"PayloadBase64Byte,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// The response code returned if the call is successful. Valid values:
	//
	// *   **UNKNOWN**: A system error occurred.
	// *   **SUCCESS**: The request is successful.
	// *   **TIMEOUT**: The request times out.
	// *   **OFFLINE**: The device is offline.
	// *   **HALFCONN**: The device is offline. If the status of the device is HALFCONN, the device is offline but does not remain offline for a full heartbeat cycle.
	RrpcCode *string `json:"RrpcCode,omitempty" xml:"RrpcCode,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RRpcResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RRpcResponseBody) GoString() string {
	return s.String()
}

func (s *RRpcResponseBody) SetCode(v string) *RRpcResponseBody {
	s.Code = &v
	return s
}

func (s *RRpcResponseBody) SetErrorMessage(v string) *RRpcResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RRpcResponseBody) SetMessageId(v int64) *RRpcResponseBody {
	s.MessageId = &v
	return s
}

func (s *RRpcResponseBody) SetPayloadBase64Byte(v string) *RRpcResponseBody {
	s.PayloadBase64Byte = &v
	return s
}

func (s *RRpcResponseBody) SetRequestId(v string) *RRpcResponseBody {
	s.RequestId = &v
	return s
}

func (s *RRpcResponseBody) SetRrpcCode(v string) *RRpcResponseBody {
	s.RrpcCode = &v
	return s
}

func (s *RRpcResponseBody) SetSuccess(v bool) *RRpcResponseBody {
	s.Success = &v
	return s
}

type RRpcResponse struct {
	Headers    map[string]*string `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32             `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RRpcResponseBody  `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RRpcResponse) String() string {
	return tea.Prettify(s)
}

func (s RRpcResponse) GoString() string {
	return s.String()
}

func (s *RRpcResponse) SetHeaders(v map[string]*string) *RRpcResponse {
	s.Headers = v
	return s
}

func (s *RRpcResponse) SetStatusCode(v int32) *RRpcResponse {
	s.StatusCode = &v
	return s
}

func (s *RRpcResponse) SetBody(v *RRpcResponseBody) *RRpcResponse {
	s.Body = v
	return s
}

type ReBindLicenseDeviceRequest struct {
	// The **DeviceNames** of all devices to which you want to rebind a license.
	//
	// You can call the [QueryDevice](~~69905~~) operation to query the **DeviceNames** of all devices that belong to a specific product.
	DeviceNameList []*string `json:"DeviceNameList,omitempty" xml:"DeviceNameList,omitempty" type:"Repeated"`
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  You must specify the ID of a public instance of the new version or an Enterprise Edition instance. Otherwise, the request fails. You do not need to specify the ID of a public instance of the previous version.
	//
	// For more information, see [Overview](~~356505~~) of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The license type. Set the value to **LINK_SPEECH_COMMON_LICENSE**.
	LicenseCode *string `json:"LicenseCode,omitempty" xml:"LicenseCode,omitempty"`
	// The **ProductKey** of the product to which the devices belong.
	//
	// You can go to the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products of the instance.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s ReBindLicenseDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s ReBindLicenseDeviceRequest) GoString() string {
	return s.String()
}

func (s *ReBindLicenseDeviceRequest) SetDeviceNameList(v []*string) *ReBindLicenseDeviceRequest {
	s.DeviceNameList = v
	return s
}

func (s *ReBindLicenseDeviceRequest) SetIotInstanceId(v string) *ReBindLicenseDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ReBindLicenseDeviceRequest) SetLicenseCode(v string) *ReBindLicenseDeviceRequest {
	s.LicenseCode = &v
	return s
}

func (s *ReBindLicenseDeviceRequest) SetProductKey(v string) *ReBindLicenseDeviceRequest {
	s.ProductKey = &v
	return s
}

type ReBindLicenseDeviceResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The result of the batch rebinding operation.
	Data *ReBindLicenseDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ReBindLicenseDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReBindLicenseDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *ReBindLicenseDeviceResponseBody) SetCode(v string) *ReBindLicenseDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *ReBindLicenseDeviceResponseBody) SetData(v *ReBindLicenseDeviceResponseBodyData) *ReBindLicenseDeviceResponseBody {
	s.Data = v
	return s
}

func (s *ReBindLicenseDeviceResponseBody) SetErrorMessage(v string) *ReBindLicenseDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ReBindLicenseDeviceResponseBody) SetRequestId(v string) *ReBindLicenseDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *ReBindLicenseDeviceResponseBody) SetSuccess(v bool) *ReBindLicenseDeviceResponseBody {
	s.Success = &v
	return s
}

type ReBindLicenseDeviceResponseBodyData struct {
	// The unique ID that can be used to query the progress of the batch rebinding operation.
	CheckProgressId *string `json:"CheckProgressId,omitempty" xml:"CheckProgressId,omitempty"`
	// The number of devices that failed to be rebound to the license.
	FailSum *int64 `json:"FailSum,omitempty" xml:"FailSum,omitempty"`
	// The progress of the batch rebinding operation. The progress is a percentage. Valid values: 1 to 100.
	Progress *int32 `json:"Progress,omitempty" xml:"Progress,omitempty"`
	// The URL of the file that contains unbound devices. The devices failed to be rebound with the license.
	ResultCsvFile *string `json:"ResultCsvFile,omitempty" xml:"ResultCsvFile,omitempty"`
	// The number of devices to which the license is rebound.
	SuccessSum *int64 `json:"SuccessSum,omitempty" xml:"SuccessSum,omitempty"`
}

func (s ReBindLicenseDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s ReBindLicenseDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *ReBindLicenseDeviceResponseBodyData) SetCheckProgressId(v string) *ReBindLicenseDeviceResponseBodyData {
	s.CheckProgressId = &v
	return s
}

func (s *ReBindLicenseDeviceResponseBodyData) SetFailSum(v int64) *ReBindLicenseDeviceResponseBodyData {
	s.FailSum = &v
	return s
}

func (s *ReBindLicenseDeviceResponseBodyData) SetProgress(v int32) *ReBindLicenseDeviceResponseBodyData {
	s.Progress = &v
	return s
}

func (s *ReBindLicenseDeviceResponseBodyData) SetResultCsvFile(v string) *ReBindLicenseDeviceResponseBodyData {
	s.ResultCsvFile = &v
	return s
}

func (s *ReBindLicenseDeviceResponseBodyData) SetSuccessSum(v int64) *ReBindLicenseDeviceResponseBodyData {
	s.SuccessSum = &v
	return s
}

type ReBindLicenseDeviceResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReBindLicenseDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReBindLicenseDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s ReBindLicenseDeviceResponse) GoString() string {
	return s.String()
}

func (s *ReBindLicenseDeviceResponse) SetHeaders(v map[string]*string) *ReBindLicenseDeviceResponse {
	s.Headers = v
	return s
}

func (s *ReBindLicenseDeviceResponse) SetStatusCode(v int32) *ReBindLicenseDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *ReBindLicenseDeviceResponse) SetBody(v *ReBindLicenseDeviceResponseBody) *ReBindLicenseDeviceResponse {
	s.Body = v
	return s
}

type RecognizeCarNumRequest struct {
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s RecognizeCarNumRequest) String() string {
	return tea.Prettify(s)
}

func (s RecognizeCarNumRequest) GoString() string {
	return s.String()
}

func (s *RecognizeCarNumRequest) SetUrl(v string) *RecognizeCarNumRequest {
	s.Url = &v
	return s
}

type RecognizeCarNumResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RecognizeCarNumResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RecognizeCarNumResponseBody) GoString() string {
	return s.String()
}

func (s *RecognizeCarNumResponseBody) SetCode(v string) *RecognizeCarNumResponseBody {
	s.Code = &v
	return s
}

func (s *RecognizeCarNumResponseBody) SetData(v string) *RecognizeCarNumResponseBody {
	s.Data = &v
	return s
}

func (s *RecognizeCarNumResponseBody) SetErrorMessage(v string) *RecognizeCarNumResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RecognizeCarNumResponseBody) SetRequestId(v string) *RecognizeCarNumResponseBody {
	s.RequestId = &v
	return s
}

func (s *RecognizeCarNumResponseBody) SetSuccess(v bool) *RecognizeCarNumResponseBody {
	s.Success = &v
	return s
}

type RecognizeCarNumResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RecognizeCarNumResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RecognizeCarNumResponse) String() string {
	return tea.Prettify(s)
}

func (s RecognizeCarNumResponse) GoString() string {
	return s.String()
}

func (s *RecognizeCarNumResponse) SetHeaders(v map[string]*string) *RecognizeCarNumResponse {
	s.Headers = v
	return s
}

func (s *RecognizeCarNumResponse) SetStatusCode(v int32) *RecognizeCarNumResponse {
	s.StatusCode = &v
	return s
}

func (s *RecognizeCarNumResponse) SetBody(v *RecognizeCarNumResponseBody) *RecognizeCarNumResponse {
	s.Body = v
	return s
}

type RecognizePictureGeneralRequest struct {
	Url *string `json:"Url,omitempty" xml:"Url,omitempty"`
}

func (s RecognizePictureGeneralRequest) String() string {
	return tea.Prettify(s)
}

func (s RecognizePictureGeneralRequest) GoString() string {
	return s.String()
}

func (s *RecognizePictureGeneralRequest) SetUrl(v string) *RecognizePictureGeneralRequest {
	s.Url = &v
	return s
}

type RecognizePictureGeneralResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *string `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RecognizePictureGeneralResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RecognizePictureGeneralResponseBody) GoString() string {
	return s.String()
}

func (s *RecognizePictureGeneralResponseBody) SetCode(v string) *RecognizePictureGeneralResponseBody {
	s.Code = &v
	return s
}

func (s *RecognizePictureGeneralResponseBody) SetData(v string) *RecognizePictureGeneralResponseBody {
	s.Data = &v
	return s
}

func (s *RecognizePictureGeneralResponseBody) SetErrorMessage(v string) *RecognizePictureGeneralResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RecognizePictureGeneralResponseBody) SetRequestId(v string) *RecognizePictureGeneralResponseBody {
	s.RequestId = &v
	return s
}

func (s *RecognizePictureGeneralResponseBody) SetSuccess(v bool) *RecognizePictureGeneralResponseBody {
	s.Success = &v
	return s
}

type RecognizePictureGeneralResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RecognizePictureGeneralResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RecognizePictureGeneralResponse) String() string {
	return tea.Prettify(s)
}

func (s RecognizePictureGeneralResponse) GoString() string {
	return s.String()
}

func (s *RecognizePictureGeneralResponse) SetHeaders(v map[string]*string) *RecognizePictureGeneralResponse {
	s.Headers = v
	return s
}

func (s *RecognizePictureGeneralResponse) SetStatusCode(v int32) *RecognizePictureGeneralResponse {
	s.StatusCode = &v
	return s
}

func (s *RecognizePictureGeneralResponse) SetBody(v *RecognizePictureGeneralResponseBody) *RecognizePictureGeneralResponse {
	s.Body = v
	return s
}

type RefreshDeviceTunnelSharePasswordRequest struct {
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s RefreshDeviceTunnelSharePasswordRequest) String() string {
	return tea.Prettify(s)
}

func (s RefreshDeviceTunnelSharePasswordRequest) GoString() string {
	return s.String()
}

func (s *RefreshDeviceTunnelSharePasswordRequest) SetDeviceName(v string) *RefreshDeviceTunnelSharePasswordRequest {
	s.DeviceName = &v
	return s
}

func (s *RefreshDeviceTunnelSharePasswordRequest) SetIotInstanceId(v string) *RefreshDeviceTunnelSharePasswordRequest {
	s.IotInstanceId = &v
	return s
}

func (s *RefreshDeviceTunnelSharePasswordRequest) SetProductKey(v string) *RefreshDeviceTunnelSharePasswordRequest {
	s.ProductKey = &v
	return s
}

type RefreshDeviceTunnelSharePasswordResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	Password     *string `json:"Password,omitempty" xml:"Password,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RefreshDeviceTunnelSharePasswordResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RefreshDeviceTunnelSharePasswordResponseBody) GoString() string {
	return s.String()
}

func (s *RefreshDeviceTunnelSharePasswordResponseBody) SetCode(v string) *RefreshDeviceTunnelSharePasswordResponseBody {
	s.Code = &v
	return s
}

func (s *RefreshDeviceTunnelSharePasswordResponseBody) SetErrorMessage(v string) *RefreshDeviceTunnelSharePasswordResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RefreshDeviceTunnelSharePasswordResponseBody) SetPassword(v string) *RefreshDeviceTunnelSharePasswordResponseBody {
	s.Password = &v
	return s
}

func (s *RefreshDeviceTunnelSharePasswordResponseBody) SetRequestId(v string) *RefreshDeviceTunnelSharePasswordResponseBody {
	s.RequestId = &v
	return s
}

func (s *RefreshDeviceTunnelSharePasswordResponseBody) SetSuccess(v bool) *RefreshDeviceTunnelSharePasswordResponseBody {
	s.Success = &v
	return s
}

type RefreshDeviceTunnelSharePasswordResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RefreshDeviceTunnelSharePasswordResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RefreshDeviceTunnelSharePasswordResponse) String() string {
	return tea.Prettify(s)
}

func (s RefreshDeviceTunnelSharePasswordResponse) GoString() string {
	return s.String()
}

func (s *RefreshDeviceTunnelSharePasswordResponse) SetHeaders(v map[string]*string) *RefreshDeviceTunnelSharePasswordResponse {
	s.Headers = v
	return s
}

func (s *RefreshDeviceTunnelSharePasswordResponse) SetStatusCode(v int32) *RefreshDeviceTunnelSharePasswordResponse {
	s.StatusCode = &v
	return s
}

func (s *RefreshDeviceTunnelSharePasswordResponse) SetBody(v *RefreshDeviceTunnelSharePasswordResponseBody) *RefreshDeviceTunnelSharePasswordResponse {
	s.Body = v
	return s
}

type RefreshStudioAppTokenOpenRequest struct {
	AppId         *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProjectId     *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s RefreshStudioAppTokenOpenRequest) String() string {
	return tea.Prettify(s)
}

func (s RefreshStudioAppTokenOpenRequest) GoString() string {
	return s.String()
}

func (s *RefreshStudioAppTokenOpenRequest) SetAppId(v string) *RefreshStudioAppTokenOpenRequest {
	s.AppId = &v
	return s
}

func (s *RefreshStudioAppTokenOpenRequest) SetIotInstanceId(v string) *RefreshStudioAppTokenOpenRequest {
	s.IotInstanceId = &v
	return s
}

func (s *RefreshStudioAppTokenOpenRequest) SetProjectId(v string) *RefreshStudioAppTokenOpenRequest {
	s.ProjectId = &v
	return s
}

type RefreshStudioAppTokenOpenResponseBody struct {
	Code         *string                                    `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *RefreshStudioAppTokenOpenResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                    `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                    `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                      `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RefreshStudioAppTokenOpenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RefreshStudioAppTokenOpenResponseBody) GoString() string {
	return s.String()
}

func (s *RefreshStudioAppTokenOpenResponseBody) SetCode(v string) *RefreshStudioAppTokenOpenResponseBody {
	s.Code = &v
	return s
}

func (s *RefreshStudioAppTokenOpenResponseBody) SetData(v *RefreshStudioAppTokenOpenResponseBodyData) *RefreshStudioAppTokenOpenResponseBody {
	s.Data = v
	return s
}

func (s *RefreshStudioAppTokenOpenResponseBody) SetErrorMessage(v string) *RefreshStudioAppTokenOpenResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RefreshStudioAppTokenOpenResponseBody) SetRequestId(v string) *RefreshStudioAppTokenOpenResponseBody {
	s.RequestId = &v
	return s
}

func (s *RefreshStudioAppTokenOpenResponseBody) SetSuccess(v bool) *RefreshStudioAppTokenOpenResponseBody {
	s.Success = &v
	return s
}

type RefreshStudioAppTokenOpenResponseBodyData struct {
	BizId    *string `json:"BizId,omitempty" xml:"BizId,omitempty"`
	BizType  *string `json:"BizType,omitempty" xml:"BizType,omitempty"`
	IsEnable *string `json:"IsEnable,omitempty" xml:"IsEnable,omitempty"`
	Token    *string `json:"Token,omitempty" xml:"Token,omitempty"`
	Type     *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s RefreshStudioAppTokenOpenResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s RefreshStudioAppTokenOpenResponseBodyData) GoString() string {
	return s.String()
}

func (s *RefreshStudioAppTokenOpenResponseBodyData) SetBizId(v string) *RefreshStudioAppTokenOpenResponseBodyData {
	s.BizId = &v
	return s
}

func (s *RefreshStudioAppTokenOpenResponseBodyData) SetBizType(v string) *RefreshStudioAppTokenOpenResponseBodyData {
	s.BizType = &v
	return s
}

func (s *RefreshStudioAppTokenOpenResponseBodyData) SetIsEnable(v string) *RefreshStudioAppTokenOpenResponseBodyData {
	s.IsEnable = &v
	return s
}

func (s *RefreshStudioAppTokenOpenResponseBodyData) SetToken(v string) *RefreshStudioAppTokenOpenResponseBodyData {
	s.Token = &v
	return s
}

func (s *RefreshStudioAppTokenOpenResponseBodyData) SetType(v string) *RefreshStudioAppTokenOpenResponseBodyData {
	s.Type = &v
	return s
}

type RefreshStudioAppTokenOpenResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RefreshStudioAppTokenOpenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RefreshStudioAppTokenOpenResponse) String() string {
	return tea.Prettify(s)
}

func (s RefreshStudioAppTokenOpenResponse) GoString() string {
	return s.String()
}

func (s *RefreshStudioAppTokenOpenResponse) SetHeaders(v map[string]*string) *RefreshStudioAppTokenOpenResponse {
	s.Headers = v
	return s
}

func (s *RefreshStudioAppTokenOpenResponse) SetStatusCode(v int32) *RefreshStudioAppTokenOpenResponse {
	s.StatusCode = &v
	return s
}

func (s *RefreshStudioAppTokenOpenResponse) SetBody(v *RefreshStudioAppTokenOpenResponseBody) *RefreshStudioAppTokenOpenResponse {
	s.Body = v
	return s
}

type RegisterDeviceRequest struct {
	// The AppKey of the LoRaWAN device.
	//
	// When you create a LoRaWAN device, set **LoraNodeType** to **USERDEFINED**. This parameter is required.
	AppKey *string `json:"AppKey,omitempty" xml:"AppKey,omitempty"`
	// The DevEUI of the LoRaWAN device.
	//
	// This parameter is required when you create a LoRaWAN device.
	DevEui *string `json:"DevEui,omitempty" xml:"DevEui,omitempty"`
	// The DeviceName of the device. The name must be 4 to 32 characters in length, and can contain letters, digits, hyphens (-), underscores (\_), at signs (@), periods (.), and colons (:).
	//
	// You can use a combination of the DeviceName and ProductKey parameters to identify a device.
	//
	// >  If you do not specify this parameter, IoT Platform randomly generates a DeviceName.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The JoinEUI of the LoRaWAN device.
	//
	// When you create a LoRaWAN device, set **LoraNodeType** to **USERDEFINED**. This parameter is required.
	JoinEui *string `json:"JoinEui,omitempty" xml:"JoinEui,omitempty"`
	// The type of the LoRaWAN device. Valid values:
	//
	// *   **ALIYUNDEFINED**: The device is issued by Alibaba Cloud. You must specify **DevEui** and **PinCode**.
	// *   **USERDEFINED**: The device is user-defined. You must specify **DevEui**, **JoinEui**, and **AppKey**.
	LoraNodeType *string `json:"LoraNodeType,omitempty" xml:"LoraNodeType,omitempty"`
	// The alias of the device. The alias must be 4 to 64 characters in length, and can contain letters, digits, and underscores (\_).
	//
	// >  If you do not specify this parameter, IoT Platform does not generate an alias for the device.
	Nickname *string `json:"Nickname,omitempty" xml:"Nickname,omitempty"`
	// The PIN code of the LoRaWAN device. This parameter is used to verify the DevEUI.
	//
	// When you create a LoRaWAN device, set **LoraNodeType** to **ALIYUNDEFINED**. This parameter is required.
	PinCode *string `json:"PinCode,omitempty" xml:"PinCode,omitempty"`
	// The ProductKey of the product to which the device belongs. A ProductKey is a GUID that is issued by IoT Platform to a product.
	//
	// You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s RegisterDeviceRequest) String() string {
	return tea.Prettify(s)
}

func (s RegisterDeviceRequest) GoString() string {
	return s.String()
}

func (s *RegisterDeviceRequest) SetAppKey(v string) *RegisterDeviceRequest {
	s.AppKey = &v
	return s
}

func (s *RegisterDeviceRequest) SetDevEui(v string) *RegisterDeviceRequest {
	s.DevEui = &v
	return s
}

func (s *RegisterDeviceRequest) SetDeviceName(v string) *RegisterDeviceRequest {
	s.DeviceName = &v
	return s
}

func (s *RegisterDeviceRequest) SetIotInstanceId(v string) *RegisterDeviceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *RegisterDeviceRequest) SetJoinEui(v string) *RegisterDeviceRequest {
	s.JoinEui = &v
	return s
}

func (s *RegisterDeviceRequest) SetLoraNodeType(v string) *RegisterDeviceRequest {
	s.LoraNodeType = &v
	return s
}

func (s *RegisterDeviceRequest) SetNickname(v string) *RegisterDeviceRequest {
	s.Nickname = &v
	return s
}

func (s *RegisterDeviceRequest) SetPinCode(v string) *RegisterDeviceRequest {
	s.PinCode = &v
	return s
}

func (s *RegisterDeviceRequest) SetProductKey(v string) *RegisterDeviceRequest {
	s.ProductKey = &v
	return s
}

type RegisterDeviceResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The device information returned if the call is successful.
	Data *RegisterDeviceResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RegisterDeviceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RegisterDeviceResponseBody) GoString() string {
	return s.String()
}

func (s *RegisterDeviceResponseBody) SetCode(v string) *RegisterDeviceResponseBody {
	s.Code = &v
	return s
}

func (s *RegisterDeviceResponseBody) SetData(v *RegisterDeviceResponseBodyData) *RegisterDeviceResponseBody {
	s.Data = v
	return s
}

func (s *RegisterDeviceResponseBody) SetErrorMessage(v string) *RegisterDeviceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RegisterDeviceResponseBody) SetRequestId(v string) *RegisterDeviceResponseBody {
	s.RequestId = &v
	return s
}

func (s *RegisterDeviceResponseBody) SetSuccess(v bool) *RegisterDeviceResponseBody {
	s.Success = &v
	return s
}

type RegisterDeviceResponseBodyData struct {
	// The DevEUI of the LoRaWAN device. This parameter is returned only when you create a LoRaWAN device.
	DevEui *string `json:"DevEui,omitempty" xml:"DevEui,omitempty"`
	// The DeviceName of the device.
	//
	// > Keep the information confidential.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The DeviceSecret of the device.
	//
	// > Keep the information confidential.
	DeviceSecret *string `json:"DeviceSecret,omitempty" xml:"DeviceSecret,omitempty"`
	// The ID of the device. The ID is the unique identifier that is issued by IoT Platform to the device.
	//
	// > Keep the information confidential.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The JoinEUI of the LoRaWAN device. This parameter is returned only when you create a LoRaWAN device.
	JoinEui *string `json:"JoinEui,omitempty" xml:"JoinEui,omitempty"`
	// The alias of the device.
	//
	// If you do not specify an alias for the device, this parameter is empty.
	Nickname *string `json:"Nickname,omitempty" xml:"Nickname,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s RegisterDeviceResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s RegisterDeviceResponseBodyData) GoString() string {
	return s.String()
}

func (s *RegisterDeviceResponseBodyData) SetDevEui(v string) *RegisterDeviceResponseBodyData {
	s.DevEui = &v
	return s
}

func (s *RegisterDeviceResponseBodyData) SetDeviceName(v string) *RegisterDeviceResponseBodyData {
	s.DeviceName = &v
	return s
}

func (s *RegisterDeviceResponseBodyData) SetDeviceSecret(v string) *RegisterDeviceResponseBodyData {
	s.DeviceSecret = &v
	return s
}

func (s *RegisterDeviceResponseBodyData) SetIotId(v string) *RegisterDeviceResponseBodyData {
	s.IotId = &v
	return s
}

func (s *RegisterDeviceResponseBodyData) SetJoinEui(v string) *RegisterDeviceResponseBodyData {
	s.JoinEui = &v
	return s
}

func (s *RegisterDeviceResponseBodyData) SetNickname(v string) *RegisterDeviceResponseBodyData {
	s.Nickname = &v
	return s
}

func (s *RegisterDeviceResponseBodyData) SetProductKey(v string) *RegisterDeviceResponseBodyData {
	s.ProductKey = &v
	return s
}

type RegisterDeviceResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RegisterDeviceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RegisterDeviceResponse) String() string {
	return tea.Prettify(s)
}

func (s RegisterDeviceResponse) GoString() string {
	return s.String()
}

func (s *RegisterDeviceResponse) SetHeaders(v map[string]*string) *RegisterDeviceResponse {
	s.Headers = v
	return s
}

func (s *RegisterDeviceResponse) SetStatusCode(v int32) *RegisterDeviceResponse {
	s.StatusCode = &v
	return s
}

func (s *RegisterDeviceResponse) SetBody(v *RegisterDeviceResponseBody) *RegisterDeviceResponse {
	s.Body = v
	return s
}

type ReleaseEdgeDriverVersionRequest struct {
	DriverId      *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	DriverVersion *string `json:"DriverVersion,omitempty" xml:"DriverVersion,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s ReleaseEdgeDriverVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s ReleaseEdgeDriverVersionRequest) GoString() string {
	return s.String()
}

func (s *ReleaseEdgeDriverVersionRequest) SetDriverId(v string) *ReleaseEdgeDriverVersionRequest {
	s.DriverId = &v
	return s
}

func (s *ReleaseEdgeDriverVersionRequest) SetDriverVersion(v string) *ReleaseEdgeDriverVersionRequest {
	s.DriverVersion = &v
	return s
}

func (s *ReleaseEdgeDriverVersionRequest) SetIotInstanceId(v string) *ReleaseEdgeDriverVersionRequest {
	s.IotInstanceId = &v
	return s
}

type ReleaseEdgeDriverVersionResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ReleaseEdgeDriverVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReleaseEdgeDriverVersionResponseBody) GoString() string {
	return s.String()
}

func (s *ReleaseEdgeDriverVersionResponseBody) SetCode(v string) *ReleaseEdgeDriverVersionResponseBody {
	s.Code = &v
	return s
}

func (s *ReleaseEdgeDriverVersionResponseBody) SetErrorMessage(v string) *ReleaseEdgeDriverVersionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ReleaseEdgeDriverVersionResponseBody) SetRequestId(v string) *ReleaseEdgeDriverVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *ReleaseEdgeDriverVersionResponseBody) SetSuccess(v bool) *ReleaseEdgeDriverVersionResponseBody {
	s.Success = &v
	return s
}

type ReleaseEdgeDriverVersionResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReleaseEdgeDriverVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReleaseEdgeDriverVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s ReleaseEdgeDriverVersionResponse) GoString() string {
	return s.String()
}

func (s *ReleaseEdgeDriverVersionResponse) SetHeaders(v map[string]*string) *ReleaseEdgeDriverVersionResponse {
	s.Headers = v
	return s
}

func (s *ReleaseEdgeDriverVersionResponse) SetStatusCode(v int32) *ReleaseEdgeDriverVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *ReleaseEdgeDriverVersionResponse) SetBody(v *ReleaseEdgeDriverVersionResponseBody) *ReleaseEdgeDriverVersionResponse {
	s.Body = v
	return s
}

type ReleaseProductRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product to be published.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s ReleaseProductRequest) String() string {
	return tea.Prettify(s)
}

func (s ReleaseProductRequest) GoString() string {
	return s.String()
}

func (s *ReleaseProductRequest) SetIotInstanceId(v string) *ReleaseProductRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ReleaseProductRequest) SetProductKey(v string) *ReleaseProductRequest {
	s.ProductKey = &v
	return s
}

type ReleaseProductResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ReleaseProductResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReleaseProductResponseBody) GoString() string {
	return s.String()
}

func (s *ReleaseProductResponseBody) SetCode(v string) *ReleaseProductResponseBody {
	s.Code = &v
	return s
}

func (s *ReleaseProductResponseBody) SetErrorMessage(v string) *ReleaseProductResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ReleaseProductResponseBody) SetRequestId(v string) *ReleaseProductResponseBody {
	s.RequestId = &v
	return s
}

func (s *ReleaseProductResponseBody) SetSuccess(v bool) *ReleaseProductResponseBody {
	s.Success = &v
	return s
}

type ReleaseProductResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReleaseProductResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReleaseProductResponse) String() string {
	return tea.Prettify(s)
}

func (s ReleaseProductResponse) GoString() string {
	return s.String()
}

func (s *ReleaseProductResponse) SetHeaders(v map[string]*string) *ReleaseProductResponse {
	s.Headers = v
	return s
}

func (s *ReleaseProductResponse) SetStatusCode(v int32) *ReleaseProductResponse {
	s.StatusCode = &v
	return s
}

func (s *ReleaseProductResponse) SetBody(v *ReleaseProductResponseBody) *ReleaseProductResponse {
	s.Body = v
	return s
}

type RemoveThingTopoRequest struct {
	// The DeviceName of the device.
	//
	// >  If you specify a value for this parameter, you must also specify a value for the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// >  If you specify a value for this parameter, you do not need to specify a value for the **ProductKey** or **DeviceName** parameter. The IotId parameter specifies a globally unique identifier (GUID) for the device. The value of the **IotId** parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for the **IotId** parameter and values for the **ProductKey** and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	//
	// **Important**
	//
	// *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// *   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	//
	// >  If you specify a value for this parameter, you must also specify a value for the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s RemoveThingTopoRequest) String() string {
	return tea.Prettify(s)
}

func (s RemoveThingTopoRequest) GoString() string {
	return s.String()
}

func (s *RemoveThingTopoRequest) SetDeviceName(v string) *RemoveThingTopoRequest {
	s.DeviceName = &v
	return s
}

func (s *RemoveThingTopoRequest) SetIotId(v string) *RemoveThingTopoRequest {
	s.IotId = &v
	return s
}

func (s *RemoveThingTopoRequest) SetIotInstanceId(v string) *RemoveThingTopoRequest {
	s.IotInstanceId = &v
	return s
}

func (s *RemoveThingTopoRequest) SetProductKey(v string) *RemoveThingTopoRequest {
	s.ProductKey = &v
	return s
}

type RemoveThingTopoResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the topological relationship was deleted.
	//
	// *   **true**: The topological relationship was deleted.
	// *   **false**: The topological relationship failed to be deleted.
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RemoveThingTopoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RemoveThingTopoResponseBody) GoString() string {
	return s.String()
}

func (s *RemoveThingTopoResponseBody) SetCode(v string) *RemoveThingTopoResponseBody {
	s.Code = &v
	return s
}

func (s *RemoveThingTopoResponseBody) SetData(v bool) *RemoveThingTopoResponseBody {
	s.Data = &v
	return s
}

func (s *RemoveThingTopoResponseBody) SetErrorMessage(v string) *RemoveThingTopoResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RemoveThingTopoResponseBody) SetRequestId(v string) *RemoveThingTopoResponseBody {
	s.RequestId = &v
	return s
}

func (s *RemoveThingTopoResponseBody) SetSuccess(v bool) *RemoveThingTopoResponseBody {
	s.Success = &v
	return s
}

type RemoveThingTopoResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RemoveThingTopoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RemoveThingTopoResponse) String() string {
	return tea.Prettify(s)
}

func (s RemoveThingTopoResponse) GoString() string {
	return s.String()
}

func (s *RemoveThingTopoResponse) SetHeaders(v map[string]*string) *RemoveThingTopoResponse {
	s.Headers = v
	return s
}

func (s *RemoveThingTopoResponse) SetStatusCode(v int32) *RemoveThingTopoResponse {
	s.StatusCode = &v
	return s
}

func (s *RemoveThingTopoResponse) SetBody(v *RemoveThingTopoResponseBody) *RemoveThingTopoResponse {
	s.Body = v
	return s
}

type ReplaceEdgeInstanceGatewayRequest struct {
	CurrentGatewayId *string `json:"CurrentGatewayId,omitempty" xml:"CurrentGatewayId,omitempty"`
	InstanceId       *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId    *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	NewGatewayId     *string `json:"NewGatewayId,omitempty" xml:"NewGatewayId,omitempty"`
}

func (s ReplaceEdgeInstanceGatewayRequest) String() string {
	return tea.Prettify(s)
}

func (s ReplaceEdgeInstanceGatewayRequest) GoString() string {
	return s.String()
}

func (s *ReplaceEdgeInstanceGatewayRequest) SetCurrentGatewayId(v string) *ReplaceEdgeInstanceGatewayRequest {
	s.CurrentGatewayId = &v
	return s
}

func (s *ReplaceEdgeInstanceGatewayRequest) SetInstanceId(v string) *ReplaceEdgeInstanceGatewayRequest {
	s.InstanceId = &v
	return s
}

func (s *ReplaceEdgeInstanceGatewayRequest) SetIotInstanceId(v string) *ReplaceEdgeInstanceGatewayRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ReplaceEdgeInstanceGatewayRequest) SetNewGatewayId(v string) *ReplaceEdgeInstanceGatewayRequest {
	s.NewGatewayId = &v
	return s
}

type ReplaceEdgeInstanceGatewayResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ReplaceEdgeInstanceGatewayResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReplaceEdgeInstanceGatewayResponseBody) GoString() string {
	return s.String()
}

func (s *ReplaceEdgeInstanceGatewayResponseBody) SetCode(v string) *ReplaceEdgeInstanceGatewayResponseBody {
	s.Code = &v
	return s
}

func (s *ReplaceEdgeInstanceGatewayResponseBody) SetErrorMessage(v string) *ReplaceEdgeInstanceGatewayResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ReplaceEdgeInstanceGatewayResponseBody) SetRequestId(v string) *ReplaceEdgeInstanceGatewayResponseBody {
	s.RequestId = &v
	return s
}

func (s *ReplaceEdgeInstanceGatewayResponseBody) SetSuccess(v bool) *ReplaceEdgeInstanceGatewayResponseBody {
	s.Success = &v
	return s
}

type ReplaceEdgeInstanceGatewayResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReplaceEdgeInstanceGatewayResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReplaceEdgeInstanceGatewayResponse) String() string {
	return tea.Prettify(s)
}

func (s ReplaceEdgeInstanceGatewayResponse) GoString() string {
	return s.String()
}

func (s *ReplaceEdgeInstanceGatewayResponse) SetHeaders(v map[string]*string) *ReplaceEdgeInstanceGatewayResponse {
	s.Headers = v
	return s
}

func (s *ReplaceEdgeInstanceGatewayResponse) SetStatusCode(v int32) *ReplaceEdgeInstanceGatewayResponse {
	s.StatusCode = &v
	return s
}

func (s *ReplaceEdgeInstanceGatewayResponse) SetBody(v *ReplaceEdgeInstanceGatewayResponseBody) *ReplaceEdgeInstanceGatewayResponse {
	s.Body = v
	return s
}

type RerunJobRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	JobId         *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
}

func (s RerunJobRequest) String() string {
	return tea.Prettify(s)
}

func (s RerunJobRequest) GoString() string {
	return s.String()
}

func (s *RerunJobRequest) SetIotInstanceId(v string) *RerunJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *RerunJobRequest) SetJobId(v string) *RerunJobRequest {
	s.JobId = &v
	return s
}

type RerunJobResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RerunJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RerunJobResponseBody) GoString() string {
	return s.String()
}

func (s *RerunJobResponseBody) SetCode(v string) *RerunJobResponseBody {
	s.Code = &v
	return s
}

func (s *RerunJobResponseBody) SetErrorMessage(v string) *RerunJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RerunJobResponseBody) SetRequestId(v string) *RerunJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *RerunJobResponseBody) SetSuccess(v bool) *RerunJobResponseBody {
	s.Success = &v
	return s
}

type RerunJobResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RerunJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RerunJobResponse) String() string {
	return tea.Prettify(s)
}

func (s RerunJobResponse) GoString() string {
	return s.String()
}

func (s *RerunJobResponse) SetHeaders(v map[string]*string) *RerunJobResponse {
	s.Headers = v
	return s
}

func (s *RerunJobResponse) SetStatusCode(v int32) *RerunJobResponse {
	s.StatusCode = &v
	return s
}

func (s *RerunJobResponse) SetBody(v *RerunJobResponseBody) *RerunJobResponse {
	s.Body = v
	return s
}

type ResetConsumerGroupPositionRequest struct {
	// The ID of the consumer group. After you call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group, the consumer group ID is returned. You can call the [QueryConsumerGroupList](~~170419~~) operation to query the consumer group ID by group name. You can also go to the IoT Platform console,and choose **Rules** > **Server-side Subscription** > **Consumer Groups** to view the consumer group ID.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s ResetConsumerGroupPositionRequest) String() string {
	return tea.Prettify(s)
}

func (s ResetConsumerGroupPositionRequest) GoString() string {
	return s.String()
}

func (s *ResetConsumerGroupPositionRequest) SetGroupId(v string) *ResetConsumerGroupPositionRequest {
	s.GroupId = &v
	return s
}

func (s *ResetConsumerGroupPositionRequest) SetIotInstanceId(v string) *ResetConsumerGroupPositionRequest {
	s.IotInstanceId = &v
	return s
}

type ResetConsumerGroupPositionResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ResetConsumerGroupPositionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResetConsumerGroupPositionResponseBody) GoString() string {
	return s.String()
}

func (s *ResetConsumerGroupPositionResponseBody) SetCode(v string) *ResetConsumerGroupPositionResponseBody {
	s.Code = &v
	return s
}

func (s *ResetConsumerGroupPositionResponseBody) SetErrorMessage(v string) *ResetConsumerGroupPositionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ResetConsumerGroupPositionResponseBody) SetRequestId(v string) *ResetConsumerGroupPositionResponseBody {
	s.RequestId = &v
	return s
}

func (s *ResetConsumerGroupPositionResponseBody) SetSuccess(v bool) *ResetConsumerGroupPositionResponseBody {
	s.Success = &v
	return s
}

type ResetConsumerGroupPositionResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ResetConsumerGroupPositionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ResetConsumerGroupPositionResponse) String() string {
	return tea.Prettify(s)
}

func (s ResetConsumerGroupPositionResponse) GoString() string {
	return s.String()
}

func (s *ResetConsumerGroupPositionResponse) SetHeaders(v map[string]*string) *ResetConsumerGroupPositionResponse {
	s.Headers = v
	return s
}

func (s *ResetConsumerGroupPositionResponse) SetStatusCode(v int32) *ResetConsumerGroupPositionResponse {
	s.StatusCode = &v
	return s
}

func (s *ResetConsumerGroupPositionResponse) SetBody(v *ResetConsumerGroupPositionResponseBody) *ResetConsumerGroupPositionResponse {
	s.Body = v
	return s
}

type ResetDeviceTimelineRequest struct {
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s ResetDeviceTimelineRequest) String() string {
	return tea.Prettify(s)
}

func (s ResetDeviceTimelineRequest) GoString() string {
	return s.String()
}

func (s *ResetDeviceTimelineRequest) SetDeviceName(v string) *ResetDeviceTimelineRequest {
	s.DeviceName = &v
	return s
}

func (s *ResetDeviceTimelineRequest) SetIotInstanceId(v string) *ResetDeviceTimelineRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ResetDeviceTimelineRequest) SetProductKey(v string) *ResetDeviceTimelineRequest {
	s.ProductKey = &v
	return s
}

type ResetDeviceTimelineResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ResetDeviceTimelineResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResetDeviceTimelineResponseBody) GoString() string {
	return s.String()
}

func (s *ResetDeviceTimelineResponseBody) SetCode(v string) *ResetDeviceTimelineResponseBody {
	s.Code = &v
	return s
}

func (s *ResetDeviceTimelineResponseBody) SetErrorMessage(v string) *ResetDeviceTimelineResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ResetDeviceTimelineResponseBody) SetRequestId(v string) *ResetDeviceTimelineResponseBody {
	s.RequestId = &v
	return s
}

func (s *ResetDeviceTimelineResponseBody) SetSuccess(v bool) *ResetDeviceTimelineResponseBody {
	s.Success = &v
	return s
}

type ResetDeviceTimelineResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ResetDeviceTimelineResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ResetDeviceTimelineResponse) String() string {
	return tea.Prettify(s)
}

func (s ResetDeviceTimelineResponse) GoString() string {
	return s.String()
}

func (s *ResetDeviceTimelineResponse) SetHeaders(v map[string]*string) *ResetDeviceTimelineResponse {
	s.Headers = v
	return s
}

func (s *ResetDeviceTimelineResponse) SetStatusCode(v int32) *ResetDeviceTimelineResponse {
	s.StatusCode = &v
	return s
}

func (s *ResetDeviceTimelineResponse) SetBody(v *ResetDeviceTimelineResponseBody) *ResetDeviceTimelineResponse {
	s.Body = v
	return s
}

type ResetThingRequest struct {
	// The DeviceName of the device.
	//
	// >  If you specify a value for this parameter, you must also specify a value for the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device.
	//
	// >  If you specify a value for this parameter, you do not need to specify a value for the **ProductKey** or **DeviceName** parameter. The **IotId** parameter specifies a globally unique identifier (GUID) for the device. The value of the IotId parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for the **IotId** parameter and values for the **ProductKey** and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Instance overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >  If you specify a value for this parameter, you must also specify a value for the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s ResetThingRequest) String() string {
	return tea.Prettify(s)
}

func (s ResetThingRequest) GoString() string {
	return s.String()
}

func (s *ResetThingRequest) SetDeviceName(v string) *ResetThingRequest {
	s.DeviceName = &v
	return s
}

func (s *ResetThingRequest) SetIotId(v string) *ResetThingRequest {
	s.IotId = &v
	return s
}

func (s *ResetThingRequest) SetIotInstanceId(v string) *ResetThingRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ResetThingRequest) SetProductKey(v string) *ResetThingRequest {
	s.ProductKey = &v
	return s
}

type ResetThingResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the device job.
	JobId *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values: **true** indicates that the call was successful. **false** indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ResetThingResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ResetThingResponseBody) GoString() string {
	return s.String()
}

func (s *ResetThingResponseBody) SetCode(v string) *ResetThingResponseBody {
	s.Code = &v
	return s
}

func (s *ResetThingResponseBody) SetErrorMessage(v string) *ResetThingResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ResetThingResponseBody) SetJobId(v string) *ResetThingResponseBody {
	s.JobId = &v
	return s
}

func (s *ResetThingResponseBody) SetRequestId(v string) *ResetThingResponseBody {
	s.RequestId = &v
	return s
}

func (s *ResetThingResponseBody) SetSuccess(v bool) *ResetThingResponseBody {
	s.Success = &v
	return s
}

type ResetThingResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ResetThingResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ResetThingResponse) String() string {
	return tea.Prettify(s)
}

func (s ResetThingResponse) GoString() string {
	return s.String()
}

func (s *ResetThingResponse) SetHeaders(v map[string]*string) *ResetThingResponse {
	s.Headers = v
	return s
}

func (s *ResetThingResponse) SetStatusCode(v int32) *ResetThingResponse {
	s.StatusCode = &v
	return s
}

func (s *ResetThingResponse) SetBody(v *ResetThingResponseBody) *ResetThingResponse {
	s.Body = v
	return s
}

type RetrySoundCodeLabelBatchRequest struct {
	BatchCode     *string `json:"BatchCode,omitempty" xml:"BatchCode,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s RetrySoundCodeLabelBatchRequest) String() string {
	return tea.Prettify(s)
}

func (s RetrySoundCodeLabelBatchRequest) GoString() string {
	return s.String()
}

func (s *RetrySoundCodeLabelBatchRequest) SetBatchCode(v string) *RetrySoundCodeLabelBatchRequest {
	s.BatchCode = &v
	return s
}

func (s *RetrySoundCodeLabelBatchRequest) SetIotInstanceId(v string) *RetrySoundCodeLabelBatchRequest {
	s.IotInstanceId = &v
	return s
}

type RetrySoundCodeLabelBatchResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s RetrySoundCodeLabelBatchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s RetrySoundCodeLabelBatchResponseBody) GoString() string {
	return s.String()
}

func (s *RetrySoundCodeLabelBatchResponseBody) SetCode(v string) *RetrySoundCodeLabelBatchResponseBody {
	s.Code = &v
	return s
}

func (s *RetrySoundCodeLabelBatchResponseBody) SetErrorMessage(v string) *RetrySoundCodeLabelBatchResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *RetrySoundCodeLabelBatchResponseBody) SetRequestId(v string) *RetrySoundCodeLabelBatchResponseBody {
	s.RequestId = &v
	return s
}

func (s *RetrySoundCodeLabelBatchResponseBody) SetSuccess(v bool) *RetrySoundCodeLabelBatchResponseBody {
	s.Success = &v
	return s
}

type RetrySoundCodeLabelBatchResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *RetrySoundCodeLabelBatchResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s RetrySoundCodeLabelBatchResponse) String() string {
	return tea.Prettify(s)
}

func (s RetrySoundCodeLabelBatchResponse) GoString() string {
	return s.String()
}

func (s *RetrySoundCodeLabelBatchResponse) SetHeaders(v map[string]*string) *RetrySoundCodeLabelBatchResponse {
	s.Headers = v
	return s
}

func (s *RetrySoundCodeLabelBatchResponse) SetStatusCode(v int32) *RetrySoundCodeLabelBatchResponse {
	s.StatusCode = &v
	return s
}

func (s *RetrySoundCodeLabelBatchResponse) SetBody(v *RetrySoundCodeLabelBatchResponseBody) *RetrySoundCodeLabelBatchResponse {
	s.Body = v
	return s
}

type ReupgradeOTATaskRequest struct {
	// The ID of the instance. You can view the ID of an instance on the **Overview** page in the IoT Platform console.****
	//
	// >*   If the instance has an ID, you must specify the **IotInstanceId** parameter. If you do not specify this parameter, the call fails.
	// >*   If the instance does not have an **ID** or no **Overview** page is displayed for the instance, you do not need to specify this parameter.
	//
	// For more information, see [Instance overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the update batch.
	//
	// After you call the [CreateOTAStaticUpgradeJob](~~147496~~) or [CreateOTADynamicUpgradeJob](~~147887~~) operation to create an update batch, the **JobId** parameter is returned.
	//
	// You can also view the **batch ID** on the **Firmware Details** page in the IoT Platform console.
	JobId  *string   `json:"JobId,omitempty" xml:"JobId,omitempty"`
	TaskId []*string `json:"TaskId,omitempty" xml:"TaskId,omitempty" type:"Repeated"`
}

func (s ReupgradeOTATaskRequest) String() string {
	return tea.Prettify(s)
}

func (s ReupgradeOTATaskRequest) GoString() string {
	return s.String()
}

func (s *ReupgradeOTATaskRequest) SetIotInstanceId(v string) *ReupgradeOTATaskRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ReupgradeOTATaskRequest) SetJobId(v string) *ReupgradeOTATaskRequest {
	s.JobId = &v
	return s
}

func (s *ReupgradeOTATaskRequest) SetTaskId(v []*string) *ReupgradeOTATaskRequest {
	s.TaskId = v
	return s
}

type ReupgradeOTATaskResponseBody struct {
	// The error code returned if the call fails.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call is successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ReupgradeOTATaskResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ReupgradeOTATaskResponseBody) GoString() string {
	return s.String()
}

func (s *ReupgradeOTATaskResponseBody) SetCode(v string) *ReupgradeOTATaskResponseBody {
	s.Code = &v
	return s
}

func (s *ReupgradeOTATaskResponseBody) SetErrorMessage(v string) *ReupgradeOTATaskResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ReupgradeOTATaskResponseBody) SetRequestId(v string) *ReupgradeOTATaskResponseBody {
	s.RequestId = &v
	return s
}

func (s *ReupgradeOTATaskResponseBody) SetSuccess(v bool) *ReupgradeOTATaskResponseBody {
	s.Success = &v
	return s
}

type ReupgradeOTATaskResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ReupgradeOTATaskResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ReupgradeOTATaskResponse) String() string {
	return tea.Prettify(s)
}

func (s ReupgradeOTATaskResponse) GoString() string {
	return s.String()
}

func (s *ReupgradeOTATaskResponse) SetHeaders(v map[string]*string) *ReupgradeOTATaskResponse {
	s.Headers = v
	return s
}

func (s *ReupgradeOTATaskResponse) SetStatusCode(v int32) *ReupgradeOTATaskResponse {
	s.StatusCode = &v
	return s
}

func (s *ReupgradeOTATaskResponse) SetBody(v *ReupgradeOTATaskResponseBody) *ReupgradeOTATaskResponse {
	s.Body = v
	return s
}

type SaveDevicePropRequest struct {
	// The DeviceName of the device.
	//
	// >  If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// >  If you specify this parameter, you do not need to specify the **ProductKey** or **DeviceName** parameters. The **IotId** parameter specifies a globally unique identifier (GUID) for the device. The value of the IotId parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. On the **Overview** page in the IoT Platform console, you can view the **ID** of the instance.
	//
	//
	// **Important**
	//
	// *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// *   If the **Overview** page or instance ID is not displayed in the IoT Platform console, you do not need to configure this parameter.
	//
	// For more information about the instance, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// >  If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The tag that you want to specify for the device. You can specify multiple tags.
	//
	// The tags must be JSON data in the **Key:Value** format. **Key** indicates the tag name, and **Value** indicates the tag value.
	//
	// Separate multiple tags with commas (,). Example: **Props={"color":"red","shape":"round"}**
	//
	//
	// **Important**
	//
	// *   The maximum size of the **Props** parameter is 5 KB.
	// *   `abc` is a **key** that is reserved by IoT Platform. You cannot set **Key** to abc. If you set `Key` to abc, the abc tag is automatically filtered when you query tags.
	Props *string `json:"Props,omitempty" xml:"Props,omitempty"`
}

func (s SaveDevicePropRequest) String() string {
	return tea.Prettify(s)
}

func (s SaveDevicePropRequest) GoString() string {
	return s.String()
}

func (s *SaveDevicePropRequest) SetDeviceName(v string) *SaveDevicePropRequest {
	s.DeviceName = &v
	return s
}

func (s *SaveDevicePropRequest) SetIotId(v string) *SaveDevicePropRequest {
	s.IotId = &v
	return s
}

func (s *SaveDevicePropRequest) SetIotInstanceId(v string) *SaveDevicePropRequest {
	s.IotInstanceId = &v
	return s
}

func (s *SaveDevicePropRequest) SetProductKey(v string) *SaveDevicePropRequest {
	s.ProductKey = &v
	return s
}

func (s *SaveDevicePropRequest) SetProps(v string) *SaveDevicePropRequest {
	s.Props = &v
	return s
}

type SaveDevicePropResponseBody struct {
	// The error code returned if the call fails. For more information about error codes, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SaveDevicePropResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SaveDevicePropResponseBody) GoString() string {
	return s.String()
}

func (s *SaveDevicePropResponseBody) SetCode(v string) *SaveDevicePropResponseBody {
	s.Code = &v
	return s
}

func (s *SaveDevicePropResponseBody) SetErrorMessage(v string) *SaveDevicePropResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SaveDevicePropResponseBody) SetRequestId(v string) *SaveDevicePropResponseBody {
	s.RequestId = &v
	return s
}

func (s *SaveDevicePropResponseBody) SetSuccess(v bool) *SaveDevicePropResponseBody {
	s.Success = &v
	return s
}

type SaveDevicePropResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SaveDevicePropResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SaveDevicePropResponse) String() string {
	return tea.Prettify(s)
}

func (s SaveDevicePropResponse) GoString() string {
	return s.String()
}

func (s *SaveDevicePropResponse) SetHeaders(v map[string]*string) *SaveDevicePropResponse {
	s.Headers = v
	return s
}

func (s *SaveDevicePropResponse) SetStatusCode(v int32) *SaveDevicePropResponse {
	s.StatusCode = &v
	return s
}

func (s *SaveDevicePropResponse) SetBody(v *SaveDevicePropResponseBody) *SaveDevicePropResponse {
	s.Body = v
	return s
}

type SaveScriptRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ParserId      *int64  `json:"ParserId,omitempty" xml:"ParserId,omitempty"`
	ScriptDraft   *string `json:"ScriptDraft,omitempty" xml:"ScriptDraft,omitempty"`
}

func (s SaveScriptRequest) String() string {
	return tea.Prettify(s)
}

func (s SaveScriptRequest) GoString() string {
	return s.String()
}

func (s *SaveScriptRequest) SetIotInstanceId(v string) *SaveScriptRequest {
	s.IotInstanceId = &v
	return s
}

func (s *SaveScriptRequest) SetParserId(v int64) *SaveScriptRequest {
	s.ParserId = &v
	return s
}

func (s *SaveScriptRequest) SetScriptDraft(v string) *SaveScriptRequest {
	s.ScriptDraft = &v
	return s
}

type SaveScriptResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SaveScriptResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SaveScriptResponseBody) GoString() string {
	return s.String()
}

func (s *SaveScriptResponseBody) SetCode(v string) *SaveScriptResponseBody {
	s.Code = &v
	return s
}

func (s *SaveScriptResponseBody) SetErrorMessage(v string) *SaveScriptResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SaveScriptResponseBody) SetRequestId(v string) *SaveScriptResponseBody {
	s.RequestId = &v
	return s
}

func (s *SaveScriptResponseBody) SetSuccess(v bool) *SaveScriptResponseBody {
	s.Success = &v
	return s
}

type SaveScriptResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SaveScriptResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SaveScriptResponse) String() string {
	return tea.Prettify(s)
}

func (s SaveScriptResponse) GoString() string {
	return s.String()
}

func (s *SaveScriptResponse) SetHeaders(v map[string]*string) *SaveScriptResponse {
	s.Headers = v
	return s
}

func (s *SaveScriptResponse) SetStatusCode(v int32) *SaveScriptResponse {
	s.StatusCode = &v
	return s
}

func (s *SaveScriptResponse) SetBody(v *SaveScriptResponseBody) *SaveScriptResponse {
	s.Body = v
	return s
}

type SetDeviceDesiredPropertyRequest struct {
	// The name of the device.
	//
	// > If you specify a value for this parameter, you must also specify a value for the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// > The IotId parameter specifies a globally unique identifier (GUID) for the device. The value of the **IotId** parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for this parameter, you do not need to specify the **ProductKey** or **DeviceName** parameters. If you specify values for the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The property value that you want to specify. The value of this parameter is a JSON string. Format: **Key:Value**. Example: {"Temperature":35}. You can specify up to 10 desired property values.
	//
	// *   **Key** specifies the identifier of the property. You can view the property identifier on the **Define Feature**[ tab of the Product Details page in the IoT Platform console. You can also call the ](~~150321~~)QueryThingModel operation and view the property identifier in the returned TSL data.
	//
	//     If the temperature property belongs to a custom module named testFb, this parameter is set to **{"testFb:temperature":35}**.
	//
	// >The specified property must allow read/write access. If you specify a read-only property, the setting fails. The property identifier must be unique.
	//
	// *   **Value** specifies the desired value of the property. The value must match the data type and value range that are defined for the property.
	//
	// > If you set Value to null, the desired value of the property is cleared.
	Items *string `json:"Items,omitempty" xml:"Items,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// > If you configure this parameter, you must also specify a value for the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The version number of the desired property value. The value of this parameter is a JSON string. Format: Key:Value. Example: {"Temperature":2}.
	//
	// *   **Key** specifies the identifier of the property. You can view the property identifier on the Define Feature tab of the Product Details page in the IoT Platform console.
	//
	// > The property identifier must be unique.
	//
	// *   **Value** specifies the version number of the desired property value.
	//
	//     The first time you specify a desired property value, set the Value parameter to 0. After you set the property value, the version number changes to 1. Each time you specify a desired property value, IoT Platform automatically increases the version number by 1. The second time that you specify a desired property value, the version number changes to 2. The third time that you specify a desired property value, set the version number to 2. After you specify the desired property value, the version number changes to 3.
	//
	// > If the version number that you specify for this parameter is not the current version number, the server rejects the request. If you are not sure about the current version number, you do not need to specify a version number. However, you must enter a valid JSON object {}.
	Versions *string `json:"Versions,omitempty" xml:"Versions,omitempty"`
}

func (s SetDeviceDesiredPropertyRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDeviceDesiredPropertyRequest) GoString() string {
	return s.String()
}

func (s *SetDeviceDesiredPropertyRequest) SetDeviceName(v string) *SetDeviceDesiredPropertyRequest {
	s.DeviceName = &v
	return s
}

func (s *SetDeviceDesiredPropertyRequest) SetIotId(v string) *SetDeviceDesiredPropertyRequest {
	s.IotId = &v
	return s
}

func (s *SetDeviceDesiredPropertyRequest) SetIotInstanceId(v string) *SetDeviceDesiredPropertyRequest {
	s.IotInstanceId = &v
	return s
}

func (s *SetDeviceDesiredPropertyRequest) SetItems(v string) *SetDeviceDesiredPropertyRequest {
	s.Items = &v
	return s
}

func (s *SetDeviceDesiredPropertyRequest) SetProductKey(v string) *SetDeviceDesiredPropertyRequest {
	s.ProductKey = &v
	return s
}

func (s *SetDeviceDesiredPropertyRequest) SetVersions(v string) *SetDeviceDesiredPropertyRequest {
	s.Versions = &v
	return s
}

type SetDeviceDesiredPropertyResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call is successful. For more information, see the following parameters.
	Data *SetDeviceDesiredPropertyResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SetDeviceDesiredPropertyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDeviceDesiredPropertyResponseBody) GoString() string {
	return s.String()
}

func (s *SetDeviceDesiredPropertyResponseBody) SetCode(v string) *SetDeviceDesiredPropertyResponseBody {
	s.Code = &v
	return s
}

func (s *SetDeviceDesiredPropertyResponseBody) SetData(v *SetDeviceDesiredPropertyResponseBodyData) *SetDeviceDesiredPropertyResponseBody {
	s.Data = v
	return s
}

func (s *SetDeviceDesiredPropertyResponseBody) SetErrorMessage(v string) *SetDeviceDesiredPropertyResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SetDeviceDesiredPropertyResponseBody) SetRequestId(v string) *SetDeviceDesiredPropertyResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetDeviceDesiredPropertyResponseBody) SetSuccess(v bool) *SetDeviceDesiredPropertyResponseBody {
	s.Success = &v
	return s
}

type SetDeviceDesiredPropertyResponseBodyData struct {
	// The ID of the message that IoT Platform sends to the device to specify desired property values.
	MessageId *string `json:"MessageId,omitempty" xml:"MessageId,omitempty"`
	// The current version numbers of the desired property values.
	Versions *string `json:"Versions,omitempty" xml:"Versions,omitempty"`
}

func (s SetDeviceDesiredPropertyResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s SetDeviceDesiredPropertyResponseBodyData) GoString() string {
	return s.String()
}

func (s *SetDeviceDesiredPropertyResponseBodyData) SetMessageId(v string) *SetDeviceDesiredPropertyResponseBodyData {
	s.MessageId = &v
	return s
}

func (s *SetDeviceDesiredPropertyResponseBodyData) SetVersions(v string) *SetDeviceDesiredPropertyResponseBodyData {
	s.Versions = &v
	return s
}

type SetDeviceDesiredPropertyResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDeviceDesiredPropertyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDeviceDesiredPropertyResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDeviceDesiredPropertyResponse) GoString() string {
	return s.String()
}

func (s *SetDeviceDesiredPropertyResponse) SetHeaders(v map[string]*string) *SetDeviceDesiredPropertyResponse {
	s.Headers = v
	return s
}

func (s *SetDeviceDesiredPropertyResponse) SetStatusCode(v int32) *SetDeviceDesiredPropertyResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDeviceDesiredPropertyResponse) SetBody(v *SetDeviceDesiredPropertyResponseBody) *SetDeviceDesiredPropertyResponse {
	s.Body = v
	return s
}

type SetDeviceGroupTagsRequest struct {
	// The ID of the group. The ID is the globally unique identifier (GUID) for the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The type of the group.
	//
	// You do not need to configure this parameter.
	GroupType *string `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The ID of the instance. On the **Overview** page in the IoT Platform console, you can view the **ID** of the instance.
	//
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If the **Overview** page or instance ID is not displayed in the IoT Platform console, you do not need to configure this parameter.
	//
	// For more information about the instance, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The tag data in the JSON format. The TagString parameter specifies multiple tags in the format of key-value pairs. You must specify **tagKey** and **tagValue** for each tag.
	//
	// *   **tagKey**: the tag key. The key must be 2 to 30 characters in length, and can contain letters, digits, and periods (.).
	// *   **tagValue**: the tag value. Each value can contain letters, digits, underscores (\_), and hyphens (-). The value must be 1 to 128 characters in length.
	//
	// Separate multiple tags with commas (,). Example: `[{"tagKey":"h1","tagValue":"rr"},{"tagKey":"7h","tagValue":"rr"}]`
	//
	// If you specify a new value for an existing tag, the new tag value overwrites the original value.
	//
	// If you want to delete a tag, you do not need to specify the key and value for the tag.
	//
	// **
	//
	// **Important** `abc` is a key that is reserved by IoT Platform. You cannot set **tagKey** to abc. If you set `tagKey` to abc, the abc tag is automatically filtered when you query tags.
	TagString *string `json:"TagString,omitempty" xml:"TagString,omitempty"`
}

func (s SetDeviceGroupTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDeviceGroupTagsRequest) GoString() string {
	return s.String()
}

func (s *SetDeviceGroupTagsRequest) SetGroupId(v string) *SetDeviceGroupTagsRequest {
	s.GroupId = &v
	return s
}

func (s *SetDeviceGroupTagsRequest) SetGroupType(v string) *SetDeviceGroupTagsRequest {
	s.GroupType = &v
	return s
}

func (s *SetDeviceGroupTagsRequest) SetIotInstanceId(v string) *SetDeviceGroupTagsRequest {
	s.IotInstanceId = &v
	return s
}

func (s *SetDeviceGroupTagsRequest) SetTagString(v string) *SetDeviceGroupTagsRequest {
	s.TagString = &v
	return s
}

type SetDeviceGroupTagsResponseBody struct {
	// The error code returned if the call fails. For more information about the error codes, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SetDeviceGroupTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDeviceGroupTagsResponseBody) GoString() string {
	return s.String()
}

func (s *SetDeviceGroupTagsResponseBody) SetCode(v string) *SetDeviceGroupTagsResponseBody {
	s.Code = &v
	return s
}

func (s *SetDeviceGroupTagsResponseBody) SetErrorMessage(v string) *SetDeviceGroupTagsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SetDeviceGroupTagsResponseBody) SetRequestId(v string) *SetDeviceGroupTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetDeviceGroupTagsResponseBody) SetSuccess(v bool) *SetDeviceGroupTagsResponseBody {
	s.Success = &v
	return s
}

type SetDeviceGroupTagsResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDeviceGroupTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDeviceGroupTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDeviceGroupTagsResponse) GoString() string {
	return s.String()
}

func (s *SetDeviceGroupTagsResponse) SetHeaders(v map[string]*string) *SetDeviceGroupTagsResponse {
	s.Headers = v
	return s
}

func (s *SetDeviceGroupTagsResponse) SetStatusCode(v int32) *SetDeviceGroupTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDeviceGroupTagsResponse) SetBody(v *SetDeviceGroupTagsResponseBody) *SetDeviceGroupTagsResponse {
	s.Body = v
	return s
}

type SetDevicePropertyRequest struct {
	// The DeviceName of the device.
	//
	// > If you configure this parameter, you must specify a value for the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. The ID is a unique identifier that is issued by IoT Platform to the device.
	//
	// > The IotId parameter specifies a globally unique identifier (GUID) for the device. The value of the **IotId** parameter corresponds to a combination of the values of the **ProductKey** and **DeviceName** parameters. If you specify a value for this parameter, you do not need to configure the **ProductKey** or **DeviceName** parameter. If you specify values for the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the elastic container instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The properties that you want to specify. The properties must be in the JSON format.
	//
	// Each property consists of a **key-value pair in the key:value format**. Separate multiple properties with commas (,).
	//
	// For example, you can configure the following properties for a smart lamp:
	//
	// *   A switch property whose key is **Switch** and whose data type is **BOOLEAN**. The value is **1**. The value 1 indicates that the light is on.
	// *   A color property whose key is **Color** and whose data type is **STRING**. The value is **blue**.
	//
	// In this case, you can specify the following properties in the JSON format:
	//
	// `Items={"Switch":1,"Color":"blue"}`
	//
	// >  If you specify properties for the custom module testFb, set the Items parameter to `{"testFb:Switch":1,"testFb:Color":"blue"}`. The testFb module is not the default module.
	Items *string `json:"Items,omitempty" xml:"Items,omitempty"`
	// The ProductKey of the product to which the device belongs.
	//
	// > If you configure this parameter, you must also specify a value for the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	Qos        *int32  `json:"Qos,omitempty" xml:"Qos,omitempty"`
}

func (s SetDevicePropertyRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDevicePropertyRequest) GoString() string {
	return s.String()
}

func (s *SetDevicePropertyRequest) SetDeviceName(v string) *SetDevicePropertyRequest {
	s.DeviceName = &v
	return s
}

func (s *SetDevicePropertyRequest) SetIotId(v string) *SetDevicePropertyRequest {
	s.IotId = &v
	return s
}

func (s *SetDevicePropertyRequest) SetIotInstanceId(v string) *SetDevicePropertyRequest {
	s.IotInstanceId = &v
	return s
}

func (s *SetDevicePropertyRequest) SetItems(v string) *SetDevicePropertyRequest {
	s.Items = &v
	return s
}

func (s *SetDevicePropertyRequest) SetProductKey(v string) *SetDevicePropertyRequest {
	s.ProductKey = &v
	return s
}

func (s *SetDevicePropertyRequest) SetQos(v int32) *SetDevicePropertyRequest {
	s.Qos = &v
	return s
}

type SetDevicePropertyResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The data returned if the call is successful.
	Data *SetDevicePropertyResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SetDevicePropertyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDevicePropertyResponseBody) GoString() string {
	return s.String()
}

func (s *SetDevicePropertyResponseBody) SetCode(v string) *SetDevicePropertyResponseBody {
	s.Code = &v
	return s
}

func (s *SetDevicePropertyResponseBody) SetData(v *SetDevicePropertyResponseBodyData) *SetDevicePropertyResponseBody {
	s.Data = v
	return s
}

func (s *SetDevicePropertyResponseBody) SetErrorMessage(v string) *SetDevicePropertyResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SetDevicePropertyResponseBody) SetRequestId(v string) *SetDevicePropertyResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetDevicePropertyResponseBody) SetSuccess(v bool) *SetDevicePropertyResponseBody {
	s.Success = &v
	return s
}

type SetDevicePropertyResponseBodyData struct {
	// The ID of the message that IoT Platform sends to the device.
	MessageId *string `json:"MessageId,omitempty" xml:"MessageId,omitempty"`
}

func (s SetDevicePropertyResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s SetDevicePropertyResponseBodyData) GoString() string {
	return s.String()
}

func (s *SetDevicePropertyResponseBodyData) SetMessageId(v string) *SetDevicePropertyResponseBodyData {
	s.MessageId = &v
	return s
}

type SetDevicePropertyResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDevicePropertyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDevicePropertyResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDevicePropertyResponse) GoString() string {
	return s.String()
}

func (s *SetDevicePropertyResponse) SetHeaders(v map[string]*string) *SetDevicePropertyResponse {
	s.Headers = v
	return s
}

func (s *SetDevicePropertyResponse) SetStatusCode(v int32) *SetDevicePropertyResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDevicePropertyResponse) SetBody(v *SetDevicePropertyResponseBody) *SetDevicePropertyResponse {
	s.Body = v
	return s
}

type SetDevicesPropertyRequest struct {
	DeviceName []*string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty" type:"Repeated"`
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The properties that you want to specify. The properties must be in the JSON format.
	//
	// Each property consists of a **key-value pair in the key:value format**. Separate multiple properties with commas (,).
	//
	// For example, you can configure the following properties for a smart lamp:
	//
	// *   A switch property whose key is **Switch** and whose data type is **BOOLEAN**. The value is **1**. The value 1 indicates that the light is on.
	// *   A color property whose key is **Color** and whose data type is **STRING**. The value is **blue**.
	//
	// In this case, you can specify the following properties in the JSON format:
	//
	// `Items={"Switch":1,"Color":"blue"}`
	//
	// >  If you configure properties for the custom module testFb, set the Items parameter to `{"testFb:Switch":1,"testFb:Color":"blue"}`. The testFb module is not the default module.
	Items *string `json:"Items,omitempty" xml:"Items,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	Qos        *int32  `json:"Qos,omitempty" xml:"Qos,omitempty"`
}

func (s SetDevicesPropertyRequest) String() string {
	return tea.Prettify(s)
}

func (s SetDevicesPropertyRequest) GoString() string {
	return s.String()
}

func (s *SetDevicesPropertyRequest) SetDeviceName(v []*string) *SetDevicesPropertyRequest {
	s.DeviceName = v
	return s
}

func (s *SetDevicesPropertyRequest) SetIotInstanceId(v string) *SetDevicesPropertyRequest {
	s.IotInstanceId = &v
	return s
}

func (s *SetDevicesPropertyRequest) SetItems(v string) *SetDevicesPropertyRequest {
	s.Items = &v
	return s
}

func (s *SetDevicesPropertyRequest) SetProductKey(v string) *SetDevicesPropertyRequest {
	s.ProductKey = &v
	return s
}

func (s *SetDevicesPropertyRequest) SetQos(v int32) *SetDevicesPropertyRequest {
	s.Qos = &v
	return s
}

type SetDevicesPropertyResponseBody struct {
	// The error code returned if the call fails. For more information about the error codes, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SetDevicesPropertyResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetDevicesPropertyResponseBody) GoString() string {
	return s.String()
}

func (s *SetDevicesPropertyResponseBody) SetCode(v string) *SetDevicesPropertyResponseBody {
	s.Code = &v
	return s
}

func (s *SetDevicesPropertyResponseBody) SetErrorMessage(v string) *SetDevicesPropertyResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SetDevicesPropertyResponseBody) SetRequestId(v string) *SetDevicesPropertyResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetDevicesPropertyResponseBody) SetSuccess(v bool) *SetDevicesPropertyResponseBody {
	s.Success = &v
	return s
}

type SetDevicesPropertyResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetDevicesPropertyResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetDevicesPropertyResponse) String() string {
	return tea.Prettify(s)
}

func (s SetDevicesPropertyResponse) GoString() string {
	return s.String()
}

func (s *SetDevicesPropertyResponse) SetHeaders(v map[string]*string) *SetDevicesPropertyResponse {
	s.Headers = v
	return s
}

func (s *SetDevicesPropertyResponse) SetStatusCode(v int32) *SetDevicesPropertyResponse {
	s.StatusCode = &v
	return s
}

func (s *SetDevicesPropertyResponse) SetBody(v *SetDevicesPropertyResponseBody) *SetDevicesPropertyResponse {
	s.Body = v
	return s
}

type SetEdgeInstanceDriverConfigsRequest struct {
	Configs       []*SetEdgeInstanceDriverConfigsRequestConfigs `json:"Configs,omitempty" xml:"Configs,omitempty" type:"Repeated"`
	DriverId      *string                                       `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	InstanceId    *string                                       `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string                                       `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s SetEdgeInstanceDriverConfigsRequest) String() string {
	return tea.Prettify(s)
}

func (s SetEdgeInstanceDriverConfigsRequest) GoString() string {
	return s.String()
}

func (s *SetEdgeInstanceDriverConfigsRequest) SetConfigs(v []*SetEdgeInstanceDriverConfigsRequestConfigs) *SetEdgeInstanceDriverConfigsRequest {
	s.Configs = v
	return s
}

func (s *SetEdgeInstanceDriverConfigsRequest) SetDriverId(v string) *SetEdgeInstanceDriverConfigsRequest {
	s.DriverId = &v
	return s
}

func (s *SetEdgeInstanceDriverConfigsRequest) SetInstanceId(v string) *SetEdgeInstanceDriverConfigsRequest {
	s.InstanceId = &v
	return s
}

func (s *SetEdgeInstanceDriverConfigsRequest) SetIotInstanceId(v string) *SetEdgeInstanceDriverConfigsRequest {
	s.IotInstanceId = &v
	return s
}

type SetEdgeInstanceDriverConfigsRequestConfigs struct {
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	Format  *string `json:"Format,omitempty" xml:"Format,omitempty"`
	Key     *string `json:"Key,omitempty" xml:"Key,omitempty"`
}

func (s SetEdgeInstanceDriverConfigsRequestConfigs) String() string {
	return tea.Prettify(s)
}

func (s SetEdgeInstanceDriverConfigsRequestConfigs) GoString() string {
	return s.String()
}

func (s *SetEdgeInstanceDriverConfigsRequestConfigs) SetContent(v string) *SetEdgeInstanceDriverConfigsRequestConfigs {
	s.Content = &v
	return s
}

func (s *SetEdgeInstanceDriverConfigsRequestConfigs) SetFormat(v string) *SetEdgeInstanceDriverConfigsRequestConfigs {
	s.Format = &v
	return s
}

func (s *SetEdgeInstanceDriverConfigsRequestConfigs) SetKey(v string) *SetEdgeInstanceDriverConfigsRequestConfigs {
	s.Key = &v
	return s
}

type SetEdgeInstanceDriverConfigsResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SetEdgeInstanceDriverConfigsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetEdgeInstanceDriverConfigsResponseBody) GoString() string {
	return s.String()
}

func (s *SetEdgeInstanceDriverConfigsResponseBody) SetCode(v string) *SetEdgeInstanceDriverConfigsResponseBody {
	s.Code = &v
	return s
}

func (s *SetEdgeInstanceDriverConfigsResponseBody) SetErrorMessage(v string) *SetEdgeInstanceDriverConfigsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SetEdgeInstanceDriverConfigsResponseBody) SetRequestId(v string) *SetEdgeInstanceDriverConfigsResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetEdgeInstanceDriverConfigsResponseBody) SetSuccess(v bool) *SetEdgeInstanceDriverConfigsResponseBody {
	s.Success = &v
	return s
}

type SetEdgeInstanceDriverConfigsResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetEdgeInstanceDriverConfigsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetEdgeInstanceDriverConfigsResponse) String() string {
	return tea.Prettify(s)
}

func (s SetEdgeInstanceDriverConfigsResponse) GoString() string {
	return s.String()
}

func (s *SetEdgeInstanceDriverConfigsResponse) SetHeaders(v map[string]*string) *SetEdgeInstanceDriverConfigsResponse {
	s.Headers = v
	return s
}

func (s *SetEdgeInstanceDriverConfigsResponse) SetStatusCode(v int32) *SetEdgeInstanceDriverConfigsResponse {
	s.StatusCode = &v
	return s
}

func (s *SetEdgeInstanceDriverConfigsResponse) SetBody(v *SetEdgeInstanceDriverConfigsResponseBody) *SetEdgeInstanceDriverConfigsResponse {
	s.Body = v
	return s
}

type SetProductCertInfoRequest struct {
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****
	//
	// >  If your instance has an ID, you must specify the ID for the parameter. Otherwise, the call fails. If no Overview page or ID is generated for your instance, you do not need configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The source from which the X.509 certificate is issued.
	//
	// *   **1**: The X.509 certificate is issued by IoT Platform.
	// *   **3**: The X.509 certificate is issued by a third-party platform.
	IssueModel *int32 `json:"IssueModel,omitempty" xml:"IssueModel,omitempty"`
	// The **ProductKey** of the product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s SetProductCertInfoRequest) String() string {
	return tea.Prettify(s)
}

func (s SetProductCertInfoRequest) GoString() string {
	return s.String()
}

func (s *SetProductCertInfoRequest) SetIotInstanceId(v string) *SetProductCertInfoRequest {
	s.IotInstanceId = &v
	return s
}

func (s *SetProductCertInfoRequest) SetIssueModel(v int32) *SetProductCertInfoRequest {
	s.IssueModel = &v
	return s
}

func (s *SetProductCertInfoRequest) SetProductKey(v string) *SetProductCertInfoRequest {
	s.ProductKey = &v
	return s
}

type SetProductCertInfoResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SetProductCertInfoResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetProductCertInfoResponseBody) GoString() string {
	return s.String()
}

func (s *SetProductCertInfoResponseBody) SetCode(v string) *SetProductCertInfoResponseBody {
	s.Code = &v
	return s
}

func (s *SetProductCertInfoResponseBody) SetErrorMessage(v string) *SetProductCertInfoResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SetProductCertInfoResponseBody) SetRequestId(v string) *SetProductCertInfoResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetProductCertInfoResponseBody) SetSuccess(v bool) *SetProductCertInfoResponseBody {
	s.Success = &v
	return s
}

type SetProductCertInfoResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetProductCertInfoResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetProductCertInfoResponse) String() string {
	return tea.Prettify(s)
}

func (s SetProductCertInfoResponse) GoString() string {
	return s.String()
}

func (s *SetProductCertInfoResponse) SetHeaders(v map[string]*string) *SetProductCertInfoResponse {
	s.Headers = v
	return s
}

func (s *SetProductCertInfoResponse) SetStatusCode(v int32) *SetProductCertInfoResponse {
	s.StatusCode = &v
	return s
}

func (s *SetProductCertInfoResponse) SetBody(v *SetProductCertInfoResponseBody) *SetProductCertInfoResponse {
	s.Body = v
	return s
}

type SetStudioProjectCooperationRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Status        *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s SetStudioProjectCooperationRequest) String() string {
	return tea.Prettify(s)
}

func (s SetStudioProjectCooperationRequest) GoString() string {
	return s.String()
}

func (s *SetStudioProjectCooperationRequest) SetIotInstanceId(v string) *SetStudioProjectCooperationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *SetStudioProjectCooperationRequest) SetStatus(v string) *SetStudioProjectCooperationRequest {
	s.Status = &v
	return s
}

type SetStudioProjectCooperationResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *bool   `json:"Data,omitempty" xml:"Data,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SetStudioProjectCooperationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetStudioProjectCooperationResponseBody) GoString() string {
	return s.String()
}

func (s *SetStudioProjectCooperationResponseBody) SetCode(v string) *SetStudioProjectCooperationResponseBody {
	s.Code = &v
	return s
}

func (s *SetStudioProjectCooperationResponseBody) SetData(v bool) *SetStudioProjectCooperationResponseBody {
	s.Data = &v
	return s
}

func (s *SetStudioProjectCooperationResponseBody) SetErrorMessage(v string) *SetStudioProjectCooperationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SetStudioProjectCooperationResponseBody) SetRequestId(v string) *SetStudioProjectCooperationResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetStudioProjectCooperationResponseBody) SetSuccess(v bool) *SetStudioProjectCooperationResponseBody {
	s.Success = &v
	return s
}

type SetStudioProjectCooperationResponse struct {
	Headers    map[string]*string                       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetStudioProjectCooperationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetStudioProjectCooperationResponse) String() string {
	return tea.Prettify(s)
}

func (s SetStudioProjectCooperationResponse) GoString() string {
	return s.String()
}

func (s *SetStudioProjectCooperationResponse) SetHeaders(v map[string]*string) *SetStudioProjectCooperationResponse {
	s.Headers = v
	return s
}

func (s *SetStudioProjectCooperationResponse) SetStatusCode(v int32) *SetStudioProjectCooperationResponse {
	s.StatusCode = &v
	return s
}

func (s *SetStudioProjectCooperationResponse) SetBody(v *SetStudioProjectCooperationResponseBody) *SetStudioProjectCooperationResponse {
	s.Body = v
	return s
}

type SetupStudioAppAuthModeOpenRequest struct {
	AppId         *string `json:"AppId,omitempty" xml:"AppId,omitempty"`
	AuthMode      *int32  `json:"AuthMode,omitempty" xml:"AuthMode,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProjectId     *string `json:"ProjectId,omitempty" xml:"ProjectId,omitempty"`
}

func (s SetupStudioAppAuthModeOpenRequest) String() string {
	return tea.Prettify(s)
}

func (s SetupStudioAppAuthModeOpenRequest) GoString() string {
	return s.String()
}

func (s *SetupStudioAppAuthModeOpenRequest) SetAppId(v string) *SetupStudioAppAuthModeOpenRequest {
	s.AppId = &v
	return s
}

func (s *SetupStudioAppAuthModeOpenRequest) SetAuthMode(v int32) *SetupStudioAppAuthModeOpenRequest {
	s.AuthMode = &v
	return s
}

func (s *SetupStudioAppAuthModeOpenRequest) SetIotInstanceId(v string) *SetupStudioAppAuthModeOpenRequest {
	s.IotInstanceId = &v
	return s
}

func (s *SetupStudioAppAuthModeOpenRequest) SetProjectId(v string) *SetupStudioAppAuthModeOpenRequest {
	s.ProjectId = &v
	return s
}

type SetupStudioAppAuthModeOpenResponseBody struct {
	Code         *string                                     `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *SetupStudioAppAuthModeOpenResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SetupStudioAppAuthModeOpenResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SetupStudioAppAuthModeOpenResponseBody) GoString() string {
	return s.String()
}

func (s *SetupStudioAppAuthModeOpenResponseBody) SetCode(v string) *SetupStudioAppAuthModeOpenResponseBody {
	s.Code = &v
	return s
}

func (s *SetupStudioAppAuthModeOpenResponseBody) SetData(v *SetupStudioAppAuthModeOpenResponseBodyData) *SetupStudioAppAuthModeOpenResponseBody {
	s.Data = v
	return s
}

func (s *SetupStudioAppAuthModeOpenResponseBody) SetErrorMessage(v string) *SetupStudioAppAuthModeOpenResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SetupStudioAppAuthModeOpenResponseBody) SetRequestId(v string) *SetupStudioAppAuthModeOpenResponseBody {
	s.RequestId = &v
	return s
}

func (s *SetupStudioAppAuthModeOpenResponseBody) SetSuccess(v bool) *SetupStudioAppAuthModeOpenResponseBody {
	s.Success = &v
	return s
}

type SetupStudioAppAuthModeOpenResponseBodyData struct {
	AuthMode  *int32                                               `json:"AuthMode,omitempty" xml:"AuthMode,omitempty"`
	TokenInfo *SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo `json:"TokenInfo,omitempty" xml:"TokenInfo,omitempty" type:"Struct"`
}

func (s SetupStudioAppAuthModeOpenResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s SetupStudioAppAuthModeOpenResponseBodyData) GoString() string {
	return s.String()
}

func (s *SetupStudioAppAuthModeOpenResponseBodyData) SetAuthMode(v int32) *SetupStudioAppAuthModeOpenResponseBodyData {
	s.AuthMode = &v
	return s
}

func (s *SetupStudioAppAuthModeOpenResponseBodyData) SetTokenInfo(v *SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo) *SetupStudioAppAuthModeOpenResponseBodyData {
	s.TokenInfo = v
	return s
}

type SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo struct {
	BizId    *string `json:"BizId,omitempty" xml:"BizId,omitempty"`
	BizType  *string `json:"BizType,omitempty" xml:"BizType,omitempty"`
	IsEnable *string `json:"IsEnable,omitempty" xml:"IsEnable,omitempty"`
	Token    *string `json:"Token,omitempty" xml:"Token,omitempty"`
	Type     *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo) String() string {
	return tea.Prettify(s)
}

func (s SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo) GoString() string {
	return s.String()
}

func (s *SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo) SetBizId(v string) *SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo {
	s.BizId = &v
	return s
}

func (s *SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo) SetBizType(v string) *SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo {
	s.BizType = &v
	return s
}

func (s *SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo) SetIsEnable(v string) *SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo {
	s.IsEnable = &v
	return s
}

func (s *SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo) SetToken(v string) *SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo {
	s.Token = &v
	return s
}

func (s *SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo) SetType(v string) *SetupStudioAppAuthModeOpenResponseBodyDataTokenInfo {
	s.Type = &v
	return s
}

type SetupStudioAppAuthModeOpenResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SetupStudioAppAuthModeOpenResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SetupStudioAppAuthModeOpenResponse) String() string {
	return tea.Prettify(s)
}

func (s SetupStudioAppAuthModeOpenResponse) GoString() string {
	return s.String()
}

func (s *SetupStudioAppAuthModeOpenResponse) SetHeaders(v map[string]*string) *SetupStudioAppAuthModeOpenResponse {
	s.Headers = v
	return s
}

func (s *SetupStudioAppAuthModeOpenResponse) SetStatusCode(v int32) *SetupStudioAppAuthModeOpenResponse {
	s.StatusCode = &v
	return s
}

func (s *SetupStudioAppAuthModeOpenResponse) SetBody(v *SetupStudioAppAuthModeOpenResponseBody) *SetupStudioAppAuthModeOpenResponse {
	s.Body = v
	return s
}

type ShareSpeechByCombinationRequest struct {
	// The audio format. Valid values: **wav**, **mp3**, and **amr**.
	AudioFormat *string `json:"AudioFormat,omitempty" xml:"AudioFormat,omitempty"`
	// The combined content that you want to broadcast. The following types of content can be broadcasted:
	//
	// *   The speeches that are pushed to the device. You must specify the identifiers of the speeches.
	//
	// *   The custom content that you specify based on the supported format of the device.
	//
	//     For example, you can create a custom speech about the amount of money in the format of `{$xxx}`. xxx is the specific amount. If you specify `{$1000}`, the device broadcasts **CNY 1000**.
	//
	// The device broadcasts the audio files in the sequence of the values that you specify in CombinationList.
	CombinationList []*string `json:"CombinationList,omitempty" xml:"CombinationList,omitempty" type:"Repeated"`
	// The **DeviceName** of the device. If you specify this parameter, you must also specify the **ProductKey** parameter.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the device. You can call the [QuerySpeechDevice](~~280408~~) operation to obtain the ID.
	//
	// > If you specify this parameter, you do not need to specify the **ProductKey** and **DeviceName** parameters. **IotId** specifies a globally unique identifier (GUID) of the device, which corresponds to a combination of **ProductKey** and **DeviceName**. If you specify the **IotId**, **ProductKey**, and **DeviceName** parameters, the value of the **IotId** parameter takes precedence.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
	//
	// For more information, see the [Overview](~~356505~~) topic of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product to which the device belongs. If you specify this parameter, you must also specify the **DeviceName** parameter.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The unique ID of the combined speech that you want to broadcast. This ID is issued by IoT Platform to the device.
	//
	// >  If you do not specify this parameter, IoT Platform automatically generates an ID. If you need to retry broadcasting the speech, you must specify the ID to prevent repeated broadcasting.
	SpeechId *string `json:"SpeechId,omitempty" xml:"SpeechId,omitempty"`
}

func (s ShareSpeechByCombinationRequest) String() string {
	return tea.Prettify(s)
}

func (s ShareSpeechByCombinationRequest) GoString() string {
	return s.String()
}

func (s *ShareSpeechByCombinationRequest) SetAudioFormat(v string) *ShareSpeechByCombinationRequest {
	s.AudioFormat = &v
	return s
}

func (s *ShareSpeechByCombinationRequest) SetCombinationList(v []*string) *ShareSpeechByCombinationRequest {
	s.CombinationList = v
	return s
}

func (s *ShareSpeechByCombinationRequest) SetDeviceName(v string) *ShareSpeechByCombinationRequest {
	s.DeviceName = &v
	return s
}

func (s *ShareSpeechByCombinationRequest) SetIotId(v string) *ShareSpeechByCombinationRequest {
	s.IotId = &v
	return s
}

func (s *ShareSpeechByCombinationRequest) SetIotInstanceId(v string) *ShareSpeechByCombinationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *ShareSpeechByCombinationRequest) SetProductKey(v string) *ShareSpeechByCombinationRequest {
	s.ProductKey = &v
	return s
}

func (s *ShareSpeechByCombinationRequest) SetSpeechId(v string) *ShareSpeechByCombinationRequest {
	s.SpeechId = &v
	return s
}

type ShareSpeechByCombinationResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s ShareSpeechByCombinationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s ShareSpeechByCombinationResponseBody) GoString() string {
	return s.String()
}

func (s *ShareSpeechByCombinationResponseBody) SetCode(v string) *ShareSpeechByCombinationResponseBody {
	s.Code = &v
	return s
}

func (s *ShareSpeechByCombinationResponseBody) SetErrorMessage(v string) *ShareSpeechByCombinationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *ShareSpeechByCombinationResponseBody) SetRequestId(v string) *ShareSpeechByCombinationResponseBody {
	s.RequestId = &v
	return s
}

func (s *ShareSpeechByCombinationResponseBody) SetSuccess(v bool) *ShareSpeechByCombinationResponseBody {
	s.Success = &v
	return s
}

type ShareSpeechByCombinationResponse struct {
	Headers    map[string]*string                    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *ShareSpeechByCombinationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s ShareSpeechByCombinationResponse) String() string {
	return tea.Prettify(s)
}

func (s ShareSpeechByCombinationResponse) GoString() string {
	return s.String()
}

func (s *ShareSpeechByCombinationResponse) SetHeaders(v map[string]*string) *ShareSpeechByCombinationResponse {
	s.Headers = v
	return s
}

func (s *ShareSpeechByCombinationResponse) SetStatusCode(v int32) *ShareSpeechByCombinationResponse {
	s.StatusCode = &v
	return s
}

func (s *ShareSpeechByCombinationResponse) SetBody(v *ShareSpeechByCombinationResponseBody) *ShareSpeechByCombinationResponse {
	s.Body = v
	return s
}

type SpeechByCombinationRequest struct {
	AudioFormat     *string   `json:"AudioFormat,omitempty" xml:"AudioFormat,omitempty"`
	CombinationList []*string `json:"CombinationList,omitempty" xml:"CombinationList,omitempty" type:"Repeated"`
	DeviceName      *string   `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	EnforceFlag     *bool     `json:"EnforceFlag,omitempty" xml:"EnforceFlag,omitempty"`
	IotId           *string   `json:"IotId,omitempty" xml:"IotId,omitempty"`
	IotInstanceId   *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey      *string   `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	SpeechId        *string   `json:"SpeechId,omitempty" xml:"SpeechId,omitempty"`
}

func (s SpeechByCombinationRequest) String() string {
	return tea.Prettify(s)
}

func (s SpeechByCombinationRequest) GoString() string {
	return s.String()
}

func (s *SpeechByCombinationRequest) SetAudioFormat(v string) *SpeechByCombinationRequest {
	s.AudioFormat = &v
	return s
}

func (s *SpeechByCombinationRequest) SetCombinationList(v []*string) *SpeechByCombinationRequest {
	s.CombinationList = v
	return s
}

func (s *SpeechByCombinationRequest) SetDeviceName(v string) *SpeechByCombinationRequest {
	s.DeviceName = &v
	return s
}

func (s *SpeechByCombinationRequest) SetEnforceFlag(v bool) *SpeechByCombinationRequest {
	s.EnforceFlag = &v
	return s
}

func (s *SpeechByCombinationRequest) SetIotId(v string) *SpeechByCombinationRequest {
	s.IotId = &v
	return s
}

func (s *SpeechByCombinationRequest) SetIotInstanceId(v string) *SpeechByCombinationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *SpeechByCombinationRequest) SetProductKey(v string) *SpeechByCombinationRequest {
	s.ProductKey = &v
	return s
}

func (s *SpeechByCombinationRequest) SetSpeechId(v string) *SpeechByCombinationRequest {
	s.SpeechId = &v
	return s
}

type SpeechByCombinationResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SpeechByCombinationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SpeechByCombinationResponseBody) GoString() string {
	return s.String()
}

func (s *SpeechByCombinationResponseBody) SetCode(v string) *SpeechByCombinationResponseBody {
	s.Code = &v
	return s
}

func (s *SpeechByCombinationResponseBody) SetErrorMessage(v string) *SpeechByCombinationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SpeechByCombinationResponseBody) SetRequestId(v string) *SpeechByCombinationResponseBody {
	s.RequestId = &v
	return s
}

func (s *SpeechByCombinationResponseBody) SetSuccess(v bool) *SpeechByCombinationResponseBody {
	s.Success = &v
	return s
}

type SpeechByCombinationResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SpeechByCombinationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SpeechByCombinationResponse) String() string {
	return tea.Prettify(s)
}

func (s SpeechByCombinationResponse) GoString() string {
	return s.String()
}

func (s *SpeechByCombinationResponse) SetHeaders(v map[string]*string) *SpeechByCombinationResponse {
	s.Headers = v
	return s
}

func (s *SpeechByCombinationResponse) SetStatusCode(v int32) *SpeechByCombinationResponse {
	s.StatusCode = &v
	return s
}

func (s *SpeechByCombinationResponse) SetBody(v *SpeechByCombinationResponseBody) *SpeechByCombinationResponse {
	s.Body = v
	return s
}

type SpeechBySynthesisRequest struct {
	AudioFormat   *string `json:"AudioFormat,omitempty" xml:"AudioFormat,omitempty"`
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotId         *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	SpeechId      *string `json:"SpeechId,omitempty" xml:"SpeechId,omitempty"`
	SpeechRate    *int32  `json:"SpeechRate,omitempty" xml:"SpeechRate,omitempty"`
	Text          *string `json:"Text,omitempty" xml:"Text,omitempty"`
	Voice         *string `json:"Voice,omitempty" xml:"Voice,omitempty"`
	Volume        *int32  `json:"Volume,omitempty" xml:"Volume,omitempty"`
}

func (s SpeechBySynthesisRequest) String() string {
	return tea.Prettify(s)
}

func (s SpeechBySynthesisRequest) GoString() string {
	return s.String()
}

func (s *SpeechBySynthesisRequest) SetAudioFormat(v string) *SpeechBySynthesisRequest {
	s.AudioFormat = &v
	return s
}

func (s *SpeechBySynthesisRequest) SetDeviceName(v string) *SpeechBySynthesisRequest {
	s.DeviceName = &v
	return s
}

func (s *SpeechBySynthesisRequest) SetIotId(v string) *SpeechBySynthesisRequest {
	s.IotId = &v
	return s
}

func (s *SpeechBySynthesisRequest) SetIotInstanceId(v string) *SpeechBySynthesisRequest {
	s.IotInstanceId = &v
	return s
}

func (s *SpeechBySynthesisRequest) SetProductKey(v string) *SpeechBySynthesisRequest {
	s.ProductKey = &v
	return s
}

func (s *SpeechBySynthesisRequest) SetSpeechId(v string) *SpeechBySynthesisRequest {
	s.SpeechId = &v
	return s
}

func (s *SpeechBySynthesisRequest) SetSpeechRate(v int32) *SpeechBySynthesisRequest {
	s.SpeechRate = &v
	return s
}

func (s *SpeechBySynthesisRequest) SetText(v string) *SpeechBySynthesisRequest {
	s.Text = &v
	return s
}

func (s *SpeechBySynthesisRequest) SetVoice(v string) *SpeechBySynthesisRequest {
	s.Voice = &v
	return s
}

func (s *SpeechBySynthesisRequest) SetVolume(v int32) *SpeechBySynthesisRequest {
	s.Volume = &v
	return s
}

type SpeechBySynthesisResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SpeechBySynthesisResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SpeechBySynthesisResponseBody) GoString() string {
	return s.String()
}

func (s *SpeechBySynthesisResponseBody) SetCode(v string) *SpeechBySynthesisResponseBody {
	s.Code = &v
	return s
}

func (s *SpeechBySynthesisResponseBody) SetErrorMessage(v string) *SpeechBySynthesisResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SpeechBySynthesisResponseBody) SetRequestId(v string) *SpeechBySynthesisResponseBody {
	s.RequestId = &v
	return s
}

func (s *SpeechBySynthesisResponseBody) SetSuccess(v bool) *SpeechBySynthesisResponseBody {
	s.Success = &v
	return s
}

type SpeechBySynthesisResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SpeechBySynthesisResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SpeechBySynthesisResponse) String() string {
	return tea.Prettify(s)
}

func (s SpeechBySynthesisResponse) GoString() string {
	return s.String()
}

func (s *SpeechBySynthesisResponse) SetHeaders(v map[string]*string) *SpeechBySynthesisResponse {
	s.Headers = v
	return s
}

func (s *SpeechBySynthesisResponse) SetStatusCode(v int32) *SpeechBySynthesisResponse {
	s.StatusCode = &v
	return s
}

func (s *SpeechBySynthesisResponse) SetBody(v *SpeechBySynthesisResponseBody) *SpeechBySynthesisResponse {
	s.Body = v
	return s
}

type StartParserRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ParserId      *int64  `json:"ParserId,omitempty" xml:"ParserId,omitempty"`
}

func (s StartParserRequest) String() string {
	return tea.Prettify(s)
}

func (s StartParserRequest) GoString() string {
	return s.String()
}

func (s *StartParserRequest) SetIotInstanceId(v string) *StartParserRequest {
	s.IotInstanceId = &v
	return s
}

func (s *StartParserRequest) SetParserId(v int64) *StartParserRequest {
	s.ParserId = &v
	return s
}

type StartParserResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s StartParserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartParserResponseBody) GoString() string {
	return s.String()
}

func (s *StartParserResponseBody) SetCode(v string) *StartParserResponseBody {
	s.Code = &v
	return s
}

func (s *StartParserResponseBody) SetErrorMessage(v string) *StartParserResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *StartParserResponseBody) SetRequestId(v string) *StartParserResponseBody {
	s.RequestId = &v
	return s
}

func (s *StartParserResponseBody) SetSuccess(v bool) *StartParserResponseBody {
	s.Success = &v
	return s
}

type StartParserResponse struct {
	Headers    map[string]*string       `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                   `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StartParserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StartParserResponse) String() string {
	return tea.Prettify(s)
}

func (s StartParserResponse) GoString() string {
	return s.String()
}

func (s *StartParserResponse) SetHeaders(v map[string]*string) *StartParserResponse {
	s.Headers = v
	return s
}

func (s *StartParserResponse) SetStatusCode(v int32) *StartParserResponse {
	s.StatusCode = &v
	return s
}

func (s *StartParserResponse) SetBody(v *StartParserResponseBody) *StartParserResponse {
	s.Body = v
	return s
}

type StartRuleRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the rule that you want to enable. You can log on to the IoT Platform console and choose **Rules** > **Data Forwarding** to view the rule ID. You can also call the [ListRule](~~69486~~) operation and view the rule ID in the response.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s StartRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s StartRuleRequest) GoString() string {
	return s.String()
}

func (s *StartRuleRequest) SetIotInstanceId(v string) *StartRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *StartRuleRequest) SetRuleId(v int64) *StartRuleRequest {
	s.RuleId = &v
	return s
}

type StartRuleResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s StartRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StartRuleResponseBody) GoString() string {
	return s.String()
}

func (s *StartRuleResponseBody) SetCode(v string) *StartRuleResponseBody {
	s.Code = &v
	return s
}

func (s *StartRuleResponseBody) SetErrorMessage(v string) *StartRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *StartRuleResponseBody) SetRequestId(v string) *StartRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *StartRuleResponseBody) SetSuccess(v bool) *StartRuleResponseBody {
	s.Success = &v
	return s
}

type StartRuleResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StartRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StartRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s StartRuleResponse) GoString() string {
	return s.String()
}

func (s *StartRuleResponse) SetHeaders(v map[string]*string) *StartRuleResponse {
	s.Headers = v
	return s
}

func (s *StartRuleResponse) SetStatusCode(v int32) *StartRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *StartRuleResponse) SetBody(v *StartRuleResponseBody) *StartRuleResponse {
	s.Body = v
	return s
}

type StopParserRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ParserId      *int64  `json:"ParserId,omitempty" xml:"ParserId,omitempty"`
}

func (s StopParserRequest) String() string {
	return tea.Prettify(s)
}

func (s StopParserRequest) GoString() string {
	return s.String()
}

func (s *StopParserRequest) SetIotInstanceId(v string) *StopParserRequest {
	s.IotInstanceId = &v
	return s
}

func (s *StopParserRequest) SetParserId(v int64) *StopParserRequest {
	s.ParserId = &v
	return s
}

type StopParserResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s StopParserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopParserResponseBody) GoString() string {
	return s.String()
}

func (s *StopParserResponseBody) SetCode(v string) *StopParserResponseBody {
	s.Code = &v
	return s
}

func (s *StopParserResponseBody) SetErrorMessage(v string) *StopParserResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *StopParserResponseBody) SetRequestId(v string) *StopParserResponseBody {
	s.RequestId = &v
	return s
}

func (s *StopParserResponseBody) SetSuccess(v bool) *StopParserResponseBody {
	s.Success = &v
	return s
}

type StopParserResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StopParserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StopParserResponse) String() string {
	return tea.Prettify(s)
}

func (s StopParserResponse) GoString() string {
	return s.String()
}

func (s *StopParserResponse) SetHeaders(v map[string]*string) *StopParserResponse {
	s.Headers = v
	return s
}

func (s *StopParserResponse) SetStatusCode(v int32) *StopParserResponse {
	s.StatusCode = &v
	return s
}

func (s *StopParserResponse) SetBody(v *StopParserResponseBody) *StopParserResponse {
	s.Body = v
	return s
}

type StopRuleRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ID of the rule that you want to disable. You can log on to the IoT Platform console and choose **Rules** > **Data Forwarding** to view the rule ID. You can also call the [ListRule](~~69486~~) operation and view the rule ID in the response.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s StopRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s StopRuleRequest) GoString() string {
	return s.String()
}

func (s *StopRuleRequest) SetIotInstanceId(v string) *StopRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *StopRuleRequest) SetRuleId(v int64) *StopRuleRequest {
	s.RuleId = &v
	return s
}

type StopRuleResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s StopRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s StopRuleResponseBody) GoString() string {
	return s.String()
}

func (s *StopRuleResponseBody) SetCode(v string) *StopRuleResponseBody {
	s.Code = &v
	return s
}

func (s *StopRuleResponseBody) SetErrorMessage(v string) *StopRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *StopRuleResponseBody) SetRequestId(v string) *StopRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *StopRuleResponseBody) SetSuccess(v bool) *StopRuleResponseBody {
	s.Success = &v
	return s
}

type StopRuleResponse struct {
	Headers    map[string]*string    `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *StopRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s StopRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s StopRuleResponse) GoString() string {
	return s.String()
}

func (s *StopRuleResponse) SetHeaders(v map[string]*string) *StopRuleResponse {
	s.Headers = v
	return s
}

func (s *StopRuleResponse) SetStatusCode(v int32) *StopRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *StopRuleResponse) SetBody(v *StopRuleResponseBody) *StopRuleResponse {
	s.Body = v
	return s
}

type SubscribeTopicRequest struct {
	// The **DeviceName** of the device to which the topic belongs.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product to which the device belongs.
	ProductKey *string   `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	Topic      []*string `json:"Topic,omitempty" xml:"Topic,omitempty" type:"Repeated"`
}

func (s SubscribeTopicRequest) String() string {
	return tea.Prettify(s)
}

func (s SubscribeTopicRequest) GoString() string {
	return s.String()
}

func (s *SubscribeTopicRequest) SetDeviceName(v string) *SubscribeTopicRequest {
	s.DeviceName = &v
	return s
}

func (s *SubscribeTopicRequest) SetIotInstanceId(v string) *SubscribeTopicRequest {
	s.IotInstanceId = &v
	return s
}

func (s *SubscribeTopicRequest) SetProductKey(v string) *SubscribeTopicRequest {
	s.ProductKey = &v
	return s
}

func (s *SubscribeTopicRequest) SetTopic(v []*string) *SubscribeTopicRequest {
	s.Topic = v
	return s
}

type SubscribeTopicResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SubscribeTopicResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SubscribeTopicResponseBody) GoString() string {
	return s.String()
}

func (s *SubscribeTopicResponseBody) SetCode(v string) *SubscribeTopicResponseBody {
	s.Code = &v
	return s
}

func (s *SubscribeTopicResponseBody) SetErrorMessage(v string) *SubscribeTopicResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SubscribeTopicResponseBody) SetRequestId(v string) *SubscribeTopicResponseBody {
	s.RequestId = &v
	return s
}

func (s *SubscribeTopicResponseBody) SetSuccess(v bool) *SubscribeTopicResponseBody {
	s.Success = &v
	return s
}

type SubscribeTopicResponse struct {
	Headers    map[string]*string          `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                      `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SubscribeTopicResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SubscribeTopicResponse) String() string {
	return tea.Prettify(s)
}

func (s SubscribeTopicResponse) GoString() string {
	return s.String()
}

func (s *SubscribeTopicResponse) SetHeaders(v map[string]*string) *SubscribeTopicResponse {
	s.Headers = v
	return s
}

func (s *SubscribeTopicResponse) SetStatusCode(v int32) *SubscribeTopicResponse {
	s.StatusCode = &v
	return s
}

func (s *SubscribeTopicResponse) SetBody(v *SubscribeTopicResponseBody) *SubscribeTopicResponse {
	s.Body = v
	return s
}

type SyncSpeechByCombinationRequest struct {
	AudioFormat     *string   `json:"AudioFormat,omitempty" xml:"AudioFormat,omitempty"`
	CombinationList []*string `json:"CombinationList,omitempty" xml:"CombinationList,omitempty" type:"Repeated"`
	DeviceName      *string   `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	EnforceFlag     *bool     `json:"EnforceFlag,omitempty" xml:"EnforceFlag,omitempty"`
	IotId           *string   `json:"IotId,omitempty" xml:"IotId,omitempty"`
	IotInstanceId   *string   `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey      *string   `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	SpeechId        *string   `json:"SpeechId,omitempty" xml:"SpeechId,omitempty"`
}

func (s SyncSpeechByCombinationRequest) String() string {
	return tea.Prettify(s)
}

func (s SyncSpeechByCombinationRequest) GoString() string {
	return s.String()
}

func (s *SyncSpeechByCombinationRequest) SetAudioFormat(v string) *SyncSpeechByCombinationRequest {
	s.AudioFormat = &v
	return s
}

func (s *SyncSpeechByCombinationRequest) SetCombinationList(v []*string) *SyncSpeechByCombinationRequest {
	s.CombinationList = v
	return s
}

func (s *SyncSpeechByCombinationRequest) SetDeviceName(v string) *SyncSpeechByCombinationRequest {
	s.DeviceName = &v
	return s
}

func (s *SyncSpeechByCombinationRequest) SetEnforceFlag(v bool) *SyncSpeechByCombinationRequest {
	s.EnforceFlag = &v
	return s
}

func (s *SyncSpeechByCombinationRequest) SetIotId(v string) *SyncSpeechByCombinationRequest {
	s.IotId = &v
	return s
}

func (s *SyncSpeechByCombinationRequest) SetIotInstanceId(v string) *SyncSpeechByCombinationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *SyncSpeechByCombinationRequest) SetProductKey(v string) *SyncSpeechByCombinationRequest {
	s.ProductKey = &v
	return s
}

func (s *SyncSpeechByCombinationRequest) SetSpeechId(v string) *SyncSpeechByCombinationRequest {
	s.SpeechId = &v
	return s
}

type SyncSpeechByCombinationResponseBody struct {
	Code         *string                                  `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *SyncSpeechByCombinationResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                                  `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                                  `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                                    `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SyncSpeechByCombinationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s SyncSpeechByCombinationResponseBody) GoString() string {
	return s.String()
}

func (s *SyncSpeechByCombinationResponseBody) SetCode(v string) *SyncSpeechByCombinationResponseBody {
	s.Code = &v
	return s
}

func (s *SyncSpeechByCombinationResponseBody) SetData(v *SyncSpeechByCombinationResponseBodyData) *SyncSpeechByCombinationResponseBody {
	s.Data = v
	return s
}

func (s *SyncSpeechByCombinationResponseBody) SetErrorMessage(v string) *SyncSpeechByCombinationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *SyncSpeechByCombinationResponseBody) SetRequestId(v string) *SyncSpeechByCombinationResponseBody {
	s.RequestId = &v
	return s
}

func (s *SyncSpeechByCombinationResponseBody) SetSuccess(v bool) *SyncSpeechByCombinationResponseBody {
	s.Success = &v
	return s
}

type SyncSpeechByCombinationResponseBodyData struct {
	Detail             *string `json:"Detail,omitempty" xml:"Detail,omitempty"`
	DeviceErrorCode    *string `json:"DeviceErrorCode,omitempty" xml:"DeviceErrorCode,omitempty"`
	DeviceErrorMessage *string `json:"DeviceErrorMessage,omitempty" xml:"DeviceErrorMessage,omitempty"`
	Id                 *string `json:"Id,omitempty" xml:"Id,omitempty"`
	MaxRetryCount      *int32  `json:"MaxRetryCount,omitempty" xml:"MaxRetryCount,omitempty"`
	RetryCount         *int32  `json:"RetryCount,omitempty" xml:"RetryCount,omitempty"`
	Success            *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s SyncSpeechByCombinationResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s SyncSpeechByCombinationResponseBodyData) GoString() string {
	return s.String()
}

func (s *SyncSpeechByCombinationResponseBodyData) SetDetail(v string) *SyncSpeechByCombinationResponseBodyData {
	s.Detail = &v
	return s
}

func (s *SyncSpeechByCombinationResponseBodyData) SetDeviceErrorCode(v string) *SyncSpeechByCombinationResponseBodyData {
	s.DeviceErrorCode = &v
	return s
}

func (s *SyncSpeechByCombinationResponseBodyData) SetDeviceErrorMessage(v string) *SyncSpeechByCombinationResponseBodyData {
	s.DeviceErrorMessage = &v
	return s
}

func (s *SyncSpeechByCombinationResponseBodyData) SetId(v string) *SyncSpeechByCombinationResponseBodyData {
	s.Id = &v
	return s
}

func (s *SyncSpeechByCombinationResponseBodyData) SetMaxRetryCount(v int32) *SyncSpeechByCombinationResponseBodyData {
	s.MaxRetryCount = &v
	return s
}

func (s *SyncSpeechByCombinationResponseBodyData) SetRetryCount(v int32) *SyncSpeechByCombinationResponseBodyData {
	s.RetryCount = &v
	return s
}

func (s *SyncSpeechByCombinationResponseBodyData) SetSuccess(v bool) *SyncSpeechByCombinationResponseBodyData {
	s.Success = &v
	return s
}

type SyncSpeechByCombinationResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *SyncSpeechByCombinationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s SyncSpeechByCombinationResponse) String() string {
	return tea.Prettify(s)
}

func (s SyncSpeechByCombinationResponse) GoString() string {
	return s.String()
}

func (s *SyncSpeechByCombinationResponse) SetHeaders(v map[string]*string) *SyncSpeechByCombinationResponse {
	s.Headers = v
	return s
}

func (s *SyncSpeechByCombinationResponse) SetStatusCode(v int32) *SyncSpeechByCombinationResponse {
	s.StatusCode = &v
	return s
}

func (s *SyncSpeechByCombinationResponse) SetBody(v *SyncSpeechByCombinationResponseBody) *SyncSpeechByCombinationResponse {
	s.Body = v
	return s
}

type TestSpeechRequest struct {
	AudioFormat     *string                `json:"AudioFormat,omitempty" xml:"AudioFormat,omitempty"`
	EnableSoundCode *bool                  `json:"EnableSoundCode,omitempty" xml:"EnableSoundCode,omitempty"`
	IotInstanceId   *string                `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProjectCode     *string                `json:"ProjectCode,omitempty" xml:"ProjectCode,omitempty"`
	SoundCodeConfig map[string]interface{} `json:"SoundCodeConfig,omitempty" xml:"SoundCodeConfig,omitempty"`
	SpeechRate      *int32                 `json:"SpeechRate,omitempty" xml:"SpeechRate,omitempty"`
	SpeechType      *string                `json:"SpeechType,omitempty" xml:"SpeechType,omitempty"`
	Text            *string                `json:"Text,omitempty" xml:"Text,omitempty"`
	Voice           *string                `json:"Voice,omitempty" xml:"Voice,omitempty"`
	Volume          *int32                 `json:"Volume,omitempty" xml:"Volume,omitempty"`
}

func (s TestSpeechRequest) String() string {
	return tea.Prettify(s)
}

func (s TestSpeechRequest) GoString() string {
	return s.String()
}

func (s *TestSpeechRequest) SetAudioFormat(v string) *TestSpeechRequest {
	s.AudioFormat = &v
	return s
}

func (s *TestSpeechRequest) SetEnableSoundCode(v bool) *TestSpeechRequest {
	s.EnableSoundCode = &v
	return s
}

func (s *TestSpeechRequest) SetIotInstanceId(v string) *TestSpeechRequest {
	s.IotInstanceId = &v
	return s
}

func (s *TestSpeechRequest) SetProjectCode(v string) *TestSpeechRequest {
	s.ProjectCode = &v
	return s
}

func (s *TestSpeechRequest) SetSoundCodeConfig(v map[string]interface{}) *TestSpeechRequest {
	s.SoundCodeConfig = v
	return s
}

func (s *TestSpeechRequest) SetSpeechRate(v int32) *TestSpeechRequest {
	s.SpeechRate = &v
	return s
}

func (s *TestSpeechRequest) SetSpeechType(v string) *TestSpeechRequest {
	s.SpeechType = &v
	return s
}

func (s *TestSpeechRequest) SetText(v string) *TestSpeechRequest {
	s.Text = &v
	return s
}

func (s *TestSpeechRequest) SetVoice(v string) *TestSpeechRequest {
	s.Voice = &v
	return s
}

func (s *TestSpeechRequest) SetVolume(v int32) *TestSpeechRequest {
	s.Volume = &v
	return s
}

type TestSpeechShrinkRequest struct {
	AudioFormat           *string `json:"AudioFormat,omitempty" xml:"AudioFormat,omitempty"`
	EnableSoundCode       *bool   `json:"EnableSoundCode,omitempty" xml:"EnableSoundCode,omitempty"`
	IotInstanceId         *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProjectCode           *string `json:"ProjectCode,omitempty" xml:"ProjectCode,omitempty"`
	SoundCodeConfigShrink *string `json:"SoundCodeConfig,omitempty" xml:"SoundCodeConfig,omitempty"`
	SpeechRate            *int32  `json:"SpeechRate,omitempty" xml:"SpeechRate,omitempty"`
	SpeechType            *string `json:"SpeechType,omitempty" xml:"SpeechType,omitempty"`
	Text                  *string `json:"Text,omitempty" xml:"Text,omitempty"`
	Voice                 *string `json:"Voice,omitempty" xml:"Voice,omitempty"`
	Volume                *int32  `json:"Volume,omitempty" xml:"Volume,omitempty"`
}

func (s TestSpeechShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s TestSpeechShrinkRequest) GoString() string {
	return s.String()
}

func (s *TestSpeechShrinkRequest) SetAudioFormat(v string) *TestSpeechShrinkRequest {
	s.AudioFormat = &v
	return s
}

func (s *TestSpeechShrinkRequest) SetEnableSoundCode(v bool) *TestSpeechShrinkRequest {
	s.EnableSoundCode = &v
	return s
}

func (s *TestSpeechShrinkRequest) SetIotInstanceId(v string) *TestSpeechShrinkRequest {
	s.IotInstanceId = &v
	return s
}

func (s *TestSpeechShrinkRequest) SetProjectCode(v string) *TestSpeechShrinkRequest {
	s.ProjectCode = &v
	return s
}

func (s *TestSpeechShrinkRequest) SetSoundCodeConfigShrink(v string) *TestSpeechShrinkRequest {
	s.SoundCodeConfigShrink = &v
	return s
}

func (s *TestSpeechShrinkRequest) SetSpeechRate(v int32) *TestSpeechShrinkRequest {
	s.SpeechRate = &v
	return s
}

func (s *TestSpeechShrinkRequest) SetSpeechType(v string) *TestSpeechShrinkRequest {
	s.SpeechType = &v
	return s
}

func (s *TestSpeechShrinkRequest) SetText(v string) *TestSpeechShrinkRequest {
	s.Text = &v
	return s
}

func (s *TestSpeechShrinkRequest) SetVoice(v string) *TestSpeechShrinkRequest {
	s.Voice = &v
	return s
}

func (s *TestSpeechShrinkRequest) SetVolume(v int32) *TestSpeechShrinkRequest {
	s.Volume = &v
	return s
}

type TestSpeechResponseBody struct {
	Code         *string                     `json:"Code,omitempty" xml:"Code,omitempty"`
	Data         *TestSpeechResponseBodyData `json:"Data,omitempty" xml:"Data,omitempty" type:"Struct"`
	ErrorMessage *string                     `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string                     `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool                       `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s TestSpeechResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TestSpeechResponseBody) GoString() string {
	return s.String()
}

func (s *TestSpeechResponseBody) SetCode(v string) *TestSpeechResponseBody {
	s.Code = &v
	return s
}

func (s *TestSpeechResponseBody) SetData(v *TestSpeechResponseBodyData) *TestSpeechResponseBody {
	s.Data = v
	return s
}

func (s *TestSpeechResponseBody) SetErrorMessage(v string) *TestSpeechResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *TestSpeechResponseBody) SetRequestId(v string) *TestSpeechResponseBody {
	s.RequestId = &v
	return s
}

func (s *TestSpeechResponseBody) SetSuccess(v bool) *TestSpeechResponseBody {
	s.Success = &v
	return s
}

type TestSpeechResponseBodyData struct {
	Items []*string `json:"items,omitempty" xml:"items,omitempty" type:"Repeated"`
}

func (s TestSpeechResponseBodyData) String() string {
	return tea.Prettify(s)
}

func (s TestSpeechResponseBodyData) GoString() string {
	return s.String()
}

func (s *TestSpeechResponseBodyData) SetItems(v []*string) *TestSpeechResponseBodyData {
	s.Items = v
	return s
}

type TestSpeechResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TestSpeechResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TestSpeechResponse) String() string {
	return tea.Prettify(s)
}

func (s TestSpeechResponse) GoString() string {
	return s.String()
}

func (s *TestSpeechResponse) SetHeaders(v map[string]*string) *TestSpeechResponse {
	s.Headers = v
	return s
}

func (s *TestSpeechResponse) SetStatusCode(v int32) *TestSpeechResponse {
	s.StatusCode = &v
	return s
}

func (s *TestSpeechResponse) SetBody(v *TestSpeechResponseBody) *TestSpeechResponse {
	s.Body = v
	return s
}

type TestSwitchRequest struct {
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s TestSwitchRequest) String() string {
	return tea.Prettify(s)
}

func (s TestSwitchRequest) GoString() string {
	return s.String()
}

func (s *TestSwitchRequest) SetDeviceName(v string) *TestSwitchRequest {
	s.DeviceName = &v
	return s
}

func (s *TestSwitchRequest) SetIotInstanceId(v string) *TestSwitchRequest {
	s.IotInstanceId = &v
	return s
}

func (s *TestSwitchRequest) SetProductKey(v string) *TestSwitchRequest {
	s.ProductKey = &v
	return s
}

type TestSwitchResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	IotId        *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s TestSwitchResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TestSwitchResponseBody) GoString() string {
	return s.String()
}

func (s *TestSwitchResponseBody) SetCode(v string) *TestSwitchResponseBody {
	s.Code = &v
	return s
}

func (s *TestSwitchResponseBody) SetErrorMessage(v string) *TestSwitchResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *TestSwitchResponseBody) SetIotId(v string) *TestSwitchResponseBody {
	s.IotId = &v
	return s
}

func (s *TestSwitchResponseBody) SetRequestId(v string) *TestSwitchResponseBody {
	s.RequestId = &v
	return s
}

func (s *TestSwitchResponseBody) SetSuccess(v bool) *TestSwitchResponseBody {
	s.Success = &v
	return s
}

type TestSwitchResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TestSwitchResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TestSwitchResponse) String() string {
	return tea.Prettify(s)
}

func (s TestSwitchResponse) GoString() string {
	return s.String()
}

func (s *TestSwitchResponse) SetHeaders(v map[string]*string) *TestSwitchResponse {
	s.Headers = v
	return s
}

func (s *TestSwitchResponse) SetStatusCode(v int32) *TestSwitchResponse {
	s.StatusCode = &v
	return s
}

func (s *TestSwitchResponse) SetBody(v *TestSwitchResponseBody) *TestSwitchResponse {
	s.Body = v
	return s
}

type TransformClientIdRequest struct {
	// The ClientID of the device.
	ClientId *string `json:"ClientId,omitempty" xml:"ClientId,omitempty"`
	// The ID of the device.
	IotId *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s TransformClientIdRequest) String() string {
	return tea.Prettify(s)
}

func (s TransformClientIdRequest) GoString() string {
	return s.String()
}

func (s *TransformClientIdRequest) SetClientId(v string) *TransformClientIdRequest {
	s.ClientId = &v
	return s
}

func (s *TransformClientIdRequest) SetIotId(v string) *TransformClientIdRequest {
	s.IotId = &v
	return s
}

func (s *TransformClientIdRequest) SetIotInstanceId(v string) *TransformClientIdRequest {
	s.IotInstanceId = &v
	return s
}

type TransformClientIdResponseBody struct {
	// The response code. The value Success indicates that the call was successful. Other values indicate that errors occurred. For more information about error codes, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s TransformClientIdResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TransformClientIdResponseBody) GoString() string {
	return s.String()
}

func (s *TransformClientIdResponseBody) SetCode(v string) *TransformClientIdResponseBody {
	s.Code = &v
	return s
}

func (s *TransformClientIdResponseBody) SetErrorMessage(v string) *TransformClientIdResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *TransformClientIdResponseBody) SetRequestId(v string) *TransformClientIdResponseBody {
	s.RequestId = &v
	return s
}

func (s *TransformClientIdResponseBody) SetSuccess(v bool) *TransformClientIdResponseBody {
	s.Success = &v
	return s
}

type TransformClientIdResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TransformClientIdResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TransformClientIdResponse) String() string {
	return tea.Prettify(s)
}

func (s TransformClientIdResponse) GoString() string {
	return s.String()
}

func (s *TransformClientIdResponse) SetHeaders(v map[string]*string) *TransformClientIdResponse {
	s.Headers = v
	return s
}

func (s *TransformClientIdResponse) SetStatusCode(v int32) *TransformClientIdResponse {
	s.StatusCode = &v
	return s
}

func (s *TransformClientIdResponse) SetBody(v *TransformClientIdResponseBody) *TransformClientIdResponse {
	s.Body = v
	return s
}

type TriggerSceneRuleRequest struct {
	InstanceId    *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	RuleId        *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s TriggerSceneRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s TriggerSceneRuleRequest) GoString() string {
	return s.String()
}

func (s *TriggerSceneRuleRequest) SetInstanceId(v string) *TriggerSceneRuleRequest {
	s.InstanceId = &v
	return s
}

func (s *TriggerSceneRuleRequest) SetIotInstanceId(v string) *TriggerSceneRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *TriggerSceneRuleRequest) SetRuleId(v string) *TriggerSceneRuleRequest {
	s.RuleId = &v
	return s
}

type TriggerSceneRuleResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s TriggerSceneRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s TriggerSceneRuleResponseBody) GoString() string {
	return s.String()
}

func (s *TriggerSceneRuleResponseBody) SetCode(v string) *TriggerSceneRuleResponseBody {
	s.Code = &v
	return s
}

func (s *TriggerSceneRuleResponseBody) SetErrorMessage(v string) *TriggerSceneRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *TriggerSceneRuleResponseBody) SetRequestId(v string) *TriggerSceneRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *TriggerSceneRuleResponseBody) SetSuccess(v bool) *TriggerSceneRuleResponseBody {
	s.Success = &v
	return s
}

type TriggerSceneRuleResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *TriggerSceneRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s TriggerSceneRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s TriggerSceneRuleResponse) GoString() string {
	return s.String()
}

func (s *TriggerSceneRuleResponse) SetHeaders(v map[string]*string) *TriggerSceneRuleResponse {
	s.Headers = v
	return s
}

func (s *TriggerSceneRuleResponse) SetStatusCode(v int32) *TriggerSceneRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *TriggerSceneRuleResponse) SetBody(v *TriggerSceneRuleResponseBody) *TriggerSceneRuleResponse {
	s.Body = v
	return s
}

type UnbindApplicationFromEdgeInstanceRequest struct {
	ApplicationId *string `json:"ApplicationId,omitempty" xml:"ApplicationId,omitempty"`
	InstanceId    *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s UnbindApplicationFromEdgeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s UnbindApplicationFromEdgeInstanceRequest) GoString() string {
	return s.String()
}

func (s *UnbindApplicationFromEdgeInstanceRequest) SetApplicationId(v string) *UnbindApplicationFromEdgeInstanceRequest {
	s.ApplicationId = &v
	return s
}

func (s *UnbindApplicationFromEdgeInstanceRequest) SetInstanceId(v string) *UnbindApplicationFromEdgeInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *UnbindApplicationFromEdgeInstanceRequest) SetIotInstanceId(v string) *UnbindApplicationFromEdgeInstanceRequest {
	s.IotInstanceId = &v
	return s
}

type UnbindApplicationFromEdgeInstanceResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UnbindApplicationFromEdgeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnbindApplicationFromEdgeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *UnbindApplicationFromEdgeInstanceResponseBody) SetCode(v string) *UnbindApplicationFromEdgeInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *UnbindApplicationFromEdgeInstanceResponseBody) SetErrorMessage(v string) *UnbindApplicationFromEdgeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UnbindApplicationFromEdgeInstanceResponseBody) SetRequestId(v string) *UnbindApplicationFromEdgeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UnbindApplicationFromEdgeInstanceResponseBody) SetSuccess(v bool) *UnbindApplicationFromEdgeInstanceResponseBody {
	s.Success = &v
	return s
}

type UnbindApplicationFromEdgeInstanceResponse struct {
	Headers    map[string]*string                             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnbindApplicationFromEdgeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnbindApplicationFromEdgeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s UnbindApplicationFromEdgeInstanceResponse) GoString() string {
	return s.String()
}

func (s *UnbindApplicationFromEdgeInstanceResponse) SetHeaders(v map[string]*string) *UnbindApplicationFromEdgeInstanceResponse {
	s.Headers = v
	return s
}

func (s *UnbindApplicationFromEdgeInstanceResponse) SetStatusCode(v int32) *UnbindApplicationFromEdgeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *UnbindApplicationFromEdgeInstanceResponse) SetBody(v *UnbindApplicationFromEdgeInstanceResponseBody) *UnbindApplicationFromEdgeInstanceResponse {
	s.Body = v
	return s
}

type UnbindDriverFromEdgeInstanceRequest struct {
	// The ID of the driver that you want to unbind. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver that you want to unbind and obtain the driver ID.
	//
	// You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance from which you want to unbind a driver and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s UnbindDriverFromEdgeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s UnbindDriverFromEdgeInstanceRequest) GoString() string {
	return s.String()
}

func (s *UnbindDriverFromEdgeInstanceRequest) SetDriverId(v string) *UnbindDriverFromEdgeInstanceRequest {
	s.DriverId = &v
	return s
}

func (s *UnbindDriverFromEdgeInstanceRequest) SetInstanceId(v string) *UnbindDriverFromEdgeInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *UnbindDriverFromEdgeInstanceRequest) SetIotInstanceId(v string) *UnbindDriverFromEdgeInstanceRequest {
	s.IotInstanceId = &v
	return s
}

type UnbindDriverFromEdgeInstanceResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UnbindDriverFromEdgeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnbindDriverFromEdgeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *UnbindDriverFromEdgeInstanceResponseBody) SetCode(v string) *UnbindDriverFromEdgeInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *UnbindDriverFromEdgeInstanceResponseBody) SetErrorMessage(v string) *UnbindDriverFromEdgeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UnbindDriverFromEdgeInstanceResponseBody) SetRequestId(v string) *UnbindDriverFromEdgeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UnbindDriverFromEdgeInstanceResponseBody) SetSuccess(v bool) *UnbindDriverFromEdgeInstanceResponseBody {
	s.Success = &v
	return s
}

type UnbindDriverFromEdgeInstanceResponse struct {
	Headers    map[string]*string                        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnbindDriverFromEdgeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnbindDriverFromEdgeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s UnbindDriverFromEdgeInstanceResponse) GoString() string {
	return s.String()
}

func (s *UnbindDriverFromEdgeInstanceResponse) SetHeaders(v map[string]*string) *UnbindDriverFromEdgeInstanceResponse {
	s.Headers = v
	return s
}

func (s *UnbindDriverFromEdgeInstanceResponse) SetStatusCode(v int32) *UnbindDriverFromEdgeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *UnbindDriverFromEdgeInstanceResponse) SetBody(v *UnbindDriverFromEdgeInstanceResponseBody) *UnbindDriverFromEdgeInstanceResponse {
	s.Body = v
	return s
}

type UnbindLicenseProductRequest struct {
	// The ID of the Enterprise Edition instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The license type that specifies the audio and video specifications. Valid values: **480P** and **720P**.
	//
	// To view the license type of a product, choose **License Management > Product Authorization** in the **Real-time Communication Service** console.
	LicenseCode *string `json:"LicenseCode,omitempty" xml:"LicenseCode,omitempty"`
	// The ProductKey of the product from which you want to unbind the license.
	//
	// You can choose **License Management > Product Authorization** in the **Real-Time Communication Service** console to view the **ProductKey** of the product.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s UnbindLicenseProductRequest) String() string {
	return tea.Prettify(s)
}

func (s UnbindLicenseProductRequest) GoString() string {
	return s.String()
}

func (s *UnbindLicenseProductRequest) SetIotInstanceId(v string) *UnbindLicenseProductRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UnbindLicenseProductRequest) SetLicenseCode(v string) *UnbindLicenseProductRequest {
	s.LicenseCode = &v
	return s
}

func (s *UnbindLicenseProductRequest) SetProductKey(v string) *UnbindLicenseProductRequest {
	s.ProductKey = &v
	return s
}

type UnbindLicenseProductResponseBody struct {
	// The error code returned if the request fails. For more information, see the **Error codes** section of this topic.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// Indicates whether the license was unbound from the product.
	//
	// *   **true**
	// *   **false**
	Data *bool `json:"Data,omitempty" xml:"Data,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful.
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UnbindLicenseProductResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnbindLicenseProductResponseBody) GoString() string {
	return s.String()
}

func (s *UnbindLicenseProductResponseBody) SetCode(v string) *UnbindLicenseProductResponseBody {
	s.Code = &v
	return s
}

func (s *UnbindLicenseProductResponseBody) SetData(v bool) *UnbindLicenseProductResponseBody {
	s.Data = &v
	return s
}

func (s *UnbindLicenseProductResponseBody) SetErrorMessage(v string) *UnbindLicenseProductResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UnbindLicenseProductResponseBody) SetRequestId(v string) *UnbindLicenseProductResponseBody {
	s.RequestId = &v
	return s
}

func (s *UnbindLicenseProductResponseBody) SetSuccess(v bool) *UnbindLicenseProductResponseBody {
	s.Success = &v
	return s
}

type UnbindLicenseProductResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnbindLicenseProductResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnbindLicenseProductResponse) String() string {
	return tea.Prettify(s)
}

func (s UnbindLicenseProductResponse) GoString() string {
	return s.String()
}

func (s *UnbindLicenseProductResponse) SetHeaders(v map[string]*string) *UnbindLicenseProductResponse {
	s.Headers = v
	return s
}

func (s *UnbindLicenseProductResponse) SetStatusCode(v int32) *UnbindLicenseProductResponse {
	s.StatusCode = &v
	return s
}

func (s *UnbindLicenseProductResponse) SetBody(v *UnbindLicenseProductResponseBody) *UnbindLicenseProductResponse {
	s.Body = v
	return s
}

type UnbindRoleFromEdgeInstanceRequest struct {
	InstanceId    *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s UnbindRoleFromEdgeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s UnbindRoleFromEdgeInstanceRequest) GoString() string {
	return s.String()
}

func (s *UnbindRoleFromEdgeInstanceRequest) SetInstanceId(v string) *UnbindRoleFromEdgeInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *UnbindRoleFromEdgeInstanceRequest) SetIotInstanceId(v string) *UnbindRoleFromEdgeInstanceRequest {
	s.IotInstanceId = &v
	return s
}

type UnbindRoleFromEdgeInstanceResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UnbindRoleFromEdgeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnbindRoleFromEdgeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *UnbindRoleFromEdgeInstanceResponseBody) SetCode(v string) *UnbindRoleFromEdgeInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *UnbindRoleFromEdgeInstanceResponseBody) SetErrorMessage(v string) *UnbindRoleFromEdgeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UnbindRoleFromEdgeInstanceResponseBody) SetRequestId(v string) *UnbindRoleFromEdgeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UnbindRoleFromEdgeInstanceResponseBody) SetSuccess(v bool) *UnbindRoleFromEdgeInstanceResponseBody {
	s.Success = &v
	return s
}

type UnbindRoleFromEdgeInstanceResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnbindRoleFromEdgeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnbindRoleFromEdgeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s UnbindRoleFromEdgeInstanceResponse) GoString() string {
	return s.String()
}

func (s *UnbindRoleFromEdgeInstanceResponse) SetHeaders(v map[string]*string) *UnbindRoleFromEdgeInstanceResponse {
	s.Headers = v
	return s
}

func (s *UnbindRoleFromEdgeInstanceResponse) SetStatusCode(v int32) *UnbindRoleFromEdgeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *UnbindRoleFromEdgeInstanceResponse) SetBody(v *UnbindRoleFromEdgeInstanceResponseBody) *UnbindRoleFromEdgeInstanceResponse {
	s.Body = v
	return s
}

type UnbindSceneRuleFromEdgeInstanceRequest struct {
	InstanceId    *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	RuleId        *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
}

func (s UnbindSceneRuleFromEdgeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s UnbindSceneRuleFromEdgeInstanceRequest) GoString() string {
	return s.String()
}

func (s *UnbindSceneRuleFromEdgeInstanceRequest) SetInstanceId(v string) *UnbindSceneRuleFromEdgeInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *UnbindSceneRuleFromEdgeInstanceRequest) SetIotInstanceId(v string) *UnbindSceneRuleFromEdgeInstanceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UnbindSceneRuleFromEdgeInstanceRequest) SetRuleId(v string) *UnbindSceneRuleFromEdgeInstanceRequest {
	s.RuleId = &v
	return s
}

type UnbindSceneRuleFromEdgeInstanceResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UnbindSceneRuleFromEdgeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UnbindSceneRuleFromEdgeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *UnbindSceneRuleFromEdgeInstanceResponseBody) SetCode(v string) *UnbindSceneRuleFromEdgeInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *UnbindSceneRuleFromEdgeInstanceResponseBody) SetErrorMessage(v string) *UnbindSceneRuleFromEdgeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UnbindSceneRuleFromEdgeInstanceResponseBody) SetRequestId(v string) *UnbindSceneRuleFromEdgeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UnbindSceneRuleFromEdgeInstanceResponseBody) SetSuccess(v bool) *UnbindSceneRuleFromEdgeInstanceResponseBody {
	s.Success = &v
	return s
}

type UnbindSceneRuleFromEdgeInstanceResponse struct {
	Headers    map[string]*string                           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UnbindSceneRuleFromEdgeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UnbindSceneRuleFromEdgeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s UnbindSceneRuleFromEdgeInstanceResponse) GoString() string {
	return s.String()
}

func (s *UnbindSceneRuleFromEdgeInstanceResponse) SetHeaders(v map[string]*string) *UnbindSceneRuleFromEdgeInstanceResponse {
	s.Headers = v
	return s
}

func (s *UnbindSceneRuleFromEdgeInstanceResponse) SetStatusCode(v int32) *UnbindSceneRuleFromEdgeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *UnbindSceneRuleFromEdgeInstanceResponse) SetBody(v *UnbindSceneRuleFromEdgeInstanceResponseBody) *UnbindSceneRuleFromEdgeInstanceResponse {
	s.Body = v
	return s
}

type UpdateConsumerGroupRequest struct {
	// The consumer group ID. After you call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group, the consumer group ID is returned. You can call the [QueryConsumerGroupList](~~170419~~) operation to query the consumer group ID by group name. You can also go to the IoT Platform console,and choose **Rules** > **Server-side Subscription** > **Consumer Groups** to view the consumer group ID.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The new name of the consumer group. The name must be 4 to 30 characters in length and can contain letters, digits, and underscores (\_).
	NewGroupName *string `json:"NewGroupName,omitempty" xml:"NewGroupName,omitempty"`
}

func (s UpdateConsumerGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateConsumerGroupRequest) GoString() string {
	return s.String()
}

func (s *UpdateConsumerGroupRequest) SetGroupId(v string) *UpdateConsumerGroupRequest {
	s.GroupId = &v
	return s
}

func (s *UpdateConsumerGroupRequest) SetIotInstanceId(v string) *UpdateConsumerGroupRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateConsumerGroupRequest) SetNewGroupName(v string) *UpdateConsumerGroupRequest {
	s.NewGroupName = &v
	return s
}

type UpdateConsumerGroupResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateConsumerGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateConsumerGroupResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateConsumerGroupResponseBody) SetCode(v string) *UpdateConsumerGroupResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateConsumerGroupResponseBody) SetErrorMessage(v string) *UpdateConsumerGroupResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateConsumerGroupResponseBody) SetRequestId(v string) *UpdateConsumerGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateConsumerGroupResponseBody) SetSuccess(v bool) *UpdateConsumerGroupResponseBody {
	s.Success = &v
	return s
}

type UpdateConsumerGroupResponse struct {
	Headers    map[string]*string               `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                           `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateConsumerGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateConsumerGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateConsumerGroupResponse) GoString() string {
	return s.String()
}

func (s *UpdateConsumerGroupResponse) SetHeaders(v map[string]*string) *UpdateConsumerGroupResponse {
	s.Headers = v
	return s
}

func (s *UpdateConsumerGroupResponse) SetStatusCode(v int32) *UpdateConsumerGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateConsumerGroupResponse) SetBody(v *UpdateConsumerGroupResponseBody) *UpdateConsumerGroupResponse {
	s.Body = v
	return s
}

type UpdateDestinationRequest struct {
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
	Description   *string `json:"Description,omitempty" xml:"Description,omitempty"`
	DestinationId *int64  `json:"DestinationId,omitempty" xml:"DestinationId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Name          *string `json:"Name,omitempty" xml:"Name,omitempty"`
	Type          *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateDestinationRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDestinationRequest) GoString() string {
	return s.String()
}

func (s *UpdateDestinationRequest) SetConfiguration(v string) *UpdateDestinationRequest {
	s.Configuration = &v
	return s
}

func (s *UpdateDestinationRequest) SetDescription(v string) *UpdateDestinationRequest {
	s.Description = &v
	return s
}

func (s *UpdateDestinationRequest) SetDestinationId(v int64) *UpdateDestinationRequest {
	s.DestinationId = &v
	return s
}

func (s *UpdateDestinationRequest) SetIotInstanceId(v string) *UpdateDestinationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateDestinationRequest) SetName(v string) *UpdateDestinationRequest {
	s.Name = &v
	return s
}

func (s *UpdateDestinationRequest) SetType(v string) *UpdateDestinationRequest {
	s.Type = &v
	return s
}

type UpdateDestinationResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateDestinationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDestinationResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDestinationResponseBody) SetCode(v string) *UpdateDestinationResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateDestinationResponseBody) SetErrorMessage(v string) *UpdateDestinationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateDestinationResponseBody) SetRequestId(v string) *UpdateDestinationResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateDestinationResponseBody) SetSuccess(v bool) *UpdateDestinationResponseBody {
	s.Success = &v
	return s
}

type UpdateDestinationResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDestinationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDestinationResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDestinationResponse) GoString() string {
	return s.String()
}

func (s *UpdateDestinationResponse) SetHeaders(v map[string]*string) *UpdateDestinationResponse {
	s.Headers = v
	return s
}

func (s *UpdateDestinationResponse) SetStatusCode(v int32) *UpdateDestinationResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDestinationResponse) SetBody(v *UpdateDestinationResponseBody) *UpdateDestinationResponse {
	s.Body = v
	return s
}

type UpdateDeviceGroupRequest struct {
	// The description of the group. The description must be 1 to 100 characters in length.
	GroupDesc *string `json:"GroupDesc,omitempty" xml:"GroupDesc,omitempty"`
	// The ID of the group. The ID is the globally unique identifier (GUID) for the group.
	GroupId *string `json:"GroupId,omitempty" xml:"GroupId,omitempty"`
	// The type of the group.
	//
	// If you set the value to **LINK_PLATFORM_DYNAMIC**, a dynamic group is queried. If you do not specify this parameter, a static group is queried by default.
	GroupType *string `json:"GroupType,omitempty" xml:"GroupType,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s UpdateDeviceGroupRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDeviceGroupRequest) GoString() string {
	return s.String()
}

func (s *UpdateDeviceGroupRequest) SetGroupDesc(v string) *UpdateDeviceGroupRequest {
	s.GroupDesc = &v
	return s
}

func (s *UpdateDeviceGroupRequest) SetGroupId(v string) *UpdateDeviceGroupRequest {
	s.GroupId = &v
	return s
}

func (s *UpdateDeviceGroupRequest) SetGroupType(v string) *UpdateDeviceGroupRequest {
	s.GroupType = &v
	return s
}

func (s *UpdateDeviceGroupRequest) SetIotInstanceId(v string) *UpdateDeviceGroupRequest {
	s.IotInstanceId = &v
	return s
}

type UpdateDeviceGroupResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateDeviceGroupResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDeviceGroupResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDeviceGroupResponseBody) SetCode(v string) *UpdateDeviceGroupResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateDeviceGroupResponseBody) SetErrorMessage(v string) *UpdateDeviceGroupResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateDeviceGroupResponseBody) SetRequestId(v string) *UpdateDeviceGroupResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateDeviceGroupResponseBody) SetSuccess(v bool) *UpdateDeviceGroupResponseBody {
	s.Success = &v
	return s
}

type UpdateDeviceGroupResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDeviceGroupResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDeviceGroupResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDeviceGroupResponse) GoString() string {
	return s.String()
}

func (s *UpdateDeviceGroupResponse) SetHeaders(v map[string]*string) *UpdateDeviceGroupResponse {
	s.Headers = v
	return s
}

func (s *UpdateDeviceGroupResponse) SetStatusCode(v int32) *UpdateDeviceGroupResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDeviceGroupResponse) SetBody(v *UpdateDeviceGroupResponseBody) *UpdateDeviceGroupResponse {
	s.Body = v
	return s
}

type UpdateDeviceShadowRequest struct {
	// Specifies whether to perform an incremental update on the **desired** parameter. Valid values:
	//
	// *   **true**: performs an incremental update.
	// *   **false**: performs a full update. This is the default value.
	DeltaUpdate *bool `json:"DeltaUpdate,omitempty" xml:"DeltaUpdate,omitempty"`
	// The name of the device whose shadow information you want to modify.
	DeviceName *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	// The ID of the elastic container instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.****
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****
	// >*   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product to which the device belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The information that you want to specify for the device shadow.
	//
	// The information includes the following parameters:
	//
	// *   **method**: the type of the operation. Data type: string. Set the value to **update**.
	//
	// *   **state**: the status of the device shadow. Data type: string. The **desired** parameter specifies the expected shadow status.
	//
	// *   **version**: the version of the device shadow. Data type: long.
	//
	//     *   If versioning is not required, set this parameter to 0.
	//     *   If versioning is required, specify a version that is later than the current version.
	//
	// **
	//
	// **Important** If versioning is required, do not query the version of a device shadow in the IoT Platform console. If a large number of update and query operations are concurrently performed, multiple update operations may return the same version. In this case, the most recent update operation may first be completed. As a result, the current shadow information is not the latest shadow information. We recommend that you maintain the versions of device shadows on the on-premises device. When you call this operation, use an on-premises application to obtain the latest version of the device shadow.
	ShadowMessage *string `json:"ShadowMessage,omitempty" xml:"ShadowMessage,omitempty"`
}

func (s UpdateDeviceShadowRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateDeviceShadowRequest) GoString() string {
	return s.String()
}

func (s *UpdateDeviceShadowRequest) SetDeltaUpdate(v bool) *UpdateDeviceShadowRequest {
	s.DeltaUpdate = &v
	return s
}

func (s *UpdateDeviceShadowRequest) SetDeviceName(v string) *UpdateDeviceShadowRequest {
	s.DeviceName = &v
	return s
}

func (s *UpdateDeviceShadowRequest) SetIotInstanceId(v string) *UpdateDeviceShadowRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateDeviceShadowRequest) SetProductKey(v string) *UpdateDeviceShadowRequest {
	s.ProductKey = &v
	return s
}

func (s *UpdateDeviceShadowRequest) SetShadowMessage(v string) *UpdateDeviceShadowRequest {
	s.ShadowMessage = &v
	return s
}

type UpdateDeviceShadowResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateDeviceShadowResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateDeviceShadowResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateDeviceShadowResponseBody) SetCode(v string) *UpdateDeviceShadowResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateDeviceShadowResponseBody) SetErrorMessage(v string) *UpdateDeviceShadowResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateDeviceShadowResponseBody) SetRequestId(v string) *UpdateDeviceShadowResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateDeviceShadowResponseBody) SetSuccess(v bool) *UpdateDeviceShadowResponseBody {
	s.Success = &v
	return s
}

type UpdateDeviceShadowResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateDeviceShadowResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateDeviceShadowResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateDeviceShadowResponse) GoString() string {
	return s.String()
}

func (s *UpdateDeviceShadowResponse) SetHeaders(v map[string]*string) *UpdateDeviceShadowResponse {
	s.Headers = v
	return s
}

func (s *UpdateDeviceShadowResponse) SetStatusCode(v int32) *UpdateDeviceShadowResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateDeviceShadowResponse) SetBody(v *UpdateDeviceShadowResponseBody) *UpdateDeviceShadowResponse {
	s.Body = v
	return s
}

type UpdateEdgeDriverVersionRequest struct {
	// The Java Virtual Machine (JVM) startup parameter.
	Argument *string `json:"Argument,omitempty" xml:"Argument,omitempty"`
	// The rule for verifying configurations. Set this parameter to a JSON string in the following format:
	//
	// `{"deviceConfig":{"required":false},"driverConfig":{"required":false}`
	//
	// The JSON string contains the following parameters:
	//
	// *   driverConfig: the rule for verifying the configuration of the driver when the driver is to be deployed in an edge instance.
	// *   deviceConfig: the rule for verifying the configurations of devices that use the driver when the driver is to be deployed in an edge instance.
	//
	// `required`: A value of true indicates that the corresponding parameter is required. A value of false indicates that the corresponding parameter is optional.
	ConfigCheckRule *string `json:"ConfigCheckRule,omitempty" xml:"ConfigCheckRule,omitempty"`
	// The configuration of the container where the driver runs. Set this parameter to a JSON string. For more information about parameters in the JSON string, see the following parameter description of ContainerConfig.
	ContainerConfig *string `json:"ContainerConfig,omitempty" xml:"ContainerConfig,omitempty"`
	// The description of the driver. The description can be a maximum of 256 bytes in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The configuration of the driver. Set this parameter to a JSON string in the following format:
	//
	// `{"format":"JSON","content":"{}"}`
	//
	// The JSON string contains the following parameters:
	//
	// *   format: the format of the driver configuration. Valid values: KV (key-value pair), JSON (JSON string), and FILE (configuration file).
	//
	// *   content: the content of the driver configuration. If you set the format parameter to KV or JSON, set this parameter to the configuration content of the driver. If you set the format parameter to FILE, set this parameter to the URL of the driver configuration file stored in OSS.
	//
	// >To obtain the URL of the driver configuration file stored in OSS, call the [CreateOssPreSignedAddress](~~155858~~) operation.
	DriverConfig *string `json:"DriverConfig,omitempty" xml:"DriverConfig,omitempty"`
	// The ID of the driver. To obtain the driver ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Drivers** page, move the pointer over the name of the driver for which you want to update a driver version and obtain the driver ID.
	//
	// You can also call the [QueryEdgeDriver](~~155776~~) operation to query the driver ID.
	DriverId *string `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	// The version number of the driver.
	DriverVersion *string `json:"DriverVersion,omitempty" xml:"DriverVersion,omitempty"`
	// The earliest version of Link IoT Edge that is supported by the driver. The driver can run on gateways of only this version and later. For example, if you set this parameter to 2.4.0, the driver can run on gateways of only version 2.4.0 and later.
	EdgeVersion *string `json:"EdgeVersion,omitempty" xml:"EdgeVersion,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	SourceConfig  *string `json:"SourceConfig,omitempty" xml:"SourceConfig,omitempty"`
}

func (s UpdateEdgeDriverVersionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateEdgeDriverVersionRequest) GoString() string {
	return s.String()
}

func (s *UpdateEdgeDriverVersionRequest) SetArgument(v string) *UpdateEdgeDriverVersionRequest {
	s.Argument = &v
	return s
}

func (s *UpdateEdgeDriverVersionRequest) SetConfigCheckRule(v string) *UpdateEdgeDriverVersionRequest {
	s.ConfigCheckRule = &v
	return s
}

func (s *UpdateEdgeDriverVersionRequest) SetContainerConfig(v string) *UpdateEdgeDriverVersionRequest {
	s.ContainerConfig = &v
	return s
}

func (s *UpdateEdgeDriverVersionRequest) SetDescription(v string) *UpdateEdgeDriverVersionRequest {
	s.Description = &v
	return s
}

func (s *UpdateEdgeDriverVersionRequest) SetDriverConfig(v string) *UpdateEdgeDriverVersionRequest {
	s.DriverConfig = &v
	return s
}

func (s *UpdateEdgeDriverVersionRequest) SetDriverId(v string) *UpdateEdgeDriverVersionRequest {
	s.DriverId = &v
	return s
}

func (s *UpdateEdgeDriverVersionRequest) SetDriverVersion(v string) *UpdateEdgeDriverVersionRequest {
	s.DriverVersion = &v
	return s
}

func (s *UpdateEdgeDriverVersionRequest) SetEdgeVersion(v string) *UpdateEdgeDriverVersionRequest {
	s.EdgeVersion = &v
	return s
}

func (s *UpdateEdgeDriverVersionRequest) SetIotInstanceId(v string) *UpdateEdgeDriverVersionRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateEdgeDriverVersionRequest) SetSourceConfig(v string) *UpdateEdgeDriverVersionRequest {
	s.SourceConfig = &v
	return s
}

type UpdateEdgeDriverVersionResponseBody struct {
	// The return code of the operation. A value of Success indicates that the call was successful. Other values indicate that specific errors occurred. For more information, see [Error codes](~~135200~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateEdgeDriverVersionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateEdgeDriverVersionResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateEdgeDriverVersionResponseBody) SetCode(v string) *UpdateEdgeDriverVersionResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateEdgeDriverVersionResponseBody) SetErrorMessage(v string) *UpdateEdgeDriverVersionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateEdgeDriverVersionResponseBody) SetRequestId(v string) *UpdateEdgeDriverVersionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateEdgeDriverVersionResponseBody) SetSuccess(v bool) *UpdateEdgeDriverVersionResponseBody {
	s.Success = &v
	return s
}

type UpdateEdgeDriverVersionResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateEdgeDriverVersionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateEdgeDriverVersionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateEdgeDriverVersionResponse) GoString() string {
	return s.String()
}

func (s *UpdateEdgeDriverVersionResponse) SetHeaders(v map[string]*string) *UpdateEdgeDriverVersionResponse {
	s.Headers = v
	return s
}

func (s *UpdateEdgeDriverVersionResponse) SetStatusCode(v int32) *UpdateEdgeDriverVersionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateEdgeDriverVersionResponse) SetBody(v *UpdateEdgeDriverVersionResponseBody) *UpdateEdgeDriverVersionResponse {
	s.Body = v
	return s
}

type UpdateEdgeInstanceRequest struct {
	// Specifies whether to enable the edge instance. Valid values:
	//
	// *   true: enables the edge instance.
	// *   false: disables the edge instance.
	//
	// If you do not set this parameter, this parameter is not updated.
	BizEnable *bool `json:"BizEnable,omitempty" xml:"BizEnable,omitempty"`
	// The ID of the edge instance. To obtain the instance ID, perform the following steps: Log on to the [Link IoT Edge console](https://iot.console.aliyun.com/le/instance/list). On the **Edge Instances** page, move the pointer over the name of the edge instance that you want to update and obtain the instance ID.
	//
	// You can also call the [QueryEdgeInstance](~~135214~~) operation to query the instance ID.
	InstanceId *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	// The ID of the Internet of Things (IoT) service instance. This parameter is not required for the public instance but required for Enterprise Edition instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The name of the edge instance.
	//
	// The name can be up to 20 characters in length and can contain letters, digits, underscores (\_), and hyphens (-).
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The specifications of the edge instance. Valid values:
	//
	// *   10: Lite Edition
	// *   20: Standard Edition
	// *   30: Pro Edition
	//
	// If you do not set this parameter, this parameter is not updated.
	Spec *int32 `json:"Spec,omitempty" xml:"Spec,omitempty"`
	// The tags of the edge instance. Each tag is a key-value pair. Multiple tags are separated with commas (,). Example: `k1:v1,k2:v2`.
	//
	// *   Take note of the following limits on tag keys:
	//
	//     *   Tag keys cannot be left empty.
	//     *   Tag keys must be unique in the edge instance.
	//     *   Tag keys support only letters.
	//     *   Each tag key can be up to 20 characters in length.
	//
	// *   Take note of the following limits on tag values:
	//
	//     *   Tag values cannot be left empty.
	//     *   A tag value can contain letters, digits, underscores (\_), and hyphens (-).
	//     *   Each tag value can be up to 20 characters in length.
	//
	// If you do not set this parameter, this parameter is not updated.
	Tags *string `json:"Tags,omitempty" xml:"Tags,omitempty"`
}

func (s UpdateEdgeInstanceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateEdgeInstanceRequest) GoString() string {
	return s.String()
}

func (s *UpdateEdgeInstanceRequest) SetBizEnable(v bool) *UpdateEdgeInstanceRequest {
	s.BizEnable = &v
	return s
}

func (s *UpdateEdgeInstanceRequest) SetInstanceId(v string) *UpdateEdgeInstanceRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateEdgeInstanceRequest) SetIotInstanceId(v string) *UpdateEdgeInstanceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateEdgeInstanceRequest) SetName(v string) *UpdateEdgeInstanceRequest {
	s.Name = &v
	return s
}

func (s *UpdateEdgeInstanceRequest) SetSpec(v int32) *UpdateEdgeInstanceRequest {
	s.Spec = &v
	return s
}

func (s *UpdateEdgeInstanceRequest) SetTags(v string) *UpdateEdgeInstanceRequest {
	s.Tags = &v
	return s
}

type UpdateEdgeInstanceResponseBody struct {
	// The return code of the operation.
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message that is returned if the call failed.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. A value of true indicates that the call was successful. A value of false indicates that the call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateEdgeInstanceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateEdgeInstanceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateEdgeInstanceResponseBody) SetCode(v string) *UpdateEdgeInstanceResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateEdgeInstanceResponseBody) SetErrorMessage(v string) *UpdateEdgeInstanceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateEdgeInstanceResponseBody) SetRequestId(v string) *UpdateEdgeInstanceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateEdgeInstanceResponseBody) SetSuccess(v bool) *UpdateEdgeInstanceResponseBody {
	s.Success = &v
	return s
}

type UpdateEdgeInstanceResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateEdgeInstanceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateEdgeInstanceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateEdgeInstanceResponse) GoString() string {
	return s.String()
}

func (s *UpdateEdgeInstanceResponse) SetHeaders(v map[string]*string) *UpdateEdgeInstanceResponse {
	s.Headers = v
	return s
}

func (s *UpdateEdgeInstanceResponse) SetStatusCode(v int32) *UpdateEdgeInstanceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateEdgeInstanceResponse) SetBody(v *UpdateEdgeInstanceResponseBody) *UpdateEdgeInstanceResponse {
	s.Body = v
	return s
}

type UpdateEdgeInstanceChannelRequest struct {
	ChannelId     *string                                    `json:"ChannelId,omitempty" xml:"ChannelId,omitempty"`
	ChannelName   *string                                    `json:"ChannelName,omitempty" xml:"ChannelName,omitempty"`
	Configs       []*UpdateEdgeInstanceChannelRequestConfigs `json:"Configs,omitempty" xml:"Configs,omitempty" type:"Repeated"`
	DriverId      *string                                    `json:"DriverId,omitempty" xml:"DriverId,omitempty"`
	InstanceId    *string                                    `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId *string                                    `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
}

func (s UpdateEdgeInstanceChannelRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateEdgeInstanceChannelRequest) GoString() string {
	return s.String()
}

func (s *UpdateEdgeInstanceChannelRequest) SetChannelId(v string) *UpdateEdgeInstanceChannelRequest {
	s.ChannelId = &v
	return s
}

func (s *UpdateEdgeInstanceChannelRequest) SetChannelName(v string) *UpdateEdgeInstanceChannelRequest {
	s.ChannelName = &v
	return s
}

func (s *UpdateEdgeInstanceChannelRequest) SetConfigs(v []*UpdateEdgeInstanceChannelRequestConfigs) *UpdateEdgeInstanceChannelRequest {
	s.Configs = v
	return s
}

func (s *UpdateEdgeInstanceChannelRequest) SetDriverId(v string) *UpdateEdgeInstanceChannelRequest {
	s.DriverId = &v
	return s
}

func (s *UpdateEdgeInstanceChannelRequest) SetInstanceId(v string) *UpdateEdgeInstanceChannelRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateEdgeInstanceChannelRequest) SetIotInstanceId(v string) *UpdateEdgeInstanceChannelRequest {
	s.IotInstanceId = &v
	return s
}

type UpdateEdgeInstanceChannelRequestConfigs struct {
	Content *string `json:"Content,omitempty" xml:"Content,omitempty"`
	Format  *string `json:"Format,omitempty" xml:"Format,omitempty"`
	Key     *string `json:"Key,omitempty" xml:"Key,omitempty"`
}

func (s UpdateEdgeInstanceChannelRequestConfigs) String() string {
	return tea.Prettify(s)
}

func (s UpdateEdgeInstanceChannelRequestConfigs) GoString() string {
	return s.String()
}

func (s *UpdateEdgeInstanceChannelRequestConfigs) SetContent(v string) *UpdateEdgeInstanceChannelRequestConfigs {
	s.Content = &v
	return s
}

func (s *UpdateEdgeInstanceChannelRequestConfigs) SetFormat(v string) *UpdateEdgeInstanceChannelRequestConfigs {
	s.Format = &v
	return s
}

func (s *UpdateEdgeInstanceChannelRequestConfigs) SetKey(v string) *UpdateEdgeInstanceChannelRequestConfigs {
	s.Key = &v
	return s
}

type UpdateEdgeInstanceChannelResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateEdgeInstanceChannelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateEdgeInstanceChannelResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateEdgeInstanceChannelResponseBody) SetCode(v string) *UpdateEdgeInstanceChannelResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateEdgeInstanceChannelResponseBody) SetErrorMessage(v string) *UpdateEdgeInstanceChannelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateEdgeInstanceChannelResponseBody) SetRequestId(v string) *UpdateEdgeInstanceChannelResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateEdgeInstanceChannelResponseBody) SetSuccess(v bool) *UpdateEdgeInstanceChannelResponseBody {
	s.Success = &v
	return s
}

type UpdateEdgeInstanceChannelResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateEdgeInstanceChannelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateEdgeInstanceChannelResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateEdgeInstanceChannelResponse) GoString() string {
	return s.String()
}

func (s *UpdateEdgeInstanceChannelResponse) SetHeaders(v map[string]*string) *UpdateEdgeInstanceChannelResponse {
	s.Headers = v
	return s
}

func (s *UpdateEdgeInstanceChannelResponse) SetStatusCode(v int32) *UpdateEdgeInstanceChannelResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateEdgeInstanceChannelResponse) SetBody(v *UpdateEdgeInstanceChannelResponseBody) *UpdateEdgeInstanceChannelResponse {
	s.Body = v
	return s
}

type UpdateEdgeInstanceMessageRoutingRequest struct {
	InstanceId      *string `json:"InstanceId,omitempty" xml:"InstanceId,omitempty"`
	IotInstanceId   *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Name            *string `json:"Name,omitempty" xml:"Name,omitempty"`
	RouteId         *int64  `json:"RouteId,omitempty" xml:"RouteId,omitempty"`
	SourceData      *string `json:"SourceData,omitempty" xml:"SourceData,omitempty"`
	SourceType      *string `json:"SourceType,omitempty" xml:"SourceType,omitempty"`
	TargetData      *string `json:"TargetData,omitempty" xml:"TargetData,omitempty"`
	TargetIotHubQos *int32  `json:"TargetIotHubQos,omitempty" xml:"TargetIotHubQos,omitempty"`
	TargetType      *string `json:"TargetType,omitempty" xml:"TargetType,omitempty"`
	TopicFilter     *string `json:"TopicFilter,omitempty" xml:"TopicFilter,omitempty"`
}

func (s UpdateEdgeInstanceMessageRoutingRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateEdgeInstanceMessageRoutingRequest) GoString() string {
	return s.String()
}

func (s *UpdateEdgeInstanceMessageRoutingRequest) SetInstanceId(v string) *UpdateEdgeInstanceMessageRoutingRequest {
	s.InstanceId = &v
	return s
}

func (s *UpdateEdgeInstanceMessageRoutingRequest) SetIotInstanceId(v string) *UpdateEdgeInstanceMessageRoutingRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateEdgeInstanceMessageRoutingRequest) SetName(v string) *UpdateEdgeInstanceMessageRoutingRequest {
	s.Name = &v
	return s
}

func (s *UpdateEdgeInstanceMessageRoutingRequest) SetRouteId(v int64) *UpdateEdgeInstanceMessageRoutingRequest {
	s.RouteId = &v
	return s
}

func (s *UpdateEdgeInstanceMessageRoutingRequest) SetSourceData(v string) *UpdateEdgeInstanceMessageRoutingRequest {
	s.SourceData = &v
	return s
}

func (s *UpdateEdgeInstanceMessageRoutingRequest) SetSourceType(v string) *UpdateEdgeInstanceMessageRoutingRequest {
	s.SourceType = &v
	return s
}

func (s *UpdateEdgeInstanceMessageRoutingRequest) SetTargetData(v string) *UpdateEdgeInstanceMessageRoutingRequest {
	s.TargetData = &v
	return s
}

func (s *UpdateEdgeInstanceMessageRoutingRequest) SetTargetIotHubQos(v int32) *UpdateEdgeInstanceMessageRoutingRequest {
	s.TargetIotHubQos = &v
	return s
}

func (s *UpdateEdgeInstanceMessageRoutingRequest) SetTargetType(v string) *UpdateEdgeInstanceMessageRoutingRequest {
	s.TargetType = &v
	return s
}

func (s *UpdateEdgeInstanceMessageRoutingRequest) SetTopicFilter(v string) *UpdateEdgeInstanceMessageRoutingRequest {
	s.TopicFilter = &v
	return s
}

type UpdateEdgeInstanceMessageRoutingResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateEdgeInstanceMessageRoutingResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateEdgeInstanceMessageRoutingResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateEdgeInstanceMessageRoutingResponseBody) SetCode(v string) *UpdateEdgeInstanceMessageRoutingResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateEdgeInstanceMessageRoutingResponseBody) SetErrorMessage(v string) *UpdateEdgeInstanceMessageRoutingResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateEdgeInstanceMessageRoutingResponseBody) SetRequestId(v string) *UpdateEdgeInstanceMessageRoutingResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateEdgeInstanceMessageRoutingResponseBody) SetSuccess(v bool) *UpdateEdgeInstanceMessageRoutingResponseBody {
	s.Success = &v
	return s
}

type UpdateEdgeInstanceMessageRoutingResponse struct {
	Headers    map[string]*string                            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateEdgeInstanceMessageRoutingResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateEdgeInstanceMessageRoutingResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateEdgeInstanceMessageRoutingResponse) GoString() string {
	return s.String()
}

func (s *UpdateEdgeInstanceMessageRoutingResponse) SetHeaders(v map[string]*string) *UpdateEdgeInstanceMessageRoutingResponse {
	s.Headers = v
	return s
}

func (s *UpdateEdgeInstanceMessageRoutingResponse) SetStatusCode(v int32) *UpdateEdgeInstanceMessageRoutingResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateEdgeInstanceMessageRoutingResponse) SetBody(v *UpdateEdgeInstanceMessageRoutingResponseBody) *UpdateEdgeInstanceMessageRoutingResponse {
	s.Body = v
	return s
}

type UpdateJobRequest struct {
	Description   *string                `json:"Description,omitempty" xml:"Description,omitempty"`
	IotInstanceId *string                `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	JobId         *string                `json:"JobId,omitempty" xml:"JobId,omitempty"`
	RolloutConfig map[string]interface{} `json:"RolloutConfig,omitempty" xml:"RolloutConfig,omitempty"`
	TimeoutConfig map[string]interface{} `json:"TimeoutConfig,omitempty" xml:"TimeoutConfig,omitempty"`
}

func (s UpdateJobRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateJobRequest) GoString() string {
	return s.String()
}

func (s *UpdateJobRequest) SetDescription(v string) *UpdateJobRequest {
	s.Description = &v
	return s
}

func (s *UpdateJobRequest) SetIotInstanceId(v string) *UpdateJobRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateJobRequest) SetJobId(v string) *UpdateJobRequest {
	s.JobId = &v
	return s
}

func (s *UpdateJobRequest) SetRolloutConfig(v map[string]interface{}) *UpdateJobRequest {
	s.RolloutConfig = v
	return s
}

func (s *UpdateJobRequest) SetTimeoutConfig(v map[string]interface{}) *UpdateJobRequest {
	s.TimeoutConfig = v
	return s
}

type UpdateJobShrinkRequest struct {
	Description         *string `json:"Description,omitempty" xml:"Description,omitempty"`
	IotInstanceId       *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	JobId               *string `json:"JobId,omitempty" xml:"JobId,omitempty"`
	RolloutConfigShrink *string `json:"RolloutConfig,omitempty" xml:"RolloutConfig,omitempty"`
	TimeoutConfigShrink *string `json:"TimeoutConfig,omitempty" xml:"TimeoutConfig,omitempty"`
}

func (s UpdateJobShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateJobShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateJobShrinkRequest) SetDescription(v string) *UpdateJobShrinkRequest {
	s.Description = &v
	return s
}

func (s *UpdateJobShrinkRequest) SetIotInstanceId(v string) *UpdateJobShrinkRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateJobShrinkRequest) SetJobId(v string) *UpdateJobShrinkRequest {
	s.JobId = &v
	return s
}

func (s *UpdateJobShrinkRequest) SetRolloutConfigShrink(v string) *UpdateJobShrinkRequest {
	s.RolloutConfigShrink = &v
	return s
}

func (s *UpdateJobShrinkRequest) SetTimeoutConfigShrink(v string) *UpdateJobShrinkRequest {
	s.TimeoutConfigShrink = &v
	return s
}

type UpdateJobResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateJobResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateJobResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateJobResponseBody) SetCode(v string) *UpdateJobResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateJobResponseBody) SetErrorMessage(v string) *UpdateJobResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateJobResponseBody) SetRequestId(v string) *UpdateJobResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateJobResponseBody) SetSuccess(v bool) *UpdateJobResponseBody {
	s.Success = &v
	return s
}

type UpdateJobResponse struct {
	Headers    map[string]*string     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateJobResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateJobResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateJobResponse) GoString() string {
	return s.String()
}

func (s *UpdateJobResponse) SetHeaders(v map[string]*string) *UpdateJobResponse {
	s.Headers = v
	return s
}

func (s *UpdateJobResponse) SetStatusCode(v int32) *UpdateJobResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateJobResponse) SetBody(v *UpdateJobResponseBody) *UpdateJobResponse {
	s.Body = v
	return s
}

type UpdateOTAModuleRequest struct {
	// The new alias of the OTA module. The alias must be 1 to 64 characters in length, and can contain letters, digits, periods(.), hyphens (-), and underscores (\_).
	AliasName *string `json:"AliasName,omitempty" xml:"AliasName,omitempty"`
	// The new description of the OTA module. The description can be up to 100 characters in length.
	Desc *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The name of the OTA module.
	ModuleName *string `json:"ModuleName,omitempty" xml:"ModuleName,omitempty"`
	// The **ProductKey** of the product to which the OTA module belongs.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
}

func (s UpdateOTAModuleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateOTAModuleRequest) GoString() string {
	return s.String()
}

func (s *UpdateOTAModuleRequest) SetAliasName(v string) *UpdateOTAModuleRequest {
	s.AliasName = &v
	return s
}

func (s *UpdateOTAModuleRequest) SetDesc(v string) *UpdateOTAModuleRequest {
	s.Desc = &v
	return s
}

func (s *UpdateOTAModuleRequest) SetIotInstanceId(v string) *UpdateOTAModuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateOTAModuleRequest) SetModuleName(v string) *UpdateOTAModuleRequest {
	s.ModuleName = &v
	return s
}

func (s *UpdateOTAModuleRequest) SetProductKey(v string) *UpdateOTAModuleRequest {
	s.ProductKey = &v
	return s
}

type UpdateOTAModuleResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateOTAModuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateOTAModuleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateOTAModuleResponseBody) SetCode(v string) *UpdateOTAModuleResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateOTAModuleResponseBody) SetErrorMessage(v string) *UpdateOTAModuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateOTAModuleResponseBody) SetRequestId(v string) *UpdateOTAModuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateOTAModuleResponseBody) SetSuccess(v bool) *UpdateOTAModuleResponseBody {
	s.Success = &v
	return s
}

type UpdateOTAModuleResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateOTAModuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateOTAModuleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateOTAModuleResponse) GoString() string {
	return s.String()
}

func (s *UpdateOTAModuleResponse) SetHeaders(v map[string]*string) *UpdateOTAModuleResponse {
	s.Headers = v
	return s
}

func (s *UpdateOTAModuleResponse) SetStatusCode(v int32) *UpdateOTAModuleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateOTAModuleResponse) SetBody(v *UpdateOTAModuleResponseBody) *UpdateOTAModuleResponse {
	s.Body = v
	return s
}

type UpdateParserRequest struct {
	Description   *string `json:"Description,omitempty" xml:"Description,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Name          *string `json:"Name,omitempty" xml:"Name,omitempty"`
	ParserId      *int64  `json:"ParserId,omitempty" xml:"ParserId,omitempty"`
}

func (s UpdateParserRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateParserRequest) GoString() string {
	return s.String()
}

func (s *UpdateParserRequest) SetDescription(v string) *UpdateParserRequest {
	s.Description = &v
	return s
}

func (s *UpdateParserRequest) SetIotInstanceId(v string) *UpdateParserRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateParserRequest) SetName(v string) *UpdateParserRequest {
	s.Name = &v
	return s
}

func (s *UpdateParserRequest) SetParserId(v int64) *UpdateParserRequest {
	s.ParserId = &v
	return s
}

type UpdateParserResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateParserResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateParserResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateParserResponseBody) SetCode(v string) *UpdateParserResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateParserResponseBody) SetErrorMessage(v string) *UpdateParserResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateParserResponseBody) SetRequestId(v string) *UpdateParserResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateParserResponseBody) SetSuccess(v bool) *UpdateParserResponseBody {
	s.Success = &v
	return s
}

type UpdateParserResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateParserResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateParserResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateParserResponse) GoString() string {
	return s.String()
}

func (s *UpdateParserResponse) SetHeaders(v map[string]*string) *UpdateParserResponse {
	s.Headers = v
	return s
}

func (s *UpdateParserResponse) SetStatusCode(v int32) *UpdateParserResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateParserResponse) SetBody(v *UpdateParserResponseBody) *UpdateParserResponse {
	s.Body = v
	return s
}

type UpdateParserDataSourceRequest struct {
	DataSourceId  *int64  `json:"DataSourceId,omitempty" xml:"DataSourceId,omitempty"`
	Description   *string `json:"Description,omitempty" xml:"Description,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Name          *string `json:"Name,omitempty" xml:"Name,omitempty"`
}

func (s UpdateParserDataSourceRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateParserDataSourceRequest) GoString() string {
	return s.String()
}

func (s *UpdateParserDataSourceRequest) SetDataSourceId(v int64) *UpdateParserDataSourceRequest {
	s.DataSourceId = &v
	return s
}

func (s *UpdateParserDataSourceRequest) SetDescription(v string) *UpdateParserDataSourceRequest {
	s.Description = &v
	return s
}

func (s *UpdateParserDataSourceRequest) SetIotInstanceId(v string) *UpdateParserDataSourceRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateParserDataSourceRequest) SetName(v string) *UpdateParserDataSourceRequest {
	s.Name = &v
	return s
}

type UpdateParserDataSourceResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateParserDataSourceResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateParserDataSourceResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateParserDataSourceResponseBody) SetCode(v string) *UpdateParserDataSourceResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateParserDataSourceResponseBody) SetErrorMessage(v string) *UpdateParserDataSourceResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateParserDataSourceResponseBody) SetRequestId(v string) *UpdateParserDataSourceResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateParserDataSourceResponseBody) SetSuccess(v bool) *UpdateParserDataSourceResponseBody {
	s.Success = &v
	return s
}

type UpdateParserDataSourceResponse struct {
	Headers    map[string]*string                  `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                              `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateParserDataSourceResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateParserDataSourceResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateParserDataSourceResponse) GoString() string {
	return s.String()
}

func (s *UpdateParserDataSourceResponse) SetHeaders(v map[string]*string) *UpdateParserDataSourceResponse {
	s.Headers = v
	return s
}

func (s *UpdateParserDataSourceResponse) SetStatusCode(v int32) *UpdateParserDataSourceResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateParserDataSourceResponse) SetBody(v *UpdateParserDataSourceResponseBody) *UpdateParserDataSourceResponse {
	s.Body = v
	return s
}

type UpdateProductRequest struct {
	// The description of the product. The description must be 1 to 100 characters in length.
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// The ID of the instance. You can view the ID of the instance on the **Overview** page in the IoT Platform console.
	//
	//
	//
	// **Important**
	//
	// *   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.****
	// *   If no **Overview** page or **ID** is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product. A ProductKey is a GUID that is issued by IoT Platform to the product.****
	//
	// You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current Alibaba Cloud account.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The new product name that you want to use.
	//
	// The name must be 4 to 30 characters in length, and can contain letters, digits, and underscores (\_).
	//
	//
	// **Important** Each product name must be unique within the current Alibaba Cloud account.
	ProductName *string `json:"ProductName,omitempty" xml:"ProductName,omitempty"`
}

func (s UpdateProductRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateProductRequest) GoString() string {
	return s.String()
}

func (s *UpdateProductRequest) SetDescription(v string) *UpdateProductRequest {
	s.Description = &v
	return s
}

func (s *UpdateProductRequest) SetIotInstanceId(v string) *UpdateProductRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateProductRequest) SetProductKey(v string) *UpdateProductRequest {
	s.ProductKey = &v
	return s
}

func (s *UpdateProductRequest) SetProductName(v string) *UpdateProductRequest {
	s.ProductName = &v
	return s
}

type UpdateProductResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful. Valid values:
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateProductResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateProductResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateProductResponseBody) SetCode(v string) *UpdateProductResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateProductResponseBody) SetErrorMessage(v string) *UpdateProductResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateProductResponseBody) SetRequestId(v string) *UpdateProductResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateProductResponseBody) SetSuccess(v bool) *UpdateProductResponseBody {
	s.Success = &v
	return s
}

type UpdateProductResponse struct {
	Headers    map[string]*string         `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                     `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateProductResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateProductResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateProductResponse) GoString() string {
	return s.String()
}

func (s *UpdateProductResponse) SetHeaders(v map[string]*string) *UpdateProductResponse {
	s.Headers = v
	return s
}

func (s *UpdateProductResponse) SetStatusCode(v int32) *UpdateProductResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateProductResponse) SetBody(v *UpdateProductResponseBody) *UpdateProductResponse {
	s.Body = v
	return s
}

type UpdateProductFilterConfigRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product. A ProductKey is a GUID that is issued by IoT Platform to a product.
	//
	// You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// Specifies whether to deduplicate messages based on the submission time of each property. Valid values:
	//
	// *   **true**: deduplicates property messages that have the same timestamp.
	// *   **false**: does not deduplicate messages based on timestamps.
	PropertyTimestampFilter *bool `json:"PropertyTimestampFilter,omitempty" xml:"PropertyTimestampFilter,omitempty"`
	// Specifies whether to deduplicate messages based on the value of each property. Valid values:
	//
	// *   **true**: deduplicates property messages that have the same property value.
	// *   **false**: does not deduplicate messages based on property values.
	PropertyValueFilter *bool `json:"PropertyValueFilter,omitempty" xml:"PropertyValueFilter,omitempty"`
}

func (s UpdateProductFilterConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateProductFilterConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateProductFilterConfigRequest) SetIotInstanceId(v string) *UpdateProductFilterConfigRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateProductFilterConfigRequest) SetProductKey(v string) *UpdateProductFilterConfigRequest {
	s.ProductKey = &v
	return s
}

func (s *UpdateProductFilterConfigRequest) SetPropertyTimestampFilter(v bool) *UpdateProductFilterConfigRequest {
	s.PropertyTimestampFilter = &v
	return s
}

func (s *UpdateProductFilterConfigRequest) SetPropertyValueFilter(v bool) *UpdateProductFilterConfigRequest {
	s.PropertyValueFilter = &v
	return s
}

type UpdateProductFilterConfigResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateProductFilterConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateProductFilterConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateProductFilterConfigResponseBody) SetCode(v string) *UpdateProductFilterConfigResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateProductFilterConfigResponseBody) SetErrorMessage(v string) *UpdateProductFilterConfigResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateProductFilterConfigResponseBody) SetRequestId(v string) *UpdateProductFilterConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateProductFilterConfigResponseBody) SetSuccess(v bool) *UpdateProductFilterConfigResponseBody {
	s.Success = &v
	return s
}

type UpdateProductFilterConfigResponse struct {
	Headers    map[string]*string                     `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                 `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateProductFilterConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateProductFilterConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateProductFilterConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateProductFilterConfigResponse) SetHeaders(v map[string]*string) *UpdateProductFilterConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateProductFilterConfigResponse) SetStatusCode(v int32) *UpdateProductFilterConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateProductFilterConfigResponse) SetBody(v *UpdateProductFilterConfigResponseBody) *UpdateProductFilterConfigResponse {
	s.Body = v
	return s
}

type UpdateProductTagsRequest struct {
	// The ID of the instance. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	//
	// >*   If your instance has an ID, you must specify the ID for this parameter. Otherwise, the call fails.
	// >*   If no **Overview** page or ID is generated for your instance, you do not need to configure this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The ProductKey of the product. A ProductKey is a GUID that is issued by IoT Platform to a product. You can use the IoT Platform console or call the [QueryProductList](~~69271~~) operation to view the information about all products within the current account.
	ProductKey *string                               `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	ProductTag []*UpdateProductTagsRequestProductTag `json:"ProductTag,omitempty" xml:"ProductTag,omitempty" type:"Repeated"`
}

func (s UpdateProductTagsRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateProductTagsRequest) GoString() string {
	return s.String()
}

func (s *UpdateProductTagsRequest) SetIotInstanceId(v string) *UpdateProductTagsRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateProductTagsRequest) SetProductKey(v string) *UpdateProductTagsRequest {
	s.ProductKey = &v
	return s
}

func (s *UpdateProductTagsRequest) SetProductTag(v []*UpdateProductTagsRequestProductTag) *UpdateProductTagsRequest {
	s.ProductTag = v
	return s
}

type UpdateProductTagsRequestProductTag struct {
	// The keys of the product tags. Each key must be 1 to 30 characters in length, and can contain letters, digits, and periods (.).
	//
	// >  Each tag key that you specify must already exist. Each tag value that you specify must be unique.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The new values of the product tags. Each tag value must be 1 to 128 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-).
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s UpdateProductTagsRequestProductTag) String() string {
	return tea.Prettify(s)
}

func (s UpdateProductTagsRequestProductTag) GoString() string {
	return s.String()
}

func (s *UpdateProductTagsRequestProductTag) SetTagKey(v string) *UpdateProductTagsRequestProductTag {
	s.TagKey = &v
	return s
}

func (s *UpdateProductTagsRequestProductTag) SetTagValue(v string) *UpdateProductTagsRequestProductTag {
	s.TagValue = &v
	return s
}

type UpdateProductTagsResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the request fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The invalid product tags returned if the call fails. The details are included in the **ProductTag** parameter.
	InvalidProductTags *UpdateProductTagsResponseBodyInvalidProductTags `json:"InvalidProductTags,omitempty" xml:"InvalidProductTags,omitempty" type:"Struct"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateProductTagsResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateProductTagsResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateProductTagsResponseBody) SetCode(v string) *UpdateProductTagsResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateProductTagsResponseBody) SetErrorMessage(v string) *UpdateProductTagsResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateProductTagsResponseBody) SetInvalidProductTags(v *UpdateProductTagsResponseBodyInvalidProductTags) *UpdateProductTagsResponseBody {
	s.InvalidProductTags = v
	return s
}

func (s *UpdateProductTagsResponseBody) SetRequestId(v string) *UpdateProductTagsResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateProductTagsResponseBody) SetSuccess(v bool) *UpdateProductTagsResponseBody {
	s.Success = &v
	return s
}

type UpdateProductTagsResponseBodyInvalidProductTags struct {
	ProductTag []*UpdateProductTagsResponseBodyInvalidProductTagsProductTag `json:"ProductTag,omitempty" xml:"ProductTag,omitempty" type:"Repeated"`
}

func (s UpdateProductTagsResponseBodyInvalidProductTags) String() string {
	return tea.Prettify(s)
}

func (s UpdateProductTagsResponseBodyInvalidProductTags) GoString() string {
	return s.String()
}

func (s *UpdateProductTagsResponseBodyInvalidProductTags) SetProductTag(v []*UpdateProductTagsResponseBodyInvalidProductTagsProductTag) *UpdateProductTagsResponseBodyInvalidProductTags {
	s.ProductTag = v
	return s
}

type UpdateProductTagsResponseBodyInvalidProductTagsProductTag struct {
	// The key of the tag.
	TagKey *string `json:"TagKey,omitempty" xml:"TagKey,omitempty"`
	// The value of the tag.
	TagValue *string `json:"TagValue,omitempty" xml:"TagValue,omitempty"`
}

func (s UpdateProductTagsResponseBodyInvalidProductTagsProductTag) String() string {
	return tea.Prettify(s)
}

func (s UpdateProductTagsResponseBodyInvalidProductTagsProductTag) GoString() string {
	return s.String()
}

func (s *UpdateProductTagsResponseBodyInvalidProductTagsProductTag) SetTagKey(v string) *UpdateProductTagsResponseBodyInvalidProductTagsProductTag {
	s.TagKey = &v
	return s
}

func (s *UpdateProductTagsResponseBodyInvalidProductTagsProductTag) SetTagValue(v string) *UpdateProductTagsResponseBodyInvalidProductTagsProductTag {
	s.TagValue = &v
	return s
}

type UpdateProductTagsResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateProductTagsResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateProductTagsResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateProductTagsResponse) GoString() string {
	return s.String()
}

func (s *UpdateProductTagsResponse) SetHeaders(v map[string]*string) *UpdateProductTagsResponse {
	s.Headers = v
	return s
}

func (s *UpdateProductTagsResponse) SetStatusCode(v int32) *UpdateProductTagsResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateProductTagsResponse) SetBody(v *UpdateProductTagsResponseBody) *UpdateProductTagsResponse {
	s.Body = v
	return s
}

type UpdateProductTopicRequest struct {
	Codec *string `json:"Codec,omitempty" xml:"Codec,omitempty"`
	// The description of the topic category. The description must be 1 to 100 characters in length.
	Desc                 *string `json:"Desc,omitempty" xml:"Desc,omitempty"`
	EnableProxySubscribe *bool   `json:"EnableProxySubscribe,omitempty" xml:"EnableProxySubscribe,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The operation permissions of the device on the topic category. Valid values:
	//
	// *   **SUB**: Subscribe.
	// *   **PUB**: Publish.
	// *   **ALL**: Publish and Subscribe.
	Operation *string `json:"Operation,omitempty" xml:"Operation,omitempty"`
	// The ID of the topic category that you want to modify.
	TopicId *string `json:"TopicId,omitempty" xml:"TopicId,omitempty"`
	// The name of the user-defined category level that you want to set. By default, a topic category includes the following levels: \_productkey\_ and \_devicename\_. Separate the two levels with slashes (/). Format of a topic category: `productKey/deviceName/topicShortName`.
	//
	// >  Each level can contain letters, digits, and underscores (\_), and cannot be empty.
	TopicShortName *string `json:"TopicShortName,omitempty" xml:"TopicShortName,omitempty"`
}

func (s UpdateProductTopicRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateProductTopicRequest) GoString() string {
	return s.String()
}

func (s *UpdateProductTopicRequest) SetCodec(v string) *UpdateProductTopicRequest {
	s.Codec = &v
	return s
}

func (s *UpdateProductTopicRequest) SetDesc(v string) *UpdateProductTopicRequest {
	s.Desc = &v
	return s
}

func (s *UpdateProductTopicRequest) SetEnableProxySubscribe(v bool) *UpdateProductTopicRequest {
	s.EnableProxySubscribe = &v
	return s
}

func (s *UpdateProductTopicRequest) SetIotInstanceId(v string) *UpdateProductTopicRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateProductTopicRequest) SetOperation(v string) *UpdateProductTopicRequest {
	s.Operation = &v
	return s
}

func (s *UpdateProductTopicRequest) SetTopicId(v string) *UpdateProductTopicRequest {
	s.TopicId = &v
	return s
}

func (s *UpdateProductTopicRequest) SetTopicShortName(v string) *UpdateProductTopicRequest {
	s.TopicShortName = &v
	return s
}

type UpdateProductTopicResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateProductTopicResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateProductTopicResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateProductTopicResponseBody) SetCode(v string) *UpdateProductTopicResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateProductTopicResponseBody) SetErrorMessage(v string) *UpdateProductTopicResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateProductTopicResponseBody) SetRequestId(v string) *UpdateProductTopicResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateProductTopicResponseBody) SetSuccess(v bool) *UpdateProductTopicResponseBody {
	s.Success = &v
	return s
}

type UpdateProductTopicResponse struct {
	Headers    map[string]*string              `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                          `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateProductTopicResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateProductTopicResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateProductTopicResponse) GoString() string {
	return s.String()
}

func (s *UpdateProductTopicResponse) SetHeaders(v map[string]*string) *UpdateProductTopicResponse {
	s.Headers = v
	return s
}

func (s *UpdateProductTopicResponse) SetStatusCode(v int32) *UpdateProductTopicResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateProductTopicResponse) SetBody(v *UpdateProductTopicResponseBody) *UpdateProductTopicResponse {
	s.Body = v
	return s
}

type UpdateRuleRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The name of the rule. The rule name must be 1 to 30 characters in length, and can contain letters, digits, underscores (\_), and hyphens (-).
	Name *string `json:"Name,omitempty" xml:"Name,omitempty"`
	// The **ProductKey** of the product to which the rule applies.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The description of the rule. The description can be up to 100 characters in length.
	RuleDesc *string `json:"RuleDesc,omitempty" xml:"RuleDesc,omitempty"`
	// The ID of the rule that you want to modify. You can log on to the IoT Platform console and choose **Rules** > **Data Forwarding** to view the rule ID. You can also call the [ListRule](~~69486~~) operation and view the rule ID in the response.
	RuleId *int64 `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	// The SQL SELECT statement to be executed. For more information, see [SQL expressions](~~30554~~).
	//
	// >  Specify the content that follows the SELECT keyword for this parameter. For example, if the SELECT statement is `SELECT a,b,c`, specify `a,b,c` for this parameter.
	Select *string `json:"Select,omitempty" xml:"Select,omitempty"`
	// The topic to which this rule is applied. Syntax: `${deviceName}/topicShortName`. `${deviceName}` specifies the name of the device, and `topicShortName` specifies the custom name of the topic.
	//
	// *   Basic communication topics or Thing Specification Language (TSL)-based communication topics. Syntax: `${deviceName}/topicShortName`. You can replace `${deviceName}` with the `+` wildcard. The wildcard indicates that the topic applies to all devices under the product. Valid values of `topicShortName`:
	//
	//     *   `/thing/event/property/post`: submits the property data of a device.
	//
	//     *   `/thing/event/${tsl.event.identifier}/post`: submits the event data of a device. `${tsl.event.identifier}` specifies the identifier of an event in the TSL model.
	//
	//     *   `/thing/lifecycle`: submits device lifecycle changes.
	//
	//     *   `/thing/downlink/reply/message`: sends a response to a request from IoT Platform.
	//
	//     *   `/thing/list/found`: submits the data when a gateway detects a new sub-device.
	//
	//     *   `/thing/topo/lifecycle`: submits device topology changes.
	//
	//     *   `/thing/event/property/history/post`: submits historical property data of a device.
	//
	//     *   `/thing/event/${tsl.event.identifier}/post`: submits the historical event data of a device. `${tsl.event.identifier}` specifies the identifier of an event in the TSL.
	//
	//     *   `/ota/upgrade`: submits OTA update statuses.
	//
	//     *   `/ota/version/post`: submits OTA module versions.
	//
	//     *   `/thing/deviceinfo/update`: submits device tag changes.
	//
	//     *   `/edge/driver/${driver_id}/point_post`: submits pass-through data from Link IoT Edge. `${driver_id}` specifies the ID of the driver that a device uses to access Link IoT Edge.
	//
	//         `${packageId}/${jobId}/ota/job/status`: submits the statuses of OTA update batches. This topic is a basic communication topic. `${packageId}` specifies the ID of the update package. `${jobId}` specifies the ID of the update batch.
	//
	// *   Custom topics. Example: `${deviceName}/user/get`.
	//
	//     You can call the [QueryProductTopic](~~69647~~) operation to view all custom topics of the product.
	//
	//     When you specify a custom topic, you can use the `+` and `#` wildcards.
	//
	//     *   You can replace `${deviceName}` with the `+` wildcard. The wildcard indicates that the topic applies to all devices under the product.
	//
	//     *   You can replace the fields that follow ${deviceName} with `/user/#`. The `#` wildcard indicates that the topic applies whatever values are specified for the fields that follow`/user`.
	//
	//         For more information about how to use wildcards, see [Wildcards in topics](~~85539~~).
	//
	// *   Topic that is used to submit device status changes: `${deviceName}`.
	//
	//     You can use the `+` wildcard. In this case, the status changes of all devices under the product are submitted.
	ShortTopic *string `json:"ShortTopic,omitempty" xml:"ShortTopic,omitempty"`
	// The complete topic to which the rule applies.
	//
	// If you specify this parameter, you do not need to specify the **ProductKey**, **ShortTopic**, and **TopicType** parameters.
	Topic *string `json:"Topic,omitempty" xml:"Topic,omitempty"`
	// *   **0**: The topic is a basic communication topic or TSL-based communication topic.****
	// *   **1**: The topic is a custom topic.
	// *   **2**: The topic is used to submit device status changes. Syntax: `/as/mqtt/status/${productKey}/${deviceName}`.
	TopicType *int32 `json:"TopicType,omitempty" xml:"TopicType,omitempty"`
	// The condition that is used to trigger the rule. For more information, see [SQL expressions](~~30554~~).
	//
	// >  Specify the content that follows the WHERE keyword for this parameter. For example, if the WHERE statement is `WHERE a>10`, specify `a>10` for this parameter.
	Where *string `json:"Where,omitempty" xml:"Where,omitempty"`
}

func (s UpdateRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateRuleRequest) GoString() string {
	return s.String()
}

func (s *UpdateRuleRequest) SetIotInstanceId(v string) *UpdateRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateRuleRequest) SetName(v string) *UpdateRuleRequest {
	s.Name = &v
	return s
}

func (s *UpdateRuleRequest) SetProductKey(v string) *UpdateRuleRequest {
	s.ProductKey = &v
	return s
}

func (s *UpdateRuleRequest) SetRuleDesc(v string) *UpdateRuleRequest {
	s.RuleDesc = &v
	return s
}

func (s *UpdateRuleRequest) SetRuleId(v int64) *UpdateRuleRequest {
	s.RuleId = &v
	return s
}

func (s *UpdateRuleRequest) SetSelect(v string) *UpdateRuleRequest {
	s.Select = &v
	return s
}

func (s *UpdateRuleRequest) SetShortTopic(v string) *UpdateRuleRequest {
	s.ShortTopic = &v
	return s
}

func (s *UpdateRuleRequest) SetTopic(v string) *UpdateRuleRequest {
	s.Topic = &v
	return s
}

func (s *UpdateRuleRequest) SetTopicType(v int32) *UpdateRuleRequest {
	s.TopicType = &v
	return s
}

func (s *UpdateRuleRequest) SetWhere(v string) *UpdateRuleRequest {
	s.Where = &v
	return s
}

type UpdateRuleResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateRuleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateRuleResponseBody) SetCode(v string) *UpdateRuleResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateRuleResponseBody) SetErrorMessage(v string) *UpdateRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateRuleResponseBody) SetRequestId(v string) *UpdateRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateRuleResponseBody) SetSuccess(v bool) *UpdateRuleResponseBody {
	s.Success = &v
	return s
}

type UpdateRuleResponse struct {
	Headers    map[string]*string      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateRuleResponse) GoString() string {
	return s.String()
}

func (s *UpdateRuleResponse) SetHeaders(v map[string]*string) *UpdateRuleResponse {
	s.Headers = v
	return s
}

func (s *UpdateRuleResponse) SetStatusCode(v int32) *UpdateRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateRuleResponse) SetBody(v *UpdateRuleResponseBody) *UpdateRuleResponse {
	s.Body = v
	return s
}

type UpdateRuleActionRequest struct {
	// The ID of the rule action to be modified.
	//
	// After you call the [CreateRuleAction](~~69586~~) operation to create a rule action, the rule action ID is returned. You can call the [ListRuleActions](~~69517~~) operation to view the rule action ID.
	ActionId *int64 `json:"ActionId,omitempty" xml:"ActionId,omitempty"`
	// The configurations of the rule action. The configurations for different rule action types are different. For more information about the configurations for different rule action types, see [CreateRuleAction](~~69586~~).
	Configuration *string `json:"Configuration,omitempty" xml:"Configuration,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The type of the rule action. Valid values:
	//
	// *   **MNS**: forwards topic data that is processed by the rules engine to MNS.
	// *   **FC**: forwards topic data that is processed by the rules engine to Function Compute for event computing.
	// *   **REPUBLISH**: forwards topic data that is processed by the rules engine to another IoT Platform topic.
	// *   **AMQP**: forwards data to an AMQP consumer group.
	// *   **OTS**: forwards topic data that is processed by the rules engine to Tablestore for NoSQL data storage.
	//
	// > *   If you set the **DataType** parameter to **BINARY**, rules are created in the binary format. These rules cannot be used to forward data to Tablestore.
	// >*   Destination Alibaba Cloud services that are supported by the rules engine vary based on regions. For more information about the regions and destination cloud services that are supported by the rules engine, see [Regions and zones](~~85669~~).
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateRuleActionRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateRuleActionRequest) GoString() string {
	return s.String()
}

func (s *UpdateRuleActionRequest) SetActionId(v int64) *UpdateRuleActionRequest {
	s.ActionId = &v
	return s
}

func (s *UpdateRuleActionRequest) SetConfiguration(v string) *UpdateRuleActionRequest {
	s.Configuration = &v
	return s
}

func (s *UpdateRuleActionRequest) SetIotInstanceId(v string) *UpdateRuleActionRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateRuleActionRequest) SetType(v string) *UpdateRuleActionRequest {
	s.Type = &v
	return s
}

type UpdateRuleActionResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateRuleActionResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateRuleActionResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateRuleActionResponseBody) SetCode(v string) *UpdateRuleActionResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateRuleActionResponseBody) SetErrorMessage(v string) *UpdateRuleActionResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateRuleActionResponseBody) SetRequestId(v string) *UpdateRuleActionResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateRuleActionResponseBody) SetSuccess(v bool) *UpdateRuleActionResponseBody {
	s.Success = &v
	return s
}

type UpdateRuleActionResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateRuleActionResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateRuleActionResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateRuleActionResponse) GoString() string {
	return s.String()
}

func (s *UpdateRuleActionResponse) SetHeaders(v map[string]*string) *UpdateRuleActionResponse {
	s.Headers = v
	return s
}

func (s *UpdateRuleActionResponse) SetStatusCode(v int32) *UpdateRuleActionResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateRuleActionResponse) SetBody(v *UpdateRuleActionResponseBody) *UpdateRuleActionResponse {
	s.Body = v
	return s
}

type UpdateSceneRuleRequest struct {
	IotInstanceId   *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	RuleContent     *string `json:"RuleContent,omitempty" xml:"RuleContent,omitempty"`
	RuleDescription *string `json:"RuleDescription,omitempty" xml:"RuleDescription,omitempty"`
	RuleId          *string `json:"RuleId,omitempty" xml:"RuleId,omitempty"`
	RuleName        *string `json:"RuleName,omitempty" xml:"RuleName,omitempty"`
}

func (s UpdateSceneRuleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSceneRuleRequest) GoString() string {
	return s.String()
}

func (s *UpdateSceneRuleRequest) SetIotInstanceId(v string) *UpdateSceneRuleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateSceneRuleRequest) SetRuleContent(v string) *UpdateSceneRuleRequest {
	s.RuleContent = &v
	return s
}

func (s *UpdateSceneRuleRequest) SetRuleDescription(v string) *UpdateSceneRuleRequest {
	s.RuleDescription = &v
	return s
}

func (s *UpdateSceneRuleRequest) SetRuleId(v string) *UpdateSceneRuleRequest {
	s.RuleId = &v
	return s
}

func (s *UpdateSceneRuleRequest) SetRuleName(v string) *UpdateSceneRuleRequest {
	s.RuleName = &v
	return s
}

type UpdateSceneRuleResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateSceneRuleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateSceneRuleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateSceneRuleResponseBody) SetCode(v string) *UpdateSceneRuleResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateSceneRuleResponseBody) SetErrorMessage(v string) *UpdateSceneRuleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateSceneRuleResponseBody) SetRequestId(v string) *UpdateSceneRuleResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateSceneRuleResponseBody) SetSuccess(v bool) *UpdateSceneRuleResponseBody {
	s.Success = &v
	return s
}

type UpdateSceneRuleResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateSceneRuleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateSceneRuleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSceneRuleResponse) GoString() string {
	return s.String()
}

func (s *UpdateSceneRuleResponse) SetHeaders(v map[string]*string) *UpdateSceneRuleResponse {
	s.Headers = v
	return s
}

func (s *UpdateSceneRuleResponse) SetStatusCode(v int32) *UpdateSceneRuleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateSceneRuleResponse) SetBody(v *UpdateSceneRuleResponseBody) *UpdateSceneRuleResponse {
	s.Body = v
	return s
}

type UpdateSchedulePeriodRequest struct {
	Description      *string `json:"Description,omitempty" xml:"Description,omitempty"`
	EndTime          *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	IotInstanceId    *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	PeriodCode       *string `json:"PeriodCode,omitempty" xml:"PeriodCode,omitempty"`
	SoundCodeContent *string `json:"SoundCodeContent,omitempty" xml:"SoundCodeContent,omitempty"`
	StartTime        *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
}

func (s UpdateSchedulePeriodRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSchedulePeriodRequest) GoString() string {
	return s.String()
}

func (s *UpdateSchedulePeriodRequest) SetDescription(v string) *UpdateSchedulePeriodRequest {
	s.Description = &v
	return s
}

func (s *UpdateSchedulePeriodRequest) SetEndTime(v string) *UpdateSchedulePeriodRequest {
	s.EndTime = &v
	return s
}

func (s *UpdateSchedulePeriodRequest) SetIotInstanceId(v string) *UpdateSchedulePeriodRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateSchedulePeriodRequest) SetPeriodCode(v string) *UpdateSchedulePeriodRequest {
	s.PeriodCode = &v
	return s
}

func (s *UpdateSchedulePeriodRequest) SetSoundCodeContent(v string) *UpdateSchedulePeriodRequest {
	s.SoundCodeContent = &v
	return s
}

func (s *UpdateSchedulePeriodRequest) SetStartTime(v string) *UpdateSchedulePeriodRequest {
	s.StartTime = &v
	return s
}

type UpdateSchedulePeriodResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateSchedulePeriodResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateSchedulePeriodResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateSchedulePeriodResponseBody) SetCode(v string) *UpdateSchedulePeriodResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateSchedulePeriodResponseBody) SetErrorMessage(v string) *UpdateSchedulePeriodResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateSchedulePeriodResponseBody) SetRequestId(v string) *UpdateSchedulePeriodResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateSchedulePeriodResponseBody) SetSuccess(v bool) *UpdateSchedulePeriodResponseBody {
	s.Success = &v
	return s
}

type UpdateSchedulePeriodResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateSchedulePeriodResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateSchedulePeriodResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSchedulePeriodResponse) GoString() string {
	return s.String()
}

func (s *UpdateSchedulePeriodResponse) SetHeaders(v map[string]*string) *UpdateSchedulePeriodResponse {
	s.Headers = v
	return s
}

func (s *UpdateSchedulePeriodResponse) SetStatusCode(v int32) *UpdateSchedulePeriodResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateSchedulePeriodResponse) SetBody(v *UpdateSchedulePeriodResponseBody) *UpdateSchedulePeriodResponse {
	s.Body = v
	return s
}

type UpdateSoundCodeRequest struct {
	Duration         *int32  `json:"Duration,omitempty" xml:"Duration,omitempty"`
	IotInstanceId    *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Name             *string `json:"Name,omitempty" xml:"Name,omitempty"`
	SoundCode        *string `json:"SoundCode,omitempty" xml:"SoundCode,omitempty"`
	SoundCodeContent *string `json:"SoundCodeContent,omitempty" xml:"SoundCodeContent,omitempty"`
}

func (s UpdateSoundCodeRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSoundCodeRequest) GoString() string {
	return s.String()
}

func (s *UpdateSoundCodeRequest) SetDuration(v int32) *UpdateSoundCodeRequest {
	s.Duration = &v
	return s
}

func (s *UpdateSoundCodeRequest) SetIotInstanceId(v string) *UpdateSoundCodeRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateSoundCodeRequest) SetName(v string) *UpdateSoundCodeRequest {
	s.Name = &v
	return s
}

func (s *UpdateSoundCodeRequest) SetSoundCode(v string) *UpdateSoundCodeRequest {
	s.SoundCode = &v
	return s
}

func (s *UpdateSoundCodeRequest) SetSoundCodeContent(v string) *UpdateSoundCodeRequest {
	s.SoundCodeContent = &v
	return s
}

type UpdateSoundCodeResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateSoundCodeResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateSoundCodeResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateSoundCodeResponseBody) SetCode(v string) *UpdateSoundCodeResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateSoundCodeResponseBody) SetErrorMessage(v string) *UpdateSoundCodeResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateSoundCodeResponseBody) SetRequestId(v string) *UpdateSoundCodeResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateSoundCodeResponseBody) SetSuccess(v bool) *UpdateSoundCodeResponseBody {
	s.Success = &v
	return s
}

type UpdateSoundCodeResponse struct {
	Headers    map[string]*string           `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                       `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateSoundCodeResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateSoundCodeResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSoundCodeResponse) GoString() string {
	return s.String()
}

func (s *UpdateSoundCodeResponse) SetHeaders(v map[string]*string) *UpdateSoundCodeResponse {
	s.Headers = v
	return s
}

func (s *UpdateSoundCodeResponse) SetStatusCode(v int32) *UpdateSoundCodeResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateSoundCodeResponse) SetBody(v *UpdateSoundCodeResponseBody) *UpdateSoundCodeResponse {
	s.Body = v
	return s
}

type UpdateSoundCodeLabelRequest struct {
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Label         *string `json:"Label,omitempty" xml:"Label,omitempty"`
	SoundCode     *string `json:"SoundCode,omitempty" xml:"SoundCode,omitempty"`
}

func (s UpdateSoundCodeLabelRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSoundCodeLabelRequest) GoString() string {
	return s.String()
}

func (s *UpdateSoundCodeLabelRequest) SetIotInstanceId(v string) *UpdateSoundCodeLabelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateSoundCodeLabelRequest) SetLabel(v string) *UpdateSoundCodeLabelRequest {
	s.Label = &v
	return s
}

func (s *UpdateSoundCodeLabelRequest) SetSoundCode(v string) *UpdateSoundCodeLabelRequest {
	s.SoundCode = &v
	return s
}

type UpdateSoundCodeLabelResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateSoundCodeLabelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateSoundCodeLabelResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateSoundCodeLabelResponseBody) SetCode(v string) *UpdateSoundCodeLabelResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateSoundCodeLabelResponseBody) SetErrorMessage(v string) *UpdateSoundCodeLabelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateSoundCodeLabelResponseBody) SetRequestId(v string) *UpdateSoundCodeLabelResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateSoundCodeLabelResponseBody) SetSuccess(v bool) *UpdateSoundCodeLabelResponseBody {
	s.Success = &v
	return s
}

type UpdateSoundCodeLabelResponse struct {
	Headers    map[string]*string                `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                            `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateSoundCodeLabelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateSoundCodeLabelResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSoundCodeLabelResponse) GoString() string {
	return s.String()
}

func (s *UpdateSoundCodeLabelResponse) SetHeaders(v map[string]*string) *UpdateSoundCodeLabelResponse {
	s.Headers = v
	return s
}

func (s *UpdateSoundCodeLabelResponse) SetStatusCode(v int32) *UpdateSoundCodeLabelResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateSoundCodeLabelResponse) SetBody(v *UpdateSoundCodeLabelResponseBody) *UpdateSoundCodeLabelResponse {
	s.Body = v
	return s
}

type UpdateSoundCodeScheduleRequest struct {
	Description   *string `json:"Description,omitempty" xml:"Description,omitempty"`
	EndDate       *string `json:"EndDate,omitempty" xml:"EndDate,omitempty"`
	EndTime       *string `json:"EndTime,omitempty" xml:"EndTime,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Name          *string `json:"Name,omitempty" xml:"Name,omitempty"`
	ScheduleCode  *string `json:"ScheduleCode,omitempty" xml:"ScheduleCode,omitempty"`
	StartDate     *string `json:"StartDate,omitempty" xml:"StartDate,omitempty"`
	StartTime     *string `json:"StartTime,omitempty" xml:"StartTime,omitempty"`
	Status        *string `json:"Status,omitempty" xml:"Status,omitempty"`
}

func (s UpdateSoundCodeScheduleRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSoundCodeScheduleRequest) GoString() string {
	return s.String()
}

func (s *UpdateSoundCodeScheduleRequest) SetDescription(v string) *UpdateSoundCodeScheduleRequest {
	s.Description = &v
	return s
}

func (s *UpdateSoundCodeScheduleRequest) SetEndDate(v string) *UpdateSoundCodeScheduleRequest {
	s.EndDate = &v
	return s
}

func (s *UpdateSoundCodeScheduleRequest) SetEndTime(v string) *UpdateSoundCodeScheduleRequest {
	s.EndTime = &v
	return s
}

func (s *UpdateSoundCodeScheduleRequest) SetIotInstanceId(v string) *UpdateSoundCodeScheduleRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateSoundCodeScheduleRequest) SetName(v string) *UpdateSoundCodeScheduleRequest {
	s.Name = &v
	return s
}

func (s *UpdateSoundCodeScheduleRequest) SetScheduleCode(v string) *UpdateSoundCodeScheduleRequest {
	s.ScheduleCode = &v
	return s
}

func (s *UpdateSoundCodeScheduleRequest) SetStartDate(v string) *UpdateSoundCodeScheduleRequest {
	s.StartDate = &v
	return s
}

func (s *UpdateSoundCodeScheduleRequest) SetStartTime(v string) *UpdateSoundCodeScheduleRequest {
	s.StartTime = &v
	return s
}

func (s *UpdateSoundCodeScheduleRequest) SetStatus(v string) *UpdateSoundCodeScheduleRequest {
	s.Status = &v
	return s
}

type UpdateSoundCodeScheduleResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateSoundCodeScheduleResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateSoundCodeScheduleResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateSoundCodeScheduleResponseBody) SetCode(v string) *UpdateSoundCodeScheduleResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateSoundCodeScheduleResponseBody) SetErrorMessage(v string) *UpdateSoundCodeScheduleResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateSoundCodeScheduleResponseBody) SetRequestId(v string) *UpdateSoundCodeScheduleResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateSoundCodeScheduleResponseBody) SetSuccess(v bool) *UpdateSoundCodeScheduleResponseBody {
	s.Success = &v
	return s
}

type UpdateSoundCodeScheduleResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateSoundCodeScheduleResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateSoundCodeScheduleResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSoundCodeScheduleResponse) GoString() string {
	return s.String()
}

func (s *UpdateSoundCodeScheduleResponse) SetHeaders(v map[string]*string) *UpdateSoundCodeScheduleResponse {
	s.Headers = v
	return s
}

func (s *UpdateSoundCodeScheduleResponse) SetStatusCode(v int32) *UpdateSoundCodeScheduleResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateSoundCodeScheduleResponse) SetBody(v *UpdateSoundCodeScheduleResponseBody) *UpdateSoundCodeScheduleResponse {
	s.Body = v
	return s
}

type UpdateSpeechRequest struct {
	EnableSoundCode *bool                  `json:"EnableSoundCode,omitempty" xml:"EnableSoundCode,omitempty"`
	IotInstanceId   *string                `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProjectCode     *string                `json:"ProjectCode,omitempty" xml:"ProjectCode,omitempty"`
	SoundCodeConfig map[string]interface{} `json:"SoundCodeConfig,omitempty" xml:"SoundCodeConfig,omitempty"`
	SpeechCode      *string                `json:"SpeechCode,omitempty" xml:"SpeechCode,omitempty"`
	SpeechRate      *int32                 `json:"SpeechRate,omitempty" xml:"SpeechRate,omitempty"`
	Voice           *string                `json:"Voice,omitempty" xml:"Voice,omitempty"`
	Volume          *int32                 `json:"Volume,omitempty" xml:"Volume,omitempty"`
}

func (s UpdateSpeechRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSpeechRequest) GoString() string {
	return s.String()
}

func (s *UpdateSpeechRequest) SetEnableSoundCode(v bool) *UpdateSpeechRequest {
	s.EnableSoundCode = &v
	return s
}

func (s *UpdateSpeechRequest) SetIotInstanceId(v string) *UpdateSpeechRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateSpeechRequest) SetProjectCode(v string) *UpdateSpeechRequest {
	s.ProjectCode = &v
	return s
}

func (s *UpdateSpeechRequest) SetSoundCodeConfig(v map[string]interface{}) *UpdateSpeechRequest {
	s.SoundCodeConfig = v
	return s
}

func (s *UpdateSpeechRequest) SetSpeechCode(v string) *UpdateSpeechRequest {
	s.SpeechCode = &v
	return s
}

func (s *UpdateSpeechRequest) SetSpeechRate(v int32) *UpdateSpeechRequest {
	s.SpeechRate = &v
	return s
}

func (s *UpdateSpeechRequest) SetVoice(v string) *UpdateSpeechRequest {
	s.Voice = &v
	return s
}

func (s *UpdateSpeechRequest) SetVolume(v int32) *UpdateSpeechRequest {
	s.Volume = &v
	return s
}

type UpdateSpeechShrinkRequest struct {
	EnableSoundCode       *bool   `json:"EnableSoundCode,omitempty" xml:"EnableSoundCode,omitempty"`
	IotInstanceId         *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	ProjectCode           *string `json:"ProjectCode,omitempty" xml:"ProjectCode,omitempty"`
	SoundCodeConfigShrink *string `json:"SoundCodeConfig,omitempty" xml:"SoundCodeConfig,omitempty"`
	SpeechCode            *string `json:"SpeechCode,omitempty" xml:"SpeechCode,omitempty"`
	SpeechRate            *int32  `json:"SpeechRate,omitempty" xml:"SpeechRate,omitempty"`
	Voice                 *string `json:"Voice,omitempty" xml:"Voice,omitempty"`
	Volume                *int32  `json:"Volume,omitempty" xml:"Volume,omitempty"`
}

func (s UpdateSpeechShrinkRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSpeechShrinkRequest) GoString() string {
	return s.String()
}

func (s *UpdateSpeechShrinkRequest) SetEnableSoundCode(v bool) *UpdateSpeechShrinkRequest {
	s.EnableSoundCode = &v
	return s
}

func (s *UpdateSpeechShrinkRequest) SetIotInstanceId(v string) *UpdateSpeechShrinkRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateSpeechShrinkRequest) SetProjectCode(v string) *UpdateSpeechShrinkRequest {
	s.ProjectCode = &v
	return s
}

func (s *UpdateSpeechShrinkRequest) SetSoundCodeConfigShrink(v string) *UpdateSpeechShrinkRequest {
	s.SoundCodeConfigShrink = &v
	return s
}

func (s *UpdateSpeechShrinkRequest) SetSpeechCode(v string) *UpdateSpeechShrinkRequest {
	s.SpeechCode = &v
	return s
}

func (s *UpdateSpeechShrinkRequest) SetSpeechRate(v int32) *UpdateSpeechShrinkRequest {
	s.SpeechRate = &v
	return s
}

func (s *UpdateSpeechShrinkRequest) SetVoice(v string) *UpdateSpeechShrinkRequest {
	s.Voice = &v
	return s
}

func (s *UpdateSpeechShrinkRequest) SetVolume(v int32) *UpdateSpeechShrinkRequest {
	s.Volume = &v
	return s
}

type UpdateSpeechResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateSpeechResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateSpeechResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateSpeechResponseBody) SetCode(v string) *UpdateSpeechResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateSpeechResponseBody) SetErrorMessage(v string) *UpdateSpeechResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateSpeechResponseBody) SetRequestId(v string) *UpdateSpeechResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateSpeechResponseBody) SetSuccess(v bool) *UpdateSpeechResponseBody {
	s.Success = &v
	return s
}

type UpdateSpeechResponse struct {
	Headers    map[string]*string        `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                    `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateSpeechResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateSpeechResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSpeechResponse) GoString() string {
	return s.String()
}

func (s *UpdateSpeechResponse) SetHeaders(v map[string]*string) *UpdateSpeechResponse {
	s.Headers = v
	return s
}

func (s *UpdateSpeechResponse) SetStatusCode(v int32) *UpdateSpeechResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateSpeechResponse) SetBody(v *UpdateSpeechResponseBody) *UpdateSpeechResponse {
	s.Body = v
	return s
}

type UpdateSubscribeRelationRequest struct {
	ConsumerGroupIds []*string `json:"ConsumerGroupIds,omitempty" xml:"ConsumerGroupIds,omitempty" type:"Repeated"`
	// Specifies whether to push upstream device messages. Valid values:
	//
	// *   **true**: yes.
	// *   **false**: no.
	//
	// Default value: **false**.
	DeviceDataFlag *bool `json:"DeviceDataFlag,omitempty" xml:"DeviceDataFlag,omitempty"`
	// Specifies whether to push messages about device lifecycle changes. Valid values:
	//
	// *   **true**: yes.
	// *   **false**: no.
	//
	// Default value: **false**.
	DeviceLifeCycleFlag *bool `json:"DeviceLifeCycleFlag,omitempty" xml:"DeviceLifeCycleFlag,omitempty"`
	// Specifies whether to push messages about device status changes. Valid values:
	//
	// *   **true**: yes.
	// *   **false**: no.
	//
	// Default value: **false**.
	DeviceStatusChangeFlag *bool `json:"DeviceStatusChangeFlag,omitempty" xml:"DeviceStatusChangeFlag,omitempty"`
	// Specifies whether to push messages about topological relationship changes of devices. Valid values:
	//
	// *   **true**: yes. This parameter takes effect only if the **Type** parameter is set to **AMQP**.
	// *   **false**: no.
	//
	// Default value: **false**.
	DeviceTagFlag *bool `json:"DeviceTagFlag,omitempty" xml:"DeviceTagFlag,omitempty"`
	// Specifies whether to push messages about topological relationship changes of devices. Valid values:
	//
	// *   **true**: yes. This parameter is valid only for gateway products.
	// *   **false**: no.
	//
	// Default value: **false**.
	DeviceTopoLifeCycleFlag *bool `json:"DeviceTopoLifeCycleFlag,omitempty" xml:"DeviceTopoLifeCycleFlag,omitempty"`
	// Specifies whether to push messages if a gateway detects new sub-devices. Valid values:
	//
	// *   **true**: yes. This parameter is valid only for gateway products.
	// *   **false**: no.
	//
	// Default value: **false**.
	FoundDeviceListFlag *bool `json:"FoundDeviceListFlag,omitempty" xml:"FoundDeviceListFlag,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The configurations of the MNS queue. This parameter is required if the **Type** parameter is set to **AMQP**.
	//
	// For more information, see the "Definition of the MnsConfiguration parameter" section.
	MnsConfiguration *string `json:"MnsConfiguration,omitempty" xml:"MnsConfiguration,omitempty"`
	// Specifies whether to push notifications about the status of OTA update batches. Valid values:
	//
	// *   **true**: yes.
	// *   **false**: no.
	//
	// Default value: **false**.
	OtaEventFlag *bool `json:"OtaEventFlag,omitempty" xml:"OtaEventFlag,omitempty"`
	// Specifies whether to push notifications about the statuses of OTA update batches. Valid values:
	//
	// *   **true**: yes. This parameter takes effect only if the **Type** parameter is set to **AMQP**.
	// *   **false**: no.
	//
	// Default value: **false**.
	OtaJobFlag *bool `json:"OtaJobFlag,omitempty" xml:"OtaJobFlag,omitempty"`
	// Specifies whether to push messages about OTA module version numbers. Valid values:
	//
	// *   **true**: yes. This parameter takes effect only if the **Type** parameter is set to **AMQP**.
	// *   **false**: no.
	//
	// Default value: **false**.
	OtaVersionFlag *bool `json:"OtaVersionFlag,omitempty" xml:"OtaVersionFlag,omitempty"`
	// The **ProductKey** of the product that is specified for the subscription.
	ProductKey     *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	SubscribeFlags *string `json:"SubscribeFlags,omitempty" xml:"SubscribeFlags,omitempty"`
	// Specifies whether to push upstream historical Thing Specification Language (TSL) data. Valid values:
	//
	// *   **true**: yes.
	// *   **false**: no.
	//
	// Default value: **false**.
	ThingHistoryFlag *bool `json:"ThingHistoryFlag,omitempty" xml:"ThingHistoryFlag,omitempty"`
	// The type of the subscription. Valid values:
	//
	// *   **MNS**
	// *   **AMQP**
	Type *string `json:"Type,omitempty" xml:"Type,omitempty"`
}

func (s UpdateSubscribeRelationRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateSubscribeRelationRequest) GoString() string {
	return s.String()
}

func (s *UpdateSubscribeRelationRequest) SetConsumerGroupIds(v []*string) *UpdateSubscribeRelationRequest {
	s.ConsumerGroupIds = v
	return s
}

func (s *UpdateSubscribeRelationRequest) SetDeviceDataFlag(v bool) *UpdateSubscribeRelationRequest {
	s.DeviceDataFlag = &v
	return s
}

func (s *UpdateSubscribeRelationRequest) SetDeviceLifeCycleFlag(v bool) *UpdateSubscribeRelationRequest {
	s.DeviceLifeCycleFlag = &v
	return s
}

func (s *UpdateSubscribeRelationRequest) SetDeviceStatusChangeFlag(v bool) *UpdateSubscribeRelationRequest {
	s.DeviceStatusChangeFlag = &v
	return s
}

func (s *UpdateSubscribeRelationRequest) SetDeviceTagFlag(v bool) *UpdateSubscribeRelationRequest {
	s.DeviceTagFlag = &v
	return s
}

func (s *UpdateSubscribeRelationRequest) SetDeviceTopoLifeCycleFlag(v bool) *UpdateSubscribeRelationRequest {
	s.DeviceTopoLifeCycleFlag = &v
	return s
}

func (s *UpdateSubscribeRelationRequest) SetFoundDeviceListFlag(v bool) *UpdateSubscribeRelationRequest {
	s.FoundDeviceListFlag = &v
	return s
}

func (s *UpdateSubscribeRelationRequest) SetIotInstanceId(v string) *UpdateSubscribeRelationRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateSubscribeRelationRequest) SetMnsConfiguration(v string) *UpdateSubscribeRelationRequest {
	s.MnsConfiguration = &v
	return s
}

func (s *UpdateSubscribeRelationRequest) SetOtaEventFlag(v bool) *UpdateSubscribeRelationRequest {
	s.OtaEventFlag = &v
	return s
}

func (s *UpdateSubscribeRelationRequest) SetOtaJobFlag(v bool) *UpdateSubscribeRelationRequest {
	s.OtaJobFlag = &v
	return s
}

func (s *UpdateSubscribeRelationRequest) SetOtaVersionFlag(v bool) *UpdateSubscribeRelationRequest {
	s.OtaVersionFlag = &v
	return s
}

func (s *UpdateSubscribeRelationRequest) SetProductKey(v string) *UpdateSubscribeRelationRequest {
	s.ProductKey = &v
	return s
}

func (s *UpdateSubscribeRelationRequest) SetSubscribeFlags(v string) *UpdateSubscribeRelationRequest {
	s.SubscribeFlags = &v
	return s
}

func (s *UpdateSubscribeRelationRequest) SetThingHistoryFlag(v bool) *UpdateSubscribeRelationRequest {
	s.ThingHistoryFlag = &v
	return s
}

func (s *UpdateSubscribeRelationRequest) SetType(v string) *UpdateSubscribeRelationRequest {
	s.Type = &v
	return s
}

type UpdateSubscribeRelationResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateSubscribeRelationResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateSubscribeRelationResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateSubscribeRelationResponseBody) SetCode(v string) *UpdateSubscribeRelationResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateSubscribeRelationResponseBody) SetErrorMessage(v string) *UpdateSubscribeRelationResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateSubscribeRelationResponseBody) SetRequestId(v string) *UpdateSubscribeRelationResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateSubscribeRelationResponseBody) SetSuccess(v bool) *UpdateSubscribeRelationResponseBody {
	s.Success = &v
	return s
}

type UpdateSubscribeRelationResponse struct {
	Headers    map[string]*string                   `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                               `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateSubscribeRelationResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateSubscribeRelationResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateSubscribeRelationResponse) GoString() string {
	return s.String()
}

func (s *UpdateSubscribeRelationResponse) SetHeaders(v map[string]*string) *UpdateSubscribeRelationResponse {
	s.Headers = v
	return s
}

func (s *UpdateSubscribeRelationResponse) SetStatusCode(v int32) *UpdateSubscribeRelationResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateSubscribeRelationResponse) SetBody(v *UpdateSubscribeRelationResponseBody) *UpdateSubscribeRelationResponse {
	s.Body = v
	return s
}

type UpdateThingModelRequest struct {
	// The identifier of the custom TSL module. Each identifier is unique in a product.
	//
	// If you do not specify this parameter or the **FunctionBlockName** parameter, the system updates the features of the default module.
	FunctionBlockId *string `json:"FunctionBlockId,omitempty" xml:"FunctionBlockId,omitempty"`
	// The name of the custom module. The name must be 4 to 30 characters in length, and can contain letters, digits, and underscores (\_).
	//
	// *   If you do not specify this parameter or the **FunctionBlockId** parameter, the system updates the features of the default module.
	// *   If you specify this parameter, the parameter must be used in combination with the **FunctionBlockId** parameter. You can modify the name of the specified custom module. The name corresponds to the value of the **FunctionBlockId** parameter.
	//
	// >  You cannot modify the name of the default module.
	FunctionBlockName *string `json:"FunctionBlockName,omitempty" xml:"FunctionBlockName,omitempty"`
	// The identifier of the feature.
	//
	// You can call the [GetThingModelTsl](~~150319~~) operation and view the identifier in the **TslStr** response parameter.
	Identifier *string `json:"Identifier,omitempty" xml:"Identifier,omitempty"`
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product.
	//
	// You can view the ProductKey on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The updated details of the feature.
	//
	// *   If you specify the **Identifier** parameter, you can define only the identifier of the feature.
	// *   If you do not specify the **Identifier** parameter, you can define a maximum of 50 input and output parameters for a service or event.
	//
	// For more information about how to specify this parameter, see [Data structure of ThingModelJson](~~150457~~).
	ThingModelJson *string `json:"ThingModelJson,omitempty" xml:"ThingModelJson,omitempty"`
}

func (s UpdateThingModelRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateThingModelRequest) GoString() string {
	return s.String()
}

func (s *UpdateThingModelRequest) SetFunctionBlockId(v string) *UpdateThingModelRequest {
	s.FunctionBlockId = &v
	return s
}

func (s *UpdateThingModelRequest) SetFunctionBlockName(v string) *UpdateThingModelRequest {
	s.FunctionBlockName = &v
	return s
}

func (s *UpdateThingModelRequest) SetIdentifier(v string) *UpdateThingModelRequest {
	s.Identifier = &v
	return s
}

func (s *UpdateThingModelRequest) SetIotInstanceId(v string) *UpdateThingModelRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateThingModelRequest) SetProductKey(v string) *UpdateThingModelRequest {
	s.ProductKey = &v
	return s
}

func (s *UpdateThingModelRequest) SetThingModelJson(v string) *UpdateThingModelRequest {
	s.ThingModelJson = &v
	return s
}

type UpdateThingModelResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateThingModelResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateThingModelResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateThingModelResponseBody) SetCode(v string) *UpdateThingModelResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateThingModelResponseBody) SetErrorMessage(v string) *UpdateThingModelResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateThingModelResponseBody) SetRequestId(v string) *UpdateThingModelResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateThingModelResponseBody) SetSuccess(v bool) *UpdateThingModelResponseBody {
	s.Success = &v
	return s
}

type UpdateThingModelResponse struct {
	Headers    map[string]*string            `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                        `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateThingModelResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateThingModelResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateThingModelResponse) GoString() string {
	return s.String()
}

func (s *UpdateThingModelResponse) SetHeaders(v map[string]*string) *UpdateThingModelResponse {
	s.Headers = v
	return s
}

func (s *UpdateThingModelResponse) SetStatusCode(v int32) *UpdateThingModelResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateThingModelResponse) SetBody(v *UpdateThingModelResponseBody) *UpdateThingModelResponse {
	s.Body = v
	return s
}

type UpdateThingScriptRequest struct {
	// The ID of the instance. You can view the instance **ID** on the **Overview** page in the IoT Platform console.
	//
	// >*   If your instance has an ID, you must configure this parameter. If you do not set this parameter, the call fails.
	// >*   If your instance has no **Overview** page or ID, you do not need to set this parameter.
	//
	// For more information, see [Overview](~~356505~~).
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	// The **ProductKey** of the product.
	//
	// You can view the **ProductKey** on the Product Details page of the IoT Platform console. You can also obtain the ProductKey by calling the [QueryProductList](~~69271~~) operation.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The content of the script. You must specify this parameter.
	//
	// For more information about script examples, see [What is data parsing](~~68702~~).
	ScriptContent *string `json:"ScriptContent,omitempty" xml:"ScriptContent,omitempty"`
	// The type of the script. Valid values:
	//
	// *   JavaScript
	// *   Python\_27: Python 2.7
	// *   PHP\_72: PHP 7.2
	ScriptType *string `json:"ScriptType,omitempty" xml:"ScriptType,omitempty"`
}

func (s UpdateThingScriptRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateThingScriptRequest) GoString() string {
	return s.String()
}

func (s *UpdateThingScriptRequest) SetIotInstanceId(v string) *UpdateThingScriptRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateThingScriptRequest) SetProductKey(v string) *UpdateThingScriptRequest {
	s.ProductKey = &v
	return s
}

func (s *UpdateThingScriptRequest) SetScriptContent(v string) *UpdateThingScriptRequest {
	s.ScriptContent = &v
	return s
}

func (s *UpdateThingScriptRequest) SetScriptType(v string) *UpdateThingScriptRequest {
	s.ScriptType = &v
	return s
}

type UpdateThingScriptResponseBody struct {
	// The error code returned if the call fails. For more information, see [Error codes](~~87387~~).
	Code *string `json:"Code,omitempty" xml:"Code,omitempty"`
	// The error message returned if the call fails.
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	// The ID of the request.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the call was successful.
	//
	// *   **true**: The call was successful.
	// *   **false**: The call failed.
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateThingScriptResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateThingScriptResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateThingScriptResponseBody) SetCode(v string) *UpdateThingScriptResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateThingScriptResponseBody) SetErrorMessage(v string) *UpdateThingScriptResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *UpdateThingScriptResponseBody) SetRequestId(v string) *UpdateThingScriptResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateThingScriptResponseBody) SetSuccess(v bool) *UpdateThingScriptResponseBody {
	s.Success = &v
	return s
}

type UpdateThingScriptResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateThingScriptResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateThingScriptResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateThingScriptResponse) GoString() string {
	return s.String()
}

func (s *UpdateThingScriptResponse) SetHeaders(v map[string]*string) *UpdateThingScriptResponse {
	s.Headers = v
	return s
}

func (s *UpdateThingScriptResponse) SetStatusCode(v int32) *UpdateThingScriptResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateThingScriptResponse) SetBody(v *UpdateThingScriptResponseBody) *UpdateThingScriptResponse {
	s.Body = v
	return s
}

type UpdateTopicConfigRequest struct {
	Codec       *string `json:"Codec,omitempty" xml:"Codec,omitempty"`
	Description *string `json:"Description,omitempty" xml:"Description,omitempty"`
	// Specifies whether to enable the retained message broadcasting feature for a custom topic.
	//
	// *   **true**
	// *   **false**
	EnableBroadcast      *bool `json:"EnableBroadcast,omitempty" xml:"EnableBroadcast,omitempty"`
	EnableProxySubscribe *bool `json:"EnableProxySubscribe,omitempty" xml:"EnableProxySubscribe,omitempty"`
	// The instance ID. You can view the **ID** of the instance on the **Overview** page in the IoT Platform console.
	//
	// >  If your instance has an ID, you must specify this parameter. Otherwise, the request fails. If no Overview page exists or no instance ID is displayed, you do not need to specify this parameter.
	//
	// For more information, see the [Overview](~~356505~~) topic of IoT instances.
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Operation     *string `json:"Operation,omitempty" xml:"Operation,omitempty"`
	// The **ProductKey** of the product to which the device belongs. The device receives the retained message.
	ProductKey *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	// The custom topic for which you want to enable the retained message broadcasting feature.
	//
	// *   If you use an MQTT gateway device, set this parameter to the original custom topic of the device. For more information, see [Topics](~~433806~~).
	// *   If you use a non-MQTT gateway device, set this parameter to a custom topic in the following format: `/broadcast/${productKey}/${Custom field}`. `${productKey}` is the value of the **ProductKey** request parameter. You can specify `${Custom field}` based on your business requirements.
	//
	// >  When you develop devices, use code to define a broadcast topic. You do not need to create a topic in the IoT Platform console. You must grant devices the Subscribe permission or the Publish and Subscribe permission on the topic.
	TopicFullName *string `json:"TopicFullName,omitempty" xml:"TopicFullName,omitempty"`
}

func (s UpdateTopicConfigRequest) String() string {
	return tea.Prettify(s)
}

func (s UpdateTopicConfigRequest) GoString() string {
	return s.String()
}

func (s *UpdateTopicConfigRequest) SetCodec(v string) *UpdateTopicConfigRequest {
	s.Codec = &v
	return s
}

func (s *UpdateTopicConfigRequest) SetDescription(v string) *UpdateTopicConfigRequest {
	s.Description = &v
	return s
}

func (s *UpdateTopicConfigRequest) SetEnableBroadcast(v bool) *UpdateTopicConfigRequest {
	s.EnableBroadcast = &v
	return s
}

func (s *UpdateTopicConfigRequest) SetEnableProxySubscribe(v bool) *UpdateTopicConfigRequest {
	s.EnableProxySubscribe = &v
	return s
}

func (s *UpdateTopicConfigRequest) SetIotInstanceId(v string) *UpdateTopicConfigRequest {
	s.IotInstanceId = &v
	return s
}

func (s *UpdateTopicConfigRequest) SetOperation(v string) *UpdateTopicConfigRequest {
	s.Operation = &v
	return s
}

func (s *UpdateTopicConfigRequest) SetProductKey(v string) *UpdateTopicConfigRequest {
	s.ProductKey = &v
	return s
}

func (s *UpdateTopicConfigRequest) SetTopicFullName(v string) *UpdateTopicConfigRequest {
	s.TopicFullName = &v
	return s
}

type UpdateTopicConfigResponseBody struct {
	// The error code returned if the request fails. For more information, see [Error codes](~~87387~~).
	Code    *string `json:"Code,omitempty" xml:"Code,omitempty"`
	Message *string `json:"Message,omitempty" xml:"Message,omitempty"`
	// The request ID.
	RequestId *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	// Indicates whether the request was successful. Valid values:
	//
	// *   **true**
	// *   **false**
	Success *bool `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s UpdateTopicConfigResponseBody) String() string {
	return tea.Prettify(s)
}

func (s UpdateTopicConfigResponseBody) GoString() string {
	return s.String()
}

func (s *UpdateTopicConfigResponseBody) SetCode(v string) *UpdateTopicConfigResponseBody {
	s.Code = &v
	return s
}

func (s *UpdateTopicConfigResponseBody) SetMessage(v string) *UpdateTopicConfigResponseBody {
	s.Message = &v
	return s
}

func (s *UpdateTopicConfigResponseBody) SetRequestId(v string) *UpdateTopicConfigResponseBody {
	s.RequestId = &v
	return s
}

func (s *UpdateTopicConfigResponseBody) SetSuccess(v bool) *UpdateTopicConfigResponseBody {
	s.Success = &v
	return s
}

type UpdateTopicConfigResponse struct {
	Headers    map[string]*string             `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                         `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *UpdateTopicConfigResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s UpdateTopicConfigResponse) String() string {
	return tea.Prettify(s)
}

func (s UpdateTopicConfigResponse) GoString() string {
	return s.String()
}

func (s *UpdateTopicConfigResponse) SetHeaders(v map[string]*string) *UpdateTopicConfigResponse {
	s.Headers = v
	return s
}

func (s *UpdateTopicConfigResponse) SetStatusCode(v int32) *UpdateTopicConfigResponse {
	s.StatusCode = &v
	return s
}

func (s *UpdateTopicConfigResponse) SetBody(v *UpdateTopicConfigResponseBody) *UpdateTopicConfigResponse {
	s.Body = v
	return s
}

type WriteDevicesHotStorageDataRequest struct {
	DeviceName    *string `json:"DeviceName,omitempty" xml:"DeviceName,omitempty"`
	IotId         *string `json:"IotId,omitempty" xml:"IotId,omitempty"`
	IotInstanceId *string `json:"IotInstanceId,omitempty" xml:"IotInstanceId,omitempty"`
	Items         *string `json:"Items,omitempty" xml:"Items,omitempty"`
	ProductKey    *string `json:"ProductKey,omitempty" xml:"ProductKey,omitempty"`
	UserTopic     *string `json:"UserTopic,omitempty" xml:"UserTopic,omitempty"`
}

func (s WriteDevicesHotStorageDataRequest) String() string {
	return tea.Prettify(s)
}

func (s WriteDevicesHotStorageDataRequest) GoString() string {
	return s.String()
}

func (s *WriteDevicesHotStorageDataRequest) SetDeviceName(v string) *WriteDevicesHotStorageDataRequest {
	s.DeviceName = &v
	return s
}

func (s *WriteDevicesHotStorageDataRequest) SetIotId(v string) *WriteDevicesHotStorageDataRequest {
	s.IotId = &v
	return s
}

func (s *WriteDevicesHotStorageDataRequest) SetIotInstanceId(v string) *WriteDevicesHotStorageDataRequest {
	s.IotInstanceId = &v
	return s
}

func (s *WriteDevicesHotStorageDataRequest) SetItems(v string) *WriteDevicesHotStorageDataRequest {
	s.Items = &v
	return s
}

func (s *WriteDevicesHotStorageDataRequest) SetProductKey(v string) *WriteDevicesHotStorageDataRequest {
	s.ProductKey = &v
	return s
}

func (s *WriteDevicesHotStorageDataRequest) SetUserTopic(v string) *WriteDevicesHotStorageDataRequest {
	s.UserTopic = &v
	return s
}

type WriteDevicesHotStorageDataResponseBody struct {
	Code         *string `json:"Code,omitempty" xml:"Code,omitempty"`
	ErrorMessage *string `json:"ErrorMessage,omitempty" xml:"ErrorMessage,omitempty"`
	RequestId    *string `json:"RequestId,omitempty" xml:"RequestId,omitempty"`
	Success      *bool   `json:"Success,omitempty" xml:"Success,omitempty"`
}

func (s WriteDevicesHotStorageDataResponseBody) String() string {
	return tea.Prettify(s)
}

func (s WriteDevicesHotStorageDataResponseBody) GoString() string {
	return s.String()
}

func (s *WriteDevicesHotStorageDataResponseBody) SetCode(v string) *WriteDevicesHotStorageDataResponseBody {
	s.Code = &v
	return s
}

func (s *WriteDevicesHotStorageDataResponseBody) SetErrorMessage(v string) *WriteDevicesHotStorageDataResponseBody {
	s.ErrorMessage = &v
	return s
}

func (s *WriteDevicesHotStorageDataResponseBody) SetRequestId(v string) *WriteDevicesHotStorageDataResponseBody {
	s.RequestId = &v
	return s
}

func (s *WriteDevicesHotStorageDataResponseBody) SetSuccess(v bool) *WriteDevicesHotStorageDataResponseBody {
	s.Success = &v
	return s
}

type WriteDevicesHotStorageDataResponse struct {
	Headers    map[string]*string                      `json:"headers,omitempty" xml:"headers,omitempty" require:"true"`
	StatusCode *int32                                  `json:"statusCode,omitempty" xml:"statusCode,omitempty" require:"true"`
	Body       *WriteDevicesHotStorageDataResponseBody `json:"body,omitempty" xml:"body,omitempty" require:"true"`
}

func (s WriteDevicesHotStorageDataResponse) String() string {
	return tea.Prettify(s)
}

func (s WriteDevicesHotStorageDataResponse) GoString() string {
	return s.String()
}

func (s *WriteDevicesHotStorageDataResponse) SetHeaders(v map[string]*string) *WriteDevicesHotStorageDataResponse {
	s.Headers = v
	return s
}

func (s *WriteDevicesHotStorageDataResponse) SetStatusCode(v int32) *WriteDevicesHotStorageDataResponse {
	s.StatusCode = &v
	return s
}

func (s *WriteDevicesHotStorageDataResponse) SetBody(v *WriteDevicesHotStorageDataResponseBody) *WriteDevicesHotStorageDataResponse {
	s.Body = v
	return s
}

type Client struct {
	openapi.Client
}

func NewClient(config *openapi.Config) (*Client, error) {
	client := new(Client)
	err := client.Init(config)
	return client, err
}

func (client *Client) Init(config *openapi.Config) (_err error) {
	_err = client.Client.Init(config)
	if _err != nil {
		return _err
	}
	client.EndpointRule = tea.String("regional")
	client.EndpointMap = map[string]*string{
		"ap-northeast-2-pop":          tea.String("iot.aliyuncs.com"),
		"ap-south-1":                  tea.String("iot.aliyuncs.com"),
		"ap-southeast-2":              tea.String("iot.aliyuncs.com"),
		"ap-southeast-3":              tea.String("iot.aliyuncs.com"),
		"ap-southeast-5":              tea.String("iot.aliyuncs.com"),
		"cn-beijing-finance-1":        tea.String("iot.aliyuncs.com"),
		"cn-beijing-finance-pop":      tea.String("iot.aliyuncs.com"),
		"cn-beijing-gov-1":            tea.String("iot.aliyuncs.com"),
		"cn-beijing-nu16-b01":         tea.String("iot.aliyuncs.com"),
		"cn-chengdu":                  tea.String("iot.aliyuncs.com"),
		"cn-edge-1":                   tea.String("iot.aliyuncs.com"),
		"cn-fujian":                   tea.String("iot.aliyuncs.com"),
		"cn-haidian-cm12-c01":         tea.String("iot.aliyuncs.com"),
		"cn-hangzhou-bj-b01":          tea.String("iot.aliyuncs.com"),
		"cn-hangzhou-finance":         tea.String("iot.aliyuncs.com"),
		"cn-hangzhou-internal-prod-1": tea.String("iot.aliyuncs.com"),
		"cn-hangzhou-internal-test-1": tea.String("iot.aliyuncs.com"),
		"cn-hangzhou-internal-test-2": tea.String("iot.aliyuncs.com"),
		"cn-hangzhou-internal-test-3": tea.String("iot.aliyuncs.com"),
		"cn-hangzhou-test-306":        tea.String("iot.aliyuncs.com"),
		"cn-hongkong":                 tea.String("iot.aliyuncs.com"),
		"cn-hongkong-finance-pop":     tea.String("iot.aliyuncs.com"),
		"cn-huhehaote":                tea.String("iot.aliyuncs.com"),
		"cn-huhehaote-nebula-1":       tea.String("iot.aliyuncs.com"),
		"cn-qingdao":                  tea.String("iot.aliyuncs.com"),
		"cn-qingdao-nebula":           tea.String("iot.aliyuncs.com"),
		"cn-shanghai-et15-b01":        tea.String("iot.aliyuncs.com"),
		"cn-shanghai-et2-b01":         tea.String("iot.aliyuncs.com"),
		"cn-shanghai-finance-1":       tea.String("iot.aliyuncs.com"),
		"cn-shanghai-inner":           tea.String("iot.aliyuncs.com"),
		"cn-shanghai-internal-test-1": tea.String("iot.aliyuncs.com"),
		"cn-shenzhen-finance-1":       tea.String("iot.aliyuncs.com"),
		"cn-shenzhen-inner":           tea.String("iot.aliyuncs.com"),
		"cn-shenzhen-st4-d01":         tea.String("iot.aliyuncs.com"),
		"cn-shenzhen-su18-b01":        tea.String("iot.aliyuncs.com"),
		"cn-wuhan":                    tea.String("iot.aliyuncs.com"),
		"cn-wulanchabu":               tea.String("iot.aliyuncs.com"),
		"cn-yushanfang":               tea.String("iot.aliyuncs.com"),
		"cn-zhangbei":                 tea.String("iot.aliyuncs.com"),
		"cn-zhangbei-na61-b01":        tea.String("iot.aliyuncs.com"),
		"cn-zhangjiakou":              tea.String("iot.aliyuncs.com"),
		"cn-zhangjiakou-na62-a01":     tea.String("iot.aliyuncs.com"),
		"cn-zhengzhou-nebula-1":       tea.String("iot.aliyuncs.com"),
		"eu-west-1":                   tea.String("iot.aliyuncs.com"),
		"eu-west-1-oxs":               tea.String("iot.aliyuncs.com"),
		"me-east-1":                   tea.String("iot.aliyuncs.com"),
		"rus-west-1-pop":              tea.String("iot.aliyuncs.com"),
	}
	_err = client.CheckConfig(config)
	if _err != nil {
		return _err
	}
	client.Endpoint, _err = client.GetEndpoint(tea.String("iot"), client.RegionId, client.EndpointRule, client.Network, client.Suffix, client.EndpointMap, client.Endpoint)
	if _err != nil {
		return _err
	}

	return nil
}

func (client *Client) GetEndpoint(productId *string, regionId *string, endpointRule *string, network *string, suffix *string, endpointMap map[string]*string, endpoint *string) (_result *string, _err error) {
	if !tea.BoolValue(util.Empty(endpoint)) {
		_result = endpoint
		return _result, _err
	}

	if !tea.BoolValue(util.IsUnset(endpointMap)) && !tea.BoolValue(util.Empty(endpointMap[tea.StringValue(regionId)])) {
		_result = endpointMap[tea.StringValue(regionId)]
		return _result, _err
	}

	_body, _err := endpointutil.GetEndpointRules(productId, regionId, endpointRule, network, suffix)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddDataForApiSourceWithOptions(request *AddDataForApiSourceRequest, runtime *util.RuntimeOptions) (_result *AddDataForApiSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiId)) {
		query["ApiId"] = request.ApiId
	}

	if !tea.BoolValue(util.IsUnset(request.Content)) {
		query["Content"] = request.Content
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AddDataForApiSource"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddDataForApiSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddDataForApiSource(request *AddDataForApiSourceRequest) (_result *AddDataForApiSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddDataForApiSourceResponse{}
	_body, _err := client.AddDataForApiSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddDeviceToSharePromotionWithOptions(request *AddDeviceToSharePromotionRequest, runtime *util.RuntimeOptions) (_result *AddDeviceToSharePromotionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceSimpleInfoList)) {
		body["DeviceSimpleInfoList"] = request.DeviceSimpleInfoList
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SharePromotionActivityId)) {
		body["SharePromotionActivityId"] = request.SharePromotionActivityId
	}

	if !tea.BoolValue(util.IsUnset(request.ShareTaskCode)) {
		body["ShareTaskCode"] = request.ShareTaskCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("AddDeviceToSharePromotion"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddDeviceToSharePromotionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddDeviceToSharePromotion(request *AddDeviceToSharePromotionRequest) (_result *AddDeviceToSharePromotionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddDeviceToSharePromotionResponse{}
	_body, _err := client.AddDeviceToSharePromotionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AddShareTaskDeviceWithOptions(request *AddShareTaskDeviceRequest, runtime *util.RuntimeOptions) (_result *AddShareTaskDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotIdList)) {
		body["IotIdList"] = request.IotIdList
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		body["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ShareTaskId)) {
		body["ShareTaskId"] = request.ShareTaskId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("AddShareTaskDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AddShareTaskDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AddShareTaskDevice(request *AddShareTaskDeviceRequest) (_result *AddShareTaskDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AddShareTaskDeviceResponse{}
	_body, _err := client.AddShareTaskDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AsyncRRpcWithOptions(request *AsyncRRpcRequest, runtime *util.RuntimeOptions) (_result *AsyncRRpcResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.ExtInfo)) {
		query["ExtInfo"] = request.ExtInfo
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.TopicFullName)) {
		query["TopicFullName"] = request.TopicFullName
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MessageContent)) {
		body["MessageContent"] = request.MessageContent
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("AsyncRRpc"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AsyncRRpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AsyncRRpc(request *AsyncRRpcRequest) (_result *AsyncRRpcResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AsyncRRpcResponse{}
	_body, _err := client.AsyncRRpcWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AttachDestinationWithOptions(request *AttachDestinationRequest, runtime *util.RuntimeOptions) (_result *AttachDestinationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DestinationId)) {
		query["DestinationId"] = request.DestinationId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IsFailover)) {
		query["IsFailover"] = request.IsFailover
	}

	if !tea.BoolValue(util.IsUnset(request.ParserId)) {
		query["ParserId"] = request.ParserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachDestination"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachDestinationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AttachDestination(request *AttachDestinationRequest) (_result *AttachDestinationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachDestinationResponse{}
	_body, _err := client.AttachDestinationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) AttachParserDataSourceWithOptions(request *AttachParserDataSourceRequest, runtime *util.RuntimeOptions) (_result *AttachParserDataSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataSourceId)) {
		query["DataSourceId"] = request.DataSourceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ParserId)) {
		query["ParserId"] = request.ParserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("AttachParserDataSource"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &AttachParserDataSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) AttachParserDataSource(request *AttachParserDataSourceRequest) (_result *AttachParserDataSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &AttachParserDataSourceResponse{}
	_body, _err := client.AttachParserDataSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchAddDataForApiSourceWithOptions(request *BatchAddDataForApiSourceRequest, runtime *util.RuntimeOptions) (_result *BatchAddDataForApiSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiId)) {
		query["ApiId"] = request.ApiId
	}

	if !tea.BoolValue(util.IsUnset(request.ContentList)) {
		query["ContentList"] = request.ContentList
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchAddDataForApiSource"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchAddDataForApiSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchAddDataForApiSource(request *BatchAddDataForApiSourceRequest) (_result *BatchAddDataForApiSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchAddDataForApiSourceResponse{}
	_body, _err := client.BatchAddDataForApiSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
 *
 * @param request BatchAddDeviceGroupRelationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchAddDeviceGroupRelationsResponse
 */
func (client *Client) BatchAddDeviceGroupRelationsWithOptions(request *BatchAddDeviceGroupRelationsRequest, runtime *util.RuntimeOptions) (_result *BatchAddDeviceGroupRelationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Device)) {
		query["Device"] = request.Device
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchAddDeviceGroupRelations"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchAddDeviceGroupRelationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
 *
 * @param request BatchAddDeviceGroupRelationsRequest
 * @return BatchAddDeviceGroupRelationsResponse
 */
func (client *Client) BatchAddDeviceGroupRelations(request *BatchAddDeviceGroupRelationsRequest) (_result *BatchAddDeviceGroupRelationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchAddDeviceGroupRelationsResponse{}
	_body, _err := client.BatchAddDeviceGroupRelationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can attach up to 10 sub-devices to a gateway in a single call.
 * *   The API operation caller must be the gateway owner.
 * *   If you specify a sub-device that is already attached to a gateway, the original gateway is replaced with the specified gateway.
 * *   If one of the specified sub-devices fails to establish a topological relationship with the gateway, the system rolls back, and all specified sub-devices fail to establish topological relationships with the gateway.
 * *   After you call this operation to establish topological relationships between sub-devices and the gateway, IoT Platform uses the `/sys/${productKey}/${deviceName}/thing/topo/change` topic to push information that includes the result of this operation to the gateway. For more information, see [Notify gateways of changes of topological relationships](~~89299~~).
 * ## QPS limits
 * You can call this API operation up to 10 times per second per Alibaba Cloud account.
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchAddThingTopoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchAddThingTopoResponse
 */
func (client *Client) BatchAddThingTopoWithOptions(request *BatchAddThingTopoRequest, runtime *util.RuntimeOptions) (_result *BatchAddThingTopoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GwDeviceName)) {
		query["GwDeviceName"] = request.GwDeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.GwProductKey)) {
		query["GwProductKey"] = request.GwProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TopoAddItem)) {
		query["TopoAddItem"] = request.TopoAddItem
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchAddThingTopo"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchAddThingTopoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can attach up to 10 sub-devices to a gateway in a single call.
 * *   The API operation caller must be the gateway owner.
 * *   If you specify a sub-device that is already attached to a gateway, the original gateway is replaced with the specified gateway.
 * *   If one of the specified sub-devices fails to establish a topological relationship with the gateway, the system rolls back, and all specified sub-devices fail to establish topological relationships with the gateway.
 * *   After you call this operation to establish topological relationships between sub-devices and the gateway, IoT Platform uses the `/sys/${productKey}/${deviceName}/thing/topo/change` topic to push information that includes the result of this operation to the gateway. For more information, see [Notify gateways of changes of topological relationships](~~89299~~).
 * ## QPS limits
 * You can call this API operation up to 10 times per second per Alibaba Cloud account.
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchAddThingTopoRequest
 * @return BatchAddThingTopoResponse
 */
func (client *Client) BatchAddThingTopo(request *BatchAddThingTopoRequest) (_result *BatchAddThingTopoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchAddThingTopoResponse{}
	_body, _err := client.BatchAddThingTopoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information about common request parameters, see [Common parameters](~~30561~~).
 *
 * @param request BatchBindDeviceToEdgeInstanceWithDriverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchBindDeviceToEdgeInstanceWithDriverResponse
 */
func (client *Client) BatchBindDeviceToEdgeInstanceWithDriverWithOptions(request *BatchBindDeviceToEdgeInstanceWithDriverRequest, runtime *util.RuntimeOptions) (_result *BatchBindDeviceToEdgeInstanceWithDriverResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotIds)) {
		query["IotIds"] = request.IotIds
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchBindDeviceToEdgeInstanceWithDriver"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchBindDeviceToEdgeInstanceWithDriverResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information about common request parameters, see [Common parameters](~~30561~~).
 *
 * @param request BatchBindDeviceToEdgeInstanceWithDriverRequest
 * @return BatchBindDeviceToEdgeInstanceWithDriverResponse
 */
func (client *Client) BatchBindDeviceToEdgeInstanceWithDriver(request *BatchBindDeviceToEdgeInstanceWithDriverRequest) (_result *BatchBindDeviceToEdgeInstanceWithDriverResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchBindDeviceToEdgeInstanceWithDriverResponse{}
	_body, _err := client.BatchBindDeviceToEdgeInstanceWithDriverWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchBindDevicesIntoProjectWithOptions(request *BatchBindDevicesIntoProjectRequest, runtime *util.RuntimeOptions) (_result *BatchBindDevicesIntoProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Devices)) {
		body["Devices"] = request.Devices
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchBindDevicesIntoProject"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchBindDevicesIntoProjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchBindDevicesIntoProject(request *BatchBindDevicesIntoProjectRequest) (_result *BatchBindDevicesIntoProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchBindDevicesIntoProjectResponse{}
	_body, _err := client.BatchBindDevicesIntoProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchBindProductsIntoProjectWithOptions(request *BatchBindProductsIntoProjectRequest, runtime *util.RuntimeOptions) (_result *BatchBindProductsIntoProjectResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKeys)) {
		body["ProductKeys"] = request.ProductKeys
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchBindProductsIntoProject"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchBindProductsIntoProjectResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchBindProductsIntoProject(request *BatchBindProductsIntoProjectRequest) (_result *BatchBindProductsIntoProjectResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchBindProductsIntoProjectResponse{}
	_body, _err := client.BatchBindProductsIntoProjectWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation with the **BatchRegisterDeviceWithApplyId** operation to register multiple devices under a product. Each device carries a unique DeviceName.
 * Procedure:
 * 1\\. Call this operation to specify the DeviceNames of the devices to be registered. IoT Platform returns an application ID (**ApplyId**). A successful response indicates that the request to verify the DeviceNames is submitted. The actual registration process is asynchronously implemented and takes some minutes.
 * 2\\. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the name setting result.
 * 3\\. Call the [BatchRegisterDeviceWithApplyId](~~69514~~) operation to register multiple devices.
 * 4\\. Optional. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to view the registration result.
 * 5\\. Call the [QueryPageByApplyId](~~69518~~) operation to query the information about the registered devices.
 * ## Limits
 * - You can specify a maximum of 10,000 DeviceNames in a single call.
 * - Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchCheckDeviceNamesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchCheckDeviceNamesResponse
 */
func (client *Client) BatchCheckDeviceNamesWithOptions(request *BatchCheckDeviceNamesRequest, runtime *util.RuntimeOptions) (_result *BatchCheckDeviceNamesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		body["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceNameList)) {
		body["DeviceNameList"] = request.DeviceNameList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchCheckDeviceNames"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchCheckDeviceNamesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation with the **BatchRegisterDeviceWithApplyId** operation to register multiple devices under a product. Each device carries a unique DeviceName.
 * Procedure:
 * 1\\. Call this operation to specify the DeviceNames of the devices to be registered. IoT Platform returns an application ID (**ApplyId**). A successful response indicates that the request to verify the DeviceNames is submitted. The actual registration process is asynchronously implemented and takes some minutes.
 * 2\\. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the name setting result.
 * 3\\. Call the [BatchRegisterDeviceWithApplyId](~~69514~~) operation to register multiple devices.
 * 4\\. Optional. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to view the registration result.
 * 5\\. Call the [QueryPageByApplyId](~~69518~~) operation to query the information about the registered devices.
 * ## Limits
 * - You can specify a maximum of 10,000 DeviceNames in a single call.
 * - Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchCheckDeviceNamesRequest
 * @return BatchCheckDeviceNamesResponse
 */
func (client *Client) BatchCheckDeviceNames(request *BatchCheckDeviceNamesRequest) (_result *BatchCheckDeviceNamesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchCheckDeviceNamesResponse{}
	_body, _err := client.BatchCheckDeviceNamesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this operation up to 100 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchCheckImportDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchCheckImportDeviceResponse
 */
func (client *Client) BatchCheckImportDeviceWithOptions(request *BatchCheckImportDeviceRequest, runtime *util.RuntimeOptions) (_result *BatchCheckImportDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceList)) {
		body["DeviceList"] = request.DeviceList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchCheckImportDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchCheckImportDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this operation up to 100 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchCheckImportDeviceRequest
 * @return BatchCheckImportDeviceResponse
 */
func (client *Client) BatchCheckImportDevice(request *BatchCheckImportDeviceRequest) (_result *BatchCheckImportDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchCheckImportDeviceResponse{}
	_body, _err := client.BatchCheckImportDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The invalid device models returned if the call fails.
 *
 * @param request BatchCheckVehicleDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchCheckVehicleDeviceResponse
 */
func (client *Client) BatchCheckVehicleDeviceWithOptions(request *BatchCheckVehicleDeviceRequest, runtime *util.RuntimeOptions) (_result *BatchCheckVehicleDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceList)) {
		body["DeviceList"] = request.DeviceList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchCheckVehicleDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchCheckVehicleDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The invalid device models returned if the call fails.
 *
 * @param request BatchCheckVehicleDeviceRequest
 * @return BatchCheckVehicleDeviceResponse
 */
func (client *Client) BatchCheckVehicleDevice(request *BatchCheckVehicleDeviceRequest) (_result *BatchCheckVehicleDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchCheckVehicleDeviceResponse{}
	_body, _err := client.BatchCheckVehicleDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchClearEdgeInstanceDeviceConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchClearEdgeInstanceDeviceConfigResponse
 */
func (client *Client) BatchClearEdgeInstanceDeviceConfigWithOptions(request *BatchClearEdgeInstanceDeviceConfigRequest, runtime *util.RuntimeOptions) (_result *BatchClearEdgeInstanceDeviceConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotIds)) {
		query["IotIds"] = request.IotIds
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchClearEdgeInstanceDeviceConfig"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchClearEdgeInstanceDeviceConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchClearEdgeInstanceDeviceConfigRequest
 * @return BatchClearEdgeInstanceDeviceConfigResponse
 */
func (client *Client) BatchClearEdgeInstanceDeviceConfig(request *BatchClearEdgeInstanceDeviceConfigRequest) (_result *BatchClearEdgeInstanceDeviceConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchClearEdgeInstanceDeviceConfigResponse{}
	_body, _err := client.BatchClearEdgeInstanceDeviceConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchCreateSoundCodeLabelWithOptions(request *BatchCreateSoundCodeLabelRequest, runtime *util.RuntimeOptions) (_result *BatchCreateSoundCodeLabelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduleCode)) {
		body["ScheduleCode"] = request.ScheduleCode
	}

	if !tea.BoolValue(util.IsUnset(request.Total)) {
		body["Total"] = request.Total
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchCreateSoundCodeLabel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchCreateSoundCodeLabelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchCreateSoundCodeLabel(request *BatchCreateSoundCodeLabelRequest) (_result *BatchCreateSoundCodeLabelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchCreateSoundCodeLabelResponse{}
	_body, _err := client.BatchCreateSoundCodeLabelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchCreateSoundCodeLabelWithLabelsWithOptions(request *BatchCreateSoundCodeLabelWithLabelsRequest, runtime *util.RuntimeOptions) (_result *BatchCreateSoundCodeLabelWithLabelsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Labels)) {
		body["Labels"] = request.Labels
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduleCode)) {
		body["ScheduleCode"] = request.ScheduleCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchCreateSoundCodeLabelWithLabels"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchCreateSoundCodeLabelWithLabelsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchCreateSoundCodeLabelWithLabels(request *BatchCreateSoundCodeLabelWithLabelsRequest) (_result *BatchCreateSoundCodeLabelWithLabelsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchCreateSoundCodeLabelWithLabelsResponse{}
	_body, _err := client.BatchCreateSoundCodeLabelWithLabelsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchDeleteDeviceGroupRelationsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeleteDeviceGroupRelationsResponse
 */
func (client *Client) BatchDeleteDeviceGroupRelationsWithOptions(request *BatchDeleteDeviceGroupRelationsRequest, runtime *util.RuntimeOptions) (_result *BatchDeleteDeviceGroupRelationsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Device)) {
		query["Device"] = request.Device
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchDeleteDeviceGroupRelations"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchDeleteDeviceGroupRelationsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchDeleteDeviceGroupRelationsRequest
 * @return BatchDeleteDeviceGroupRelationsResponse
 */
func (client *Client) BatchDeleteDeviceGroupRelations(request *BatchDeleteDeviceGroupRelationsRequest) (_result *BatchDeleteDeviceGroupRelationsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchDeleteDeviceGroupRelationsResponse{}
	_body, _err := client.BatchDeleteDeviceGroupRelationsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchDeleteEdgeInstanceChannelWithOptions(request *BatchDeleteEdgeInstanceChannelRequest, runtime *util.RuntimeOptions) (_result *BatchDeleteEdgeInstanceChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChannelIds)) {
		query["ChannelIds"] = request.ChannelIds
	}

	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchDeleteEdgeInstanceChannel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchDeleteEdgeInstanceChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchDeleteEdgeInstanceChannel(request *BatchDeleteEdgeInstanceChannelRequest) (_result *BatchDeleteEdgeInstanceChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchDeleteEdgeInstanceChannelResponse{}
	_body, _err := client.BatchDeleteEdgeInstanceChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchGetDeviceBindStatusWithOptions(request *BatchGetDeviceBindStatusRequest, runtime *util.RuntimeOptions) (_result *BatchGetDeviceBindStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotIds)) {
		query["IotIds"] = request.IotIds
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchGetDeviceBindStatus"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchGetDeviceBindStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchGetDeviceBindStatus(request *BatchGetDeviceBindStatusRequest) (_result *BatchGetDeviceBindStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchGetDeviceBindStatusResponse{}
	_body, _err := client.BatchGetDeviceBindStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, you can perform the following operations:
 * *   You can specify a value for the **ProductKey** parameter and multiple values for the **DeviceName** parameter to query the status of devices that belong to a product.
 * *   You can specify multiple values for the **IotId** parameter to query the status of devices that belong to different products.****
 * >You can query the status of up to 50 devices in a call.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchGetDeviceStateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetDeviceStateResponse
 */
func (client *Client) BatchGetDeviceStateWithOptions(request *BatchGetDeviceStateRequest, runtime *util.RuntimeOptions) (_result *BatchGetDeviceStateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchGetDeviceState"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchGetDeviceStateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, you can perform the following operations:
 * *   You can specify a value for the **ProductKey** parameter and multiple values for the **DeviceName** parameter to query the status of devices that belong to a product.
 * *   You can specify multiple values for the **IotId** parameter to query the status of devices that belong to different products.****
 * >You can query the status of up to 50 devices in a call.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchGetDeviceStateRequest
 * @return BatchGetDeviceStateResponse
 */
func (client *Client) BatchGetDeviceState(request *BatchGetDeviceStateRequest) (_result *BatchGetDeviceStateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchGetDeviceStateResponse{}
	_body, _err := client.BatchGetDeviceStateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * A single Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users share the quota of the Alibaba Cloud account.
 *
 * @param request BatchGetEdgeDriverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetEdgeDriverResponse
 */
func (client *Client) BatchGetEdgeDriverWithOptions(request *BatchGetEdgeDriverRequest, runtime *util.RuntimeOptions) (_result *BatchGetEdgeDriverResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DriverIds)) {
		query["DriverIds"] = request.DriverIds
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchGetEdgeDriver"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchGetEdgeDriverResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * A single Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users share the quota of the Alibaba Cloud account.
 *
 * @param request BatchGetEdgeDriverRequest
 * @return BatchGetEdgeDriverResponse
 */
func (client *Client) BatchGetEdgeDriver(request *BatchGetEdgeDriverRequest) (_result *BatchGetEdgeDriverResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchGetEdgeDriverResponse{}
	_body, _err := client.BatchGetEdgeDriverWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchGetEdgeInstanceChannelWithOptions(request *BatchGetEdgeInstanceChannelRequest, runtime *util.RuntimeOptions) (_result *BatchGetEdgeInstanceChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChannelIds)) {
		query["ChannelIds"] = request.ChannelIds
	}

	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchGetEdgeInstanceChannel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchGetEdgeInstanceChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchGetEdgeInstanceChannel(request *BatchGetEdgeInstanceChannelRequest) (_result *BatchGetEdgeInstanceChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchGetEdgeInstanceChannelResponse{}
	_body, _err := client.BatchGetEdgeInstanceChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchGetEdgeInstanceDeviceChannelWithOptions(request *BatchGetEdgeInstanceDeviceChannelRequest, runtime *util.RuntimeOptions) (_result *BatchGetEdgeInstanceDeviceChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotIds)) {
		query["IotIds"] = request.IotIds
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchGetEdgeInstanceDeviceChannel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchGetEdgeInstanceDeviceChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchGetEdgeInstanceDeviceChannel(request *BatchGetEdgeInstanceDeviceChannelRequest) (_result *BatchGetEdgeInstanceDeviceChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchGetEdgeInstanceDeviceChannelResponse{}
	_body, _err := client.BatchGetEdgeInstanceDeviceChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchGetEdgeInstanceDeviceConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetEdgeInstanceDeviceConfigResponse
 */
func (client *Client) BatchGetEdgeInstanceDeviceConfigWithOptions(request *BatchGetEdgeInstanceDeviceConfigRequest, runtime *util.RuntimeOptions) (_result *BatchGetEdgeInstanceDeviceConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotIds)) {
		query["IotIds"] = request.IotIds
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchGetEdgeInstanceDeviceConfig"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchGetEdgeInstanceDeviceConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchGetEdgeInstanceDeviceConfigRequest
 * @return BatchGetEdgeInstanceDeviceConfigResponse
 */
func (client *Client) BatchGetEdgeInstanceDeviceConfig(request *BatchGetEdgeInstanceDeviceConfigRequest) (_result *BatchGetEdgeInstanceDeviceConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchGetEdgeInstanceDeviceConfigResponse{}
	_body, _err := client.BatchGetEdgeInstanceDeviceConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchGetEdgeInstanceDeviceDriverWithOptions(request *BatchGetEdgeInstanceDeviceDriverRequest, runtime *util.RuntimeOptions) (_result *BatchGetEdgeInstanceDeviceDriverResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotIds)) {
		query["IotIds"] = request.IotIds
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchGetEdgeInstanceDeviceDriver"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchGetEdgeInstanceDeviceDriverResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchGetEdgeInstanceDeviceDriver(request *BatchGetEdgeInstanceDeviceDriverRequest) (_result *BatchGetEdgeInstanceDeviceDriverResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchGetEdgeInstanceDeviceDriverResponse{}
	_body, _err := client.BatchGetEdgeInstanceDeviceDriverWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchGetEdgeInstanceDriverConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchGetEdgeInstanceDriverConfigsResponse
 */
func (client *Client) BatchGetEdgeInstanceDriverConfigsWithOptions(request *BatchGetEdgeInstanceDriverConfigsRequest, runtime *util.RuntimeOptions) (_result *BatchGetEdgeInstanceDriverConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DriverIds)) {
		query["DriverIds"] = request.DriverIds
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchGetEdgeInstanceDriverConfigs"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchGetEdgeInstanceDriverConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchGetEdgeInstanceDriverConfigsRequest
 * @return BatchGetEdgeInstanceDriverConfigsResponse
 */
func (client *Client) BatchGetEdgeInstanceDriverConfigs(request *BatchGetEdgeInstanceDriverConfigsRequest) (_result *BatchGetEdgeInstanceDriverConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchGetEdgeInstanceDriverConfigsResponse{}
	_body, _err := client.BatchGetEdgeInstanceDriverConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchGrayMigrationDeviceWithOptions(request *BatchGrayMigrationDeviceRequest, runtime *util.RuntimeOptions) (_result *BatchGrayMigrationDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceNames)) {
		body["DeviceNames"] = request.DeviceNames
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchGrayMigrationDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchGrayMigrationDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchGrayMigrationDevice(request *BatchGrayMigrationDeviceRequest) (_result *BatchGrayMigrationDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchGrayMigrationDeviceResponse{}
	_body, _err := client.BatchGrayMigrationDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * Before you call this operation, make sure that an MQTT gateway and the related product are created and the **ProductKey** of the product is obtained. For more information, see [Create an MQTT gateway](~~433804~~).
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchImportDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchImportDeviceResponse
 */
func (client *Client) BatchImportDeviceWithOptions(request *BatchImportDeviceRequest, runtime *util.RuntimeOptions) (_result *BatchImportDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceList)) {
		body["DeviceList"] = request.DeviceList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchImportDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchImportDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * Before you call this operation, make sure that an MQTT gateway and the related product are created and the **ProductKey** of the product is obtained. For more information, see [Create an MQTT gateway](~~433804~~).
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchImportDeviceRequest
 * @return BatchImportDeviceResponse
 */
func (client *Client) BatchImportDevice(request *BatchImportDeviceRequest) (_result *BatchImportDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchImportDeviceResponse{}
	_body, _err := client.BatchImportDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Indicates whether the call was successful. Valid values:
 * - **true**: The call was successful.
 * - **false**: The call failed.
 *
 * @param request BatchImportVehicleDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchImportVehicleDeviceResponse
 */
func (client *Client) BatchImportVehicleDeviceWithOptions(request *BatchImportVehicleDeviceRequest, runtime *util.RuntimeOptions) (_result *BatchImportVehicleDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceList)) {
		body["DeviceList"] = request.DeviceList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchImportVehicleDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchImportVehicleDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Indicates whether the call was successful. Valid values:
 * - **true**: The call was successful.
 * - **false**: The call failed.
 *
 * @param request BatchImportVehicleDeviceRequest
 * @return BatchImportVehicleDeviceResponse
 */
func (client *Client) BatchImportVehicleDevice(request *BatchImportVehicleDeviceRequest) (_result *BatchImportVehicleDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchImportVehicleDeviceResponse{}
	_body, _err := client.BatchImportVehicleDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation to publish a message to a maximum of 100 devices of a product at a time.
 * *   The BatchPub operation cannot be used to send commands of setting properties or calling services. If you need to set properties, use the [SetDeviceProperty](~~69579~~) or [SetDevicesProperty](~~96243~~) operation. If you need to call services, use the [InvokeThingService](~~69584~~) or [InvokeThingsService](~~96242~~) operation.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchPubRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchPubResponse
 */
func (client *Client) BatchPubWithOptions(request *BatchPubRequest, runtime *util.RuntimeOptions) (_result *BatchPubResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MessageContent)) {
		query["MessageContent"] = request.MessageContent
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Qos)) {
		query["Qos"] = request.Qos
	}

	if !tea.BoolValue(util.IsUnset(request.TopicShortName)) {
		query["TopicShortName"] = request.TopicShortName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchPub"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchPubResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation to publish a message to a maximum of 100 devices of a product at a time.
 * *   The BatchPub operation cannot be used to send commands of setting properties or calling services. If you need to set properties, use the [SetDeviceProperty](~~69579~~) or [SetDevicesProperty](~~96243~~) operation. If you need to call services, use the [InvokeThingService](~~69584~~) or [InvokeThingsService](~~96242~~) operation.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchPubRequest
 * @return BatchPubResponse
 */
func (client *Client) BatchPub(request *BatchPubRequest) (_result *BatchPubResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchPubResponse{}
	_body, _err := client.BatchPubWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   You can query a maximum of 100 devices in a single call.
 * *   You can query the details of devices that belong only to the current Alibaba Cloud account. If you specify a device that does not belong to the current account, an error message is returned.
 * *   If you specify multiple devices and some devices do not exist, only the details of existing devices are returned.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchQueryDeviceDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchQueryDeviceDetailResponse
 */
func (client *Client) BatchQueryDeviceDetailWithOptions(request *BatchQueryDeviceDetailRequest, runtime *util.RuntimeOptions) (_result *BatchQueryDeviceDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchQueryDeviceDetail"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchQueryDeviceDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   You can query a maximum of 100 devices in a single call.
 * *   You can query the details of devices that belong only to the current Alibaba Cloud account. If you specify a device that does not belong to the current account, an error message is returned.
 * *   If you specify multiple devices and some devices do not exist, only the details of existing devices are returned.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchQueryDeviceDetailRequest
 * @return BatchQueryDeviceDetailResponse
 */
func (client *Client) BatchQueryDeviceDetail(request *BatchQueryDeviceDetailRequest) (_result *BatchQueryDeviceDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchQueryDeviceDetailResponse{}
	_body, _err := client.BatchQueryDeviceDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can use one of the following methods to register multiple devices:
 * *   If you want to generate random DeviceNames, call the BatchRegisterDevice operation.
 *     Perform the following steps to register devices and view the result:
 *     1\\. Call the BatchRegisterDevice operation to register multiple devices. A successful response indicates that the registration request is submitted. The actual registration process is asynchronously implemented and takes some minutes.
 *     2\\. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the device registration result.
 *     3\\. Call the [QueryPageByApplyId](~~69518~~) operation to view the details of registered devices. The details include the DeviceName, DeviceSecret, and IotId parameters.
 * *   If you want to specify custom DeviceNames, call the BatchRegisterDeviceWithApplyId operation. For more information, see [BatchRegisterDeviceWithApplyId](~~69514~~).
 * ## Limits
 * - You can create a maximum of 10,000 devices in a single call.
 * - Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchRegisterDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchRegisterDeviceResponse
 */
func (client *Client) BatchRegisterDeviceWithOptions(request *BatchRegisterDeviceRequest, runtime *util.RuntimeOptions) (_result *BatchRegisterDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Count)) {
		query["Count"] = request.Count
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchRegisterDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchRegisterDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can use one of the following methods to register multiple devices:
 * *   If you want to generate random DeviceNames, call the BatchRegisterDevice operation.
 *     Perform the following steps to register devices and view the result:
 *     1\\. Call the BatchRegisterDevice operation to register multiple devices. A successful response indicates that the registration request is submitted. The actual registration process is asynchronously implemented and takes some minutes.
 *     2\\. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the device registration result.
 *     3\\. Call the [QueryPageByApplyId](~~69518~~) operation to view the details of registered devices. The details include the DeviceName, DeviceSecret, and IotId parameters.
 * *   If you want to specify custom DeviceNames, call the BatchRegisterDeviceWithApplyId operation. For more information, see [BatchRegisterDeviceWithApplyId](~~69514~~).
 * ## Limits
 * - You can create a maximum of 10,000 devices in a single call.
 * - Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchRegisterDeviceRequest
 * @return BatchRegisterDeviceResponse
 */
func (client *Client) BatchRegisterDevice(request *BatchRegisterDeviceRequest) (_result *BatchRegisterDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchRegisterDeviceResponse{}
	_body, _err := client.BatchRegisterDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can use one of the following methods to register multiple devices at a time:
 * *   Call the [BatchRegisterDevice](~~69473~~) operation to generate random DeviceNames.
 * *   Call the BatchRegisterDeviceWithApplyId and **BatchCheckDeviceNames** operations to specify custom DeviceNames. Procedure:
 *     Call the [BatchCheckDeviceNames](~~69482~~) operation and specify the names of devices that you want to register. If the DeviceNames are valid, IoT Platform returns an application ID that is specified by the **ApplyId** parameter. You can query the DeviceName setting results, device registration results, and device details by **ApplyId**.
 *     Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the name setting result.
 *     Call the BatchRegisterDeviceWithApplyId operation to register multiple devices. The successful result that is returned by this operation indicates that only the batch registration request is submitted. In actual scenarios, the registration process takes a few minutes.
 *     Optional. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the device registration result.
 *     Call the [QueryPageByApplyId](~~69518~~) operation to view the details of devices that are registered in batches.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request BatchRegisterDeviceWithApplyIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchRegisterDeviceWithApplyIdResponse
 */
func (client *Client) BatchRegisterDeviceWithApplyIdWithOptions(request *BatchRegisterDeviceWithApplyIdRequest, runtime *util.RuntimeOptions) (_result *BatchRegisterDeviceWithApplyIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApplyId)) {
		query["ApplyId"] = request.ApplyId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchRegisterDeviceWithApplyId"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchRegisterDeviceWithApplyIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can use one of the following methods to register multiple devices at a time:
 * *   Call the [BatchRegisterDevice](~~69473~~) operation to generate random DeviceNames.
 * *   Call the BatchRegisterDeviceWithApplyId and **BatchCheckDeviceNames** operations to specify custom DeviceNames. Procedure:
 *     Call the [BatchCheckDeviceNames](~~69482~~) operation and specify the names of devices that you want to register. If the DeviceNames are valid, IoT Platform returns an application ID that is specified by the **ApplyId** parameter. You can query the DeviceName setting results, device registration results, and device details by **ApplyId**.
 *     Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the name setting result.
 *     Call the BatchRegisterDeviceWithApplyId operation to register multiple devices. The successful result that is returned by this operation indicates that only the batch registration request is submitted. In actual scenarios, the registration process takes a few minutes.
 *     Optional. Call the [QueryBatchRegisterDeviceStatus](~~69483~~) operation to query the device registration result.
 *     Call the [QueryPageByApplyId](~~69518~~) operation to view the details of devices that are registered in batches.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request BatchRegisterDeviceWithApplyIdRequest
 * @return BatchRegisterDeviceWithApplyIdResponse
 */
func (client *Client) BatchRegisterDeviceWithApplyId(request *BatchRegisterDeviceWithApplyIdRequest) (_result *BatchRegisterDeviceWithApplyIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchRegisterDeviceWithApplyIdResponse{}
	_body, _err := client.BatchRegisterDeviceWithApplyIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchSetEdgeInstanceDeviceChannelWithOptions(request *BatchSetEdgeInstanceDeviceChannelRequest, runtime *util.RuntimeOptions) (_result *BatchSetEdgeInstanceDeviceChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChannelId)) {
		query["ChannelId"] = request.ChannelId
	}

	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotIds)) {
		query["IotIds"] = request.IotIds
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchSetEdgeInstanceDeviceChannel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchSetEdgeInstanceDeviceChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchSetEdgeInstanceDeviceChannel(request *BatchSetEdgeInstanceDeviceChannelRequest) (_result *BatchSetEdgeInstanceDeviceChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchSetEdgeInstanceDeviceChannelResponse{}
	_body, _err := client.BatchSetEdgeInstanceDeviceChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchSetEdgeInstanceDeviceConfigWithOptions(request *BatchSetEdgeInstanceDeviceConfigRequest, runtime *util.RuntimeOptions) (_result *BatchSetEdgeInstanceDeviceConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceConfigs)) {
		query["DeviceConfigs"] = request.DeviceConfigs
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchSetEdgeInstanceDeviceConfig"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchSetEdgeInstanceDeviceConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchSetEdgeInstanceDeviceConfig(request *BatchSetEdgeInstanceDeviceConfigRequest) (_result *BatchSetEdgeInstanceDeviceConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchSetEdgeInstanceDeviceConfigResponse{}
	_body, _err := client.BatchSetEdgeInstanceDeviceConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchUnbindDeviceFromEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchUnbindDeviceFromEdgeInstanceResponse
 */
func (client *Client) BatchUnbindDeviceFromEdgeInstanceWithOptions(request *BatchUnbindDeviceFromEdgeInstanceRequest, runtime *util.RuntimeOptions) (_result *BatchUnbindDeviceFromEdgeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotIds)) {
		query["IotIds"] = request.IotIds
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchUnbindDeviceFromEdgeInstance"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchUnbindDeviceFromEdgeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchUnbindDeviceFromEdgeInstanceRequest
 * @return BatchUnbindDeviceFromEdgeInstanceResponse
 */
func (client *Client) BatchUnbindDeviceFromEdgeInstance(request *BatchUnbindDeviceFromEdgeInstanceRequest) (_result *BatchUnbindDeviceFromEdgeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchUnbindDeviceFromEdgeInstanceResponse{}
	_body, _err := client.BatchUnbindDeviceFromEdgeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchUnbindProjectDevicesWithOptions(request *BatchUnbindProjectDevicesRequest, runtime *util.RuntimeOptions) (_result *BatchUnbindProjectDevicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Devices)) {
		body["Devices"] = request.Devices
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchUnbindProjectDevices"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchUnbindProjectDevicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchUnbindProjectDevices(request *BatchUnbindProjectDevicesRequest) (_result *BatchUnbindProjectDevicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchUnbindProjectDevicesResponse{}
	_body, _err := client.BatchUnbindProjectDevicesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BatchUnbindProjectProductsWithOptions(request *BatchUnbindProjectProductsRequest, runtime *util.RuntimeOptions) (_result *BatchUnbindProjectProductsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKeys)) {
		body["ProductKeys"] = request.ProductKeys
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchUnbindProjectProducts"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchUnbindProjectProductsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BatchUnbindProjectProducts(request *BatchUnbindProjectProductsRequest) (_result *BatchUnbindProjectProductsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchUnbindProjectProductsResponse{}
	_body, _err := client.BatchUnbindProjectProductsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchUpdateDeviceNicknameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchUpdateDeviceNicknameResponse
 */
func (client *Client) BatchUpdateDeviceNicknameWithOptions(request *BatchUpdateDeviceNicknameRequest, runtime *util.RuntimeOptions) (_result *BatchUpdateDeviceNicknameResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceNicknameInfo)) {
		query["DeviceNicknameInfo"] = request.DeviceNicknameInfo
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BatchUpdateDeviceNickname"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BatchUpdateDeviceNicknameResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BatchUpdateDeviceNicknameRequest
 * @return BatchUpdateDeviceNicknameResponse
 */
func (client *Client) BatchUpdateDeviceNickname(request *BatchUpdateDeviceNicknameRequest) (_result *BatchUpdateDeviceNicknameResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BatchUpdateDeviceNicknameResponse{}
	_body, _err := client.BatchUpdateDeviceNicknameWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BindApplicationToEdgeInstanceWithOptions(request *BindApplicationToEdgeInstanceRequest, runtime *util.RuntimeOptions) (_result *BindApplicationToEdgeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApplicationId)) {
		query["ApplicationId"] = request.ApplicationId
	}

	if !tea.BoolValue(util.IsUnset(request.ApplicationVersion)) {
		query["ApplicationVersion"] = request.ApplicationVersion
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BindApplicationToEdgeInstance"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BindApplicationToEdgeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BindApplicationToEdgeInstance(request *BindApplicationToEdgeInstanceRequest) (_result *BindApplicationToEdgeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BindApplicationToEdgeInstanceResponse{}
	_body, _err := client.BindApplicationToEdgeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BindDriverToEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindDriverToEdgeInstanceResponse
 */
func (client *Client) BindDriverToEdgeInstanceWithOptions(request *BindDriverToEdgeInstanceRequest, runtime *util.RuntimeOptions) (_result *BindDriverToEdgeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.DriverVersion)) {
		query["DriverVersion"] = request.DriverVersion
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OrderId)) {
		query["OrderId"] = request.OrderId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BindDriverToEdgeInstance"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BindDriverToEdgeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BindDriverToEdgeInstanceRequest
 * @return BindDriverToEdgeInstanceResponse
 */
func (client *Client) BindDriverToEdgeInstance(request *BindDriverToEdgeInstanceRequest) (_result *BindDriverToEdgeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BindDriverToEdgeInstanceResponse{}
	_body, _err := client.BindDriverToEdgeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BindGatewayToEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindGatewayToEdgeInstanceResponse
 */
func (client *Client) BindGatewayToEdgeInstanceWithOptions(request *BindGatewayToEdgeInstanceRequest, runtime *util.RuntimeOptions) (_result *BindGatewayToEdgeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BindGatewayToEdgeInstance"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BindGatewayToEdgeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BindGatewayToEdgeInstanceRequest
 * @return BindGatewayToEdgeInstanceResponse
 */
func (client *Client) BindGatewayToEdgeInstance(request *BindGatewayToEdgeInstanceRequest) (_result *BindGatewayToEdgeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BindGatewayToEdgeInstanceResponse{}
	_body, _err := client.BindGatewayToEdgeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * Before you call this operation, make sure that the following steps are complete:
 * 1.  A license is purchased. For more information, see [Purchase a license](~~427935~~).
 * 2.  The license is bound to a product. The devices to which you want to bind the license belong to the product. For more information, see [BindLicenseProduct](~~427956~~) or [Bind a license to a product](~~427937~~).
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BindLicenseDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindLicenseDeviceResponse
 */
func (client *Client) BindLicenseDeviceWithOptions(request *BindLicenseDeviceRequest, runtime *util.RuntimeOptions) (_result *BindLicenseDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.LicenseCode)) {
		query["LicenseCode"] = request.LicenseCode
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceNameList)) {
		body["DeviceNameList"] = request.DeviceNameList
	}

	if !tea.BoolValue(util.IsUnset(request.IotIdList)) {
		body["IotIdList"] = request.IotIdList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("BindLicenseDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BindLicenseDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * Before you call this operation, make sure that the following steps are complete:
 * 1.  A license is purchased. For more information, see [Purchase a license](~~427935~~).
 * 2.  The license is bound to a product. The devices to which you want to bind the license belong to the product. For more information, see [BindLicenseProduct](~~427956~~) or [Bind a license to a product](~~427937~~).
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request BindLicenseDeviceRequest
 * @return BindLicenseDeviceResponse
 */
func (client *Client) BindLicenseDevice(request *BindLicenseDeviceRequest) (_result *BindLicenseDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BindLicenseDeviceResponse{}
	_body, _err := client.BindLicenseDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BindLicenseProductWithOptions(request *BindLicenseProductRequest, runtime *util.RuntimeOptions) (_result *BindLicenseProductResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.LicenseCode)) {
		query["LicenseCode"] = request.LicenseCode
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BindLicenseProduct"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BindLicenseProductResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BindLicenseProduct(request *BindLicenseProductRequest) (_result *BindLicenseProductResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BindLicenseProductResponse{}
	_body, _err := client.BindLicenseProductWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BindRoleToEdgeInstanceWithOptions(request *BindRoleToEdgeInstanceRequest, runtime *util.RuntimeOptions) (_result *BindRoleToEdgeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RoleArn)) {
		query["RoleArn"] = request.RoleArn
	}

	if !tea.BoolValue(util.IsUnset(request.RoleName)) {
		query["RoleName"] = request.RoleName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BindRoleToEdgeInstance"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BindRoleToEdgeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BindRoleToEdgeInstance(request *BindRoleToEdgeInstanceRequest) (_result *BindRoleToEdgeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BindRoleToEdgeInstanceResponse{}
	_body, _err := client.BindRoleToEdgeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) BindSceneRuleToEdgeInstanceWithOptions(request *BindSceneRuleToEdgeInstanceRequest, runtime *util.RuntimeOptions) (_result *BindSceneRuleToEdgeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("BindSceneRuleToEdgeInstance"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &BindSceneRuleToEdgeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) BindSceneRuleToEdgeInstance(request *BindSceneRuleToEdgeInstanceRequest) (_result *BindSceneRuleToEdgeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &BindSceneRuleToEdgeInstanceResponse{}
	_body, _err := client.BindSceneRuleToEdgeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CancelJobWithOptions(request *CancelJobRequest, runtime *util.RuntimeOptions) (_result *CancelJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CancelJob(request *CancelJobRequest) (_result *CancelJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CancelJobResponse{}
	_body, _err := client.CancelJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   You can cancel only the dynamic update policy that is attached to a dynamic update batch. This operation is not applicable to static update batches.
 *     After the operation is successful, the **JobStatus** parameter is set to CANCELED.
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CancelOTAStrategyByJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelOTAStrategyByJobResponse
 */
func (client *Client) CancelOTAStrategyByJobWithOptions(request *CancelOTAStrategyByJobRequest, runtime *util.RuntimeOptions) (_result *CancelOTAStrategyByJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelOTAStrategyByJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelOTAStrategyByJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   You can cancel only the dynamic update policy that is attached to a dynamic update batch. This operation is not applicable to static update batches.
 *     After the operation is successful, the **JobStatus** parameter is set to CANCELED.
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CancelOTAStrategyByJobRequest
 * @return CancelOTAStrategyByJobResponse
 */
func (client *Client) CancelOTAStrategyByJob(request *CancelOTAStrategyByJobRequest) (_result *CancelOTAStrategyByJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CancelOTAStrategyByJobResponse{}
	_body, _err := client.CancelOTAStrategyByJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation can cancel device update tasks only when the tasks are in the to be pushed, pushed, or in upgrade state.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request CancelOTATaskByDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelOTATaskByDeviceResponse
 */
func (client *Client) CancelOTATaskByDeviceWithOptions(request *CancelOTATaskByDeviceRequest, runtime *util.RuntimeOptions) (_result *CancelOTATaskByDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.FirmwareId)) {
		query["FirmwareId"] = request.FirmwareId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelOTATaskByDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelOTATaskByDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation can cancel device update tasks only when the tasks are in the to be pushed, pushed, or in upgrade state.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request CancelOTATaskByDeviceRequest
 * @return CancelOTATaskByDeviceResponse
 */
func (client *Client) CancelOTATaskByDevice(request *CancelOTATaskByDeviceRequest) (_result *CancelOTATaskByDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CancelOTATaskByDeviceResponse{}
	_body, _err := client.CancelOTATaskByDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, make sure that you specify at least one of the CancelScheduledTask, CancelQueuedTask, CancelInProgressTask, CancelNotifiedTask, and CancelUnconfirmedTask parameters. Otherwise, the request will fail.
 * ## QPS limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CancelOTATaskByJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelOTATaskByJobResponse
 */
func (client *Client) CancelOTATaskByJobWithOptions(request *CancelOTATaskByJobRequest, runtime *util.RuntimeOptions) (_result *CancelOTATaskByJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CancelInProgressTask)) {
		query["CancelInProgressTask"] = request.CancelInProgressTask
	}

	if !tea.BoolValue(util.IsUnset(request.CancelNotifiedTask)) {
		query["CancelNotifiedTask"] = request.CancelNotifiedTask
	}

	if !tea.BoolValue(util.IsUnset(request.CancelQueuedTask)) {
		query["CancelQueuedTask"] = request.CancelQueuedTask
	}

	if !tea.BoolValue(util.IsUnset(request.CancelScheduledTask)) {
		query["CancelScheduledTask"] = request.CancelScheduledTask
	}

	if !tea.BoolValue(util.IsUnset(request.CancelUnconfirmedTask)) {
		query["CancelUnconfirmedTask"] = request.CancelUnconfirmedTask
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelOTATaskByJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelOTATaskByJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, make sure that you specify at least one of the CancelScheduledTask, CancelQueuedTask, CancelInProgressTask, CancelNotifiedTask, and CancelUnconfirmedTask parameters. Otherwise, the request will fail.
 * ## QPS limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CancelOTATaskByJobRequest
 * @return CancelOTATaskByJobResponse
 */
func (client *Client) CancelOTATaskByJob(request *CancelOTATaskByJobRequest) (_result *CancelOTATaskByJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CancelOTATaskByJobResponse{}
	_body, _err := client.CancelOTATaskByJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CancelReleaseProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelReleaseProductResponse
 */
func (client *Client) CancelReleaseProductWithOptions(request *CancelReleaseProductRequest, runtime *util.RuntimeOptions) (_result *CancelReleaseProductResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CancelReleaseProduct"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CancelReleaseProductResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CancelReleaseProductRequest
 * @return CancelReleaseProductResponse
 */
func (client *Client) CancelReleaseProduct(request *CancelReleaseProductRequest) (_result *CancelReleaseProductResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CancelReleaseProductResponse{}
	_body, _err := client.CancelReleaseProductWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CheckBindLicenseDeviceProgressWithOptions(request *CheckBindLicenseDeviceProgressRequest, runtime *util.RuntimeOptions) (_result *CheckBindLicenseDeviceProgressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CheckProgressId)) {
		query["CheckProgressId"] = request.CheckProgressId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.LicenseCode)) {
		query["LicenseCode"] = request.LicenseCode
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CheckBindLicenseDeviceProgress"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CheckBindLicenseDeviceProgressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CheckBindLicenseDeviceProgress(request *CheckBindLicenseDeviceProgressRequest) (_result *CheckBindLicenseDeviceProgressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CheckBindLicenseDeviceProgressResponse{}
	_body, _err := client.CheckBindLicenseDeviceProgressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   Each time you call this operation, you must specify the identifiers of properties whose desired values you want to delete for the **Identifies** parameter. If you do not configure the **Identifies** parameter, the call fails.
 * *   You can specify up to 10 property identifiers for the **Identifies** parameter in a single call.
 * *   After you call this operation to deletes the desired values of properties of a device, you can call the [QueryDeviceDesiredProperty](~~107566~~) operation to query the desired values of properties of the device. In this case, the QueryDeviceDesiredProperty operation returns the **Identifier** parameter instead of the **Value** parameter.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ClearDeviceDesiredPropertyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ClearDeviceDesiredPropertyResponse
 */
func (client *Client) ClearDeviceDesiredPropertyWithOptions(request *ClearDeviceDesiredPropertyRequest, runtime *util.RuntimeOptions) (_result *ClearDeviceDesiredPropertyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Identifies)) {
		body["Identifies"] = request.Identifies
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ClearDeviceDesiredProperty"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ClearDeviceDesiredPropertyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   Each time you call this operation, you must specify the identifiers of properties whose desired values you want to delete for the **Identifies** parameter. If you do not configure the **Identifies** parameter, the call fails.
 * *   You can specify up to 10 property identifiers for the **Identifies** parameter in a single call.
 * *   After you call this operation to deletes the desired values of properties of a device, you can call the [QueryDeviceDesiredProperty](~~107566~~) operation to query the desired values of properties of the device. In this case, the QueryDeviceDesiredProperty operation returns the **Identifier** parameter instead of the **Value** parameter.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ClearDeviceDesiredPropertyRequest
 * @return ClearDeviceDesiredPropertyResponse
 */
func (client *Client) ClearDeviceDesiredProperty(request *ClearDeviceDesiredPropertyRequest) (_result *ClearDeviceDesiredPropertyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ClearDeviceDesiredPropertyResponse{}
	_body, _err := client.ClearDeviceDesiredPropertyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ClearEdgeInstanceDriverConfigsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ClearEdgeInstanceDriverConfigsResponse
 */
func (client *Client) ClearEdgeInstanceDriverConfigsWithOptions(request *ClearEdgeInstanceDriverConfigsRequest, runtime *util.RuntimeOptions) (_result *ClearEdgeInstanceDriverConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ClearEdgeInstanceDriverConfigs"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ClearEdgeInstanceDriverConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ClearEdgeInstanceDriverConfigsRequest
 * @return ClearEdgeInstanceDriverConfigsResponse
 */
func (client *Client) ClearEdgeInstanceDriverConfigs(request *ClearEdgeInstanceDriverConfigsRequest) (_result *ClearEdgeInstanceDriverConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ClearEdgeInstanceDriverConfigsResponse{}
	_body, _err := client.ClearEdgeInstanceDriverConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CloseDeviceTunnelWithOptions(request *CloseDeviceTunnelRequest, runtime *util.RuntimeOptions) (_result *CloseDeviceTunnelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TunnelId)) {
		query["TunnelId"] = request.TunnelId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CloseDeviceTunnel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CloseDeviceTunnelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CloseDeviceTunnel(request *CloseDeviceTunnelRequest) (_result *CloseDeviceTunnelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CloseDeviceTunnelResponse{}
	_body, _err := client.CloseDeviceTunnelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CloseEdgeInstanceDeploymentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CloseEdgeInstanceDeploymentResponse
 */
func (client *Client) CloseEdgeInstanceDeploymentWithOptions(request *CloseEdgeInstanceDeploymentRequest, runtime *util.RuntimeOptions) (_result *CloseEdgeInstanceDeploymentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CloseEdgeInstanceDeployment"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CloseEdgeInstanceDeploymentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CloseEdgeInstanceDeploymentRequest
 * @return CloseEdgeInstanceDeploymentResponse
 */
func (client *Client) CloseEdgeInstanceDeployment(request *CloseEdgeInstanceDeploymentRequest) (_result *CloseEdgeInstanceDeploymentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CloseEdgeInstanceDeploymentResponse{}
	_body, _err := client.CloseEdgeInstanceDeploymentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * To confirm update tasks in a scheduled update batch, you must call this operation within the specified time range.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ConfirmOTATaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfirmOTATaskResponse
 */
func (client *Client) ConfirmOTATaskWithOptions(request *ConfirmOTATaskRequest, runtime *util.RuntimeOptions) (_result *ConfirmOTATaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ConfirmOTATask"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ConfirmOTATaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * To confirm update tasks in a scheduled update batch, you must call this operation within the specified time range.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ConfirmOTATaskRequest
 * @return ConfirmOTATaskResponse
 */
func (client *Client) ConfirmOTATask(request *ConfirmOTATaskRequest) (_result *ConfirmOTATaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ConfirmOTATaskResponse{}
	_body, _err := client.ConfirmOTATaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If a destination product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you can copy a TSL model.
 * *   The categories of the source product and destination product must be the same. The product category is indicated by the **CategoryKey** parameter. You can call the [QueryProduct](~~69272~~) operation and view the **CategoryKey** parameter of a product in the returned result.
 * *   You must specify the version of the TSL model that you want to copy by using the **SourceModelVersion** parameter in the request. Otherwise, the CopyThingModel operation fails.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to five queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CopyThingModelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CopyThingModelResponse
 */
func (client *Client) CopyThingModelWithOptions(request *CopyThingModelRequest, runtime *util.RuntimeOptions) (_result *CopyThingModelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceModelVersion)) {
		query["SourceModelVersion"] = request.SourceModelVersion
	}

	if !tea.BoolValue(util.IsUnset(request.SourceProductKey)) {
		query["SourceProductKey"] = request.SourceProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.TargetProductKey)) {
		query["TargetProductKey"] = request.TargetProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CopyThingModel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CopyThingModelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If a destination product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you can copy a TSL model.
 * *   The categories of the source product and destination product must be the same. The product category is indicated by the **CategoryKey** parameter. You can call the [QueryProduct](~~69272~~) operation and view the **CategoryKey** parameter of a product in the returned result.
 * *   You must specify the version of the TSL model that you want to copy by using the **SourceModelVersion** parameter in the request. Otherwise, the CopyThingModel operation fails.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to five queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CopyThingModelRequest
 * @return CopyThingModelResponse
 */
func (client *Client) CopyThingModel(request *CopyThingModelRequest) (_result *CopyThingModelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CopyThingModelResponse{}
	_body, _err := client.CopyThingModelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * You can call this operation to query the shared speeches that were broadcasted six hours ago. For example, if a speech was broadcasted at 07:15, you can query the speech after 13:15.
 * ## QPS limits
 * You can call this API operation up to 100 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CountSpeechBroadcastHourRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CountSpeechBroadcastHourResponse
 */
func (client *Client) CountSpeechBroadcastHourWithOptions(request *CountSpeechBroadcastHourRequest, runtime *util.RuntimeOptions) (_result *CountSpeechBroadcastHourResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.QueryDateTimeHour)) {
		query["QueryDateTimeHour"] = request.QueryDateTimeHour
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ShareTaskCode)) {
		body["ShareTaskCode"] = request.ShareTaskCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CountSpeechBroadcastHour"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CountSpeechBroadcastHourResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * You can call this operation to query the shared speeches that were broadcasted six hours ago. For example, if a speech was broadcasted at 07:15, you can query the speech after 13:15.
 * ## QPS limits
 * You can call this API operation up to 100 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CountSpeechBroadcastHourRequest
 * @return CountSpeechBroadcastHourResponse
 */
func (client *Client) CountSpeechBroadcastHour(request *CountSpeechBroadcastHourRequest) (_result *CountSpeechBroadcastHourResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CountSpeechBroadcastHourResponse{}
	_body, _err := client.CountSpeechBroadcastHourWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateConsumerGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConsumerGroupResponse
 */
func (client *Client) CreateConsumerGroupWithOptions(request *CreateConsumerGroupRequest, runtime *util.RuntimeOptions) (_result *CreateConsumerGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SubBizCode)) {
		query["SubBizCode"] = request.SubBizCode
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateConsumerGroup"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateConsumerGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateConsumerGroupRequest
 * @return CreateConsumerGroupResponse
 */
func (client *Client) CreateConsumerGroup(request *CreateConsumerGroupRequest) (_result *CreateConsumerGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateConsumerGroupResponse{}
	_body, _err := client.CreateConsumerGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateConsumerGroupSubscribeRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateConsumerGroupSubscribeRelationResponse
 */
func (client *Client) CreateConsumerGroupSubscribeRelationWithOptions(request *CreateConsumerGroupSubscribeRelationRequest, runtime *util.RuntimeOptions) (_result *CreateConsumerGroupSubscribeRelationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConsumerGroupId)) {
		query["ConsumerGroupId"] = request.ConsumerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateConsumerGroupSubscribeRelation"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateConsumerGroupSubscribeRelationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateConsumerGroupSubscribeRelationRequest
 * @return CreateConsumerGroupSubscribeRelationResponse
 */
func (client *Client) CreateConsumerGroupSubscribeRelation(request *CreateConsumerGroupSubscribeRelationRequest) (_result *CreateConsumerGroupSubscribeRelationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateConsumerGroupSubscribeRelationResponse{}
	_body, _err := client.CreateConsumerGroupSubscribeRelationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDataAPIServiceWithOptions(request *CreateDataAPIServiceRequest, runtime *util.RuntimeOptions) (_result *CreateDataAPIServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiPath)) {
		body["ApiPath"] = request.ApiPath
	}

	if !tea.BoolValue(util.IsUnset(request.Desc)) {
		body["Desc"] = request.Desc
	}

	if !tea.BoolValue(util.IsUnset(request.DisplayName)) {
		body["DisplayName"] = request.DisplayName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.OriginSql)) {
		body["OriginSql"] = request.OriginSql
	}

	if !tea.BoolValue(util.IsUnset(request.RequestParam)) {
		body["RequestParam"] = request.RequestParam
	}

	if !tea.BoolValue(util.IsUnset(request.ResponseParam)) {
		body["ResponseParam"] = request.ResponseParam
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateSql)) {
		body["TemplateSql"] = request.TemplateSql
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDataAPIService"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDataAPIServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDataAPIService(request *CreateDataAPIServiceRequest) (_result *CreateDataAPIServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDataAPIServiceResponse{}
	_body, _err := client.CreateDataAPIServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * Before you call this operation, perform the following steps: First, create a data source. For information about how to create a data source, see Step 1 to Step 6 in the [Create a data source](~~270932~~) topic. Second, go to the **Data Source** tab on the **Message Forwarding** page of the instance that you want to manage in the IoT Platform console. Then, view and record the ID of the **data source** that you created.
 * >  If you set Topic to a custom topic for a product or device that uses the open source Message Queuing Telemetry Transport (MQTT) protocol, you must specify ScopeType and ProductKey. If ScopeType is set to DEVICE, you must also specify DeviceName.
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateDataSourceItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataSourceItemResponse
 */
func (client *Client) CreateDataSourceItemWithOptions(request *CreateDataSourceItemRequest, runtime *util.RuntimeOptions) (_result *CreateDataSourceItemResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataSourceId)) {
		query["DataSourceId"] = request.DataSourceId
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ScopeType)) {
		query["ScopeType"] = request.ScopeType
	}

	if !tea.BoolValue(util.IsUnset(request.Topic)) {
		query["Topic"] = request.Topic
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDataSourceItem"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDataSourceItemResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * Before you call this operation, perform the following steps: First, create a data source. For information about how to create a data source, see Step 1 to Step 6 in the [Create a data source](~~270932~~) topic. Second, go to the **Data Source** tab on the **Message Forwarding** page of the instance that you want to manage in the IoT Platform console. Then, view and record the ID of the **data source** that you created.
 * >  If you set Topic to a custom topic for a product or device that uses the open source Message Queuing Telemetry Transport (MQTT) protocol, you must specify ScopeType and ProductKey. If ScopeType is set to DEVICE, you must also specify DeviceName.
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateDataSourceItemRequest
 * @return CreateDataSourceItemResponse
 */
func (client *Client) CreateDataSourceItem(request *CreateDataSourceItemRequest) (_result *CreateDataSourceItemResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDataSourceItemResponse{}
	_body, _err := client.CreateDataSourceItemWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDestinationWithOptions(request *CreateDestinationRequest, runtime *util.RuntimeOptions) (_result *CreateDestinationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		query["Configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDestination"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDestinationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDestination(request *CreateDestinationRequest) (_result *CreateDestinationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDestinationResponse{}
	_body, _err := client.CreateDestinationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * To distribute devices, perform the following steps:
 * 1\\. Asynchronously call this operation to create a device distribution task and obtain the **JobId** parameter.
 * 2\\. Use **JobId** as a request parameter and repeatedly call the [QueryDeviceDistributeJob](~~199536~~) operation to obtain the **Status** parameter.
 * >  You must control the frequency of calls based on the QPS limit of the QueryDeviceDistributeJob operation.
 * If either of the following values is returned for the **Status** parameter, the distribution task ends:
 * *   **2**: The device distribution task is completed. This return value does not indicate that the devices are distributed. To obtain the distribution result of each device, perform the next step.
 * *   **3**: The distribution is unexpectedly interrupted. After you process the error, you can initiate a device distribution task again.
 * 3\\. Use **JobId** that is returned in Step 1 as a request parameter and call the [QueryDeviceDistributeDetail](~~199533~~) operation to obtain the **File** parameter. The File parameter indicates the file URL of the distribution result.
 * >  The file URL is valid for 10 minutes.
 * 4\\. Obtain the distribution result by using the file URL. The **Code** parameter indicates whether a device is distributed. If the value of the **Code** parameter is 200, the device is distributed.
 * If the distribution fails, you can perform the preceding steps to distribute devices again.
 * ## Limits
 * - This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
 * - You cannot call this operation to distribute devices across accounts.
 * - Each Alibaba Cloud account can create a maximum of 10 tasks to distribute products or devices. For more information about how to create a product distribution task, see [CreateProductDistributeJob](/help/en/iot-platform/latest/createproductdistributejob).
 * - Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateDeviceDistributeJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDeviceDistributeJobResponse
 */
func (client *Client) CreateDeviceDistributeJobWithOptions(request *CreateDeviceDistributeJobRequest, runtime *util.RuntimeOptions) (_result *CreateDeviceDistributeJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		body["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		body["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.SourceInstanceId)) {
		body["SourceInstanceId"] = request.SourceInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Strategy)) {
		body["Strategy"] = request.Strategy
	}

	if !tea.BoolValue(util.IsUnset(request.TargetAliyunId)) {
		body["TargetAliyunId"] = request.TargetAliyunId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetInstanceConfig)) {
		body["TargetInstanceConfig"] = request.TargetInstanceConfig
	}

	if !tea.BoolValue(util.IsUnset(request.TargetUid)) {
		body["TargetUid"] = request.TargetUid
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDeviceDistributeJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDeviceDistributeJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * To distribute devices, perform the following steps:
 * 1\\. Asynchronously call this operation to create a device distribution task and obtain the **JobId** parameter.
 * 2\\. Use **JobId** as a request parameter and repeatedly call the [QueryDeviceDistributeJob](~~199536~~) operation to obtain the **Status** parameter.
 * >  You must control the frequency of calls based on the QPS limit of the QueryDeviceDistributeJob operation.
 * If either of the following values is returned for the **Status** parameter, the distribution task ends:
 * *   **2**: The device distribution task is completed. This return value does not indicate that the devices are distributed. To obtain the distribution result of each device, perform the next step.
 * *   **3**: The distribution is unexpectedly interrupted. After you process the error, you can initiate a device distribution task again.
 * 3\\. Use **JobId** that is returned in Step 1 as a request parameter and call the [QueryDeviceDistributeDetail](~~199533~~) operation to obtain the **File** parameter. The File parameter indicates the file URL of the distribution result.
 * >  The file URL is valid for 10 minutes.
 * 4\\. Obtain the distribution result by using the file URL. The **Code** parameter indicates whether a device is distributed. If the value of the **Code** parameter is 200, the device is distributed.
 * If the distribution fails, you can perform the preceding steps to distribute devices again.
 * ## Limits
 * - This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
 * - You cannot call this operation to distribute devices across accounts.
 * - Each Alibaba Cloud account can create a maximum of 10 tasks to distribute products or devices. For more information about how to create a product distribution task, see [CreateProductDistributeJob](/help/en/iot-platform/latest/createproductdistributejob).
 * - Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).  >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateDeviceDistributeJobRequest
 * @return CreateDeviceDistributeJobResponse
 */
func (client *Client) CreateDeviceDistributeJob(request *CreateDeviceDistributeJobRequest) (_result *CreateDeviceDistributeJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDeviceDistributeJobResponse{}
	_body, _err := client.CreateDeviceDistributeJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDeviceDynamicGroupWithOptions(request *CreateDeviceDynamicGroupRequest, runtime *util.RuntimeOptions) (_result *CreateDeviceDynamicGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DynamicGroupExpression)) {
		query["DynamicGroupExpression"] = request.DynamicGroupExpression
	}

	if !tea.BoolValue(util.IsUnset(request.GroupDesc)) {
		query["GroupDesc"] = request.GroupDesc
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDeviceDynamicGroup"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDeviceDynamicGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDeviceDynamicGroup(request *CreateDeviceDynamicGroupRequest) (_result *CreateDeviceDynamicGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDeviceDynamicGroupResponse{}
	_body, _err := client.CreateDeviceDynamicGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateDeviceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDeviceGroupResponse
 */
func (client *Client) CreateDeviceGroupWithOptions(request *CreateDeviceGroupRequest, runtime *util.RuntimeOptions) (_result *CreateDeviceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupDesc)) {
		query["GroupDesc"] = request.GroupDesc
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SuperGroupId)) {
		query["SuperGroupId"] = request.SuperGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDeviceGroup"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDeviceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateDeviceGroupRequest
 * @return CreateDeviceGroupResponse
 */
func (client *Client) CreateDeviceGroup(request *CreateDeviceGroupRequest) (_result *CreateDeviceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDeviceGroupResponse{}
	_body, _err := client.CreateDeviceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDeviceTunnelWithOptions(request *CreateDeviceTunnelRequest, runtime *util.RuntimeOptions) (_result *CreateDeviceTunnelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Udi)) {
		query["Udi"] = request.Udi
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDeviceTunnel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDeviceTunnelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDeviceTunnel(request *CreateDeviceTunnelRequest) (_result *CreateDeviceTunnelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDeviceTunnelResponse{}
	_body, _err := client.CreateDeviceTunnelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateDownloadDataJobWithOptions(tmpReq *CreateDownloadDataJobRequest, runtime *util.RuntimeOptions) (_result *CreateDownloadDataJobResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateDownloadDataJobShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.FileConfig)) {
		request.FileConfigShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.FileConfig, tea.String("FileConfig"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DownloadDataType)) {
		query["DownloadDataType"] = request.DownloadDataType
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.FileConfigShrink)) {
		query["FileConfig"] = request.FileConfigShrink
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TableName)) {
		query["TableName"] = request.TableName
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateDownloadDataJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateDownloadDataJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateDownloadDataJob(request *CreateDownloadDataJobRequest) (_result *CreateDownloadDataJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateDownloadDataJobResponse{}
	_body, _err := client.CreateDownloadDataJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * A single Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users share the quota of the Alibaba Cloud account.
 *
 * @param request CreateEdgeDriverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEdgeDriverResponse
 */
func (client *Client) CreateEdgeDriverWithOptions(request *CreateEdgeDriverRequest, runtime *util.RuntimeOptions) (_result *CreateEdgeDriverResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CpuArch)) {
		query["CpuArch"] = request.CpuArch
	}

	if !tea.BoolValue(util.IsUnset(request.DriverName)) {
		query["DriverName"] = request.DriverName
	}

	if !tea.BoolValue(util.IsUnset(request.DriverProtocol)) {
		query["DriverProtocol"] = request.DriverProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IsBuiltIn)) {
		query["IsBuiltIn"] = request.IsBuiltIn
	}

	if !tea.BoolValue(util.IsUnset(request.Runtime)) {
		query["Runtime"] = request.Runtime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEdgeDriver"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEdgeDriverResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * A single Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users share the quota of the Alibaba Cloud account.
 *
 * @param request CreateEdgeDriverRequest
 * @return CreateEdgeDriverResponse
 */
func (client *Client) CreateEdgeDriver(request *CreateEdgeDriverRequest) (_result *CreateEdgeDriverResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEdgeDriverResponse{}
	_body, _err := client.CreateEdgeDriverWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateEdgeDriverVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEdgeDriverVersionResponse
 */
func (client *Client) CreateEdgeDriverVersionWithOptions(request *CreateEdgeDriverVersionRequest, runtime *util.RuntimeOptions) (_result *CreateEdgeDriverVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Argument)) {
		query["Argument"] = request.Argument
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigCheckRule)) {
		query["ConfigCheckRule"] = request.ConfigCheckRule
	}

	if !tea.BoolValue(util.IsUnset(request.ContainerConfig)) {
		query["ContainerConfig"] = request.ContainerConfig
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DriverConfig)) {
		query["DriverConfig"] = request.DriverConfig
	}

	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.DriverVersion)) {
		query["DriverVersion"] = request.DriverVersion
	}

	if !tea.BoolValue(util.IsUnset(request.EdgeVersion)) {
		query["EdgeVersion"] = request.EdgeVersion
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceConfig)) {
		query["SourceConfig"] = request.SourceConfig
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEdgeDriverVersion"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEdgeDriverVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateEdgeDriverVersionRequest
 * @return CreateEdgeDriverVersionResponse
 */
func (client *Client) CreateEdgeDriverVersion(request *CreateEdgeDriverVersionRequest) (_result *CreateEdgeDriverVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEdgeDriverVersionResponse{}
	_body, _err := client.CreateEdgeDriverVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * A single Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users share the quota of the Alibaba Cloud account.
 *
 * @param request CreateEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEdgeInstanceResponse
 */
func (client *Client) CreateEdgeInstanceWithOptions(request *CreateEdgeInstanceRequest, runtime *util.RuntimeOptions) (_result *CreateEdgeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEdgeInstance"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEdgeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * A single Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users share the quota of the Alibaba Cloud account.
 *
 * @param request CreateEdgeInstanceRequest
 * @return CreateEdgeInstanceResponse
 */
func (client *Client) CreateEdgeInstance(request *CreateEdgeInstanceRequest) (_result *CreateEdgeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEdgeInstanceResponse{}
	_body, _err := client.CreateEdgeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateEdgeInstanceChannelWithOptions(request *CreateEdgeInstanceChannelRequest, runtime *util.RuntimeOptions) (_result *CreateEdgeInstanceChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChannelName)) {
		query["ChannelName"] = request.ChannelName
	}

	if !tea.BoolValue(util.IsUnset(request.Configs)) {
		query["Configs"] = request.Configs
	}

	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEdgeInstanceChannel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEdgeInstanceChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateEdgeInstanceChannel(request *CreateEdgeInstanceChannelRequest) (_result *CreateEdgeInstanceChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEdgeInstanceChannelResponse{}
	_body, _err := client.CreateEdgeInstanceChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateEdgeInstanceDeploymentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEdgeInstanceDeploymentResponse
 */
func (client *Client) CreateEdgeInstanceDeploymentWithOptions(request *CreateEdgeInstanceDeploymentRequest, runtime *util.RuntimeOptions) (_result *CreateEdgeInstanceDeploymentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEdgeInstanceDeployment"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEdgeInstanceDeploymentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateEdgeInstanceDeploymentRequest
 * @return CreateEdgeInstanceDeploymentResponse
 */
func (client *Client) CreateEdgeInstanceDeployment(request *CreateEdgeInstanceDeploymentRequest) (_result *CreateEdgeInstanceDeploymentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEdgeInstanceDeploymentResponse{}
	_body, _err := client.CreateEdgeInstanceDeploymentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateEdgeInstanceMessageRoutingWithOptions(request *CreateEdgeInstanceMessageRoutingRequest, runtime *util.RuntimeOptions) (_result *CreateEdgeInstanceMessageRoutingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.SourceData)) {
		query["SourceData"] = request.SourceData
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		query["SourceType"] = request.SourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TargetData)) {
		query["TargetData"] = request.TargetData
	}

	if !tea.BoolValue(util.IsUnset(request.TargetIotHubQos)) {
		query["TargetIotHubQos"] = request.TargetIotHubQos
	}

	if !tea.BoolValue(util.IsUnset(request.TargetType)) {
		query["TargetType"] = request.TargetType
	}

	if !tea.BoolValue(util.IsUnset(request.TopicFilter)) {
		query["TopicFilter"] = request.TopicFilter
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEdgeInstanceMessageRouting"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEdgeInstanceMessageRoutingResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateEdgeInstanceMessageRouting(request *CreateEdgeInstanceMessageRoutingRequest) (_result *CreateEdgeInstanceMessageRoutingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEdgeInstanceMessageRoutingResponse{}
	_body, _err := client.CreateEdgeInstanceMessageRoutingWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateEdgeOssPreSignedAddressRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateEdgeOssPreSignedAddressResponse
 */
func (client *Client) CreateEdgeOssPreSignedAddressWithOptions(request *CreateEdgeOssPreSignedAddressRequest, runtime *util.RuntimeOptions) (_result *CreateEdgeOssPreSignedAddressResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		query["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceId)) {
		query["ResourceId"] = request.ResourceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceVersion)) {
		query["ResourceVersion"] = request.ResourceVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateEdgeOssPreSignedAddress"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateEdgeOssPreSignedAddressResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateEdgeOssPreSignedAddressRequest
 * @return CreateEdgeOssPreSignedAddressResponse
 */
func (client *Client) CreateEdgeOssPreSignedAddress(request *CreateEdgeOssPreSignedAddressRequest) (_result *CreateEdgeOssPreSignedAddressResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateEdgeOssPreSignedAddressResponse{}
	_body, _err := client.CreateEdgeOssPreSignedAddressWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateJobWithOptions(tmpReq *CreateJobRequest, runtime *util.RuntimeOptions) (_result *CreateJobResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateJobShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.JobFile)) {
		request.JobFileShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.JobFile, tea.String("JobFile"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.RolloutConfig)) {
		request.RolloutConfigShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RolloutConfig, tea.String("RolloutConfig"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.TargetConfig)) {
		request.TargetConfigShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.TargetConfig, tea.String("TargetConfig"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.TimeoutConfig)) {
		request.TimeoutConfigShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.TimeoutConfig, tea.String("TimeoutConfig"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JobDocument)) {
		query["JobDocument"] = request.JobDocument
	}

	if !tea.BoolValue(util.IsUnset(request.JobFileShrink)) {
		query["JobFile"] = request.JobFileShrink
	}

	if !tea.BoolValue(util.IsUnset(request.JobName)) {
		query["JobName"] = request.JobName
	}

	if !tea.BoolValue(util.IsUnset(request.RolloutConfigShrink)) {
		query["RolloutConfig"] = request.RolloutConfigShrink
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduledTime)) {
		query["ScheduledTime"] = request.ScheduledTime
	}

	if !tea.BoolValue(util.IsUnset(request.TargetConfigShrink)) {
		query["TargetConfig"] = request.TargetConfigShrink
	}

	if !tea.BoolValue(util.IsUnset(request.TimeoutConfigShrink)) {
		query["TimeoutConfig"] = request.TimeoutConfigShrink
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateJob(request *CreateJobRequest) (_result *CreateJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateJobResponse{}
	_body, _err := client.CreateJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * You can call this operation to create up to 500 devices.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateLoRaNodesTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLoRaNodesTaskResponse
 */
func (client *Client) CreateLoRaNodesTaskWithOptions(request *CreateLoRaNodesTaskRequest, runtime *util.RuntimeOptions) (_result *CreateLoRaNodesTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceInfo)) {
		query["DeviceInfo"] = request.DeviceInfo
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateLoRaNodesTask"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateLoRaNodesTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * You can call this operation to create up to 500 devices.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateLoRaNodesTaskRequest
 * @return CreateLoRaNodesTaskResponse
 */
func (client *Client) CreateLoRaNodesTask(request *CreateLoRaNodesTaskRequest) (_result *CreateLoRaNodesTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateLoRaNodesTaskResponse{}
	_body, _err := client.CreateLoRaNodesTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common parameters](~~30561~~).
 *
 * @param request CreateOTADynamicUpgradeJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOTADynamicUpgradeJobResponse
 */
func (client *Client) CreateOTADynamicUpgradeJobWithOptions(request *CreateOTADynamicUpgradeJobRequest, runtime *util.RuntimeOptions) (_result *CreateOTADynamicUpgradeJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DownloadProtocol)) {
		query["DownloadProtocol"] = request.DownloadProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.DynamicMode)) {
		query["DynamicMode"] = request.DynamicMode
	}

	if !tea.BoolValue(util.IsUnset(request.FirmwareId)) {
		query["FirmwareId"] = request.FirmwareId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupType)) {
		query["GroupType"] = request.GroupType
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MaximumPerMinute)) {
		query["MaximumPerMinute"] = request.MaximumPerMinute
	}

	if !tea.BoolValue(util.IsUnset(request.MultiModuleMode)) {
		query["MultiModuleMode"] = request.MultiModuleMode
	}

	if !tea.BoolValue(util.IsUnset(request.NeedConfirm)) {
		query["NeedConfirm"] = request.NeedConfirm
	}

	if !tea.BoolValue(util.IsUnset(request.NeedPush)) {
		query["NeedPush"] = request.NeedPush
	}

	if !tea.BoolValue(util.IsUnset(request.OverwriteMode)) {
		query["OverwriteMode"] = request.OverwriteMode
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.RetryCount)) {
		query["RetryCount"] = request.RetryCount
	}

	if !tea.BoolValue(util.IsUnset(request.RetryInterval)) {
		query["RetryInterval"] = request.RetryInterval
	}

	if !tea.BoolValue(util.IsUnset(request.SrcVersion)) {
		query["SrcVersion"] = request.SrcVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TimeoutInMinutes)) {
		query["TimeoutInMinutes"] = request.TimeoutInMinutes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOTADynamicUpgradeJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOTADynamicUpgradeJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common parameters](~~30561~~).
 *
 * @param request CreateOTADynamicUpgradeJobRequest
 * @return CreateOTADynamicUpgradeJobResponse
 */
func (client *Client) CreateOTADynamicUpgradeJob(request *CreateOTADynamicUpgradeJobRequest) (_result *CreateOTADynamicUpgradeJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOTADynamicUpgradeJobResponse{}
	_body, _err := client.CreateOTADynamicUpgradeJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Before you call this operation to create an OTA update package, you must call the [GenerateOTAUploadURL](~~147310~~) operation to generate the information about the files that you want to add to the OTA update package and call the Object Storage Service (OSS) [PostObject](~~31988~~) operation to upload the files.
 * ## Limits
 * Each Alibaba Cloud account can have up to 500 update packages.
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateOTAFirmwareRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOTAFirmwareResponse
 */
func (client *Client) CreateOTAFirmwareWithOptions(request *CreateOTAFirmwareRequest, runtime *util.RuntimeOptions) (_result *CreateOTAFirmwareResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DestVersion)) {
		query["DestVersion"] = request.DestVersion
	}

	if !tea.BoolValue(util.IsUnset(request.FirmwareDesc)) {
		query["FirmwareDesc"] = request.FirmwareDesc
	}

	if !tea.BoolValue(util.IsUnset(request.FirmwareName)) {
		query["FirmwareName"] = request.FirmwareName
	}

	if !tea.BoolValue(util.IsUnset(request.FirmwareSign)) {
		query["FirmwareSign"] = request.FirmwareSign
	}

	if !tea.BoolValue(util.IsUnset(request.FirmwareSize)) {
		query["FirmwareSize"] = request.FirmwareSize
	}

	if !tea.BoolValue(util.IsUnset(request.FirmwareUrl)) {
		query["FirmwareUrl"] = request.FirmwareUrl
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ModuleName)) {
		query["ModuleName"] = request.ModuleName
	}

	if !tea.BoolValue(util.IsUnset(request.MultiFiles)) {
		query["MultiFiles"] = request.MultiFiles
	}

	if !tea.BoolValue(util.IsUnset(request.NeedToVerify)) {
		query["NeedToVerify"] = request.NeedToVerify
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.SignMethod)) {
		query["SignMethod"] = request.SignMethod
	}

	if !tea.BoolValue(util.IsUnset(request.SrcVersion)) {
		query["SrcVersion"] = request.SrcVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	if !tea.BoolValue(util.IsUnset(request.Udi)) {
		query["Udi"] = request.Udi
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOTAFirmware"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOTAFirmwareResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Before you call this operation to create an OTA update package, you must call the [GenerateOTAUploadURL](~~147310~~) operation to generate the information about the files that you want to add to the OTA update package and call the Object Storage Service (OSS) [PostObject](~~31988~~) operation to upload the files.
 * ## Limits
 * Each Alibaba Cloud account can have up to 500 update packages.
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateOTAFirmwareRequest
 * @return CreateOTAFirmwareResponse
 */
func (client *Client) CreateOTAFirmware(request *CreateOTAFirmwareRequest) (_result *CreateOTAFirmwareResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOTAFirmwareResponse{}
	_body, _err := client.CreateOTAFirmwareWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * OTA modules are the updatable units of the devices that belong to the same product. The default module indicates the entire firmware of a device. You can call this operation to create a custom OTA module.
 * *   You can create a maximum of 10 custom OTA modules for each product.
 * *   After an OTA module is created, you cannot modify its name. You can call the [UpdateOTAModule](~~186061~~) operation to modify the module alias and description.
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateOTAModuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOTAModuleResponse
 */
func (client *Client) CreateOTAModuleWithOptions(request *CreateOTAModuleRequest, runtime *util.RuntimeOptions) (_result *CreateOTAModuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliasName)) {
		query["AliasName"] = request.AliasName
	}

	if !tea.BoolValue(util.IsUnset(request.Desc)) {
		query["Desc"] = request.Desc
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ModuleName)) {
		query["ModuleName"] = request.ModuleName
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOTAModule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOTAModuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * OTA modules are the updatable units of the devices that belong to the same product. The default module indicates the entire firmware of a device. You can call this operation to create a custom OTA module.
 * *   You can create a maximum of 10 custom OTA modules for each product.
 * *   After an OTA module is created, you cannot modify its name. You can call the [UpdateOTAModule](~~186061~~) operation to modify the module alias and description.
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateOTAModuleRequest
 * @return CreateOTAModuleResponse
 */
func (client *Client) CreateOTAModule(request *CreateOTAModuleRequest) (_result *CreateOTAModuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOTAModuleResponse{}
	_body, _err := client.CreateOTAModuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you specify that an update package does not need to be verified when you call the [CreateOTAFirmware](~~147311~~) operation, you must make sure that the update package is verified before you call the CreateOTAStaticUpgradeJob operation to create an update batch. For more information about how to create a task to verify an update package, see [CreateOTAVerifyJob](~~147480~~).
 * *   You can initiate update tasks for a maximum of 200 devices in each call. If you use a device list file, you can initiate update tasks for a maximum of 1,000,000 devices. However, you must call the [GenerateDeviceNameListURL](~~186062~~) operation to generate a URL for the device list file. Then, you can perform the operations as prompted to upload the device list file.
 * *   When you initiate update tasks for multiple devices, the devices that already have the destination firmware versions are skipped.
 * *   Each device can be in the pending or updating status only in one update task. If you initiate another update task for a device that is in the pending or updating status, the update task fails.
 * *   You can create multiple static update batches by using a single update package.
 * *   Downloading update packages through the MQTT protocol is supported only in the China (Shanghai) region.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateOTAStaticUpgradeJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOTAStaticUpgradeJobResponse
 */
func (client *Client) CreateOTAStaticUpgradeJobWithOptions(request *CreateOTAStaticUpgradeJobRequest, runtime *util.RuntimeOptions) (_result *CreateOTAStaticUpgradeJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DnListFileUrl)) {
		query["DnListFileUrl"] = request.DnListFileUrl
	}

	if !tea.BoolValue(util.IsUnset(request.DownloadProtocol)) {
		query["DownloadProtocol"] = request.DownloadProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.FirmwareId)) {
		query["FirmwareId"] = request.FirmwareId
	}

	if !tea.BoolValue(util.IsUnset(request.GrayPercent)) {
		query["GrayPercent"] = request.GrayPercent
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupType)) {
		query["GroupType"] = request.GroupType
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MaximumPerMinute)) {
		query["MaximumPerMinute"] = request.MaximumPerMinute
	}

	if !tea.BoolValue(util.IsUnset(request.MultiModuleMode)) {
		query["MultiModuleMode"] = request.MultiModuleMode
	}

	if !tea.BoolValue(util.IsUnset(request.NeedConfirm)) {
		query["NeedConfirm"] = request.NeedConfirm
	}

	if !tea.BoolValue(util.IsUnset(request.NeedPush)) {
		query["NeedPush"] = request.NeedPush
	}

	if !tea.BoolValue(util.IsUnset(request.OverwriteMode)) {
		query["OverwriteMode"] = request.OverwriteMode
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.RetryCount)) {
		query["RetryCount"] = request.RetryCount
	}

	if !tea.BoolValue(util.IsUnset(request.RetryInterval)) {
		query["RetryInterval"] = request.RetryInterval
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduleFinishTime)) {
		query["ScheduleFinishTime"] = request.ScheduleFinishTime
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduleTime)) {
		query["ScheduleTime"] = request.ScheduleTime
	}

	if !tea.BoolValue(util.IsUnset(request.SrcVersion)) {
		query["SrcVersion"] = request.SrcVersion
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TargetDeviceName)) {
		query["TargetDeviceName"] = request.TargetDeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.TargetSelection)) {
		query["TargetSelection"] = request.TargetSelection
	}

	if !tea.BoolValue(util.IsUnset(request.TimeoutInMinutes)) {
		query["TimeoutInMinutes"] = request.TimeoutInMinutes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOTAStaticUpgradeJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOTAStaticUpgradeJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you specify that an update package does not need to be verified when you call the [CreateOTAFirmware](~~147311~~) operation, you must make sure that the update package is verified before you call the CreateOTAStaticUpgradeJob operation to create an update batch. For more information about how to create a task to verify an update package, see [CreateOTAVerifyJob](~~147480~~).
 * *   You can initiate update tasks for a maximum of 200 devices in each call. If you use a device list file, you can initiate update tasks for a maximum of 1,000,000 devices. However, you must call the [GenerateDeviceNameListURL](~~186062~~) operation to generate a URL for the device list file. Then, you can perform the operations as prompted to upload the device list file.
 * *   When you initiate update tasks for multiple devices, the devices that already have the destination firmware versions are skipped.
 * *   Each device can be in the pending or updating status only in one update task. If you initiate another update task for a device that is in the pending or updating status, the update task fails.
 * *   You can create multiple static update batches by using a single update package.
 * *   Downloading update packages through the MQTT protocol is supported only in the China (Shanghai) region.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateOTAStaticUpgradeJobRequest
 * @return CreateOTAStaticUpgradeJobResponse
 */
func (client *Client) CreateOTAStaticUpgradeJob(request *CreateOTAStaticUpgradeJobRequest) (_result *CreateOTAStaticUpgradeJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOTAStaticUpgradeJobResponse{}
	_body, _err := client.CreateOTAStaticUpgradeJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You must verify an update package before you push the package to devices for a batch update. Only verified update packages can be used to update devices in batches. You can call the [QueryOTAFirmware](~~147461~~) operation to view the status of a verification task.
 * *   You cannot initiate a verification task for an update package that is being verified or has been verified.
 * *   You can specify a maximum of 10 devices for a verification task.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateOTAVerifyJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOTAVerifyJobResponse
 */
func (client *Client) CreateOTAVerifyJobWithOptions(request *CreateOTAVerifyJobRequest, runtime *util.RuntimeOptions) (_result *CreateOTAVerifyJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DownloadProtocol)) {
		query["DownloadProtocol"] = request.DownloadProtocol
	}

	if !tea.BoolValue(util.IsUnset(request.FirmwareId)) {
		query["FirmwareId"] = request.FirmwareId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NeedConfirm)) {
		query["NeedConfirm"] = request.NeedConfirm
	}

	if !tea.BoolValue(util.IsUnset(request.NeedPush)) {
		query["NeedPush"] = request.NeedPush
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	if !tea.BoolValue(util.IsUnset(request.TargetDeviceName)) {
		query["TargetDeviceName"] = request.TargetDeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.TimeoutInMinutes)) {
		query["TimeoutInMinutes"] = request.TimeoutInMinutes
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateOTAVerifyJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateOTAVerifyJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You must verify an update package before you push the package to devices for a batch update. Only verified update packages can be used to update devices in batches. You can call the [QueryOTAFirmware](~~147461~~) operation to view the status of a verification task.
 * *   You cannot initiate a verification task for an update package that is being verified or has been verified.
 * *   You can specify a maximum of 10 devices for a verification task.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateOTAVerifyJobRequest
 * @return CreateOTAVerifyJobResponse
 */
func (client *Client) CreateOTAVerifyJob(request *CreateOTAVerifyJobRequest) (_result *CreateOTAVerifyJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateOTAVerifyJobResponse{}
	_body, _err := client.CreateOTAVerifyJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateParserWithOptions(request *CreateParserRequest, runtime *util.RuntimeOptions) (_result *CreateParserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateParser"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateParserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateParser(request *CreateParserRequest) (_result *CreateParserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateParserResponse{}
	_body, _err := client.CreateParserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateParserDataSourceWithOptions(request *CreateParserDataSourceRequest, runtime *util.RuntimeOptions) (_result *CreateParserDataSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateParserDataSource"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateParserDataSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateParserDataSource(request *CreateParserDataSourceRequest) (_result *CreateParserDataSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateParserDataSourceResponse{}
	_body, _err := client.CreateParserDataSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If a Thing Specification Language (TSL) model is required to create a product, you must set the **AliyunCommodityCode** parameter to iothub_senior and configure the **DataFormat** parameter.******** For more information, see the "**Request parameters**" section of this topic.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProductResponse
 */
func (client *Client) CreateProductWithOptions(request *CreateProductRequest, runtime *util.RuntimeOptions) (_result *CreateProductResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunCommodityCode)) {
		query["AliyunCommodityCode"] = request.AliyunCommodityCode
	}

	if !tea.BoolValue(util.IsUnset(request.AuthType)) {
		query["AuthType"] = request.AuthType
	}

	if !tea.BoolValue(util.IsUnset(request.CategoryKey)) {
		query["CategoryKey"] = request.CategoryKey
	}

	if !tea.BoolValue(util.IsUnset(request.DataFormat)) {
		query["DataFormat"] = request.DataFormat
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.Id2)) {
		query["Id2"] = request.Id2
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JoinPermissionId)) {
		query["JoinPermissionId"] = request.JoinPermissionId
	}

	if !tea.BoolValue(util.IsUnset(request.NetType)) {
		query["NetType"] = request.NetType
	}

	if !tea.BoolValue(util.IsUnset(request.NodeType)) {
		query["NodeType"] = request.NodeType
	}

	if !tea.BoolValue(util.IsUnset(request.ProductName)) {
		query["ProductName"] = request.ProductName
	}

	if !tea.BoolValue(util.IsUnset(request.ProtocolType)) {
		query["ProtocolType"] = request.ProtocolType
	}

	if !tea.BoolValue(util.IsUnset(request.PublishAuto)) {
		query["PublishAuto"] = request.PublishAuto
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ValidateType)) {
		query["ValidateType"] = request.ValidateType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateProduct"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateProductResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If a Thing Specification Language (TSL) model is required to create a product, you must set the **AliyunCommodityCode** parameter to iothub_senior and configure the **DataFormat** parameter.******** For more information, see the "**Request parameters**" section of this topic.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateProductRequest
 * @return CreateProductResponse
 */
func (client *Client) CreateProduct(request *CreateProductRequest) (_result *CreateProductResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateProductResponse{}
	_body, _err := client.CreateProductWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
 * *   You cannot call this operation to distribute a product across accounts.
 * *   A product distribution task does not distribute the devices under the product.
 * *   After a product is distributed, you cannot modify its TSL model and scripts.
 * *   Each Alibaba Cloud account can create a maximum of 10 tasks to distribute products or devices. For more information about how to create a device distribution task, see [CreateDeviceDistributeJob](~~199390~~).
 * *   Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
 *     **
 *     **Note** RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateProductDistributeJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProductDistributeJobResponse
 */
func (client *Client) CreateProductDistributeJobWithOptions(request *CreateProductDistributeJobRequest, runtime *util.RuntimeOptions) (_result *CreateProductDistributeJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.SourceInstanceId)) {
		query["SourceInstanceId"] = request.SourceInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetAliyunId)) {
		query["TargetAliyunId"] = request.TargetAliyunId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetInstanceId)) {
		query["TargetInstanceId"] = request.TargetInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetUid)) {
		query["TargetUid"] = request.TargetUid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateProductDistributeJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateProductDistributeJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
 * *   You cannot call this operation to distribute a product across accounts.
 * *   A product distribution task does not distribute the devices under the product.
 * *   After a product is distributed, you cannot modify its TSL model and scripts.
 * *   Each Alibaba Cloud account can create a maximum of 10 tasks to distribute products or devices. For more information about how to create a device distribution task, see [CreateDeviceDistributeJob](~~199390~~).
 * *   Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
 *     **
 *     **Note** RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateProductDistributeJobRequest
 * @return CreateProductDistributeJobResponse
 */
func (client *Client) CreateProductDistributeJob(request *CreateProductDistributeJobRequest) (_result *CreateProductDistributeJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateProductDistributeJobResponse{}
	_body, _err := client.CreateProductDistributeJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can create a maximum of 10 tags for a product in a single call.
 * *   Each product can have a maximum of 100 tags.
 * > You must specify the tag keys and tag values. Otherwise, the call fails. For description about the tag values, see the "**Request parameters**" section of this topic.
 * ## QPS limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateProductTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProductTagsResponse
 */
func (client *Client) CreateProductTagsWithOptions(request *CreateProductTagsRequest, runtime *util.RuntimeOptions) (_result *CreateProductTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ProductTag)) {
		query["ProductTag"] = request.ProductTag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateProductTags"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateProductTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can create a maximum of 10 tags for a product in a single call.
 * *   Each product can have a maximum of 100 tags.
 * > You must specify the tag keys and tag values. Otherwise, the call fails. For description about the tag values, see the "**Request parameters**" section of this topic.
 * ## QPS limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateProductTagsRequest
 * @return CreateProductTagsResponse
 */
func (client *Client) CreateProductTags(request *CreateProductTagsRequest) (_result *CreateProductTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateProductTagsResponse{}
	_body, _err := client.CreateProductTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 1 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateProductTopicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProductTopicResponse
 */
func (client *Client) CreateProductTopicWithOptions(request *CreateProductTopicRequest, runtime *util.RuntimeOptions) (_result *CreateProductTopicResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Codec)) {
		query["Codec"] = request.Codec
	}

	if !tea.BoolValue(util.IsUnset(request.Desc)) {
		query["Desc"] = request.Desc
	}

	if !tea.BoolValue(util.IsUnset(request.EnableProxySubscribe)) {
		query["EnableProxySubscribe"] = request.EnableProxySubscribe
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Operation)) {
		query["Operation"] = request.Operation
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.TopicShortName)) {
		query["TopicShortName"] = request.TopicShortName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateProductTopic"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateProductTopicResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 1 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateProductTopicRequest
 * @return CreateProductTopicResponse
 */
func (client *Client) CreateProductTopic(request *CreateProductTopicRequest) (_result *CreateProductTopicResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateProductTopicResponse{}
	_body, _err := client.CreateProductTopicWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation, you must specify the **ProductKey** parameter in the request.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRuleResponse
 */
func (client *Client) CreateRuleWithOptions(request *CreateRuleRequest, runtime *util.RuntimeOptions) (_result *CreateRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataType)) {
		query["DataType"] = request.DataType
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleDesc)) {
		query["RuleDesc"] = request.RuleDesc
	}

	if !tea.BoolValue(util.IsUnset(request.Select)) {
		query["Select"] = request.Select
	}

	if !tea.BoolValue(util.IsUnset(request.ShortTopic)) {
		query["ShortTopic"] = request.ShortTopic
	}

	if !tea.BoolValue(util.IsUnset(request.Topic)) {
		query["Topic"] = request.Topic
	}

	if !tea.BoolValue(util.IsUnset(request.TopicType)) {
		query["TopicType"] = request.TopicType
	}

	if !tea.BoolValue(util.IsUnset(request.Where)) {
		query["Where"] = request.Where
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation, you must specify the **ProductKey** parameter in the request.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateRuleRequest
 * @return CreateRuleResponse
 */
func (client *Client) CreateRule(request *CreateRuleRequest) (_result *CreateRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateRuleResponse{}
	_body, _err := client.CreateRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   Destination Alibaba Cloud services that are supported by the rules engine vary based on regions. For more information about the regions and destination cloud services that are supported by the rules engine, see [Regions and zones](~~85669~~).
 * *   You can create a maximum of 10 rule actions for each rule.
 * *   You can call this API operation to define rule actions to forward data to an IoT Platform topic, AMQP consumer group, or Alibaba Cloud service. The supported Alibaba Cloud services include Message Service (MNS), Function Compute, and Tablestore. If you need to forward data to ApsaraDB RDS, you must use the [IoT Platform console](https://iot.console.aliyun.com).
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateRuleActionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRuleActionResponse
 */
func (client *Client) CreateRuleActionWithOptions(request *CreateRuleActionRequest, runtime *util.RuntimeOptions) (_result *CreateRuleActionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		query["Configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.ErrorActionFlag)) {
		query["ErrorActionFlag"] = request.ErrorActionFlag
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateRuleAction"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateRuleActionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   Destination Alibaba Cloud services that are supported by the rules engine vary based on regions. For more information about the regions and destination cloud services that are supported by the rules engine, see [Regions and zones](~~85669~~).
 * *   You can create a maximum of 10 rule actions for each rule.
 * *   You can call this API operation to define rule actions to forward data to an IoT Platform topic, AMQP consumer group, or Alibaba Cloud service. The supported Alibaba Cloud services include Message Service (MNS), Function Compute, and Tablestore. If you need to forward data to ApsaraDB RDS, you must use the [IoT Platform console](https://iot.console.aliyun.com).
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateRuleActionRequest
 * @return CreateRuleActionResponse
 */
func (client *Client) CreateRuleAction(request *CreateRuleActionRequest) (_result *CreateRuleActionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateRuleActionResponse{}
	_body, _err := client.CreateRuleActionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateSceneRuleWithOptions(request *CreateSceneRuleRequest, runtime *util.RuntimeOptions) (_result *CreateSceneRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleContent)) {
		query["RuleContent"] = request.RuleContent
	}

	if !tea.BoolValue(util.IsUnset(request.RuleDescription)) {
		query["RuleDescription"] = request.RuleDescription
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		query["RuleName"] = request.RuleName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSceneRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSceneRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateSceneRule(request *CreateSceneRuleRequest) (_result *CreateSceneRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSceneRuleResponse{}
	_body, _err := client.CreateSceneRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateSchedulePeriodWithOptions(request *CreateSchedulePeriodRequest, runtime *util.RuntimeOptions) (_result *CreateSchedulePeriodResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		body["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduleCode)) {
		body["ScheduleCode"] = request.ScheduleCode
	}

	if !tea.BoolValue(util.IsUnset(request.SoundCodeContent)) {
		body["SoundCodeContent"] = request.SoundCodeContent
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		body["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSchedulePeriod"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSchedulePeriodResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateSchedulePeriod(request *CreateSchedulePeriodRequest) (_result *CreateSchedulePeriodResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSchedulePeriodResponse{}
	_body, _err := client.CreateSchedulePeriodWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateSharePromotionActivityWithOptions(request *CreateSharePromotionActivityRequest, runtime *util.RuntimeOptions) (_result *CreateSharePromotionActivityResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		body["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SharePromotionActivityName)) {
		body["SharePromotionActivityName"] = request.SharePromotionActivityName
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		body["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSharePromotionActivity"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSharePromotionActivityResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateSharePromotionActivity(request *CreateSharePromotionActivityRequest) (_result *CreateSharePromotionActivityResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSharePromotionActivityResponse{}
	_body, _err := client.CreateSharePromotionActivityWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateSharePromotionSpeechModelWithOptions(request *CreateSharePromotionSpeechModelRequest, runtime *util.RuntimeOptions) (_result *CreateSharePromotionSpeechModelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AudioFormat)) {
		body["AudioFormat"] = request.AudioFormat
	}

	if !tea.BoolValue(util.IsUnset(request.BizCode)) {
		body["BizCode"] = request.BizCode
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SharePromotionActivityId)) {
		body["SharePromotionActivityId"] = request.SharePromotionActivityId
	}

	if !tea.BoolValue(util.IsUnset(request.ShareTaskCode)) {
		body["ShareTaskCode"] = request.ShareTaskCode
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechModelType)) {
		body["SpeechModelType"] = request.SpeechModelType
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechRate)) {
		body["SpeechRate"] = request.SpeechRate
	}

	if !tea.BoolValue(util.IsUnset(request.Text)) {
		body["Text"] = request.Text
	}

	if !tea.BoolValue(util.IsUnset(request.Voice)) {
		body["Voice"] = request.Voice
	}

	if !tea.BoolValue(util.IsUnset(request.Volume)) {
		body["Volume"] = request.Volume
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSharePromotionSpeechModel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSharePromotionSpeechModelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateSharePromotionSpeechModel(request *CreateSharePromotionSpeechModelRequest) (_result *CreateSharePromotionSpeechModelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSharePromotionSpeechModelResponse{}
	_body, _err := client.CreateSharePromotionSpeechModelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateSoundCodeWithOptions(request *CreateSoundCodeRequest, runtime *util.RuntimeOptions) (_result *CreateSoundCodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Duration)) {
		body["Duration"] = request.Duration
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OpenType)) {
		body["OpenType"] = request.OpenType
	}

	if !tea.BoolValue(util.IsUnset(request.SoundCodeContent)) {
		body["SoundCodeContent"] = request.SoundCodeContent
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSoundCode"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSoundCodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateSoundCode(request *CreateSoundCodeRequest) (_result *CreateSoundCodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSoundCodeResponse{}
	_body, _err := client.CreateSoundCodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateSoundCodeLabelWithOptions(request *CreateSoundCodeLabelRequest, runtime *util.RuntimeOptions) (_result *CreateSoundCodeLabelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Label)) {
		body["Label"] = request.Label
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduleCode)) {
		body["ScheduleCode"] = request.ScheduleCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSoundCodeLabel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSoundCodeLabelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateSoundCodeLabel(request *CreateSoundCodeLabelRequest) (_result *CreateSoundCodeLabelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSoundCodeLabelResponse{}
	_body, _err := client.CreateSoundCodeLabelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateSoundCodeScheduleWithOptions(request *CreateSoundCodeScheduleRequest, runtime *util.RuntimeOptions) (_result *CreateSoundCodeScheduleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		body["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.OpenType)) {
		body["OpenType"] = request.OpenType
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		body["StartDate"] = request.StartDate
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSoundCodeSchedule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSoundCodeScheduleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateSoundCodeSchedule(request *CreateSoundCodeScheduleRequest) (_result *CreateSoundCodeScheduleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSoundCodeScheduleResponse{}
	_body, _err := client.CreateSoundCodeScheduleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateSpeechWithOptions(tmpReq *CreateSpeechRequest, runtime *util.RuntimeOptions) (_result *CreateSpeechResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &CreateSpeechShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.SoundCodeConfig)) {
		request.SoundCodeConfigShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.SoundCodeConfig, tea.String("SoundCodeConfig"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AudioFormat)) {
		body["AudioFormat"] = request.AudioFormat
	}

	if !tea.BoolValue(util.IsUnset(request.BizCode)) {
		body["BizCode"] = request.BizCode
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSoundCode)) {
		body["EnableSoundCode"] = request.EnableSoundCode
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectCode)) {
		body["ProjectCode"] = request.ProjectCode
	}

	if !tea.BoolValue(util.IsUnset(request.SoundCodeConfigShrink)) {
		body["SoundCodeConfig"] = request.SoundCodeConfigShrink
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechRate)) {
		body["SpeechRate"] = request.SpeechRate
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechType)) {
		body["SpeechType"] = request.SpeechType
	}

	if !tea.BoolValue(util.IsUnset(request.Text)) {
		body["Text"] = request.Text
	}

	if !tea.BoolValue(util.IsUnset(request.Voice)) {
		body["Voice"] = request.Voice
	}

	if !tea.BoolValue(util.IsUnset(request.Volume)) {
		body["Volume"] = request.Volume
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSpeech"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSpeechResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateSpeech(request *CreateSpeechRequest) (_result *CreateSpeechResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSpeechResponse{}
	_body, _err := client.CreateSpeechWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateStudioAppDomainOpenWithOptions(request *CreateStudioAppDomainOpenRequest, runtime *util.RuntimeOptions) (_result *CreateStudioAppDomainOpenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		body["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Host)) {
		body["Host"] = request.Host
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.Protocol)) {
		body["Protocol"] = request.Protocol
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateStudioAppDomainOpen"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateStudioAppDomainOpenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateStudioAppDomainOpen(request *CreateStudioAppDomainOpenRequest) (_result *CreateStudioAppDomainOpenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateStudioAppDomainOpenResponse{}
	_body, _err := client.CreateStudioAppDomainOpenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Server-side subscriptions are categorized into the following two types:
 * *   MNS subscription: pushes subscribed messages to MNS queues. Your server applications listen to MNS queues to receive device messages. For more information, see [Configure MNS server-side subscriptions](~~68948~~). You can call this operation to create an MNS subscription.
 * *   AMQP subscription: pushes subscribed messages to your server by using the AMQP channel. For more information, see [Configure AMQP server-side subscriptions](~~142376~~). To configure an AMQP subscription, perform the following steps:
 *     1\\. Call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group and obtain the returned consumer group ID. Messages are pushed to the consumer group. The AMQP client carries the consumer group ID when the client connected to IoT Platform. For more information, see [Connect an AMQP client to IoT Platform](~~142489~~).
 *     2\\. Call the CreateSubscribeRelation operation to create an AMQP subscription.
 *     3\\. Optional. Call the [CreateConsumerGroupSubscribeRelation](~~170354~~) operation to add a consumer group to the AMQP subscription. You can also call the [DeleteConsumerGroupSubscribeRelation](~~170357~~) operation to remove a consumer group from an AMQP subscription.
 *     4\\. Optional. Call the [QueryConsumerGroupStatus](~~170358~~) operation to query the status of a consumer group, including online client information, message consumption rate, number of accumulated messages, and last message consumption time. You can also call the [ResetConsumerGroupPosition](~~170355~~) operation to clear the accumulated messages of the consumer group.
 * ## QPS limits
 * You can call this API operation up to five times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateSubscribeRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSubscribeRelationResponse
 */
func (client *Client) CreateSubscribeRelationWithOptions(request *CreateSubscribeRelationRequest, runtime *util.RuntimeOptions) (_result *CreateSubscribeRelationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConsumerGroupIds)) {
		query["ConsumerGroupIds"] = request.ConsumerGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceDataFlag)) {
		query["DeviceDataFlag"] = request.DeviceDataFlag
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceLifeCycleFlag)) {
		query["DeviceLifeCycleFlag"] = request.DeviceLifeCycleFlag
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceStatusChangeFlag)) {
		query["DeviceStatusChangeFlag"] = request.DeviceStatusChangeFlag
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceTagFlag)) {
		query["DeviceTagFlag"] = request.DeviceTagFlag
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceTopoLifeCycleFlag)) {
		query["DeviceTopoLifeCycleFlag"] = request.DeviceTopoLifeCycleFlag
	}

	if !tea.BoolValue(util.IsUnset(request.FoundDeviceListFlag)) {
		query["FoundDeviceListFlag"] = request.FoundDeviceListFlag
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MnsConfiguration)) {
		query["MnsConfiguration"] = request.MnsConfiguration
	}

	if !tea.BoolValue(util.IsUnset(request.OtaEventFlag)) {
		query["OtaEventFlag"] = request.OtaEventFlag
	}

	if !tea.BoolValue(util.IsUnset(request.OtaJobFlag)) {
		query["OtaJobFlag"] = request.OtaJobFlag
	}

	if !tea.BoolValue(util.IsUnset(request.OtaVersionFlag)) {
		query["OtaVersionFlag"] = request.OtaVersionFlag
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.SubscribeFlags)) {
		query["SubscribeFlags"] = request.SubscribeFlags
	}

	if !tea.BoolValue(util.IsUnset(request.ThingHistoryFlag)) {
		query["ThingHistoryFlag"] = request.ThingHistoryFlag
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateSubscribeRelation"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateSubscribeRelationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Server-side subscriptions are categorized into the following two types:
 * *   MNS subscription: pushes subscribed messages to MNS queues. Your server applications listen to MNS queues to receive device messages. For more information, see [Configure MNS server-side subscriptions](~~68948~~). You can call this operation to create an MNS subscription.
 * *   AMQP subscription: pushes subscribed messages to your server by using the AMQP channel. For more information, see [Configure AMQP server-side subscriptions](~~142376~~). To configure an AMQP subscription, perform the following steps:
 *     1\\. Call the [CreateConsumerGroup](~~170388~~) operation to create a consumer group and obtain the returned consumer group ID. Messages are pushed to the consumer group. The AMQP client carries the consumer group ID when the client connected to IoT Platform. For more information, see [Connect an AMQP client to IoT Platform](~~142489~~).
 *     2\\. Call the CreateSubscribeRelation operation to create an AMQP subscription.
 *     3\\. Optional. Call the [CreateConsumerGroupSubscribeRelation](~~170354~~) operation to add a consumer group to the AMQP subscription. You can also call the [DeleteConsumerGroupSubscribeRelation](~~170357~~) operation to remove a consumer group from an AMQP subscription.
 *     4\\. Optional. Call the [QueryConsumerGroupStatus](~~170358~~) operation to query the status of a consumer group, including online client information, message consumption rate, number of accumulated messages, and last message consumption time. You can also call the [ResetConsumerGroupPosition](~~170355~~) operation to clear the accumulated messages of the consumer group.
 * ## QPS limits
 * You can call this API operation up to five times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateSubscribeRelationRequest
 * @return CreateSubscribeRelationResponse
 */
func (client *Client) CreateSubscribeRelation(request *CreateSubscribeRelationRequest) (_result *CreateSubscribeRelationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateSubscribeRelationResponse{}
	_body, _err := client.CreateSubscribeRelationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
 * *   Before you call the operation, you can use the [json-schema](https://github.com/everit-org/json-schema?spm=a2c4g.11186623.2.23.575832d9zD7fZb) library to verify the input parameters in **ThingModelJson**. For more information, see [Data structure of ThingModelJson](~~150457~~).
 * *   You can call this operation to add a maximum of 10 TSL features. TSL features include properties, services, and events.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateThingModelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateThingModelResponse
 */
func (client *Client) CreateThingModelWithOptions(request *CreateThingModelRequest, runtime *util.RuntimeOptions) (_result *CreateThingModelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FunctionBlockId)) {
		query["FunctionBlockId"] = request.FunctionBlockId
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionBlockName)) {
		query["FunctionBlockName"] = request.FunctionBlockName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ThingModelJson)) {
		query["ThingModelJson"] = request.ThingModelJson
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateThingModel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateThingModelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
 * *   Before you call the operation, you can use the [json-schema](https://github.com/everit-org/json-schema?spm=a2c4g.11186623.2.23.575832d9zD7fZb) library to verify the input parameters in **ThingModelJson**. For more information, see [Data structure of ThingModelJson](~~150457~~).
 * *   You can call this operation to add a maximum of 10 TSL features. TSL features include properties, services, and events.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateThingModelRequest
 * @return CreateThingModelResponse
 */
func (client *Client) CreateThingModel(request *CreateThingModelRequest) (_result *CreateThingModelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateThingModelResponse{}
	_body, _err := client.CreateThingModelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * A data parsing script is used to convert data submitted by devices into the JSON format. The data submitted by devices is in a custom format. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
 * > If the data format is **Alink JSON**, the CreateThingScript operation is not supported. Alink JSON is a standard data format that is defined by IoT Connectivity Alliance (ICA).
 * ## QPS limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateThingScriptRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateThingScriptResponse
 */
func (client *Client) CreateThingScriptWithOptions(request *CreateThingScriptRequest, runtime *util.RuntimeOptions) (_result *CreateThingScriptResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ScriptContent)) {
		query["ScriptContent"] = request.ScriptContent
	}

	if !tea.BoolValue(util.IsUnset(request.ScriptType)) {
		query["ScriptType"] = request.ScriptType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateThingScript"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateThingScriptResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * A data parsing script is used to convert data submitted by devices into the JSON format. The data submitted by devices is in a custom format. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
 * > If the data format is **Alink JSON**, the CreateThingScript operation is not supported. Alink JSON is a standard data format that is defined by IoT Connectivity Alliance (ICA).
 * ## QPS limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateThingScriptRequest
 * @return CreateThingScriptResponse
 */
func (client *Client) CreateThingScript(request *CreateThingScriptRequest) (_result *CreateThingScriptResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateThingScriptResponse{}
	_body, _err := client.CreateThingScriptWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) CreateTopicConfigWithOptions(request *CreateTopicConfigRequest, runtime *util.RuntimeOptions) (_result *CreateTopicConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Codec)) {
		query["Codec"] = request.Codec
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EnableBroadcast)) {
		query["EnableBroadcast"] = request.EnableBroadcast
	}

	if !tea.BoolValue(util.IsUnset(request.EnableProxySubscribe)) {
		query["EnableProxySubscribe"] = request.EnableProxySubscribe
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Operation)) {
		query["Operation"] = request.Operation
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.TopicFullName)) {
		query["TopicFullName"] = request.TopicFullName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTopicConfig"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTopicConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) CreateTopicConfig(request *CreateTopicConfigRequest) (_result *CreateTopicConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTopicConfigResponse{}
	_body, _err := client.CreateTopicConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   You can specify a maximum of 100 destination topics for a source topic.
 * *   The device to which the source topic belongs must be activated.
 * *   The source and destination topics support only custom topics.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateTopicRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateTopicRouteTableResponse
 */
func (client *Client) CreateTopicRouteTableWithOptions(request *CreateTopicRouteTableRequest, runtime *util.RuntimeOptions) (_result *CreateTopicRouteTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DstTopic)) {
		query["DstTopic"] = request.DstTopic
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SrcTopic)) {
		query["SrcTopic"] = request.SrcTopic
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("CreateTopicRouteTable"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &CreateTopicRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   You can specify a maximum of 100 destination topics for a source topic.
 * *   The device to which the source topic belongs must be activated.
 * *   The source and destination topics support only custom topics.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request CreateTopicRouteTableRequest
 * @return CreateTopicRouteTableResponse
 */
func (client *Client) CreateTopicRouteTable(request *CreateTopicRouteTableRequest) (_result *CreateTopicRouteTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &CreateTopicRouteTableResponse{}
	_body, _err := client.CreateTopicRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call the [QueryClientIds](~~371985~~) operation to view the ClientIDs of a device and obtain the number of ClientIDs.
 * *   After you call the DeleteClientIds operation, all ClientIDs of the device are deleted and cannot be resumed. To obtain a new ClientID, you can register the device again.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteClientIdsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteClientIdsResponse
 */
func (client *Client) DeleteClientIdsWithOptions(request *DeleteClientIdsRequest, runtime *util.RuntimeOptions) (_result *DeleteClientIdsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteClientIds"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteClientIdsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call the [QueryClientIds](~~371985~~) operation to view the ClientIDs of a device and obtain the number of ClientIDs.
 * *   After you call the DeleteClientIds operation, all ClientIDs of the device are deleted and cannot be resumed. To obtain a new ClientID, you can register the device again.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteClientIdsRequest
 * @return DeleteClientIdsResponse
 */
func (client *Client) DeleteClientIds(request *DeleteClientIdsRequest) (_result *DeleteClientIdsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteClientIdsResponse{}
	_body, _err := client.DeleteClientIdsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   You cannot delete the default consumer group provided by IoT Platform.
 * *   If the consumer group is associated with an AMQP subscription, you must disassociate the consumer group from the subscription. If the subscription has multiple consumer groups, you can call the [DeleteConsumerGroupSubscribeRelation](~~170357~~) operation to remove the consumer group from the subscription. If the subscription has only one consumer group, you can call the [UpdateSubscribeRelation](~~170351~~) operation to change the consumer group or call the [DeleteSubscribeRelation](~~170353~~) operation to delete the subscription.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteConsumerGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConsumerGroupResponse
 */
func (client *Client) DeleteConsumerGroupWithOptions(request *DeleteConsumerGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteConsumerGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteConsumerGroup"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteConsumerGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   You cannot delete the default consumer group provided by IoT Platform.
 * *   If the consumer group is associated with an AMQP subscription, you must disassociate the consumer group from the subscription. If the subscription has multiple consumer groups, you can call the [DeleteConsumerGroupSubscribeRelation](~~170357~~) operation to remove the consumer group from the subscription. If the subscription has only one consumer group, you can call the [UpdateSubscribeRelation](~~170351~~) operation to change the consumer group or call the [DeleteSubscribeRelation](~~170353~~) operation to delete the subscription.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteConsumerGroupRequest
 * @return DeleteConsumerGroupResponse
 */
func (client *Client) DeleteConsumerGroup(request *DeleteConsumerGroupRequest) (_result *DeleteConsumerGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteConsumerGroupResponse{}
	_body, _err := client.DeleteConsumerGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   If the AMQP subscription has only one consumer group, you cannot call this operation to remove the consumer group.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteConsumerGroupSubscribeRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteConsumerGroupSubscribeRelationResponse
 */
func (client *Client) DeleteConsumerGroupSubscribeRelationWithOptions(request *DeleteConsumerGroupSubscribeRelationRequest, runtime *util.RuntimeOptions) (_result *DeleteConsumerGroupSubscribeRelationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConsumerGroupId)) {
		query["ConsumerGroupId"] = request.ConsumerGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteConsumerGroupSubscribeRelation"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteConsumerGroupSubscribeRelationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   If the AMQP subscription has only one consumer group, you cannot call this operation to remove the consumer group.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteConsumerGroupSubscribeRelationRequest
 * @return DeleteConsumerGroupSubscribeRelationResponse
 */
func (client *Client) DeleteConsumerGroupSubscribeRelation(request *DeleteConsumerGroupSubscribeRelationRequest) (_result *DeleteConsumerGroupSubscribeRelationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteConsumerGroupSubscribeRelationResponse{}
	_body, _err := client.DeleteConsumerGroupSubscribeRelationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDataSourceItemWithOptions(request *DeleteDataSourceItemRequest, runtime *util.RuntimeOptions) (_result *DeleteDataSourceItemResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataSourceId)) {
		query["DataSourceId"] = request.DataSourceId
	}

	if !tea.BoolValue(util.IsUnset(request.DataSourceItemId)) {
		query["DataSourceItemId"] = request.DataSourceItemId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDataSourceItem"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDataSourceItemResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDataSourceItem(request *DeleteDataSourceItemRequest) (_result *DeleteDataSourceItemResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDataSourceItemResponse{}
	_body, _err := client.DeleteDataSourceItemWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDestinationWithOptions(request *DeleteDestinationRequest, runtime *util.RuntimeOptions) (_result *DeleteDestinationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DestinationId)) {
		query["DestinationId"] = request.DestinationId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDestination"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDestinationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDestination(request *DeleteDestinationRequest) (_result *DeleteDestinationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDestinationResponse{}
	_body, _err := client.DeleteDestinationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   When you call this operation with an Alibaba Cloud account, IoT Platform sends a verification code by text message to confirm your identity.
 * *   When you call this operation with a RAM user, IoT Platform does not send a verification code. To ensure device security, you can create custom permission policies to perform fine-grained permission management. For more information, see [Mapping of IoT Platform operations and RAM policies](~~47485~~) and [Custom permissions](~~47495~~).
 * **Warning**
 * *   After a device is deleted, the device ID (**IotId**) becomes invalid, and all other information associated with the device is deleted. In addition, you can no longer perform an operation on the device.
 * *   Before you delete a device in the IoT Platform console, make sure that the corresponding actual device is offline. Otherwise, after the device is deleted from IoT Platform, the actual device continues to initiate connection requests to IoT Platform. If the number of requests exceeds the upper limit, IoT Platform starts request throttling. In this case, access of other devices within your Alibaba Cloud account is affected.
 * *   After you delete a device, the certificate of the device becomes invalid and cannot be restored. Proceed with caution.
 * ****
 * *   You must specify a value for the **IotId** parameter or values for the **ProductKey** and **DeviceName** parameters to identify a device.
 * *   If you specify a gateway and the number of sub-devices that belong to the gateway exceeds 2,000, you can call this operation to create a device job to delete the topological relationships in an asynchronous manner. The operation returns the **JobId** parameter.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDeviceResponse
 */
func (client *Client) DeleteDeviceWithOptions(request *DeleteDeviceRequest, runtime *util.RuntimeOptions) (_result *DeleteDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   When you call this operation with an Alibaba Cloud account, IoT Platform sends a verification code by text message to confirm your identity.
 * *   When you call this operation with a RAM user, IoT Platform does not send a verification code. To ensure device security, you can create custom permission policies to perform fine-grained permission management. For more information, see [Mapping of IoT Platform operations and RAM policies](~~47485~~) and [Custom permissions](~~47495~~).
 * **Warning**
 * *   After a device is deleted, the device ID (**IotId**) becomes invalid, and all other information associated with the device is deleted. In addition, you can no longer perform an operation on the device.
 * *   Before you delete a device in the IoT Platform console, make sure that the corresponding actual device is offline. Otherwise, after the device is deleted from IoT Platform, the actual device continues to initiate connection requests to IoT Platform. If the number of requests exceeds the upper limit, IoT Platform starts request throttling. In this case, access of other devices within your Alibaba Cloud account is affected.
 * *   After you delete a device, the certificate of the device becomes invalid and cannot be restored. Proceed with caution.
 * ****
 * *   You must specify a value for the **IotId** parameter or values for the **ProductKey** and **DeviceName** parameters to identify a device.
 * *   If you specify a gateway and the number of sub-devices that belong to the gateway exceeds 2,000, you can call this operation to create a device job to delete the topological relationships in an asynchronous manner. The operation returns the **JobId** parameter.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteDeviceRequest
 * @return DeleteDeviceResponse
 */
func (client *Client) DeleteDevice(request *DeleteDeviceRequest) (_result *DeleteDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDeviceResponse{}
	_body, _err := client.DeleteDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
 * *   Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteDeviceDistributeJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDeviceDistributeJobResponse
 */
func (client *Client) DeleteDeviceDistributeJobWithOptions(request *DeleteDeviceDistributeJobRequest, runtime *util.RuntimeOptions) (_result *DeleteDeviceDistributeJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDeviceDistributeJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDeviceDistributeJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
 * *   Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteDeviceDistributeJobRequest
 * @return DeleteDeviceDistributeJobResponse
 */
func (client *Client) DeleteDeviceDistributeJob(request *DeleteDeviceDistributeJobRequest) (_result *DeleteDeviceDistributeJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDeviceDistributeJobResponse{}
	_body, _err := client.DeleteDeviceDistributeJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDeviceDynamicGroupWithOptions(request *DeleteDeviceDynamicGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteDeviceDynamicGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDeviceDynamicGroup"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDeviceDynamicGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDeviceDynamicGroup(request *DeleteDeviceDynamicGroupRequest) (_result *DeleteDeviceDynamicGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDeviceDynamicGroupResponse{}
	_body, _err := client.DeleteDeviceDynamicGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteDeviceFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDeviceFileResponse
 */
func (client *Client) DeleteDeviceFileWithOptions(request *DeleteDeviceFileRequest, runtime *util.RuntimeOptions) (_result *DeleteDeviceFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDeviceFile"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDeviceFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteDeviceFileRequest
 * @return DeleteDeviceFileResponse
 */
func (client *Client) DeleteDeviceFile(request *DeleteDeviceFileRequest) (_result *DeleteDeviceFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDeviceFileResponse{}
	_body, _err := client.DeleteDeviceFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteDeviceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDeviceGroupResponse
 */
func (client *Client) DeleteDeviceGroupWithOptions(request *DeleteDeviceGroupRequest, runtime *util.RuntimeOptions) (_result *DeleteDeviceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDeviceGroup"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDeviceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteDeviceGroupRequest
 * @return DeleteDeviceGroupResponse
 */
func (client *Client) DeleteDeviceGroup(request *DeleteDeviceGroupRequest) (_result *DeleteDeviceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDeviceGroupResponse{}
	_body, _err := client.DeleteDeviceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteDevicePropRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDevicePropResponse
 */
func (client *Client) DeleteDevicePropWithOptions(request *DeleteDevicePropRequest, runtime *util.RuntimeOptions) (_result *DeleteDevicePropResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.PropKey)) {
		query["PropKey"] = request.PropKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDeviceProp"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDevicePropResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteDevicePropRequest
 * @return DeleteDevicePropResponse
 */
func (client *Client) DeleteDeviceProp(request *DeleteDevicePropRequest) (_result *DeleteDevicePropResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDevicePropResponse{}
	_body, _err := client.DeleteDevicePropWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDeviceSpeechWithOptions(request *DeleteDeviceSpeechRequest, runtime *util.RuntimeOptions) (_result *DeleteDeviceSpeechResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceSpeechList)) {
		body["DeviceSpeechList"] = request.DeviceSpeechList
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		body["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDeviceSpeech"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDeviceSpeechResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDeviceSpeech(request *DeleteDeviceSpeechRequest) (_result *DeleteDeviceSpeechResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDeviceSpeechResponse{}
	_body, _err := client.DeleteDeviceSpeechWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteDeviceTunnelWithOptions(request *DeleteDeviceTunnelRequest, runtime *util.RuntimeOptions) (_result *DeleteDeviceTunnelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TunnelId)) {
		query["TunnelId"] = request.TunnelId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteDeviceTunnel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteDeviceTunnelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteDeviceTunnel(request *DeleteDeviceTunnelRequest) (_result *DeleteDeviceTunnelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteDeviceTunnelResponse{}
	_body, _err := client.DeleteDeviceTunnelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   You are not allowed to delete a driver that has a published version.
 * *   Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteEdgeDriverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEdgeDriverResponse
 */
func (client *Client) DeleteEdgeDriverWithOptions(request *DeleteEdgeDriverRequest, runtime *util.RuntimeOptions) (_result *DeleteEdgeDriverResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEdgeDriver"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEdgeDriverResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   You are not allowed to delete a driver that has a published version.
 * *   Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteEdgeDriverRequest
 * @return DeleteEdgeDriverResponse
 */
func (client *Client) DeleteEdgeDriver(request *DeleteEdgeDriverRequest) (_result *DeleteEdgeDriverResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEdgeDriverResponse{}
	_body, _err := client.DeleteEdgeDriverWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   You are not allowed to delete a published driver version.
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteEdgeDriverVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEdgeDriverVersionResponse
 */
func (client *Client) DeleteEdgeDriverVersionWithOptions(request *DeleteEdgeDriverVersionRequest, runtime *util.RuntimeOptions) (_result *DeleteEdgeDriverVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.DriverVersion)) {
		query["DriverVersion"] = request.DriverVersion
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEdgeDriverVersion"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEdgeDriverVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   You are not allowed to delete a published driver version.
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteEdgeDriverVersionRequest
 * @return DeleteEdgeDriverVersionResponse
 */
func (client *Client) DeleteEdgeDriverVersion(request *DeleteEdgeDriverVersionRequest) (_result *DeleteEdgeDriverVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEdgeDriverVersionResponse{}
	_body, _err := client.DeleteEdgeDriverVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteEdgeInstanceResponse
 */
func (client *Client) DeleteEdgeInstanceWithOptions(request *DeleteEdgeInstanceRequest, runtime *util.RuntimeOptions) (_result *DeleteEdgeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEdgeInstance"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEdgeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteEdgeInstanceRequest
 * @return DeleteEdgeInstanceResponse
 */
func (client *Client) DeleteEdgeInstance(request *DeleteEdgeInstanceRequest) (_result *DeleteEdgeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEdgeInstanceResponse{}
	_body, _err := client.DeleteEdgeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteEdgeInstanceMessageRoutingWithOptions(request *DeleteEdgeInstanceMessageRoutingRequest, runtime *util.RuntimeOptions) (_result *DeleteEdgeInstanceMessageRoutingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteId)) {
		query["RouteId"] = request.RouteId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteEdgeInstanceMessageRouting"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteEdgeInstanceMessageRoutingResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteEdgeInstanceMessageRouting(request *DeleteEdgeInstanceMessageRoutingRequest) (_result *DeleteEdgeInstanceMessageRoutingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteEdgeInstanceMessageRoutingResponse{}
	_body, _err := client.DeleteEdgeInstanceMessageRoutingWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteJobWithOptions(request *DeleteJobRequest, runtime *util.RuntimeOptions) (_result *DeleteJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteJob(request *DeleteJobRequest) (_result *DeleteJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteJobResponse{}
	_body, _err := client.DeleteJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteOTAFirmwareRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteOTAFirmwareResponse
 */
func (client *Client) DeleteOTAFirmwareWithOptions(request *DeleteOTAFirmwareRequest, runtime *util.RuntimeOptions) (_result *DeleteOTAFirmwareResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FirmwareId)) {
		query["FirmwareId"] = request.FirmwareId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteOTAFirmware"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteOTAFirmwareResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteOTAFirmwareRequest
 * @return DeleteOTAFirmwareResponse
 */
func (client *Client) DeleteOTAFirmware(request *DeleteOTAFirmwareRequest) (_result *DeleteOTAFirmwareResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteOTAFirmwareResponse{}
	_body, _err := client.DeleteOTAFirmwareWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   The default module cannot be deleted.
 * *   If an update package exists in an OTA module, you cannot delete the OTA module.
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteOTAModuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteOTAModuleResponse
 */
func (client *Client) DeleteOTAModuleWithOptions(request *DeleteOTAModuleRequest, runtime *util.RuntimeOptions) (_result *DeleteOTAModuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ModuleName)) {
		query["ModuleName"] = request.ModuleName
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteOTAModule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteOTAModuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   The default module cannot be deleted.
 * *   If an update package exists in an OTA module, you cannot delete the OTA module.
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteOTAModuleRequest
 * @return DeleteOTAModuleResponse
 */
func (client *Client) DeleteOTAModule(request *DeleteOTAModuleRequest) (_result *DeleteOTAModuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteOTAModuleResponse{}
	_body, _err := client.DeleteOTAModuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteParserWithOptions(request *DeleteParserRequest, runtime *util.RuntimeOptions) (_result *DeleteParserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ParserId)) {
		query["ParserId"] = request.ParserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteParser"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteParserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteParser(request *DeleteParserRequest) (_result *DeleteParserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteParserResponse{}
	_body, _err := client.DeleteParserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteParserDataSourceWithOptions(request *DeleteParserDataSourceRequest, runtime *util.RuntimeOptions) (_result *DeleteParserDataSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataSourceId)) {
		query["DataSourceId"] = request.DataSourceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteParserDataSource"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteParserDataSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteParserDataSource(request *DeleteParserDataSourceRequest) (_result *DeleteParserDataSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteParserDataSourceResponse{}
	_body, _err := client.DeleteParserDataSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   After a product is deleted, the ProductKey of the product is invalid. The related information about the product is also deleted. You cannot perform the required operations on the product.
 * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteProductResponse
 */
func (client *Client) DeleteProductWithOptions(request *DeleteProductRequest, runtime *util.RuntimeOptions) (_result *DeleteProductResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteProduct"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteProductResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   After a product is deleted, the ProductKey of the product is invalid. The related information about the product is also deleted. You cannot perform the required operations on the product.
 * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteProductRequest
 * @return DeleteProductResponse
 */
func (client *Client) DeleteProduct(request *DeleteProductRequest) (_result *DeleteProductResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteProductResponse{}
	_body, _err := client.DeleteProductWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   You can delete a maximum of 10 tags in a single call.
 * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteProductTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteProductTagsResponse
 */
func (client *Client) DeleteProductTagsWithOptions(request *DeleteProductTagsRequest, runtime *util.RuntimeOptions) (_result *DeleteProductTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ProductTagKey)) {
		query["ProductTagKey"] = request.ProductTagKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteProductTags"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteProductTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   You can delete a maximum of 10 tags in a single call.
 * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteProductTagsRequest
 * @return DeleteProductTagsResponse
 */
func (client *Client) DeleteProductTags(request *DeleteProductTagsRequest) (_result *DeleteProductTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteProductTagsResponse{}
	_body, _err := client.DeleteProductTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteProductTopicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteProductTopicResponse
 */
func (client *Client) DeleteProductTopicWithOptions(request *DeleteProductTopicRequest, runtime *util.RuntimeOptions) (_result *DeleteProductTopicResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TopicId)) {
		query["TopicId"] = request.TopicId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteProductTopic"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteProductTopicResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteProductTopicRequest
 * @return DeleteProductTopicResponse
 */
func (client *Client) DeleteProductTopic(request *DeleteProductTopicRequest) (_result *DeleteProductTopicResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteProductTopicResponse{}
	_body, _err := client.DeleteProductTopicWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRuleResponse
 */
func (client *Client) DeleteRuleWithOptions(request *DeleteRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteRuleRequest
 * @return DeleteRuleResponse
 */
func (client *Client) DeleteRule(request *DeleteRuleRequest) (_result *DeleteRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRuleResponse{}
	_body, _err := client.DeleteRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteRuleActionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRuleActionResponse
 */
func (client *Client) DeleteRuleActionWithOptions(request *DeleteRuleActionRequest, runtime *util.RuntimeOptions) (_result *DeleteRuleActionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActionId)) {
		query["ActionId"] = request.ActionId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteRuleAction"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteRuleActionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteRuleActionRequest
 * @return DeleteRuleActionResponse
 */
func (client *Client) DeleteRuleAction(request *DeleteRuleActionRequest) (_result *DeleteRuleActionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteRuleActionResponse{}
	_body, _err := client.DeleteRuleActionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSceneRuleWithOptions(request *DeleteSceneRuleRequest, runtime *util.RuntimeOptions) (_result *DeleteSceneRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSceneRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSceneRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSceneRule(request *DeleteSceneRuleRequest) (_result *DeleteSceneRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSceneRuleResponse{}
	_body, _err := client.DeleteSceneRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSchedulePeriodWithOptions(request *DeleteSchedulePeriodRequest, runtime *util.RuntimeOptions) (_result *DeleteSchedulePeriodResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PeriodCode)) {
		body["PeriodCode"] = request.PeriodCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSchedulePeriod"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSchedulePeriodResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSchedulePeriod(request *DeleteSchedulePeriodRequest) (_result *DeleteSchedulePeriodResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSchedulePeriodResponse{}
	_body, _err := client.DeleteSchedulePeriodWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteShareTaskDeviceWithOptions(request *DeleteShareTaskDeviceRequest, runtime *util.RuntimeOptions) (_result *DeleteShareTaskDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotIdList)) {
		body["IotIdList"] = request.IotIdList
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ShareTaskId)) {
		body["ShareTaskId"] = request.ShareTaskId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteShareTaskDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteShareTaskDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteShareTaskDevice(request *DeleteShareTaskDeviceRequest) (_result *DeleteShareTaskDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteShareTaskDeviceResponse{}
	_body, _err := client.DeleteShareTaskDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSoundCodeWithOptions(request *DeleteSoundCodeRequest, runtime *util.RuntimeOptions) (_result *DeleteSoundCodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SoundCode)) {
		body["SoundCode"] = request.SoundCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSoundCode"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSoundCodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSoundCode(request *DeleteSoundCodeRequest) (_result *DeleteSoundCodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSoundCodeResponse{}
	_body, _err := client.DeleteSoundCodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSoundCodeLabelWithOptions(request *DeleteSoundCodeLabelRequest, runtime *util.RuntimeOptions) (_result *DeleteSoundCodeLabelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SoundCode)) {
		body["SoundCode"] = request.SoundCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSoundCodeLabel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSoundCodeLabelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSoundCodeLabel(request *DeleteSoundCodeLabelRequest) (_result *DeleteSoundCodeLabelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSoundCodeLabelResponse{}
	_body, _err := client.DeleteSoundCodeLabelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSoundCodeScheduleWithOptions(request *DeleteSoundCodeScheduleRequest, runtime *util.RuntimeOptions) (_result *DeleteSoundCodeScheduleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduleCode)) {
		body["ScheduleCode"] = request.ScheduleCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSoundCodeSchedule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSoundCodeScheduleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSoundCodeSchedule(request *DeleteSoundCodeScheduleRequest) (_result *DeleteSoundCodeScheduleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSoundCodeScheduleResponse{}
	_body, _err := client.DeleteSoundCodeScheduleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteSpeechWithOptions(request *DeleteSpeechRequest, runtime *util.RuntimeOptions) (_result *DeleteSpeechResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechCodeList)) {
		body["SpeechCodeList"] = request.SpeechCodeList
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSpeech"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSpeechResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteSpeech(request *DeleteSpeechRequest) (_result *DeleteSpeechResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSpeechResponse{}
	_body, _err := client.DeleteSpeechWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteStudioAppDomainOpenWithOptions(request *DeleteStudioAppDomainOpenRequest, runtime *util.RuntimeOptions) (_result *DeleteStudioAppDomainOpenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		body["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.DomainId)) {
		body["DomainId"] = request.DomainId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteStudioAppDomainOpen"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteStudioAppDomainOpenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteStudioAppDomainOpen(request *DeleteStudioAppDomainOpenRequest) (_result *DeleteStudioAppDomainOpenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteStudioAppDomainOpenResponse{}
	_body, _err := client.DeleteStudioAppDomainOpenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteSubscribeRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSubscribeRelationResponse
 */
func (client *Client) DeleteSubscribeRelationWithOptions(request *DeleteSubscribeRelationRequest, runtime *util.RuntimeOptions) (_result *DeleteSubscribeRelationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteSubscribeRelation"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteSubscribeRelationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteSubscribeRelationRequest
 * @return DeleteSubscribeRelationResponse
 */
func (client *Client) DeleteSubscribeRelation(request *DeleteSubscribeRelationRequest) (_result *DeleteSubscribeRelationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteSubscribeRelationResponse{}
	_body, _err := client.DeleteSubscribeRelationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call the DeleteThingModel operation.
 * *   If an existing feature or custom TSL module in a product is not published, you can call the DeleteThingModel operation to remove the feature or delete the custom TSL module.
 * *   When you call the DeleteThingModel operation, you must specify a value for the **ProductKey** parameter. The following list describes how the DeleteThingModel operation works:
 *     *   If you specify a value only for the **ProductKey** parameter, the operation deletes all custom TSL modules and removes all features in the default TSL module from the specified product.
 *     *   If you specify values only for the **ProductKey** and **FunctionBlockId** parameters, the operation deletes the specified custom TSL module from the specified product.
 *     *   If you specify a value for the **ProductKey** parameter and a value for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter, the operation removes one or more specified features from the default TSL module of the specified product. The operation removes the specified features only if the features exist. If the value that you specified for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter does not exist in the default TSL module, the operation returns the same result as when you specify a value only for the **ProductKey** parameter.
 *     *   If you specify values for the **ProductKey** and **FunctionBlockId** parameters and a value for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter, the operation removes one or more specified features from a specified custom TSL module in a specified product. The operation removes the specified features only if the features exist. If the value that you specified for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter does not exist, the operation returns the same result as when you specify values only for the **ProductKey** and **FunctionBlockId** parameters.
 * > You must specify up to 10 identifiers for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter.
 * *   After you call the DeleteThingModel operation to remove one or more features from a product, you must call the [PublishThingModel](~~150311~~) operation to re-publish the TSL model of the product. This way, the change takes effect.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 5 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request DeleteThingModelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteThingModelResponse
 */
func (client *Client) DeleteThingModelWithOptions(request *DeleteThingModelRequest, runtime *util.RuntimeOptions) (_result *DeleteThingModelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EventIdentifier)) {
		query["EventIdentifier"] = request.EventIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionBlockId)) {
		query["FunctionBlockId"] = request.FunctionBlockId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.PropertyIdentifier)) {
		query["PropertyIdentifier"] = request.PropertyIdentifier
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.ServiceIdentifier)) {
		query["ServiceIdentifier"] = request.ServiceIdentifier
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteThingModel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteThingModelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call the DeleteThingModel operation.
 * *   If an existing feature or custom TSL module in a product is not published, you can call the DeleteThingModel operation to remove the feature or delete the custom TSL module.
 * *   When you call the DeleteThingModel operation, you must specify a value for the **ProductKey** parameter. The following list describes how the DeleteThingModel operation works:
 *     *   If you specify a value only for the **ProductKey** parameter, the operation deletes all custom TSL modules and removes all features in the default TSL module from the specified product.
 *     *   If you specify values only for the **ProductKey** and **FunctionBlockId** parameters, the operation deletes the specified custom TSL module from the specified product.
 *     *   If you specify a value for the **ProductKey** parameter and a value for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter, the operation removes one or more specified features from the default TSL module of the specified product. The operation removes the specified features only if the features exist. If the value that you specified for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter does not exist in the default TSL module, the operation returns the same result as when you specify a value only for the **ProductKey** parameter.
 *     *   If you specify values for the **ProductKey** and **FunctionBlockId** parameters and a value for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter, the operation removes one or more specified features from a specified custom TSL module in a specified product. The operation removes the specified features only if the features exist. If the value that you specified for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter does not exist, the operation returns the same result as when you specify values only for the **ProductKey** and **FunctionBlockId** parameters.
 * > You must specify up to 10 identifiers for the **PropertyIdentifier.N**, **ServiceIdentifier.N**, or **EventIdentifier.N** parameter.
 * *   After you call the DeleteThingModel operation to remove one or more features from a product, you must call the [PublishThingModel](~~150311~~) operation to re-publish the TSL model of the product. This way, the change takes effect.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 5 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request DeleteThingModelRequest
 * @return DeleteThingModelResponse
 */
func (client *Client) DeleteThingModel(request *DeleteThingModelRequest) (_result *DeleteThingModelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteThingModelResponse{}
	_body, _err := client.DeleteThingModelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DeleteTopicConfigWithOptions(request *DeleteTopicConfigRequest, runtime *util.RuntimeOptions) (_result *DeleteTopicConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.TopicFullName)) {
		query["TopicFullName"] = request.TopicFullName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTopicConfig"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTopicConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DeleteTopicConfig(request *DeleteTopicConfigRequest) (_result *DeleteTopicConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTopicConfigResponse{}
	_body, _err := client.DeleteTopicConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteTopicRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteTopicRouteTableResponse
 */
func (client *Client) DeleteTopicRouteTableWithOptions(request *DeleteTopicRouteTableRequest, runtime *util.RuntimeOptions) (_result *DeleteTopicRouteTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DstTopic)) {
		query["DstTopic"] = request.DstTopic
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SrcTopic)) {
		query["SrcTopic"] = request.SrcTopic
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DeleteTopicRouteTable"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DeleteTopicRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DeleteTopicRouteTableRequest
 * @return DeleteTopicRouteTableResponse
 */
func (client *Client) DeleteTopicRouteTable(request *DeleteTopicRouteTableRequest) (_result *DeleteTopicRouteTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DeleteTopicRouteTableResponse{}
	_body, _err := client.DeleteTopicRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request DetachDestinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachDestinationResponse
 */
func (client *Client) DetachDestinationWithOptions(request *DetachDestinationRequest, runtime *util.RuntimeOptions) (_result *DetachDestinationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DestinationId)) {
		query["DestinationId"] = request.DestinationId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ParserId)) {
		query["ParserId"] = request.ParserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachDestination"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachDestinationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request DetachDestinationRequest
 * @return DetachDestinationResponse
 */
func (client *Client) DetachDestination(request *DetachDestinationRequest) (_result *DetachDestinationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachDestinationResponse{}
	_body, _err := client.DetachDestinationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DetachParserDataSourceWithOptions(request *DetachParserDataSourceRequest, runtime *util.RuntimeOptions) (_result *DetachParserDataSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataSourceId)) {
		query["DataSourceId"] = request.DataSourceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ParserId)) {
		query["ParserId"] = request.ParserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DetachParserDataSource"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DetachParserDataSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DetachParserDataSource(request *DetachParserDataSourceRequest) (_result *DetachParserDataSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DetachParserDataSourceResponse{}
	_body, _err := client.DetachParserDataSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisableDeviceTunnelWithOptions(request *DisableDeviceTunnelRequest, runtime *util.RuntimeOptions) (_result *DisableDeviceTunnelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableDeviceTunnel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableDeviceTunnelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisableDeviceTunnel(request *DisableDeviceTunnelRequest) (_result *DisableDeviceTunnelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableDeviceTunnelResponse{}
	_body, _err := client.DisableDeviceTunnelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisableDeviceTunnelShareWithOptions(request *DisableDeviceTunnelShareRequest, runtime *util.RuntimeOptions) (_result *DisableDeviceTunnelShareResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableDeviceTunnelShare"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableDeviceTunnelShareResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisableDeviceTunnelShare(request *DisableDeviceTunnelShareRequest) (_result *DisableDeviceTunnelShareResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableDeviceTunnelShareResponse{}
	_body, _err := client.DisableDeviceTunnelShareWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) DisableSceneRuleWithOptions(request *DisableSceneRuleRequest, runtime *util.RuntimeOptions) (_result *DisableSceneRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableSceneRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableSceneRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) DisableSceneRule(request *DisableSceneRuleRequest) (_result *DisableSceneRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableSceneRuleResponse{}
	_body, _err := client.DisableSceneRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   After a device is disabled, you cannot connect the device to IoT Platform. You can perform device-specific operations on the device. However, the information about the device is still retained in IoT Platform. You can use the [EnableThing](~~69603~~) API operation to connect the disabled device to IoT Platform again.
 * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DisableThingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableThingResponse
 */
func (client *Client) DisableThingWithOptions(request *DisableThingRequest, runtime *util.RuntimeOptions) (_result *DisableThingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("DisableThing"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &DisableThingResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   After a device is disabled, you cannot connect the device to IoT Platform. You can perform device-specific operations on the device. However, the information about the device is still retained in IoT Platform. You can use the [EnableThing](~~69603~~) API operation to connect the disabled device to IoT Platform again.
 * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request DisableThingRequest
 * @return DisableThingResponse
 */
func (client *Client) DisableThing(request *DisableThingRequest) (_result *DisableThingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &DisableThingResponse{}
	_body, _err := client.DisableThingWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnableDeviceTunnelWithOptions(request *EnableDeviceTunnelRequest, runtime *util.RuntimeOptions) (_result *EnableDeviceTunnelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableDeviceTunnel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableDeviceTunnelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnableDeviceTunnel(request *EnableDeviceTunnelRequest) (_result *EnableDeviceTunnelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableDeviceTunnelResponse{}
	_body, _err := client.EnableDeviceTunnelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnableDeviceTunnelShareWithOptions(request *EnableDeviceTunnelShareRequest, runtime *util.RuntimeOptions) (_result *EnableDeviceTunnelShareResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableDeviceTunnelShare"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableDeviceTunnelShareResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnableDeviceTunnelShare(request *EnableDeviceTunnelShareRequest) (_result *EnableDeviceTunnelShareResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableDeviceTunnelShareResponse{}
	_body, _err := client.EnableDeviceTunnelShareWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) EnableSceneRuleWithOptions(request *EnableSceneRuleRequest, runtime *util.RuntimeOptions) (_result *EnableSceneRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableSceneRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableSceneRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) EnableSceneRule(request *EnableSceneRuleRequest) (_result *EnableSceneRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableSceneRuleResponse{}
	_body, _err := client.EnableSceneRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request EnableThingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableThingResponse
 */
func (client *Client) EnableThingWithOptions(request *EnableThingRequest, runtime *util.RuntimeOptions) (_result *EnableThingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("EnableThing"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &EnableThingResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request EnableThingRequest
 * @return EnableThingResponse
 */
func (client *Client) EnableThing(request *EnableThingRequest) (_result *EnableThingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &EnableThingResponse{}
	_body, _err := client.EnableThingWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation can be used with other operations to upload a device list file. Procedure:
 * 1. Call this operation to generate the information of a device list file that you want to upload to OSS.
 * The response parameters of this API operation include:
 * The following request parameters of the OSS [PostObject](/help/en/object-storage-service/latest/postobject) operation that is used to upload the device list file: **Key**, **AccessKeyId**, **Signature**, and **Policy**.
 * 2. Use an [OSS SDK](/help/en/object-storage-service/latest/sdk-code-samples-overview) to call the [PostObject](/help/en/object-storage-service/latest/postobject) operation to upload the device list file within 1 minute after a response is returned. For more information about sample code, see the "Usage of response parameters" section in this topic.
 * >  The parameter information that is returned by this operation is valid for 1 minute. You must upload the device list file within 1 minute.  3. After you upload the device list file, call the [CreateOTAStaticUpgradeJob](/help/en/iot-platform/latest/e1qtmo) operation of IoT Platform to create a static update batch within 60 minutes.
 * If you upload device list files but you do not call the CreateOTAStaticUpgradeJob operation to create a static update batch, the system automatically deletes the uploaded files. The system deletes files on a regular basis.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 * ## Requirements
 * *   A device list file contains the names of devices. Separate multiple device names with line feeds. Each line contains only one device name. A device list file must be in the CSV format. The maximum size of a device list file is 5 MB.
 * *   Each device list file can contain up to 10,000 names for the devices in a product that is related to an update package. If the number of device names in a device list file exceeds the limit, an error occurs when you use the file to create a static update batch.
 *
 * @param request GenerateDeviceNameListURLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateDeviceNameListURLResponse
 */
func (client *Client) GenerateDeviceNameListURLWithOptions(request *GenerateDeviceNameListURLRequest, runtime *util.RuntimeOptions) (_result *GenerateDeviceNameListURLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GenerateDeviceNameListURL"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GenerateDeviceNameListURLResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation can be used with other operations to upload a device list file. Procedure:
 * 1. Call this operation to generate the information of a device list file that you want to upload to OSS.
 * The response parameters of this API operation include:
 * The following request parameters of the OSS [PostObject](/help/en/object-storage-service/latest/postobject) operation that is used to upload the device list file: **Key**, **AccessKeyId**, **Signature**, and **Policy**.
 * 2. Use an [OSS SDK](/help/en/object-storage-service/latest/sdk-code-samples-overview) to call the [PostObject](/help/en/object-storage-service/latest/postobject) operation to upload the device list file within 1 minute after a response is returned. For more information about sample code, see the "Usage of response parameters" section in this topic.
 * >  The parameter information that is returned by this operation is valid for 1 minute. You must upload the device list file within 1 minute.  3. After you upload the device list file, call the [CreateOTAStaticUpgradeJob](/help/en/iot-platform/latest/e1qtmo) operation of IoT Platform to create a static update batch within 60 minutes.
 * If you upload device list files but you do not call the CreateOTAStaticUpgradeJob operation to create a static update batch, the system automatically deletes the uploaded files. The system deletes files on a regular basis.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 * ## Requirements
 * *   A device list file contains the names of devices. Separate multiple device names with line feeds. Each line contains only one device name. A device list file must be in the CSV format. The maximum size of a device list file is 5 MB.
 * *   Each device list file can contain up to 10,000 names for the devices in a product that is related to an update package. If the number of device names in a device list file exceeds the limit, an error occurs when you use the file to create a static update batch.
 *
 * @param request GenerateDeviceNameListURLRequest
 * @return GenerateDeviceNameListURLResponse
 */
func (client *Client) GenerateDeviceNameListURL(request *GenerateDeviceNameListURLRequest) (_result *GenerateDeviceNameListURLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GenerateDeviceNameListURLResponse{}
	_body, _err := client.GenerateDeviceNameListURLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GenerateFileUploadURLWithOptions(request *GenerateFileUploadURLRequest, runtime *util.RuntimeOptions) (_result *GenerateFileUploadURLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BizCode)) {
		query["BizCode"] = request.BizCode
	}

	if !tea.BoolValue(util.IsUnset(request.FileName)) {
		query["FileName"] = request.FileName
	}

	if !tea.BoolValue(util.IsUnset(request.FileSuffix)) {
		query["FileSuffix"] = request.FileSuffix
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GenerateFileUploadURL"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GenerateFileUploadURLResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GenerateFileUploadURL(request *GenerateFileUploadURLRequest) (_result *GenerateFileUploadURLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GenerateFileUploadURLResponse{}
	_body, _err := client.GenerateFileUploadURLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation can be used together with other operations to create an update package. Procedure:
 * 1\\. Call this API operation to generate the details of an update package file that you want to upload to OSS.
 * The following section describes the response parameters of this API operation:
 * *   The following request parameters of the OSS [PostObject](~~31988~~) operation that is used to upload the update package file: **Key**, **OSSAccessKeyId**, **Signature**, and **Policy**.
 * *   The following request parameter of the [CreateOTAFirmware](~~147311~~) operation that is used to create the update package: **FirmwareUrl**.
 * 2\\. Use an [OSS SDK](~~52834~~) to call the [PostObject](~~31988~~) operation to upload the update package file. For more information about sample code, see the "Usage of response parameters" section.
 * > The parameter information that is returned by this operation is valid for 1 minute. You must upload the update package file within 1 minute. The maximum size of the uploaded update package file is 1,000 MB.
 * 3\\. After the update package file is uploaded, call the [CreateOTAFirmware](~~147311~~) operation to create an update package within 60 minutes.
 * If update package files are uploaded but you do not call the CreateOTAFirmware operation to create update packages for the files, the uploaded files are automatically deleted by the system on a regular basis.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request GenerateOTAUploadURLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GenerateOTAUploadURLResponse
 */
func (client *Client) GenerateOTAUploadURLWithOptions(request *GenerateOTAUploadURLRequest, runtime *util.RuntimeOptions) (_result *GenerateOTAUploadURLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FileSuffix)) {
		query["FileSuffix"] = request.FileSuffix
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GenerateOTAUploadURL"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GenerateOTAUploadURLResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation can be used together with other operations to create an update package. Procedure:
 * 1\\. Call this API operation to generate the details of an update package file that you want to upload to OSS.
 * The following section describes the response parameters of this API operation:
 * *   The following request parameters of the OSS [PostObject](~~31988~~) operation that is used to upload the update package file: **Key**, **OSSAccessKeyId**, **Signature**, and **Policy**.
 * *   The following request parameter of the [CreateOTAFirmware](~~147311~~) operation that is used to create the update package: **FirmwareUrl**.
 * 2\\. Use an [OSS SDK](~~52834~~) to call the [PostObject](~~31988~~) operation to upload the update package file. For more information about sample code, see the "Usage of response parameters" section.
 * > The parameter information that is returned by this operation is valid for 1 minute. You must upload the update package file within 1 minute. The maximum size of the uploaded update package file is 1,000 MB.
 * 3\\. After the update package file is uploaded, call the [CreateOTAFirmware](~~147311~~) operation to create an update package within 60 minutes.
 * If update package files are uploaded but you do not call the CreateOTAFirmware operation to create update packages for the files, the uploaded files are automatically deleted by the system on a regular basis.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request GenerateOTAUploadURLRequest
 * @return GenerateOTAUploadURLResponse
 */
func (client *Client) GenerateOTAUploadURL(request *GenerateOTAUploadURLRequest) (_result *GenerateOTAUploadURLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GenerateOTAUploadURLResponse{}
	_body, _err := client.GenerateOTAUploadURLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDataAPIServiceDetailWithOptions(request *GetDataAPIServiceDetailRequest, runtime *util.RuntimeOptions) (_result *GetDataAPIServiceDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiSrn)) {
		body["ApiSrn"] = request.ApiSrn
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDataAPIServiceDetail"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDataAPIServiceDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDataAPIServiceDetail(request *GetDataAPIServiceDetailRequest) (_result *GetDataAPIServiceDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDataAPIServiceDetailResponse{}
	_body, _err := client.GetDataAPIServiceDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDestinationWithOptions(request *GetDestinationRequest, runtime *util.RuntimeOptions) (_result *GetDestinationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DestinationId)) {
		query["DestinationId"] = request.DestinationId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDestination"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDestinationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDestination(request *GetDestinationRequest) (_result *GetDestinationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDestinationResponse{}
	_body, _err := client.GetDestinationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 500 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetDeviceShadowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDeviceShadowResponse
 */
func (client *Client) GetDeviceShadowWithOptions(request *GetDeviceShadowRequest, runtime *util.RuntimeOptions) (_result *GetDeviceShadowResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDeviceShadow"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDeviceShadowResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 500 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetDeviceShadowRequest
 * @return GetDeviceShadowResponse
 */
func (client *Client) GetDeviceShadow(request *GetDeviceShadowRequest) (_result *GetDeviceShadowResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDeviceShadowResponse{}
	_body, _err := client.GetDeviceShadowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetDeviceStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDeviceStatusResponse
 */
func (client *Client) GetDeviceStatusWithOptions(request *GetDeviceStatusRequest, runtime *util.RuntimeOptions) (_result *GetDeviceStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDeviceStatus"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDeviceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetDeviceStatusRequest
 * @return GetDeviceStatusResponse
 */
func (client *Client) GetDeviceStatus(request *GetDeviceStatusRequest) (_result *GetDeviceStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDeviceStatusResponse{}
	_body, _err := client.GetDeviceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDeviceTunnelShareStatusWithOptions(request *GetDeviceTunnelShareStatusRequest, runtime *util.RuntimeOptions) (_result *GetDeviceTunnelShareStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDeviceTunnelShareStatus"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDeviceTunnelShareStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDeviceTunnelShareStatus(request *GetDeviceTunnelShareStatusRequest) (_result *GetDeviceTunnelShareStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDeviceTunnelShareStatusResponse{}
	_body, _err := client.GetDeviceTunnelShareStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDeviceTunnelStatusWithOptions(request *GetDeviceTunnelStatusRequest, runtime *util.RuntimeOptions) (_result *GetDeviceTunnelStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDeviceTunnelStatus"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDeviceTunnelStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDeviceTunnelStatus(request *GetDeviceTunnelStatusRequest) (_result *GetDeviceTunnelStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDeviceTunnelStatusResponse{}
	_body, _err := client.GetDeviceTunnelStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetDownloadFileWithOptions(tmpReq *GetDownloadFileRequest, runtime *util.RuntimeOptions) (_result *GetDownloadFileResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &GetDownloadFileShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Context)) {
		request.ContextShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Context, tea.String("Context"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.LongJobId)) {
		query["LongJobId"] = request.LongJobId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContextShrink)) {
		body["Context"] = request.ContextShrink
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetDownloadFile"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetDownloadFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetDownloadFile(request *GetDownloadFileRequest) (_result *GetDownloadFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetDownloadFileResponse{}
	_body, _err := client.GetDownloadFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetEdgeDriverVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEdgeDriverVersionResponse
 */
func (client *Client) GetEdgeDriverVersionWithOptions(request *GetEdgeDriverVersionRequest, runtime *util.RuntimeOptions) (_result *GetEdgeDriverVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.DriverVersion)) {
		query["DriverVersion"] = request.DriverVersion
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetEdgeDriverVersion"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetEdgeDriverVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetEdgeDriverVersionRequest
 * @return GetEdgeDriverVersionResponse
 */
func (client *Client) GetEdgeDriverVersion(request *GetEdgeDriverVersionRequest) (_result *GetEdgeDriverVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetEdgeDriverVersionResponse{}
	_body, _err := client.GetEdgeDriverVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEdgeInstanceResponse
 */
func (client *Client) GetEdgeInstanceWithOptions(request *GetEdgeInstanceRequest, runtime *util.RuntimeOptions) (_result *GetEdgeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetEdgeInstance"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetEdgeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetEdgeInstanceRequest
 * @return GetEdgeInstanceResponse
 */
func (client *Client) GetEdgeInstance(request *GetEdgeInstanceRequest) (_result *GetEdgeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetEdgeInstanceResponse{}
	_body, _err := client.GetEdgeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetEdgeInstanceDeploymentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetEdgeInstanceDeploymentResponse
 */
func (client *Client) GetEdgeInstanceDeploymentWithOptions(request *GetEdgeInstanceDeploymentRequest, runtime *util.RuntimeOptions) (_result *GetEdgeInstanceDeploymentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeploymentId)) {
		query["DeploymentId"] = request.DeploymentId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetEdgeInstanceDeployment"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetEdgeInstanceDeploymentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetEdgeInstanceDeploymentRequest
 * @return GetEdgeInstanceDeploymentResponse
 */
func (client *Client) GetEdgeInstanceDeployment(request *GetEdgeInstanceDeploymentRequest) (_result *GetEdgeInstanceDeploymentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetEdgeInstanceDeploymentResponse{}
	_body, _err := client.GetEdgeInstanceDeploymentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetEdgeInstanceMessageRoutingWithOptions(request *GetEdgeInstanceMessageRoutingRequest, runtime *util.RuntimeOptions) (_result *GetEdgeInstanceMessageRoutingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RouteId)) {
		query["RouteId"] = request.RouteId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetEdgeInstanceMessageRouting"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetEdgeInstanceMessageRoutingResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetEdgeInstanceMessageRouting(request *GetEdgeInstanceMessageRoutingRequest) (_result *GetEdgeInstanceMessageRoutingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetEdgeInstanceMessageRoutingResponse{}
	_body, _err := client.GetEdgeInstanceMessageRoutingWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetGatewayBySubDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetGatewayBySubDeviceResponse
 */
func (client *Client) GetGatewayBySubDeviceWithOptions(request *GetGatewayBySubDeviceRequest, runtime *util.RuntimeOptions) (_result *GetGatewayBySubDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetGatewayBySubDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetGatewayBySubDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetGatewayBySubDeviceRequest
 * @return GetGatewayBySubDeviceResponse
 */
func (client *Client) GetGatewayBySubDevice(request *GetGatewayBySubDeviceRequest) (_result *GetGatewayBySubDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetGatewayBySubDeviceResponse{}
	_body, _err := client.GetGatewayBySubDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * You can call this API operation up to 50 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetLoraNodesTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLoraNodesTaskResponse
 */
func (client *Client) GetLoraNodesTaskWithOptions(request *GetLoraNodesTaskRequest, runtime *util.RuntimeOptions) (_result *GetLoraNodesTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetLoraNodesTask"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetLoraNodesTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * You can call this API operation up to 50 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetLoraNodesTaskRequest
 * @return GetLoraNodesTaskResponse
 */
func (client *Client) GetLoraNodesTask(request *GetLoraNodesTaskRequest) (_result *GetLoraNodesTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetLoraNodesTaskResponse{}
	_body, _err := client.GetLoraNodesTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetParserWithOptions(request *GetParserRequest, runtime *util.RuntimeOptions) (_result *GetParserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ParserId)) {
		query["ParserId"] = request.ParserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetParser"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetParserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetParser(request *GetParserRequest) (_result *GetParserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetParserResponse{}
	_body, _err := client.GetParserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetParserDataSourceWithOptions(request *GetParserDataSourceRequest, runtime *util.RuntimeOptions) (_result *GetParserDataSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataSourceId)) {
		query["DataSourceId"] = request.DataSourceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetParserDataSource"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetParserDataSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetParserDataSource(request *GetParserDataSourceRequest) (_result *GetParserDataSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetParserDataSourceResponse{}
	_body, _err := client.GetParserDataSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRuleResponse
 */
func (client *Client) GetRuleWithOptions(request *GetRuleRequest, runtime *util.RuntimeOptions) (_result *GetRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetRuleRequest
 * @return GetRuleResponse
 */
func (client *Client) GetRule(request *GetRuleRequest) (_result *GetRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetRuleResponse{}
	_body, _err := client.GetRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
 *
 * @param request GetRuleActionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRuleActionResponse
 */
func (client *Client) GetRuleActionWithOptions(request *GetRuleActionRequest, runtime *util.RuntimeOptions) (_result *GetRuleActionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActionId)) {
		query["ActionId"] = request.ActionId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetRuleAction"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetRuleActionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
 *
 * @param request GetRuleActionRequest
 * @return GetRuleActionResponse
 */
func (client *Client) GetRuleAction(request *GetRuleActionRequest) (_result *GetRuleActionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetRuleActionResponse{}
	_body, _err := client.GetRuleActionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetSceneRuleWithOptions(request *GetSceneRuleRequest, runtime *util.RuntimeOptions) (_result *GetSceneRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSceneRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSceneRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetSceneRule(request *GetSceneRuleRequest) (_result *GetSceneRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSceneRuleResponse{}
	_body, _err := client.GetSceneRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetShareSpeechModelAudioWithOptions(request *GetShareSpeechModelAudioRequest, runtime *util.RuntimeOptions) (_result *GetShareSpeechModelAudioResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ShareTaskId)) {
		body["ShareTaskId"] = request.ShareTaskId
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechModelCodeList)) {
		body["SpeechModelCodeList"] = request.SpeechModelCodeList
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetShareSpeechModelAudio"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetShareSpeechModelAudioResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetShareSpeechModelAudio(request *GetShareSpeechModelAudioRequest) (_result *GetShareSpeechModelAudioResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetShareSpeechModelAudioResponse{}
	_body, _err := client.GetShareSpeechModelAudioWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetShareTaskByDeviceOpenWithOptions(request *GetShareTaskByDeviceOpenRequest, runtime *util.RuntimeOptions) (_result *GetShareTaskByDeviceOpenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		body["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		body["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		body["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetShareTaskByDeviceOpen"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetShareTaskByDeviceOpenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetShareTaskByDeviceOpen(request *GetShareTaskByDeviceOpenRequest) (_result *GetShareTaskByDeviceOpenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetShareTaskByDeviceOpenResponse{}
	_body, _err := client.GetShareTaskByDeviceOpenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetSoundCodeAudioWithOptions(request *GetSoundCodeAudioRequest, runtime *util.RuntimeOptions) (_result *GetSoundCodeAudioResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SoundCodeList)) {
		body["SoundCodeList"] = request.SoundCodeList
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSoundCodeAudio"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSoundCodeAudioResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetSoundCodeAudio(request *GetSoundCodeAudioRequest) (_result *GetSoundCodeAudioResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSoundCodeAudioResponse{}
	_body, _err := client.GetSoundCodeAudioWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetSoundCodeScheduleWithOptions(request *GetSoundCodeScheduleRequest, runtime *util.RuntimeOptions) (_result *GetSoundCodeScheduleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduleCode)) {
		body["ScheduleCode"] = request.ScheduleCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSoundCodeSchedule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSoundCodeScheduleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetSoundCodeSchedule(request *GetSoundCodeScheduleRequest) (_result *GetSoundCodeScheduleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSoundCodeScheduleResponse{}
	_body, _err := client.GetSoundCodeScheduleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetSpeechDeviceDetailWithOptions(request *GetSpeechDeviceDetailRequest, runtime *util.RuntimeOptions) (_result *GetSpeechDeviceDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		body["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSpeechDeviceDetail"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSpeechDeviceDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetSpeechDeviceDetail(request *GetSpeechDeviceDetailRequest) (_result *GetSpeechDeviceDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSpeechDeviceDetailResponse{}
	_body, _err := client.GetSpeechDeviceDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to three times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetSpeechLicenseDeviceStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSpeechLicenseDeviceStatisticsResponse
 */
func (client *Client) GetSpeechLicenseDeviceStatisticsWithOptions(request *GetSpeechLicenseDeviceStatisticsRequest, runtime *util.RuntimeOptions) (_result *GetSpeechLicenseDeviceStatisticsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetSpeechLicenseDeviceStatistics"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSpeechLicenseDeviceStatisticsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to three times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetSpeechLicenseDeviceStatisticsRequest
 * @return GetSpeechLicenseDeviceStatisticsResponse
 */
func (client *Client) GetSpeechLicenseDeviceStatistics(request *GetSpeechLicenseDeviceStatisticsRequest) (_result *GetSpeechLicenseDeviceStatisticsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSpeechLicenseDeviceStatisticsResponse{}
	_body, _err := client.GetSpeechLicenseDeviceStatisticsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetSpeechVoiceWithOptions(runtime *util.RuntimeOptions) (_result *GetSpeechVoiceResponse, _err error) {
	req := &openapi.OpenApiRequest{}
	params := &openapi.Params{
		Action:      tea.String("GetSpeechVoice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetSpeechVoiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetSpeechVoice() (_result *GetSpeechVoiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetSpeechVoiceResponse{}
	_body, _err := client.GetSpeechVoiceWithOptions(runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GetStudioAppTokenOpenWithOptions(request *GetStudioAppTokenOpenRequest, runtime *util.RuntimeOptions) (_result *GetStudioAppTokenOpenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		body["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("GetStudioAppTokenOpen"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetStudioAppTokenOpenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GetStudioAppTokenOpen(request *GetStudioAppTokenOpenRequest) (_result *GetStudioAppTokenOpenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetStudioAppTokenOpenResponse{}
	_body, _err := client.GetStudioAppTokenOpenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
 *
 * @param request GetThingModelTslRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetThingModelTslResponse
 */
func (client *Client) GetThingModelTslWithOptions(request *GetThingModelTslRequest, runtime *util.RuntimeOptions) (_result *GetThingModelTslResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FunctionBlockId)) {
		query["FunctionBlockId"] = request.FunctionBlockId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ModelVersion)) {
		query["ModelVersion"] = request.ModelVersion
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Simple)) {
		query["Simple"] = request.Simple
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetThingModelTsl"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetThingModelTslResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
 *
 * @param request GetThingModelTslRequest
 * @return GetThingModelTslResponse
 */
func (client *Client) GetThingModelTsl(request *GetThingModelTslRequest) (_result *GetThingModelTslResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetThingModelTslResponse{}
	_body, _err := client.GetThingModelTslWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetThingModelTslPublishedRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetThingModelTslPublishedResponse
 */
func (client *Client) GetThingModelTslPublishedWithOptions(request *GetThingModelTslPublishedRequest, runtime *util.RuntimeOptions) (_result *GetThingModelTslPublishedResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FunctionBlockId)) {
		query["FunctionBlockId"] = request.FunctionBlockId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ModelVersion)) {
		query["ModelVersion"] = request.ModelVersion
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Simple)) {
		query["Simple"] = request.Simple
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetThingModelTslPublished"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetThingModelTslPublishedResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetThingModelTslPublishedRequest
 * @return GetThingModelTslPublishedResponse
 */
func (client *Client) GetThingModelTslPublished(request *GetThingModelTslPublishedRequest) (_result *GetThingModelTslPublishedResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetThingModelTslPublishedResponse{}
	_body, _err := client.GetThingModelTslPublishedWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   A data parsing script is used to convert the custom-formatted data to JSON data after the data is submitted by a device. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetThingScriptRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetThingScriptResponse
 */
func (client *Client) GetThingScriptWithOptions(request *GetThingScriptRequest, runtime *util.RuntimeOptions) (_result *GetThingScriptResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetThingScript"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetThingScriptResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   A data parsing script is used to convert the custom-formatted data to JSON data after the data is submitted by a device. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetThingScriptRequest
 * @return GetThingScriptResponse
 */
func (client *Client) GetThingScript(request *GetThingScriptRequest) (_result *GetThingScriptResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetThingScriptResponse{}
	_body, _err := client.GetThingScriptWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetThingTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetThingTemplateResponse
 */
func (client *Client) GetThingTemplateWithOptions(request *GetThingTemplateRequest, runtime *util.RuntimeOptions) (_result *GetThingTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CategoryKey)) {
		query["CategoryKey"] = request.CategoryKey
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetThingTemplate"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetThingTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 2 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetThingTemplateRequest
 * @return GetThingTemplateResponse
 */
func (client *Client) GetThingTemplate(request *GetThingTemplateRequest) (_result *GetThingTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetThingTemplateResponse{}
	_body, _err := client.GetThingTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can initiate a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetThingTopoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetThingTopoResponse
 */
func (client *Client) GetThingTopoWithOptions(request *GetThingTopoRequest, runtime *util.RuntimeOptions) (_result *GetThingTopoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GetThingTopo"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GetThingTopoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can initiate a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request GetThingTopoRequest
 * @return GetThingTopoResponse
 */
func (client *Client) GetThingTopo(request *GetThingTopoRequest) (_result *GetThingTopoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GetThingTopoResponse{}
	_body, _err := client.GetThingTopoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GisQueryDeviceLocationWithOptions(request *GisQueryDeviceLocationRequest, runtime *util.RuntimeOptions) (_result *GisQueryDeviceLocationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ThingList)) {
		query["ThingList"] = request.ThingList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GisQueryDeviceLocation"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GisQueryDeviceLocationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GisQueryDeviceLocation(request *GisQueryDeviceLocationRequest) (_result *GisQueryDeviceLocationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GisQueryDeviceLocationResponse{}
	_body, _err := client.GisQueryDeviceLocationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) GisSearchDeviceTraceWithOptions(request *GisSearchDeviceTraceRequest, runtime *util.RuntimeOptions) (_result *GisSearchDeviceTraceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MapMatch)) {
		query["MapMatch"] = request.MapMatch
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("GisSearchDeviceTrace"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &GisSearchDeviceTraceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) GisSearchDeviceTrace(request *GisSearchDeviceTraceRequest) (_result *GisSearchDeviceTraceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &GisSearchDeviceTraceResponse{}
	_body, _err := client.GisSearchDeviceTraceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ImportDTDataWithOptions(request *ImportDTDataRequest, runtime *util.RuntimeOptions) (_result *ImportDTDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DTInstanceId)) {
		query["DTInstanceId"] = request.DTInstanceId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Items)) {
		body["Items"] = request.Items
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		body["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ImportDTData"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ImportDTDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ImportDTData(request *ImportDTDataRequest) (_result *ImportDTDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ImportDTDataResponse{}
	_body, _err := client.ImportDTDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * Before you call this operation, make sure that an MQTT gateway and the related product are created and the **ProductKey** of the product is obtained. For more information, see [Create an MQTT gateway](~~433804~~).
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ImportDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportDeviceResponse
 */
func (client *Client) ImportDeviceWithOptions(request *ImportDeviceRequest, runtime *util.RuntimeOptions) (_result *ImportDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceSecret)) {
		query["DeviceSecret"] = request.DeviceSecret
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Nickname)) {
		query["Nickname"] = request.Nickname
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Sn)) {
		query["Sn"] = request.Sn
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ImportDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ImportDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * Before you call this operation, make sure that an MQTT gateway and the related product are created and the **ProductKey** of the product is obtained. For more information, see [Create an MQTT gateway](~~433804~~).
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ImportDeviceRequest
 * @return ImportDeviceResponse
 */
func (client *Client) ImportDevice(request *ImportDeviceRequest) (_result *ImportDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ImportDeviceResponse{}
	_body, _err := client.ImportDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ImportThingModelTslRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportThingModelTslResponse
 */
func (client *Client) ImportThingModelTslWithOptions(request *ImportThingModelTslRequest, runtime *util.RuntimeOptions) (_result *ImportThingModelTslResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FunctionBlockId)) {
		query["FunctionBlockId"] = request.FunctionBlockId
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionBlockName)) {
		query["FunctionBlockName"] = request.FunctionBlockName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.TslStr)) {
		query["TslStr"] = request.TslStr
	}

	if !tea.BoolValue(util.IsUnset(request.TslUrl)) {
		query["TslUrl"] = request.TslUrl
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ImportThingModelTsl"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ImportThingModelTslResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ImportThingModelTslRequest
 * @return ImportThingModelTslResponse
 */
func (client *Client) ImportThingModelTsl(request *ImportThingModelTslRequest) (_result *ImportThingModelTslResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ImportThingModelTslResponse{}
	_body, _err := client.ImportThingModelTslWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) InvokeDataAPIServiceWithOptions(request *InvokeDataAPIServiceRequest, runtime *util.RuntimeOptions) (_result *InvokeDataAPIServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiSrn)) {
		body["ApiSrn"] = request.ApiSrn
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Param)) {
		body["Param"] = request.Param
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("InvokeDataAPIService"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &InvokeDataAPIServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) InvokeDataAPIService(request *InvokeDataAPIServiceRequest) (_result *InvokeDataAPIServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &InvokeDataAPIServiceResponse{}
	_body, _err := client.InvokeDataAPIServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you define a service in a Thing Specification Language (TSL) model, the mode in which the service is called is specified. When you call a service by using this operation, IoT Platform uses a call mode based on the value of the **Identifier** parameter.
 * *   Synchronous mode: IoT Platform sends a revert-remote procedure call (RRPC) request to a device. Then, the device synchronously returns an RRPC response. For more information about how to use an RRPC, see [What is RRPC?](~~90567~~)
 * *   Asynchronous mode: IoT Platform sends an RRPC request to a device. Then, the device asynchronously returns an RRPC response. For more information about topics, see [Device properties, events, and services](~~89301~~).
 * > If you set the Checksum Type parameter to **Verification-free** when you create a product, the asynchronous mode is used.
 * When the device receives the service call, the device returns a response to the service caller. When you configure the device, you must specify the response logic and response parameters. The data formats of response parameters must comply with the Alink protocol. Example:
 * ```
 * {
 * 	"id": "58***89",
 * 	"code": 200,
 * 	"data": {},
 * 	"message": "success",
 * 	"localizedMsg": "localizedMsg"
 * }
 * ```
 * > *   The **id** parameter specifies the unique identifier of the request. The ID is generated by IoT Platform. The device can obtain the ID from the request parameters and then return the ID.
 * >*   The **code** parameter specifies the result of the service call. The value of the parameter is an integer.
 * >*   The **data** parameter specifies the result of the service call. This parameter is returned to the service caller. You can configure the parameters that you want to include in the returned result. The data must be in the JSON format.
 * >*   The **message** and **localizedMsg** parameters are optional.
 * >*   Link SDK for C of IoT Platform provides an example on how to use a TSL model. For more information, see [Call device services](~~258239~~).
 * ## Limits
 * If you synchronously call a service, the timeout period is 8 seconds. If a server does not receive a response within 8 seconds, a timeout error occurs. No limit is imposed on the timeout period of asynchronous calls.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request InvokeThingServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InvokeThingServiceResponse
 */
func (client *Client) InvokeThingServiceWithOptions(request *InvokeThingServiceRequest, runtime *util.RuntimeOptions) (_result *InvokeThingServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Args)) {
		query["Args"] = request.Args
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.Identifier)) {
		query["Identifier"] = request.Identifier
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Qos)) {
		query["Qos"] = request.Qos
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InvokeThingService"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &InvokeThingServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you define a service in a Thing Specification Language (TSL) model, the mode in which the service is called is specified. When you call a service by using this operation, IoT Platform uses a call mode based on the value of the **Identifier** parameter.
 * *   Synchronous mode: IoT Platform sends a revert-remote procedure call (RRPC) request to a device. Then, the device synchronously returns an RRPC response. For more information about how to use an RRPC, see [What is RRPC?](~~90567~~)
 * *   Asynchronous mode: IoT Platform sends an RRPC request to a device. Then, the device asynchronously returns an RRPC response. For more information about topics, see [Device properties, events, and services](~~89301~~).
 * > If you set the Checksum Type parameter to **Verification-free** when you create a product, the asynchronous mode is used.
 * When the device receives the service call, the device returns a response to the service caller. When you configure the device, you must specify the response logic and response parameters. The data formats of response parameters must comply with the Alink protocol. Example:
 * ```
 * {
 * 	"id": "58***89",
 * 	"code": 200,
 * 	"data": {},
 * 	"message": "success",
 * 	"localizedMsg": "localizedMsg"
 * }
 * ```
 * > *   The **id** parameter specifies the unique identifier of the request. The ID is generated by IoT Platform. The device can obtain the ID from the request parameters and then return the ID.
 * >*   The **code** parameter specifies the result of the service call. The value of the parameter is an integer.
 * >*   The **data** parameter specifies the result of the service call. This parameter is returned to the service caller. You can configure the parameters that you want to include in the returned result. The data must be in the JSON format.
 * >*   The **message** and **localizedMsg** parameters are optional.
 * >*   Link SDK for C of IoT Platform provides an example on how to use a TSL model. For more information, see [Call device services](~~258239~~).
 * ## Limits
 * If you synchronously call a service, the timeout period is 8 seconds. If a server does not receive a response within 8 seconds, a timeout error occurs. No limit is imposed on the timeout period of asynchronous calls.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request InvokeThingServiceRequest
 * @return InvokeThingServiceResponse
 */
func (client *Client) InvokeThingService(request *InvokeThingServiceRequest) (_result *InvokeThingServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &InvokeThingServiceResponse{}
	_body, _err := client.InvokeThingServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can only asynchronously call this operation.
 * When the device receives the service call, the device returns a response to the service caller. When you configure the device, you must specify the response logic and response parameters. The data formats of response parameters must comply with the Alink protocol. Example:
 * ```
 * {
 * 	"id": "58***89",
 * 	"code": 200,
 * 	"data": {},
 * 	"message": "success",
 * 	"localizedMsg": "localizedMsg"
 * }
 * ```
 * > *   The **id** parameter specifies the unique identifier of the request. The ID is generated by IoT Platform. The device can obtain the ID from the request parameters and return the ID.
 * >*   The **code** parameter specifies the result of the service call. The value of the parameter is an integer.
 * >*   The **data** parameter specifies the result of the service call. This parameter is returned to the service caller. You can specify the parameters included in the returned result. The data must be in JSON format.
 * >*   The **message** and **localizedMsg** parameters are optional.
 * >*    Link SDK for C of IoT Platform provides an example on how to use a TSL model. For more information, see [Call device services](~~258239~~).
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request InvokeThingsServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InvokeThingsServiceResponse
 */
func (client *Client) InvokeThingsServiceWithOptions(request *InvokeThingsServiceRequest, runtime *util.RuntimeOptions) (_result *InvokeThingsServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Args)) {
		query["Args"] = request.Args
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.Identifier)) {
		query["Identifier"] = request.Identifier
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Qos)) {
		query["Qos"] = request.Qos
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("InvokeThingsService"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &InvokeThingsServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can only asynchronously call this operation.
 * When the device receives the service call, the device returns a response to the service caller. When you configure the device, you must specify the response logic and response parameters. The data formats of response parameters must comply with the Alink protocol. Example:
 * ```
 * {
 * 	"id": "58***89",
 * 	"code": 200,
 * 	"data": {},
 * 	"message": "success",
 * 	"localizedMsg": "localizedMsg"
 * }
 * ```
 * > *   The **id** parameter specifies the unique identifier of the request. The ID is generated by IoT Platform. The device can obtain the ID from the request parameters and return the ID.
 * >*   The **code** parameter specifies the result of the service call. The value of the parameter is an integer.
 * >*   The **data** parameter specifies the result of the service call. This parameter is returned to the service caller. You can specify the parameters included in the returned result. The data must be in JSON format.
 * >*   The **message** and **localizedMsg** parameters are optional.
 * >*    Link SDK for C of IoT Platform provides an example on how to use a TSL model. For more information, see [Call device services](~~258239~~).
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request InvokeThingsServiceRequest
 * @return InvokeThingsServiceResponse
 */
func (client *Client) InvokeThingsService(request *InvokeThingsServiceRequest) (_result *InvokeThingsServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &InvokeThingsServiceResponse{}
	_body, _err := client.InvokeThingsServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListAnalyticsDataWithOptions(request *ListAnalyticsDataRequest, runtime *util.RuntimeOptions) (_result *ListAnalyticsDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApiPath)) {
		query["ApiPath"] = request.ApiPath
	}

	if !tea.BoolValue(util.IsUnset(request.Condition)) {
		query["Condition"] = request.Condition
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IsoId)) {
		query["IsoId"] = request.IsoId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNum)) {
		query["PageNum"] = request.PageNum
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListAnalyticsData"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListAnalyticsDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListAnalyticsData(request *ListAnalyticsDataRequest) (_result *ListAnalyticsDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListAnalyticsDataResponse{}
	_body, _err := client.ListAnalyticsDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListDataSourceItemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDataSourceItemResponse
 */
func (client *Client) ListDataSourceItemWithOptions(request *ListDataSourceItemRequest, runtime *util.RuntimeOptions) (_result *ListDataSourceItemResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataSourceId)) {
		query["DataSourceId"] = request.DataSourceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["Page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SearchName)) {
		query["SearchName"] = request.SearchName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDataSourceItem"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDataSourceItemResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListDataSourceItemRequest
 * @return ListDataSourceItemResponse
 */
func (client *Client) ListDataSourceItem(request *ListDataSourceItemRequest) (_result *ListDataSourceItemResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDataSourceItemResponse{}
	_body, _err := client.ListDataSourceItemWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListDestinationWithOptions(request *ListDestinationRequest, runtime *util.RuntimeOptions) (_result *ListDestinationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["Page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SearchName)) {
		query["SearchName"] = request.SearchName
	}

	if !tea.BoolValue(util.IsUnset(request.Types)) {
		query["Types"] = request.Types
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDestination"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDestinationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListDestination(request *ListDestinationRequest) (_result *ListDestinationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDestinationResponse{}
	_body, _err := client.ListDestinationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you use an Enterprise Edition instance, you must specify the **IotInstanceId** parameter when you call this operation. Otherwise, the call fails.
 * ## QPS limits
 * You can call this API operation up to five times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListDeviceDistributeJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDeviceDistributeJobResponse
 */
func (client *Client) ListDeviceDistributeJobWithOptions(request *ListDeviceDistributeJobRequest, runtime *util.RuntimeOptions) (_result *ListDeviceDistributeJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	if !tea.BoolValue(util.IsUnset(request.TargetUid)) {
		query["TargetUid"] = request.TargetUid
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		body["JobId"] = request.JobId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDeviceDistributeJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDeviceDistributeJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you use an Enterprise Edition instance, you must specify the **IotInstanceId** parameter when you call this operation. Otherwise, the call fails.
 * ## QPS limits
 * You can call this API operation up to five times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListDeviceDistributeJobRequest
 * @return ListDeviceDistributeJobResponse
 */
func (client *Client) ListDeviceDistributeJob(request *ListDeviceDistributeJobRequest) (_result *ListDeviceDistributeJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDeviceDistributeJobResponse{}
	_body, _err := client.ListDeviceDistributeJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 * *   Multiple Alibaba Cloud accounts can run a maximum of 200 QPS at the same time.
 *
 * @param request ListDistributedDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDistributedDeviceResponse
 */
func (client *Client) ListDistributedDeviceWithOptions(request *ListDistributedDeviceRequest, runtime *util.RuntimeOptions) (_result *ListDistributedDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.SourceInstanceId)) {
		query["SourceInstanceId"] = request.SourceInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetUid)) {
		query["TargetUid"] = request.TargetUid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDistributedDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDistributedDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 * *   Multiple Alibaba Cloud accounts can run a maximum of 200 QPS at the same time.
 *
 * @param request ListDistributedDeviceRequest
 * @return ListDistributedDeviceResponse
 */
func (client *Client) ListDistributedDevice(request *ListDistributedDeviceRequest) (_result *ListDistributedDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDistributedDeviceResponse{}
	_body, _err := client.ListDistributedDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call this operation only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
 * ## QPS limits
 * You can call this API operation up to five times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListDistributedProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDistributedProductResponse
 */
func (client *Client) ListDistributedProductWithOptions(request *ListDistributedProductRequest, runtime *util.RuntimeOptions) (_result *ListDistributedProductResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.SourceInstanceId)) {
		query["SourceInstanceId"] = request.SourceInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetInstanceId)) {
		query["TargetInstanceId"] = request.TargetInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TargetUid)) {
		query["TargetUid"] = request.TargetUid
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListDistributedProduct"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListDistributedProductResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call this operation only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
 * ## QPS limits
 * You can call this API operation up to five times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListDistributedProductRequest
 * @return ListDistributedProductResponse
 */
func (client *Client) ListDistributedProduct(request *ListDistributedProductRequest) (_result *ListDistributedProductResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListDistributedProductResponse{}
	_body, _err := client.ListDistributedProductWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListJobWithOptions(request *ListJobRequest, runtime *util.RuntimeOptions) (_result *ListJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListJob(request *ListJobRequest) (_result *ListJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListJobResponse{}
	_body, _err := client.ListJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListOTAFirmwareRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOTAFirmwareResponse
 */
func (client *Client) ListOTAFirmwareWithOptions(request *ListOTAFirmwareRequest, runtime *util.RuntimeOptions) (_result *ListOTAFirmwareResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.DestVersion)) {
		query["DestVersion"] = request.DestVersion
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListOTAFirmware"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListOTAFirmwareResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListOTAFirmwareRequest
 * @return ListOTAFirmwareResponse
 */
func (client *Client) ListOTAFirmware(request *ListOTAFirmwareRequest) (_result *ListOTAFirmwareResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListOTAFirmwareResponse{}
	_body, _err := client.ListOTAFirmwareWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListOTAJobByDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOTAJobByDeviceResponse
 */
func (client *Client) ListOTAJobByDeviceWithOptions(request *ListOTAJobByDeviceRequest, runtime *util.RuntimeOptions) (_result *ListOTAJobByDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.FirmwareId)) {
		query["FirmwareId"] = request.FirmwareId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListOTAJobByDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListOTAJobByDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListOTAJobByDeviceRequest
 * @return ListOTAJobByDeviceResponse
 */
func (client *Client) ListOTAJobByDevice(request *ListOTAJobByDeviceRequest) (_result *ListOTAJobByDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListOTAJobByDeviceResponse{}
	_body, _err := client.ListOTAJobByDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListOTAJobByFirmwareRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOTAJobByFirmwareResponse
 */
func (client *Client) ListOTAJobByFirmwareWithOptions(request *ListOTAJobByFirmwareRequest, runtime *util.RuntimeOptions) (_result *ListOTAJobByFirmwareResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.FirmwareId)) {
		query["FirmwareId"] = request.FirmwareId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListOTAJobByFirmware"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListOTAJobByFirmwareResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListOTAJobByFirmwareRequest
 * @return ListOTAJobByFirmwareResponse
 */
func (client *Client) ListOTAJobByFirmware(request *ListOTAJobByFirmwareRequest) (_result *ListOTAJobByFirmwareResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListOTAJobByFirmwareResponse{}
	_body, _err := client.ListOTAJobByFirmwareWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListOTAModuleByProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOTAModuleByProductResponse
 */
func (client *Client) ListOTAModuleByProductWithOptions(request *ListOTAModuleByProductRequest, runtime *util.RuntimeOptions) (_result *ListOTAModuleByProductResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListOTAModuleByProduct"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListOTAModuleByProductResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListOTAModuleByProductRequest
 * @return ListOTAModuleByProductResponse
 */
func (client *Client) ListOTAModuleByProduct(request *ListOTAModuleByProductRequest) (_result *ListOTAModuleByProductResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListOTAModuleByProductResponse{}
	_body, _err := client.ListOTAModuleByProductWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListOTAModuleVersionsByDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOTAModuleVersionsByDeviceResponse
 */
func (client *Client) ListOTAModuleVersionsByDeviceWithOptions(request *ListOTAModuleVersionsByDeviceRequest, runtime *util.RuntimeOptions) (_result *ListOTAModuleVersionsByDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListOTAModuleVersionsByDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListOTAModuleVersionsByDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListOTAModuleVersionsByDeviceRequest
 * @return ListOTAModuleVersionsByDeviceResponse
 */
func (client *Client) ListOTAModuleVersionsByDevice(request *ListOTAModuleVersionsByDeviceRequest) (_result *ListOTAModuleVersionsByDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListOTAModuleVersionsByDeviceResponse{}
	_body, _err := client.ListOTAModuleVersionsByDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request ListOTATaskByJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOTATaskByJobResponse
 */
func (client *Client) ListOTATaskByJobWithOptions(request *ListOTATaskByJobRequest, runtime *util.RuntimeOptions) (_result *ListOTATaskByJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceNames)) {
		query["DeviceNames"] = request.DeviceNames
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.TaskStatus)) {
		query["TaskStatus"] = request.TaskStatus
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListOTATaskByJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListOTATaskByJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request ListOTATaskByJobRequest
 * @return ListOTATaskByJobResponse
 */
func (client *Client) ListOTATaskByJob(request *ListOTATaskByJobRequest) (_result *ListOTATaskByJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListOTATaskByJobResponse{}
	_body, _err := client.ListOTATaskByJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListOTAUnfinishedTaskByDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListOTAUnfinishedTaskByDeviceResponse
 */
func (client *Client) ListOTAUnfinishedTaskByDeviceWithOptions(request *ListOTAUnfinishedTaskByDeviceRequest, runtime *util.RuntimeOptions) (_result *ListOTAUnfinishedTaskByDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ModuleName)) {
		query["ModuleName"] = request.ModuleName
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.TaskStatus)) {
		query["TaskStatus"] = request.TaskStatus
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListOTAUnfinishedTaskByDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListOTAUnfinishedTaskByDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListOTAUnfinishedTaskByDeviceRequest
 * @return ListOTAUnfinishedTaskByDeviceResponse
 */
func (client *Client) ListOTAUnfinishedTaskByDevice(request *ListOTAUnfinishedTaskByDeviceRequest) (_result *ListOTAUnfinishedTaskByDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListOTAUnfinishedTaskByDeviceResponse{}
	_body, _err := client.ListOTAUnfinishedTaskByDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListParserWithOptions(request *ListParserRequest, runtime *util.RuntimeOptions) (_result *ListParserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SearchName)) {
		query["SearchName"] = request.SearchName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListParser"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListParserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListParser(request *ListParserRequest) (_result *ListParserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListParserResponse{}
	_body, _err := client.ListParserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListParserDataSourceWithOptions(request *ListParserDataSourceRequest, runtime *util.RuntimeOptions) (_result *ListParserDataSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Page)) {
		query["Page"] = request.Page
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SearchName)) {
		query["SearchName"] = request.SearchName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListParserDataSource"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListParserDataSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListParserDataSource(request *ListParserDataSourceRequest) (_result *ListParserDataSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListParserDataSourceResponse{}
	_body, _err := client.ListParserDataSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListParserDestinationWithOptions(request *ListParserDestinationRequest, runtime *util.RuntimeOptions) (_result *ListParserDestinationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IsFailover)) {
		query["IsFailover"] = request.IsFailover
	}

	if !tea.BoolValue(util.IsUnset(request.ParserId)) {
		query["ParserId"] = request.ParserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListParserDestination"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListParserDestinationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListParserDestination(request *ListParserDestinationRequest) (_result *ListParserDestinationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListParserDestinationResponse{}
	_body, _err := client.ListParserDestinationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 * *   You can specify a tag key or a tag key-value pair for search.
 * *   If you specify multiple tags, the logical relationship among these tags is **OR**.
 *
 * @param request ListProductByTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProductByTagsResponse
 */
func (client *Client) ListProductByTagsWithOptions(request *ListProductByTagsRequest, runtime *util.RuntimeOptions) (_result *ListProductByTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductTag)) {
		query["ProductTag"] = request.ProductTag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListProductByTags"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListProductByTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 * *   You can specify a tag key or a tag key-value pair for search.
 * *   If you specify multiple tags, the logical relationship among these tags is **OR**.
 *
 * @param request ListProductByTagsRequest
 * @return ListProductByTagsResponse
 */
func (client *Client) ListProductByTags(request *ListProductByTagsRequest) (_result *ListProductByTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListProductByTagsResponse{}
	_body, _err := client.ListProductByTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListProductTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProductTagsResponse
 */
func (client *Client) ListProductTagsWithOptions(request *ListProductTagsRequest, runtime *util.RuntimeOptions) (_result *ListProductTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListProductTags"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListProductTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListProductTagsRequest
 * @return ListProductTagsResponse
 */
func (client *Client) ListProductTags(request *ListProductTagsRequest) (_result *ListProductTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListProductTagsResponse{}
	_body, _err := client.ListProductTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 20 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRuleResponse
 */
func (client *Client) ListRuleWithOptions(request *ListRuleRequest, runtime *util.RuntimeOptions) (_result *ListRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 20 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListRuleRequest
 * @return ListRuleResponse
 */
func (client *Client) ListRule(request *ListRuleRequest) (_result *ListRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListRuleResponse{}
	_body, _err := client.ListRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListRuleActionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRuleActionsResponse
 */
func (client *Client) ListRuleActionsWithOptions(request *ListRuleActionsRequest, runtime *util.RuntimeOptions) (_result *ListRuleActionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListRuleActions"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListRuleActionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListRuleActionsRequest
 * @return ListRuleActionsResponse
 */
func (client *Client) ListRuleActions(request *ListRuleActionsRequest) (_result *ListRuleActionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListRuleActionsResponse{}
	_body, _err := client.ListRuleActionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ListTaskWithOptions(tmpReq *ListTaskRequest, runtime *util.RuntimeOptions) (_result *ListTaskResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &ListTaskShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.Device)) {
		request.DeviceShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.Device, tea.String("Device"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceShrink)) {
		query["Device"] = request.DeviceShrink
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	if !tea.BoolValue(util.IsUnset(request.Limit)) {
		query["Limit"] = request.Limit
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListTask"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ListTask(request *ListTaskRequest) (_result *ListTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListTaskResponse{}
	_body, _err := client.ListTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can manage TSL models by version. After you import a TSL model by calling the [ImportThingModelTsl](~~150320~~) operation, copy a TSL model by calling the [CopyThingModel](~~150322~~) operation, or edit a TSL model, you must publish the TSL model by calling the [PublishThingModel](~~150311~~) operation. Then, the TSL model can be used. Each time a TSL model of a product is published, a new version is generated.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListThingModelVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListThingModelVersionResponse
 */
func (client *Client) ListThingModelVersionWithOptions(request *ListThingModelVersionRequest, runtime *util.RuntimeOptions) (_result *ListThingModelVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListThingModelVersion"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListThingModelVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can manage TSL models by version. After you import a TSL model by calling the [ImportThingModelTsl](~~150320~~) operation, copy a TSL model by calling the [CopyThingModel](~~150322~~) operation, or edit a TSL model, you must publish the TSL model by calling the [PublishThingModel](~~150311~~) operation. Then, the TSL model can be used. Each time a TSL model of a product is published, a new version is generated.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListThingModelVersionRequest
 * @return ListThingModelVersionResponse
 */
func (client *Client) ListThingModelVersion(request *ListThingModelVersionRequest) (_result *ListThingModelVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListThingModelVersionResponse{}
	_body, _err := client.ListThingModelVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * IoT Platform provides product categories that have defined TSL models, such as street lamps, vehicle location cards, and water immersion detectors.
 * When you call the [CreateProduct](~~69123~~) operation to create a product, you can set the CategoryKey parameter to specify a product category. The product that you create references the standardized TSL model of the specified category.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListThingTemplatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListThingTemplatesResponse
 */
func (client *Client) ListThingTemplatesWithOptions(request *ListThingTemplatesRequest, runtime *util.RuntimeOptions) (_result *ListThingTemplatesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ListThingTemplates"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ListThingTemplatesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * IoT Platform provides product categories that have defined TSL models, such as street lamps, vehicle location cards, and water immersion detectors.
 * When you call the [CreateProduct](~~69123~~) operation to create a product, you can set the CategoryKey parameter to specify a product category. The product that you create references the standardized TSL model of the specified category.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ListThingTemplatesRequest
 * @return ListThingTemplatesResponse
 */
func (client *Client) ListThingTemplates(request *ListThingTemplatesRequest) (_result *ListThingTemplatesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ListThingTemplatesResponse{}
	_body, _err := client.ListThingTemplatesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ModifyOTAFirmwareWithOptions(request *ModifyOTAFirmwareRequest, runtime *util.RuntimeOptions) (_result *ModifyOTAFirmwareResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FirmwareDesc)) {
		query["FirmwareDesc"] = request.FirmwareDesc
	}

	if !tea.BoolValue(util.IsUnset(request.FirmwareId)) {
		query["FirmwareId"] = request.FirmwareId
	}

	if !tea.BoolValue(util.IsUnset(request.FirmwareName)) {
		query["FirmwareName"] = request.FirmwareName
	}

	if !tea.BoolValue(util.IsUnset(request.FirmwareUdi)) {
		query["FirmwareUdi"] = request.FirmwareUdi
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ModifyOTAFirmware"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ModifyOTAFirmwareResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ModifyOTAFirmware(request *ModifyOTAFirmwareRequest) (_result *ModifyOTAFirmwareResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ModifyOTAFirmwareResponse{}
	_body, _err := client.ModifyOTAFirmwareWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * A successful response indicates that the command to add topological relationships is sent to the gateway. It does not indicate that the topological relationships are added.
 * When you develop the gateway, you must subscribe to the topic that is used to send notifications when you add topological relationships. For more information about the topic and message format, see [Manage topological relationships](~~89299~~).
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request NotifyAddThingTopoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return NotifyAddThingTopoResponse
 */
func (client *Client) NotifyAddThingTopoWithOptions(request *NotifyAddThingTopoRequest, runtime *util.RuntimeOptions) (_result *NotifyAddThingTopoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceListStr)) {
		query["DeviceListStr"] = request.DeviceListStr
	}

	if !tea.BoolValue(util.IsUnset(request.GwDeviceName)) {
		query["GwDeviceName"] = request.GwDeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.GwIotId)) {
		query["GwIotId"] = request.GwIotId
	}

	if !tea.BoolValue(util.IsUnset(request.GwProductKey)) {
		query["GwProductKey"] = request.GwProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("NotifyAddThingTopo"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &NotifyAddThingTopoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * A successful response indicates that the command to add topological relationships is sent to the gateway. It does not indicate that the topological relationships are added.
 * When you develop the gateway, you must subscribe to the topic that is used to send notifications when you add topological relationships. For more information about the topic and message format, see [Manage topological relationships](~~89299~~).
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request NotifyAddThingTopoRequest
 * @return NotifyAddThingTopoResponse
 */
func (client *Client) NotifyAddThingTopo(request *NotifyAddThingTopoRequest) (_result *NotifyAddThingTopoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &NotifyAddThingTopoResponse{}
	_body, _err := client.NotifyAddThingTopoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) OpenIotServiceWithOptions(request *OpenIotServiceRequest, runtime *util.RuntimeOptions) (_result *OpenIotServiceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.OwnerId)) {
		query["OwnerId"] = request.OwnerId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("OpenIotService"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &OpenIotServiceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) OpenIotService(request *OpenIotServiceRequest) (_result *OpenIotServiceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &OpenIotServiceResponse{}
	_body, _err := client.OpenIotServiceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PackageSoundCodeLabelBatchAudioWithOptions(request *PackageSoundCodeLabelBatchAudioRequest, runtime *util.RuntimeOptions) (_result *PackageSoundCodeLabelBatchAudioResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BatchCode)) {
		body["BatchCode"] = request.BatchCode
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("PackageSoundCodeLabelBatchAudio"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PackageSoundCodeLabelBatchAudioResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PackageSoundCodeLabelBatchAudio(request *PackageSoundCodeLabelBatchAudioRequest) (_result *PackageSoundCodeLabelBatchAudioResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PackageSoundCodeLabelBatchAudioResponse{}
	_body, _err := client.PackageSoundCodeLabelBatchAudioWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this operation up to 100 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request PageQuerySharedSpeechOpenRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PageQuerySharedSpeechOpenResponse
 */
func (client *Client) PageQuerySharedSpeechOpenWithOptions(request *PageQuerySharedSpeechOpenRequest, runtime *util.RuntimeOptions) (_result *PageQuerySharedSpeechOpenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		body["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		body["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		body["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		body["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ShareTaskCode)) {
		body["ShareTaskCode"] = request.ShareTaskCode
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		body["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("PageQuerySharedSpeechOpen"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PageQuerySharedSpeechOpenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this operation up to 100 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request PageQuerySharedSpeechOpenRequest
 * @return PageQuerySharedSpeechOpenResponse
 */
func (client *Client) PageQuerySharedSpeechOpen(request *PageQuerySharedSpeechOpenRequest) (_result *PageQuerySharedSpeechOpenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PageQuerySharedSpeechOpenResponse{}
	_body, _err := client.PageQuerySharedSpeechOpenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * You can call this operation to query only shared speech broadcasting data six hours ago. For example, if a shared speech was broadcasted at 07:15, you can query the speech after 13:15.
 * ## QPS limits
 * You can call this operation up to 100 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request PageQuerySpeechBroadcastHourRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PageQuerySpeechBroadcastHourResponse
 */
func (client *Client) PageQuerySpeechBroadcastHourWithOptions(request *PageQuerySpeechBroadcastHourRequest, runtime *util.RuntimeOptions) (_result *PageQuerySpeechBroadcastHourResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.QueryDateTimeHour)) {
		query["QueryDateTimeHour"] = request.QueryDateTimeHour
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.PageToken)) {
		body["PageToken"] = request.PageToken
	}

	if !tea.BoolValue(util.IsUnset(request.ShareTaskCode)) {
		body["ShareTaskCode"] = request.ShareTaskCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("PageQuerySpeechBroadcastHour"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PageQuerySpeechBroadcastHourResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * You can call this operation to query only shared speech broadcasting data six hours ago. For example, if a shared speech was broadcasted at 07:15, you can query the speech after 13:15.
 * ## QPS limits
 * You can call this operation up to 100 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request PageQuerySpeechBroadcastHourRequest
 * @return PageQuerySpeechBroadcastHourResponse
 */
func (client *Client) PageQuerySpeechBroadcastHour(request *PageQuerySpeechBroadcastHourRequest) (_result *PageQuerySpeechBroadcastHourResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PageQuerySpeechBroadcastHourResponse{}
	_body, _err := client.PageQuerySpeechBroadcastHourWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Before you call this operation, a receipt template must be available in the Letter Sending Service console. Otherwise, the request fails.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request PrintByTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PrintByTemplateResponse
 */
func (client *Client) PrintByTemplateWithOptions(request *PrintByTemplateRequest, runtime *util.RuntimeOptions) (_result *PrintByTemplateResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		body["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.HistoryPrintTopic)) {
		body["HistoryPrintTopic"] = request.HistoryPrintTopic
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		body["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ParamsJsonString)) {
		body["ParamsJsonString"] = request.ParamsJsonString
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		body["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.TemplateBizCode)) {
		body["TemplateBizCode"] = request.TemplateBizCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("PrintByTemplate"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PrintByTemplateResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Before you call this operation, a receipt template must be available in the Letter Sending Service console. Otherwise, the request fails.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request PrintByTemplateRequest
 * @return PrintByTemplateResponse
 */
func (client *Client) PrintByTemplate(request *PrintByTemplateRequest) (_result *PrintByTemplateResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PrintByTemplateResponse{}
	_body, _err := client.PrintByTemplateWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * This operation does not support device property settings and service invocations.
 * *   To set properties, call the [SetDeviceProperty](~~69579~~) or [SetDevicesProperty](~~96243~~) operation.
 * *   To invoke a service, call the [InvokeThingService](~~69584~~) or [InvokeThingsService](~~96242~~) operation.
 * ## QPS limit
 * You can call this API operation up to 1,600 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request PubRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PubResponse
 */
func (client *Client) PubWithOptions(request *PubRequest, runtime *util.RuntimeOptions) (_result *PubResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContentType)) {
		query["ContentType"] = request.ContentType
	}

	if !tea.BoolValue(util.IsUnset(request.CorrelationData)) {
		query["CorrelationData"] = request.CorrelationData
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MessageExpiryInterval)) {
		query["MessageExpiryInterval"] = request.MessageExpiryInterval
	}

	if !tea.BoolValue(util.IsUnset(request.PayloadFormatIndicator)) {
		query["PayloadFormatIndicator"] = request.PayloadFormatIndicator
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Qos)) {
		query["Qos"] = request.Qos
	}

	if !tea.BoolValue(util.IsUnset(request.ResponseTopic)) {
		query["ResponseTopic"] = request.ResponseTopic
	}

	if !tea.BoolValue(util.IsUnset(request.Retained)) {
		query["Retained"] = request.Retained
	}

	if !tea.BoolValue(util.IsUnset(request.TopicAlias)) {
		query["TopicAlias"] = request.TopicAlias
	}

	if !tea.BoolValue(util.IsUnset(request.TopicFullName)) {
		query["TopicFullName"] = request.TopicFullName
	}

	if !tea.BoolValue(util.IsUnset(request.UserProp)) {
		query["UserProp"] = request.UserProp
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.MessageContent)) {
		body["MessageContent"] = request.MessageContent
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("Pub"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PubResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * This operation does not support device property settings and service invocations.
 * *   To set properties, call the [SetDeviceProperty](~~69579~~) or [SetDevicesProperty](~~96243~~) operation.
 * *   To invoke a service, call the [InvokeThingService](~~69584~~) or [InvokeThingsService](~~96242~~) operation.
 * ## QPS limit
 * You can call this API operation up to 1,600 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request PubRequest
 * @return PubResponse
 */
func (client *Client) Pub(request *PubRequest) (_result *PubResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PubResponse{}
	_body, _err := client.PubWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can use the **TopicFullName** parameter in the **request** to specify the devices to which you want to broadcast messages. For more information, see the description about the **TopicFullName** parameter in this topic.
 * ## QPS limits
 * - Each Alibaba Cloud account can run only one query per second (QPS) to broadcast a message to devices that subscribe to a topic.
 * - Each Alibaba Cloud account can run only one query per minute (QPM) to broadcast a message to all online devices of a product.      >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request PubBroadcastRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PubBroadcastResponse
 */
func (client *Client) PubBroadcastWithOptions(request *PubBroadcastRequest, runtime *util.RuntimeOptions) (_result *PubBroadcastResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MessageContent)) {
		query["MessageContent"] = request.MessageContent
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.TopicFullName)) {
		query["TopicFullName"] = request.TopicFullName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PubBroadcast"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PubBroadcastResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can use the **TopicFullName** parameter in the **request** to specify the devices to which you want to broadcast messages. For more information, see the description about the **TopicFullName** parameter in this topic.
 * ## QPS limits
 * - Each Alibaba Cloud account can run only one query per second (QPS) to broadcast a message to devices that subscribe to a topic.
 * - Each Alibaba Cloud account can run only one query per minute (QPM) to broadcast a message to all online devices of a product.      >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request PubBroadcastRequest
 * @return PubBroadcastResponse
 */
func (client *Client) PubBroadcast(request *PubBroadcastRequest) (_result *PubBroadcastResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PubBroadcastResponse{}
	_body, _err := client.PubBroadcastWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PublishScriptWithOptions(request *PublishScriptRequest, runtime *util.RuntimeOptions) (_result *PublishScriptResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ParserId)) {
		query["ParserId"] = request.ParserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PublishScript"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PublishScriptResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PublishScript(request *PublishScriptRequest) (_result *PublishScriptResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PublishScriptResponse{}
	_body, _err := client.PublishScriptWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PublishStudioAppWithOptions(request *PublishStudioAppRequest, runtime *util.RuntimeOptions) (_result *PublishStudioAppResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		body["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("PublishStudioApp"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PublishStudioAppResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PublishStudioApp(request *PublishStudioAppRequest) (_result *PublishStudioAppResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PublishStudioAppResponse{}
	_body, _err := client.PublishStudioAppWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request PublishThingModelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PublishThingModelResponse
 */
func (client *Client) PublishThingModelWithOptions(request *PublishThingModelRequest, runtime *util.RuntimeOptions) (_result *PublishThingModelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ModelVersion)) {
		query["ModelVersion"] = request.ModelVersion
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("PublishThingModel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PublishThingModelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request PublishThingModelRequest
 * @return PublishThingModelResponse
 */
func (client *Client) PublishThingModel(request *PublishThingModelRequest) (_result *PublishThingModelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PublishThingModelResponse{}
	_body, _err := client.PublishThingModelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) PushSpeechWithOptions(request *PushSpeechRequest, runtime *util.RuntimeOptions) (_result *PushSpeechResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		body["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		body["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		body["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectCode)) {
		body["ProjectCode"] = request.ProjectCode
	}

	if !tea.BoolValue(util.IsUnset(request.PushMode)) {
		body["PushMode"] = request.PushMode
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechCodeList)) {
		body["SpeechCodeList"] = request.SpeechCodeList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("PushSpeech"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &PushSpeechResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) PushSpeech(request *PushSpeechRequest) (_result *PushSpeechResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &PushSpeechResponse{}
	_body, _err := client.PushSpeechWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 30 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryBatchRegisterDeviceStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryBatchRegisterDeviceStatusResponse
 */
func (client *Client) QueryBatchRegisterDeviceStatusWithOptions(request *QueryBatchRegisterDeviceStatusRequest, runtime *util.RuntimeOptions) (_result *QueryBatchRegisterDeviceStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApplyId)) {
		query["ApplyId"] = request.ApplyId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryBatchRegisterDeviceStatus"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryBatchRegisterDeviceStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 30 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryBatchRegisterDeviceStatusRequest
 * @return QueryBatchRegisterDeviceStatusResponse
 */
func (client *Client) QueryBatchRegisterDeviceStatus(request *QueryBatchRegisterDeviceStatusRequest) (_result *QueryBatchRegisterDeviceStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryBatchRegisterDeviceStatusResponse{}
	_body, _err := client.QueryBatchRegisterDeviceStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * You can call this API operation up to 10 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryCertUrlByApplyIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryCertUrlByApplyIdResponse
 */
func (client *Client) QueryCertUrlByApplyIdWithOptions(request *QueryCertUrlByApplyIdRequest, runtime *util.RuntimeOptions) (_result *QueryCertUrlByApplyIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApplyId)) {
		query["ApplyId"] = request.ApplyId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryCertUrlByApplyId"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryCertUrlByApplyIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * You can call this API operation up to 10 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryCertUrlByApplyIdRequest
 * @return QueryCertUrlByApplyIdResponse
 */
func (client *Client) QueryCertUrlByApplyId(request *QueryCertUrlByApplyIdRequest) (_result *QueryCertUrlByApplyIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryCertUrlByApplyIdResponse{}
	_body, _err := client.QueryCertUrlByApplyIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryClientIdsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryClientIdsResponse
 */
func (client *Client) QueryClientIdsWithOptions(request *QueryClientIdsRequest, runtime *util.RuntimeOptions) (_result *QueryClientIdsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryClientIds"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryClientIdsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryClientIdsRequest
 * @return QueryClientIdsResponse
 */
func (client *Client) QueryClientIds(request *QueryClientIdsRequest) (_result *QueryClientIdsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryClientIdsResponse{}
	_body, _err := client.QueryClientIdsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryConsumerGroupByGroupIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryConsumerGroupByGroupIdResponse
 */
func (client *Client) QueryConsumerGroupByGroupIdWithOptions(request *QueryConsumerGroupByGroupIdRequest, runtime *util.RuntimeOptions) (_result *QueryConsumerGroupByGroupIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryConsumerGroupByGroupId"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryConsumerGroupByGroupIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryConsumerGroupByGroupIdRequest
 * @return QueryConsumerGroupByGroupIdResponse
 */
func (client *Client) QueryConsumerGroupByGroupId(request *QueryConsumerGroupByGroupIdRequest) (_result *QueryConsumerGroupByGroupIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryConsumerGroupByGroupIdResponse{}
	_body, _err := client.QueryConsumerGroupByGroupIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryConsumerGroupListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryConsumerGroupListResponse
 */
func (client *Client) QueryConsumerGroupListWithOptions(request *QueryConsumerGroupListRequest, runtime *util.RuntimeOptions) (_result *QueryConsumerGroupListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.Fuzzy)) {
		query["Fuzzy"] = request.Fuzzy
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SubBizCode)) {
		query["SubBizCode"] = request.SubBizCode
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryConsumerGroupList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryConsumerGroupListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryConsumerGroupListRequest
 * @return QueryConsumerGroupListResponse
 */
func (client *Client) QueryConsumerGroupList(request *QueryConsumerGroupListRequest) (_result *QueryConsumerGroupListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryConsumerGroupListResponse{}
	_body, _err := client.QueryConsumerGroupListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryConsumerGroupStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryConsumerGroupStatusResponse
 */
func (client *Client) QueryConsumerGroupStatusWithOptions(request *QueryConsumerGroupStatusRequest, runtime *util.RuntimeOptions) (_result *QueryConsumerGroupStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryConsumerGroupStatus"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryConsumerGroupStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryConsumerGroupStatusRequest
 * @return QueryConsumerGroupStatusResponse
 */
func (client *Client) QueryConsumerGroupStatus(request *QueryConsumerGroupStatusRequest) (_result *QueryConsumerGroupStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryConsumerGroupStatusResponse{}
	_body, _err := client.QueryConsumerGroupStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryDetailSceneRuleLogWithOptions(request *QueryDetailSceneRuleLogRequest, runtime *util.RuntimeOptions) (_result *QueryDetailSceneRuleLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.TraceId)) {
		query["TraceId"] = request.TraceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDetailSceneRuleLog"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDetailSceneRuleLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryDetailSceneRuleLog(request *QueryDetailSceneRuleLogRequest) (_result *QueryDetailSceneRuleLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDetailSceneRuleLogResponse{}
	_body, _err := client.QueryDetailSceneRuleLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * The QueryDevice operation can return up to one million devices each time you call the operation.
 * ## QPS limits
 * - You can call this API operation up to 50 times per second per account. >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 * - If the product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter is greater than or equal to 100,000, the queries per second (QPS) of this operation decreases.
 * In this case, you can call this API operation up to two times per second per account.
 *
 * @param request QueryDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceResponse
 */
func (client *Client) QueryDeviceWithOptions(request *QueryDeviceRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * The QueryDevice operation can return up to one million devices each time you call the operation.
 * ## QPS limits
 * - You can call this API operation up to 50 times per second per account. >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 * - If the product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter is greater than or equal to 100,000, the queries per second (QPS) of this operation decreases.
 * In this case, you can call this API operation up to two times per second per account.
 *
 * @param request QueryDeviceRequest
 * @return QueryDeviceResponse
 */
func (client *Client) QueryDevice(request *QueryDeviceRequest) (_result *QueryDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceResponse{}
	_body, _err := client.QueryDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can query devices on Enterprise Edition instances only in the China (Shanghai) and Japan (Tokyo) regions.
 * *   The QueryDeviceBySQL operation can return up to 10,000 devices each time you call the operation. For more information, see the "`Syntax of LIMIT clauses`" section of this topic.
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceBySQLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceBySQLResponse
 */
func (client *Client) QueryDeviceBySQLWithOptions(request *QueryDeviceBySQLRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceBySQLResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SQL)) {
		query["SQL"] = request.SQL
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceBySQL"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceBySQLResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can query devices on Enterprise Edition instances only in the China (Shanghai) and Japan (Tokyo) regions.
 * *   The QueryDeviceBySQL operation can return up to 10,000 devices each time you call the operation. For more information, see the "`Syntax of LIMIT clauses`" section of this topic.
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceBySQLRequest
 * @return QueryDeviceBySQLResponse
 */
func (client *Client) QueryDeviceBySQL(request *QueryDeviceBySQLRequest) (_result *QueryDeviceBySQLResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceBySQLResponse{}
	_body, _err := client.QueryDeviceBySQLWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   After the status of a device changes, the new status is applied within 10 seconds. After the new status is applied, you can search for the device by using the new status. Before the new status is applied, you can search for the device by using the previous status.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceByStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceByStatusResponse
 */
func (client *Client) QueryDeviceByStatusWithOptions(request *QueryDeviceByStatusRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceByStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceByStatus"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceByStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   After the status of a device changes, the new status is applied within 10 seconds. After the new status is applied, you can search for the device by using the new status. Before the new status is applied, you can search for the device by using the previous status.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceByStatusRequest
 * @return QueryDeviceByStatusResponse
 */
func (client *Client) QueryDeviceByStatus(request *QueryDeviceByStatusRequest) (_result *QueryDeviceByStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceByStatusResponse{}
	_body, _err := client.QueryDeviceByStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   You can specify a maximum of 10 tags in a single call.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceByTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceByTagsResponse
 */
func (client *Client) QueryDeviceByTagsWithOptions(request *QueryDeviceByTagsRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceByTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceByTags"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceByTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   You can specify a maximum of 10 tags in a single call.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceByTagsRequest
 * @return QueryDeviceByTagsResponse
 */
func (client *Client) QueryDeviceByTags(request *QueryDeviceByTagsRequest) (_result *QueryDeviceByTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceByTagsResponse{}
	_body, _err := client.QueryDeviceByTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryDeviceCertWithOptions(request *QueryDeviceCertRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceCertResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceCert"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceCertResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryDeviceCert(request *QueryDeviceCertRequest) (_result *QueryDeviceCertResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceCertResponse{}
	_body, _err := client.QueryDeviceCertWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The desired values of read-only properties cannot be queried.
 * *   You can query the desired values of up to 10 properties in a single call.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceDesiredPropertyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceDesiredPropertyResponse
 */
func (client *Client) QueryDeviceDesiredPropertyWithOptions(request *QueryDeviceDesiredPropertyRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceDesiredPropertyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionBlockId)) {
		query["FunctionBlockId"] = request.FunctionBlockId
	}

	if !tea.BoolValue(util.IsUnset(request.Identifier)) {
		query["Identifier"] = request.Identifier
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceDesiredProperty"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceDesiredPropertyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The desired values of read-only properties cannot be queried.
 * *   You can query the desired values of up to 10 properties in a single call.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceDesiredPropertyRequest
 * @return QueryDeviceDesiredPropertyResponse
 */
func (client *Client) QueryDeviceDesiredProperty(request *QueryDeviceDesiredPropertyRequest) (_result *QueryDeviceDesiredPropertyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceDesiredPropertyResponse{}
	_body, _err := client.QueryDeviceDesiredPropertyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceDetailResponse
 */
func (client *Client) QueryDeviceDetailWithOptions(request *QueryDeviceDetailRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceDetail"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceDetailRequest
 * @return QueryDeviceDetailResponse
 */
func (client *Client) QueryDeviceDetail(request *QueryDeviceDetailRequest) (_result *QueryDeviceDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceDetailResponse{}
	_body, _err := client.QueryDeviceDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceDistributeDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceDistributeDetailResponse
 */
func (client *Client) QueryDeviceDistributeDetailWithOptions(request *QueryDeviceDistributeDetailRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceDistributeDetailResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceDistributeDetail"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceDistributeDetailResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceDistributeDetailRequest
 * @return QueryDeviceDistributeDetailResponse
 */
func (client *Client) QueryDeviceDistributeDetail(request *QueryDeviceDistributeDetailRequest) (_result *QueryDeviceDistributeDetailResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceDistributeDetailResponse{}
	_body, _err := client.QueryDeviceDistributeDetailWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceDistributeJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceDistributeJobResponse
 */
func (client *Client) QueryDeviceDistributeJobWithOptions(request *QueryDeviceDistributeJobRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceDistributeJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceDistributeJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceDistributeJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   This operation can be called only by using the following **endpoint**: `iot.cn-shanghai.aliyuncs.com`.
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceDistributeJobRequest
 * @return QueryDeviceDistributeJobResponse
 */
func (client *Client) QueryDeviceDistributeJob(request *QueryDeviceDistributeJobRequest) (_result *QueryDeviceDistributeJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceDistributeJobResponse{}
	_body, _err := client.QueryDeviceDistributeJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can query only the event records that are generated in the previous 30 days.
 * >  The storage period of an event record is calculated from the day when the record is generated.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request QueryDeviceEventDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceEventDataResponse
 */
func (client *Client) QueryDeviceEventDataWithOptions(request *QueryDeviceEventDataRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceEventDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Asc)) {
		query["Asc"] = request.Asc
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.EventType)) {
		query["EventType"] = request.EventType
	}

	if !tea.BoolValue(util.IsUnset(request.Identifier)) {
		query["Identifier"] = request.Identifier
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceEventData"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceEventDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can query only the event records that are generated in the previous 30 days.
 * >  The storage period of an event record is calculated from the day when the record is generated.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request QueryDeviceEventDataRequest
 * @return QueryDeviceEventDataResponse
 */
func (client *Client) QueryDeviceEventData(request *QueryDeviceEventDataRequest) (_result *QueryDeviceEventDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceEventDataResponse{}
	_body, _err := client.QueryDeviceEventDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceFileResponse
 */
func (client *Client) QueryDeviceFileWithOptions(request *QueryDeviceFileRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceFileResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.FileId)) {
		query["FileId"] = request.FileId
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceFile"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceFileResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceFileRequest
 * @return QueryDeviceFileResponse
 */
func (client *Client) QueryDeviceFile(request *QueryDeviceFileRequest) (_result *QueryDeviceFileResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceFileResponse{}
	_body, _err := client.QueryDeviceFileWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   The returned file information for this operation call does not contain download URLs. To obtain the download URL of a file, call [QueryDeviceFile](~~112002~~).
 * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceFileListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceFileListResponse
 */
func (client *Client) QueryDeviceFileListWithOptions(request *QueryDeviceFileListRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceFileListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceFileList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceFileListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   The returned file information for this operation call does not contain download URLs. To obtain the download URL of a file, call [QueryDeviceFile](~~112002~~).
 * *   Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceFileListRequest
 * @return QueryDeviceFileListResponse
 */
func (client *Client) QueryDeviceFileList(request *QueryDeviceFileListRequest) (_result *QueryDeviceFileListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceFileListResponse{}
	_body, _err := client.QueryDeviceFileListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   You can add a device to a maximum of 10 groups.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceGroupByDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceGroupByDeviceResponse
 */
func (client *Client) QueryDeviceGroupByDeviceWithOptions(request *QueryDeviceGroupByDeviceRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceGroupByDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceGroupByDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceGroupByDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   You can add a device to a maximum of 10 groups.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceGroupByDeviceRequest
 * @return QueryDeviceGroupByDeviceResponse
 */
func (client *Client) QueryDeviceGroupByDevice(request *QueryDeviceGroupByDeviceRequest) (_result *QueryDeviceGroupByDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceGroupByDeviceResponse{}
	_body, _err := client.QueryDeviceGroupByDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceGroupByTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceGroupByTagsResponse
 */
func (client *Client) QueryDeviceGroupByTagsWithOptions(request *QueryDeviceGroupByTagsRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceGroupByTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Tag)) {
		query["Tag"] = request.Tag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceGroupByTags"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceGroupByTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceGroupByTagsRequest
 * @return QueryDeviceGroupByTagsResponse
 */
func (client *Client) QueryDeviceGroupByTags(request *QueryDeviceGroupByTagsRequest) (_result *QueryDeviceGroupByTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceGroupByTagsResponse{}
	_body, _err := client.QueryDeviceGroupByTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 30 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceGroupInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceGroupInfoResponse
 */
func (client *Client) QueryDeviceGroupInfoWithOptions(request *QueryDeviceGroupInfoRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceGroupInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupType)) {
		query["GroupType"] = request.GroupType
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceGroupInfo"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceGroupInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 30 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceGroupInfoRequest
 * @return QueryDeviceGroupInfoResponse
 */
func (client *Client) QueryDeviceGroupInfo(request *QueryDeviceGroupInfoRequest) (_result *QueryDeviceGroupInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceGroupInfoResponse{}
	_body, _err := client.QueryDeviceGroupInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 100 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceGroupListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceGroupListResponse
 */
func (client *Client) QueryDeviceGroupListWithOptions(request *QueryDeviceGroupListRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceGroupListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.GroupName)) {
		query["GroupName"] = request.GroupName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupTypes)) {
		query["GroupTypes"] = request.GroupTypes
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.SuperGroupId)) {
		query["SuperGroupId"] = request.SuperGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceGroupList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceGroupListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 100 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceGroupListRequest
 * @return QueryDeviceGroupListResponse
 */
func (client *Client) QueryDeviceGroupList(request *QueryDeviceGroupListRequest) (_result *QueryDeviceGroupListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceGroupListResponse{}
	_body, _err := client.QueryDeviceGroupListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceGroupTagListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceGroupTagListResponse
 */
func (client *Client) QueryDeviceGroupTagListWithOptions(request *QueryDeviceGroupTagListRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceGroupTagListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupType)) {
		query["GroupType"] = request.GroupType
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceGroupTagList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceGroupTagListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceGroupTagListRequest
 * @return QueryDeviceGroupTagListResponse
 */
func (client *Client) QueryDeviceGroupTagList(request *QueryDeviceGroupTagListRequest) (_result *QueryDeviceGroupTagListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceGroupTagListResponse{}
	_body, _err := client.QueryDeviceGroupTagListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
 *
 * @param request QueryDeviceInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceInfoResponse
 */
func (client *Client) QueryDeviceInfoWithOptions(request *QueryDeviceInfoRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceInfo"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
 *
 * @param request QueryDeviceInfoRequest
 * @return QueryDeviceInfoResponse
 */
func (client *Client) QueryDeviceInfo(request *QueryDeviceInfoRequest) (_result *QueryDeviceInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceInfoResponse{}
	_body, _err := client.QueryDeviceInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceListByDeviceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceListByDeviceGroupResponse
 */
func (client *Client) QueryDeviceListByDeviceGroupWithOptions(request *QueryDeviceListByDeviceGroupRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceListByDeviceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceListByDeviceGroup"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceListByDeviceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceListByDeviceGroupRequest
 * @return QueryDeviceListByDeviceGroupResponse
 */
func (client *Client) QueryDeviceListByDeviceGroup(request *QueryDeviceListByDeviceGroupRequest) (_result *QueryDeviceListByDeviceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceListByDeviceGroupResponse{}
	_body, _err := client.QueryDeviceListByDeviceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   You can query only the event records that are generated in the last 30 days.
 * >  The storage period of an event record is calculated from the day when the record is generated.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceOriginalEventDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceOriginalEventDataResponse
 */
func (client *Client) QueryDeviceOriginalEventDataWithOptions(request *QueryDeviceOriginalEventDataRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceOriginalEventDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Asc)) {
		query["Asc"] = request.Asc
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Identifier)) {
		query["Identifier"] = request.Identifier
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NextPageToken)) {
		query["NextPageToken"] = request.NextPageToken
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceOriginalEventData"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceOriginalEventDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   You can query only the event records that are generated in the last 30 days.
 * >  The storage period of an event record is calculated from the day when the record is generated.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceOriginalEventDataRequest
 * @return QueryDeviceOriginalEventDataResponse
 */
func (client *Client) QueryDeviceOriginalEventData(request *QueryDeviceOriginalEventDataRequest) (_result *QueryDeviceOriginalEventDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceOriginalEventDataResponse{}
	_body, _err := client.QueryDeviceOriginalEventDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can query only the property records that are generated within the previous 30 days.
 * >  The data of a property is stored from the day when the data is generated.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceOriginalPropertyDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceOriginalPropertyDataResponse
 */
func (client *Client) QueryDeviceOriginalPropertyDataWithOptions(request *QueryDeviceOriginalPropertyDataRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceOriginalPropertyDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Asc)) {
		query["Asc"] = request.Asc
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Identifier)) {
		query["Identifier"] = request.Identifier
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NextPageToken)) {
		query["NextPageToken"] = request.NextPageToken
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceOriginalPropertyData"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceOriginalPropertyDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can query only the property records that are generated within the previous 30 days.
 * >  The data of a property is stored from the day when the data is generated.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceOriginalPropertyDataRequest
 * @return QueryDeviceOriginalPropertyDataResponse
 */
func (client *Client) QueryDeviceOriginalPropertyData(request *QueryDeviceOriginalPropertyDataRequest) (_result *QueryDeviceOriginalPropertyDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceOriginalPropertyDataResponse{}
	_body, _err := client.QueryDeviceOriginalPropertyDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceOriginalPropertyStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceOriginalPropertyStatusResponse
 */
func (client *Client) QueryDeviceOriginalPropertyStatusWithOptions(request *QueryDeviceOriginalPropertyStatusRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceOriginalPropertyStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Asc)) {
		query["Asc"] = request.Asc
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NextPageToken)) {
		query["NextPageToken"] = request.NextPageToken
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceOriginalPropertyStatus"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceOriginalPropertyStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceOriginalPropertyStatusRequest
 * @return QueryDeviceOriginalPropertyStatusResponse
 */
func (client *Client) QueryDeviceOriginalPropertyStatus(request *QueryDeviceOriginalPropertyStatusRequest) (_result *QueryDeviceOriginalPropertyStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceOriginalPropertyStatusResponse{}
	_body, _err := client.QueryDeviceOriginalPropertyStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   You can query only the service call records that are generated in the last 30 days.
 * >  The storage period of a service call record is calculated from the day when the service is called.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * > Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceOriginalServiceDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceOriginalServiceDataResponse
 */
func (client *Client) QueryDeviceOriginalServiceDataWithOptions(request *QueryDeviceOriginalServiceDataRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceOriginalServiceDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Asc)) {
		query["Asc"] = request.Asc
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Identifier)) {
		query["Identifier"] = request.Identifier
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NextPageToken)) {
		query["NextPageToken"] = request.NextPageToken
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceOriginalServiceData"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceOriginalServiceDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   You can query only the service call records that are generated in the last 30 days.
 * >  The storage period of a service call record is calculated from the day when the service is called.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * > Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceOriginalServiceDataRequest
 * @return QueryDeviceOriginalServiceDataResponse
 */
func (client *Client) QueryDeviceOriginalServiceData(request *QueryDeviceOriginalServiceDataRequest) (_result *QueryDeviceOriginalServiceDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceOriginalServiceDataResponse{}
	_body, _err := client.QueryDeviceOriginalServiceDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDevicePropRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDevicePropResponse
 */
func (client *Client) QueryDevicePropWithOptions(request *QueryDevicePropRequest, runtime *util.RuntimeOptions) (_result *QueryDevicePropResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceProp"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDevicePropResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDevicePropRequest
 * @return QueryDevicePropResponse
 */
func (client *Client) QueryDeviceProp(request *QueryDevicePropRequest) (_result *QueryDevicePropResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDevicePropResponse{}
	_body, _err := client.QueryDevicePropWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * When you call this operation to query property records within a specified period, the number of records for a property at a point in time may reach the limit.**** The limit is specified by the **PageSize** parameter. In this case, the query stops. Some records of other properties may be not returned.**** You can check whether all records of a property are returned based on the NextValid repsonse parameter:
 * - If the value of the **NextValid** parameter is true, unretrieved records exist in the period that is indicated by the **NextTime** and **EndTime** parameter.
 * You can use the value of the **NextTime** response parameter as the value of the StartTime request parameter and call this operation again to query the rest records. You can call this operation multiple times until the value of the **NextValid** parameter is false.  >  To retrieve all property records within a specified period, you can set the **PageSize** parameter to the maximum value. Then, call this operation multiple times until the value of the **NextValid** parameter is false.
 * - If the value of the **NextValid** parameter is false, all property records are returned.
 * ## Limits
 * *   A maximum of 10 properties can be queried at a time. A maximum of 100 records can be queried for each property.
 * *   You can query property data that is generated within the last 30 days.
 * > The storage period of a property record is calculated from the day when the property record was generated.
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDevicePropertiesDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDevicePropertiesDataResponse
 */
func (client *Client) QueryDevicePropertiesDataWithOptions(request *QueryDevicePropertiesDataRequest, runtime *util.RuntimeOptions) (_result *QueryDevicePropertiesDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Asc)) {
		query["Asc"] = request.Asc
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Identifier)) {
		query["Identifier"] = request.Identifier
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDevicePropertiesData"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDevicePropertiesDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * When you call this operation to query property records within a specified period, the number of records for a property at a point in time may reach the limit.**** The limit is specified by the **PageSize** parameter. In this case, the query stops. Some records of other properties may be not returned.**** You can check whether all records of a property are returned based on the NextValid repsonse parameter:
 * - If the value of the **NextValid** parameter is true, unretrieved records exist in the period that is indicated by the **NextTime** and **EndTime** parameter.
 * You can use the value of the **NextTime** response parameter as the value of the StartTime request parameter and call this operation again to query the rest records. You can call this operation multiple times until the value of the **NextValid** parameter is false.  >  To retrieve all property records within a specified period, you can set the **PageSize** parameter to the maximum value. Then, call this operation multiple times until the value of the **NextValid** parameter is false.
 * - If the value of the **NextValid** parameter is false, all property records are returned.
 * ## Limits
 * *   A maximum of 10 properties can be queried at a time. A maximum of 100 records can be queried for each property.
 * *   You can query property data that is generated within the last 30 days.
 * > The storage period of a property record is calculated from the day when the property record was generated.
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDevicePropertiesDataRequest
 * @return QueryDevicePropertiesDataResponse
 */
func (client *Client) QueryDevicePropertiesData(request *QueryDevicePropertiesDataRequest) (_result *QueryDevicePropertiesDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDevicePropertiesDataResponse{}
	_body, _err := client.QueryDevicePropertiesDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If a device or a digital twin node has multiple properties, you can call this operation to query the data of the properties multiple times. You must specify a value for the **Identifier** parameter each time you call the operation. You can also call the [QueryDevicePropertiesData](~~99237~~) operation and specify multiple values for the **Identifier** parameter to query the data of the properties.
 * ## Limits
 * You can query only property data that is generated within the previous 30 days.
 * >  The data of a property is stored from the day when the data is generated.
 *
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request QueryDevicePropertyDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDevicePropertyDataResponse
 */
func (client *Client) QueryDevicePropertyDataWithOptions(request *QueryDevicePropertyDataRequest, runtime *util.RuntimeOptions) (_result *QueryDevicePropertyDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Asc)) {
		query["Asc"] = request.Asc
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Identifier)) {
		query["Identifier"] = request.Identifier
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDevicePropertyData"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDevicePropertyDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If a device or a digital twin node has multiple properties, you can call this operation to query the data of the properties multiple times. You must specify a value for the **Identifier** parameter each time you call the operation. You can also call the [QueryDevicePropertiesData](~~99237~~) operation and specify multiple values for the **Identifier** parameter to query the data of the properties.
 * ## Limits
 * You can query only property data that is generated within the previous 30 days.
 * >  The data of a property is stored from the day when the data is generated.
 *
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request QueryDevicePropertyDataRequest
 * @return QueryDevicePropertyDataResponse
 */
func (client *Client) QueryDevicePropertyData(request *QueryDevicePropertyDataRequest) (_result *QueryDevicePropertyDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDevicePropertyDataResponse{}
	_body, _err := client.QueryDevicePropertyDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * To query the property data of a digital twin node, you must set the **IotId** parameter to the ID of the digital twin node.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 200 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request QueryDevicePropertyStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDevicePropertyStatusResponse
 */
func (client *Client) QueryDevicePropertyStatusWithOptions(request *QueryDevicePropertyStatusRequest, runtime *util.RuntimeOptions) (_result *QueryDevicePropertyStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionBlockId)) {
		query["FunctionBlockId"] = request.FunctionBlockId
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDevicePropertyStatus"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDevicePropertyStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * To query the property data of a digital twin node, you must set the **IotId** parameter to the ID of the digital twin node.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 200 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request QueryDevicePropertyStatusRequest
 * @return QueryDevicePropertyStatusResponse
 */
func (client *Client) QueryDevicePropertyStatus(request *QueryDevicePropertyStatusRequest) (_result *QueryDevicePropertyStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDevicePropertyStatusResponse{}
	_body, _err := client.QueryDevicePropertyStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryDeviceProvisioningWithOptions(request *QueryDeviceProvisioningRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceProvisioningResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		body["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceProvisioning"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceProvisioningResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryDeviceProvisioning(request *QueryDeviceProvisioningRequest) (_result *QueryDeviceProvisioningResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceProvisioningResponse{}
	_body, _err := client.QueryDeviceProvisioningWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can query only the service call records of the previous 30 days.
 * >  The storage period of a service call record is calculated from the day when the service is called.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceServiceDataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceServiceDataResponse
 */
func (client *Client) QueryDeviceServiceDataWithOptions(request *QueryDeviceServiceDataRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceServiceDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Asc)) {
		query["Asc"] = request.Asc
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Identifier)) {
		query["Identifier"] = request.Identifier
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceServiceData"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceServiceDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can query only the service call records of the previous 30 days.
 * >  The storage period of a service call record is calculated from the day when the service is called.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceServiceDataRequest
 * @return QueryDeviceServiceDataResponse
 */
func (client *Client) QueryDeviceServiceData(request *QueryDeviceServiceDataRequest) (_result *QueryDeviceServiceDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceServiceDataResponse{}
	_body, _err := client.QueryDeviceServiceDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryDeviceSpeechWithOptions(request *QueryDeviceSpeechRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceSpeechResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		body["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		body["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceSpeech"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceSpeechResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryDeviceSpeech(request *QueryDeviceSpeechRequest) (_result *QueryDeviceSpeechResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceSpeechResponse{}
	_body, _err := client.QueryDeviceSpeechWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceStatisticsResponse
 */
func (client *Client) QueryDeviceStatisticsWithOptions(request *QueryDeviceStatisticsRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceStatisticsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceStatistics"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceStatisticsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceStatisticsRequest
 * @return QueryDeviceStatisticsResponse
 */
func (client *Client) QueryDeviceStatistics(request *QueryDeviceStatisticsRequest) (_result *QueryDeviceStatisticsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceStatisticsResponse{}
	_body, _err := client.QueryDeviceStatisticsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this operation up to 100 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceSubTopicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDeviceSubTopicResponse
 */
func (client *Client) QueryDeviceSubTopicWithOptions(request *QueryDeviceSubTopicRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceSubTopicResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceSubTopic"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceSubTopicResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this operation up to 100 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDeviceSubTopicRequest
 * @return QueryDeviceSubTopicResponse
 */
func (client *Client) QueryDeviceSubTopic(request *QueryDeviceSubTopicRequest) (_result *QueryDeviceSubTopicResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceSubTopicResponse{}
	_body, _err := client.QueryDeviceSubTopicWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryDeviceTunnelWithOptions(request *QueryDeviceTunnelRequest, runtime *util.RuntimeOptions) (_result *QueryDeviceTunnelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TunnelId)) {
		query["TunnelId"] = request.TunnelId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDeviceTunnel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDeviceTunnelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryDeviceTunnel(request *QueryDeviceTunnelRequest) (_result *QueryDeviceTunnelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDeviceTunnelResponse{}
	_body, _err := client.QueryDeviceTunnelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryDevicesHotStorageDataWithOptions(request *QueryDevicesHotStorageDataRequest, runtime *util.RuntimeOptions) (_result *QueryDevicesHotStorageDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Asc)) {
		query["Asc"] = request.Asc
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.Identifier)) {
		query["Identifier"] = request.Identifier
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NextPageToken)) {
		query["NextPageToken"] = request.NextPageToken
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.UserTopic)) {
		query["UserTopic"] = request.UserTopic
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDevicesHotStorageData"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDevicesHotStorageDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryDevicesHotStorageData(request *QueryDevicesHotStorageDataRequest) (_result *QueryDevicesHotStorageDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDevicesHotStorageDataResponse{}
	_body, _err := client.QueryDevicesHotStorageDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryDevicesHotStorageDataStatusWithOptions(request *QueryDevicesHotStorageDataStatusRequest, runtime *util.RuntimeOptions) (_result *QueryDevicesHotStorageDataStatusResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Asc)) {
		query["Asc"] = request.Asc
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NextPageToken)) {
		query["NextPageToken"] = request.NextPageToken
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.UserTopic)) {
		query["UserTopic"] = request.UserTopic
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDevicesHotStorageDataStatus"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDevicesHotStorageDataStatusResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryDevicesHotStorageDataStatus(request *QueryDevicesHotStorageDataStatusRequest) (_result *QueryDevicesHotStorageDataStatusResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDevicesHotStorageDataStatusResponse{}
	_body, _err := client.QueryDevicesHotStorageDataStatusWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   The dynamic group feature is available for public instances and Enterprise Edition instances in the China (Shanghai) region. For more information, see [Manage instances](~~147356~~).
 * *   Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 *     **
 *     **Note**The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDynamicGroupDevicesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryDynamicGroupDevicesResponse
 */
func (client *Client) QueryDynamicGroupDevicesWithOptions(request *QueryDynamicGroupDevicesRequest, runtime *util.RuntimeOptions) (_result *QueryDynamicGroupDevicesResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.FuzzyName)) {
		query["FuzzyName"] = request.FuzzyName
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NextToken)) {
		query["NextToken"] = request.NextToken
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryDynamicGroupDevices"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryDynamicGroupDevicesResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   The dynamic group feature is available for public instances and Enterprise Edition instances in the China (Shanghai) region. For more information, see [Manage instances](~~147356~~).
 * *   Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 *     **
 *     **Note**The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryDynamicGroupDevicesRequest
 * @return QueryDynamicGroupDevicesResponse
 */
func (client *Client) QueryDynamicGroupDevices(request *QueryDynamicGroupDevicesRequest) (_result *QueryDynamicGroupDevicesResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryDynamicGroupDevicesResponse{}
	_body, _err := client.QueryDynamicGroupDevicesWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * A single Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users share the quota of the Alibaba Cloud account.
 *
 * @param request QueryEdgeDriverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeDriverResponse
 */
func (client *Client) QueryEdgeDriverWithOptions(request *QueryEdgeDriverRequest, runtime *util.RuntimeOptions) (_result *QueryEdgeDriverResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.DriverName)) {
		query["DriverName"] = request.DriverName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryEdgeDriver"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryEdgeDriverResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * A single Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users share the quota of the Alibaba Cloud account.
 *
 * @param request QueryEdgeDriverRequest
 * @return QueryEdgeDriverResponse
 */
func (client *Client) QueryEdgeDriver(request *QueryEdgeDriverRequest) (_result *QueryEdgeDriverResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryEdgeDriverResponse{}
	_body, _err := client.QueryEdgeDriverWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryEdgeDriverVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeDriverVersionResponse
 */
func (client *Client) QueryEdgeDriverVersionWithOptions(request *QueryEdgeDriverVersionRequest, runtime *util.RuntimeOptions) (_result *QueryEdgeDriverVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.DriverVersion)) {
		query["DriverVersion"] = request.DriverVersion
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.VersionState)) {
		query["VersionState"] = request.VersionState
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryEdgeDriverVersion"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryEdgeDriverVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryEdgeDriverVersionRequest
 * @return QueryEdgeDriverVersionResponse
 */
func (client *Client) QueryEdgeDriverVersion(request *QueryEdgeDriverVersionRequest) (_result *QueryEdgeDriverVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryEdgeDriverVersionResponse{}
	_body, _err := client.QueryEdgeDriverVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In addition to the preceding exclusive request parameters, you must specify common request parameters when calling this API operation. For more information about common request parameters, see [Common parameters](~~30561~~).
 *
 * @param request QueryEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeInstanceResponse
 */
func (client *Client) QueryEdgeInstanceWithOptions(request *QueryEdgeInstanceRequest, runtime *util.RuntimeOptions) (_result *QueryEdgeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryEdgeInstance"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryEdgeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In addition to the preceding exclusive request parameters, you must specify common request parameters when calling this API operation. For more information about common request parameters, see [Common parameters](~~30561~~).
 *
 * @param request QueryEdgeInstanceRequest
 * @return QueryEdgeInstanceResponse
 */
func (client *Client) QueryEdgeInstance(request *QueryEdgeInstanceRequest) (_result *QueryEdgeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryEdgeInstanceResponse{}
	_body, _err := client.QueryEdgeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryEdgeInstanceChannelWithOptions(request *QueryEdgeInstanceChannelRequest, runtime *util.RuntimeOptions) (_result *QueryEdgeInstanceChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChannelName)) {
		query["ChannelName"] = request.ChannelName
	}

	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryEdgeInstanceChannel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryEdgeInstanceChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryEdgeInstanceChannel(request *QueryEdgeInstanceChannelRequest) (_result *QueryEdgeInstanceChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryEdgeInstanceChannelResponse{}
	_body, _err := client.QueryEdgeInstanceChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryEdgeInstanceDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeInstanceDeviceResponse
 */
func (client *Client) QueryEdgeInstanceDeviceWithOptions(request *QueryEdgeInstanceDeviceRequest, runtime *util.RuntimeOptions) (_result *QueryEdgeInstanceDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryEdgeInstanceDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryEdgeInstanceDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryEdgeInstanceDeviceRequest
 * @return QueryEdgeInstanceDeviceResponse
 */
func (client *Client) QueryEdgeInstanceDevice(request *QueryEdgeInstanceDeviceRequest) (_result *QueryEdgeInstanceDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryEdgeInstanceDeviceResponse{}
	_body, _err := client.QueryEdgeInstanceDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryEdgeInstanceDeviceByDriverWithOptions(request *QueryEdgeInstanceDeviceByDriverRequest, runtime *util.RuntimeOptions) (_result *QueryEdgeInstanceDeviceByDriverResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChannelId)) {
		query["ChannelId"] = request.ChannelId
	}

	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryEdgeInstanceDeviceByDriver"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryEdgeInstanceDeviceByDriverResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryEdgeInstanceDeviceByDriver(request *QueryEdgeInstanceDeviceByDriverRequest) (_result *QueryEdgeInstanceDeviceByDriverResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryEdgeInstanceDeviceByDriverResponse{}
	_body, _err := client.QueryEdgeInstanceDeviceByDriverWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryEdgeInstanceDriverRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeInstanceDriverResponse
 */
func (client *Client) QueryEdgeInstanceDriverWithOptions(request *QueryEdgeInstanceDriverRequest, runtime *util.RuntimeOptions) (_result *QueryEdgeInstanceDriverResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryEdgeInstanceDriver"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryEdgeInstanceDriverResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryEdgeInstanceDriverRequest
 * @return QueryEdgeInstanceDriverResponse
 */
func (client *Client) QueryEdgeInstanceDriver(request *QueryEdgeInstanceDriverRequest) (_result *QueryEdgeInstanceDriverResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryEdgeInstanceDriverResponse{}
	_body, _err := client.QueryEdgeInstanceDriverWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryEdgeInstanceGatewayRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeInstanceGatewayResponse
 */
func (client *Client) QueryEdgeInstanceGatewayWithOptions(request *QueryEdgeInstanceGatewayRequest, runtime *util.RuntimeOptions) (_result *QueryEdgeInstanceGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryEdgeInstanceGateway"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryEdgeInstanceGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryEdgeInstanceGatewayRequest
 * @return QueryEdgeInstanceGatewayResponse
 */
func (client *Client) QueryEdgeInstanceGateway(request *QueryEdgeInstanceGatewayRequest) (_result *QueryEdgeInstanceGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryEdgeInstanceGatewayResponse{}
	_body, _err := client.QueryEdgeInstanceGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryEdgeInstanceHistoricDeploymentRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryEdgeInstanceHistoricDeploymentResponse
 */
func (client *Client) QueryEdgeInstanceHistoricDeploymentWithOptions(request *QueryEdgeInstanceHistoricDeploymentRequest, runtime *util.RuntimeOptions) (_result *QueryEdgeInstanceHistoricDeploymentResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryEdgeInstanceHistoricDeployment"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryEdgeInstanceHistoricDeploymentResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryEdgeInstanceHistoricDeploymentRequest
 * @return QueryEdgeInstanceHistoricDeploymentResponse
 */
func (client *Client) QueryEdgeInstanceHistoricDeployment(request *QueryEdgeInstanceHistoricDeploymentRequest) (_result *QueryEdgeInstanceHistoricDeploymentResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryEdgeInstanceHistoricDeploymentResponse{}
	_body, _err := client.QueryEdgeInstanceHistoricDeploymentWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryEdgeInstanceMessageRoutingWithOptions(request *QueryEdgeInstanceMessageRoutingRequest, runtime *util.RuntimeOptions) (_result *QueryEdgeInstanceMessageRoutingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryEdgeInstanceMessageRouting"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryEdgeInstanceMessageRoutingResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryEdgeInstanceMessageRouting(request *QueryEdgeInstanceMessageRoutingRequest) (_result *QueryEdgeInstanceMessageRoutingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryEdgeInstanceMessageRoutingResponse{}
	_body, _err := client.QueryEdgeInstanceMessageRoutingWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryEdgeInstanceSceneRuleWithOptions(request *QueryEdgeInstanceSceneRuleRequest, runtime *util.RuntimeOptions) (_result *QueryEdgeInstanceSceneRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryEdgeInstanceSceneRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryEdgeInstanceSceneRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryEdgeInstanceSceneRule(request *QueryEdgeInstanceSceneRuleRequest) (_result *QueryEdgeInstanceSceneRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryEdgeInstanceSceneRuleResponse{}
	_body, _err := client.QueryEdgeInstanceSceneRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryImportedDeviceByApplyIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryImportedDeviceByApplyIdResponse
 */
func (client *Client) QueryImportedDeviceByApplyIdWithOptions(request *QueryImportedDeviceByApplyIdRequest, runtime *util.RuntimeOptions) (_result *QueryImportedDeviceByApplyIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApplyId)) {
		query["ApplyId"] = request.ApplyId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		query["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryImportedDeviceByApplyId"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryImportedDeviceByApplyIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryImportedDeviceByApplyIdRequest
 * @return QueryImportedDeviceByApplyIdResponse
 */
func (client *Client) QueryImportedDeviceByApplyId(request *QueryImportedDeviceByApplyIdRequest) (_result *QueryImportedDeviceByApplyIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryImportedDeviceByApplyIdResponse{}
	_body, _err := client.QueryImportedDeviceByApplyIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryJobWithOptions(request *QueryJobRequest, runtime *util.RuntimeOptions) (_result *QueryJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryJob(request *QueryJobRequest) (_result *QueryJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryJobResponse{}
	_body, _err := client.QueryJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryJobStatisticsWithOptions(request *QueryJobStatisticsRequest, runtime *util.RuntimeOptions) (_result *QueryJobStatisticsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := openapiutil.Query(util.ToMap(request))
	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryJobStatistics"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("GET"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryJobStatisticsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryJobStatistics(request *QueryJobStatisticsRequest) (_result *QueryJobStatisticsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryJobStatisticsResponse{}
	_body, _err := client.QueryJobStatisticsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryLicenseDeviceListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryLicenseDeviceListResponse
 */
func (client *Client) QueryLicenseDeviceListWithOptions(request *QueryLicenseDeviceListRequest, runtime *util.RuntimeOptions) (_result *QueryLicenseDeviceListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.LicenseCode)) {
		query["LicenseCode"] = request.LicenseCode
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		query["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryLicenseDeviceList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryLicenseDeviceListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryLicenseDeviceListRequest
 * @return QueryLicenseDeviceListResponse
 */
func (client *Client) QueryLicenseDeviceList(request *QueryLicenseDeviceListRequest) (_result *QueryLicenseDeviceListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryLicenseDeviceListResponse{}
	_body, _err := client.QueryLicenseDeviceListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryLoRaJoinPermissionsWithOptions(request *QueryLoRaJoinPermissionsRequest, runtime *util.RuntimeOptions) (_result *QueryLoRaJoinPermissionsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryLoRaJoinPermissions"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryLoRaJoinPermissionsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryLoRaJoinPermissions(request *QueryLoRaJoinPermissionsRequest) (_result *QueryLoRaJoinPermissionsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryLoRaJoinPermissionsResponse{}
	_body, _err := client.QueryLoRaJoinPermissionsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryMessageInfoWithOptions(request *QueryMessageInfoRequest, runtime *util.RuntimeOptions) (_result *QueryMessageInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.UniMsgId)) {
		query["UniMsgId"] = request.UniMsgId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryMessageInfo"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryMessageInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryMessageInfo(request *QueryMessageInfoRequest) (_result *QueryMessageInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryMessageInfoResponse{}
	_body, _err := client.QueryMessageInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryOTAFirmwareRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryOTAFirmwareResponse
 */
func (client *Client) QueryOTAFirmwareWithOptions(request *QueryOTAFirmwareRequest, runtime *util.RuntimeOptions) (_result *QueryOTAFirmwareResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FirmwareId)) {
		query["FirmwareId"] = request.FirmwareId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryOTAFirmware"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryOTAFirmwareResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryOTAFirmwareRequest
 * @return QueryOTAFirmwareResponse
 */
func (client *Client) QueryOTAFirmware(request *QueryOTAFirmwareRequest) (_result *QueryOTAFirmwareResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryOTAFirmwareResponse{}
	_body, _err := client.QueryOTAFirmwareWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After you call the [CreateOTAVerifyJob](~~147480~~), [CreateOTAStaticUpgradeJob](~~147496~~), or [CreateOTADynamicUpgradeJob](~~147887~~) API operation to create an update batch, the **JobId** parameter is returned. You can use this parameter to query the details of the update batch.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryOTAJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryOTAJobResponse
 */
func (client *Client) QueryOTAJobWithOptions(request *QueryOTAJobRequest, runtime *util.RuntimeOptions) (_result *QueryOTAJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryOTAJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryOTAJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After you call the [CreateOTAVerifyJob](~~147480~~), [CreateOTAStaticUpgradeJob](~~147496~~), or [CreateOTADynamicUpgradeJob](~~147887~~) API operation to create an update batch, the **JobId** parameter is returned. You can use this parameter to query the details of the update batch.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryOTAJobRequest
 * @return QueryOTAJobResponse
 */
func (client *Client) QueryOTAJob(request *QueryOTAJobRequest) (_result *QueryOTAJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryOTAJobResponse{}
	_body, _err := client.QueryOTAJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryPageByApplyIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryPageByApplyIdResponse
 */
func (client *Client) QueryPageByApplyIdWithOptions(request *QueryPageByApplyIdRequest, runtime *util.RuntimeOptions) (_result *QueryPageByApplyIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApplyId)) {
		query["ApplyId"] = request.ApplyId
	}

	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryPageByApplyId"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryPageByApplyIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryPageByApplyIdRequest
 * @return QueryPageByApplyIdResponse
 */
func (client *Client) QueryPageByApplyId(request *QueryPageByApplyIdRequest) (_result *QueryPageByApplyIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryPageByApplyIdResponse{}
	_body, _err := client.QueryPageByApplyIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryProductResponse
 */
func (client *Client) QueryProductWithOptions(request *QueryProductRequest, runtime *util.RuntimeOptions) (_result *QueryProductResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryProduct"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryProductResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryProductRequest
 * @return QueryProductResponse
 */
func (client *Client) QueryProduct(request *QueryProductRequest) (_result *QueryProductResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryProductResponse{}
	_body, _err := client.QueryProductWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 30 times per second per account.
 * >The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryProductCertInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryProductCertInfoResponse
 */
func (client *Client) QueryProductCertInfoWithOptions(request *QueryProductCertInfoRequest, runtime *util.RuntimeOptions) (_result *QueryProductCertInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryProductCertInfo"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryProductCertInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 30 times per second per account.
 * >The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryProductCertInfoRequest
 * @return QueryProductCertInfoResponse
 */
func (client *Client) QueryProductCertInfo(request *QueryProductCertInfoRequest) (_result *QueryProductCertInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryProductCertInfoResponse{}
	_body, _err := client.QueryProductCertInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * *   Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * > The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 * *   If the product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter is greater than or equal to 100,000, the QPS of this operation decreases.
 *     In this case, each Alibaba Cloud account can run up to 2 QPS.
 *
 * @param request QueryProductListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryProductListResponse
 */
func (client *Client) QueryProductListWithOptions(request *QueryProductListRequest, runtime *util.RuntimeOptions) (_result *QueryProductListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliyunCommodityCode)) {
		query["AliyunCommodityCode"] = request.AliyunCommodityCode
	}

	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryProductList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryProductListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * *   Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * > The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 * *   If the product of the value of the **CurrentPage** parameter and the value of the **PageSize** parameter is greater than or equal to 100,000, the QPS of this operation decreases.
 *     In this case, each Alibaba Cloud account can run up to 2 QPS.
 *
 * @param request QueryProductListRequest
 * @return QueryProductListResponse
 */
func (client *Client) QueryProductList(request *QueryProductListRequest) (_result *QueryProductListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryProductListResponse{}
	_body, _err := client.QueryProductListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 3 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryProductTopicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryProductTopicResponse
 */
func (client *Client) QueryProductTopicWithOptions(request *QueryProductTopicRequest, runtime *util.RuntimeOptions) (_result *QueryProductTopicResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryProductTopic"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryProductTopicResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 3 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryProductTopicRequest
 * @return QueryProductTopicResponse
 */
func (client *Client) QueryProductTopic(request *QueryProductTopicRequest) (_result *QueryProductTopicResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryProductTopicResponse{}
	_body, _err := client.QueryProductTopicWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to three times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryProjectShareDeviceListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryProjectShareDeviceListResponse
 */
func (client *Client) QueryProjectShareDeviceListWithOptions(request *QueryProjectShareDeviceListRequest, runtime *util.RuntimeOptions) (_result *QueryProjectShareDeviceListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		body["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		body["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		body["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryProjectShareDeviceList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryProjectShareDeviceListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to three times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryProjectShareDeviceListRequest
 * @return QueryProjectShareDeviceListResponse
 */
func (client *Client) QueryProjectShareDeviceList(request *QueryProjectShareDeviceListRequest) (_result *QueryProjectShareDeviceListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryProjectShareDeviceListResponse{}
	_body, _err := client.QueryProjectShareDeviceListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySceneRuleWithOptions(request *QuerySceneRuleRequest, runtime *util.RuntimeOptions) (_result *QuerySceneRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		query["RuleName"] = request.RuleName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySceneRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySceneRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySceneRule(request *QuerySceneRuleRequest) (_result *QuerySceneRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySceneRuleResponse{}
	_body, _err := client.QuerySceneRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySchedulePeriodListWithOptions(request *QuerySchedulePeriodListRequest, runtime *util.RuntimeOptions) (_result *QuerySchedulePeriodListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		body["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduleCode)) {
		body["ScheduleCode"] = request.ScheduleCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySchedulePeriodList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySchedulePeriodListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySchedulePeriodList(request *QuerySchedulePeriodListRequest) (_result *QuerySchedulePeriodListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySchedulePeriodListResponse{}
	_body, _err := client.QuerySchedulePeriodListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryShareProductNameByProductKeyWithOptions(request *QueryShareProductNameByProductKeyRequest, runtime *util.RuntimeOptions) (_result *QueryShareProductNameByProductKeyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		body["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ShareTaskCode)) {
		body["ShareTaskCode"] = request.ShareTaskCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryShareProductNameByProductKey"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryShareProductNameByProductKeyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryShareProductNameByProductKey(request *QueryShareProductNameByProductKeyRequest) (_result *QueryShareProductNameByProductKeyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryShareProductNameByProductKeyResponse{}
	_body, _err := client.QueryShareProductNameByProductKeyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySharePromotionActivityAuditResultWithOptions(request *QuerySharePromotionActivityAuditResultRequest, runtime *util.RuntimeOptions) (_result *QuerySharePromotionActivityAuditResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SharePromotionActivityId)) {
		body["SharePromotionActivityId"] = request.SharePromotionActivityId
	}

	if !tea.BoolValue(util.IsUnset(request.ShareTaskCode)) {
		body["ShareTaskCode"] = request.ShareTaskCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySharePromotionActivityAuditResult"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySharePromotionActivityAuditResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySharePromotionActivityAuditResult(request *QuerySharePromotionActivityAuditResultRequest) (_result *QuerySharePromotionActivityAuditResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySharePromotionActivityAuditResultResponse{}
	_body, _err := client.QuerySharePromotionActivityAuditResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to three times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryShareTaskDeviceListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryShareTaskDeviceListResponse
 */
func (client *Client) QueryShareTaskDeviceListWithOptions(request *QueryShareTaskDeviceListRequest, runtime *util.RuntimeOptions) (_result *QueryShareTaskDeviceListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		body["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		body["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ShareTaskId)) {
		body["ShareTaskId"] = request.ShareTaskId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryShareTaskDeviceList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryShareTaskDeviceListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to three times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryShareTaskDeviceListRequest
 * @return QueryShareTaskDeviceListResponse
 */
func (client *Client) QueryShareTaskDeviceList(request *QueryShareTaskDeviceListRequest) (_result *QueryShareTaskDeviceListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryShareTaskDeviceListResponse{}
	_body, _err := client.QueryShareTaskDeviceListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySolutionDeviceGroupPageWithOptions(request *QuerySolutionDeviceGroupPageRequest, runtime *util.RuntimeOptions) (_result *QuerySolutionDeviceGroupPageResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FuzzyGroupName)) {
		query["FuzzyGroupName"] = request.FuzzyGroupName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		query["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectCode)) {
		query["ProjectCode"] = request.ProjectCode
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySolutionDeviceGroupPage"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySolutionDeviceGroupPageResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySolutionDeviceGroupPage(request *QuerySolutionDeviceGroupPageRequest) (_result *QuerySolutionDeviceGroupPageResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySolutionDeviceGroupPageResponse{}
	_body, _err := client.QuerySolutionDeviceGroupPageWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySoundCodeLabelBatchFailedResultWithOptions(request *QuerySoundCodeLabelBatchFailedResultRequest, runtime *util.RuntimeOptions) (_result *QuerySoundCodeLabelBatchFailedResultResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BatchCode)) {
		body["BatchCode"] = request.BatchCode
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySoundCodeLabelBatchFailedResult"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySoundCodeLabelBatchFailedResultResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySoundCodeLabelBatchFailedResult(request *QuerySoundCodeLabelBatchFailedResultRequest) (_result *QuerySoundCodeLabelBatchFailedResultResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySoundCodeLabelBatchFailedResultResponse{}
	_body, _err := client.QuerySoundCodeLabelBatchFailedResultWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySoundCodeLabelBatchListWithOptions(request *QuerySoundCodeLabelBatchListRequest, runtime *util.RuntimeOptions) (_result *QuerySoundCodeLabelBatchListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		body["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduleCode)) {
		body["ScheduleCode"] = request.ScheduleCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySoundCodeLabelBatchList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySoundCodeLabelBatchListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySoundCodeLabelBatchList(request *QuerySoundCodeLabelBatchListRequest) (_result *QuerySoundCodeLabelBatchListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySoundCodeLabelBatchListResponse{}
	_body, _err := client.QuerySoundCodeLabelBatchListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySoundCodeLabelListWithOptions(request *QuerySoundCodeLabelListRequest, runtime *util.RuntimeOptions) (_result *QuerySoundCodeLabelListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		body["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduleCode)) {
		body["ScheduleCode"] = request.ScheduleCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySoundCodeLabelList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySoundCodeLabelListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySoundCodeLabelList(request *QuerySoundCodeLabelListRequest) (_result *QuerySoundCodeLabelListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySoundCodeLabelListResponse{}
	_body, _err := client.QuerySoundCodeLabelListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySoundCodeListWithOptions(request *QuerySoundCodeListRequest, runtime *util.RuntimeOptions) (_result *QuerySoundCodeListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		body["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySoundCodeList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySoundCodeListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySoundCodeList(request *QuerySoundCodeListRequest) (_result *QuerySoundCodeListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySoundCodeListResponse{}
	_body, _err := client.QuerySoundCodeListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySoundCodeScheduleListWithOptions(request *QuerySoundCodeScheduleListRequest, runtime *util.RuntimeOptions) (_result *QuerySoundCodeScheduleListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		body["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySoundCodeScheduleList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySoundCodeScheduleListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySoundCodeScheduleList(request *QuerySoundCodeScheduleListRequest) (_result *QuerySoundCodeScheduleListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySoundCodeScheduleListResponse{}
	_body, _err := client.QuerySoundCodeScheduleListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySpeechWithOptions(request *QuerySpeechRequest, runtime *util.RuntimeOptions) (_result *QuerySpeechResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechCode)) {
		body["SpeechCode"] = request.SpeechCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySpeech"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySpeechResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySpeech(request *QuerySpeechRequest) (_result *QuerySpeechResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySpeechResponse{}
	_body, _err := client.QuerySpeechWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySpeechDeviceWithOptions(request *QuerySpeechDeviceRequest, runtime *util.RuntimeOptions) (_result *QuerySpeechDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AvailableSpace)) {
		body["AvailableSpace"] = request.AvailableSpace
	}

	if !tea.BoolValue(util.IsUnset(request.AvailableSpaceScope)) {
		body["AvailableSpaceScope"] = request.AvailableSpaceScope
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		body["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		body["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectCode)) {
		body["ProjectCode"] = request.ProjectCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySpeechDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySpeechDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySpeechDevice(request *QuerySpeechDeviceRequest) (_result *QuerySpeechDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySpeechDeviceResponse{}
	_body, _err := client.QuerySpeechDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySpeechLicenseAvailableQuotaWithOptions(request *QuerySpeechLicenseAvailableQuotaRequest, runtime *util.RuntimeOptions) (_result *QuerySpeechLicenseAvailableQuotaResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySpeechLicenseAvailableQuota"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySpeechLicenseAvailableQuotaResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySpeechLicenseAvailableQuota(request *QuerySpeechLicenseAvailableQuotaRequest) (_result *QuerySpeechLicenseAvailableQuotaResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySpeechLicenseAvailableQuotaResponse{}
	_body, _err := client.QuerySpeechLicenseAvailableQuotaWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to three times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QuerySpeechLicenseDeviceListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySpeechLicenseDeviceListResponse
 */
func (client *Client) QuerySpeechLicenseDeviceListWithOptions(request *QuerySpeechLicenseDeviceListRequest, runtime *util.RuntimeOptions) (_result *QuerySpeechLicenseDeviceListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		query["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CheckGroupId)) {
		body["CheckGroupId"] = request.CheckGroupId
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		body["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.LicenseStatusList)) {
		body["LicenseStatusList"] = request.LicenseStatusList
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		body["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySpeechLicenseDeviceList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySpeechLicenseDeviceListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to three times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QuerySpeechLicenseDeviceListRequest
 * @return QuerySpeechLicenseDeviceListResponse
 */
func (client *Client) QuerySpeechLicenseDeviceList(request *QuerySpeechLicenseDeviceListRequest) (_result *QuerySpeechLicenseDeviceListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySpeechLicenseDeviceListResponse{}
	_body, _err := client.QuerySpeechLicenseDeviceListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySpeechListWithOptions(request *QuerySpeechListRequest, runtime *util.RuntimeOptions) (_result *QuerySpeechListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AudioFormat)) {
		body["AudioFormat"] = request.AudioFormat
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		body["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectCode)) {
		body["ProjectCode"] = request.ProjectCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySpeechList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySpeechListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySpeechList(request *QuerySpeechListRequest) (_result *QuerySpeechListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySpeechListResponse{}
	_body, _err := client.QuerySpeechListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySpeechPushJobWithOptions(request *QuerySpeechPushJobRequest, runtime *util.RuntimeOptions) (_result *QuerySpeechPushJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.JobCode)) {
		query["JobCode"] = request.JobCode
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		body["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectCode)) {
		body["ProjectCode"] = request.ProjectCode
	}

	if !tea.BoolValue(util.IsUnset(request.PushMode)) {
		body["PushMode"] = request.PushMode
	}

	if !tea.BoolValue(util.IsUnset(request.StatusList)) {
		body["StatusList"] = request.StatusList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySpeechPushJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySpeechPushJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySpeechPushJob(request *QuerySpeechPushJobRequest) (_result *QuerySpeechPushJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySpeechPushJobResponse{}
	_body, _err := client.QuerySpeechPushJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySpeechPushJobDeviceWithOptions(request *QuerySpeechPushJobDeviceRequest, runtime *util.RuntimeOptions) (_result *QuerySpeechPushJobDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		body["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JobCode)) {
		body["JobCode"] = request.JobCode
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		body["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		body["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySpeechPushJobDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySpeechPushJobDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySpeechPushJobDevice(request *QuerySpeechPushJobDeviceRequest) (_result *QuerySpeechPushJobDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySpeechPushJobDeviceResponse{}
	_body, _err := client.QuerySpeechPushJobDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySpeechPushJobSpeechWithOptions(request *QuerySpeechPushJobSpeechRequest, runtime *util.RuntimeOptions) (_result *QuerySpeechPushJobSpeechResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JobCode)) {
		body["JobCode"] = request.JobCode
	}

	if !tea.BoolValue(util.IsUnset(request.PageId)) {
		body["PageId"] = request.PageId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySpeechPushJobSpeech"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySpeechPushJobSpeechResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySpeechPushJobSpeech(request *QuerySpeechPushJobSpeechRequest) (_result *QuerySpeechPushJobSpeechResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySpeechPushJobSpeechResponse{}
	_body, _err := client.QuerySpeechPushJobSpeechWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryStudioAppDomainListOpenWithOptions(request *QueryStudioAppDomainListOpenRequest, runtime *util.RuntimeOptions) (_result *QueryStudioAppDomainListOpenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		body["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryStudioAppDomainListOpen"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryStudioAppDomainListOpenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryStudioAppDomainListOpen(request *QueryStudioAppDomainListOpenRequest) (_result *QueryStudioAppDomainListOpenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryStudioAppDomainListOpenResponse{}
	_body, _err := client.QueryStudioAppDomainListOpenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryStudioAppListWithOptions(request *QueryStudioAppListRequest, runtime *util.RuntimeOptions) (_result *QueryStudioAppListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FuzzyName)) {
		body["FuzzyName"] = request.FuzzyName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		body["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	if !tea.BoolValue(util.IsUnset(request.Types)) {
		body["Types"] = request.Types
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryStudioAppList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryStudioAppListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryStudioAppList(request *QueryStudioAppListRequest) (_result *QueryStudioAppListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryStudioAppListResponse{}
	_body, _err := client.QueryStudioAppListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryStudioAppPageListOpenWithOptions(request *QueryStudioAppPageListOpenRequest, runtime *util.RuntimeOptions) (_result *QueryStudioAppPageListOpenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		body["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IsRelease)) {
		body["IsRelease"] = request.IsRelease
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		body["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryStudioAppPageListOpen"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryStudioAppPageListOpenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryStudioAppPageListOpen(request *QueryStudioAppPageListOpenRequest) (_result *QueryStudioAppPageListOpenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryStudioAppPageListOpenResponse{}
	_body, _err := client.QueryStudioAppPageListOpenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryStudioProjectListWithOptions(request *QueryStudioProjectListRequest, runtime *util.RuntimeOptions) (_result *QueryStudioProjectListResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.PageNo)) {
		body["PageNo"] = request.PageNo
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		body["PageSize"] = request.PageSize
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryStudioProjectList"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryStudioProjectListResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryStudioProjectList(request *QueryStudioProjectListRequest) (_result *QueryStudioProjectListResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryStudioProjectListResponse{}
	_body, _err := client.QueryStudioProjectListWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QuerySubscribeRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySubscribeRelationResponse
 */
func (client *Client) QuerySubscribeRelationWithOptions(request *QuerySubscribeRelationRequest, runtime *util.RuntimeOptions) (_result *QuerySubscribeRelationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySubscribeRelation"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySubscribeRelationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QuerySubscribeRelationRequest
 * @return QuerySubscribeRelationResponse
 */
func (client *Client) QuerySubscribeRelation(request *QuerySubscribeRelationRequest) (_result *QuerySubscribeRelationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySubscribeRelationResponse{}
	_body, _err := client.QuerySubscribeRelationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QuerySummarySceneRuleLogWithOptions(request *QuerySummarySceneRuleLogRequest, runtime *util.RuntimeOptions) (_result *QuerySummarySceneRuleLogResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentPage)) {
		query["CurrentPage"] = request.CurrentPage
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		query["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PageSize)) {
		query["PageSize"] = request.PageSize
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		query["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		query["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySummarySceneRuleLog"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySummarySceneRuleLogResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QuerySummarySceneRuleLog(request *QuerySummarySceneRuleLogRequest) (_result *QuerySummarySceneRuleLogResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySummarySceneRuleLogResponse{}
	_body, _err := client.QuerySummarySceneRuleLogWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QuerySuperDeviceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QuerySuperDeviceGroupResponse
 */
func (client *Client) QuerySuperDeviceGroupWithOptions(request *QuerySuperDeviceGroupRequest, runtime *util.RuntimeOptions) (_result *QuerySuperDeviceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QuerySuperDeviceGroup"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QuerySuperDeviceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QuerySuperDeviceGroupRequest
 * @return QuerySuperDeviceGroupResponse
 */
func (client *Client) QuerySuperDeviceGroup(request *QuerySuperDeviceGroupRequest) (_result *QuerySuperDeviceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QuerySuperDeviceGroupResponse{}
	_body, _err := client.QuerySuperDeviceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryTaskWithOptions(request *QueryTaskRequest, runtime *util.RuntimeOptions) (_result *QueryTaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryTask"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryTaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryTask(request *QueryTaskRequest) (_result *QueryTaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryTaskResponse{}
	_body, _err := client.QueryTaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * TSL features include properties, services, and events.
 * If you add custom modules to a TSL model and the value of the **FunctionBlockId** parameter is empty, you can obtain the TSL features of each custom module. If the value of the FunctionBlockId parameter is not empty, you can obtain the TSL features of a specified custom module.
 * For more information about the data format of the **ThingModelJson** parameter, see [Data structure of ThingModelJson](~~150457~~).
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryThingModelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryThingModelResponse
 */
func (client *Client) QueryThingModelWithOptions(request *QueryThingModelRequest, runtime *util.RuntimeOptions) (_result *QueryThingModelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FunctionBlockId)) {
		query["FunctionBlockId"] = request.FunctionBlockId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ModelVersion)) {
		query["ModelVersion"] = request.ModelVersion
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryThingModel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryThingModelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * TSL features include properties, services, and events.
 * If you add custom modules to a TSL model and the value of the **FunctionBlockId** parameter is empty, you can obtain the TSL features of each custom module. If the value of the FunctionBlockId parameter is not empty, you can obtain the TSL features of a specified custom module.
 * For more information about the data format of the **ThingModelJson** parameter, see [Data structure of ThingModelJson](~~150457~~).
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryThingModelRequest
 * @return QueryThingModelResponse
 */
func (client *Client) QueryThingModel(request *QueryThingModelRequest) (_result *QueryThingModelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryThingModelResponse{}
	_body, _err := client.QueryThingModelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryThingModelExtendConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryThingModelExtendConfigResponse
 */
func (client *Client) QueryThingModelExtendConfigWithOptions(request *QueryThingModelExtendConfigRequest, runtime *util.RuntimeOptions) (_result *QueryThingModelExtendConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FunctionBlockId)) {
		query["FunctionBlockId"] = request.FunctionBlockId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ModelVersion)) {
		query["ModelVersion"] = request.ModelVersion
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryThingModelExtendConfig"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryThingModelExtendConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryThingModelExtendConfigRequest
 * @return QueryThingModelExtendConfigResponse
 */
func (client *Client) QueryThingModelExtendConfig(request *QueryThingModelExtendConfigRequest) (_result *QueryThingModelExtendConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryThingModelExtendConfigResponse{}
	_body, _err := client.QueryThingModelExtendConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryThingModelExtendConfigPublishedRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryThingModelExtendConfigPublishedResponse
 */
func (client *Client) QueryThingModelExtendConfigPublishedWithOptions(request *QueryThingModelExtendConfigPublishedRequest, runtime *util.RuntimeOptions) (_result *QueryThingModelExtendConfigPublishedResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FunctionBlockId)) {
		query["FunctionBlockId"] = request.FunctionBlockId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ModelVersion)) {
		query["ModelVersion"] = request.ModelVersion
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryThingModelExtendConfigPublished"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryThingModelExtendConfigPublishedResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryThingModelExtendConfigPublishedRequest
 * @return QueryThingModelExtendConfigPublishedResponse
 */
func (client *Client) QueryThingModelExtendConfigPublished(request *QueryThingModelExtendConfigPublishedRequest) (_result *QueryThingModelExtendConfigPublishedResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryThingModelExtendConfigPublishedResponse{}
	_body, _err := client.QueryThingModelExtendConfigPublishedWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryThingModelPublishedRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryThingModelPublishedResponse
 */
func (client *Client) QueryThingModelPublishedWithOptions(request *QueryThingModelPublishedRequest, runtime *util.RuntimeOptions) (_result *QueryThingModelPublishedResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FunctionBlockId)) {
		query["FunctionBlockId"] = request.FunctionBlockId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ModelVersion)) {
		query["ModelVersion"] = request.ModelVersion
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ResourceGroupId)) {
		query["ResourceGroupId"] = request.ResourceGroupId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryThingModelPublished"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryThingModelPublishedResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryThingModelPublishedRequest
 * @return QueryThingModelPublishedResponse
 */
func (client *Client) QueryThingModelPublished(request *QueryThingModelPublishedRequest) (_result *QueryThingModelPublishedResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryThingModelPublishedResponse{}
	_body, _err := client.QueryThingModelPublishedWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) QueryTopicConfigWithOptions(request *QueryTopicConfigRequest, runtime *util.RuntimeOptions) (_result *QueryTopicConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryTopicConfig"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryTopicConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) QueryTopicConfig(request *QueryTopicConfigRequest) (_result *QueryTopicConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryTopicConfigResponse{}
	_body, _err := client.QueryTopicConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
 *
 * @param request QueryTopicReverseRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryTopicReverseRouteTableResponse
 */
func (client *Client) QueryTopicReverseRouteTableWithOptions(request *QueryTopicReverseRouteTableRequest, runtime *util.RuntimeOptions) (_result *QueryTopicReverseRouteTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RegionId)) {
		query["RegionId"] = request.RegionId
	}

	if !tea.BoolValue(util.IsUnset(request.Topic)) {
		query["Topic"] = request.Topic
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryTopicReverseRouteTable"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryTopicReverseRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * In addition to the preceding operation-specific request parameters, you must specify common request parameters when you call this operation. For more information, see [Common request parameters](~~30561~~).
 *
 * @param request QueryTopicReverseRouteTableRequest
 * @return QueryTopicReverseRouteTableResponse
 */
func (client *Client) QueryTopicReverseRouteTable(request *QueryTopicReverseRouteTableRequest) (_result *QueryTopicReverseRouteTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryTopicReverseRouteTableResponse{}
	_body, _err := client.QueryTopicReverseRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryTopicRouteTableRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryTopicRouteTableResponse
 */
func (client *Client) QueryTopicRouteTableWithOptions(request *QueryTopicRouteTableRequest, runtime *util.RuntimeOptions) (_result *QueryTopicRouteTableResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Topic)) {
		query["Topic"] = request.Topic
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryTopicRouteTable"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryTopicRouteTableResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request QueryTopicRouteTableRequest
 * @return QueryTopicRouteTableResponse
 */
func (client *Client) QueryTopicRouteTable(request *QueryTopicRouteTableRequest) (_result *QueryTopicRouteTableResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryTopicRouteTableResponse{}
	_body, _err := client.QueryTopicRouteTableWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You can call this operation to query the information about a device of a JT/T 808 gateway product.
 * *   When you call this operation, you must specify a **ProductKey** and a **DeviceName**. Otherwise, the call fails.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request QueryVehicleDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryVehicleDeviceResponse
 */
func (client *Client) QueryVehicleDeviceWithOptions(request *QueryVehicleDeviceRequest, runtime *util.RuntimeOptions) (_result *QueryVehicleDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("QueryVehicleDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &QueryVehicleDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You can call this operation to query the information about a device of a JT/T 808 gateway product.
 * *   When you call this operation, you must specify a **ProductKey** and a **DeviceName**. Otherwise, the call fails.
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request QueryVehicleDeviceRequest
 * @return QueryVehicleDeviceResponse
 */
func (client *Client) QueryVehicleDevice(request *QueryVehicleDeviceRequest) (_result *QueryVehicleDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &QueryVehicleDeviceResponse{}
	_body, _err := client.QueryVehicleDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If the device fails to send a response within the timeout period after you call the operation, IoT Platform considers that the call fails even if the device receives the message. The timeout period is specified by the **Timeout** parameter.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 1000 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request RRpcRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RRpcResponse
 */
func (client *Client) RRpcWithOptions(request *RRpcRequest, runtime *util.RuntimeOptions) (_result *RRpcResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ContentType)) {
		query["ContentType"] = request.ContentType
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Timeout)) {
		query["Timeout"] = request.Timeout
	}

	if !tea.BoolValue(util.IsUnset(request.Topic)) {
		query["Topic"] = request.Topic
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.RequestBase64Byte)) {
		body["RequestBase64Byte"] = request.RequestBase64Byte
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("RRpc"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RRpcResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If the device fails to send a response within the timeout period after you call the operation, IoT Platform considers that the call fails even if the device receives the message. The timeout period is specified by the **Timeout** parameter.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 1000 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request RRpcRequest
 * @return RRpcResponse
 */
func (client *Client) RRpc(request *RRpcRequest) (_result *RRpcResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RRpcResponse{}
	_body, _err := client.RRpcWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to five times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ReBindLicenseDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReBindLicenseDeviceResponse
 */
func (client *Client) ReBindLicenseDeviceWithOptions(request *ReBindLicenseDeviceRequest, runtime *util.RuntimeOptions) (_result *ReBindLicenseDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.LicenseCode)) {
		query["LicenseCode"] = request.LicenseCode
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceNameList)) {
		body["DeviceNameList"] = request.DeviceNameList
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
		Body:  openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ReBindLicenseDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReBindLicenseDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to five times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ReBindLicenseDeviceRequest
 * @return ReBindLicenseDeviceResponse
 */
func (client *Client) ReBindLicenseDevice(request *ReBindLicenseDeviceRequest) (_result *ReBindLicenseDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReBindLicenseDeviceResponse{}
	_body, _err := client.ReBindLicenseDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RecognizeCarNumWithOptions(request *RecognizeCarNumRequest, runtime *util.RuntimeOptions) (_result *RecognizeCarNumResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Url)) {
		query["Url"] = request.Url
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RecognizeCarNum"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RecognizeCarNumResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RecognizeCarNum(request *RecognizeCarNumRequest) (_result *RecognizeCarNumResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RecognizeCarNumResponse{}
	_body, _err := client.RecognizeCarNumWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RecognizePictureGeneralWithOptions(request *RecognizePictureGeneralRequest, runtime *util.RuntimeOptions) (_result *RecognizePictureGeneralResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Url)) {
		query["Url"] = request.Url
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RecognizePictureGeneral"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RecognizePictureGeneralResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RecognizePictureGeneral(request *RecognizePictureGeneralRequest) (_result *RecognizePictureGeneralResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RecognizePictureGeneralResponse{}
	_body, _err := client.RecognizePictureGeneralWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RefreshDeviceTunnelSharePasswordWithOptions(request *RefreshDeviceTunnelSharePasswordRequest, runtime *util.RuntimeOptions) (_result *RefreshDeviceTunnelSharePasswordResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RefreshDeviceTunnelSharePassword"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RefreshDeviceTunnelSharePasswordResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RefreshDeviceTunnelSharePassword(request *RefreshDeviceTunnelSharePasswordRequest) (_result *RefreshDeviceTunnelSharePasswordResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RefreshDeviceTunnelSharePasswordResponse{}
	_body, _err := client.RefreshDeviceTunnelSharePasswordWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RefreshStudioAppTokenOpenWithOptions(request *RefreshStudioAppTokenOpenRequest, runtime *util.RuntimeOptions) (_result *RefreshStudioAppTokenOpenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		body["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("RefreshStudioAppTokenOpen"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RefreshStudioAppTokenOpenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RefreshStudioAppTokenOpen(request *RefreshStudioAppTokenOpenRequest) (_result *RefreshStudioAppTokenOpenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RefreshStudioAppTokenOpenResponse{}
	_body, _err := client.RefreshStudioAppTokenOpenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If you call this operation to register a device under a product, the device is added to the product in the IoT Platform console. After the device is registered, IoT Platform issues the IotId parameter to the device. This parameter is a globally unique identifier (GUID) of the device. To perform operations on a device, you must use the IotId parameter to identify the device.
 * You can also use a combination of the ProductKey and DeviceName parameters to identify a device. A ProductKey is issued by IoT Platform to a product when you create the product. A DeviceName is specified or randomly generated when you create a device. The IotId parameter has a higher priority than a combination of the ProductKey and DeviceName parameters.
 * For information about how to register multiple devices under a product at the same time, see [BatchRegisterDeviceWithApplyId](~~69514~~).
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 30 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request RegisterDeviceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RegisterDeviceResponse
 */
func (client *Client) RegisterDeviceWithOptions(request *RegisterDeviceRequest, runtime *util.RuntimeOptions) (_result *RegisterDeviceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppKey)) {
		query["AppKey"] = request.AppKey
	}

	if !tea.BoolValue(util.IsUnset(request.DevEui)) {
		query["DevEui"] = request.DevEui
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JoinEui)) {
		query["JoinEui"] = request.JoinEui
	}

	if !tea.BoolValue(util.IsUnset(request.LoraNodeType)) {
		query["LoraNodeType"] = request.LoraNodeType
	}

	if !tea.BoolValue(util.IsUnset(request.Nickname)) {
		query["Nickname"] = request.Nickname
	}

	if !tea.BoolValue(util.IsUnset(request.PinCode)) {
		query["PinCode"] = request.PinCode
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RegisterDevice"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RegisterDeviceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If you call this operation to register a device under a product, the device is added to the product in the IoT Platform console. After the device is registered, IoT Platform issues the IotId parameter to the device. This parameter is a globally unique identifier (GUID) of the device. To perform operations on a device, you must use the IotId parameter to identify the device.
 * You can also use a combination of the ProductKey and DeviceName parameters to identify a device. A ProductKey is issued by IoT Platform to a product when you create the product. A DeviceName is specified or randomly generated when you create a device. The IotId parameter has a higher priority than a combination of the ProductKey and DeviceName parameters.
 * For information about how to register multiple devices under a product at the same time, see [BatchRegisterDeviceWithApplyId](~~69514~~).
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 30 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request RegisterDeviceRequest
 * @return RegisterDeviceResponse
 */
func (client *Client) RegisterDevice(request *RegisterDeviceRequest) (_result *RegisterDeviceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RegisterDeviceResponse{}
	_body, _err := client.RegisterDeviceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ReleaseEdgeDriverVersionWithOptions(request *ReleaseEdgeDriverVersionRequest, runtime *util.RuntimeOptions) (_result *ReleaseEdgeDriverVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.DriverVersion)) {
		query["DriverVersion"] = request.DriverVersion
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReleaseEdgeDriverVersion"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReleaseEdgeDriverVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ReleaseEdgeDriverVersion(request *ReleaseEdgeDriverVersionRequest) (_result *ReleaseEdgeDriverVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReleaseEdgeDriverVersionResponse{}
	_body, _err := client.ReleaseEdgeDriverVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   After a product is published, you cannot call the [CreateThingModel](~~150323~~), [UpdateThingModel](~~151240~~), [ImportThingModelTSL](~~150320~~), [PublishThingModel](~~150311~~), [DeleteThingModel](~~150312~~), or [CopyThingModel](~~150322~~) operation to edit the Thing Specification Language (TSL) model of the product. To edit the TSL model, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ReleaseProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseProductResponse
 */
func (client *Client) ReleaseProductWithOptions(request *ReleaseProductRequest, runtime *util.RuntimeOptions) (_result *ReleaseProductResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReleaseProduct"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReleaseProductResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   After a product is published, you cannot call the [CreateThingModel](~~150323~~), [UpdateThingModel](~~151240~~), [ImportThingModelTSL](~~150320~~), [PublishThingModel](~~150311~~), [DeleteThingModel](~~150312~~), or [CopyThingModel](~~150322~~) operation to edit the Thing Specification Language (TSL) model of the product. To edit the TSL model, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ReleaseProductRequest
 * @return ReleaseProductResponse
 */
func (client *Client) ReleaseProduct(request *ReleaseProductRequest) (_result *ReleaseProductResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReleaseProductResponse{}
	_body, _err := client.ReleaseProductWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   If you specify a gateway, this operation removes the topological relationships between the gateway and all attached sub-devices.
 * *   If you specify a sub-device, this operation removes the topological relationship between the sub-device and the gateway to which the sub-device is attached.
 * # QPS limits
 * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request RemoveThingTopoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveThingTopoResponse
 */
func (client *Client) RemoveThingTopoWithOptions(request *RemoveThingTopoRequest, runtime *util.RuntimeOptions) (_result *RemoveThingTopoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RemoveThingTopo"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RemoveThingTopoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   If you specify a gateway, this operation removes the topological relationships between the gateway and all attached sub-devices.
 * *   If you specify a sub-device, this operation removes the topological relationship between the sub-device and the gateway to which the sub-device is attached.
 * # QPS limits
 * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request RemoveThingTopoRequest
 * @return RemoveThingTopoResponse
 */
func (client *Client) RemoveThingTopo(request *RemoveThingTopoRequest) (_result *RemoveThingTopoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RemoveThingTopoResponse{}
	_body, _err := client.RemoveThingTopoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ReplaceEdgeInstanceGatewayWithOptions(request *ReplaceEdgeInstanceGatewayRequest, runtime *util.RuntimeOptions) (_result *ReplaceEdgeInstanceGatewayResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.CurrentGatewayId)) {
		query["CurrentGatewayId"] = request.CurrentGatewayId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NewGatewayId)) {
		query["NewGatewayId"] = request.NewGatewayId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReplaceEdgeInstanceGateway"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReplaceEdgeInstanceGatewayResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ReplaceEdgeInstanceGateway(request *ReplaceEdgeInstanceGatewayRequest) (_result *ReplaceEdgeInstanceGatewayResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReplaceEdgeInstanceGatewayResponse{}
	_body, _err := client.ReplaceEdgeInstanceGatewayWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RerunJobWithOptions(request *RerunJobRequest, runtime *util.RuntimeOptions) (_result *RerunJobResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("RerunJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RerunJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RerunJob(request *RerunJobRequest) (_result *RerunJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RerunJobResponse{}
	_body, _err := client.RerunJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ResetConsumerGroupPositionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetConsumerGroupPositionResponse
 */
func (client *Client) ResetConsumerGroupPositionWithOptions(request *ResetConsumerGroupPositionRequest, runtime *util.RuntimeOptions) (_result *ResetConsumerGroupPositionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResetConsumerGroupPosition"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ResetConsumerGroupPositionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ResetConsumerGroupPositionRequest
 * @return ResetConsumerGroupPositionResponse
 */
func (client *Client) ResetConsumerGroupPosition(request *ResetConsumerGroupPositionRequest) (_result *ResetConsumerGroupPositionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ResetConsumerGroupPositionResponse{}
	_body, _err := client.ResetConsumerGroupPositionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) ResetDeviceTimelineWithOptions(request *ResetDeviceTimelineRequest, runtime *util.RuntimeOptions) (_result *ResetDeviceTimelineResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResetDeviceTimeline"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ResetDeviceTimelineResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) ResetDeviceTimeline(request *ResetDeviceTimelineRequest) (_result *ResetDeviceTimelineResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ResetDeviceTimelineResponse{}
	_body, _err := client.ResetDeviceTimelineWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   After you use dynamic registration to obtain the device certificate information of a directly connected device and activate the device, you can call this operation to reset the dynamic registration status of the status to unregistered in the IoT Platform console. Then, you can use dynamic registration again to obtain the device certificate information. The device certificate information includes ProductKey, DeviceName, and DeviceSecret.
 * > This operation is called to reset the dynamic registration status instead of activation status of a device. After you call the operation to reset the dynamic registration status of a device, the status of the device in the IoT Platform console is not reset to inactive.
 * *   If you specify a gateway and the number of sub-devices that belong to the gateway exceeds 2,000, you can call this operation to create a device job to delete the topological relationships in an asynchronous manner. The operation returns the **JobId** parameter.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request ResetThingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetThingResponse
 */
func (client *Client) ResetThingWithOptions(request *ResetThingRequest, runtime *util.RuntimeOptions) (_result *ResetThingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ResetThing"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ResetThingResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   After you use dynamic registration to obtain the device certificate information of a directly connected device and activate the device, you can call this operation to reset the dynamic registration status of the status to unregistered in the IoT Platform console. Then, you can use dynamic registration again to obtain the device certificate information. The device certificate information includes ProductKey, DeviceName, and DeviceSecret.
 * > This operation is called to reset the dynamic registration status instead of activation status of a device. After you call the operation to reset the dynamic registration status of a device, the status of the device in the IoT Platform console is not reset to inactive.
 * *   If you specify a gateway and the number of sub-devices that belong to the gateway exceeds 2,000, you can call this operation to create a device job to delete the topological relationships in an asynchronous manner. The operation returns the **JobId** parameter.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request ResetThingRequest
 * @return ResetThingResponse
 */
func (client *Client) ResetThing(request *ResetThingRequest) (_result *ResetThingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ResetThingResponse{}
	_body, _err := client.ResetThingWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) RetrySoundCodeLabelBatchWithOptions(request *RetrySoundCodeLabelBatchRequest, runtime *util.RuntimeOptions) (_result *RetrySoundCodeLabelBatchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BatchCode)) {
		body["BatchCode"] = request.BatchCode
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("RetrySoundCodeLabelBatch"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &RetrySoundCodeLabelBatchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) RetrySoundCodeLabelBatch(request *RetrySoundCodeLabelBatchRequest) (_result *RetrySoundCodeLabelBatchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &RetrySoundCodeLabelBatchResponse{}
	_body, _err := client.RetrySoundCodeLabelBatchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If the update task requires confirmation, you must make sure that it has been confirmed before you call this operation. You can call the [ConfirmOTATask](~~254666~~) operation to confirm update tasks.
 * ## QPS limits
 * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ReupgradeOTATaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReupgradeOTATaskResponse
 */
func (client *Client) ReupgradeOTATaskWithOptions(request *ReupgradeOTATaskRequest, runtime *util.RuntimeOptions) (_result *ReupgradeOTATaskResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	if !tea.BoolValue(util.IsUnset(request.TaskId)) {
		query["TaskId"] = request.TaskId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("ReupgradeOTATask"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ReupgradeOTATaskResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If the update task requires confirmation, you must make sure that it has been confirmed before you call this operation. You can call the [ConfirmOTATask](~~254666~~) operation to confirm update tasks.
 * ## QPS limits
 * Each Alibaba Cloud account can run a maximum of 20 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ReupgradeOTATaskRequest
 * @return ReupgradeOTATaskResponse
 */
func (client *Client) ReupgradeOTATask(request *ReupgradeOTATaskRequest) (_result *ReupgradeOTATaskResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ReupgradeOTATaskResponse{}
	_body, _err := client.ReupgradeOTATaskWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   A device can have a maximum of 100 tags.
 * *   You can modify or add a maximum of 100 tags at a time.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request SaveDevicePropRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SaveDevicePropResponse
 */
func (client *Client) SaveDevicePropWithOptions(request *SaveDevicePropRequest, runtime *util.RuntimeOptions) (_result *SaveDevicePropResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Props)) {
		query["Props"] = request.Props
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SaveDeviceProp"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SaveDevicePropResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   A device can have a maximum of 100 tags.
 * *   You can modify or add a maximum of 100 tags at a time.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request SaveDevicePropRequest
 * @return SaveDevicePropResponse
 */
func (client *Client) SaveDeviceProp(request *SaveDevicePropRequest) (_result *SaveDevicePropResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SaveDevicePropResponse{}
	_body, _err := client.SaveDevicePropWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SaveScriptWithOptions(request *SaveScriptRequest, runtime *util.RuntimeOptions) (_result *SaveScriptResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ParserId)) {
		query["ParserId"] = request.ParserId
	}

	if !tea.BoolValue(util.IsUnset(request.ScriptDraft)) {
		query["ScriptDraft"] = request.ScriptDraft
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SaveScript"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SaveScriptResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SaveScript(request *SaveScriptRequest) (_result *SaveScriptResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SaveScriptResponse{}
	_body, _err := client.SaveScriptWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   You cannot query the desired values of read-only properties.
 * *   You can specify up to 10 desired property values in a call.
 * *   After a device is created, the value of the **Version** parameter is 0. If you want to configure the **Version** parameter the first time you specify a desired property value, set the **Version** parameter to 0.
 * > If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request SetDeviceDesiredPropertyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDeviceDesiredPropertyResponse
 */
func (client *Client) SetDeviceDesiredPropertyWithOptions(request *SetDeviceDesiredPropertyRequest, runtime *util.RuntimeOptions) (_result *SetDeviceDesiredPropertyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Items)) {
		query["Items"] = request.Items
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Versions)) {
		query["Versions"] = request.Versions
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDeviceDesiredProperty"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDeviceDesiredPropertyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   You cannot query the desired values of read-only properties.
 * *   You can specify up to 10 desired property values in a call.
 * *   After a device is created, the value of the **Version** parameter is 0. If you want to configure the **Version** parameter the first time you specify a desired property value, set the **Version** parameter to 0.
 * > If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request SetDeviceDesiredPropertyRequest
 * @return SetDeviceDesiredPropertyResponse
 */
func (client *Client) SetDeviceDesiredProperty(request *SetDeviceDesiredPropertyRequest) (_result *SetDeviceDesiredPropertyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDeviceDesiredPropertyResponse{}
	_body, _err := client.SetDeviceDesiredPropertyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * A device group can have a maximum of 100 tags.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request SetDeviceGroupTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDeviceGroupTagsResponse
 */
func (client *Client) SetDeviceGroupTagsWithOptions(request *SetDeviceGroupTagsRequest, runtime *util.RuntimeOptions) (_result *SetDeviceGroupTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupType)) {
		query["GroupType"] = request.GroupType
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.TagString)) {
		query["TagString"] = request.TagString
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDeviceGroupTags"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDeviceGroupTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * A device group can have a maximum of 100 tags.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 50 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request SetDeviceGroupTagsRequest
 * @return SetDeviceGroupTagsResponse
 */
func (client *Client) SetDeviceGroupTags(request *SetDeviceGroupTagsRequest) (_result *SetDeviceGroupTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDeviceGroupTagsResponse{}
	_body, _err := client.SetDeviceGroupTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * After IoT Platform sends a request to configure device properties, the device receives and processes the request in an asynchronous manner. When you call this operation, a successful response indicates that IoT Platform sent a request. The response does not indicate that the device received and processed the request. After the device SDK responds to the request, the device properties are configured.
 * > If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request SetDevicePropertyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDevicePropertyResponse
 */
func (client *Client) SetDevicePropertyWithOptions(request *SetDevicePropertyRequest, runtime *util.RuntimeOptions) (_result *SetDevicePropertyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Items)) {
		query["Items"] = request.Items
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Qos)) {
		query["Qos"] = request.Qos
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDeviceProperty"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDevicePropertyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * After IoT Platform sends a request to configure device properties, the device receives and processes the request in an asynchronous manner. When you call this operation, a successful response indicates that IoT Platform sent a request. The response does not indicate that the device received and processed the request. After the device SDK responds to the request, the device properties are configured.
 * > If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 500 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request SetDevicePropertyRequest
 * @return SetDevicePropertyResponse
 */
func (client *Client) SetDeviceProperty(request *SetDevicePropertyRequest) (_result *SetDevicePropertyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDevicePropertyResponse{}
	_body, _err := client.SetDevicePropertyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request SetDevicesPropertyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDevicesPropertyResponse
 */
func (client *Client) SetDevicesPropertyWithOptions(request *SetDevicesPropertyRequest, runtime *util.RuntimeOptions) (_result *SetDevicesPropertyResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Items)) {
		query["Items"] = request.Items
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Qos)) {
		query["Qos"] = request.Qos
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetDevicesProperty"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetDevicesPropertyResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * If the Thing Specification Language (TSL) data is of the float or double type, the parameter values that correspond to the TSL data contain at least one decimal place. Examples: 10.0 and 11.1.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request SetDevicesPropertyRequest
 * @return SetDevicesPropertyResponse
 */
func (client *Client) SetDevicesProperty(request *SetDevicesPropertyRequest) (_result *SetDevicesPropertyResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetDevicesPropertyResponse{}
	_body, _err := client.SetDevicesPropertyWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetEdgeInstanceDriverConfigsWithOptions(request *SetEdgeInstanceDriverConfigsRequest, runtime *util.RuntimeOptions) (_result *SetEdgeInstanceDriverConfigsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configs)) {
		query["Configs"] = request.Configs
	}

	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetEdgeInstanceDriverConfigs"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetEdgeInstanceDriverConfigsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetEdgeInstanceDriverConfigs(request *SetEdgeInstanceDriverConfigsRequest) (_result *SetEdgeInstanceDriverConfigsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetEdgeInstanceDriverConfigsResponse{}
	_body, _err := client.SetEdgeInstanceDriverConfigsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 30 times per second per account.
 * >The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request SetProductCertInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetProductCertInfoResponse
 */
func (client *Client) SetProductCertInfoWithOptions(request *SetProductCertInfoRequest, runtime *util.RuntimeOptions) (_result *SetProductCertInfoResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IssueModel)) {
		query["IssueModel"] = request.IssueModel
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SetProductCertInfo"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetProductCertInfoResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 30 times per second per account.
 * >The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request SetProductCertInfoRequest
 * @return SetProductCertInfoResponse
 */
func (client *Client) SetProductCertInfo(request *SetProductCertInfoRequest) (_result *SetProductCertInfoResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetProductCertInfoResponse{}
	_body, _err := client.SetProductCertInfoWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetStudioProjectCooperationWithOptions(request *SetStudioProjectCooperationRequest, runtime *util.RuntimeOptions) (_result *SetStudioProjectCooperationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		body["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("SetStudioProjectCooperation"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetStudioProjectCooperationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetStudioProjectCooperation(request *SetStudioProjectCooperationRequest) (_result *SetStudioProjectCooperationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetStudioProjectCooperationResponse{}
	_body, _err := client.SetStudioProjectCooperationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SetupStudioAppAuthModeOpenWithOptions(request *SetupStudioAppAuthModeOpenRequest, runtime *util.RuntimeOptions) (_result *SetupStudioAppAuthModeOpenResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AppId)) {
		body["AppId"] = request.AppId
	}

	if !tea.BoolValue(util.IsUnset(request.AuthMode)) {
		body["AuthMode"] = request.AuthMode
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectId)) {
		body["ProjectId"] = request.ProjectId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("SetupStudioAppAuthModeOpen"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SetupStudioAppAuthModeOpenResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SetupStudioAppAuthModeOpen(request *SetupStudioAppAuthModeOpenRequest) (_result *SetupStudioAppAuthModeOpenResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SetupStudioAppAuthModeOpenResponse{}
	_body, _err := client.SetupStudioAppAuthModeOpenWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ShareSpeechByCombinationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ShareSpeechByCombinationResponse
 */
func (client *Client) ShareSpeechByCombinationWithOptions(request *ShareSpeechByCombinationRequest, runtime *util.RuntimeOptions) (_result *ShareSpeechByCombinationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AudioFormat)) {
		body["AudioFormat"] = request.AudioFormat
	}

	if !tea.BoolValue(util.IsUnset(request.CombinationList)) {
		body["CombinationList"] = request.CombinationList
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		body["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		body["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		body["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechId)) {
		body["SpeechId"] = request.SpeechId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("ShareSpeechByCombination"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &ShareSpeechByCombinationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 50 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request ShareSpeechByCombinationRequest
 * @return ShareSpeechByCombinationResponse
 */
func (client *Client) ShareSpeechByCombination(request *ShareSpeechByCombinationRequest) (_result *ShareSpeechByCombinationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &ShareSpeechByCombinationResponse{}
	_body, _err := client.ShareSpeechByCombinationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SpeechByCombinationWithOptions(request *SpeechByCombinationRequest, runtime *util.RuntimeOptions) (_result *SpeechByCombinationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AudioFormat)) {
		body["AudioFormat"] = request.AudioFormat
	}

	if !tea.BoolValue(util.IsUnset(request.CombinationList)) {
		body["CombinationList"] = request.CombinationList
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		body["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.EnforceFlag)) {
		body["EnforceFlag"] = request.EnforceFlag
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		body["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		body["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechId)) {
		body["SpeechId"] = request.SpeechId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("SpeechByCombination"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SpeechByCombinationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SpeechByCombination(request *SpeechByCombinationRequest) (_result *SpeechByCombinationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SpeechByCombinationResponse{}
	_body, _err := client.SpeechByCombinationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SpeechBySynthesisWithOptions(request *SpeechBySynthesisRequest, runtime *util.RuntimeOptions) (_result *SpeechBySynthesisResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AudioFormat)) {
		body["AudioFormat"] = request.AudioFormat
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		body["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		body["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		body["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechId)) {
		body["SpeechId"] = request.SpeechId
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechRate)) {
		body["SpeechRate"] = request.SpeechRate
	}

	if !tea.BoolValue(util.IsUnset(request.Text)) {
		body["Text"] = request.Text
	}

	if !tea.BoolValue(util.IsUnset(request.Voice)) {
		body["Voice"] = request.Voice
	}

	if !tea.BoolValue(util.IsUnset(request.Volume)) {
		body["Volume"] = request.Volume
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("SpeechBySynthesis"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SpeechBySynthesisResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SpeechBySynthesis(request *SpeechBySynthesisRequest) (_result *SpeechBySynthesisResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SpeechBySynthesisResponse{}
	_body, _err := client.SpeechBySynthesisWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StartParserWithOptions(request *StartParserRequest, runtime *util.RuntimeOptions) (_result *StartParserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ParserId)) {
		query["ParserId"] = request.ParserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartParser"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartParserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StartParser(request *StartParserRequest) (_result *StartParserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartParserResponse{}
	_body, _err := client.StartParserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   You must verify that the rule has SQL statements configured before you start the rule. If you do not set an SQL statement when you create the rule, call the [UpdateRule](~~69513~~) operation to add an SQL statement and update the rule.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request StartRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartRuleResponse
 */
func (client *Client) StartRuleWithOptions(request *StartRuleRequest, runtime *util.RuntimeOptions) (_result *StartRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StartRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StartRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   You must verify that the rule has SQL statements configured before you start the rule. If you do not set an SQL statement when you create the rule, call the [UpdateRule](~~69513~~) operation to add an SQL statement and update the rule.
 * *   Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request StartRuleRequest
 * @return StartRuleResponse
 */
func (client *Client) StartRule(request *StartRuleRequest) (_result *StartRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StartRuleResponse{}
	_body, _err := client.StartRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) StopParserWithOptions(request *StopParserRequest, runtime *util.RuntimeOptions) (_result *StopParserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ParserId)) {
		query["ParserId"] = request.ParserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopParser"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopParserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) StopParser(request *StopParserRequest) (_result *StopParserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopParserResponse{}
	_body, _err := client.StopParserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request StopRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopRuleResponse
 */
func (client *Client) StopRuleWithOptions(request *StopRuleRequest, runtime *util.RuntimeOptions) (_result *StopRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("StopRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &StopRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request StopRuleRequest
 * @return StopRuleResponse
 */
func (client *Client) StopRule(request *StopRuleRequest) (_result *StopRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &StopRuleResponse{}
	_body, _err := client.StopRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   The device that needs to subscribe to topics must be connected to IoT Platform and online.
 * *   You can call this operation to subscribe to the topics of a specified device. You can specify a maximum of 10 topics in a single call.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request SubscribeTopicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SubscribeTopicResponse
 */
func (client *Client) SubscribeTopicWithOptions(request *SubscribeTopicRequest, runtime *util.RuntimeOptions) (_result *SubscribeTopicResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.Topic)) {
		query["Topic"] = request.Topic
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("SubscribeTopic"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SubscribeTopicResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   The device that needs to subscribe to topics must be connected to IoT Platform and online.
 * *   You can call this operation to subscribe to the topics of a specified device. You can specify a maximum of 10 topics in a single call.
 * ## QPS limits
 * Each Alibaba Cloud account can run up to 10 queries per second (QPS).
 * >  The RAM users of an Alibaba Cloud account share the quota of the Alibaba Cloud account.
 *
 * @param request SubscribeTopicRequest
 * @return SubscribeTopicResponse
 */
func (client *Client) SubscribeTopic(request *SubscribeTopicRequest) (_result *SubscribeTopicResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SubscribeTopicResponse{}
	_body, _err := client.SubscribeTopicWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) SyncSpeechByCombinationWithOptions(request *SyncSpeechByCombinationRequest, runtime *util.RuntimeOptions) (_result *SyncSpeechByCombinationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AudioFormat)) {
		body["AudioFormat"] = request.AudioFormat
	}

	if !tea.BoolValue(util.IsUnset(request.CombinationList)) {
		body["CombinationList"] = request.CombinationList
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		body["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.EnforceFlag)) {
		body["EnforceFlag"] = request.EnforceFlag
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		body["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		body["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechId)) {
		body["SpeechId"] = request.SpeechId
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("SyncSpeechByCombination"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &SyncSpeechByCombinationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) SyncSpeechByCombination(request *SyncSpeechByCombinationRequest) (_result *SyncSpeechByCombinationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &SyncSpeechByCombinationResponse{}
	_body, _err := client.SyncSpeechByCombinationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TestSpeechWithOptions(tmpReq *TestSpeechRequest, runtime *util.RuntimeOptions) (_result *TestSpeechResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &TestSpeechShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.SoundCodeConfig)) {
		request.SoundCodeConfigShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.SoundCodeConfig, tea.String("SoundCodeConfig"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AudioFormat)) {
		body["AudioFormat"] = request.AudioFormat
	}

	if !tea.BoolValue(util.IsUnset(request.EnableSoundCode)) {
		body["EnableSoundCode"] = request.EnableSoundCode
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectCode)) {
		body["ProjectCode"] = request.ProjectCode
	}

	if !tea.BoolValue(util.IsUnset(request.SoundCodeConfigShrink)) {
		body["SoundCodeConfig"] = request.SoundCodeConfigShrink
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechRate)) {
		body["SpeechRate"] = request.SpeechRate
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechType)) {
		body["SpeechType"] = request.SpeechType
	}

	if !tea.BoolValue(util.IsUnset(request.Text)) {
		body["Text"] = request.Text
	}

	if !tea.BoolValue(util.IsUnset(request.Voice)) {
		body["Voice"] = request.Voice
	}

	if !tea.BoolValue(util.IsUnset(request.Volume)) {
		body["Volume"] = request.Volume
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("TestSpeech"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TestSpeechResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TestSpeech(request *TestSpeechRequest) (_result *TestSpeechResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TestSpeechResponse{}
	_body, _err := client.TestSpeechWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TestSwitchWithOptions(request *TestSwitchRequest, runtime *util.RuntimeOptions) (_result *TestSwitchResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TestSwitch"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TestSwitchResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TestSwitch(request *TestSwitchRequest) (_result *TestSwitchResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TestSwitchResponse{}
	_body, _err := client.TestSwitchWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can call the [QueryClientIds](~~371985~~) operation to view the ClientIDs of a device.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request TransformClientIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TransformClientIdResponse
 */
func (client *Client) TransformClientIdWithOptions(request *TransformClientIdRequest, runtime *util.RuntimeOptions) (_result *TransformClientIdResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ClientId)) {
		query["ClientId"] = request.ClientId
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TransformClientId"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TransformClientIdResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can call the [QueryClientIds](~~371985~~) operation to view the ClientIDs of a device.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request TransformClientIdRequest
 * @return TransformClientIdResponse
 */
func (client *Client) TransformClientId(request *TransformClientIdRequest) (_result *TransformClientIdResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TransformClientIdResponse{}
	_body, _err := client.TransformClientIdWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) TriggerSceneRuleWithOptions(request *TriggerSceneRuleRequest, runtime *util.RuntimeOptions) (_result *TriggerSceneRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("TriggerSceneRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &TriggerSceneRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) TriggerSceneRule(request *TriggerSceneRuleRequest) (_result *TriggerSceneRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &TriggerSceneRuleResponse{}
	_body, _err := client.TriggerSceneRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UnbindApplicationFromEdgeInstanceWithOptions(request *UnbindApplicationFromEdgeInstanceRequest, runtime *util.RuntimeOptions) (_result *UnbindApplicationFromEdgeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ApplicationId)) {
		query["ApplicationId"] = request.ApplicationId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnbindApplicationFromEdgeInstance"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnbindApplicationFromEdgeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UnbindApplicationFromEdgeInstance(request *UnbindApplicationFromEdgeInstanceRequest) (_result *UnbindApplicationFromEdgeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnbindApplicationFromEdgeInstanceResponse{}
	_body, _err := client.UnbindApplicationFromEdgeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UnbindDriverFromEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindDriverFromEdgeInstanceResponse
 */
func (client *Client) UnbindDriverFromEdgeInstanceWithOptions(request *UnbindDriverFromEdgeInstanceRequest, runtime *util.RuntimeOptions) (_result *UnbindDriverFromEdgeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnbindDriverFromEdgeInstance"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnbindDriverFromEdgeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UnbindDriverFromEdgeInstanceRequest
 * @return UnbindDriverFromEdgeInstanceResponse
 */
func (client *Client) UnbindDriverFromEdgeInstance(request *UnbindDriverFromEdgeInstanceRequest) (_result *UnbindDriverFromEdgeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnbindDriverFromEdgeInstanceResponse{}
	_body, _err := client.UnbindDriverFromEdgeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Usage notes
 * A license is bound with a product. For more information, see [BindLicenseProduct](~~427956~~) or [Bind a license to a product](~~427937~~).
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UnbindLicenseProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindLicenseProductResponse
 */
func (client *Client) UnbindLicenseProductWithOptions(request *UnbindLicenseProductRequest, runtime *util.RuntimeOptions) (_result *UnbindLicenseProductResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.LicenseCode)) {
		query["LicenseCode"] = request.LicenseCode
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnbindLicenseProduct"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnbindLicenseProductResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Usage notes
 * A license is bound with a product. For more information, see [BindLicenseProduct](~~427956~~) or [Bind a license to a product](~~427937~~).
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * > The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UnbindLicenseProductRequest
 * @return UnbindLicenseProductResponse
 */
func (client *Client) UnbindLicenseProduct(request *UnbindLicenseProductRequest) (_result *UnbindLicenseProductResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnbindLicenseProductResponse{}
	_body, _err := client.UnbindLicenseProductWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UnbindRoleFromEdgeInstanceWithOptions(request *UnbindRoleFromEdgeInstanceRequest, runtime *util.RuntimeOptions) (_result *UnbindRoleFromEdgeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnbindRoleFromEdgeInstance"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnbindRoleFromEdgeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UnbindRoleFromEdgeInstance(request *UnbindRoleFromEdgeInstanceRequest) (_result *UnbindRoleFromEdgeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnbindRoleFromEdgeInstanceResponse{}
	_body, _err := client.UnbindRoleFromEdgeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UnbindSceneRuleFromEdgeInstanceWithOptions(request *UnbindSceneRuleFromEdgeInstanceRequest, runtime *util.RuntimeOptions) (_result *UnbindSceneRuleFromEdgeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UnbindSceneRuleFromEdgeInstance"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UnbindSceneRuleFromEdgeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UnbindSceneRuleFromEdgeInstance(request *UnbindSceneRuleFromEdgeInstanceRequest) (_result *UnbindSceneRuleFromEdgeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UnbindSceneRuleFromEdgeInstanceResponse{}
	_body, _err := client.UnbindSceneRuleFromEdgeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   You cannot modify the default consumer group provided by IoT Platform.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateConsumerGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateConsumerGroupResponse
 */
func (client *Client) UpdateConsumerGroupWithOptions(request *UpdateConsumerGroupRequest, runtime *util.RuntimeOptions) (_result *UpdateConsumerGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.NewGroupName)) {
		query["NewGroupName"] = request.NewGroupName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateConsumerGroup"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateConsumerGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   You cannot modify the default consumer group provided by IoT Platform.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateConsumerGroupRequest
 * @return UpdateConsumerGroupResponse
 */
func (client *Client) UpdateConsumerGroup(request *UpdateConsumerGroupRequest) (_result *UpdateConsumerGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateConsumerGroupResponse{}
	_body, _err := client.UpdateConsumerGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateDestinationWithOptions(request *UpdateDestinationRequest, runtime *util.RuntimeOptions) (_result *UpdateDestinationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		query["Configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DestinationId)) {
		query["DestinationId"] = request.DestinationId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDestination"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDestinationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateDestination(request *UpdateDestinationRequest) (_result *UpdateDestinationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDestinationResponse{}
	_body, _err := client.UpdateDestinationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateDeviceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDeviceGroupResponse
 */
func (client *Client) UpdateDeviceGroupWithOptions(request *UpdateDeviceGroupRequest, runtime *util.RuntimeOptions) (_result *UpdateDeviceGroupResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.GroupDesc)) {
		query["GroupDesc"] = request.GroupDesc
	}

	if !tea.BoolValue(util.IsUnset(request.GroupId)) {
		query["GroupId"] = request.GroupId
	}

	if !tea.BoolValue(util.IsUnset(request.GroupType)) {
		query["GroupType"] = request.GroupType
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDeviceGroup"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDeviceGroupResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateDeviceGroupRequest
 * @return UpdateDeviceGroupResponse
 */
func (client *Client) UpdateDeviceGroup(request *UpdateDeviceGroupRequest) (_result *UpdateDeviceGroupResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDeviceGroupResponse{}
	_body, _err := client.UpdateDeviceGroupWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 500 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateDeviceShadowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateDeviceShadowResponse
 */
func (client *Client) UpdateDeviceShadowWithOptions(request *UpdateDeviceShadowRequest, runtime *util.RuntimeOptions) (_result *UpdateDeviceShadowResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeltaUpdate)) {
		query["DeltaUpdate"] = request.DeltaUpdate
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ShadowMessage)) {
		query["ShadowMessage"] = request.ShadowMessage
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateDeviceShadow"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateDeviceShadowResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 500 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateDeviceShadowRequest
 * @return UpdateDeviceShadowResponse
 */
func (client *Client) UpdateDeviceShadow(request *UpdateDeviceShadowRequest) (_result *UpdateDeviceShadowResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateDeviceShadowResponse{}
	_body, _err := client.UpdateDeviceShadowWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   If a request parameter is not specified, the original value of the parameter will be cleared for the driver version.
 * *   You are not allowed to update a published driver version.
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateEdgeDriverVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEdgeDriverVersionResponse
 */
func (client *Client) UpdateEdgeDriverVersionWithOptions(request *UpdateEdgeDriverVersionRequest, runtime *util.RuntimeOptions) (_result *UpdateEdgeDriverVersionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Argument)) {
		query["Argument"] = request.Argument
	}

	if !tea.BoolValue(util.IsUnset(request.ConfigCheckRule)) {
		query["ConfigCheckRule"] = request.ConfigCheckRule
	}

	if !tea.BoolValue(util.IsUnset(request.ContainerConfig)) {
		query["ContainerConfig"] = request.ContainerConfig
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.DriverConfig)) {
		query["DriverConfig"] = request.DriverConfig
	}

	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.DriverVersion)) {
		query["DriverVersion"] = request.DriverVersion
	}

	if !tea.BoolValue(util.IsUnset(request.EdgeVersion)) {
		query["EdgeVersion"] = request.EdgeVersion
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceConfig)) {
		query["SourceConfig"] = request.SourceConfig
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateEdgeDriverVersion"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateEdgeDriverVersionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   If a request parameter is not specified, the original value of the parameter will be cleared for the driver version.
 * *   You are not allowed to update a published driver version.
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateEdgeDriverVersionRequest
 * @return UpdateEdgeDriverVersionResponse
 */
func (client *Client) UpdateEdgeDriverVersion(request *UpdateEdgeDriverVersionRequest) (_result *UpdateEdgeDriverVersionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateEdgeDriverVersionResponse{}
	_body, _err := client.UpdateEdgeDriverVersionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateEdgeInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateEdgeInstanceResponse
 */
func (client *Client) UpdateEdgeInstanceWithOptions(request *UpdateEdgeInstanceRequest, runtime *util.RuntimeOptions) (_result *UpdateEdgeInstanceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.BizEnable)) {
		query["BizEnable"] = request.BizEnable
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.Spec)) {
		query["Spec"] = request.Spec
	}

	if !tea.BoolValue(util.IsUnset(request.Tags)) {
		query["Tags"] = request.Tags
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateEdgeInstance"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateEdgeInstanceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of five queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateEdgeInstanceRequest
 * @return UpdateEdgeInstanceResponse
 */
func (client *Client) UpdateEdgeInstance(request *UpdateEdgeInstanceRequest) (_result *UpdateEdgeInstanceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateEdgeInstanceResponse{}
	_body, _err := client.UpdateEdgeInstanceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateEdgeInstanceChannelWithOptions(request *UpdateEdgeInstanceChannelRequest, runtime *util.RuntimeOptions) (_result *UpdateEdgeInstanceChannelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ChannelId)) {
		query["ChannelId"] = request.ChannelId
	}

	if !tea.BoolValue(util.IsUnset(request.ChannelName)) {
		query["ChannelName"] = request.ChannelName
	}

	if !tea.BoolValue(util.IsUnset(request.Configs)) {
		query["Configs"] = request.Configs
	}

	if !tea.BoolValue(util.IsUnset(request.DriverId)) {
		query["DriverId"] = request.DriverId
	}

	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateEdgeInstanceChannel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateEdgeInstanceChannelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateEdgeInstanceChannel(request *UpdateEdgeInstanceChannelRequest) (_result *UpdateEdgeInstanceChannelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateEdgeInstanceChannelResponse{}
	_body, _err := client.UpdateEdgeInstanceChannelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateEdgeInstanceMessageRoutingWithOptions(request *UpdateEdgeInstanceMessageRoutingRequest, runtime *util.RuntimeOptions) (_result *UpdateEdgeInstanceMessageRoutingResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.InstanceId)) {
		query["InstanceId"] = request.InstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.RouteId)) {
		query["RouteId"] = request.RouteId
	}

	if !tea.BoolValue(util.IsUnset(request.SourceData)) {
		query["SourceData"] = request.SourceData
	}

	if !tea.BoolValue(util.IsUnset(request.SourceType)) {
		query["SourceType"] = request.SourceType
	}

	if !tea.BoolValue(util.IsUnset(request.TargetData)) {
		query["TargetData"] = request.TargetData
	}

	if !tea.BoolValue(util.IsUnset(request.TargetIotHubQos)) {
		query["TargetIotHubQos"] = request.TargetIotHubQos
	}

	if !tea.BoolValue(util.IsUnset(request.TargetType)) {
		query["TargetType"] = request.TargetType
	}

	if !tea.BoolValue(util.IsUnset(request.TopicFilter)) {
		query["TopicFilter"] = request.TopicFilter
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateEdgeInstanceMessageRouting"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateEdgeInstanceMessageRoutingResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateEdgeInstanceMessageRouting(request *UpdateEdgeInstanceMessageRoutingRequest) (_result *UpdateEdgeInstanceMessageRoutingResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateEdgeInstanceMessageRoutingResponse{}
	_body, _err := client.UpdateEdgeInstanceMessageRoutingWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateJobWithOptions(tmpReq *UpdateJobRequest, runtime *util.RuntimeOptions) (_result *UpdateJobResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateJobShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.RolloutConfig)) {
		request.RolloutConfigShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.RolloutConfig, tea.String("RolloutConfig"), tea.String("json"))
	}

	if !tea.BoolValue(util.IsUnset(tmpReq.TimeoutConfig)) {
		request.TimeoutConfigShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.TimeoutConfig, tea.String("TimeoutConfig"), tea.String("json"))
	}

	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.JobId)) {
		query["JobId"] = request.JobId
	}

	if !tea.BoolValue(util.IsUnset(request.RolloutConfigShrink)) {
		query["RolloutConfig"] = request.RolloutConfigShrink
	}

	if !tea.BoolValue(util.IsUnset(request.TimeoutConfigShrink)) {
		query["TimeoutConfig"] = request.TimeoutConfigShrink
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateJob"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateJobResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateJob(request *UpdateJobRequest) (_result *UpdateJobResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateJobResponse{}
	_body, _err := client.UpdateJobWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateOTAModuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateOTAModuleResponse
 */
func (client *Client) UpdateOTAModuleWithOptions(request *UpdateOTAModuleRequest, runtime *util.RuntimeOptions) (_result *UpdateOTAModuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.AliasName)) {
		query["AliasName"] = request.AliasName
	}

	if !tea.BoolValue(util.IsUnset(request.Desc)) {
		query["Desc"] = request.Desc
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ModuleName)) {
		query["ModuleName"] = request.ModuleName
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateOTAModule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateOTAModuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateOTAModuleRequest
 * @return UpdateOTAModuleResponse
 */
func (client *Client) UpdateOTAModule(request *UpdateOTAModuleRequest) (_result *UpdateOTAModuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateOTAModuleResponse{}
	_body, _err := client.UpdateOTAModuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateParserWithOptions(request *UpdateParserRequest, runtime *util.RuntimeOptions) (_result *UpdateParserResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ParserId)) {
		query["ParserId"] = request.ParserId
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateParser"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateParserResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateParser(request *UpdateParserRequest) (_result *UpdateParserResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateParserResponse{}
	_body, _err := client.UpdateParserWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateParserDataSourceWithOptions(request *UpdateParserDataSourceRequest, runtime *util.RuntimeOptions) (_result *UpdateParserDataSourceResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DataSourceId)) {
		query["DataSourceId"] = request.DataSourceId
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateParserDataSource"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateParserDataSourceResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateParserDataSource(request *UpdateParserDataSourceRequest) (_result *UpdateParserDataSourceResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateParserDataSourceResponse{}
	_body, _err := client.UpdateParserDataSourceWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateProductRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateProductResponse
 */
func (client *Client) UpdateProductWithOptions(request *UpdateProductRequest, runtime *util.RuntimeOptions) (_result *UpdateProductResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ProductName)) {
		query["ProductName"] = request.ProductName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateProduct"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateProductResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## QPS limits
 * You can call this API operation up to 10 times per second per account.
 * >  The RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateProductRequest
 * @return UpdateProductResponse
 */
func (client *Client) UpdateProduct(request *UpdateProductRequest) (_result *UpdateProductResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateProductResponse{}
	_body, _err := client.UpdateProductWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Message deduplication rules
 * Based on the rules that you set, IoT Platform determines whether to use the rules engine or server-side subscriptions to forward property data that is submitted by devices to a specified destination.
 * The triggering conditions of rules are related by the logic AND relation. For example, if you set the PropertyValueFilter=true and PropertyTimestampFilter=true conditions, the rule to remove duplicate messages is triggered only when both of the conditions are met.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateProductFilterConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateProductFilterConfigResponse
 */
func (client *Client) UpdateProductFilterConfigWithOptions(request *UpdateProductFilterConfigRequest, runtime *util.RuntimeOptions) (_result *UpdateProductFilterConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.PropertyTimestampFilter)) {
		query["PropertyTimestampFilter"] = request.PropertyTimestampFilter
	}

	if !tea.BoolValue(util.IsUnset(request.PropertyValueFilter)) {
		query["PropertyValueFilter"] = request.PropertyValueFilter
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateProductFilterConfig"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateProductFilterConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Message deduplication rules
 * Based on the rules that you set, IoT Platform determines whether to use the rules engine or server-side subscriptions to forward property data that is submitted by devices to a specified destination.
 * The triggering conditions of rules are related by the logic AND relation. For example, if you set the PropertyValueFilter=true and PropertyTimestampFilter=true conditions, the rule to remove duplicate messages is triggered only when both of the conditions are met.
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateProductFilterConfigRequest
 * @return UpdateProductFilterConfigResponse
 */
func (client *Client) UpdateProductFilterConfig(request *UpdateProductFilterConfigRequest) (_result *UpdateProductFilterConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateProductFilterConfigResponse{}
	_body, _err := client.UpdateProductFilterConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * You can update a maximum of 10 tags in a single call.
 * > You must specify the tag keys and tag values. Otherwise, the call fails. For description about the tag values, see the "**Request parameters**" section of this topic.
 * ## QPS limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateProductTagsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateProductTagsResponse
 */
func (client *Client) UpdateProductTagsWithOptions(request *UpdateProductTagsRequest, runtime *util.RuntimeOptions) (_result *UpdateProductTagsResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ProductTag)) {
		query["ProductTag"] = request.ProductTag
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateProductTags"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateProductTagsResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * You can update a maximum of 10 tags in a single call.
 * > You must specify the tag keys and tag values. Otherwise, the call fails. For description about the tag values, see the "**Request parameters**" section of this topic.
 * ## QPS limits
 * Each Alibaba Cloud account can run a maximum of 500 queries per second (QPS).
 * >  The Resource Access Management (RAM) users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateProductTagsRequest
 * @return UpdateProductTagsResponse
 */
func (client *Client) UpdateProductTags(request *UpdateProductTagsRequest) (_result *UpdateProductTagsResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateProductTagsResponse{}
	_body, _err := client.UpdateProductTagsWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateProductTopicRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateProductTopicResponse
 */
func (client *Client) UpdateProductTopicWithOptions(request *UpdateProductTopicRequest, runtime *util.RuntimeOptions) (_result *UpdateProductTopicResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Codec)) {
		query["Codec"] = request.Codec
	}

	if !tea.BoolValue(util.IsUnset(request.Desc)) {
		query["Desc"] = request.Desc
	}

	if !tea.BoolValue(util.IsUnset(request.EnableProxySubscribe)) {
		query["EnableProxySubscribe"] = request.EnableProxySubscribe
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Operation)) {
		query["Operation"] = request.Operation
	}

	if !tea.BoolValue(util.IsUnset(request.TopicId)) {
		query["TopicId"] = request.TopicId
	}

	if !tea.BoolValue(util.IsUnset(request.TopicShortName)) {
		query["TopicShortName"] = request.TopicShortName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateProductTopic"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateProductTopicResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateProductTopicRequest
 * @return UpdateProductTopicResponse
 */
func (client *Client) UpdateProductTopic(request *UpdateProductTopicRequest) (_result *UpdateProductTopicResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateProductTopicResponse{}
	_body, _err := client.UpdateProductTopicWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRuleResponse
 */
func (client *Client) UpdateRuleWithOptions(request *UpdateRuleRequest, runtime *util.RuntimeOptions) (_result *UpdateRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		query["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.RuleDesc)) {
		query["RuleDesc"] = request.RuleDesc
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	if !tea.BoolValue(util.IsUnset(request.Select)) {
		query["Select"] = request.Select
	}

	if !tea.BoolValue(util.IsUnset(request.ShortTopic)) {
		query["ShortTopic"] = request.ShortTopic
	}

	if !tea.BoolValue(util.IsUnset(request.Topic)) {
		query["Topic"] = request.Topic
	}

	if !tea.BoolValue(util.IsUnset(request.TopicType)) {
		query["TopicType"] = request.TopicType
	}

	if !tea.BoolValue(util.IsUnset(request.Where)) {
		query["Where"] = request.Where
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateRuleRequest
 * @return UpdateRuleResponse
 */
func (client *Client) UpdateRule(request *UpdateRuleRequest) (_result *UpdateRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateRuleResponse{}
	_body, _err := client.UpdateRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateRuleActionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRuleActionResponse
 */
func (client *Client) UpdateRuleActionWithOptions(request *UpdateRuleActionRequest, runtime *util.RuntimeOptions) (_result *UpdateRuleActionResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ActionId)) {
		query["ActionId"] = request.ActionId
	}

	if !tea.BoolValue(util.IsUnset(request.Configuration)) {
		query["Configuration"] = request.Configuration
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateRuleAction"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateRuleActionResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 50 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateRuleActionRequest
 * @return UpdateRuleActionResponse
 */
func (client *Client) UpdateRuleAction(request *UpdateRuleActionRequest) (_result *UpdateRuleActionResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateRuleActionResponse{}
	_body, _err := client.UpdateRuleActionWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateSceneRuleWithOptions(request *UpdateSceneRuleRequest, runtime *util.RuntimeOptions) (_result *UpdateSceneRuleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleContent)) {
		query["RuleContent"] = request.RuleContent
	}

	if !tea.BoolValue(util.IsUnset(request.RuleDescription)) {
		query["RuleDescription"] = request.RuleDescription
	}

	if !tea.BoolValue(util.IsUnset(request.RuleId)) {
		query["RuleId"] = request.RuleId
	}

	if !tea.BoolValue(util.IsUnset(request.RuleName)) {
		query["RuleName"] = request.RuleName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSceneRule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateSceneRuleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateSceneRule(request *UpdateSceneRuleRequest) (_result *UpdateSceneRuleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateSceneRuleResponse{}
	_body, _err := client.UpdateSceneRuleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateSchedulePeriodWithOptions(request *UpdateSchedulePeriodRequest, runtime *util.RuntimeOptions) (_result *UpdateSchedulePeriodResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		body["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.PeriodCode)) {
		body["PeriodCode"] = request.PeriodCode
	}

	if !tea.BoolValue(util.IsUnset(request.SoundCodeContent)) {
		body["SoundCodeContent"] = request.SoundCodeContent
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		body["StartTime"] = request.StartTime
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSchedulePeriod"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateSchedulePeriodResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateSchedulePeriod(request *UpdateSchedulePeriodRequest) (_result *UpdateSchedulePeriodResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateSchedulePeriodResponse{}
	_body, _err := client.UpdateSchedulePeriodWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateSoundCodeWithOptions(request *UpdateSoundCodeRequest, runtime *util.RuntimeOptions) (_result *UpdateSoundCodeResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Duration)) {
		body["Duration"] = request.Duration
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.SoundCode)) {
		body["SoundCode"] = request.SoundCode
	}

	if !tea.BoolValue(util.IsUnset(request.SoundCodeContent)) {
		body["SoundCodeContent"] = request.SoundCodeContent
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSoundCode"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateSoundCodeResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateSoundCode(request *UpdateSoundCodeRequest) (_result *UpdateSoundCodeResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateSoundCodeResponse{}
	_body, _err := client.UpdateSoundCodeWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateSoundCodeLabelWithOptions(request *UpdateSoundCodeLabelRequest, runtime *util.RuntimeOptions) (_result *UpdateSoundCodeLabelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Label)) {
		body["Label"] = request.Label
	}

	if !tea.BoolValue(util.IsUnset(request.SoundCode)) {
		body["SoundCode"] = request.SoundCode
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSoundCodeLabel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateSoundCodeLabelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateSoundCodeLabel(request *UpdateSoundCodeLabelRequest) (_result *UpdateSoundCodeLabelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateSoundCodeLabelResponse{}
	_body, _err := client.UpdateSoundCodeLabelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateSoundCodeScheduleWithOptions(request *UpdateSoundCodeScheduleRequest, runtime *util.RuntimeOptions) (_result *UpdateSoundCodeScheduleResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Description)) {
		body["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EndDate)) {
		body["EndDate"] = request.EndDate
	}

	if !tea.BoolValue(util.IsUnset(request.EndTime)) {
		body["EndTime"] = request.EndTime
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Name)) {
		body["Name"] = request.Name
	}

	if !tea.BoolValue(util.IsUnset(request.ScheduleCode)) {
		body["ScheduleCode"] = request.ScheduleCode
	}

	if !tea.BoolValue(util.IsUnset(request.StartDate)) {
		body["StartDate"] = request.StartDate
	}

	if !tea.BoolValue(util.IsUnset(request.StartTime)) {
		body["StartTime"] = request.StartTime
	}

	if !tea.BoolValue(util.IsUnset(request.Status)) {
		body["Status"] = request.Status
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSoundCodeSchedule"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateSoundCodeScheduleResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateSoundCodeSchedule(request *UpdateSoundCodeScheduleRequest) (_result *UpdateSoundCodeScheduleResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateSoundCodeScheduleResponse{}
	_body, _err := client.UpdateSoundCodeScheduleWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) UpdateSpeechWithOptions(tmpReq *UpdateSpeechRequest, runtime *util.RuntimeOptions) (_result *UpdateSpeechResponse, _err error) {
	_err = util.ValidateModel(tmpReq)
	if _err != nil {
		return _result, _err
	}
	request := &UpdateSpeechShrinkRequest{}
	openapiutil.Convert(tmpReq, request)
	if !tea.BoolValue(util.IsUnset(tmpReq.SoundCodeConfig)) {
		request.SoundCodeConfigShrink = openapiutil.ArrayToStringWithSpecifiedStyle(tmpReq.SoundCodeConfig, tea.String("SoundCodeConfig"), tea.String("json"))
	}

	body := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.EnableSoundCode)) {
		body["EnableSoundCode"] = request.EnableSoundCode
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		body["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProjectCode)) {
		body["ProjectCode"] = request.ProjectCode
	}

	if !tea.BoolValue(util.IsUnset(request.SoundCodeConfigShrink)) {
		body["SoundCodeConfig"] = request.SoundCodeConfigShrink
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechCode)) {
		body["SpeechCode"] = request.SpeechCode
	}

	if !tea.BoolValue(util.IsUnset(request.SpeechRate)) {
		body["SpeechRate"] = request.SpeechRate
	}

	if !tea.BoolValue(util.IsUnset(request.Voice)) {
		body["Voice"] = request.Voice
	}

	if !tea.BoolValue(util.IsUnset(request.Volume)) {
		body["Volume"] = request.Volume
	}

	req := &openapi.OpenApiRequest{
		Body: openapiutil.ParseToMap(body),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSpeech"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateSpeechResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) UpdateSpeech(request *UpdateSpeechRequest) (_result *UpdateSpeechResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateSpeechResponse{}
	_body, _err := client.UpdateSpeechWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateSubscribeRelationRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateSubscribeRelationResponse
 */
func (client *Client) UpdateSubscribeRelationWithOptions(request *UpdateSubscribeRelationRequest, runtime *util.RuntimeOptions) (_result *UpdateSubscribeRelationResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.ConsumerGroupIds)) {
		query["ConsumerGroupIds"] = request.ConsumerGroupIds
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceDataFlag)) {
		query["DeviceDataFlag"] = request.DeviceDataFlag
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceLifeCycleFlag)) {
		query["DeviceLifeCycleFlag"] = request.DeviceLifeCycleFlag
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceStatusChangeFlag)) {
		query["DeviceStatusChangeFlag"] = request.DeviceStatusChangeFlag
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceTagFlag)) {
		query["DeviceTagFlag"] = request.DeviceTagFlag
	}

	if !tea.BoolValue(util.IsUnset(request.DeviceTopoLifeCycleFlag)) {
		query["DeviceTopoLifeCycleFlag"] = request.DeviceTopoLifeCycleFlag
	}

	if !tea.BoolValue(util.IsUnset(request.FoundDeviceListFlag)) {
		query["FoundDeviceListFlag"] = request.FoundDeviceListFlag
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.MnsConfiguration)) {
		query["MnsConfiguration"] = request.MnsConfiguration
	}

	if !tea.BoolValue(util.IsUnset(request.OtaEventFlag)) {
		query["OtaEventFlag"] = request.OtaEventFlag
	}

	if !tea.BoolValue(util.IsUnset(request.OtaJobFlag)) {
		query["OtaJobFlag"] = request.OtaJobFlag
	}

	if !tea.BoolValue(util.IsUnset(request.OtaVersionFlag)) {
		query["OtaVersionFlag"] = request.OtaVersionFlag
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.SubscribeFlags)) {
		query["SubscribeFlags"] = request.SubscribeFlags
	}

	if !tea.BoolValue(util.IsUnset(request.ThingHistoryFlag)) {
		query["ThingHistoryFlag"] = request.ThingHistoryFlag
	}

	if !tea.BoolValue(util.IsUnset(request.Type)) {
		query["Type"] = request.Type
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateSubscribeRelation"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateSubscribeRelationResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * >  RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateSubscribeRelationRequest
 * @return UpdateSubscribeRelationResponse
 */
func (client *Client) UpdateSubscribeRelation(request *UpdateSubscribeRelationRequest) (_result *UpdateSubscribeRelationResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateSubscribeRelationResponse{}
	_body, _err := client.UpdateSubscribeRelationWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * ## Limits
 * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
 * *   When you call this operation, you can use the [json-schema](https://github.com/everit-org/json-schema?spm=a2c4g.11186623.2.23.575832d9zD7fZb) library to verify the input parameters in **ThingModelJson**. For more information, see [Data structure of ThingModelJson](~~150457~~).
 * *   You can call this operation to update only one feature. TSL features include properties, services, and events.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateThingModelRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateThingModelResponse
 */
func (client *Client) UpdateThingModelWithOptions(request *UpdateThingModelRequest, runtime *util.RuntimeOptions) (_result *UpdateThingModelResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.FunctionBlockId)) {
		query["FunctionBlockId"] = request.FunctionBlockId
	}

	if !tea.BoolValue(util.IsUnset(request.FunctionBlockName)) {
		query["FunctionBlockName"] = request.FunctionBlockName
	}

	if !tea.BoolValue(util.IsUnset(request.Identifier)) {
		query["Identifier"] = request.Identifier
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ThingModelJson)) {
		query["ThingModelJson"] = request.ThingModelJson
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateThingModel"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateThingModelResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * ## Limits
 * *   If a product is published, you must call the [CancelReleaseProduct](~~213875~~) operation to unpublish the product before you call this operation.
 * *   When you call this operation, you can use the [json-schema](https://github.com/everit-org/json-schema?spm=a2c4g.11186623.2.23.575832d9zD7fZb) library to verify the input parameters in **ThingModelJson**. For more information, see [Data structure of ThingModelJson](~~150457~~).
 * *   You can call this operation to update only one feature. TSL features include properties, services, and events.
 * *   Each Alibaba Cloud account can run a maximum of 5 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateThingModelRequest
 * @return UpdateThingModelResponse
 */
func (client *Client) UpdateThingModel(request *UpdateThingModelRequest) (_result *UpdateThingModelResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateThingModelResponse{}
	_body, _err := client.UpdateThingModelWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 * *   A data parsing script is used to convert the custom-formatted data to JSON data after the data is submitted by a device. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateThingScriptRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateThingScriptResponse
 */
func (client *Client) UpdateThingScriptWithOptions(request *UpdateThingScriptRequest, runtime *util.RuntimeOptions) (_result *UpdateThingScriptResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.ScriptContent)) {
		query["ScriptContent"] = request.ScriptContent
	}

	if !tea.BoolValue(util.IsUnset(request.ScriptType)) {
		query["ScriptType"] = request.ScriptType
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateThingScript"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateThingScriptResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 * *   A data parsing script is used to convert the custom-formatted data to JSON data after the data is submitted by a device. You can write a script in JavaScript, Python 2.7, and PHP 7.2. For more information, see [Submit scripts for data parsing](~~149963~~).
 * *   Each Alibaba Cloud account can run a maximum of 10 queries per second (QPS).
 * > RAM users of an Alibaba Cloud account share the quota of the account.
 *
 * @param request UpdateThingScriptRequest
 * @return UpdateThingScriptResponse
 */
func (client *Client) UpdateThingScript(request *UpdateThingScriptRequest) (_result *UpdateThingScriptResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateThingScriptResponse{}
	_body, _err := client.UpdateThingScriptWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

/**
 *
 * @param request UpdateTopicConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateTopicConfigResponse
 */
func (client *Client) UpdateTopicConfigWithOptions(request *UpdateTopicConfigRequest, runtime *util.RuntimeOptions) (_result *UpdateTopicConfigResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.Codec)) {
		query["Codec"] = request.Codec
	}

	if !tea.BoolValue(util.IsUnset(request.Description)) {
		query["Description"] = request.Description
	}

	if !tea.BoolValue(util.IsUnset(request.EnableBroadcast)) {
		query["EnableBroadcast"] = request.EnableBroadcast
	}

	if !tea.BoolValue(util.IsUnset(request.EnableProxySubscribe)) {
		query["EnableProxySubscribe"] = request.EnableProxySubscribe
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Operation)) {
		query["Operation"] = request.Operation
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.TopicFullName)) {
		query["TopicFullName"] = request.TopicFullName
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("UpdateTopicConfig"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &UpdateTopicConfigResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

/**
 *
 * @param request UpdateTopicConfigRequest
 * @return UpdateTopicConfigResponse
 */
func (client *Client) UpdateTopicConfig(request *UpdateTopicConfigRequest) (_result *UpdateTopicConfigResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &UpdateTopicConfigResponse{}
	_body, _err := client.UpdateTopicConfigWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}

func (client *Client) WriteDevicesHotStorageDataWithOptions(request *WriteDevicesHotStorageDataRequest, runtime *util.RuntimeOptions) (_result *WriteDevicesHotStorageDataResponse, _err error) {
	_err = util.ValidateModel(request)
	if _err != nil {
		return _result, _err
	}
	query := map[string]interface{}{}
	if !tea.BoolValue(util.IsUnset(request.DeviceName)) {
		query["DeviceName"] = request.DeviceName
	}

	if !tea.BoolValue(util.IsUnset(request.IotId)) {
		query["IotId"] = request.IotId
	}

	if !tea.BoolValue(util.IsUnset(request.IotInstanceId)) {
		query["IotInstanceId"] = request.IotInstanceId
	}

	if !tea.BoolValue(util.IsUnset(request.Items)) {
		query["Items"] = request.Items
	}

	if !tea.BoolValue(util.IsUnset(request.ProductKey)) {
		query["ProductKey"] = request.ProductKey
	}

	if !tea.BoolValue(util.IsUnset(request.UserTopic)) {
		query["UserTopic"] = request.UserTopic
	}

	req := &openapi.OpenApiRequest{
		Query: openapiutil.Query(query),
	}
	params := &openapi.Params{
		Action:      tea.String("WriteDevicesHotStorageData"),
		Version:     tea.String("2018-01-20"),
		Protocol:    tea.String("HTTPS"),
		Pathname:    tea.String("/"),
		Method:      tea.String("POST"),
		AuthType:    tea.String("AK"),
		Style:       tea.String("RPC"),
		ReqBodyType: tea.String("formData"),
		BodyType:    tea.String("json"),
	}
	_result = &WriteDevicesHotStorageDataResponse{}
	_body, _err := client.CallApi(params, req, runtime)
	if _err != nil {
		return _result, _err
	}
	_err = tea.Convert(_body, &_result)
	return _result, _err
}

func (client *Client) WriteDevicesHotStorageData(request *WriteDevicesHotStorageDataRequest) (_result *WriteDevicesHotStorageDataResponse, _err error) {
	runtime := &util.RuntimeOptions{}
	_result = &WriteDevicesHotStorageDataResponse{}
	_body, _err := client.WriteDevicesHotStorageDataWithOptions(request, runtime)
	if _err != nil {
		return _result, _err
	}
	_result = _body
	return _result, _err
}
